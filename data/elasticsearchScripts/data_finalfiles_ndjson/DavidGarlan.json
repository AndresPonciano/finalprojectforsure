{"title": "A formal basis for architectural connection\n", "abstract": " As software systems become more complex, the overall system structure\u2014or software architecture\u2014becomes a central design problem.  An important step toward an engineering discipline of software is a formal basis for describing and analyzing these designs. In the article we present a formal approach to one aspect of architectural design: the interactions among components. The key idea is to define architectural connectors as explicit semantic entities. These are specified as a collection of protocols that characterize each of the participant roles in an interaction and how these roles interact. We illustrate how this scheme can be used to define a variety of common architectural connectors.  We further provide a formal semantics and show how this leads to a system in  which architectural compatibility can be checked in a way analogous to type-checking in programming languages.", "num_citations": "1966\n", "authors": ["621"]}
{"title": "Project aura: Toward distraction-free pervasive computing\n", "abstract": " The most precious resource in a computer system is no longer its processor, memory, disk, or network, but rather human attention. Aura aims to minimize distractions on a user's attention, creating an environment that adapts to the user's context and needs. Aura is specifically intended for pervasive computing environments involving wireless communication, wearable or handheld computers, and smart spaces. Human attention is an especially scarce resource in such environments, because the user is often preoccupied with walking, driving, or other real-world interactions. In addition, mobile computing poses difficult challenges such as intermittent and variable-bandwidth connectivity, concern for battery life, and the client resource constraints that weight and size considerations impose. To accomplish its ambitious goals, research in Aura spans every system level: from the hardware, through the operating system, to\u00a0\u2026", "num_citations": "1359\n", "authors": ["621"]}
{"title": "Acme: An architecture description interchange language\n", "abstract": " Numerous architectural description languages (ADLs) have been developed, each providing complementary capabilities for architectural development and analysis. Unfortunately, each ADL and supporting toolset operates in isolation, making it difficult to integrate those tools and share architectural descriptions. Acme is being developed as a joint effort of the software architecture research community as a common interchange format for architecture design tools. Acme provides a structural framework for characterizing architectures, together with annotation facilities for additional ADL-specific information. This scheme permits subsets of ADL tools to share architectural information that is jointly understood, while tolerating the presence of information that falls outside their common vocabulary. In this paper we describe Acme's key features, rationale, and technical innovations.", "num_citations": "1291\n", "authors": ["621"]}
{"title": "Acme: Architectural description of component-based systems\n", "abstract": " Over the past decade there has been considerable experimentation with the design of architecture description languages that can provide a formal basis for description and analysis of the architectures of component-based systems. As the field has matured there has emerged among the software architecture research community general consensus about many aspects of the foundations for architectural representation and analysis. One result has been the development of a generic architecture description language, called Acme, that can serve as a common representation for software architectures and that permits the integration of diverse collections of in-dependently developed architectural analysis tools. In this paper we describe the Acme language and tools, and our experience in using it to integrate architecture analysis tools and to describe component-based systems.", "num_citations": "943\n", "authors": ["621"]}
{"title": "Architectural mismatch or why it's hard to build systems out of existing parts\n", "abstract": " Many would argue that future breakthroughs in software productivity will depend on our ability to combine existing pieces of software to produce new applications. An important step towards this goal is the development of new techniques to detect and cope with mismatches in the assembled parts. Some problems of composition are due to low-level issues of interoperability, such as mismatches in programming languages or database schemas. However, in this paper we highlight a different, and in many ways more pervasive, class of problem: architectural mismatch. Specifically, we use our experience in building a family of software design environments from existing parts to illustrate a variety of types of mismatch that center around the assumptions a reusable part makes about the structure of the application in which is to appear. Based on this experience we show how an architectural view of the mismatch problem\u00a0\u2026", "num_citations": "830\n", "authors": ["621"]}
{"title": "Aura: an architectural framework for user mobility in ubiquitous computing environments\n", "abstract": " Ubiquitous computing poses a number of challenges for software architecture. One of the most important is the ability to design software systems that accommodate dynamically-changing resources. Resource variability arises naturally in a ubiquitous computing setting through user mobility (a user moves from one computing environment to another), and through the need to exploit time-varying resources in a given environment (such as wireless bandwidth). Traditional approaches to handling resource variability in applications attempt to address the problem by imposing uniformity on the environment. We argue that those approaches are inadequate, and describe an alternative architectural framework that is better matched to the needs of ubiquitous computing. A key feature of the architecture is that user tasks become first class entities. User proxies, or Auras, use models of user tasks to set up, monitor and\u00a0\u2026", "num_citations": "810\n", "authors": ["621"]}
{"title": "Architectural mismatch: Why reuse is so hard\n", "abstract": " Why isn't there more progress toward building systems from existing parts? One answer is that the assumptions of the parts about their intended environment are implicit and either don't match the actual environment or conflict with those of other parts. The authors explore these problems in the context of their own experience with a compositional approach.< >", "num_citations": "788\n", "authors": ["621"]}
{"title": "Context is key\n", "abstract": " Context is not simply the state of a predefined environment with a fixed set of interaction resources. It's part of a process of interacting with an ever-changing environment composed of reconfigurable, migratory, distributed, and multiscale resources.", "num_citations": "749\n", "authors": ["621"]}
{"title": "Formalizing architectural connection\n", "abstract": " As software systems become more complex the overall system structure - or software architecture - becomes a central design problem. An important step towards an engineering discipline of software is a formal basis for describing and analyzing these designs. We present a theory for one aspect of architectural description, the interactions between components. The key idea is to define architectural connectors as explicit semantic entities. These are specified as a collection of protocols that characterize each of the participant roles in an interaction and how these roles interact. We illustrate how this scheme can be used to define a variety of common architectural connectors. We provide a formal semantics and show how this lends to a sound deductive system in which architectural compatibility can be checked in a way analogous to type checking in programming languages.< >", "num_citations": "724\n", "authors": ["621"]}
{"title": "Software architecture: a roadmap\n", "abstract": " Over the past decade software architecture has received increasing attention as an important subfield of software engineering. During that time there has been considerable progress in developing the technological and methodological base for treating architectural design as an engineering discipline. However, much remains to be done to achieve that goal. Moreover, the changing face of technology raises a number of new challenges for software architecture. This paper examines some of the important trends of software architecture in research and practice, and speculates on the important emerging trends, challenges, and aspirations.", "num_citations": "641\n", "authors": ["621"]}
{"title": "Introduction to the special issue on software architecture\n", "abstract": " A critical aspect of the design for any large software system is its gross structure represented as a high-level organization of computational elements and interactions between those elements. Broadly speaking, this is the software architectural level of design [1],[2]. The structure of software has long been recognized as an important issue of concern (eg,[3],[4]). However, recently software architecture has begun to emerge as an explicit field of study for software engineering practitioners and researchers. Evidence of this trend is apparent in a large body of recent work in areas such as module interface languages, domain specific architectures, architectural description languages, design patterns and handbooks, formal underpinnings for architectural design, and architectural design environments. What exactly do we mean by the term\\software architecture?\" As one might expect of a field that has only recently emerged as an explicit focus for research and development, there is currently no universally-accepted definition. Moreover, if we look at the common uses of the term\\architecture\" in software, we find that it is used in quite di erent ways, often making it di cult to understand what aspect is being addressed. Among the various uses are (a) the architecture of a particular system, as in\\the architecture of this system consists of the following components,\"(b) an architectural style, as in\\this system adopts a client-server architecture,\" and (c) the general study of architecture, as in\\the papers in this journal are about architecture.\"", "num_citations": "636\n", "authors": ["621"]}
{"title": "Specifying and analyzing dynamic software architectures\n", "abstract": " A critical issue for complex component-based systems design is the modeling and analysis of architecture. One of the complicating factors in developing architectural models is accounting for systems whose architecture changes dynamically (during run time). This is because dynamic changes to architectural structure may interact in subtle ways with on-going computations of the system.             In this paper we argue that it is possible and valuable to provide a modeling approach that accounts for the interactions between architectural reconfiguration and non-reconfiguration system functionality, while maintaining a separation of concerns between these two aspects of a system. The key to the approach is to use a uniform notation and semantic base for both reconfiguration and steady-state behavior, while at the same time providing syntactic separation between the two. As we will show, this permits us to view\u00a0\u2026", "num_citations": "615\n", "authors": ["621"]}
{"title": "Exploiting style in architectural design environments\n", "abstract": " As the design of software architectures emerges as a discipline within software engineering, it will become increasingly important to support architectural description and analysis with tools and environments. In this paper we describe a system for developing architectural design environments that exploit architectural styles to guide software architects in producing specific systems. The primary contributions of this research are: (a) a generic object model for representing architectural designs; (b) the characterization of architectural styles as specializations of this object model; and (c) a toolkit for creating an open architectural design environment from a description of a specific architectural style. We use our experience in implementing these concepts to illustrate how style-oriented architectural design raises new challenges for software support environments.", "num_citations": "605\n", "authors": ["621"]}
{"title": "Formalizing style to understand descriptions of software architecture\n", "abstract": " The software architecture of most systems is usually described informally and diagrammatically by means of boxes and lines. In order for these descriptions to be meaningful, the diagrams are understood by interpreting the boxes and lines in specific, conventionalized ways. The informal, imprecise nature of these interpretations has a number of limitations. In this article we consider these conventionalized interpretations as architectural styles and provide a formal framework for their uniform definition. In addition to providing a template for precisely defining new architectural styles, this framework allows for analysis within and between different architectural styles.", "num_citations": "411\n", "authors": ["621"]}
{"title": "Architectural styles, design patterns, and objects\n", "abstract": " Architectural styles, object-oriented design and design patterns all hold promise as approaches that simplify software design and reuse by capturing and exploiting system design knowledge. This article explores the capabilities and roles of the various approaches, their strengths and their limitations.", "num_citations": "330\n", "authors": ["621"]}
{"title": "Using style to understand descriptions of software architecture\n", "abstract": " The software architecture of most systems is described informally and diagrammatically. In order for these descriptions to be meaningful at all, figures are understood by interpreting the boxes and lines in specific, conventionalized ways[5]. The imprecision of these interpretations has a number of limitations. In this paper we consider these conventionalized interpretations as architectural styles and provide a formal framework for their uniform definition. In addition to providing a template for precisely defining new architectural styles, this framework allows for the proof that the notational constraints on a style are sufficient to guarantee the meanings of all described systems and provides a unified semantic base through which different stylistic interpretations can be compared.", "num_citations": "309\n", "authors": ["621"]}
{"title": "Software architecture\n", "abstract": " As the size and complexity of software systems increase, the design, specification, and analysis of overall system structure becomes a critical issue. Structural issues include the organization of a system as a composition of components; global control structures, the protocols for communication, synchronization, and data access; the assignment of functionality to design elements; the composition of design elements; physical distribution; scaling and performance, and dimensions of evolution. This is the software architecture level of design.", "num_citations": "302\n", "authors": ["621"]}
{"title": "Formalizing design spaces: Implicit invocation mechanisms\n", "abstract": " An important goal of software engineering is to exploit commonalities in system design in order to reduce the complexity of building new systems, support large-scale reuse, and provide automated assistance for system development. A significant roadblock to accomplishing this goal is that common properties of systems are poorly understood. In this paper we argue that formal specification can help solve this problem. A formal definition of a design framework can identify the common properties of a family of systems and make clear the dimensions of specialization. New designs can then be built out of old ones in a principled way, at reduced cost to designers and implementors.             To illustrate these points, we present a formalization of a system integration technique called implicit invocation. We show how many previously unrelated systems can be viewed as instances of the same underlying framework\u00a0\u2026", "num_citations": "203\n", "authors": ["621"]}
{"title": "Stitch: A language for architecture-based self-adaptation\n", "abstract": " Requirements for high availability in computing systems today demand that systems be self-adaptive to maintain expected qualities-of-service in the presence of system faults, variable environmental conditions, and changing user requirements. Autonomic computing tackles the challenge of automating tasks that humans would otherwise have to perform to achieve this goal. However, existing approaches to autonomic computing lack the ability to capture routine human repair tasks in a way that takes into account the business context humans use in selecting an appropriate form of adaptation, while dealing with timing delays and uncertainties in outcome of repair actions. In this article, we present Stitch, a language for representing repair strategies within the context of an architecture-based self-adaptation framework. Stitch supports the explicit representation of repair decision trees together with the ability to express\u00a0\u2026", "num_citations": "199\n", "authors": ["621"]}
{"title": "A compositional formalization of connector wrappers\n", "abstract": " Increasingly systems are composed of parts: software components, and the interaction mechanisms (connectors) that enable them to communicate. When assembling systems front independently developed and potentially mismatched parts, wrappers may be used to overcome mismatch as well as to remedy extra-functional deficiencies. Unfortunately the current practice of wrapper creation and use is ad hoc, resulting in artifacts that are often hard to reuse or compose, and whose impact is difficult to analyze. What is needed is a more principled basis for creating, understanding, and applying wrappers. Focusing on the class of connector wrappers (wrappers that address issues related to communication and compatibility), we present a means of characterizing connector wrappers as protocol transformations, modularizing them, and reasoning about their properties. Examples are drawn from commonly practiced\u00a0\u2026", "num_citations": "162\n", "authors": ["621"]}
{"title": "Formal modeling and analysis of software architecture: Components, connectors, and events\n", "abstract": " Developing a good software architecture for a complex system is a critically important step for insuring that the system will satisfy its principal objectives. Unfortunately, today descriptions of software architecture are largely based on informal \u201cbox-and-line\u201d drawings that are often ambiguous, incomplete, inconsistent, and unanalyzable. This need not be the case. Over the past decade a number of researchers have developed formal languages and associated analysis tools for software architecture. In this paper I describe a number of the representative results from this body of work.", "num_citations": "161\n", "authors": ["621"]}
{"title": "Reconciling the needs of architectural description with object-modeling notations\n", "abstract": " Complex software systems require expressive notations for representing their software architectures. Two competing paths have emerged. One is to use a specialized notation for architecture, an architecture description language (ADL). The other is to adapt a general-purpose modeling notation, such as UML. The latter has a number of benefits, including familiarity to developers, close mapping to implementations, and commercial tool support. However, it remains an open question as to how best to use object-oriented notations for architectural description, and, indeed, whether they are sufficiently expressive, as currently defined. In this paper, we take a systematic look at these questions, examining the space of possible mappings from ADLs into UML. Specifically, we describe (a) the principal strategies for representing architectural structure in UML; (b) the benefits and limitations of each strategy; and (c) aspects of\u00a0\u2026", "num_citations": "156\n", "authors": ["621"]}
{"title": "Specifying dynamism in software architectures\n", "abstract": " A critical issue for complex component-based systems design is the modeling and analysis of architecture. One of the complicating factors in developing architectural models is accounting for systems whose architecture changes dynamically (during run time). This is because dynamic changes to architectural structure may interact in subtle ways with on-going computations of the system. In this paper we argue that it is possible and valuable to provide a modeling approach that accounts for the interactions between architectural reconfiguration and non-reconfiguration system functionality, while maintaining a separation of concerns between these two aspects of a system. The key to the approach is to use a uniform notation and semantic base for both reconfiguration and steady-state behavior, while at the same time providing syntactic separation between the two. As we will show, this permits us to view the architecture in terms of a set possible architectural snapshots, each with its own steady-state behavior. Transitions between these snapshots are accounted for by special reconfiguration-triggering events.", "num_citations": "155\n", "authors": ["621"]}
{"title": "Model checking publish-subscribe systems\n", "abstract": " While publish-subscribe systems have good engineering properties, they are difficult to reason about and to test. Model checking such systems is an attractive alternative. However, in practice coming up with an appropriate state model for a pub-sub system can be a difficult and error-prone task. In this paper we address this problem by describing a generic pub-sub model checking framework. The key feature of this framework is a reusable, parameterized state machine model that captures pub-sub run-time event management and dispatch policy. Generation of models for specific pub-sub systems is then handled by a translation tool that accepts as input a set of pub-sub component descriptions together with a set of pub-sub properties, and maps them into the framework where they can be checked using off-the-shelf model checking tools.", "num_citations": "154\n", "authors": ["621"]}
{"title": "Software engineering in an uncertain world\n", "abstract": " In this paper, we argue that the reality of today's software systems requires us to consider uncertainty as a first-class concern in the design, implementation, and deployment of those systems. We further argue that this induces a paradigm shift, and a number of research challenges that must be addressed.", "num_citations": "148\n", "authors": ["621"]}
{"title": "Task-driven computing\n", "abstract": " We are moving towards a world of pervasive computing in which users can access and manipulate information from anywhere at anytime. Computing devices and networks are becoming ubiquitous. In this new world, computing will no longer be tethered to desktops users will become increasingly mobile. As users move across environments, they will have access to a dynamic range of computing devices and software services. They will want to use the resources to perform computing tasks. Todays computing infrastructure does not support this model of computing very well because computers interact with users in terms of low level abstractions applications and individual devices. Today, if a mobile user wants to use the computing resources of a new environment, he has to manually figure out how to perform a computing task using local resources andor to migrate his computing context from another environment. Such manual operation is unacceptable in a pervasive computing world because it does not scale with the increasing amount of software services, user mobility and resource dynamism. It also demands that users spend too much time on non-task related configuration activities. This technical report describes an approach called task-driven computing that can be used to solve this problem. The approach is based on the insight that with appropriate system support it is possible to let users interact with their computing environments in terms of high level tasks and free them from low level configuration activities.Descriptors:", "num_citations": "142\n", "authors": ["621"]}
{"title": "Architecture-based performance analysis\n", "abstract": " A software architecture should expose important system properties for consideration and analysis. Performancerelated properties are frequently of interest in determining the acceptability of a given software design. In this paper we show how queueing network modeling can be adapted to support performance analysis of software architectures. We also describe a tool for transforming a software architecture in a particular style into a queueing network and analyzing its performance.", "num_citations": "142\n", "authors": ["621"]}
{"title": "Program comprehension as fact finding\n", "abstract": " Little is known about how developers think about design during code modification tasks or how experienced developers' design knowledge helps them work more effectively. We performed a lab study in which thirteen developers worked for 3 hours under-standing the design of a 54 KLOC open source application. Par-ticipants had from 0 to 10.5 years of industry experience and were grouped into three\" experts\" and ten\" novices.\" We observed that participants spent their time seeking, learning, critiquing, explain-ing, proposing, and implementing facts about the code such as\" getFoldLevel has effects\". These facts served numerous roles, such as suggesting changes, constraining changes, and predicting the amount of additional investigation necessary to make a change. Differences between experts and novices included that the experts explained the root cause of the design problem and made changes to\u00a0\u2026", "num_citations": "121\n", "authors": ["621"]}
{"title": "Views for tools in integrated environments\n", "abstract": " This paper addresses the problem of building tools for integrated programming environments. Integrated environments have the desirable property that the tools in it can share a database of common structures. But they have the undesirable property that these tools are hard to build because typically a single representation of the database must serve all tools. The solution proposed in this work allows tools to maintain appropriate representations or \"views\" of the objects they manipulate while retaining the benefits of shared access to common structures. We illustrate the approach with two examples of tools for an environment for programming-in-the-large, and outline current work in progress on efficient implementations of these ideas.", "num_citations": "121\n", "authors": ["621"]}
{"title": "Formal modeling and analysis of the HLA component integration standard\n", "abstract": " An increasingly important trend in the engineering of complex systems is the design of component integration standards. Such standards define rules of interaction and shared communication infrastructure that permit composition of systems out of independently-developed parts. A problem with these standards is that it is often difficult to understand exactly what they require and provide, and to analyze them in order to understand their deeper properties. In this paper we use our experience in modeling the High Level Architecture (HLA) for Distributed Simulation to show how one can capture the structured protocol inherent in an integration standard as a formal architectural model that can be analyzed to detect anomalies, race conditions, and deadlocks.", "num_citations": "113\n", "authors": ["621"]}
{"title": "Architectural mismatch: Why reuse is still so hard\n", "abstract": " In this article, David Garlan, Robert Allen, and John Ockerbloom reflect on the state of architectural mismatch, a term they coined in their 1995 IEEE Software article, \"Architectural Mismatch: Why Reuse Is So Hard.\" Although the nature of software systems has changed dramatically since the earlier article was published, the challenge of architectural mismatch remains an important concern for the software engineering field.", "num_citations": "111\n", "authors": ["621"]}
{"title": "A compositional approach for constructing connectors\n", "abstract": " Increasingly, systems are composed from independently developed parts, and mechanisms that allow those parts to interact (connectors). In many situations, specialized forms of interaction are needed to bridge component mismatches or to achieve extra-functional properties (e.g., security, performance, reliability), making the design and implementation of these interaction mechanisms a critical issue. Unfortunately, system developers have few options: they must live with available, but often inadequate, generic support for interaction (such as RPC), or they must handcraft specialized mechanisms at great cost. The authors describe a partial solution to this problem, whereby interaction mechanisms are constructed compositionally. Specifically, we describe a set of operators that can transform generic communication mechanisms (such as RPC and publish-subscribe) to incrementally add new capabilities. We show\u00a0\u2026", "num_citations": "111\n", "authors": ["621"]}
{"title": "Formal connectors\n", "abstract": " As software systems become more complex the overall system structure-or software architecture-becomes a central design problem. An important step towards an engineering discipline of software is a formal basis for describing and analyzing these designs. In this paper we present a theory for one aspect of architectural description the interactions between components. The key idea is to define architectural connectors as explicit semantic entities. These are specified as a collection of protocols that characterize each of the participant roles in an interaction and how these roles interact. We illustrate how this scheme can be used to define a variety of common architectural connectors. We further provide a formal semantics and show how this leads to a system in which architectural compatibility can be checked in a way analogous to type checking in programming languages.Descriptors:", "num_citations": "111\n", "authors": ["621"]}
{"title": "Research directions in software architecture\n", "abstract": " A critical aspect of the design for any large software system is its high-level organization of computational elements and interactions between those elements. Broadly speaking, this is the software architectural level of design[Garlan and Shaw 1993; Perry and Wolf 1992]. The structure of software has long been recognized as an important issue(eg,[Dijkstra 1968; Parnas et al. 1985]) and recently software architecture has begun to emerge as an explicit field of study for software engineering practitioners and researchers. There is a large body of recent work in areas such as module interface languages, domain-specific architectures, architectural description languages, design patterns and handbooks, formal underpinnings for architectural design, and architectural design environments[Garlan 1995; Garlan and Perry 1995].Although there is increasing agreement about the issues addressed by architectural design\u00a0\u2026", "num_citations": "109\n", "authors": ["621"]}
{"title": "Beyond definition/use: Architectural interconnection\n", "abstract": " Large software systems require decompositional mechanisms in order to make them tractable. Traditionally, MILs and IDLs have played this role by providing notations based on definition/use bindings. In this paper we argue that current MIL/IDLs based on definition/use have some serious drawbacks. A significant problem is that they fail to distinguish between \"implementation\" and \"interaction\" relationships between modules. We propose an alternative model in which components interact along welldefined lines of communication -- or connectors. Connectors are defined as protocols that capture the expected patterns of communication between modules. We show how this leads to a scheme that is much more expressive for architectural relationships, that allows the formal definition of module interaction, and that supports its own form of automated checks and formal reasoning.", "num_citations": "109\n", "authors": ["621"]}
{"title": "Reconciling the needs of architectural description with object-modeling notations\n", "abstract": " Complex software systems require expressive notations for representing their software architectures. Two competing paths have emerged. One is to use a specialized notation for architecture \u2014 or architecture description language (ADL). The other is to adapt a general-purpose modeling notation, such as UML. The latter has a number of benefits, including familiarity to developers, close mapping to implementations, and commercial tool support. However, it remains an open question as to how best to use object-oriented notations for architectural description, and, indeed, whether they are sufficiently expressive, as currently defined. In this paper we take a systematic look at these questions, examining the space of possible mappings from ADLs into object notations. Specifically, we describe (a) the principle strategies for representing architectural structure in UML; (b) the benefits and limitations of each\u00a0\u2026", "num_citations": "107\n", "authors": ["621"]}
{"title": "Gnome: An introductory programming environment based on a family of structure editors\n", "abstract": " Structure editors have frequently been used as powerful and unifying interfaces for programming environments in computer science research settings. Few, however, have found their way into common use. GNOME is an attempt to channel the experience gained in the use of structure editing for software development environment research of the Gandalf Project into a practical novice programming environment. Based on a family of structure editors, it is currently being used to teach programming to undergraduates at Carnegie-Mellon University. This paper describes the GNOME environment, recounts lessons learned in adapting structure editors to novice programmers, and discusses its effectiveness as a teaching environment.", "num_citations": "100\n", "authors": ["621"]}
{"title": "Style-based reuse for software architectures\n", "abstract": " Although numerous mechanisms for promoting software reuse have been proposed and implemented over the years, most have focused on the reuse of implementation code. There is much conjecture and some empirical evidence, however, that the most effective forms of reuse are generally found at more abstract levels of software design. We discuss software reuse at the architectural level of design. Specifically, we argue that the concept of \"architectural style\" is useful for supporting the classification, storage, and retrieval of reusable architectural design elements. We briefly describe the Aesop system's Software Shelf (D. Garlan et al., 1994), a tool that assists designers in selecting appropriate design elements and patterns based on stylistic information and design constraints.", "num_citations": "95\n", "authors": ["621"]}
{"title": "The aura software architecture: an infrastructure for ubiquitous computing\n", "abstract": " Computing environments of the future should enable mobile users to take full advantage of the computing capabilities available at each location, while allowing them to focus on their real tasks, rather than being distracted by dealing with the configuration and reconfiguration of computer systems to support those tasks. The Aura infrastructure performs automatic configuration and reconfiguration of Ubicomp environments, according to the users task and intent. This report describes the software architecture of the Aura infrastructure, and discusses the underlying rational. It describes the architecture from a layered perspective, detailing the partition of responsibility and shared assumptions, as well as from a component-connector perspective, detailing the protocols of interaction between the components APIs and sequencing. The contents and format of the exchanged messages is extensively discussed, as well as the details pertaining service interconnection and decomposition. This report proposes a utility-based approach for modeling user preferences, and details how such models can be exploited for both coarse-grain automatic reconfiguration, and fine-grain adaptation to resource change.Descriptors:", "num_citations": "94\n", "authors": ["621"]}
{"title": "Agents of change: Educating software engineering leaders\n", "abstract": " Most professional degree programs for software engineering focus on solving today's problems with today's technologies. Carnegie Mellon's Master of Software Engineering program takes a different approach, preparing engineers to work with new science and technology throughout their careers and helping them become agents of change in the industry. The approach aims to cultivate future leaders in software engineering. It combines a long-term, mentored software development project with an unusual core curriculum that stresses broad-based models and problem-solving skills.", "num_citations": "94\n", "authors": ["621"]}
{"title": "The role of software architecture in requirements engineering\n", "abstract": " The role of software architecture (which reflects high-level implementation constraints) in requirements engineering is clarified by providing perspectives on relevant issues, including the following: is requirements engineering merely a front end to the software development process that is concerned only with problem definition? Is software architecture an application-specific, high-level design of a system (for example, \"an object-oriented system with a specified object hierarchy\")? What is the relationship between the problem definition and the solution structure? What is the relationship between the roles of requirements engineer, software architect, and application domain specialist?.< >", "num_citations": "93\n", "authors": ["621"]}
{"title": "Low-cost, adaptable tool integration policies for integrated environments\n", "abstract": " An important requirement for successful integrated programming environments is support for implicit tool invocation; rather than force a user to explicitly invoke each tool, mechanisms in the environment can take responsibility for guaranteeing that the right tools are invoked at the right times. However, these mechanisms typically intertwine policies of when and how the tools are invoked, with what the tools do when they are invoked. Consequently, adapting the environment to achieve different tool interactions is often difficult without modifying the code that implements the environment or the tools. In this paper we describe a simple, low-cost mechanism that solves this problem. Specifically, we show how tool integration based on selective broadcast can be adapted to allow dynamically configurable policies of tool interaction. We describe an implementation of these mechanisms, and show how it supports multiple\u00a0\u2026", "num_citations": "92\n", "authors": ["621"]}
{"title": "The Wright architectural specification language\n", "abstract": " An important step towards establishing an engineering discipline of software is to provide a formal basis for describing and analyzing software architectures. The Wright Architectural Speci cation Language was developed for this purpose. The key novel features of Wright are its support for (a) formal speci cation of new architectural connection types,(b) formal de nition of architectural styles, and (c) rules for checking the consistency and completeness of architectural designs.This research was sponsored by the National Science Foundation under Grant Number CCR-9357792, by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the o cial policies, either expressed or implied, of Wright Laboratory, or the US Government. The US Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation thereon.", "num_citations": "89\n", "authors": ["621"]}
{"title": "Analyzing architectural styles with alloy\n", "abstract": " The backbone of many architectures is an architectural style that provides a domain-specific design vocabulary and set of constraints on how that vocabulary can be used. Hence, designing a sound and appropriate architectural style becomes an important and intellectually challenging activity. Unfortunately, although there are numerous tools to help in the analysis of individual architectures, relatively less work has been done on tools to help the style designer. In this paper we show how to map an architectural style, expressed formally in an architectural description language, into a relational model that can be automatically checked for properties such as whether a style is consistent, whether a style satisfies some predicate over the architectural structure, whether two styles are compatible for composition, and whether one style refines another.", "num_citations": "85\n", "authors": ["621"]}
{"title": "What is style\n", "abstract": " A central aspect of architectural design is the use of recurring organizational patterns and idioms| or architectural styles GS93, PW92, MG92, GHJV94]. Examples include generic system organizations such as those based on data ow or layers, as well as speci c organizational structures such as the classical decomposition of a compiler, the OSI communication stack, and the MVC user interface paradigm.The principled use of architectural styles has a number of practical bene ts. First, it promotes design reuse: routine solutions with well-understood properties can be reapplied to new problems with con dence. Second, it can lead to signi cant code reuse: often the invariant aspects of an architectural style lend themselves to shared implementations. Third, it is easier for others to understand a system's organization if conventionalized structures are used. For example, even without giving details, characterization of a system as a\\client-server\" organization immediately conveys a strong image of the kinds of pieces and how they t together. Fourth, use of standardized styles supports interoperability. Examples include CORBA object-oriented architecture Cor91], and event-based tool integration Ger89]. Fifth, by constraining the design space, an architectural style often permits specialized, style-speci c analyses. For example, it is possible to analyze pipelter systems for schedulability, throughput, latency, and deadlock-freedom. Such analyses might not be meaningful for an arbitrary, ad hoc architecture {or even one constructed in a di erent style. Sixth, it is usually possible to provide style-speci c visualizations: this makes it possible to provide graphical\u00a0\u2026", "num_citations": "83\n", "authors": ["621"]}
{"title": "Software architecture: a travelogue\n", "abstract": " Over the past two and a half decades software architecture has emerged as an important subfield of software engineering. During that time there has been considerable progress in developing the technological and methodological base for treating architectural design as an engineering discipline. However, much still remains to be done to achieve that. Moreover, the changing face of technology raises a number of challenges for software architecture. This travelogue recounts the history of the field, its current state of practice and research, and speculates on some of the important emerging trends, challenges, and aspirations.", "num_citations": "79\n", "authors": ["621"]}
{"title": "Analyzing architectural styles\n", "abstract": " The backbone of most software architectures and component integration frameworks is one or more architectural styles that provide a domain-specific design vocabulary and a set of constraints on how that vocabulary is used. Today\u2019s architectural styles are increasingly complex, involving rich vocabularies and numerous constraints. Hence, designing a sound and appropriate style becomes an intellectually challenging activity. Unfortunately, although there are numerous tools to help in the analysis of architectures for individual systems, relatively less work has been done on tools to help in the design of architectural styles. In this paper we address this gap by showing how to map an architectural style, expressed formally in an architectural description language, into a relational model that can then be checked for properties, such as whether a style is consistent, whether a style satisfies some predicates over its\u00a0\u2026", "num_citations": "77\n", "authors": ["621"]}
{"title": "Formal specifications as reusable frameworks\n", "abstract": " We use our experience in applying formal methods to the development of electronic instrumentation systems to argue the value of developing formal, domain-specific models that serve as reusable frameworks for a family of software products. To illustrate what we mean by \u201cframework\u201d we present a non-trivial specification for a family of instruments, and show how certain properties of that specification lead to its potential for reusability. Finally, we outline the important research issues that are raised by this approach. In particular, we examine the suitability of existing formal specification notations for explicitly characterizing and instantiating such frameworks.", "num_citations": "75\n", "authors": ["621"]}
{"title": "Reasoning about human participation in self-adaptive systems\n", "abstract": " Self-adaptive systems overcome many of the limitations of human supervision in complex software-intensive systems by endowing them with the ability to automatically adapt their structure and behavior in the presence of runtime changes. However, adaptation in some classes of systems (e.g., Safety-critical) can benefit by receiving information from humans (e.g., Acting as sophisticated sensors, decision-makers), or by involving them as system-level effectors to execute adaptations (e.g., When automation is not possible, or as a fallback mechanism). However, human participants are influenced by factors external to the system (e.g., Training level, fatigue) that affect the likelihood of success when they perform a task, its duration, or even if they are willing to perform it in the first place. Without careful consideration of these factors, it is unclear how to decide when to involve humans in adaptation, and in which way. In\u00a0\u2026", "num_citations": "74\n", "authors": ["621"]}
{"title": "Formal modeling of the enterprise javabeans\u2122 component integration framework\n", "abstract": " An emerging trend in the engineering of complex systems is the use of component integration frameworks. Such a framework prescribes an architectural design that permits flexible composition of thirdparty components into applications. A good example is Sun Microsystems\u2019 Enterprise JavaBeans\u2122 (EJB) framework, which supports object- oriented, distributed, enterprise-level applications, such as account management systems. One problem with frameworks like EJB is that they are documented informally, making it difficult to understand precisely what is provided by the framework, and what is required to use it. We believe formal specification can help, and in this paper show how a formal architectural description language can be used to describe and provide insight into such frameworks.", "num_citations": "71\n", "authors": ["621"]}
{"title": "Design fragments make using frameworks easier\n", "abstract": " Object oriented frameworks impose additional burdens on programmers that libraries did not, such as requiring the programmer to understand the method callback sequence, respecting behavior constraints within these methods, and devising solutions within a constrained solution space. To overcome these burdens, we express the repeated patterns of engagement with the framework as a design fragment. We analyzed the 20 demo applets provided by Sun and created a representative catalog of design fragments of conventional best practice. By evaluating 36 applets pulled from the internet we show that these design fragments are common, many applets copied the structure of the Sun demos, and that creation of a catalog of design fragments is practical. Design fragments give programmers immediate benefit through tool-based conformance assurance and long-term benefit through expression of design intent.", "num_citations": "69\n", "authors": ["621"]}
{"title": "A case study in architectural modeling: the AEGIS system\n", "abstract": " Software architecture is receiving increasingly attention as a critical design level for software systems. However the current practice of architectural description is largely informal and ad hoc, with the consequence that architectural documents serve as a poor communication mechanism, are difficult to analyze, and may have very little relationship to the implemented system. In an attempt to address these problems several researchers have experimented with formalisms for architectural specification and modelling. One such formalism is the WRIGHT specification language. In this paper, we show how WRIGHT can be used to provide insight into an architectural design by modelling a prototype implementation of part of the AEGIS Weapons System (AWS).", "num_citations": "64\n", "authors": ["621"]}
{"title": "Higher order connectors\n", "abstract": " A critical issue for architectural design is the nature of the glue, or connectors, with which a system's parts are combined. Thus an important first step toward improving our ability to compose parts is to make to make connectors explicit semantic enties, where they can be documented, analyzed, and (sometimes) used to generate code. A number of notations for software architecture do precisely this. However, a key second step is to understand operations over connectors. In principle, such operations would permit one to produce new connectors out of old ones, adapt existing connectors to new contexts of use, and factor out common properties of connectors so they can be reused. In this paper we argue that the use of \"higher order connectors\" is one way to achieve this goal.", "num_citations": "63\n", "authors": ["621"]}
{"title": "Experience with a course on architectures for software systems\n", "abstract": " As software systems grow in size and complexity their design problem extends beyond algorithms and data structures to issues of system design. This area receives little or no treatment in existing computer science curricula. Although courses about specific systems are usually available, there is no systematic treatment of the organizations used to assemble components into systems. These issues \u2014 the software architecture level of software design \u2014 are the subject of a new course that we taught for the first time in Spring 1992. This paper describes the motivation for the course, the content and structure of the current version, and our plans for improving the next version.", "num_citations": "63\n", "authors": ["621"]}
{"title": "Software architecture: Practice, potential, and pitfalls\n", "abstract": " Whatever the long-term impact of software architecture may turn out to be, an appropriate starting point is a concrete appraisal of the current state of the practice in the use of software architecture. It is the purpose of the article to take a step in this direction. It provides concrete examples of what is now possible when architectural principles are applied to industrial problems in systematic ways, considers the potential impact of software architecture over the next few years, and suggests steps that should be taken to bring this about.< >", "num_citations": "61\n", "authors": ["621"]}
{"title": "Style-based refinement for software architecture\n", "abstract": " A question that frequently arises for architectural design is \u2018When can I implement a design in style S1 using a design in style Sz.\u201c\u2019In this paper I propose a technique for structuring a solution to this kind of problem using the idea of substyles. This technique leads to a two-step process in which first, useful subsets of a family of architectures are identified, and second, refinement rules specific to these subsets are established. I will argue that this technique, in combination with an unconventional interpretation of refinement, clarifies how engineers actually carry out architectural refinement and provides a formal framework for establishing the correctness of those methods.", "num_citations": "58\n", "authors": ["621"]}
{"title": "Stochastic game analysis and latency awareness for proactive self-adaptation\n", "abstract": " Although different approaches to decision-making in self-adaptive systems have shown their effectiveness in the past by factoring in predictions about the system and its environment (eg, resource availability), no proposal considers the latency associated with the execution of tactics upon the target system. However, dierent adaptation tactics can take different amounts of time until their effects can be observed. In reactive adaptation, ignoring adaptation tactic latency can lead to suboptimal adaptation decisions (eg, activating a server that takes more time to boot than the transient spike in traffic that triggered its activation). In proactive adaptation, taking adaptation latency into account is necessary to get the system into the desired state to deal with an upcoming situation. In this paper, we introduce a formal analysis technique based on model checking of stochastic multiplayer games (SMGs) that enables us to quantify\u00a0\u2026", "num_citations": "55\n", "authors": ["621"]}
{"title": "An introduction to the Aesop system\n", "abstract": " As the design of software architectures emerges as a discipline within software engineering, it becomes increasingly important to support architectural description and analysis with tools and environments. This paper provides a brief introduction to Aesop, a set of tools for developing architectural design environments that exploit architectural styles to guide software architects in producing specific systems.", "num_citations": "55\n", "authors": ["621"]}
{"title": "Adding implicit invocation to traditional programming languages\n", "abstract": " Implicit invocation based on event broadcasting is an increasingly important technique for integrating systems. The authors broaden the class of systems that can benefit from this approach by showing how to augment general-purpose programming languages with facilities for implicit invocation. They illustrate the approach in the context of the Ada language. Attempts to add implicit invocation to standard languages raise a number of design decisions that can have a significant impact on the properties of the mechanism and on its usability. These design considerations are highlighted so that any similar attempt to add implicit invocation to a strongly-typed, procedure-oriented programming language can benefit from this work.< >", "num_citations": "52\n", "authors": ["621"]}
{"title": "Model checking implicit-invocation systems\n", "abstract": " While implicit invocation (publish-subscribe) systems have good engineering properties, they are difficult to reason about and to test. Model checking such systems is an attractive alternative. However, it is not clear what kinds of state models are best suited for this. We propose a structural approach, which factors the model checking problem into two parts: behavior specific to a particular implicit invocation system, and reusable run-time infrastructure that handles event-based communication and delivery policies. The reusable portion is itself structured so that alternative run-time mechanisms may be experimented with.", "num_citations": "51\n", "authors": ["621"]}
{"title": "Handling uncertainty in autonomic systems\n", "abstract": " Autonomic, or self-adaptive, systems are increasingly important. One of the most prevalent techniques is to adopt a control systems view of the solution: adding a runtime, separate control unit that monitors and adapts the system under consideration. A problem with this paradigm for system engineering is that the control and the system are loosely coupled, introducing a variety of sources of uncertainty. In this paper we describe three specific sources of uncertainty, and briefly explain how we address those in the Rainbow Project.", "num_citations": "49\n", "authors": ["621"]}
{"title": "Bridging the HLA: Problems and solutions\n", "abstract": " The High-Level Architecture (HLA) provides a common architecture for distributed modeling and simulation. In its original form, HLA allows a number of simulations to be joined together into a federation using a single run time infrastructure. Recently there has been interest in joining multiple federations together using a mediating unit, called an HLA \"bridge.\" This paper presents the results of an in-depth study of the feasibility of an HLA bridge in the context of the current HLA interface specification. Problems and solutions are discussed and illustrated using particular HLA services.", "num_citations": "46\n", "authors": ["621"]}
{"title": "A structural approach to the maintenance of structure-oriented environments\n", "abstract": " A serious problem for programming environments and operating systems is that existing software becomes invalid when the environment or operating system is replaced by a new release. Unfortunately, there has been no systematic treatment of the problem; current approaches are manual, ad hoc, and time consuming both for implementers of programs and for their users. In this paper we present a new approach. Focusing on a solution to the problems for structure-oriented environments, we show how automatic converters can be generated in terms of an implementor's changes to formal descriptions of these environments.", "num_citations": "41\n", "authors": ["621"]}
{"title": "Hybrid planning for decision making in self-adaptive systems\n", "abstract": " Run-time generation of adaptation plans is a powerful mechanism that helps a self-adaptive system to meet its goals in a dynamically changing environment. In the past, researchers have demonstrated successful use of various automated planning techniques to generate adaptation plans at run time. However, for a planning technique, there is often a trade-off between timeliness and optimality of the solution. For some self-adaptive systems, ideally, one would like to have a planning approach that is both quick and finds an optimal adaptation plan. To find the right balance between these conflicting requirements, this paper introduces a hybrid planning approach that combines more than one planner to obtain the benefits of each. In this paper, to instantiate a hybrid planner we combine deterministic planning with Markov Decision Process (MDP) planning to obtain the best of both worlds: deterministic planning\u00a0\u2026", "num_citations": "39\n", "authors": ["621"]}
{"title": "Mapping architectural concepts to uml-rt\n", "abstract": " Complex software systems require expressive notations for representing their software architectures. Two competing paths have emerged, one using a specialized notation for architecture--or architecture description language (ADL), the other using notations applied generally throughout design, such as UML. The latter has a number of benefits, including familiarity to developers, close mappings to implementations, and commercial tool support. However, it remains an open question how best to use object-oriented notations for architectural description and whether they are sufficiently expressive as currently defined. In this paper, we present a mapping between Acme, a notation designed for expressing architectures, and the UML Real-Time Profile--an object-oriented design notation. Specifically, we describe (a) how to map Acme descriptions to descriptions in the UML Real-Time Profile, and (b) the places where this mapping breaks down.", "num_citations": "38\n", "authors": ["621"]}
{"title": "Coordination Languages and Models Second International Conference COORDINATION'97 Berlin, Germany, September 1\u20133, 1997 Proceedings\n", "abstract": " The 22 revised full papers and 6 posters presented in the book were carefully reviewed and selected from a total of 69 submissions. Also included are three invited papers. The papers are devoted to an emerging class of languages and models, which have been variously termed coordination languages, configuration languages, and architectural description languages. These formalisms provide a clean separation between software components and their interaction in the overall software organization, which is particularly important for large-scale applications and open systems.", "num_citations": "37\n", "authors": ["621"]}
{"title": "Contract-based integration of cyber-physical analyses\n", "abstract": " Developing cyber-physical systems involves multiple engineering domains, e.g., timing, logical correctness, thermal resilience, and mechanical stress. In today's industrial practice, these domains rely on multiple analyses to obtain and verify critical system properties. Domain differences make the analyses abstract away interactions among themselves, potentially invalidating the results. Specifically, one challenge is to ensure that an analysis is never applied to a model that violates the assumptions of the analysis. Since such violation can originate from the updating of the model by another analysis, analyses must be executed in the correct order. Another challenge is to apply diverse analyses soundly and scalably over models of realistic complexity. To address these challenges, we develop an analysis integration approach that uses contracts to specify dependencies between analyses, determine their correct\u00a0\u2026", "num_citations": "35\n", "authors": ["621"]}
{"title": "Automated planning for software architecture evolution\n", "abstract": " In previous research, we have developed a theoretical framework to help software architects make better decisions when planning software evolution. Our approach is based on representation and analysis of candidate evolution paths-sequences of transitional architectures leading from the current system to a desired target architecture. One problem with this kind of approach is that it imposes a heavy burden on the software architect, who must explicitly define and model these candidate paths. In this paper, we show how automated planning techniques can be used to support automatic generation of evolution paths, relieving this burden on the architect. We illustrate our approach by applying it to a data migration scenario, showing how this architecture evolution problem can be translated into a planning problem and solved using existing automated planning tools.", "num_citations": "34\n", "authors": ["621"]}
{"title": "First international workshop on architectures for software systems workshop summary\n", "abstract": " As systems become more complex, the high-level organization of the overall system---the software architecture---becomes a critical aspect of design. Architectural concerns include organization of a system as a composition of components; global control structures; protocols for communication, synchronization, and data access; assignment of functionality to design elements; physical distribution; scaling and performance; dimensions of evolution; and selection among design alternatives.Recently, software architecture has begun to emerge as an important field of study for software engineering practitioners and researchers. Architectural issues are being addressed by work in areas such as module interface languages, domain-specific architectures, software reuse, codification of organizational patterns for software, architectural description languages, formal underpinnings for architectural design, and architectural\u00a0\u2026", "num_citations": "32\n", "authors": ["621"]}
{"title": "Software architecture: perspectives on an emerging discipline\n", "abstract": " KEY BENEFIT: Good software developers often adopt one or several architectural patterns as strategies for system organization. But, although they use these patterns purposefully, they often use them informally and nearly unconsciously. This book organizes this substantial emerging\" folklore\" of system design--with its rich language of system description--and closes the gap between the useful abstractions (constructs and patterns) of system design and the current models, notations and tools. It identifies useful patterns clearly, gives examples, compares them, and evaluates their utility in various settings--allowing readers to develop a repertoire of useful techniques that goes beyond the single-minded current fads.KEY TOPICS: Examines the ways in which architectural issues can impact software design; shows how to design new systems in principled ways using well-understood architectural paradigms\u00a0\u2026", "num_citations": "31\n", "authors": ["621"]}
{"title": "Transformgen: automating the maintenance of structure-oriented environments\n", "abstract": " A serious problem for programs that use persistent data is that information created and maintained by the program becomes invalid if the persistent types used in the program are modified in a new release. Unfortunately, there has been little systematic treatment of the problem; current approaches are manual, ad hoc, and time consuming both for programmers and users. In this article we present a new approach. Focusing on the special case of managing abstract syntax trees in structure-oriented environments, we show how automatic transformers can be generated in terms of an implementor's changes to the grammar of these environments.", "num_citations": "31\n", "authors": ["621"]}
{"title": "Programming Environments based on structure editing: The Gnome approach\n", "abstract": " The use of integrated programming environments based on structure editing is an emerging technology that has now reached the stage of being both demonstrably useful and readily implementable. We have outlined some of the salient aspects of our work in developing the GNOME and MacGNOME, programming environments and suggested paths of implementation that seem to be worth traveling. A predominant theme in all of this has been the need to separate policy from mechanism. While the choice of user interface policies will probably differ widely from those we have made here, the mechanisms that we have sketched will nonetheless be applicable to future environments.", "num_citations": "31\n", "authors": ["621"]}
{"title": "Formally specifying electronic instruments\n", "abstract": " This paper shows how formal specification techniques can be beneficially applied in the develop ment of electronic instrumentation. As an example of our approach we present a specification of a simple electronic instrument, written in the Z specification language. We argue that such specifications can be used to gain insight into software/hardware systems and to clarify the resulting design. A consequence is that formal specifications can assume a pivotal role in system design as non-executable prototypes and lead to a cost-effect application of formal techniq, ues in industrial settings.", "num_citations": "30\n", "authors": ["621"]}
{"title": "The role of formal reusable frameworks\n", "abstract": " We use our experience in applying formal methods to large-scale industrial problems to argue (a) the practical importance of developing formal reusable frameworks, and (b) th e need for further research into techniques for defining and instantiating these frameworks.", "num_citations": "29\n", "authors": ["621"]}
{"title": "A practical method for documenting software architectures\n", "abstract": " A practical approach for documenting software architectures is presented. The approach is based on the well-known architectural concept of views, and holds that documentation consists of documenting the relevant views and then documenting the information that applies to more than one view. Views can be usefully grouped into viewtypes, corresponding to the three broad ways an architect must think about a system: as a set of implementation units, as a set of runtime elements interacting to carry out the system\u2019s work, and as a set of elements existing in and relating to external structures in its environment. A simple three-step procedure for choosing the relevant views to document is given, and applied to the problem of documentation for a large, complex NASA system.", "num_citations": "27\n", "authors": ["621"]}
{"title": "A transformational approach to generating application-specific environments\n", "abstract": " Current software development environments tend to lie at opposite ends of a spectrum: at one extreme are specialized application generators; at the other are general-purpose programming environments. The former provide strong support for system development and reuse, but are costly to build and available only for limited domains. The latter provide weak support, but are generally available and universally applicable.", "num_citations": "27\n", "authors": ["621"]}
{"title": "A feasibility study of the HLA bridge\n", "abstract": " The High-Level Architecture HLA provides a common architecture for distributed modeling and simulation. In its original form the HLA allows a number of simulations to be joined together into a federation using a single run time infrastructure. Recently there has been an interest in joining multiple such federations together using a mediating unit, called an HLA bridge. This document presents an in-depth study of the feasibility of an HLA bridge in the context of the current HLA interface specification. The results are summarized on two levels. First, we identify general classes of problems and solutions. Second, we provide a detailed discussion of the desired behavior of selected service protocols in the presence of a bridge federate.Descriptors:", "num_citations": "26\n", "authors": ["621"]}
{"title": "Software architecture and object-oriented systems\n", "abstract": " Over the past decade software architecture has emerged as an important subfield of software engineering. During that time there has been considerable progress in developing the technological and methodological base for treating architectural design as an engineering discipline, including specialized architectural description languages, tools, analytic techniques, handbooks, and methods. In this paper I survey the main features of the field, and then compare software architecture with object-oriented systems to illustrate some of the important similarities and differences between the two fields.", "num_citations": "25\n", "authors": ["621"]}
{"title": "Towards formalized software architectures\n", "abstract": " An important goal in software engineering is to describe complex software systems at an architectural level of abstraction. While there are many useful architectural paradigms (pipes, blackboards, etc.) they are typically understood only idiomatically and applied in an ad hoc fashion. We show how a formal model allows us to say precisely what we mean by a software architecture, explore its properties, and systematically describe instances of the architecture. We illustrate the approach using the well-known example of pipe-filter architectures.This research was sponsored by the National Science Foundation under Grants CCR-9109469 and CCR-9112880, and by Siemens Corporate Research, Inc. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Siemens or the US Government.", "num_citations": "25\n", "authors": ["621"]}
{"title": "Flexible unparsing in a structure editing environment\n", "abstract": " Generators of structure editing-based programming environments require some form of unparse specification language with which an implementor can describe mappings between objects in the programming environment and concrete, visual representations of them. They must also provide an unparser to execute those mappings in a running programming environment. We describe one such unparse specification language, called VIZ, and its unparser, called UAL. VIZ combines in a uniform descriptive framework a variety of capabilities to describe flexible views of a programming database using a library of high-level formatting routines that can be customized and extended by the implementor. The UAL unparser allows the highly conditional unparse mappings of VIZ to be executed efficiently. Its implementation is based on the automatic generation of explicit display views, together with a scheme for efficient incremental updating of them in response to arbitrary changes to objects in the programming environment.", "num_citations": "25\n", "authors": ["621"]}
{"title": "Software architecture\n", "abstract": " Software Architecture Page 1 Software Architecture David Garlan Carnegie Mellon University NASA Fault Management Workshop New Orleans April 2012 Page 2 4/14/2012 Garlan 2 About me \u220e Professor of Computer Science \u2751 At Carnegie Mellon University since 1990 \u2751 Before then in industry (test and measurement) \u220e Research interests \u2751 Software architecture tools and techniques \u2751 Self-healing and self-adaptive systems \u220e Connection with NASA \u2751 Engagement since 2004 \u2751 Sabbatical at JPL summer of 2006 \u2751 On-going education offerings for several NASA Centers Page 3 4/14/2012 Garlan 3 This Talk \u220e What is Software Architecture? \u2751 Why is it important? \u2751 What are key principles and concepts of software architecture? \u2751 How can formal \u201carchitectural thinking\u201d yield systems that better satisfy their requirements? \u220e Prospects for improving Fault Management through architectural design \u2751 How do these \u2026", "num_citations": "24\n", "authors": ["621"]}
{"title": "User guidance of resource-adaptive systems\n", "abstract": " This paper presents a framework for engineering resource-adaptive software systems targeted at small mobile devices. The proposed framework empowers users to control tradeoffs among a rich set of ervicespecific aspects of quality of service. After motivating the problem, the paper proposes a model for capturing user preferences with respect to quality of service, and illustrates prototype user interfaces to elicit such models. The paper then describes the extensions and integration work made to accommodate the proposed framework on top of an existing software infrastructure for ubiquitous computing. The research question addressed here is the feasibility of coordinating resource allocation and adaptation policies in a way that end-users can understand and control in real time. The evaluation covered both systems and the usability perspectives, the latter by means of a user study. The contributions of this work\u00a0\u2026", "num_citations": "23\n", "authors": ["621"]}
{"title": "Time is not money: The case for multi-dimensional accounting in value-based software engineering\n", "abstract": " \" Time is money\", or so goes the old saying. Perhaps influenced by this aphorism, some strategies for incorporating costs in the analysis of software design express all costs in currency units for reasons of simplicity and tractability. Indeed, in theoretical economics all costs can, in principle, be expressed in dollars. Software engineering problems, however, often present situations in which converting all costs to a common currency is problematical. In this paper we pinpoint some of these situations and the underlying causes of the problems, and we argue that it is often better to treat costs as a multidimensional value, with dimensions corresponding to distinct types of resources. We go on to highlight the differences among cost dimensions that need to be considered when developing cost-benefit analyses, and we suggest mechanisms for mediating among heterogeneous cost dimensions.", "num_citations": "23\n", "authors": ["621"]}
{"title": "Stylized architecture, design patterns, and objects\n", "abstract": " Software system builders are increasingly recognizing the importance of exploiting design knowledge in the engineering of new systems. One way to do this is to define an architectural style for a collection of related systems. The style determines a coherent vocabulary of system design elements and rules for their composition. By structuring the design space for a family of related systems a style can, in principle, drastically simplify the process of building a system, reduce costs of implementation through reusable infrastructure, and improve system integrity through style-specific analyses and checks.  Like architectural style, object-oriented design patterns attempt to capture and exploit design knowledge to ease the process of designing software systems and reusing proven designs. There are, however, significant differences in the roles and capabilities of architectural styles and object-oriented design patterns, as there are between architectural design and object-oriented design. In this paper we illustrate the relationship between software architecture and object-oriented design, as well as the relationship between architectural styles and design patterns. We begin by defining our terms and then proceed to compare and contrast the various approaches with examples.", "num_citations": "23\n", "authors": ["621"]}
{"title": "Making formal methods education effective for professional software engineers\n", "abstract": " A critical issue in the design of a professional software engineering degree program is the way in which formal methods are integrated into the curriculum. The approach taken by most programs is to teach formal techniques for software development in a separate course on formal methods. In this paper we detail some of the problems with that approach and describe an alternative in which formal methods are integrated across the curriculum. We illustrate the strengths and weaknesses of this alternative in terms of our experience of using it in the Master of Software Engineering Program at Carnegie Mellon University.", "num_citations": "23\n", "authors": ["621"]}
{"title": "A 10-year perspective on software engineering self-adaptive systems\n", "abstract": " \u201cThe goal of this workshop is to bring together researchers and practitioners from many [areas] to discuss the fundamental principles, state of the art, and critical challenges of self-healing systems.\u2026 we intend to focus on the software engineering aspects, including the software languages, techniques and mechanisms that can be used to support dynamic adaptive behavior.\u201d", "num_citations": "22\n", "authors": ["621"]}
{"title": "A case study in software architecture interchange\n", "abstract": " An important issue for the specification and design of software architectures is how to combine the analysis capabilities of multiple architectural definition languages (ADLs) and their supporting toolsets. In this paper, we describe our experience of integrating three ADLs: Wright, Rapide, and Aesop. We discovered that it is possible to achieve interoperability in ADL tools for a non-trivial subset of the systems describable by these languages, even though the languages have different views about architectural structure and semantics. To carry out the integration we used the Acme architectural interchange language and its supporting tools.", "num_citations": "22\n", "authors": ["621"]}
{"title": "Toward explainable multi-objective probabilistic planning\n", "abstract": " Use of multi-objective probabilistic planning to synthesize behavior of CPSs can play an important role in engineering systems that must self-optimize for multiple quality objectives and operate under uncertainty. However, the reasoning behind automated planning is opaque to end-users. They may not understand why a particular behavior is generated, and therefore not be able to calibrate their confidence in the systems working properly. To address this problem, we propose a method to automatically generate verbal explanation of multi-objective probabilistic planning, that explains why a particular behavior is generated on the basis of the optimization objectives. Our explanation method involves describing objective values of a generated behavior and explaining any tradeoff made to reconcile competing objectives. We contribute: (i) an explainable planning representation that facilitates explanation generation\u00a0\u2026", "num_citations": "21\n", "authors": ["621"]}
{"title": "Eliminating inter-domain vulnerabilities in cyber-physical systems: An analysis contracts approach\n", "abstract": " Designing secure cyber-physical systems (CPS) is a particularly difficult task since security vulnerabilities stem not only from traditional cybersecurity concerns, but also physical ones. Many of the standard methods for CPS design make strong and unverified assumptions about the trustworthiness of physical devices, such as sensors. When these assumptions are violated, subtle inter-domain vulnerabilities are introduced into the system model. In this paper we use formal specification of analysis contracts to expose security assumptions and guarantees of analyses from reliability, control, and sensor security domains. We show that this specification allows us to determine where these assumptions are violated, opening the door to malicious attacks. We demonstrate how this approach can help discover and prevent vulnerabilities using a self-driving car example.", "num_citations": "20\n", "authors": ["621"]}
{"title": "Modeling of Architectures with UML\n", "abstract": " A critical level of abstraction in the modeling of a large, complex system is its architecture. At an architectural level one models the principal system elements and their interaction. Architectural models are typically used to provide an intellectually tractable, birds-eye view of a system and to permit design-time reasoning about system-level concerns such as performance, reliability, portability, and conformance to external standards and architectural styles.               In practice most architectural descriptions are informal documents. They are usually centered on box-and-line diagrams, with explanatory prose. Visual conventions are idiosyncratic, and usually project specific. As a result, architectural descriptions are only vaguely understood by developers, they cannot be analyzed for consistency or completeness, they are only hypothetically related to implementations, their properties cannot be enforced as a\u00a0\u2026", "num_citations": "20\n", "authors": ["621"]}
{"title": "Formal approaches to software architecture\n", "abstract": " An important goal in software engineering is to describe complex software systems at an architectural level of abstraction. While good software engineers routinely employ architectural concepts in their designs these concepts are typically used idiomatically and in an ad hoc fashion. What appears to be missing is a formal basis for software architecture. But what exactly does this mean? In this paper we illustrate by example three approaches to formalizing software architecture. The first represents an industrial development effort to formalize a specific class of applications. The second shows how to use formalism to understand the design space for a commonly used architectural style. The third considers the problem of providing a formal basis for the generic notion of architectural interconnection.", "num_citations": "20\n", "authors": ["621"]}
{"title": "Integrating formal methods into a professional master of software engineering program\n", "abstract": " A critical issue in the design of a professional software engineering degree program is the way in which formal methods are integrated into the curriculum. The approach taken by most programs is to teach formal techniques for software development in a separate course on formal methods. In this paper we detail some of the problems with that approach and describe an alternative in which formal methods are integrated across the curriculum. We illustrate the strengths and weaknesses of this alternative in terms of our experience of using it in the Master of Software Engineering Program at Carnegie Mellon University.", "num_citations": "19\n", "authors": ["621"]}
{"title": "Developing adaptive systems with synchronized architectures\n", "abstract": " In this paper we show how to specify and refine self-adapting systems, by employing the state-based formalism called action systems. Assuming a fixed set of possible configurations, we use a recently-introduced synchronization operator to achieve separation of concerns between adaptation policy, fault tolerance and steady-state system execution. Using action systems allows us to apply standard refinement techniques, aimed for correct implementations of higher-level models. We illustrate this idea by applying it to the problem of coping with dynamically-varying user requirements and possible fault situations.", "num_citations": "15\n", "authors": ["621"]}
{"title": "Synthesizing programming environments from reusable features\n", "abstract": " Synthesizing programming environments from reusable features | Software reusability ACM Digital Library Logo ACM Logo Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware reusability: vol. , applications and experienceSynthesizing programming environments from reusable features chapter Synthesizing programming environments from reusable features Share on Authors: Gail Elaine Kaiser profile image GE Kaiser View Profile , David Barnard Garlan profile image D. Garlan View Profile Authors Info & Affiliations Publication: Software reusability: vol. , applications and experienceJune 1989 Pages 35\u201355https://doi.org/10.1145/75722.75724 1citation 0 \u2026", "num_citations": "15\n", "authors": ["621"]}
{"title": "DARTSim: An exemplar for evaluation and comparison of self-adaptation approaches for smart cyber-physical systems\n", "abstract": " Motivated by the need for cyber-physical systems (CPS) to perform in dynamic and uncertain environments, smart CPS (sCPS) utilize self-adaptive capabilities to autonomously manage uncertainties at the intersection of the cyber and physical worlds. In this context, self-adaptation approaches face particular challenges, including (i) environment monitoring that is subject to sensing errors; (ii) adaptation actions that take time, sometimes due to physical movement; (iii) dire consequences for not adapting in a timely manner; and (iv) incomparable objectives that cannot be conflated into a single utility metric (e.g., avoiding an accident vs. providing good service). To enable researchers to evaluate and compare self-adaptation approaches aiming to address these unique challenges of sCPS, we introduce the DARTSim exemplar. DARTSim implements a high-level simulation of a team of unmanned air vehicles (UAVs\u00a0\u2026", "num_citations": "14\n", "authors": ["621"]}
{"title": "Uncertainty reduction in self-adaptive systems\n", "abstract": " Self-adaptive systems depend on models of themselves and their environment to decide whether and how to adapt, but these models are often affected by uncertainty. While current adaptation decision approaches are able to model and reason about this uncertainty, they do not consider ways to reduce it. This presents an opportunity for improving decision-making in self-adaptive systems, because reducing uncertainty results in a better characterization of the current and future states of the system and the environment (at some cost), which in turn supports making better adaptation decisions. We propose uncertainty reduction as the natural next step in uncertainty management in the field of self-adaptive systems. This requires both an approach to decide when to reduce uncertainty, and a catalog of tactics to reduce different kinds of uncertainty. We present an example of such a decision, examples of uncertainty\u00a0\u2026", "num_citations": "14\n", "authors": ["621"]}
{"title": "Active: A tool for integrating analysis contracts\n", "abstract": " In this paper we present ACTIVE, a tool and framework to semantically integrate independently-developed analysis plugins in OSATE, a tool for modeling systems in the Architecture Analysis and Design Language AADL. In the paper we analyze the problems that occur when independently-developed analysis plugins are executed on an AADL model and how these problems can lead to invalid analysis results. We show how our framework model plugin interactions in a formal way in order to enable automatic verification. These interactions are captured in an analysis contract that describes inputs, outputs, assumptions, and guarantees. The input and outputs in the contract allow us to determine the correct order in which plugins must execute. The assumptions and guarantees, on the other hand, capture the conditions that must be valid to execute a plugin and the one that are expected to be valid afterwards. The ACTIVE framework allows the inclusion of any generic verification tool eg model checkers to verify these conditions. To coordinate all these activities uses two components the ACTIVE EXECUTER and the ACTIVE VERIFIER. The ACTIVE EXECUTER executes the plugins in the required order calling the ACTIVE VERIFIER every time assumption and guarantees need to be verified. The ACTIVE VERIFIER, in turn identifies and executes the verification tool that needs to be invoked based on the target formula. Together, they ensure that the plugins are always executed in the correct order and under the correct conditions guaranteeing a sound verification process. To the best of our knowledge ACTIVE is the first extensible framework able to\u00a0\u2026", "num_citations": "14\n", "authors": ["621"]}
{"title": "Measuring attack surface in software architecture\n", "abstract": " In this report we show how to adapt the notion of \u201cattack surface\u201d to formally evaluate security properties at the architectural level of design and to identify vulnerabilities in architectural designs. Further we explore the application of this metric in the context of architecture-based transformations to improve security by reducing the attack surface. These transformations are described in detail and validated with a simple experiment.The authors would like to acknowledge Pratyusa Manadhata and Jeannette Wing; without their work formalizing the attack surface metric, our work would not be possible. The authors would also like to thank the Software Engineering Institute for supporting this work. This research was supported in part by CyLab at Carnegie Mellon under grants DAAD19-02-1-0389 and W911NF-09-1-0273 from the Army Research Office.", "num_citations": "14\n", "authors": ["621"]}
{"title": "Acme-based software architecture interchange\n", "abstract": " An important issue for the specification and design of software architectures is how to combine the analysis capabilities of multiple architectural definition languages (ADLs) and their supporting toolsets. In this paper, we describe our experience of integrating three ADLs: Wright, Rapide, and Aesop. We discovered that it is possible to achieve interoperability in ADL tools for a non-trivial subset of the systems describable by these languages, even though the languages have different views about architectural structure and semantics. To carry out the integration we used the Acme architectural interchange language and its supporting tools.", "num_citations": "14\n", "authors": ["621"]}
{"title": "Improving user-awareness by factoring it out of applications\n", "abstract": " Computers support more and more daily activities for common users. However, user attention is taking a heavy toll when scaling the use of computers for tasks that span many locations, large periods of time, and that are constantly interrupted and resumed. To reduce such toll, computer systems must improve their awareness of user tasks, across multiple devices, and over time spans of weeks or even years. In this paper, we discuss the limitations of building such awareness into applications, and propose to factor the awareness of user tasks into a common infrastructure. We summarize the main features of such infrastructure and distill some of the lessons learned.", "num_citations": "13\n", "authors": ["621"]}
{"title": "Documenting software architectures: Recommendations for industrial practice\n", "abstract": " An important issue for software system development is the documentation of architecture designs. In this report, we describe techniques for the architectural documentation of software-based systems in the context of development processes that use UML for software design. The architectural documentation is organized in four kinds of views problem domain view, code view, run-time view and deployment view. We examine JavaPhoneTM as a case study to illustrate the approach what kinds of information are provided in each kind of view, what forms of notation should be used, what are their limitations, and what uses can be made of this documentation.Descriptors:", "num_citations": "13\n", "authors": ["621"]}
{"title": "Explanations for human-on-the-loop: A probabilistic model checking approach\n", "abstract": " Many self-adaptive systems benefit from human involvement and oversight, where a human operator can provide expertise not available to the system and can detect problems that the system is unaware of. One way of achieving this is by placing the human operator on the loop-ie, providing supervisory oversight and intervening in the case of questionable adaptation decisions. To make such interaction effective, explanation is sometimes helpful to allow the human to understand why the system is making certain decisions and calibrate confidence from the human perspective. However, explanations come with costs in terms of delayed actions and the possibility that a human may make a bad judgement. Hence, it is not always obvious whether explanations will improve overall utility and, if so, what kinds of explanation to provide to the operator. In this work, we define a formal framework for reasoning about\u00a0\u2026", "num_citations": "12\n", "authors": ["621"]}
{"title": "Formal modeling and analysis of the HLA RTI\n", "abstract": " The HLA RTI is a complex artifact, supporting several classes of interaction (e.g., federation management, object management, time management). A critical challenge in producing an RTI architectural framework (and its associated simulation interface specifications) is to develop confidence that its specification is well-formed and complete. In this paper we describe on-going work in formally modelling the HLA both to document the standard more precisely, as well as to analyze it for anomalies, omissions, inconsistencies, and ambiguities. The technical basis for this work is the use of a formal architectural description language, called Wright, and its accompanying toolset.", "num_citations": "12\n", "authors": ["621"]}
{"title": "A software infrastructure for user\u2013guided quality\u2013of\u2013service tradeoffs\n", "abstract": " This paper presents a framework for engineering resource-adaptive software targeted at small mobile devices. Rather than building a solution from scratch, we extend and integrate existing work on software infrastructures for ubiquitous computing, and on resource-adaptive applications.               This paper addresses two research questions: first, is it feasibility to coordinate resource allocation and adaptation policies among several applications in a way that is both effective and efficient. And second, can end-users understand and control such adaptive behaviors dynamically, depending on user-defined goals for each activity. The evaluation covered both the systems and the usability perspectives, the latter by means of a user study.               The contributions of this work are: first, a set of design guidelines, including APIs for integrating new applications; second, a concrete infrastructure that implements the\u00a0\u2026", "num_citations": "11\n", "authors": ["621"]}
{"title": "Architectural unification.\n", "abstract": " Many software designs are produced by combining and elaborating existing architectural design fragments. These fragments may be design patterns, partially thought-out ideas, or portions of some previously-developed system design. To provide mechanized support for this activity it is necessary to have a precise characterization of when and how two or more architectural fragments can be combined. In this paper we describe extensions to notations for software architecture to represent incomplete design fragments, and algorithms for combining fragments in a process analogous to unification in logic.", "num_citations": "11\n", "authors": ["621"]}
{"title": "Architectural Style: An Object-Oriented Approach\n", "abstract": " Software system builders are increasingly recognizing the importance of exploiting design knowledge in the engineering of new systems. One way to do this is to de ne an architectural style for a collection of related systems. The style determines a coherent vocabulary of system design elements and rules for their composition. By structuring the design space for a family of related systems a style can, in principle, drastically simplify the process of building a system, reduce costs of implementation through reusable infrastructure, and improve system integrity through style-speci c analyses and checks.In this article we describe one way to realize these bene ts. Speci cally, we describe Aesop, an environment for architectural design that supports the de nition and use of architectural styles. Aesop adopts an object-oriented approach to the representation of both styles and designs. It also provides a repository of reusable architectural design fragments. In this way it is able to both leverage many of the capabilities of object-oriented systems and also take advantage of the emerging compendium of design patterns. However, at the same time Aesop retains a distinct architectural character. We elaborate on these distinctions to illustrate how concerns of architectural design both resemble and di er from those of object-oriented methods and patterns.", "num_citations": "11\n", "authors": ["621"]}
{"title": "Giving users the steering wheel for guiding resource-adaptive systems\n", "abstract": " Addressing resource variation plays an increasingly important role in engineering today's software systems. Research in resource-adaptive applications takes an important step towards addressing this problem. However, existing solutions stop short of addressing the fact that different user tasks often have specific goals of quality of service, and that such goals often entail multiple aspects of quality of service. This paper presents a framework for engineering software systems capable of adapting to resource variations in ways that are specific to the quality goals of each user task. For that, users are empowered to specify their task-specific preferences with respect to multiple aspects of quality of service. Such preferences are then exploited to both coordinate resource usage across the applications supporting the task, and to dynamically control the resource adaptation polices of those applications. A user study validates that non-expert users can use this framework to successfully control the behavior of such adaptive systems.", "num_citations": "10\n", "authors": ["621"]}
{"title": "Acme StrawManual\n", "abstract": " ACME is a formal specification language for describing software architectures. In its role as a community-based, generic, software architecture description language (ADL), ACME supports the interchange of software architecture designs between architecture design environments and other tools developed by the EDCS community and elsewhere. ACME provides a structural framework for characterizing architectures, together with annotation facilities for additional ADL-specific information. This scheme permits subsets of ADL tools to share architectural information that is jointly understood, while tolerating the presence of information that falls outside of their common vocabulary.", "num_citations": "10\n", "authors": ["621"]}
{"title": "Formal methods for software engineers: Tradeoffs in curriculum design\n", "abstract": " While formal methods are becoming increasingly important to software engineering, currently there is little consensus on how they should be taught. In this paper I outline some of the important dimensions of curriculum design for formal methods and illustrate the tradeoffs through a brief examination of four common course formats. I summarize what I have learned from teaching courses in each of these formats and outline an agenda of educational research that will enable us to teach formal methods more effectively.", "num_citations": "10\n", "authors": ["621"]}
{"title": "Tradeoff-focused contrastive explanation for MDP planning\n", "abstract": " End-users\u2019 trust in automated agents is important as automated decision-making and planning is increasingly used in many aspects of people\u2019s lives. In real-world applications of planning, multiple optimization objectives are often involved. Thus, planning agents\u2019 decisions can involve complex tradeoffs among competing objectives. It can be difficult for the end-users to understand why an agent decides on a particular planning solution on the basis of its objective values. As a result, the users may not know whether the agent is making the right decisions, and may lack trust in it. In this work, we contribute an approach, based on contrastive explanation, that enables a multi-objective MDP planning agent to explain its decisions in a way that communicates its tradeoff rationale in terms of the domain-level concepts. We conduct a human subjects experiment to evaluate the effectiveness of our explanation approach in a\u00a0\u2026", "num_citations": "9\n", "authors": ["621"]}
{"title": "Modeling challenges for CPS systems\n", "abstract": " Summary form only given. Today's complex cyber-physical systems require the use of a variety of models to capture different aspects of these systems: physical models, software models, control models, and so on. A critical challenge is to ensure consistency and completeness of these models. In this talk we describe an approach that uses architectural models as the basis for reconciliation. Specifically, a base architecture of the system is used as a unifying representation to compare the structure and semantics of the associated models through a set of architectural projections, or views. Each model is related to the base architecture through the abstraction of a corresponding architectural view, which captures structural and semantic correspondences between model elements and system entities. The use of the architectural view framework to relate system models from different domains is illustrated in the context of\u00a0\u2026", "num_citations": "9\n", "authors": ["621"]}
{"title": "Evolution Styles-Formal foundations and tool support for software architecture evolution\n", "abstract": " Architecture evolution is a central feature of virtually all software systems. As new market opportunities, technologies, platforms, and frameworks become available systems must change their organizational structures to accommodate them, requiring large-scale and systematic restructuring. Today architects have few tools to help them plan and execute such evolutionary paths. In particular, they have almost no assistance in reasoning about questions such as: How should we stage the evolution to achieve business goals in the presence of limited development resources? How can we reduce risk in incorporating new technologies and infrastructure required by the target architecture? How can we make principled tradeoffs between time and development effort? What kinds of changes can be made independently, and which require coordinated system-wide modifications? How can an evolution plan be represented and communicated within an organization? In this report we outline first steps towards a formal basis for assisting architects in developing and reasoning about architectural evolution paths. The key insight behind the approach is that at an architectural level of abstraction many system evolutions follow certain common patterns\u2013or evolution styles. By taking advantage of regularity in the space of common architectural evolutions, and by making the notion of evolutions styles a first-class entity that can be formally defined, we can provide automated assistance for expressing architecture evolution, and for reasoning about both the correctness and quality of evolution paths.", "num_citations": "9\n", "authors": ["621"]}
{"title": "Modeling of Architecutures with UML\n", "abstract": " A critical level of abstraction in the modeling of a large, complex system is its architecture. At an architectural level one models the principal system elements and their interaction. Architectural models are typically used to provide an intellectually tractable, birds-eye view of a system and to permit design-time reasoning about system-level concerns such as performance, reliability, portability, and conformance to external standards and architectural styles.In practice most architectural descriptions are informal documents. They are usually centered on box-and-line diagrams, with explanatory prose. Visual conventions are idiosyncratic, and usually project specific. As a result, architectural descriptions are only vaguely understood by developers, they cannot be analyzed for consistency or completeness, they are only hypothetically related to implementations, their properties cannot be enforced as a system evolves, and\u00a0\u2026", "num_citations": "9\n", "authors": ["621"]}
{"title": "Formalizing a specification for analysis: the HLA ownership properties\n", "abstract": " Interfaces are commonly specified using informal or semi-formal techniques, relying primarily on natural language descriptions. Such specifications, however, can easily overlook significant details and are not amenable to analysis by automated tools. This paper looks at formalizing one portion of a substantial specification, the ownership management chapter of the DoD HLA framework, and at the subsequent analysis using the tool Ladybug.Descriptors:", "num_citations": "9\n", "authors": ["621"]}
{"title": "Preconditions for understanding (formal specification)\n", "abstract": " The author argues that advocates of a formal method have an obligation to explain the relationship between the role of proof in that method and the role of proof in others. Such comparisons are needed to (a) clarify the 'method' behind a specific notation, (b) dispel misconceptions invited by the use of similar vocabulary with different meanings, and (c) suggest improvements to existing methods. These points are illustrated by comparing the use of preconditions in Z with that in other formal methods.< >", "num_citations": "9\n", "authors": ["621"]}
{"title": "Task planning of cyber-human systems\n", "abstract": " Internet of Things (IoT) allows for cyber-physical applications to be created and composed to provide intelligent support or automation of end-user tasks. For many of such tasks, human participation is crucial to the success and the quality of the tasks. The cyber systems should proactively request help from the humans to accomplish the tasks when needed. However, the outcome of such system-human synergy may be affected by factors external to the systems. Failure to consider those factors when involving human participants in the tasks may result in suboptimal performance and negative experience on the humans. In this paper, we propose an approach for automated generation of control strategies of cyber-human systems. We investigate how explicit modeling of human participant can be used in automated planning to generate cooperative strategy of human and system to achieve a given task, by\u00a0\u2026", "num_citations": "8\n", "authors": ["621"]}
{"title": "Challenges in developing a software architecture evolution tool as a plug-in\n", "abstract": " Recent research has developed a theoretical basis for providing software architects with better support for planning and carrying out major evolutions of software systems. However, these theoretical models have yet to be implemented in a complete, integrated tool. In this paper, we consider some of the challenges involved in developing such a tool as a plug-in to an existing architecture modeling framework. We present an experience report based on the development of a prototype architecture evolution tool as a plug-in to MagicDraw, a commercial UML tool. We find that there are many practical obstacles to developing tools for architecture evolution modeling as plug-ins, and we discuss some of the key factors that plug-in developers should weigh when considering frameworks.", "num_citations": "8\n", "authors": ["621"]}
{"title": "Beyond desktop management: scaling task management in space and time\n", "abstract": " Computers support more and more daily activities for common users, and users increasingly take their activities to different locations. Rather than being bound to a specific device, users would like to take full advantage of the computer systems accessible to them, much like they take advantage of the furniture in each physical space. However, user attention takes a heavy toll when scaling the use of computers to tasks that are constantly interrupted and resumed, and that span many locations and long periods. In this report we describe an infrastructure that provides users with easy access to their tasks as a logical unit, across multiple devices, and over time spans of years. The infrastructure handles platform and application heterogeneity, as well as dynamic adaptation to resource variations. We validate that the infrastructures overhead is small compared to normal application startup, and that the approach scales.Descriptors:", "num_citations": "8\n", "authors": ["621"]}
{"title": "From computers everywhere to tasks anywhere: The Aura approach\n", "abstract": " A critical problem for ubiquitous systems engineering is to exploit resource-rich environments without burdening the user with their configuration and management. A particularly important aspect of this problem is to support continuity in the face of mobility and dynamically varying resources. In this paper we argue that a solution to this problem requires new system-level components and architectures. Specifically, we describe our design of a personal \u201cAura\u201d component that acts on behalf of a user to manage resources, provide continuity, and support high-level user tasks.", "num_citations": "8\n", "authors": ["621"]}
{"title": "Architectures for Software Systems\n", "abstract": " CiNii \u8ad6\u6587 - Architectures for Software Systems CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3 ] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb \u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9\u306e\u518d\u958b\u306b\u3064\u3044\u3066 Architectures for Software Systems GARLAN D. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 GARLAN D. \u53ce\u9332\u520a\u884c\u7269 Tutorial on ACM SigSoft'93. (Dec.) Tutorial on ACM SigSoft'93. (Dec.), 1993 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u30c9\u30e1\u30a4\u30f3\u5206\u6790\u30fb\u30e2\u30c7\u30ea\u30f3\u30b0\u6982\u8aac \u4f0a\u85e4 \u6f54 , \u7530\u6751 \u606d\u4e45 , \u6775\u5d8b \u4fee\u4e09 \u60c5\u5831\u51e6\u7406\u5b66\u4f1a \u7814\u7a76\u5831\u544a. SE,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u5de5\u5b66\u7814\u7a76\u4f1a\u5831\u544a 103, 1-8, 1995-03-09 \u53c2\u8003\u6587\u732e41\u4ef6 \u88ab\u5f15\u7528\u6587\u732e2\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10020889386 \u8cc7\u6599\u7a2e\u5225 \u4f1a\u8b70\u8cc7\u6599 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u66f8\u304d\u51fa\u3057 EndNote\u306b\u66f8\u304d\u51fa\u3057 Mendeley\u306b\u66f8\u304d\u51fa\u3057 Refer/BiblX\u3067\u8868\u793a RIS\u3067\u2026", "num_citations": "8\n", "authors": ["621"]}
{"title": "Model-based analysis of microservice resiliency patterns\n", "abstract": " Microservice application developers try to mitigate the impact of partial outages typically by implementing service-to-service interactions that use well-known resiliency patterns, such as Retry, Fail Fast, and Circuit Breaker. However, those resiliency patterns-as well as their available open-source implementations-are often documented informally, leaving it up to application developers to figure out when and how to use those patterns in the context of a particular microservice application. In this paper, we take a first step towards improving on this situation by introducing a model checking-based approach in which we use the PRISM probabilistic model checker to analyze the behavior of the Retry and Circuit Breaker resiliency patterns as continuous-time Markov chains (CTMC). This approach has enabled us to quantify the impact of applying each resiliency pattern on multiple quality attributes, as well as to determine\u00a0\u2026", "num_citations": "7\n", "authors": ["621"]}
{"title": "Architecture-based planning of software evolution\n", "abstract": " Software architecture allows us to make many decisions about a software system and analyze it even before it has been implemented, so as to make planned development possible. Similarly, architecture-based software evolution planning makes planned evolution possible by allowing us to make many decisions about the evolution of a software system and to analyze its evolution at the level of architecture design before software evolution is realized. In this paper, we develop a framework for architecture-based software evolution planning. It is done by defining various foundational terms and concepts, providing a taxonomy of software evolution plans, and then showing how to calculate values for various types of plans. By identifying and defining constituent foundational concepts, this conceptual framework makes precise the notion of \"architecture-based software planning\". By developing a value-calculation\u00a0\u2026", "num_citations": "7\n", "authors": ["621"]}
{"title": "Acme: An\n", "abstract": " Numerous architectural description languages (ADLs) have been developed, each providing complementary capabilities for architectural development and analysis. Unfortunately, each ADL and supporting toolset operates in isola-tion, making it dicult to integrate those tools and share architectural descriptions. Acme is being developed as a joint eort of the software architecture research community as a com-mon interchange format for architecture de-sign tools. Acme provides a structural frame-work for characterizing architectures, together with annotation facilities for additional ADL-speci c information. This scheme permits sub-sets of ADL tools to share architectural infor-mation that is jointly understood, while tol-erating the presence of information that falls outside their common vocabulary. In this pa-per we describe Acme's key features, rationale, and technical innovations. 1", "num_citations": "7\n", "authors": ["621"]}
{"title": "A behavioral notion of robustness for software systems\n", "abstract": " Software systems are designed and implemented with assumptions about the environment. However, once the system is deployed, the actual environment may deviate from its expected behavior, possibly undermining desired properties of the system. To enable systematic design of systems that are robust against potential environmental deviations, we propose a rigorous notion of robustness for software systems. In particular, the robustness of a system is defined as the largest set of deviating environmental behaviors under which the system is capable of guaranteeing a desired property. We describe a new set of design analysis problems based on our notion of robustness, and a technique for automatically computing robustness of a system given its behavior description. We demonstrate potential applications of our robustness notion on two case studies involving network protocols and safety-critical interfaces.", "num_citations": "6\n", "authors": ["621"]}
{"title": "An advanced persistent threat exemplar\n", "abstract": " Security researchers do not have sufficient example systems for conducting research on advanced persistent threats, and companies and agencies that experience attacks in the wild are reluctant to release detailed information that can be examined. In this paper, we describe an Advanced Persistent Threat Exemplar that is intended to provide a real-world attack scenario with sufficient complexity for reasoning about defensive system adaptation, while not containing so much information as to be too complex. It draws from actual published attacks and experiences as a security engineer by the authors.Descriptors:", "num_citations": "6\n", "authors": ["621"]}
{"title": "Synchronized architectures for adaptive systems\n", "abstract": " In this paper we demonstrate how to use action systems to specify and refine self-adaptive systems. Focusing on the special case in which there is a fixed set of possible configurations, we use a recently-introduced synchronization operator to achieve separation of concerns between adaptation policy and steady-state system execution. The use of action systems permits the application of standard techniques for refinement to construct correct implementations from higher-level models. We illustrate the application of this idea to the problem of coping with dynamically-varying user requirements.", "num_citations": "6\n", "authors": ["621"]}
{"title": "Extending IDL to support concurrent views\n", "abstract": " Derivation and refinement in IDL currently provide kinds of views in the sense that two IDL structures can describe the same data in different ways. But derivation and refinement are limited in that (a) they do not support concurrent access to shared information and (b) the range of differences between derived views is quite restricted. In this paper we outline an architecture in which IDL is extended to correct these problems. This design allows a collection of IDL-based tools to access a common object base concurrently through views defined as (extended) IDL structures. Mappings between views are provided automatically by the IDL translator and database support mechanisms.", "num_citations": "6\n", "authors": ["621"]}
{"title": "Lynceus: Cost-efficient tuning and provisioning of data analytic jobs\n", "abstract": " Modern data analytic and machine learning jobs find in the cloud a natural deployment platform to satisfy their notoriously large resource requirements. Yet, to achieve cost efficiency, it is crucial to identify a deployment configuration that satisfies user-defined QoS constraints (e.g., on execution time), while avoiding unnecessary over-provisioning.This paper introduces Lynceus, a new approach for the optimization of cloud-based data analytic jobs that improves over state-of-the-art approaches by enabling significant cost savings both in terms of the final recommended configuration and of the optimization process used to recommend configurations.Unlike existing solutions, Lynceus optimizes in a joint fashion both the cloud-related (i.e., which and how many machines to provision) and the application-level (e.g. the hyper-parameters of a machine learning algorithm) parameters. This allows for a reduction of the cost\u00a0\u2026", "num_citations": "5\n", "authors": ["621"]}
{"title": "An automated approach to management of a collection of autonomic systems\n", "abstract": " Modern enterprise IT systems are increasingly becoming compositions of many subsystems each of which is an autonomic system. These individual autonomic systems act independently to maintain their locally defined SLAs but can take actions which are inconsistent with and potentially detrimental to the global system objective. Currently, human administrators intervene to resolve these conflicts but are challenged by complexity in the prediction of current and future states of the constituent systems and their managers, multiple conflicting quality dimensions which may change over time, combinatorially large configuration space across the set of constituent systems, and the time critical nature of the decisions to be made to prevent further degradation. To address these challenges, this paper proposes an approach that enables the creation of a higher level autonomic system, referred to as a meta-manager, that\u00a0\u2026", "num_citations": "5\n", "authors": ["621"]}
{"title": "Managing safety and mission completion via collective run-time adaptation\n", "abstract": " Mobile Multi-Robot Systems (MMRSs) are an emerging class of systems that are composed of a team of robots, various devices (like movable cameras, sensors) which collaborate with each other to accomplish defined missions. Moreover, these systems must operate in dynamic and potentially uncontrollable and unknown environments that might compromise the safety of the system and the completion of the defined mission. A model of the environment describing, e.g., obstacles, no-fly zones, wind and weather conditions might be available, however, the assumption that such a model is both correct and complete is often wrong. In this paper, we describe an approach that supports execution of missions at run time. It addresses collective adaptation problems in a decentralized fashion, and enables the addition of new entities in the system at any time. Moreover, it is based on two adaptation resolution methods: one\u00a0\u2026", "num_citations": "5\n", "authors": ["621"]}
{"title": "Pervasive Computing and the Future of CSCW Systems\n", "abstract": " The use of largely isolated workstations and laptops as the primary carrier of personal computing is giving way to a world of pervasive computing populated by ubiquitous networks of heterogeneous computing and information facilities. In such a world the boundaries between a user", "num_citations": "5\n", "authors": ["621"]}
{"title": "Effective formal methods education for professional software engineers\n", "abstract": " At the core of any engineering discipline is a collection of formal techniques for development and analysis of the artifacts produced by engineers. For example, civil engineers use structural analysis based on formalisms for characterizing strength of materials, and chemical engineers use formalisms based on unit operations. Unfortunately, software engineering has had relatively little success in applying formal techniques to real systems. There is little in the way of routine formalism that is applied throughout the industry. By and large, software engineers develop systems using informal methods and procedures based on accumulated experience building similar systems.One explanation for this is that the state of the science underlying large-scale, commercial software development is relatively immature (Shaw, 1990). While there are many proposals for formal software development methods,(such as program verification (Hoare, 1972), rigorous program development (Gries, 1981; Jones, 1986), abstract specifications of modules (Guttag and Horning, 1980), and modeling of concurrency (Hoare, 1978) there is as yet no well-established body of formal foundations that are uniformly recognized as fundamental to industrial software development. While there are some notable successes of formal methods in industry (such as Barrett, 1989; Nix and Collins, 1988; Delisle and Garlan, 1990), the fact remains that the primary proponents of systematic application of formal development have been academicians and those working in the areas of secure and safety-critical systems.", "num_citations": "5\n", "authors": ["621"]}
{"title": "Software Architecture: Perspectives on an Engineering Discipline\n", "abstract": " Good software developers often adopt one or several architectural patterns as strategies for system organization. But, although they use these patterns purposefully, they often use them informally and nearly unconsciously. This book organizes this substantial emerging \"folklore\" of system design -- with its rich language of system description -- and closes the gap between the useful abstractions (constructs and patterns) of system design and the current models, notations and tools. It identifies useful patterns clearly, gives examples, compares them, and evaluates their utility in various settings -- allowing readers to develop a repertoire of useful techniques that goes beyond the single-minded current fads. Examines the ways in which architectural issues can impact software design; shows how to design new systems in principled ways using well-understood architectural paradigms; emphasizes informal descriptions\u00a0\u2026", "num_citations": "5\n", "authors": ["621"]}
{"title": "Errata: A formal basis for architectural connection\n", "abstract": " We present corrections to a previously published article which appeared in ACM Transaction on Software Engineering and Methodology 6, 3 (July 1997), pp. 213\u2013249", "num_citations": "4\n", "authors": ["621"]}
{"title": "TrimTuner: Efficient Optimization of Machine Learning Jobs in the Cloud via Sub-Sampling\n", "abstract": " This work introduces TrimTuner, the first system for optimizing machine learning jobs in the cloud to exploit sub-sampling techniques to reduce the cost of the optimization process, while keeping into account user-specified constraints. TrimTuner jointly optimizes the cloud and application-specific parameters and, unlike state of the art works for cloud optimization, eschews the need to train the model with the full training set every time a new configuration is sampled. Indeed, by leveraging sub-sampling techniques and data-sets that are up to 60 x smaller than the original one, we show that TrimTuner can reduce the cost of the optimization process by up to 50 x. Further, TrimTuner speeds-up the recommendation process by 65 x with respect to state of the art techniques for hyperparameter optimization that use sub-sampling techniques. The reasons for this improvement are twofold: i) a novel domain specific heuristic\u00a0\u2026", "num_citations": "3\n", "authors": ["621"]}
{"title": "Hybrid planning in self-adaptive systems\n", "abstract": " Self-adaptive software systems make decisions at run time that seek to change their behavior in response to faults, changing environments and attacks. Therefore, having an appropriate planning approach to find an adaptation plan is critical to successful self-adaptation. For many realistic systems, ideally one would like to have a planning approach that is both quick and finds an optimal adaptation plan. However, due to the fundamental trade-off between quality and timeliness of planning, often designers have to compromise between an approach that is quick to find a plan and an approach that is slow but finds an optimal plan. To deal with this trade-off, this work proposes a hybrid planning approach that combines more than one planning approach to bring their benefits together.", "num_citations": "3\n", "authors": ["621"]}
{"title": "Multiscale time abstractions for long-range planning under uncertainty\n", "abstract": " Planning in CPSs requires temporal reasoning to handle the dynamics of the environment, including human behavior, as well as temporal constraints on system goals and durations of actions that systems and human actors may take. The discrete abstraction of time in a state space planning should have a time sampling parameter value that satisfies some relation to achieve a certain precision. In particular, the sampling period should be small enough to allow the dynamics of the problem domain to be modeled with sufficient precision. Meanwhile, in many cases, events in the far future (relative to the sampling period) may be relevant to the decision making earlier in the planning timeline; therefore, a longer planning look-ahead horizon can yield a closer-to-optimal plan. Unfortunately, planning with a uniform fine-grained discrete abstraction of time and a long look-ahead horizon is typically computationally\u00a0\u2026", "num_citations": "3\n", "authors": ["621"]}
{"title": "Large-Scale Complex IT Systems. Development, Operation and Management: 17th Monterey Workshop 2012, Oxford, UK, March 19-21, 2012, Revised Selected Papers\n", "abstract": " This book presents the thoroughly refereed and revised post-workshop proceedings of the 17th Monterey Workshop, held in Oxford, UK, in March 2012. The workshop explored the challenges associated with the Development, Operation and Management of Large-Scale complex IT Systems. The 21 revised full papers presented were significantly extended and improved by the insights gained from the productive and lively discussions at the workshop, and the feedback from the post-workshop peer reviews.", "num_citations": "3\n", "authors": ["621"]}
{"title": "Software Architectures\n", "abstract": " For all but the most trivial software systems, you cannot hope to succeed without paying careful attention to its architecture: the way the system is decomposed into constituent parts and the ways those parts interact with each other. Without an architecture that is appropriate for the problem being solved the project will fail. Even with a superb architecture, if it is not well understood and well communicated--in other words, well documented--the project will fail. Not may fail. Will fail.Accordingly, software architecture is at the center of a frenzy of attention these days. A new book about it seems to pop out monthly. In response to industrial need, universities are adding software architecture to their software engineering curricula. It\u2019s now common for \u201csoftware architect\u201d to be a defined position in organizations, and professional practice groups for software architects are emerging. It has been the subject of major international conferences and workshops. The purveyors of the Unified Modeling Language promote their product by calling it \u201cthe standard notation for software architecture\u201d(a claim that may say at least as much about the pervasiveness of architecture as about UML). The Software Engineering Institute maintains a bibliography of journal and conference papers about software architecture and its population is approaching 1000.", "num_citations": "3\n", "authors": ["621"]}
{"title": "The role of formalized domain-specific software frameworks\n", "abstract": " We use our experience in developing formal domain-specific software processes in an industrial setting to argue the benefits of (a) developing specialized software process models tailored to a particular class of software system, and (b) the use of formal methods and notations for extracting these models.", "num_citations": "3\n", "authors": ["621"]}
{"title": "Trade-off-oriented development: making quality attribute trade-offs first-class\n", "abstract": " Implementing a solution for a design decision that precisely satisfies the trade-off between quality attributes can be extremely challenging. Further, typically quality attribute trade-offs are not represented as first-class entities in development artifacts. Hence, decisions might be sub-optimal and lack requirements traceability as well as changeability. We propose Trade-off-oriented Development (ToD), a new concept to automate the selection and integration of reusable implementations for a given design decision based on quality attribute trade-offs. Implementations that vary in quality attributes and that solve reoccurring design decisions are collected in a design decision library. Developers declaratively specify the quality attribute trade-off, which is then used to automatically select the best fitting implementation. We argue that thereby, software could satisfy the trade-offs more precisely, requirements are traceable and\u00a0\u2026", "num_citations": "2\n", "authors": ["621"]}
{"title": "Aura: Distraction-free ubiquitous computing\n", "abstract": " Technological trends are leading to a world in which computing is all around us \u2013 in our cars, our kitchens, our offices, our phones, and even our clothes. In this world we can expect to see an explosion of computational devices, services, and information at our disposal. While this is an undeniable opportunity, currently we are ill-prepared to deal with its implications.", "num_citations": "2\n", "authors": ["621"]}
{"title": "Toward compositional construction of complex connectors\n", "abstract": " ABSTRACT A critical issue for systems composed of independentlydeveloped parts is the design and implementation of mechanisms that allow those parts to interact. In many situations specialized forms of interaction are needed to bridge component mismatches or to achieve extrafunctional properties (eg, security, performance, reliability). Unfortunately, system developers have few options: they must either live with available, but often inadequate, generic support for interaction (such as RPC), or they must handcraft specialized mechanisms at great cost. In this paper we describe a partial solution to this problem, whereby interaction mechanisms are constructed compositionally. Specifically, we describe a set of operators that can transform generic communication mechanisms (such as RPC and publish-subscribe) to incrementally add new capabilities. We show how these transformations can be used to realize complex interactions, such as Kerberized RPC, at relatively low cost. We also outline the formal underpinnings for these operators and illustrate how to reason about properties of operator composition.", "num_citations": "2\n", "authors": ["621"]}
{"title": "Foundations for Compositional Connectors\n", "abstract": " A critical issue for architectural design is the nature of the glue, or connectors, with which a system's parts are combined. Thus an important rst step toward improving our ability to compose parts is to make to make connectors explicit semantic enties, where they can be documented, analyzed, and sometimes used to generate code. A number of notations for software architecture do precisely this. However, a key second step is to understand operations over connectors. In principle, such operations would permit one to produce new connectors out of old ones, adapt existing connectors to new contexts of use, and factor out common properties of connectors so they can be reused. In this paper we argue that the use of higher order connectors\" is one way to achieve this goal.", "num_citations": "2\n", "authors": ["621"]}
{"title": "Experience with a Course on Architectures for Software Systems Part II: Educational Materials\n", "abstract": " This report contains the materials used by the instructors to teach the course CS 15-775: Architectures for Software Systems in the Spring of 1994 in the School of Computer Science at Carnegie Mellon University. The materials include the lecture slides, questions (with answers) on readings, and homework assignments (with sample solutions.)", "num_citations": "2\n", "authors": ["621"]}
{"title": "Nico Habermann's research: a brief retrospective\n", "abstract": " The last decade and a half of Nico Habermann's research career focused on software engineering, and in particular on software development environments. His earlier work was oriented more towards operating systems and programming language research. We take this opportunity to look back at his research, putting it in a larger perspective, identifying some general themes that characterize his contributions to software engineering in particular, and to computer science in general.< >", "num_citations": "2\n", "authors": ["621"]}
{"title": "An introduction to software architecture\n", "abstract": " An Introduction to Software Architecture By David Garlan & Mary Shaw \u2013 94 Page 1 WATERLOO CHERITON SCHOOL OF COMPUTER SCIENCE An Introduction to Software Architecture By David Garlan & Mary Shaw \u2013 94 CS 446/646 ECE452 May 16th, 2011 IMPORTANT NOTICE TO STUDENTS These slides are NOT to be used as a replacement for student notes. These slides are sometimes vague and incomplete on purpose to spark a class discussion Page 2 2011-05-04 CS446/646 ECE452 2 WATERLOO CHERITON SCHOOL OF COMPUTER SCIENCE Motivation Software Systems \u25cf are more complex & bigger \u25cf are not just about \u201calgorithms\u201d anymore Challenges \u2013 structural issues \u2013 communication (type, protocol) \u2013 synchronization \u2013 data access & manipulation \u2013 deployment \u2013 performance \u2013 testing Which ones of these issues are more important than the others? Page 3 2011-05-04 CS446/646 ECE452 \u2026", "num_citations": "2\n", "authors": ["621"]}
{"title": "Domain Specifications Require First Class Connectors\n", "abstract": " Software systems are rarely conceived in isolation. Instead, most systems represent a new instance of a product in some family of related systems, be they accounting systems, database products, or compilers. Each system typically shares with other applications in its family a common \u201cframework\u201d of behavioral and structural properties.(Even single systems undergo requirements drift over time, and can therefore be viewed as a family of systems.) We can exploit this fact by specifying application-specific domains. First, such a domain specification can substantially reduce costs by amortizing efforts across a family of systems. Second, a shared domain model can lead to a desirable uniformity across products. Third, in many cases shared concepts at the domain level can be implemented by corresponding reusable software components. Fourth, the requirement of producing a domain specification that acts as\u00a0\u2026", "num_citations": "2\n", "authors": ["621"]}
{"title": "ASCENT: Application-Specific Environment Transformer\n", "abstract": " Current software development environments tend to lie at opposite ends of a spectrum: at one extreme are specialized application generators; at the other are general-purpose programming environments. The former provide strong support for system development and reuse, but are costly to build and available only for limited domains. The latter provide weak support, but are generally available and universally applicable. We describe a technique for automating the production of application-specific environments that lie between these two extremes. The key idea is that these environments can be derived from general-purpose programming environments by a process of structured transformation. We describe a tool for performing these transformations. It provides a set of formal operators for specializing a description of a general-purpose environment; as operators are applied, the system semi-automatically builds a\u00a0\u2026", "num_citations": "2\n", "authors": ["621"]}
{"title": "Session Summary-Emerging Issues\n", "abstract": " It would be a mistake to infer from the title of this session that discussions of emerging issues were postponed until this final session of the workshop. On the contrary, all of the preceding sessions devoted a large proportion of the discussion to identifying issues that are poorly understood and much in need of further research. In leading this session, Sam Redwine did a remarkable job of condensing this multi-leveled, wide ranging spectrum of issues into a coherent outline. His presentation consisted of two major parts: first he delivered (without interruptions) a summary of the issues discussed in previous sessions; next he highlighted topics for future work and outlined specific actions that should be taken. This was followed by a discussion covering a range of topics relating to Redwine\u2019s presentation, the agenda for the next meeting, and other topics.The next two sections contain an annotated version of Redwine\u2019s\u00a0\u2026", "num_citations": "2\n", "authors": ["621"]}
{"title": "Engineering Secure Self-Adaptive Systems with Bayesian Games\n", "abstract": " Security attacks present unique challenges to self-adaptive system design due to the adversarial nature of the environment. Game theory approaches have been explored in security to model malicious behaviors and design reliable defense for the system in a mathematically grounded manner. However, modeling the system as a single player, as done in prior works, is insufficient for the system under partial compromise and for the design of fine-grained defensive strategies where the rest of the system with autonomy can cooperate to mitigate the impact of attacks. To deal with such issues, we propose a new self-adaptive framework incorporating Bayesian game theory and model the defender (ie, the system) at the granularity of components. Under security attacks, the architecture model of the system is translated into a Bayesian multi-player game, where each component is explicitly modeled as an independent player while security attacks are encoded as variant types for the components. The optimal defensive strategy for the system is dynamically computed by solving the pure equilibrium (ie, adaptation response) to achieve the best possible system utility, improving the resiliency of the system against security attacks. We illustrate our approach using an example involving load balancing and a case study on inter-domain routing.", "num_citations": "1\n", "authors": ["621"]}
{"title": "The unknown unknowns are not totally unknown\n", "abstract": " The question of whether \u201chandling unanticipated changes is the ultimate challenge for self-adaptation\u201d is impossible to evaluate without looking closely at what \u201cunanticipated\u201d means. In this position paper I try to bring a little clarity to this issue by arguing that the common distinction between \u201cknown unknowns\u201d and \u201cunknown unknowns\u201d is too crude: for most systems there are changes that are not directly handled by \u201cfirst-order\u201d adaptation, but can, with appropriate engineering, be addressed naturally through \u201csecond-order\u201d adaptation. I explain what I mean by this and consider ways in which such systems might be engineered.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Building Long-Lived Adaptive Systems\n", "abstract": " We are happy to introduce the \"Building Long-Lived Adaptive Systems\" theme issue of IEEE Software. This issue includes contributions from successful researchers and practitioners who work on constructing software that can continue to operate for years or even decades, adapting itself to changes in its ecosystem that may not have been envisaged by its designers. So, what are long-lived adaptive software systems, and what is their relevance?", "num_citations": "1\n", "authors": ["621"]}
{"title": "Software Engineering: Reflections on an Evolving Discipline\n", "abstract": " This paper analyzes Software Architecture, defining it and describing the evolution of this field and its role in software engineering. In addition, it covers key concepts of a software architecture course, steps to pursue an architectural thinking, the elements of organizational architecture maturity and emerging trends and issues such as: Architecture evolution, Architecture conformance, Frameworks, platforms, and ecologies, and Self-Adaptive Systems.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Invited Talk-Engineering Self-Healing and Self-Improving Systems\n", "abstract": " The proliferation of computing systems into every facet of our everyday lives raises a number of challenges for software engineering. Among those, we need to be able to build systems that take more control over their own dependability, security, and usefulness - automating many of the things that now lead to system failures and require computing experts to manage. In this talk I describe new architectural approaches to addressing these challenges, including the ability to support self-healing through architectural reflection and automated repair, and architectures that allow systems to learn new behaviors by observing their users.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Prologue: Software Architectures and Documentation\n", "abstract": " 1.1 PurposeIdentify the purpose of this SDD and its intended audience.(eg \u201cThis software design document describes the architecture and system design of XX.\u2026.\u201d).", "num_citations": "1\n", "authors": ["621"]}
{"title": "Valuation of Architecture-based Deterministic Plan for Software Evolution\n", "abstract": " Software architecture allows us to make many decisions about a software system and analyze it even before it exists in order to make systematic and planned development possible. Similarly, architecture-based software evolution planningmakes planned evolution possible by allowing us to make many decisions about evolution of a software system and analyze its evolution at the level of architecture design before software evolution is realized. In this paper, we develop a framework for architecture-based software evolution planning for the class of deterministic evolution plans by defining and relating various essential concepts and developing its valuationmechanism so that a plan with the greatest value among candidate plans can be selected as an optimal plan. A case study is conducted for explicating the framework and exemplifying its usage.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Using framework interfaces with design fragments\n", "abstract": " Framework interfaces are complex, so programmers often copy repeating patterns, either their own or from others, to interact with them. Design Fragments allow framework interactions to be explicitly defined, describing known-good uses of the framework. We demonstrate a tool that provides continual feedback on framework conformance as a program evolves.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Software architecture evaluation and analysis session report\n", "abstract": " We began by considering the broad vision for analysis and evaluation of architectures: to provide an engineering discipline that allows architects to make principled architectural decisions, evaluate the impact of those decisions, determine the conformance between architectures and other artifacts (code, requirements, etc.), and extract architectural representations from implementations.", "num_citations": "1\n", "authors": ["621"]}
{"title": "TaskPort: A Task Management Interface in an Intelligent Cognitive Assistant System\n", "abstract": " People are spending an increasing amount of time handling everyday routine tasks in their daily lives. To help people work more efficiently, Carnegie Mellon University is currently developing the RADAR (Reflective Agent with Distributed Adaptive Reasoning) system, a software-based cognitive personal assistant. The task manager is an essential component of the RADAR system that manages high-level tasks and coordinates communications among other intelligent assistants in a personal space. The task manager interface is an application that would not only allow the users to browse, create and modify tasks, but also provide more intelligent functionalities regarding task management. In this paper, we discuss the motivation, and an implementation of such task manager interface, called TaskPort. To better understand the elements that provide an edge in efficiency and productivity for the user, we explore various techniques used in the task manager interface and attempt to resolve several interesting challenges, such as flexibility, usability, scalability, and integration.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Bridging the HLA: A Case Study in Composing Publish-Subscribe Systems\n", "abstract": " The recent popularity of publish-subscribe (pub-sub) system architectures has led to a desire for a refined architecture that supports the composition of pub-sub systems. One proposed solution links such systems using a special bridge component that acts as a mediator, passing events between the systems. The bridge appears to be an ordinary pub-sub component to each system, effectively serving as a surrogate for the other system. Although attractive as a lightweight pub-sub combinator, the notion of a pub-sub bridge raises a number of questions, such as whether its use introduces new sources of deadlock or inconsistency. In this paper, we show that designing such a bridge is far from trivial, and indeed requires special treatment to achieve desired properties. To make these issues concrete, we describe our results in analyzing the feasibility of a bridge for the HLA, a standardized pub-sub framework designed for distributed simulation applications. We identify a small set of core problem classes for pub-sub bridge designs. Additionally, we also classify a set of generic solution paths and show how each applies to the problem classes. Although based on the HLA, we believe that these problems and solutions are applicable to many pub-sub systems as well as to other architectures for loosely coupled distributed systems.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Architecture for Pervasive Computing\n", "abstract": " Over the past decade there has been considerable progress in developing the technological and methodological base for treating architectural design as an engineering discipline. However, most of this work has been directed at systems based on relatively traditional platforms, such as stand-alone or networked PC\u2019s, client-server systems, and embedded control systems. In this paper we argue that the changing face of technology raises a number of substantial new challenges for software architecture. Specifically, we argue that Moore\u2019s Law coupled with pervasive access to computing services and information leads to a whole new class of research issues heretofore unaddressed by the software architecture community.", "num_citations": "1\n", "authors": ["621"]}
{"title": "Making architectural analysis reasonable\n", "abstract": " Software systems that integrate a set of concurrent and possibly distributed components are becoming increasingly common. One architectural style that is often used in such systems is implicit invocation [1, 2]. In this style, a component communicates and passes control by announcing events, and these events are multicast to a set of consuming components that perform actions in response to events. At first glance, it would seem that the inherent concurrency associated with this style would make systems intractable: the concurrency and independence of components coupled with event multicast typically leads to a highly complex concurrent system with considerable non-determinism. We are currently exploring the problems of modeling and reasoning about highly concurrent systems at an architectural level. In particular, we have identified two approaches that help make such reasoning tractable: recognizing that an application matches a known pattern, thus allowing the use of simplified reasoning techniques; constraining the architectural style so that systems in that style can be more easily understood.In this position statement, we focus on how the two approaches identified above can be applied to systems built using an implicit invocation style. We introduce a model of concurrent systems and show how the implicit invocation style produces a concurrent system. We then demonstrate how the approaches above can be applied using a number of examples. A formal treatment of this work is currently being developed. Our eventual goal is to develop a systematic understanding of the sources of tractability in concurrent systems and a set of\u00a0\u2026", "num_citations": "1\n", "authors": ["621"]}
{"title": "SIGSOFT'96 post mortem\n", "abstract": " This year the FSE featured a number of innovations. Supplementing a strong technical program of research presentations was a set of tutorials, workshops, keynotes, and panels that highlighted recent developments in the area of software design and architecture. In addition, there was an informal evening session for airing wild, new ideas about software engineering.By almost all standards the Symposium (and its associated activities) was a resounding success. General attendance was up over 50% from the previous years'. The two presymposium workshops (one on Software Architecture, and one on Viewpoints in Software Development) attracted over 75 participants, and the tutorials were well-attended by both industrial and academic researchers. Three keynote presentations (by Michael Jackson, Henry Petroski, and Eberhardt Rechtin) provided provocative new perspectives on software engineering. The\u00a0\u2026", "num_citations": "1\n", "authors": ["621"]}
{"title": "Formal modeling and analysis of architectural standards\n", "abstract": " An important trend in commercial software development is the creation of architectural standards that describe a common reference architecture for a family of related applications. Currently architectural standards are typically described using informal, or semiformal, techniques, such as application programming interface specifications, implementation guidelines, and box-and-line diagrams. In this paper we show how formal architectural modeling and analysis can be applied to architectural standards. In particular, we use the recently-issued High Level Architecture (HLA) Standard for Distributed Simulation to illustrate how architectural specification can expose several important classes of architectural design flaws, including errors of omission, design inconsistencies, potential deadlocking behavior, and race conditions. KEYWORDS Software architecture, architectural standards, reference architectures, formal Specification, HLA, Wright 1 INTRODUCTIONArchitectural frameworks are increasingly being recognized as a significant point of leverage in the development of software systems. Architectural frameworks typically determine the structure of a family of applications, providing shared infrastructure and prescribing requirements for instantiating the framework to produce a particular application. Often architectural frameworks are developed as in-house proprietary systems that permit the rapid development of new applications in a product line 13, 15]. However, they are also used to define open integration standards that permit multiple vendors to contribute parts to produce a composite system, or to provide components that can interact\u00a0\u2026", "num_citations": "1\n", "authors": ["621"]}
{"title": "The fourth symposium on the foundations of software engineering (FSE4)\n", "abstract": " (FSE4) Page 1 ACM SIGSOFT Software Engineering Notes vol 21 no 5 September 1996 Page 4 . c. Requisite knowledge customarily acquired by a prolonged course of specialized intellectual instruction and study; and d. Requires work performing consistent exercise of discretion and judgment in its performance. The \"Engineer\" must successfully complete a four (if not five) year accredited engineering program and suecessfully complete two eight hour nationally recognized written examinations. First is a Fundamentals of Engineering Examination with a reference handbook provided by NCEES. The second is the Principles and Practice of Engineering Examination, with eight problems, and an essay and multiple choice questions in one of the following 16 engineering disciplines: Chemical Mechanical Structural Environmental Electrical Control Systems Nuclear Civil Manufacturing Metallurgical Aeronautical / \u2026", "num_citations": "1\n", "authors": ["621"]}
{"title": "Software architecture (panel) next steps towards an engineering discipline for software systems design\n", "abstract": " A central concern for software engineering is the development of system structures\u2014or archit ectures\u2014that support the conceptual integrity of a software-based system. While techniques for structuring software have been a concern of the software research community for decades, recently there has emerged a new, broad-based interest in understanding the high-level organizational principles of large software systems. This int crest is manifest in diverse arenas, including design patterns for software, domain-specific software architectures, surveys of common architectural styles, industrial handbooks for architectural design, architectural description languages, and formal models of software architecture. This panel will expose some of the more promising recent developments in software architecture, and attempt to assess the extent to which those results represent fundamental progress in the engineering of software,", "num_citations": "1\n", "authors": ["621"]}