{"title": "Clone detection using abstract syntax trees\n", "abstract": " Existing research suggests that a considerable fraction (5-10%) of the source code of large scale computer programs is duplicate code (\"clones\"). Detection and removal of such clones promises decreased software maintenance costs of possibly the same magnitude. Previous work was limited to detection of either near misses differing only in single lexems, or near misses only between complete functions. The paper presents simple and practical methods for detecting exact and near miss clones over arbitrary program fragments in program source code by using abstract syntax trees. Previous work also did not suggest practical means for removing detected clones. Since our methods operate in terms of the program structure, clones could be removed by mechanical methods producing in-lined procedures or standard preprocessor macros. A tool using these techniques is applied to a C production software system\u00a0\u2026", "num_citations": "1750\n", "authors": ["2143"]}
{"title": "DMS/spl reg: program transformations for practical scalable software evolution\n", "abstract": " While a number of research systems have demonstrated the potential value of program transformations, very few of these systems have made it into practice. The core technology for such systems is well understood; what remains is integration and more importantly, the problem of handling the scale of the applications to be processed. This paper describes DMS, a practical, commercial program analysis and transformation system, and sketches a variety of tasks to which it has been applied, from redocumenting to large-scale system migration. Its success derives partly from a vision of design maintenance and the construction of infrastructure that appears necessary to support that vision. DMS handles program scale by careful space management, computational scale via parallelism and knowledge acquisition scale via domains.", "num_citations": "457\n", "authors": ["2143"]}
{"title": "Design maintenance systems\n", "abstract": " Lditional maintenance has proven difficult in the absence of design information [19]; maintainers often spend considerable energy trying to recover this design information before making changes [15]. Capture and reuse of certain kinds of design information should consequently improve the maintenance process. Updating the design information is as important as revising the software itself, for the revised design information is necessary for further maintenance. Four major software engineering efforts that ended in disaster precisely because trying to maintain their designs was perceived as impractical are described by [23]. Consequently, each design was abandoned and the projects spiraled into chaos.", "num_citations": "222\n", "authors": ["2143"]}
{"title": "TMM: Software maintenance by transformation\n", "abstract": " Porting an undocumented program without any source changes demonstrates the value of a transformational theory of maintenance. The theory is based on the reuse of knowledge.", "num_citations": "134\n", "authors": ["2143"]}
{"title": "Preprocessor conditional removal by simple partial evaluation\n", "abstract": " Preprocessors with conditionals are often used as software configuration management tools, with preprocessor variables naming configuration aspects. The preprocessor conditionals found in large systems often have complex enabling Boolean equations and nesting. Over long periods, some configuration aspects lose all utility. Removal of all traces of a configuration variable and code dependent on that aspect becomes a significant task if performed manually. An industrial-strength transformation system can remove such configuration aspects in a much shorter period of time, by symbolically simplifying away the configuration aspect. The paper sketches the problem and the required transforms, and discusses a case study involving over a million lines of source code.", "num_citations": "108\n", "authors": ["2143"]}
{"title": "Software change through design maintenance\n", "abstract": " Conventional software engineering tends to focus on a small part of the software life cycle: the design and implementation of a product. The bulk of the lifetime cost is in the maintenance phase, where one must live with the product previously developed. Presently, we have little theory and fewer tools to help us manage the maintenance activity. We contend that a fundamental cause of the difficulty is the failure to preserve design information. This results from an over preoccupation with the synthesis and maintenance of code. We offer an alternative paradigm: make the design the central focus of the construction process-get code as a byproduct; make the design the central focus of the maintenance process-preserve revised designs and get code as a byproduct. A transformational scheme for accomplishing this is presented. We call it the Design Maintenance System. The programming roles change radically from\u00a0\u2026", "num_citations": "105\n", "authors": ["2143"]}
{"title": "Reverse engineering is reverse forward engineering\n", "abstract": " Reverse engineering is focused on the challenging task of understanding legacy program code without having suitable documentation. Using a transformational forward engineering perspective, we gain the insight that much of this difficulty is caused by design decisions made during system development. Such decisions \"hide\" the program functionality and performance requirements in the final system by applying repeated refinements through layers of abstraction and information-spreading optimizations, both of which change representations and force single program entities to serve multiple purposes. To be able to reverse engineer, we essentially have to reverse these design decisions. Following the transformational approach, we can use the transformations of a forward engineering methodology and apply them \"backwards\" to reverse engineer code to a more abstract specification. Since most existing code\u00a0\u2026", "num_citations": "104\n", "authors": ["2143"]}
{"title": "Transformational maintenance by reuse of design histories\n", "abstract": " This thesis provides theory and procedures for modifying software artifacts implemented by a formal transformation process. Installing modifications requires knowing not only what transformations were applied (a derivation history) to construct the artifact, but also why the application sequence ensures that the artifact meets its specification. The derivation history and the justification are collectively called a design history. A Design Maintenance System (DMS), when provided with a formal change called a maintenance delta, revises a design history to guide construction of a new artifact. A DMS can be used to integrate a stream of deltas into a history, providing implementations as a side effect, leading to an incremental-evolution model for software construction.", "num_citations": "50\n", "authors": ["2143"]}
{"title": "Re-engineering C++ component models via automatic program transformation\n", "abstract": " Automated program transformation holds promise for a variety of software life cycle endeavors, particularly where the size of legacy systems makes code analysis, re-engineering, and evolution difficult and expensive. But constructing highly scalable transformation tools supporting modern languages in full generality is itself a painstaking and expensive process. This cost can be managed by developing a common transformation system infrastructure re-useable by derived tools that each address specific tasks, thus leveraging the infrastructure costs. This paper describes the design maintenance system (DMS), a practical, commercial program analysis and transformation system, and discusses how it was employed to construct a custom modernization tool being applied to a large C++ industrial avionics system. The tool transforms components developed in a 1990's-era component style to a more modern CORBA\u00a0\u2026", "num_citations": "30\n", "authors": ["2143"]}
{"title": "Maintenance and porting of software by design recovery\n", "abstract": " Enormous resources are invested in the construction of software. As needs change we would like to be able to preserve these investments. In this paper we outline a unified model for addressing the problem of change in software systems for which the original specifications are not available. Our approach is derived from a much broader paradigm for software construction. The approach is based on recovery of abstractions and design decisions made during implementation of the current version of a system. The paper consists of two major parts. We begin with a discussion of the Draco paradigm for software construction and how it can be applied to maintenance and porting problems. We follow with a discussion of our experience with a porting project using prototype implementation of these ideas.", "num_citations": "28\n", "authors": ["2143"]}
{"title": "Case study: Re-engineering C++ component models via automatic program transformation\n", "abstract": " Automated program transformation holds promise for a variety of software life cycle endeavors, particularly where the size of legacy systems makes manual code analysis, re-engineering, and evolution difficult and expensive. But constructing highly scalable transformation tools supporting modern languages in full generality is itself a painstaking and expensive process. This cost can be managed by developing a common transformation system infrastructure re-useable by derived tools that each address specific tasks, thus leveraging the infrastructure costs. This paper describes the Design Maintenance System (DMS1), a practical, commercial program analysis and transformation system, and discusses how it was employed to construct a custom modernization tool being applied to a large C++ avionics system. The tool transforms components developed in a 1990s-era component style to a more modern CORBA\u00a0\u2026", "num_citations": "21\n", "authors": ["2143"]}
{"title": "A Framework for Incremental Progress to the Application of Artificial Intelligence to Software Engineering\n", "abstract": " 1. BACKGROUNDThere is a growing interest in the potential contributions of artificial intelligence (AD to software engineering (SE). This interest is reflected in the SE literature (eg, Transactions, 1986; Rich &, Waters, 1986), and in the offering of\" AI and SE\" tracks, panels, or working groups in most SE conferences and workshops. The potential for applications of AI to SE was discussed at the recent International Conference on Software Engineering (ICSE-9, Monterey, CA, Mar. 30-Apr. 2), and at the Fourth International Workshop on Software Specification and Design (4th IWSSD, Monterey, CA, Apr. 3-4). Barry Boehm, in his remarks in the\" AI applies to SE\" session at ICSE-9, distinguished between two ways of looking at the relationship between software engineering and artificial intelligence\u2014the AI/SE and the SE/AI perspectives.", "num_citations": "19\n", "authors": ["2143"]}
{"title": "A standards-based approach to extracting business rules\n", "abstract": " \u2022 Nonsensical rule (1)\u2022 COBOL symbols are not business terms (1, 4, 6)\u2022 Direct use of implementation technology is not business vocabulary or business rule (1, 2, 3, 4, 5, 6, 7, 12)\u2022 Over specification (2, 3)\u2022 Failure to abstract variable (\u201cInventory Cat\u201d) to named business term (8, 10, 11)\u2022 Duplicated (cloned) business terms implies independence when rules may be coupled (4&7, 8&9)", "num_citations": "13\n", "authors": ["2143"]}
{"title": "Using clone detection to manage a product line\n", "abstract": " Clone detection finds code in large software systems that has been replicated and modified by hand. Remarkably, clone detection works because people copy conceptually identifiable blocks of code, and make only a few changes, which means the same syntax is detectably repeated. Each identified clone thus indicates the presence of a useful problem domain concept, and simultaneously provides an example implementation. Differences between the copies identify parameters or points of variation. Clones can thus enhance a product line development in a number of ways: removal of redundant code, lowering maintenance costs, identification of domain concepts for use in the present system or the next, and identification of parameterized reusable implementations. A slightly surprising property is that clones sometimes reveal code bugs directly by inspection of parameter bindings with inconsistent actual or conceptual types.", "num_citations": "13\n", "authors": ["2143"]}
{"title": "Invited application paper: re-engineering C++ components via automatic program transformation\n", "abstract": " Automated program transformation holds promise for a variety of software life cycle endeavors, particularly where the size of legacy systems makes code analysis, re-engineering, and evolution very difficult and expensive. But constructing transformation tools that handle the full generality of modern languages and that scale to very large applications is itself a painstaking and expensive process. This cost can be managed by developing a common transformation system infrastructure that is re-used by an array of derived tools that each address specific tasks, thus leveraging the infrastructure cost over the various tools. This talk describes DMS, a practical, commercial program analysis and transformation system, and discusses how its infrastructure was employed to construct the Boeing Migration Tool (BMT), a custom component modernization application being applied to a large C++ industrial avionics system. The\u00a0\u2026", "num_citations": "12\n", "authors": ["2143"]}
{"title": "A common conceptual model for clone detection results\n", "abstract": " As the field of code clone research grows, the continuing problem of interoperability between code clone detection and analysis tools grows with it. As a step toward solving this problem, this paper presents a draft proposal for a generic model of code clone detection results. Using an online wiki, we hope to generate discussion and solidify a shared understanding of the core concepts of the problem domain, enabling us to ultimately develop a generic data exchange format.", "num_citations": "11\n", "authors": ["2143"]}
{"title": "Industrial controller with optimized execution of relay ladder logic programs\n", "abstract": " A method of operating an industrial control system converts relay ladder logic programs into flow type programs expressed aslogical gatesconnected withwiresrepresenting variables. This formulation is converted to an efficient code structure in which changes in state of the variables are evaluated and only changes are propagated in evaluating program outputs. The net effect is many steps of evaluation in the control program are avoided during real-time operation of the program connected to controlled equipment.", "num_citations": "10\n", "authors": ["2143"]}
{"title": "Mechanical tool support for high integrity software development\n", "abstract": " Since the failure of a high integrity software system has a huge cost, it is important to develop reliable, trustworthy software for such systems that is very unlikely to fail due to coding errors. This high level of software reliability has to be preserved for the life-time of the system, even as its requirements and implementation change. One method for achieving this level of reliability is to formalize the software development process, and provide mechanical tools to support it, to ensure that no process errors are induced in the final code developed from a formal specification. Mechanical modification of the steps for constructing the system then can ensure that this high degree of reliability is preserved. We sketch a tool, the Design Maintenance System (DMS), which we are constructing. DMS provides the type of support required to perform these activities mechanically with interactive support, and discuss how this tool can help constructing and maintaining reliable, tr...", "num_citations": "10\n", "authors": ["2143"]}
{"title": "Parallel support for source code analysis and modification\n", "abstract": " Tools that analyze and enhance large-scale software systems using symbolic reasoning are computationally expensive, and yet processors are cheap. We believe that enabling tools with parallel foundations will lead to qualitatively more useful tools. We have implemented a large-scale industrial-strength program transformation system, the DMS Software Reengineering Toolkit, entirely in PARLANSE, a new parallel language. PARLANSE provides support for irregular fine-grain parallelism with zero-cost exception handling. This paper sketches the motivation for PARLANSE, its parallelism support and how it is used in a number of DMS-based applications, including parallel rewriting and attribute evaluation.", "num_citations": "9\n", "authors": ["2143"]}
{"title": "Practical issues in building knowledge-based code synthesis systems\n", "abstract": " We present some issues and lessons on building a practical\\generative reuse\" system. We discuss the cost of building a useful system, and the tensions between prototyping and production systems, often induced by scale demands.", "num_citations": "8\n", "authors": ["2143"]}
{"title": "Using transformation systems for software maintenance and reengineering\n", "abstract": " Software maintenance costs dominate software engineering costs, partly because most such engineering is done manually. Program Transformation tools leverage an engineer-provided base of\" transforms\"(a kind of generative reuse of programming knowledge), to automate analysis, modification, and generation of software, enhancing productivity and quality over conventional methods. This tutorial provides a complete overview of Program Transformation, from theory to implementation to application. Several real transformation systems will be examined, with application examples including automated detection and removal of duplicate code from large systems, and the potential for semi-automated refactoring of large object frameworks. The tutorial progresses from introductory to intermediate, but all the necessary background will be provided, so attendees need only basic software engineering knowledge and motivating experience modifying software.", "num_citations": "7\n", "authors": ["2143"]}
{"title": "Branch Coverage For Arbitrary Languages Made Easy: Transformation Systems to the Rescue\n", "abstract": " Branch coverage is an important measure of the thoroughness of testing. One can easily get tools that collect this information for mainstream languages (C, Ada) on mainstream platforms (Solaris, UNIX). Such tools are difficult to find for less widely used or interpretive languages (JavaScript) or languages used on nonstandard platforms (C in embedded systems).This paper shows the straightforward result that an industrial strength source-to-source transformation system can install test probes in software systems easily. What is not obvious is that such transformation systems exist. The consequential good news is that branch coverage testing tools can be easily built for all kinds of software in all kinds of execution environments.", "num_citations": "7\n", "authors": ["2143"]}
{"title": "Symbolic Simulation Based Techniques for Debugging Discrete Control Programs\n", "abstract": " Symbolic Simulation-Based Debugger (SSBD) is a new tool for debugging discrete control programs interactively. Given the control program and a partial model of the plant, SSBD finds the set of all possible causes for an observed transient behavior using symbolic simulation. The SSBD procedure is described in detail for a Boolean representation of relay ladder logic (RLL). A more general graph-based data and control flow representation of discrete control programs is introduced as to enable analysis of control programs using difficult-to-analyze features such as conditional jumps, looping, and temporary variables.", "num_citations": "4\n", "authors": ["2143"]}
{"title": "Calculating Software Metrics for Ladder Logic.\n", "abstract": " Ladder logic is a graphical language widely used to program Programmable Logic Controllers (PLCs). PLCs are found at the heart of most industrial control systems used in automation because they are robust, they are relatively easy to program and because they are a proven technology. However there is currently no means to measure the intrinsic properties and qualities of the code produced. This paper details a method for creating tools to calculate software metrics for ladder logic, specifically Rockwell Automation\u2019s implementation of ladder logic for its ControlLogix family of PLCs, Import-Export language version 2.6. Results obtained from these tools are briefly discussed also.", "num_citations": "3\n", "authors": ["2143"]}
{"title": "C-saw and genaweave: a two-level aspect weaving toolsuite\n", "abstract": " This demonstration will feature overviews of the C-SAW and GenAWeave projects. The first half of the presentation will introduce the concept of two-level aspect weaving, which unites amodel transformation tool with aprogram transformation engine. From models representing an avionics application, it will be shown how changes to model properties trigger corresponding adaptations to the related source code. The second half of the demonstration is focused on using a program transformation engine to perform the task of aspect weaving. In particular, several crosscutting concerns will be woven into an Object Pascal application.", "num_citations": "3\n", "authors": ["2143"]}
{"title": "Component architecture reengineering by program transformation\n", "abstract": " This paper shows a commercial program transformation system, DMS , applied to reengineer code in components of a distributed system implemented in C++. To be practical, such a tool has to not only reliably parse and regenerate C++ code, but it must be able to move program fragments from one place to another, accurately adjusting access paths to data. The demo shows the problem, sketches the solution, shows some of the source-to-source program transformation rules involved, and runs the tool against an illustrative example and real component code.", "num_citations": "3\n", "authors": ["2143"]}
{"title": "DMS: practical code generation and enhancement by program transformation\n", "abstract": " The DMS Software Reengineering Toolkit is generalized compiler technology used to carry out practical, custom automated analyses, enhancement and code generation for large-scale software systems. The core component of DMS is a rewriting engine, enabling the principal benefit: reuse of generative knowledge cast as source-to-source transformations. However, the core issue for realizing a practical system is scale, along a number of axes. DMS provides for scale in encoding and working with multiple domain languages, at multiple levels of abstraction, for million-line source/target systems, using parallel computation as a foundation.", "num_citations": "3\n", "authors": ["2143"]}
{"title": "Transformation systems: Generative reuse for software generation, maintenance and reengineering\n", "abstract": " Program Transformation tools use a provided base of \u201ctransforms\u201d (a kind of generative reuse of programming knowledge), to automate analysis, modification, and generation of software, enhancing productivity and quality over conventional methods. This tutorial provides a complete overview of Program Transformation, from theory to implementation to application. Real tools and applications are presented.", "num_citations": "3\n", "authors": ["2143"]}
{"title": "Scaling for the Design Maintenance System\u2122\n", "abstract": " The Design Maintenance System\u2122(DMS\u2122) is a transformation system intended to help maintain large-scale software systems. Most of the issues involved in its construction are driven by the scale of the problem: size of legacy language definitions, sheer volume of code, amount of knowledge involved, computational energy required. This paper sketches DMS, the scale issues being faced and the basic method of attack, and describes its status and an early application to removal of redundant code across large software systems.", "num_citations": "3\n", "authors": ["2143"]}
{"title": "Generators as Key to Effective Software Reuse\n", "abstract": " A simple and common approach to reuse in many organizations is a code library. While libraries can have beneficial productivity payoffs, the benefits are limited because libraries fail to address a number of key reuse issues: 1) how are entities other than code reused in an effective fashion? 2) how are reusable entities found? 3) how are they combined to make a reliable system? 4) how are they combined to make an efficient system? 5) how is the resulting system maintained? Generative reuse systems construct programs by combining carefully predefmed compatible components to produce application systems. Such system can reuse domain analysis by mechanizing the processing of domain problem descriptions, reuse code fragments at low and high levels of abstraction, and reuse domain engineering by having the problem description choose which components to combine, and knowing how to combine\u00a0\u2026", "num_citations": "3\n", "authors": ["2143"]}
{"title": "Reusing Design Histories via Transformation Systems\n", "abstract": " Reuse is normally focused on reuse of code. We believe that reuse of other design artifacts is at least as important as the reuse of code.", "num_citations": "3\n", "authors": ["2143"]}
{"title": "Breaking the Software Development Roadblock: Continuous Software Enhancement By Design Maintenance\n", "abstract": " The software development paradigm propounded by Semantic Designs, Inc. envisions a design-centric perspective rather than today\u2019s all too prevalent code-centric viewpoint. The Design Maintenance vision mandates notions of design and designing that are both formal and practicable. Our notion of a formal design entails three interrelated parts: specification (the artifact\u2019s functionality and performance goals); realization (including architectural design choices and ultimately, code); and rationale (justifying the realization of the specification). By practicable, we mean that each of the three parts of our formal notion of design are: 1) manipulable by both machine and software engineer; 2) scaleable for real, industrial-size systems (10\u2019s of MSLOC); 3) able to accommodate systems that are realized using multiple domain specific languages (ranging from high-level specification languages to implementations comprised of multiple target-execution languages); and 4) capable of continuous, incremental enhancement and extension.The implementation of this vision is called the Design Maintenance System\u2122 or DMS\u2122. The current release is DMS 1.0 Reengineering Toolkit, which provides infrastructure for Domain Specific Language (DSL) engineering as well as language neutral components that enable construction of large-scale, mixed-language specification analysis, transformation and synthesis tools. Original research and development for DMS was funded by an award from the Department of Commerce, NIST ATP under the Component-Based Software Initiative (NIST Cooperative Agreement Number 70NANB5H1165). The Design Maintenance\u00a0\u2026", "num_citations": "2\n", "authors": ["2143"]}
{"title": "DMS (transformational software maintenance by reuse) a production research system?(keynoted talk)\n", "abstract": " The Design Maintenance System (DMS) is a research vision and a set of tools for semiautomated construction and maintenance of medium to large scale software systems. Rather than reusing code, DMS instead applies program transformation technology,(re) uses construction knowledge from multiple domains, and (re) uses the design of the target software system.For the DMS vision to be successful in practice, not only must the related research problems be solved, but the related scale problems must also be solved. Building research systems that require scale to demonstrate practical value is 1) impractical in universities because large, long-lasting teams are discouraged, and 2) generally unfundable in the commercial sector due to long gestation times and unacceptable perceived risk. Such research systems must gain seed money from unusual sources", "num_citations": "2\n", "authors": ["2143"]}
{"title": "Software code base conversions\n", "abstract": " Current and future military avionic systems require real-time embedded software based on the latest technological advances in software tools, capabilities, and languages. However, the development time and lifecycle of avionic systems is so long, that the tools, processes, methodologies, and languages used by the system developers are often obsolete by the time the systems need significant upgrades or replacement. Hence, software obsolescence is a major issue faced by many avionic systems. Previously, avionics programs have tackled software obsolescence using different approaches. These approaches have included code conversions by hand, which are costly and time consuming, scripting tools/languages which have scalability problems, emulators which involve re-engineering of the peripheral code base and retention of the obsolete code engineering environment, and software wrappers which are not\u00a0\u2026", "num_citations": "1\n", "authors": ["2143"]}
{"title": "Automated Program and Model Transformation Technology\n", "abstract": " Automated Program and Model Transformation Technology Page 1 \u00a9 Semantic Designs 2005 1 Automated Program and Model Transformation Technology Ira D. Baxter, Ph.D. idbaxter@semanticdesigns.com Jeff Gray, Ph.D. gray@cis.uab.edu Page 2 \u00a9 Semantic Designs 2005 2 Tutorial Overview \u2022 Part I. Program Transformation \u2013 Transformation Tool overview and Relevance to ADM \u2013 Theory of transformation systems \u2013 Some transformation systems and applications \u2022 Part II. Model Transformation \u2013 Model Transformation to Support Model Evolution \u2013 Model-Driven Program Transformation Page 3 \u00a9 Semantic Designs 2005 3 Who are we? \u2022 Dr. Ira D. Baxter \u2013 CEO of Semantic Designs \u2013 35 years Software Engineering: OS, Compilers, Transform Systems, Reuse \u2013 Architect of Design Maintenance System (DMS) \u2022 Dr. Jeff Gray \u2013 CIS Department, University of Alabama at Birmingham \u2022 Assistant Professor \u2022 Research \u2026", "num_citations": "1\n", "authors": ["2143"]}
{"title": "C++ component model reengineering by automatic transformation\n", "abstract": " Reengineering legacy software to use a modern component model can be accomplished by repeatedly applying a large number of semantically-sensitive program transformations, some of which synthesize new code structures, while others modify legacy code and meld it into the new framework. Using machinery that automates the process conquers the problems of massive scale, soundness, and regularity, and furthermore reduces time to completion by overlapping the project\u2019s design and implementation phases. This article describes experiences in automating the reengineering of a collection of avionics components to conform to a Common Object Request Broker Architecture-like component framework, using Design Maintenance System, a program analysis and transformation system designed for building software engineering tools for large systems.", "num_citations": "1\n", "authors": ["2143"]}
{"title": "DMS (The Design Maintenance System) A Tool for Automating Software Quality Enhancement\n", "abstract": " This white paper sketches how a new type of software engineering technology can be used to automate a variety of software quality enhancement activities. This technology, a kind of extremely configurable, generalized compiler, is packaged in a tool named DMS. Automation is enabled by \u201cteaching\u201d DMS critical concepts of the application problem domain, properties of the application programming language, and methodological softwareengineering problem solving approaches. Value comes from using DMS to apply this organization-specific knowledge to frequent activities of its engineers.In essence, DMS is reusing deep engineering knowledge (as opposed to tools that simply reuse \u201ccode\u201d). This amplifies the effect of skilled engineers, by allowing them to focus on the deep engineering issues rather than the microscopic details of carrying out such engineering tasks, and by allowing them to experiment more\u00a0\u2026", "num_citations": "1\n", "authors": ["2143"]}
{"title": "Using Domain-Specific, Abstract Parallelism\n", "abstract": " Discovery of potential parallelism in low level code is difficult, especially in the absence of problem domain knowledge. Au alternative is to explicitly represent maximal potential parallelism in atmtra_t program components. A transformation system refines a program composed of such components into ac oncrete program. We discuss an experimental system in which we are installing such facilities. An example refinement sequence is provided.", "num_citations": "1\n", "authors": ["2143"]}