{"title": "Identifying thresholds for object-oriented software metrics\n", "abstract": " Despite the importance of software metrics and the large number of proposed metrics, they have not been widely applied in industry yet. One reason might be that, for most metrics, the range of expected values, i.e., reference values are not known. This paper presents results of a study on the structure of a large collection of open-source programs developed in Java, of varying sizes and from different application domains. The aim of this work is the definition of thresholds for a set of object-oriented software metrics, namely: LCOM, DIT, coupling factor, afferent couplings, number of public methods, and number of public fields. We carried out an experiment to evaluate the practical use of the proposed thresholds. The results of this evaluation indicate that the proposed thresholds can support the identification of classes which violate design principles, as well as the identification of well-designed classes. The method\u00a0\u2026", "num_citations": "213\n", "authors": ["1230"]}
{"title": "A catalogue of thresholds for object-oriented software metrics\n", "abstract": " Thresholds for the majority of software metrics are still not known. This might be the reason why a measurement method that should be part of a software quality assessment process is not yet present in object-oriented software industry. In this work, we applied an empirical method to 111 system dataset, identifying thresholds for 17 object-oriented software metrics. Furthermore, we propose some improvements in this employed method. Differently from previous work, we have developed a catalogue of thresholds that gathers a greater amount of object-oriented software metrics, allowing the assessment of methods, classes and packages. Our approach suggests three ranges in the thresholds: Good/Common, Regular/Casual and Bad/Uncommon. Although they do not necessarily express the best practices in Software Engineering, they reflect a quality standard followed by most of the evaluated software. To evaluate our catalogue, we present a case study which shows its application in the evaluation of a proprietary software, in contrast with the developers consensus about its internal quality. Results show that our thresholds are capable of indicating the real panorama of the evaluated software.", "num_citations": "51\n", "authors": ["1230"]}
{"title": "A comparison of three algorithms for computing truck factors\n", "abstract": " Truck Factor (also known as Bus Factor or Lottery Number) is the minimal number of developers that have to be hit by a truck (or leave) before a project is incapacitated. Therefore, it is a measure that reveals the concentration of knowledge and the key developers in a project. Due to the importance of this information to project managers, algorithms were proposed to automatically compute Truck Factors, using maintenance activity data extracted from version control systems. However, to the best of our knowledge, we still lack studies that compare the accuracy of the results produced by such algorithms. Therefore, in this paper, we evaluate and compare the results of three Truck Factor algorithms. To this end, we empirically determine the truck factors of 35 open-source systems by consulting their developers. Our results show that two algorithms are very accurate, especially when the systems have a small Truck\u00a0\u2026", "num_citations": "23\n", "authors": ["1230"]}
{"title": "Software evolution characterization-a complex network approach\n", "abstract": " A evolu\u00e7\u00e3o do software tem sido objeto de pesquisas nas \u00faltimos d\u00e9cadas, revelando que um sistema de software tem crescimento cont\u00ednuo, continuando mudan\u00e7as, aumentando a complexidade e diminuindo a qualidade. No entanto, o conhecimento sobre como esse processo ocorre ainda n\u00e3o est\u00e1 consolidado. Este artigo apresenta o resultados de um estudo sobre caracteriza\u00e7\u00e3o da evolu\u00e7\u00e3o de software com base em conceitos de Redes Complexas. Analisamos 16 sistemas de software de c\u00f3digo aberto e um aplica\u00e7\u00e3o comercial, num total de 129 vers\u00f5es. Os resultados deste estudo mostram que: a densidade de uma rede de software diminui \u00e0 medida que o sistema de software cresce; o di\u00e2metro dessas redes \u00e9 curto; as classes com grau superior manter esse status; tais classes s\u00e3o inst\u00e1veis\u200b\u200b e sua coes\u00e3o interna se degrada. Nossas investiga\u00e7\u00f5es tamb\u00e9m revelaram um quadro interessante que modela a estrutura macrosc\u00f3pica das redes de software. N\u00f3s a cham\u00e1vamos de casinha.", "num_citations": "11\n", "authors": ["1230"]}
{"title": "A systematic literature mapping on the relationship between design patterns and bad smells\n", "abstract": " Bad Smells are symptoms that appear in the source code of a software system and may indicate a structural problem that requires code refactoring. Design patterns are solutions known as good practices that help building software systems with high quality and flexibility. Intuitively, it is possible to assume that the use of design patterns might avoid bad smells. Intriguingly, some recent studies have pointed out that this assumption is not true. This paper presents a systematic literature mapping of studies that investigate the relationship between design patterns and bad smells. We identified 16 papers which were categorized into three different approaches: impact on software quality, refactoring and co-occurrence. Amongst these three approaches, the co-occurrence relationship is the less explored in the literature. In addition, we identified that studies focusing on co-occurrence between design patterns and bad\u00a0\u2026", "num_citations": "10\n", "authors": ["1230"]}
{"title": "The usefulness of software metric thresholds for detection of bad smells and fault prediction\n", "abstract": " ContextSoftware metrics may be an effective tool to assess the quality of software, but to guide their use it is important to define their thresholds. Bad smells and fault also impact the quality of software. Extracting metrics from software systems is relatively low cost since there are tools widely used for this purpose, which makes feasible applying software metrics to identify bad smells and to predict faults.ObjectiveTo inspect whether thresholds of object-oriented metrics may be used to aid bad smells detection and fault predictions.MethodTo direct this research, we have defined three research questions (RQ), two related to identification of bad smells, and one for identifying fault in software systems. To answer these RQs, we have proposed detection strategies for the bad smells: Large Class, Long Method, Data Class, Feature Envy, and Refused Bequest, based on metrics and their thresholds. To assess the quality of\u00a0\u2026", "num_citations": "9\n", "authors": ["1230"]}
{"title": "Evaluating co-occurrence of GOF design patterns with god class and long method bad smells\n", "abstract": " Design patterns are general reusable solutions to common recurring problems in software projects. These solutions, when correctly applied, are supposed to enhance modular and flexible structures in software. The aim of this work is to study the occurrences of God Class and Long Method bad smells in software systems developed with design patterns. To achieve this aim, we carried out a study with five Java project, in order to:(i) investigate if the use of GOF design patterns avoid the occurrences of the bad smells God Class and Long Method,(ii) identify co-occurrences of the GOF design patterns with these bad smells, and (iii) identify the main situations that lead software systems to present these co-occurrences. The results obtained suggest that Composite and Factory Method have a low co-occurrence with these bad smells, and Template Method and Observer have a high co-occurrence with God Class and Long Method, respectively. In addition, we have identified that the misuse of design patterns and the scattering and crosscutting concerns has contributed to the emergence of such co-occurrences.", "num_citations": "9\n", "authors": ["1230"]}
{"title": "Reference values for object-oriented software metrics\n", "abstract": " Although a large quantity of OO software has been produced, little is known about the actual structure of this type of software. There is a large number of proposed metrics for OO software, but they are still not employed effectively in industry. A reason for this is that there are few data published about this topic, and typical values of the metrics are not known. This paper presents the results of a study carried out on a large collection of open-source software developed in Java. The objective of this study was to identify characteristics of this type of software in terms of a set of metrics for OO software, such as connectivity, class cohesion and depth of a class in its inheritance tree. The results of the study provide important insights on the structure of open-source OO software and exhibit values that can be taken as baselines for the values of measures of the metrics.", "num_citations": "9\n", "authors": ["1230"]}
{"title": "Avalia\u00e7\u00e3o de conectividade em sistemas orientados por objetos\n", "abstract": " Dentre os fatores de avalia\u00e7ao da qualidade de um software, destaca-se a manutenibilidade, a medida da facilidade de realizar sua manuten\u00e7ao. A manuten\u00e7ao de software \u00e9 respons\u00e1vel pela maior parte do custo total de um sistema. Desta forma, faz-se importante a obten\u00e7ao de recursos que contribuam para a cria\u00e7ao de software cuja manuten\u00e7ao seja mais f\u00e1cil. Dentre outros aspectos, a obten\u00e7ao de software com esta caracter\u0131stica \u00e9 proporcionada principalmente pelo projeto de software que vise estrutura flex\u0131vel e est\u00e1vel, na qual o grau de interdepend\u00eancia entre as partes constituintes do software, seus m\u00f3dulos, seja o menor poss\u0131vel. Quanto maior o grau de conectividade de um software, mais r\u0131gida a sua estrutura, menor a manutenibilidade e maior o custo do sistema. A orienta\u00e7ao por objetos \u00e9 um paradigma de constru\u00e7ao de software caracterizado por potencializar a obten\u00e7ao de software de alta qualidade, favorecendo aspectos como modularidade, manutenibilidade e reusabilidade.Este trabalho tem como tese que a conectividade \u00e9 o fator preponderante na avalia\u00e7ao da qualidade estrutural de um software e, conseq\u00fcentemente, deve ser tida como fator de grande import\u00e2ncia na manuten\u00e7ao e no custo de um sistema. O objetivo principal desta disserta\u00e7ao \u00e9 a proposta de um modelo de avalia\u00e7ao de conectividade em software orientado por objetos, bem como a constru\u00e7ao de uma ferramenta de coleta de m\u00e9tricas que viabiliza a aplica\u00e7ao do modelo proposto para softwares implementados na linguagem Java.", "num_citations": "9\n", "authors": ["1230"]}
{"title": "Algorithms for estimating truck factors: a comparative study\n", "abstract": " Software development is a knowledge-intensive industry. For this reason, concentration of knowledge in software projects tends to be very risky, which increases the relevance of strategies that reveal how source code knowledge is distributed among team members. The truck factor (also known as the bus factor) is an increasingly popular concept\u2014proposed by practitioners\u2014that indicates the minimal number of developers that have to be hit by a truck (or leave the team) before a project is incapacitated. Therefore, it is a measure that reveals the concentration of knowledge and the key developers in a project. Due to the importance of this concept, algorithms have been proposed to automatically compute truck factors, using maintenance activity data extracted from version control systems. However, we still lack large studies that assess the results of truck factor algorithms. To fulfill this gap in the literature, this paper\u00a0\u2026", "num_citations": "8\n", "authors": ["1230"]}
{"title": "An exploratory study on cooccurrence of design patterns and bad smells using software metrics\n", "abstract": " A design pattern is a general reusable solution to commonly recurring problems in software projects. Bad smells are symptoms existing in the source code that possibly indicate the presence of a structural problem that requires code refactoring. Although design pattern and bad smells be different concepts, literature has shown that they may be related and cooccur during the evolution of a software system. This paper presents an empirical study that investigates cooccurrences of design patterns and bad smells as well as identifies the main factors that contribute to the emergence of the relationship between them. We carried out a case study with five Java systems to: (1) investigate if the use of design pattern reduces bad smell occurrence, (2) identify cooccurrences of design patterns and bad smells, and (3) identify situations that contribute for the cooccurrence emergence. As the main result, we found that the\u00a0\u2026", "num_citations": "8\n", "authors": ["1230"]}
{"title": "The evolving structures of software systems\n", "abstract": " Software maintenance is an important problem because software is an evolving complex system. To make software maintenance viable, it is important to know the real nature of the systems we have to deal with. Little House is a model that provides a macroscopic view of software systems. According to Little House, a software system can be modeled as a graph with five components. This model is intended to be an approach to improve the understanding and the analysis of software structures. However, to achieve this aim, it is necessary to determine its characteristics and its implications. This paper presents the results of an empirical study aiming to characterize software evolution by means of Little House and software metrics. We analyzed several versions of 13 open source software systems, which have been developed over nearly 10 years. The results of the study show that there are two main components of\u00a0\u2026", "num_citations": "8\n", "authors": ["1230"]}
{"title": "Reestrutura\u00e7\u00e3o de software dirigida por conectividade para redu\u00e7\u00e3o de custo de manuten\u00e7\u00e3o\n", "abstract": " Most of the software cost is due to maintenance. In the last years, there has been a great deal of interest in developing cost estimation and effort prediction instruments for software maintenance. This work proposes that module connectivity", "num_citations": "8\n", "authors": ["1230"]}
{"title": "FindSmells: flexible composition of bad smell detection strategies\n", "abstract": " Bad smells are symptoms of problems in the source code of software systems. They may harm the maintenance and evolution of systems on different levels. Thus, detecting smells is essential in order to support the software quality improvement. Since even small systems may contain several bad smell instances, and considering that developers have to prioritize their elimination, its automated detection is a necessary support for developers. Regarding that, detection strategies have been proposed to formalize rules to detect specific bad smells, such as Large Class and Feature Envy. Several tools like JDeodorant and JSpIRIT implement these strategies but, in general, they do not provide full customization of the formal rules that define a detection strategy. In this paper, we propose FindSmells, a tool for detecting bad smells in software systems through software metrics and their thresholds. With FindSmells, the user\u00a0\u2026", "num_citations": "6\n", "authors": ["1230"]}
{"title": "Statistical dataset on software metrics in object-oriented systems\n", "abstract": " This paper presents a set of statistical data on the software metrics of object-oriented systems. The data were generated from the Qualitas.class Corpus, which gathered a large amount of metrics data from the 111 systems included in Qualitas Corpus. We used the R project for Statistical Computing to generate 6 statistical graphs, 4 summarization/aggregation tables and an R script, for each of the 21 metrics evaluated in each of the 111 systems. This amounted to 13,986 graphs, 8,800 tables and 2,200 R scripts. We also utilized EasyFit to fit a large number of distributions to each dataset, which in turn provided the best fitting statistical distribution, as well as the fit ranking. We also provide a MySQL database dump that normalizes the metric measures and facilitates data manipulation tasks such as filtering and aggregation. By making this set available, we intend to help researchers in their work on software metrics.", "num_citations": "6\n", "authors": ["1230"]}
{"title": "Um modelo de predi\u00e7\u00e3o de amplitude da propaga\u00e7\u00e3o de modifica\u00e7\u00f5es contratuais em software orientado por objetos\n", "abstract": " Este trabalho apresenta um novo modelo de avalia\u00e7\u00e3o e predi\u00e7\u00e3o de manutenibilidade de software. O modelo, denominado K3B, realiza predi\u00e7\u00e3o de amplitude da propaga\u00e7\u00e3o de modifica\u00e7\u00f5es contratuais em software orientado por objetos. Modifica\u00e7\u00e3o contratual \u00e9 aquela ocorrida em uma classe de forma a alterar o seu contrato, que corresponde aos servi\u00e7os da classe, e \u00e0s pr\u00e9 e p\u00f3s-condi\u00e7\u00f5es desses servi\u00e7os. Pr\u00e9condi\u00e7\u00e3o \u00e9 uma condi\u00e7\u00e3o que deve ser satisfeita para que o servi\u00e7o seja realizado com sucesso. As p\u00f3s-condi\u00e7\u00f5es de um servi\u00e7o correspondem ao estado do sistema ap\u00f3s a realiza\u00e7\u00e3o do servi\u00e7o. K3B fornece o n\u00famero esperado de passos de modifica\u00e7\u00f5es no software dado que um n\u00famero inicial de m\u00f3dulos sofrer\u00e1 modifica\u00e7\u00f5es. O modelo \u00e9 definido em termos do n\u00famero total de m\u00f3dulos do software, do n\u00famero de m\u00f3dulos que ser\u00e3o inicialmente modificados e de m\u00e9tricas do software, tais como coes\u00e3o, acoplamento e conectividade.Para dar suporte ao uso de K3B e \u00e0 sua concep\u00e7\u00e3o, este trabalho tamb\u00e9m prop\u00f5e uma m\u00e9trica para avalia\u00e7\u00e3o de coes\u00e3o de classes denominada Coes\u00e3o de Responsabilidade, e apresenta os resultados de um estudo que identifica valores refer\u00eancia para um conjunto de m\u00e9tricas de software orientado por objetos, em particular aquelas que podem ser associadas \u00e0 K3B. Al\u00e9m disso, relata os resultados de um estudo sobre os grafos de depend\u00eancia entre m\u00f3dulos que revela importantes propriedades da natureza evolutiva de softwares e identifica a estrutura macrosc\u00f3pica desses grafos. O modelo K3B foi avaliado empiricamente a partir de dados de um conjunto de softwares abertos. Os\u00a0\u2026", "num_citations": "6\n", "authors": ["1230"]}
{"title": "Uma iniciativa para apoiar e empoderar alunas de ensino t\u00e9cnico e de gradua\u00e7\u00e3o em computa\u00e7\u00e3o\n", "abstract": " Este artigo apresenta um projeto criado por professoras em uma institui\u00e7\u00e3o de ensino que possui dois cursos t\u00e9cnicos e uma gradua\u00e7\u00e3o na \u00e1rea de Computa\u00e7\u00e3o. \u00c9 descrito um relato de experi\u00eancias a partir das a\u00e7\u00f5es no \u00e2mbito do projeto direcionadas a essas alunas para incentiv\u00e1-las e apoi\u00e1-las a concluir seus cursos e encoraj\u00e1-las para o mercado de trabalho. Como resultado do projeto, espera-se criar e consolidar uma rede de apoio m\u00fatuo entre as alunas desses cursos, bem como um grupo de orienta\u00e7\u00e3o a elas, com atividades sistem\u00e1ticas supervisionadas pelas professoras.", "num_citations": "5\n", "authors": ["1230"]}
{"title": "A model for estimating change propagation in software\n", "abstract": " A major issue in software maintenance is change propagation. A software engineer should be able to assess the impact of a change in a software system, so that the effort to accomplish the maintenance may be properly estimated. We define a novel model, named K3B, for estimating change propagation impact. The model aims to predict how far a set of changes will propagate throughout the system. K3B is a stochastic model that has input parameters about the system and the number of modules which will be initially changed. K3B returns the estimated number of change steps, considering that a module may be changed more than once during a modification process. We provide the implementation of K3B for object-oriented programs. We compare our implementation with data from an artificial scenario, given by simulation, as well as with data from a real scenario, given by historical data. We found strong\u00a0\u2026", "num_citations": "5\n", "authors": ["1230"]}
{"title": "Analysis of Coupling Evolution on Open Source Systems\n", "abstract": " Software evolution is an intrinsic process of the software life cycle. The comprehension of this process is a central research topic in Software Engineering. It is widely accepted that as a software system evolves, its internal quality declines, and its complexity increases. However, there is a gap in the comprehension of how this process occurs in a fine-grained view. In this work, we apply a software metric approach to investigate how the internal quality of object-oriented software systems evolves in the aspect of coupling. More specifically, we analyze (i) how the coupling behavior may be described over the software evolution,(ii) how the coupling behavior affects the reusability and complexity of the systems, and (iii) the percentage of classes from the systems that directly impacts on the coupling evolution. The results and observations of this study are compiled in seven properties of coupling evolution, among which\u00a0\u2026", "num_citations": "4\n", "authors": ["1230"]}
{"title": "A tool for detection of co-occurrences between design patterns and bad smells\n", "abstract": " A design pattern is a general reusable solution to recurring problems in software design. These solutions are considered good programming practices and aim to produce flexible, extensible and maintainable software. Bad Smells are symptoms present in the software source code that indicate occurrence of possible problems that can impair the quality of the project. Despite that these two structures may have opposite concepts, studies have indicated that they may present relations of co-occurrence during the implementation phase. Since these relationships represent the degenerate structure of a design pattern and consequently reduce the quality of the software, they should be identified and removed. In this paper, we propose Design Pattern Smell, a tool for co-occurrences detection between design patterns and bad smell in software systems. With Design Pattern Smell, the user may identify the artifacts that hold such relationships and the intensity with which they occur in the design patterns analyzed. In addition, Design Pattern Smell may be used as a refactoring guide, since all artifacts detected with co-occurrences are displayed to the user. Video: https://youtu. be/hFwyId9nHnM", "num_citations": "4\n", "authors": ["1230"]}
{"title": "Mapping the potential change impact in object-oriented software\n", "abstract": " The present work brings the results of a study carried out to investigate the change propagation impact in object-oriented programs. We have performed this analysis by considering a macroscopic topology of object-oriented program called Little House. According to this topology, the dependence graph of classes can be partitioned into six components, namely: In, LSCC, Out, Tendrils, Tubes, and Disconnected. We analyzed the data of 12 open source Java projects, in a total of 54 versions of them. The results of our study suggest that LSCC and Out concentrate the classes with the far highest potential change impact. We have also observed that this characteristic remains during the software evolution.", "num_citations": "4\n", "authors": ["1230"]}
{"title": "M\u00e9trica de Coes\u00e3o de Responsabilidade-A Utilidade de M\u00e9trica de Coes\u00e3o na Identifica\u00e7\u00e3o de Classes com Problemas Estruturais\n", "abstract": " Muitas m\u00e9tricas de coes\u00e3o de classe t\u00eam sido propostas na literatura. Entretanto, ainda n\u00e3o ha um consenso sobre a melhor abordagem para medir coes\u00e3o. Uma quest\u00e3o importante nesse t\u00f3pico e que o grau de coes\u00e3o interna de uma classe e dificilmente capturado por meio autom\u00e1tico, pois esse tipo de avalia\u00e7\u00e3o e estreitamente dependente do conhecimento do dom\u00ednio de problema da aplica\u00e7\u00e3o. Os resultados relatados neste artigo identificam evid\u00eancias de que, embora m\u00e9tricas de coes\u00e3o possam n\u00e3o ser indicadores precisos, elas s\u00e3o \u00fateis para a avalia\u00e7\u00e3o da qualidade estrutural de uma classe. S\u00e3o avaliadas quatro m\u00e9tricas: LCOM, LCOM4, TCC e COR. Coes\u00e3o de Responsabilidade (COR) e definida neste trabalho como um indicador do n\u00famero de responsabilidades implementadas por uma classe. A m\u00e9trica COR foi definida de maneira a tornar mais simples a interpreta\u00e7\u00e3o dos resultados da avalia\u00e7\u00e3o da coes\u00e3o interna de uma classe. Os resultados deste trabalho mostram que a aplica\u00e7\u00e3o de m\u00e9tricas como COR podem auxiliar a identificar classes com problemas estruturais.", "num_citations": "4\n", "authors": ["1230"]}
{"title": "Applying software metric thresholds for detection of bad smells\n", "abstract": " Software metrics can be an effective measurement tool to assess the quality of software. In the literature, there are a lot of software metrics applicable to systems implemented in different paradigms like Objects Oriented Programming (OOP). To guide the use of these metrics in the evaluation of the quality of software systems, it is important to define their thresholds. The aim of this study is to investigate the effectiveness of the thresholds in the evaluation of the quality of object oriented software. To do that, we used a threshold catalog of 18 software metrics derived from 100 software systems to define detection strategies for five bad smells. They are: Large Class, Long Method, Data Class, Feature Envy and Refused Bequest. We investigate the effectiveness of the thresholds in detection analysis of 12 software systems using these strategies. The results obtained by the proposed strategies were compared with the\u00a0\u2026", "num_citations": "3\n", "authors": ["1230"]}
{"title": "The dance of classes-A stochastic model for software structure evolution\n", "abstract": " In this study, we investigate software structure evolution and growth. We represent software structure by means of a generic macro-topology called Little House, which models the dependencies among classes of object-oriented software systems. We, then, define a stochastic model to predict the way software architectures evolve. The model estimates how the classes of object-oriented programs get connected one to another along the evolution of the systems. To define the model, we analyzed data from 81 versions of six Java based projects. We analyzed each pair of sequential versions, for each project, in order to depict a pattern of software structure evolution based on Little House. To evaluate the model, we performed two experiments: one with the data used to derive the model, and another with data of 35 releases, in total, of four open-source Java project. In both experiments, we found a very low rate of error\u00a0\u2026", "num_citations": "3\n", "authors": ["1230"]}
{"title": "A generic macroscopic topology of software networks-a quantitative evaluation\n", "abstract": " The dependence among modules in a software system usually is represented as a network, in which the nodes are the modules, and the edges are the connections between the modules. The relationships among modules in software systems are hard to assess, especially in large programs. Knowing the nature of the software system structures is very important to improve maintenance tasks and other challenging tasks in software development. A previous work of the authors of this paper has defined a model to the topology of software networks, named Little House. This model is a generic macroscopic view of software systems, and it is an adaptation of the well-known Bow-tie model. According to Little House, a software network can be partitioned into six components, in such a way there is a special pattern of connections among them. This paper describes the results of a quantitative evaluation of Little House. The\u00a0\u2026", "num_citations": "3\n", "authors": ["1230"]}
{"title": "Software engineering evolution: The history told by icse\n", "abstract": " Software Engineering knowledge has continuously grown at a very high speed. In this work, we aim to provide a perspective on how the body of knowledge of Software Engineering has evolved. For this purpose, we analyzed data of 3,300 works published from 1988 to 2018 in one of the most important conferences on Software Engineering, the International Conference on Software Engineering (ICSE). We identified the main topics investigated in Software Engineering and how the investigation of those topics has evolved over the time. The results bring a compilation of Software Engineering evolution that may be of value to the software community.", "num_citations": "2\n", "authors": ["1230"]}
{"title": "Characterization of public opinion on political events in brazil based on twitter data\n", "abstract": " In this work we characterize Brazilian online population sentiment on different political events using data from Twitter and we also discuss the advantages of the usage of this social media as data source. The results demonstrated that the Brazilian population uses Twitter to manifest their political view, expressing both positive and negative sentiments regarding political events. This kind of characterization may contribute to build a critical opinion of Brazilian people, once they would not be limited by what is being divulgated by typical media, such as television and newspapers. Additionally, we reinforced the applicability of social media, as Twitter, to make this kind of characterization.", "num_citations": "2\n", "authors": ["1230"]}
{"title": "A Comparative Study of Algorithms for Estimating Truck Factor\n", "abstract": " In modern software projects, it is crucial to have reliable data about how knowledge on the source code is distributed among the team members. This information can help for example to avoid \"islands of knowledge\" and to prevent the risks associated to the loss of key developers. Truck factor is a key measure proposed to estimate such risks. Basically, truck factor (aka bus factor) designates the minimal number of developers that have to be hit by a truck (or quit) before a project is incapacitated. Although being a key measure of the concentration of information among team members, we still have few algorithms proposed to estimate truck factors. More importantly, we lack rigorous comparisons of the existing algorithms. Therefore, in this paper we provide a comparative study of the two main algorithms proposed in the literature to estimate truck factors. For this purpose, we rely on a large dataset of 133 popular\u00a0\u2026", "num_citations": "2\n", "authors": ["1230"]}
{"title": "Raftool-ferramenta de filtragem de m\u00e9todos, classes e pacotes com medi\u00e7\u00f5es incomuns de m\u00e9tricas de software\n", "abstract": " RAFTool - Ferramenta de Filtragem de M\u00e9todos, Classes e Pacotes com Medi\u00e7\u00f5es Incomuns de M\u00e9tricas de Software Page 1 Fil\u00f3 et al. (2014) Introdu\u00e7\u00e3o De ni\u00e7\u00e3o do Problema Estado da Arte Objetivo da RAFTool Valores Refer\u00eancia O Processo de Medi\u00e7\u00e3o no MPS.BR Requisitos Instancia\u00e7\u00e3o Filtragem de M\u00e9todos, Classes ou Pacotes Visualiza\u00e7\u00e3o e Exporta\u00e7\u00e3o Cen\u00e1rios de Uso Conclus\u00e3o RAFTool - Ferramenta de Filtragem de M\u00e9todos, Classes e Pacotes com Medi\u00e7\u00f5es Incomuns de M\u00e9tricas de Software Tarc\u00edsio Fil\u00f3 1 Mariza Bigonha 1 Kecia Ferreira 2 1Programa de P\u00f3s-Gradua\u00e7\u00e3o em Ci\u00eancias da Computa\u00e7\u00e3o (PPGCC) Departamento de Ci\u00eancia da Computa\u00e7\u00e3o - Universidade Federal de Minas Gerais (UFMG) - Belo Horizonte - MG - Brasil 2Departamento de Computa\u00e7\u00e3o - Centro Federal de Educa\u00e7\u00e3o Tecnol\u00f3gica de Minas Gerais (CEFET-MG) - Belo Horizonte - MG - Brasil 02 de dezembro de 2014 \u2026", "num_citations": "2\n", "authors": ["1230"]}
{"title": "On The Gap Between Software Maintenance Theory and Practitioners' Approaches\n", "abstract": " The way practitioners perform maintenance tasks in practice is little known by researchers. In turn, practitioners are not always up to date with the proposals provided by the research community. This work investigates the gap between software maintenance techniques proposed by the research community and the software maintenance practice. We carried out a survey with 112 practitioners from 92 companies and 12 countries. We concentrate on analyzing if and how practitioners understand and apply the following subjects: bad smells, refactoring, software metrics, and change impact analysis. This study shows that there is a large gap between research approaches and industry practice in those subjects, especially in change impact analysis and software metrics.", "num_citations": "1\n", "authors": ["1230"]}
{"title": "Oracles of Bad Smells: a Systematic Literature Review\n", "abstract": " A bad smell is an evidence of a design problem that may be harmful to the software maintenance. Several studies have been carried out to aid the identification of bad smells, by defining approaches or tools. Usually, the evaluation of these studies' results relies on data of oracles bad smells. An oracle is a set of data of bad smells found in a given software system. Such data serves as a referential template or a benchmark to evaluate the proposals on detecting bad smells. The availability and the quality of bad smell oracles are crucial to assert the quality of detection strategies of bad smells. This study aims to compile the bad smell oracles proposed in the literature. To achieve this, we conducted a Systematic Literature Review (SLR) to identify bad smell oracles and their characteristics. The main result of this study is a catalog of bad smell oracles that may be useful for research on bad smells, especially the studies\u00a0\u2026", "num_citations": "1\n", "authors": ["1230"]}
{"title": "Identifica\u00e7\u00e3o de Padr\u00f5es de Caracter\u00edsticas Estruturais em Software Orientado a Objetos\n", "abstract": " Manter os softwares criados em funcionamento e com qualidade \u00e9 um grande desafio. A compreens\u00e3o profunda do software pode favorecer o controle dos impactos das modifica\u00e7\u00f5es realizadas e a gest\u00e3o do processo de manunten\u00e7\u00e3o de software. Todavia, para alcan\u00e7ar isso, s\u00e3o necess\u00e1rios recursos que permitam a avalia\u00e7\u00e3o apropriada do software. Buscando contribuir com um recurso desta natureza, um trabalho anterior das autoras do presente artigo define um modelo, denominado Little House, que consiste em uma figura macrosc\u00f3pica gen\u00e9rica das estruturas de software orientado a objetos. Little House modela o software como um grafo com cinco v\u00e9rtices, denominados componentes, que correspondem a conjuntos de classes conectados entre si. O presente trabalho tem por objetivo caracterizar qualitativamente esses componentes por meio de estudos de caso com cinco softwares Java. O estudo consistiu em inspecionar manualmente todas as classes a fim de identificar seus prop\u00f3sitos. A an\u00e1lise dos resultados revela como as classes dos softwares s\u00e3o distribu\u00eddas entre os componentes de Little House conforme os prop\u00f3sitos delas. Os resultados deste trabalho identificam padr\u00f5es de caracter\u00edsticas estruturais de software que indicam como os softwares com os quais temos que lidar s\u00e3o estruturados.", "num_citations": "1\n", "authors": ["1230"]}
{"title": "Valores Refer\u00eancia para M\u00e9tricas de Software Orientado por Objetos\n", "abstract": " Although a large quantity of OO software has been produced, little is known about the actual structure of this type of software. There is a large number of proposed metrics for OO software, but they are still not employed effectively in industry. A reason for this is that there are few data published about this topic, and typical values of the metrics are not known. This paper presents the results of a study carried out on a large collection of open-source software developed in Java. The objective of this study was to identify characteristics of this type of software in terms of a set of metrics for OO software, such as connectivity, class cohesion and depth of a class in its inheritance tree. The results of the study provide important insights on the structure of open-source OO software and exhibit values that can be taken as baselines for the values of measures of the metrics.", "num_citations": "1\n", "authors": ["1230"]}
{"title": "Modularidade em Sistemas Orientados por Objetos\n", "abstract": " Este livro foi escrito para ser utilizado principalmente por alunos de cursos de gradua\u00e7ao na \u00e1rea de computa\u00e7ao, como ci\u00eancia da computa\u00e7ao, matem\u00e1tica computacional, engenharia de computa\u00e7ao, sistemas de informa\u00e7ao e outros. Tamb\u00e9m pode ser utilizado por alunos de p\u00f3s-gradua\u00e7ao, eventualmente complementado com outras refer\u00eancias que abordem alguns assuntos com maior profundidade ou que apresentem alguns t\u00f3picos nao cobertos aqui. Al\u00e9m disso, pode ser \u00fatil para profissionais da \u00e1rea de computa\u00e7ao em geral, tanto para aqueles que desejem fazer uma revisao quanto para aqueles que queiram ter um primeiro contato com a \u00e1rea. viii", "num_citations": "1\n", "authors": ["1230"]}