{"title": "Using software testing to move students from trial-and-error to reflection-in-action\n", "abstract": " Introductory computer science students rely on a trial and error approach to fixing errors and debugging for too long. Moving to a reflection in action strategy can help students become more successful. Traditional programming assignments are usually assessed in a way that ignores the skills needed for reflection in action, but software testing promotes the hypothesis-forming and experimental validation that are central to this mode of learning. By changing the way assignments are assessed--where students are responsible for demonstrating correctness through testing, and then assessed on how well they achieve this goal--it is possible to reinforce desired skills. Automated feedback can also play a valuable role in encouraging students while also showing them where they can improve.", "num_citations": "328\n", "authors": ["2183"]}
{"title": "Web-CAT: automatically grading programming assignments\n", "abstract": " This demonstration introduces participants to using Web-CAT, an open-source automated grading system. Web-CAT is customizable and extensible, allowing it to support a wide variety of programming languages and assessment strategies. Web-CAT is most well-known as the system that\" grades students on how well they test their own code,\" with experimental evidence that it offers greater learning benefits than more traditional output-comparison grading. Participants will learn how to set up courses, prepare reference tests, set up assignments, and allow graders to manually grade for design.", "num_citations": "251\n", "authors": ["2183"]}
{"title": "Improving student performance by evaluating how well students test their own programs\n", "abstract": " Students need to learn more software testing skills. This paper presents an approach to teaching software testing in a way that will encourage students to practice testing skills in many classes and give them concrete feedback on their testing performance, without requiring a new course, any new faculty resources, or a significant number of lecture hours in each course where testing will be practiced. The strategy is to give students basic exposure to test-driven development, and then provide an automated tool that will assess student submissions on-demand and provide feedback for improvement. This approach has been demonstrated in an undergraduate programming languages course using a prototype tool. The results have been positive, with students expressing appreciation for the practical benefits of test-driven development on programming assignments. Experimental analysis of student programs shows a\u00a0\u2026", "num_citations": "207\n", "authors": ["2183"]}
{"title": "Algorithm visualization: The state of the field\n", "abstract": " We present findings regarding the state of the field of Algorithm Visualization (AV) based on our analysis of a collection of over 500 AVs. We examine how AVs are distributed among topics, who created them and when, their overall quality, and how they are disseminated. There does exist a cadre of good AVs and active developers. Unfortunately, we found that many AVs are of low quality, and coverage is skewed toward a few easier topics. This can make it hard for instructors to locate what they need. There are no effective repositories of AVs currently available, which puts many AVs at risk for being lost to the community over time. Thus, the field appears in need of improvement in disseminating materials, propagating known best practices, and informing developers about topic coverage. These concerns could be mitigated by building community and improving communication among AV users and developers.", "num_citations": "189\n", "authors": ["2183"]}
{"title": "Rethinking computer science education from a test-first perspective\n", "abstract": " Despite our best efforts and intentions as educators, student programmers continue to struggle in acquiring comprehension and analysis skills. Students believe that once a program runs on sample data, it is correct; most programming errors are reported by the compiler; when a program misbehaves, shuffling statements and tweaking expressions to see what happens is the best debugging approach. This paper presents a new vision for computer science education centered around the use of test-driven development in all programming assignments, from the beginning of CS1. A key element to the strategy is comprehensive, automated evaluation of student work, in terms of correctness, the thoroughness and validity of the student's tests, and an automatic coding style assessment performed using industrial-strength tools. By systematically applying the strategy across the curriculum as part of a student's regular\u00a0\u2026", "num_citations": "183\n", "authors": ["2183"]}
{"title": "A framework for practical, automated black\u2010box testing of component\u2010based software\n", "abstract": " This paper outlines a general strategy for automated black\u2010box testing of software components that includes automatic generation of component test drivers, automatic generation of black\u2010box test data, and automatic or semi\u2010automatic generation of component wrappers that serve as test oracles. This research in progress unifies several threads of testing research, and preliminary work indicates that practical levels of testing automation are possible. Copyright \u00a9 2001 John Wiley & Sons, Ltd.", "num_citations": "149\n", "authors": ["2183"]}
{"title": "Using test-driven development in the classroom: Providing students with automatic, concrete feedback on performance\n", "abstract": " There is a need for better ways to teach software testing skills to computer science undergraduates, who are routinely underprepared in this area. This paper proposes the use of test-driven development in the classroom, requiring students to test their own code in programming assignments. In addition, an automated grading approach is used to assess student-written code and student-written tests together. Students receive clear, immediate feedback on the effectiveness and validity of their testing. This approach has been piloted in an undergraduate computer science class. Results indicate that students scored higher on their program assignments while producing code with 45% fewer defects per thousand lines of code.", "num_citations": "135\n", "authors": ["2183"]}
{"title": "Comparing effective and ineffective behaviors of student programmers\n", "abstract": " This paper reports on a quantitative evaluation of five years of data collected in the first three programming courses at Virginia Tech. The dataset involves a total of 89,879 assignment submissions by 1,101 different students. Assignment results were partitioned into two groups: scores above 80%(A/B) and scores below 80%(C/D/F). To investigate student behaviors that result in differing levels of achievement, all students who consistently received A/B scores and all students who consistently received C/D/F scores were removed from the dataset. A within-subjects comparison of the scores received by the remaining individuals was performed. Further, time and code-size data that is difficult to compare directly between different courses was normalized.", "num_citations": "118\n", "authors": ["2183"]}
{"title": "Relationship between glutathione S-transferase M1, P1 and T1 polymorphisms and early onset prostate cancer\n", "abstract": " There is evidence suggesting that polymorphic variations in the glutathione S-transferases (GSTs) are associated with cancer susceptibility. Inter-individual differences in cancer susceptibility may be mediated in part through polymorphic variability in the bioactivation and detoxification of carcinogens. The GSTs have been consistently implicated as cancer susceptibility genes in this context. The GST supergene family includes several loci with well characterized polymorphisms. Approximately 50% of the Caucasian population are homozygous for deletions in GSTM1 and approximately 20% are homozygous for deletions in GSTT1, resulting in conjugation deficiency of mutagenic electrophiles to glutathione. The GSTP1 gene has a polymorphism at codon 105 resulting in an Ile to Val substitution which consequently alters the enzymatic activity of the protein and this has been suggested as a putative high-risk\u00a0\u2026", "num_citations": "112\n", "authors": ["2183"]}
{"title": "Algorithm visualization: a report on the state of the field\n", "abstract": " We present our findings on the state of the field of algorithm visualization, based on extensive search and analysis of links to hundreds of visualizations. We seek to answer questions such as how content is distributed among topics, who created algorithm visualizations and when, the overall quality of available visualizations, and how visualizations are disseminated. We have built a wiki that currently catalogs over 350 algorithm visualizations, contains the beginnings of an annotated bibliography on algorithm visualization literature, and provides information about researchers and projects. Unfortunately, we found that most existing algorithm visualizations are of low quality, and the content coverage is skewed heavily toward easier topics. There are no effective repositories or organized collections of algorithm visualizations currently available. Thus, the field appears in need of improvement in dissemination of\u00a0\u2026", "num_citations": "96\n", "authors": ["2183"]}
{"title": "The effects of layering and encapsulation on software development cost and quality\n", "abstract": " Software engineers often espouse the importance of using abstraction and encapsulation in developing software components. They advocate the \"layering\" of new components on top of existing components, using only information about the functionality and interfaces provided by the existing components. This layering approach is in contrast to a \"direct implementation\" of new components, utilizing unencapsulated access to the representation data structures and code present in the existing components. By increasing the reuse of existing components, the layering approach intuitively should result in reduced development costs, and in increased quality for the new components. However, there is no empirical evidence that indicates whether the layering approach improves developer productivity or component quality. We discuss three controlled experiments designed to gather such empirical evidence. The results\u00a0\u2026", "num_citations": "76\n", "authors": ["2183"]}
{"title": "Teaching software testing: automatic grading meets test-first coding\n", "abstract": " A new approach to teaching software testing is proposed: students use test-driven development on programming assignments, and an automated grading tool assesses their testing performance and provides feedback. The basics of the approach, screenshots of the sytem, and a discussion of industrial tool use for grading Java programs are discussed.", "num_citations": "69\n", "authors": ["2183"]}
{"title": "A framework for detecting interface violations in component-based software\n", "abstract": " Two kinds of interface contract violations can occur in component based software: a client component may fail to satisfy a requirement of a component it is using, or a component implementation may fail to fulfil its obligations to the client. The paper proposes a systematic approach for detecting both kinds of violations, so that violation detection is not hard coded into base level components, but is \"layered\" on top of them, and so that it can be turned \"on\" or \"off\" selectively for one or more components, with practically no change to executable code (limiting changes to a few declarations). Among the salient features of this approach are its use of formal specifications, the ability to handle parameterized (i.e., generic, or template) components, and the automatic generation of routine aspects of violation detection. We have designed, built, and experimented with a generator of checking components for C++ templates.", "num_citations": "66\n", "authors": ["2183"]}
{"title": "Part II: Specifying components in RESOLVE\n", "abstract": " Conceptual modules may export two kinds of things for use in client programs: type families and operation families. We say \u201cfamilies\u201d here because every RESOLVE module is generic, so a client must instantiate a module before using it. Instantiation has two parts: First you bind all of a conceptual module\u2019s formal parameters to actuals which match the formals both in structure and in other specified properties; then you select an implementation for the concept and fix the realization\u2019s (additional) parameters [Part III]. An instance created this way is called a facility. For a typical conceptual module that defines one type family and associated operation families, every instance defines a particular type and some particular operations whose specifications result, in effect, from replacing the formal parameters of the generic specification with the actuals for that instance.Usually, the difference between a particular type/operation and the corresponding family of which it is a member is clear, and we omit the word \u201cfamily\u201d for brevity. But the difference is important. More information about the treatment of types in RESOLVE appears elsewhere [Harms 90, Harms 91].", "num_citations": "62\n", "authors": ["2183"]}
{"title": "Black\u2010box testing using flowgraphs: an experimental assessment of effectiveness and automation potential\n", "abstract": " A black-box testing strategy based on Zweben et al.'s specification-based test data adequacy criteria is explored. The approach focuses on generating a flowgraph from a component's specification and applying analogues of white-box strategies to it. An experimental assessment of the fault-detecting ability of test sets generated using this approach was performed for three of Zweben et al.'s criteria using mutation analysis. By using precondition, postcondition and invariant checking wrappers around the component under test, fault detection ratios competitive with white-box techniques were achieved. Experience with a prototype test set generator used in the experiment suggests that practical automation may be feasible. Copyright\u00a9 2000 John Wiley & Sons, Ltd.", "num_citations": "58\n", "authors": ["2183"]}
{"title": "Sexual activity and prostate cancer risk in men diagnosed at a younger age\n", "abstract": " RESULTSWhereas frequent overall sexual activity in younger life (20s) increased the disease risk, it appeared to be protective against the disease when older (50s). Alone, frequent masturbation activity was a marker for increased risk in the 20s and 30s but appeared to be associated with a decreased risk in the 50s, while intercourse activity alone was not associated with the disease.", "num_citations": "53\n", "authors": ["2183"]}
{"title": "Software-defined radio: a new paradigm for integrated curriculum delivery\n", "abstract": " Software-defined radio is a rapidly developing field that is driving the development of and innovation in communications technology, and promises to significantly impact all communications sectors. Entities developing these SDR systems require a trained workforce that has been prepared with the mindset, knowledge, skills, and tools required to address both the system (breadth) and technical (depth) aspects of SDR systems. Developing SDRs necessarily involves a collection of disciplines including, but not limited to, electromagnetics, radio-frequency engineering, communications, digital signal processing, embedded systems, computer programming, and systems engineering. Whereas electrical engineering and computer science and engineering curricula at the university level may include courses in all of these areas, a student's typical curriculum does not; nor does it usually involve the integration of all these\u00a0\u2026", "num_citations": "50\n", "authors": ["2183"]}
{"title": "Getting algorithm visualizations into the classroom\n", "abstract": " Algorithm visualizations (AVs) are widely viewed as having the potential for improving computer science education. However, the rate of AV use and overall impact on education does not match the positive interest in their use that instructors report. Surveys of CS faculty show that impediments to successful use of AVs in the classroom include difficulties in finding quality AVs on desired topics, difficulties in adapting AVs to a given classroom setting, and lack of knowledge on the best way to deploy AVs. This indicates a need for better support for instructors, to get them past these barriers. We seek to provide this support through an online educational community that relies on a new model based less on the\" digital library\" approach of information gained by going to a site and searching. Instead, the focus is on community-added content through members' discussions, reviews, and ratings of content items. The AlgoViz\u00a0\u2026", "num_citations": "48\n", "authors": ["2183"]}
{"title": "Experiences using test-driven development with an automated grader\n", "abstract": " Including software testing practices in programming assignments has moved from a novel idea to accepted practice in recent years. Further, testing frameworks have spurred renewed interest in new approaches to automated grading, with some systems specifically aiming to give feedback on software testing skills. As more educators consider incorporating testing techniques in their own courses, lessons learned from using testing in the classroom as well as from using automated grading systems become more valuable. This paper summarizes experiences in using software testing in CS1- and CS2-level courses over the past three years. Among these experiences, this paper focuses on student perceptions of automated grading tools and how they might be addressed, approaches to designing project specifications, and strategies for providing meaningful feedback to students that can help improve their\u00a0\u2026", "num_citations": "48\n", "authors": ["2183"]}
{"title": "Diagnostic radiation procedures and risk of prostate cancer\n", "abstract": " Exposure to ionising radiation is an established risk factor for many cancers. We conducted a case\u2013control study to investigate whether exposure to low dose ionisation radiation from diagnostic x-ray procedures could be established as a risk factor for prostate cancer. In all 431 young-onset prostate cancer cases and 409 controls frequency matched by age were included. Exposures to barium meal, barium enema, hip x-rays, leg x-rays and intravenous pyelogram (IVP) were considered. Exposures to barium enema (adjusted odds ratio (OR) 2.06, 95% confidence interval (CI) 1.01\u20134.20) and hip x-rays (adjusted OR 2.23, 95% CI 1.42\u20133.49) at least 5 years before diagnosis were significantly associated with increased prostate cancer. For those with a family history of cancer, exposures to hip x-rays dating 10 or 20 years before diagnosis were associated with a significantly increased risk of prostate cancer: adjusted\u00a0\u2026", "num_citations": "47\n", "authors": ["2183"]}
{"title": "Method and apparatus for providing privacy/security in a communication system\n", "abstract": " Apparatus and methods are disclosed for providing privacy on communications systems which include radio links, such as cellular telephone, marine radiotelephone, IMTS, and RDSS systems, in a manner which does not require a scrambler/descrambler at each called party location. The apparatus includes a base module having a call diverter connected to the public switched telephone network through two standard telephone lines. A bypass interface circuit is connected to the call diverter between the connections to the two telephone lines to selectively connect a scrambler/descrambler in series with the two telephone lines.", "num_citations": "46\n", "authors": ["2183"]}
{"title": "Running students' software tests against each others' code: new life for an old\" gimmick\"\n", "abstract": " At SIGCSE 2002, Michael Goldwasser suggested a strategy for adding software testing practices to programming courses by requiring students to turn in tests along with their solutions, and then running every student's tests against every other student's program. This approach provides a much more robust environment for assessing the quality of student-written tests, and also provides more thorough testing of student solutions. Although software testing is included as a regular part of many more programming courses today, the all-pairs model of executing tests is still a rarity. This is because student-written tests, such as JUnit tests written for Java programs, are now more commonly written in the form of program code themselves, and they may depend on virtually any aspect of their author's own solution. These dependencies may keep one student's tests from even compiling against another student's program. This\u00a0\u2026", "num_citations": "39\n", "authors": ["2183"]}
{"title": "IDE support for test-driven development and automated grading in both Java and C++\n", "abstract": " Students need to learn testing skills, and using test-driven development on assignments is one way to help students learn. We use a flexible automated grading system called Web-CAT to assess student assignments, including the validity and completeness of their own test cases. By building on existing educational plug-ins for Eclipse, and adding our own plug-ins for electronic submission and for unit testing support in C++, we are able to use Eclipse as a portal to all the services our students will need, allowing them to accomplish all their tasks entirely within the IDE, from their project's inception to its submission and evaluation. Further, we are able to carry students through the transition from Java programming to C++ programming within this same environment.", "num_citations": "39\n", "authors": ["2183"]}
{"title": "Exploring influences on student adherence to test-driven development\n", "abstract": " Test-Driven Development (TDD) is a software development process with a test-first approach that shows promise for improving code quality. Our research addresses concerns raised in both academia and industry about a lack of motivation or acceptance in adopting TDD. In a CS2 class, we used an automated testing tool and post-class surveys to observe patterns of behavior in testing as well as changes in attitudes. We found significant positive outcomes for students following TDD. We also identified obstacles deterring students from adhering to TDD and discuss reasons and possible remedies.", "num_citations": "38\n", "authors": ["2183"]}
{"title": "Pythy: Improving the introductory python programming experience\n", "abstract": " Pythy is a web-based programming environment for Python that eliminates software-related barriers to entry for novice programmers, such as installing an IDE or the Python runtime. Using only a web browser, within minutes students can begin writing code, watch it run, and access support materials and tutorials. While there are a number of web-based Python teaching tools, Pythy differs in several respects: it manages student assignment work, including deadlines, turn-in, and grading; it supports live, interactive code examples that instructors can write and students can explore; it provides auto-saving of student work in the cloud, with full, transparent version control; and it supports media-computation-style projects that manipulate images and sounds. Pythy provides a complete ecosystem for student learning, with a user interface that follows a more familiar web browsing model, rather than a developer-focused IDE\u00a0\u2026", "num_citations": "37\n", "authors": ["2183"]}
{"title": "minimUML: A minimalist approach to UML diagramming for early computer science education\n", "abstract": " In introductory computer science courses, the Unified Modeling Language (UML) is commonly used to teach basic object-oriented design. However, there appears to be a lack of suitable software to support this task. Many of the available programs that support UML focus on developing code and not on enhancing learning. Programs designed for educational use sometimes have poor interfaces or are missing common and important features such as multiple selection and undo/redo. Hence the need for software that is tailored to an instructional environment and that has all the useful and needed functionality for that specific task. This is the purpose of minimUML. It provides a minimum amount of UML, just what is commonly used in beginning programming classes, and a simple, usable interface. In particular, minimUML is designed to support abstract design while supplying features for exploratory learning and error\u00a0\u2026", "num_citations": "37\n", "authors": ["2183"]}
{"title": "Do student programmers all tend to write the same software tests?\n", "abstract": " While many educators have added software testing practices to their programming assignments, assessing the effectiveness of student-written tests using statement coverage or branch coverage has limitations. While researchers have begun investigating alternative approaches to assessing student-written tests, this paper reports on an investigation of the quality of student written tests in terms of the number of authentic, human-written defects those tests can detect. An experiment was conducted using 101 programs written for a CS2 data structures assignment where students implemented a queue two ways, using both an array-based and a link-based representation. Students were required to write their own software tests and graded in part on the branch coverage they achieved. Using techniques from prior work, we were able to approximate the number of bugs present in the collection of student solutions, and\u00a0\u2026", "num_citations": "36\n", "authors": ["2183"]}
{"title": "The effects of procrastination interventions on programming project success\n", "abstract": " In computer science, procrastination and related problems with managing programming projects are viewed as primary causes of student attrition. Unfortunately, the most successful techniques for reducing procrastination (such as courses in study skills) are resource-intensive and do not scale to large classrooms. In this paper, we describe three course interventions that are designed to be scalable for large classrooms and require few resources to implement. Reflective writing assignments require students to consciously consider how their time management choices impact their classroom performance. Schedule sheets force students to actively plan out the time required to solve a programming project. Email alerts inform students of their progress relative to their peers as they work on an assignment, and suggest ways to improve behavior if their progress is found to be unsatisfactory. We implemented these\u00a0\u2026", "num_citations": "35\n", "authors": ["2183"]}
{"title": "CodeWorkout: short programming exercises with built-in data collection\n", "abstract": " Learning programming techniques can be challenging and frustrating for many students. Many instructors use drill-and-practice strategies to help students develop basic programming techniques and improve their confidence. Online systems that provide short programming exercises with immediate, automated feedback are often seen as a valuable approach to drill-and-practice. However, the relationship between practicing with short programming exercises and performance on larger programming assignments or exams is unclear. This paper describes CodeWorkout, an open-source drill-and-practice system that supports short programming exercises and multiple choice questions. CodeWorkout combines an open, gradual engagement model that allows any student to practice exercises, whether or not they have an account or are enrolled in a course, together with powerful course management features that\u00a0\u2026", "num_citations": "31\n", "authors": ["2183"]}
{"title": "Supporting student-written tests of GUI programs\n", "abstract": " Tools like JUnit and its relatives are making software testing reachable even for introductory students. At the same time, however, many introductory computer sciences courses use graphical interfaces as an\" attention grabber\" for students and as a metaphor for teaching object-oriented programming. Unfortunately, developing software tests for programs that have significant graphical user interfaces is beyond the abilities of typical students (and, for that matter, many educators). This paper describes a framework for combining readily available tools to create an infrastructure for writing tests for Java programs that have graphical user interfaces. These tests are level-appropriate for introductory students and fit in with current approaches in computer science education that incorporate testing in programming assignments. An analysis of data collected during actual student use of the framework in a CS1 course is\u00a0\u2026", "num_citations": "31\n", "authors": ["2183"]}
{"title": "Contract-checking wrappers for C++ classes\n", "abstract": " Two kinds of interface contract violations can occur in component-based software: A client component can fail to satisfy a requirement of a component it is using, or a component implementation can fail to fulfill its obligations to the client. The traditional approach to detecting and reporting such violations is to embed assertion checks into component source code, with compile-time control over whether they are enabled. This works well for the original component developers, but it fails to meet the needs of component clients who do not have access to source code for such components. A wrapper-based approach, in which contract checking is not hard-coded into the underlying component but is \"layered\" on top of it, offers several relative advantages. It is practical and effective for C++ classes. Checking code can be distributed in binary form along with the underlying component, it can be installed or removed without\u00a0\u2026", "num_citations": "31\n", "authors": ["2183"]}
{"title": "A formative study of influences on student testing behaviors\n", "abstract": " While Computer Science curricula teach students strategic software development processes, assessment is often product-instead of process-oriented. Test-Driven Development (TDD) has gained popularity in computing education, but evaluating students' adherence to TDD requires analyzing their development processes instead of only their final product. Consequently, we designed an adaptive feedback system for reinforcing incremental testing behaviors. In this paper, we compare the results of the system with different reinforcement schedules and with-or without-visually salient testing goals. We analyzed snapshots of students' programming projects gathered during development and interviewed students at the end of the academic term. From our findings, we identify potential for influencing student development behaviors and suggest future direction for designing adaptive reinforcement.", "num_citations": "28\n", "authors": ["2183"]}
{"title": "Software component relationships\n", "abstract": " Large complex software systems are composed of many software components. Construction and maintenance of component-based systems require a clear understanding of the dependencies between these components. To support reuse, components should be designed to minimize such dependencies. When component coupling is necessary, however, dependencies need to be expressed clearly and precisely. Most software analysis and design methodologies rely on relationships such as passes-data-to, calls, is-a-part-of, and inherits-from for this purpose. Our position is that component relationships such as these are not an e ective way to convey important dependency information to implementors and maintainers working with reusable software components. Precisely-de ned conceptual relationships are better suited to this task.", "num_citations": "28\n", "authors": ["2183"]}
{"title": "Toward reflective metadata wrappers for formally specified software components\n", "abstract": " Abstract behavioral specifications for software components hold out the potential for significantly improving a software engineer's ability to understand, predict, and reason soundly about the behavior of component-based systems. Achieving these benefits, however, requires that specifications be delivered along with components to the consumer. This paper considers the question of what is the best way to package specification and verification information for delivery along with a component. Rather than distributing specifications in\" source\" form, an alternate solution based on reflection is presented. A reflective interface that supports program-level introspective access to behavioral descriptions is proposed. By embodying this interface in a wrapper component, it becomes possible for the reflective interface to also support services for contract violation checking, self-testing, and abstract value manipulation, even when the underlying component technology does not have built-in reflection capabilities.", "num_citations": "27\n", "authors": ["2183"]}
{"title": "An approach for constructing reusable software components in Ada\n", "abstract": " This paper discusses the topic of software reuse and is aimed at the software engineer who may actually be designing reusable software. The paper concentrates on many of the technical problems encountered when constructing reusable software components today. This paper does not, however, focus on the general problem of reusable software design. Instead, it focuses on the Ada programming language, and the problems software engineers may encounter when designing components in this language. This paper is intended to be a companion to IDA Paper P-2494, Strategy and Mechanisms for Encouraging Reuse in the Acquisition of SDI Software. P-2494 discusses the managerial and legal issues involved with software reuse.Descriptors:", "num_citations": "27\n", "authors": ["2183"]}
{"title": "Investigating static analysis errors in student Java programs\n", "abstract": " Research on students learning to program has produced studies on both compile-time errors (syntax errors) and run-time errors (exceptions). Both of these types of errors are natural targets, since detection is built into the programming language. In this paper, we present an empirical investigation of static analysis errors present in syntactically correct code. Static analysis errors can be revealed by tools that examine a program's source code, but this error detection is typically not built into common programming languages and instead requires separate tools. Static analysis can be used to check formatting or commenting expectations, but it also can be used to identify problematic code or to find some kinds of conceptual or logic errors. We study nearly 10 million static analysis errors found in over 500 thousand program submissions made by students over a five-semester period. The study includes data from four\u00a0\u2026", "num_citations": "26\n", "authors": ["2183"]}
{"title": "Quantifying incremental development practices and their relationship to procrastination\n", "abstract": " We present quantitative analyses performed on character-level program edit and execution data, collected in a junior-level data structures and algorithms course. The goal of this research is to determine whether proposed measures of student behaviors such as incremental development and procrastination during their program development process are significantly related to the correctness of final solutions, the time when work is completed, or the total time spent working on a solution. A dataset of 6.3 million fine-grained events collected from each student's local Eclipse environment is analyzed, including the edits made and events such as running the program or executing software tests. We examine four primary metrics proposed as part of previous work, and also examine variants and refinements that may be more effective. We quantify behaviors such as working early and often, frequency of program and test\u00a0\u2026", "num_citations": "26\n", "authors": ["2183"]}
{"title": "Comparing test quality measures for assessing student-written tests\n", "abstract": " Many educators now include software testing activities in programming assignments, so there is a growing demand for appropriate methods of assessing the quality of student-written software tests. While tests can be hand-graded, some educators also use objective performance metrics to assess software tests. The most common measures used at present are code coverage measures\u2014tracking how much of the student\u2019s code (in terms of statements, branches, or some combination) is exercised by the corresponding software tests. Code coverage has limitations, however, and sometimes it overestimates the true quality of the tests. Some researchers have suggested that mutation analysis may provide a better indication of test quality, while some educators have experimented with simply running every student\u2019s test suite against every other student\u2019s program\u2014an \u201call-pairs\u201d strategy that gives a bit more insight into\u00a0\u2026", "num_citations": "26\n", "authors": ["2183"]}
{"title": "A formal model of software subsystems\n", "abstract": " People form internal mental models of the things they interact with in order to understand those interactions. This psychological insight has been used by the human-computer interaction (HCI) community to build computer systems that are more intuitive for end users, but it has not yet been applied to the problems of software designers, programmers, and maintainers. In fact, conventional programming languages do little to help client programmers develop good mental models of software subsystems.", "num_citations": "26\n", "authors": ["2183"]}
{"title": "DevEventTracker: Tracking development events to assess incremental development and procrastination\n", "abstract": " Good project management practices are hard to teach, and hard for novices to learn. Procrastination and bad project management practice occur frequently, and may interfere with successfully completing major programming projects in mid-level programming courses. Students often see these as abstract concepts that do not need to be actively applied in practice. Changing student behavior requires changing how this material is taught, and more importantly, changing how learning and practice are assessed. To provide proper assessment, we need to collect detailed data about how each student conducts their project development as they work on solutions. We present DevEventTracker, a system that continuously collects data from the Eclipse IDE as students program, giving us in-depth insight into students' programming habits. We report on data collected using DevEventTracker over the course of four\u00a0\u2026", "num_citations": "25\n", "authors": ["2183"]}
{"title": "Effective and ineffective software testing behaviors by novice programmers\n", "abstract": " This data-driven paper quantitatively evaluates software testing behaviors that students exhibited in introductory computer science courses. The evaluation includes data collected over five years (10 semesters) from 49,980 programming assignment submissions by 883 different students. To examine the effectiveness of software testing behaviors, we investigate the quality of their testing at different stages of their development. We partition testing behaviors into four groups according to when in their development they first achieve substantial (at least 85%) test coverage.", "num_citations": "25\n", "authors": ["2183"]}
{"title": "Representation inheritance: A safe form of\" white box\" code inheritance\n", "abstract": " There are two approaches to using code inheritance for defining new component implementations in terms of existing implementations. Black box code inheritance allows subclasses to reuse superclass implementations as-is, without direct access to their internals. Alternatively, white box code inheritance allows subclasses to have direct access to superclass implementation details, which may be necessary for the efficiency of some subclass operations and to prevent unnecessary duplication of code. Unfortunately, white box code inheritance violates the protection that encapsulation affords superclasses, opening up the possibility of a subclass interfering with the correct operation of its superclass methods. Representation inheritance is proposed as a restricted form of white box code inheritance where subclasses have direct access to superclass implementation details, but are required to respect the\u00a0\u2026", "num_citations": "25\n", "authors": ["2183"]}
{"title": "Characterizing observability and controllability of software components\n", "abstract": " Two important objectives when designing a specification for a reusable software component are understandability and utility. For a typical component defining a new abstract data type, a significant common factor affecting both of these objectives is the choice of a mathematical model of the (state space of the) ADT, which is used to explain the behavior of the ADT's operations to potential clients. There are subtle connections between the expressiveness of this mathematical model and the functions computable using the operations provided with the ADT, giving rise to interesting issues involving the two complementary system theoretic principles of \"observability\" and \"controllability\". The paper discusses problems associated with formalizing intuitively stated observability and controllability principles in accordance with these tests. Although the example we use for illustration is simple, the analysis has implications for\u00a0\u2026", "num_citations": "25\n", "authors": ["2183"]}
{"title": "Mining data from an automated grading and testing system by adding rich reporting capabilities\n", "abstract": " Programs that perform automated assignment grading can generate a great deal of meaningful data not only for the student, but for the instructor as well. Such tools are often used in computer science courses to assess student programming work. In the process of grading, a large amount of intermediate information is gathered. However, in most cases this information is not used beyond assigning scores, so the potential of learning more about the course is lost. At the same time, continuous collection of data over a large number of submissions across many courses presents an interesting but untapped resource for educational data mining. One solution to this problem is to implement a reporting tool for making use of this intermediate data to create meaningful interpretations. This paper describes how an automated grading system, Web-CAT, has been extended to provide a reporting mechanism that uses the intermediate data that is gathered during assessment of students\u2019 programs. Our implementation of the reporting tool makes use of the Business Information Reporting Tool (BIRT) developed for the Eclipse IDE.", "num_citations": "23\n", "authors": ["2183"]}
{"title": "Experiences evaluating the effectiveness of JML-JUnit testing\n", "abstract": " This paper reports on the issues the authors encountered while evaluating the JML-JUnit unit testing strategy. Given a predefined set of parameter values, JML-JUnit can automatically provide unit tests for Java programs that have specifications. We present a mutation testing experiment that evaluates the effectiveness of this testing strategy, and the lessons learned from doing this experiment. We conclude that a benchmark will enable the testing research community to meaningfully assess testing approaches.", "num_citations": "23\n", "authors": ["2183"]}
{"title": "Automatically Generating Tests from Natural Language Descriptions of Software Behavior.\n", "abstract": " Behavior-Driven Development (BDD) is an emerging agile development approach where all stakeholders (including developers and customers) work together to write user stories in structured natural language to capture a software application\u2019s functionality in terms of required \u201cbehaviors.\u201d Developers can then manually write \u201cglue\u201d code so that these scenarios can be translated into executable software tests. This glue code represents individual steps within unit and acceptance test cases, and tools exist that automate the mapping from scenario descriptions to manually written code steps (typically using regular expressions). This paper takes the position that, instead of requiring programmers to write manual glue code, it is practical to convert natural language scenario descriptions into executable software tests fully automatically. To show feasibility, this paper presents preliminary results from a tool called Kirby that uses natural language processing techniques to automatically generate executable software tests from structured English scenario descriptions. Kirby relieves the developer from the laborious work of writing code for the individual steps described in scenarios, so that both developers and customers can both focus on the scenarios as pure behavior descriptions (understandable to all, not just programmers). Preliminary results from assessing the performance and accuracy of this technique are presented.", "num_citations": "22\n", "authors": ["2183"]}
{"title": "Toward practical mutation analysis for evaluating the quality of student-written software tests\n", "abstract": " Software testing is being added to programming courses at many schools, but current assessment techniques for evaluating student-written tests are imperfect. Code coverage measures are typically used in practice, but they have limitations and sometimes overestimate the true quality of tests. Others have proposed using mutation analysis instead, but mutation analysis poses a number of practical obstacles to classroom use. This paper describes a new approach to mutation analysis of student-written tests that is more practical for educational use, especially in an automated grading context. This approach combines several techniques to produce a novel solution that addresses the shortcomings raised by more traditional mutation analysis. An evaluation of this approach in the context of both CS1 and CS2 courses illustrates how it differs from code coverage analysis. At the same time, however, the evaluation\u00a0\u2026", "num_citations": "22\n", "authors": ["2183"]}
{"title": "Developing a common format for sharing programming assignments\n", "abstract": " Computer science educators spend a lot of effort designing programming assignments, and many are willing to share the results of this investment. However, sharing of programming assignments occurs primarily in an ad hoc manner through informal channels. There are no widely used mechanisms that support instructors in finding and sharing such resources. Often, the additional work required to prepare and self-publish assignment resources in a way that others can then adapt or reuse is a significant inhibitor. Also, other instructors may have to spend an inordinate amount of time and effort to reshape a potential assignment into something that can be used in their own courses. This working group report proposes a common format for packaging assignments for sharing. This format is easy for instructors to create (requiring no specialized tools), is extensible and flexible enough to handle assignments written for\u00a0\u2026", "num_citations": "22\n", "authors": ["2183"]}
{"title": "A basic recursion concept inventory\n", "abstract": " Recursion is both an important and a difficult topic for introductory Computer Science students. Students often develop misconceptions about the topic that need to be diagnosed and corrected. In this paper, we report on our initial attempts to develop a concept inventory that measures student misconceptions on basic recursion topics. We present a collection of misconceptions and difficulties encountered by students when learning introductory recursion as presented in a typical CS2 course. Based on this collection, a draft concept inventory in the form of a series of questions was developed and evaluated, with the question rubric tagged to the list of misconceptions and difficulties.", "num_citations": "21\n", "authors": ["2183"]}
{"title": "Examining classroom interventions to reduce procrastination\n", "abstract": " Procrastination is a common problem for students. Many believe procrastination may keep otherwise competent students from succeeding. However, the most effective interventions for procrastination are resource-intensive---providing supplemental training or courses in study skills and self-regulation. These techniques do not scale to large courses. This paper investigates three new classroom interventions designed to be low-cost and low-effort to implement. Reflective writing assignments ask students to reflect on how their time management choices affect their work. Project schedule sheets require students to plan out and schedule specific tasks on their projects. E-mail situational awareness alerts give students feedback on how their progress compares to others, and to expectations. 353 students over two semesters of a junior-level advanced data structures course participated in a study where these\u00a0\u2026", "num_citations": "21\n", "authors": ["2183"]}
{"title": "RoboLIFT: Engaging CS2 students with testable, automatically evaluated Android applications\n", "abstract": " Making computer science assignments interesting and relevant is a constant challenge for instructors of introductory courses. Android has become popular in these courses to take advantage of the increasing popularity of smartphones and mobile\" apps.\" This has been shown to increase student engagement but it is only the first step, and we must continue to provide support for teaching methodologies that we have used in the past, such as test-driven development and automated assessment. We have developed RoboLIFT, a library that makes unit testing of Android applications approachable for students. Furthermore, by supporting existing automated grading techniques, we are able to sustain large student enrollments, and we evaluate the effects that using Android has had on student performance.", "num_citations": "21\n", "authors": ["2183"]}
{"title": "Peer review in CS2: conceptual learning\n", "abstract": " In computer science, students could benefit from exposure to critical programming concepts from multiple perspectives. Peer review is one method to allow students to experience authentic uses of the concepts in a non-programming manner. In this work, we examine the use of the peer review process in early, object-oriented, computer science courses as a way to develop the reviewers' knowledge of object-oriented programming concepts, specifically Abstraction, Decomposition, and Encapsulation.", "num_citations": "21\n", "authors": ["2183"]}
{"title": "Experiences using tablet PCs in a programming laboratory\n", "abstract": " This experience report describes lessons learned using first generation tablet PCs to support active learning in an undergraduate computer science laboratory course. We learned that tablet PCs are poorly matched to typical CS laboratory tasks: writing, compiling, and testing programs. Pen-based input is inadequate for typical program editing tasks, and a pen is less effective than a mouse when typing at a keyboard. Students show a clear preference for desktop computers in this environment. Nearly three quarters of our students preferred a lab supporting wireless connectivity, however. Students also believe that the use of movable, reconfigurable furniture allows them to work in arrangements that are more natural during lab. Overall, students preferred the flexibility provided by wireless network access, freedom from cables, and movable furniture, but felt tablets were ineffective for programming tasks.", "num_citations": "21\n", "authors": ["2183"]}
{"title": "Evaluating automated unit testing in sulu\n", "abstract": " Sulu is a programming language designed with automated unit testing specifically in mind. One aim of Sulu is to demonstrate how automated software testing can be more integrated into current software development processes. Sulu's runtime and tools support automated testing from end to end; automating the generation, execution, and evaluation of test suites using both code coverage and mutation analysis. To show the effectiveness of this integrated approach, we performed an experiment to evaluate a family of test suites generated using a test case generation algorithm which exhaustively enumerates every sequence of method calls within a certain bound. The results show high code coverage, including 90% statement coverage and high mutation coverage for the most comprehensive test suite generated.", "num_citations": "20\n", "authors": ["2183"]}
{"title": "Designing an adaptive learning module to teach software testing\n", "abstract": " Adaptive learning systems aim to precisely tailor education and training to the individual needs of learners. Such systems use an internal model of a user's current knowledge to adjust the navigational affordances and presentation order of material. The user model is incrementally built and updated as the user demonstrates mastery by completing exercises and tests. Designing courses that are delivered adaptively involves addressing many complexities. This paper describes experiences designing the first adaptive module in a series intended to teach software testing skills. Experiences in using the first module and a preliminary evaluation of its effectiveness are presented.", "num_citations": "20\n", "authors": ["2183"]}
{"title": "Design and specification of iterators using the swapping paradigm\n", "abstract": " How should iterators be abstracted and encapsulated in modern imperative languages? We consider the combined impact of several factors on this question: the need for a common interface model for user defined iterator abstractions, the importance of formal methods in specifying such a model, and problems involved in modular correctness proofs of iterator implementations and clients. A series of iterator designs illustrates the advantages of the swapping paradigm over the traditional copying paradigm. Specifically, swapping based designs admit more efficient implementations while offering relatively straightforward formal specifications and the potential for modular reasoning about program behavior. The final proposed design schema is a common interface model for an iterator for any generic collection.< >", "num_citations": "20\n", "authors": ["2183"]}
{"title": "Impacts of adaptive feedback on teaching test-driven development\n", "abstract": " Studies have found that following Test-Driven Development (TDD) can improve code and testing quality. However, a preliminary investigation was consistent with concerns raised by other educators about programmers resisting TDD. In this paper, we describe an adaptive, pedagogical system for tracking and encouraging students' adherence to TDD. Along with an empirical evaluation of the system, we discuss challenges and opportunities for persuading student behavior through adaptive technology.", "num_citations": "19\n", "authors": ["2183"]}
{"title": "Ensemble PDP-8: Eight principles for distributed portals\n", "abstract": " Ensemble, the National Science Digital Library (NSDL) Pathways project for Computing, builds upon a diverse group of prior NSDL, DL-I, and other projects. Ensemble has shaped its activities according to principles related to design, development, implementation, and operation of distributed portals. Here we articulate 8 key principles for distributed portals (PDPs). While our focus is on education and pedagogy, we expect that our experiences will generalize to other digital library application domains. These principles inform, facilitate, and enhance the Ensemble R&D and production activities. They allow us to provide a broad range of services, from personalization to coordination across communities. The eight PDPs can be briefly summarized as:(1) Articulation across communities using ontologies.(2) Browsing tailored to collections.(3) Integration across interfaces and virtual environments.(4) Metadata\u00a0\u2026", "num_citations": "19\n", "authors": ["2183"]}
{"title": "Dereferee: Exploring pointer mismanagement in student code\n", "abstract": " Dynamic memory management and the use of pointers are critical topics in teaching the C++ language. They are also some of the most difficult for students to grasp properly. The responsibility of ensuring that students understand these concepts does not end with the instructor's lectures---a library enhanced with diagnostics beyond those provided by the language's run-time system itself is a useful tool for giving students more detailed information when their code fails. We have designed such a toolkit, Dereferee, which students can incorporate into their code with minimal intrusion into the learning process. To demonstrate its effectiveness, we examine C++ code from students in a course that relied solely on the built-in memory management behavior of the language, without any significant additional diagnostic or debugging facilities. We instrument this code with Dereferee in order to explore the causes of errors\u00a0\u2026", "num_citations": "19\n", "authors": ["2183"]}
{"title": "Open source software and the algorithm visualization community\n", "abstract": " Algorithm visualizations are widely viewed as having the potential for major impact on computer science education, but their quality is highly variable. We report on the software development practices used by creators of algorithm visualizations, based on data that can be inferred from a catalog of over 600 algorithm visualizations. Since nearly all are free for use and many provide source code, they might be construed as being open source software. Yet many AV developers do not appear to have used open source best practices. We discuss how such development practices might be employed by the algorithm visualization community, and how they might lead to improved algorithm visualizations in the future. We conclude with a discussion of OpenDSA, an open-source project that builds on earlier progress in the field of algorithm visualization and hopes to use open-source procedures to gain users and contributors.", "num_citations": "18\n", "authors": ["2183"]}
{"title": "Misunderstandings about object-oriented design: Experiences using code reviews\n", "abstract": " In this paper we present our experience using code reviews in a CS2 course. In particular, we highlight a series of misunderstandings of object-oriented (OO) concepts we observed as a by-product of the code review exercise. In our activity, we asked students to review code, rate it using a rubric, and to justify their explanation. The students were asked to review two solutions to a project from a previous year. Through examples of their explanations, we found that students had a number of basic misunderstandings of object-oriented principles. In this paper, we present our observations of the misunderstandings, and present some general observations of how code reviews can be used as an assessment tool in CS2.", "num_citations": "18\n", "authors": ["2183"]}
{"title": "Progsnap2: A flexible format for programming process data\n", "abstract": " In this paper, we introduce ProgSnap2, a standardized format for logging programming process data. ProgSnap2 is a tool for computing education researchers, with the goal of enabling collaboration by helping them to collect and share data, analysis code, and data-driven tools to support students. We give an overview of the format, including how events, event attributes, metadata, code snapshots and external resources are represented. We also present a case study to evaluate how ProgSnap2 can facilitate collaborative research. We investigated three metrics designed to quantify students' difficulty with compiler errors-the Error Quotient, Repeated Error Density and Watwin score-and compared their distributions and ability to predict students' performance. We analyzed five different ProgSnap2 datasets, spanning a variety of contexts and programming languages. We found that each error metric is mildly\u00a0\u2026", "num_citations": "17\n", "authors": ["2183"]}
{"title": "OSSIE: An open source software defined radio platform for education and research\n", "abstract": " OSSIE (Open Source SCA Implementation:: Embedded) was originally released in 2004 to fill the need for an implementation of the Software Communications Architecture (SCA)[4] that was free, simple, open to modifications, and written in C++. OSSIE includes several features, including the core framework for running SDR applications called waveforms, a library of pre-made waveforms and components for creating new waveforms, the Waveform Workshop, a set of tools for rapid prototyping and debugging of waveforms, and a set of lab assignments designed around OSSIE. With these features OSSIE is suitable for both classroom instructional usage and as a platform for a wide range of research, from things as small as a one-semester undergraduate independent study to a PhD dissertation. This paper describes a project done for a Summer independent study, and shows how OSSIE was used to create, run, and test the software for the project.", "num_citations": "17\n", "authors": ["2183"]}
{"title": "Responses to adaptive feedback for software testing\n", "abstract": " As students learn to program they also learn basic software development methods and techniques, but educators do not often directly assess students' development processes or evaluate their adherence to specific techniques. However, automated grading systems provide opportunities to evaluate students' programming and provide feedback while the student is still in the process of developing. Consequently, automated adaptive feedback may help reinforce effective techniques and processes.", "num_citations": "16\n", "authors": ["2183"]}
{"title": "Introducing CodeWorkout: an adaptive and social learning environment\n", "abstract": " Rudimentary programming skills are essential to developing fundamental proficiency in computer science. However, learning programming techniques can be challenging and frustrating for many students. CodeWorkout is an online learning environment that offers drill-and-practice exercises with novel social and adaptive scaffolding. Learners can track their progress on an assortment of computer science areas and skills while taking advantage of social features to discuss questions and help teach each other. Meanwhile, objective measurements of questions and teaching hints help promote the best, most effective content for learning. Our poster demonstrates how both computer science students and teachers benefit from joining the CodeWorkout community and taking advantage of its unique features.", "num_citations": "16\n", "authors": ["2183"]}
{"title": "Reconsidering automated feedback: A test-driven approach\n", "abstract": " Writing meaningful software tests requires students to think critically about a problem and consider a variety of cases that might break the solution code. Consequently, to overcome bugs in their code, it would be beneficial for students to reflect over their work and write robust tests rather than relying on trial-and-error techniques. Automated grading systems provide students with prompt feedback on their programming assignments and may help them identify where their interpretation of requirements do not match the instructor's expectations.", "num_citations": "15\n", "authors": ["2183"]}
{"title": "An assertion checking wrapper design for Java\n", "abstract": " The Java Modeling Language allows one to write formal behavioral specifications for Java classes in structured comments within the source code, and then automatically generate run-time assertion checks based on such a specification. Instead of placing the generated assertion checking code directly in the underlyling class bytecode file, placing it is a separate wrapper component offers many advantages. Checks can be distributed in binary form alongside the compiled class, and clients can selectively include or exclude checks on a per-class basis without recompilation. In this approach, when checks are excluded the underlying code is just as efficient as if assertions were \u201ccompiled out.\u201d In addition, a flexible mechanism for enabling or disabling assertion execution on a per-class or per-package basis is also included. This paper presents a design for separating assertion checking code into wrapper classes and discusses the issues arising from this design.", "num_citations": "15\n", "authors": ["2183"]}
{"title": "Towards progress indicators for measuring student programming effort during solution development\n", "abstract": " When learning to program, assignment feedback can easily reinforce a fixed mindset---where one believes intelligence is a fixed ability you either have or you don't. However, this can have negative consequences for learning. The alternative is a growth mindset, where one believes intelligence is malleable and can be improved through practice, effort, and hard work. We develop a set of fifteen progress indicators that can be used to assess student programming effort independently of the correctness of their code. The goal is to provide the measurement support needed for innovative feedback that gives a more welcoming experience for students, recognizing the effort they put in and the accomplishments they make as they work on solutions, rather than simply looking at whether code\" works\". Our set of progress indicators includes seven associated with writing solution code for a problem that are suitable for use on\u00a0\u2026", "num_citations": "14\n", "authors": ["2183"]}
{"title": "Reflection support: java reflection made easy\n", "abstract": " Large software projects often require the ability to load and manage new code assets that were not originally available during system compilation. Moreover, testing tools need to inspect and run code components regardless of their structures. Reflection in Java supports these tasks by providing programmers with facilities to dynamically create objects, invoke methods, access fields, and perform code introspection at runtime. These capabilities come at the cost of reduced readability and writeability, since code written using Java\u2019s reflection classes is clunky, bulky and unintuitive. Common tasks such as object creation, method invocation, and field manipulation need to be decomposed into multiple steps that require try-catch blocks to guard against checked exceptions. Type casts and explicit use of class types as parameters make development and maintenance of code difficult, time consuming and error prone. In this paper, we discuss the difficulties of using reflection in Java. We also present an open-source library called ReflectionSupport that addresses these problems and makes reflection in Java easier to use. ReflectionSupport provides static helper methods that offer the same reflective capabilities but that encapsulate the overhead of coding with reflection. This paper focuses on improving the usability of Java reflection by presenting an API that allows programmers to obtain the benefits of reflection without the hassle.", "num_citations": "14\n", "authors": ["2183"]}
{"title": "Can quality graduate software engineering courses really be delivered asynchronously on-line?\n", "abstract": " This article briefly presents a case study in on-line asynchronous course delivery. It sketches the design of a graduate computer science course entitled \u201cSoftware Design and Quality,\u201d illustrating an effective approach to distance learning that accommodates learning by doing, team collaboration, and critical thinking. It also shows that there are effective alternatives to \u201ccanned\u201d streaming media presentations that achieve quality on-line education.", "num_citations": "14\n", "authors": ["2183"]}
{"title": "Toward a model of reusable software subsystems\n", "abstract": " No one has yet developed a generally acceptable model of reusable software that fully captures the nature of software parts and how they should be used to construct new systems. This paper discusses developing a model of reusable subsystems, where a subsystem can vary in grain size from large scale generic architectures to single module components. It draws on previous work from wisr'91 to describe the need for an analytical model of reusable subsystems, the purposes for such a model, the broad properties such a model should have, and the critical issues that have already been identi ed which must be addressed. It points out the strong incentive researchers and practitioners have to drive toward a model for software building blocks and how they are used to construct systems.", "num_citations": "14\n", "authors": ["2183"]}
{"title": "Can Mobile Gaming Psychology Be Used to Improve Time Management on Programming Assignments?\n", "abstract": " Students often procrastinate on assignments, sometimes to the extent that it negatively affects their work. Although many solutions have been researched, instructors continue searching for effective techniques that are easy to employ and require little faculty overhead. This paper describes experiences adapting techniques inspired by commercially successful mobile games. These games use structural features that limit the player's play time, and use reward systems to encourage students to cultivate game-based resources (like energy, gold, credits, etc.). This combination of limits plus incentives shapes the way players manage their play time: it deters\" binge\" play sessions and strongly promotes the use of a much larger number of play sessions spread over a longer period of time. By adapting this to the assignment self-checking and turn-in process, we hope to exert a similar effect on how students manage their\u00a0\u2026", "num_citations": "13\n", "authors": ["2183"]}
{"title": "Discovering patterns in student activity on programming assignments\n", "abstract": " In our introductory computer programming courses, students submit their code to an automated grading system for assessment, and they are allowed to make an unlimited number of attempts before the assignment is closed. This sequence of submissions can be viewed as time series data where each attempt gives rise to one or more data points, or events, that describe either an action that the student has taken or a result of those actions. Frequent episode mining is a data mining technique that lets us discover frequently occurring patterns in time series data. We apply this technique with data generated during one of our courses in order to better understand the behaviors of our students during the time that they work on a programming assignment. This paper presents an examination of the trends that we discovered in our student data.", "num_citations": "13\n", "authors": ["2183"]}
{"title": "Distributed, modular, open control architecture for power conversion systems\n", "abstract": " Due to close coupling to hardware and lack of software engineering technologies, the control software in digitally controlled power conversion systems is difficult to design and maintain. This is a natural consequence of a topology- or application-driven design approach. This paper proposes a distributed, modular, open control architecture for power conversion systems to decompose control design complexity and encapsulate and localize design dependencies to reduce unnecessary redesign effort and improve software quality. An implementation of the proposed control architecture is presented and evaluated by comparison to the legacy approach to control design in industry and academia.", "num_citations": "13\n", "authors": ["2183"]}
{"title": "Elementary control objects: toward a dataflow architecture for power electronics control software\n", "abstract": " This paper presents dataflow architecture as an approach to designing reusable and reconfigurable control software for power electronics systems. A traditional \"main-program-and-subroutine\" architecture raises a number of software issues in power electronics control that are addressed by this new strategy. The infrastructure of dataflow architecture is discussed. A 3-phase inverter application is used as an example to evaluate the proposed software architecture vs. the legacy \"main-program-and-subroutine\" approach.", "num_citations": "13\n", "authors": ["2183"]}
{"title": "Recurtutor: An interactive tutorial for learning recursion\n", "abstract": " Recursion is one of the most important and hardest topics in lower division computer science courses. As it is an advanced programming skill, the best way to learn it is through targeted practice exercises. But the best practice problems are time consuming to manually grade by an instructor. As a consequence, students historically have completed only a small number of recursion programming exercises as part of their coursework. We present a new way for teaching such programming skills. Students view examples and visualizations, then practice a wide variety of automatically assessed, small-scale programming exercises that address the sub-skills required to learn recursion. The basic recursion tutorial (RecurTutor) teaches material typically encountered in CS2 courses. Students who used RecurTutor had significantly better grades on recursion exam questions than did students who used typical instruction\u00a0\u2026", "num_citations": "12\n", "authors": ["2183"]}
{"title": "Work-in-progress: program grading and feedback generation with Web-CAT\n", "abstract": " Web-CAT, the Web-based Center for Automated Testing, is the most widely used open-source automated grading system for programming assignments in the world. Web-CAT is customizable and extensible, allowing it to support a wide variety of programming languages and assessment strategies. Web-CAT is most well known as the system that\" grades students on how well they test their own code,\" with experimental evidence that it offers greater learning benefits than more traditional output-comparison grading. This work-in-progress demonstration will show how Web-CAT can be used to automatically grade student work, assess conformance with coding style guidelines, provide students with feedback on how well they have tested their own code, and allow instructors to provide directed hints to students on where to focus their attention for improvements.", "num_citations": "12\n", "authors": ["2183"]}
{"title": "Student attitudes and motivation for peer review in CS2\n", "abstract": " Computer science students need experience with essential concepts and professional activities. Peer review is one way to meet these goals. In this work, we examine the students' attitudes towards and engagement in the peer review process, in early, object-oriented, computer science courses. To do this, we used peer review exercises in two CS2 classes at neighboring universities over the course of a semester. Using three groups (one reviewing their peers, one reviewing the instructor, and one completing small design or coding exercises), we measured the students' attitudes, their perceptions of their abilities, and how many of the reviews they completed. We found moderately positive attitudes that generally increased over time but were not significantly different between groups. We also saw a lower completion rate for students reviewing peers than for the other groups. The students' internal motivation, as\u00a0\u2026", "num_citations": "12\n", "authors": ["2183"]}
{"title": "WISR8: 8th Annual Workshop on Software Reuse: Summary and working group reports\n", "abstract": " This report briefly summarizes the work of the\" Informal versus Formal Specifications\" working group. In the initial discussion, it became clear that it would be useful to have some idea of the tradeoffs between using informal and formal specifications, so that became the main goal of the group. The result was a mode] that helps predict the impact of alternative specification methodologies, which we called PISA.", "num_citations": "12\n", "authors": ["2183"]}
{"title": "Inheritance: One mechanism, many conflicting uses\n", "abstract": " Inheritance has many bene cial uses, but merging them all into a single hierarchy can bring out serious con icts. The reasons there are such con icts, and the reasons why they are commonly allowed in oo languages can be seen by examining the di erent applications of inheritance, and who makes use of them. To illustrate this point, this position paper includes a rudimentary taxonomy of the various uses for inheritance in oo programming. The primary partition in the taxonomy, between inheritance as used by the implementer of a class or as used by the client of a class, helps to point out the ways various uses of inheritance can con ict, and can hamper e ective programming.", "num_citations": "12\n", "authors": ["2183"]}
{"title": "Building an online educational community for algorithm visualization\n", "abstract": " Algorithm visualizations (AVs) are widely viewed as having the potential for improving computer science education, yet the rate of AV use and overall impact has progressed little from the mid 1990s. Surveys of CS faculty [1] show that the impediments to successful use of AVs are related to difficulties in first finding good materials, and then difficulties in effectively deploying them in classes. Fortunately, much progress has been made in recent years. There are many high-quality AVs available (though there are enough poor quality AVs that sorting out the good ones can be time consuming)[2]. There is a growing body of research on how to effectively use AVs in the classroom (though getting up to speed on this information is again time consuming). These impediments could be overcome with adequate dissemination of information about which AVs are of good quality and how they can best be used. From the\u00a0\u2026", "num_citations": "11\n", "authors": ["2183"]}
{"title": "Impacts of Teaching test-driven development to Novice Programmers\n", "abstract": " Due to the popularity of Test-Driven Development (TDD) among software professionals, some schools have integrated it into their computing curricula. Through exposure to TDD, students gain practical experience while future employers benefit from their familiarity with the technique. However, it is important to investigate empirically whether the use of TDD in the classroom affects student performance or improves the quality of their code. Our study leverages an extensive data set representing multiple years of teaching TDD in introductory computer science classes.In this paper, we explain methods, tools, and metrics for determining students' adherence to TDD. Our study has the distinct advantage on the analysis of multiple snapshots of each student's work throughout the development process, which provides insight into their work habits and consequential outcomes. Furthermore, we establish positive correlations between students' adherence to TDD and both their solution code quality and their thoroughness of testing. As a result, we provide empirical support for the value of TDD in education and identification areas for improving its instruction.", "num_citations": "10\n", "authors": ["2183"]}
{"title": "DCER: sharing empirical computer science education data\n", "abstract": " Data sharing is common, and sometimes even required, in other disciplines. Creating a mechanism for data sharing in computer science education research will benefit both individual researchers and the community. While it is easy to say that data sharing is desirable, it is much more difficult to make it a practical reality.", "num_citations": "10\n", "authors": ["2183"]}
{"title": "Improving student programming skills by developing program comprehension abilities: Panel discussion\n", "abstract": " Students often have difficulty:Writing programs that do what the students intend;Understanding what they have written;Articulating hypotheses about the meaning of what they have written that can be turned into tests to check for correctness, and;Debugging their work once they realize there is a problem.The panelists will discuss four mutually supportive themes focused on developing program comprehension skills so that students can program more effectively.", "num_citations": "10\n", "authors": ["2183"]}
{"title": "Auto-Grading Jupyter Notebooks\n", "abstract": " Jupyter Notebooks are becoming more widely used, both for data science applications and as a convenient environment for learning Python. Currently, grading of assignments done in Jupyter Notebooks is typically done manually. Manual grading results in students receiving feedback only long after the assignment is complete. We implemented support for auto-grading programs written in Jupyter Notebooks within the Web-CAT auto-grading system. Scores received are directly reported to the Canvas gradebook. A Jupyter notebook extension allows students to upload their notebook files to Web-CAT directly. Survey results from class use show that 80% of students believe that getting immediate feedback from Web-CAT improved their performance. Instructors report that this implementation has significantly reduced their workload.", "num_citations": "9\n", "authors": ["2183"]}
{"title": "Applying spectrum-based fault localization to generate debugging suggestions for student programmers\n", "abstract": " While automated grading systems are useful for generating real-time feedback for students, they also highlight some obstacles. In particular, when a student's program contains bugs, automated systems report this fact, but not how to locate or correct them. This paper reports on a study inspired by current research on automatic fault localization - techniques to programmatically locate bugs within a piece of code under test. The goal is not to \"identify\" or diagnose the bug, but simply to locate where it is in the code, to give the student a direction to investigate. Before employing this technique live with students, this study validates that automated fault localization can be performed with the level of accuracy needed to give meaningful guidance. We used the GZoltar statistical fault localization library for Java to analyze 135 CS2-level student programs, and then manually debugged the programs to find the locations of their\u00a0\u2026", "num_citations": "9\n", "authors": ["2183"]}
{"title": "LIFT: taking GUI unit testing to new heights\n", "abstract": " The Library for Interface Testing (LIFT) supports writing unit tests for Java applications with graphical user interfaces (GUIs). Current frameworks for GUI testing provide the necessary tools, but are complicated and difficult to use for beginners, often requiring a significant amount of time to learn. LIFT takes the approach that unit testing GUIs should be no different than testing any other type of code. By providing a set of frequently used filters for identifying GUI components and a set of operations for acting on those components, LIFT lets programmers quickly and easily test their GUI applications.", "num_citations": "9\n", "authors": ["2183"]}
{"title": "Effect of interface style in peer review comments for UML designs\n", "abstract": " This paper presents our evaluation of using a Tablet-PC to provide peer-review comments in the first year Computer Science course. Our exploration consisted of an evaluation of how students write comments on other students' assignments using three different methods: pen and paper, a Tablet-PC, and a desktop computer. Our ultimate goal is to explore the effect that interface style (Tablet vs. Desktop) has on the quality and quantity of the comments provided.", "num_citations": "9\n", "authors": ["2183"]}
{"title": "Implementing dataflow-based control software for power electronics systems\n", "abstract": " Dataflow provides a natural way to describe the structure of many control algorithms. This paper presents a method for implementing modular, reusable and reconfigurable control software for power electronics systems using a dataflow architecture. A 3-phase inverter application is used as an a example to illustrate the approach and evaluate the proposed software versus the legacy \"main-program-and-subroutine\" approach.", "num_citations": "9\n", "authors": ["2183"]}
{"title": "Peer review in CS2: Conceptual learning and high-level thinking\n", "abstract": " In computer science, students could benefit from exposure to critical programming concepts from multiple perspectives. Peer review is one method to allow students to experience authentic uses of the concepts in an activity that is not itself programming. In this work, we examine how to implement the peer review process in early, object-oriented computer science courses as a way to increase the students\u2019 knowledge of programming concepts, specifically Abstraction, Decomposition, and Encapsulation, and to develop their higher-level thinking skills. We are exploring the peer review process, the effects of the type of review on the reviewers, and the results this has on the students\u2019 learning. To study these ideas, we used peer review activities in CS2 classes at two universities over the course of a semester. Using three groups (one reviewing their peers, one reviewing the instructor, and one completing small design\u00a0\u2026", "num_citations": "8\n", "authors": ["2183"]}
{"title": "Using spectrum-based fault location and heatmaps to express debugging suggestions to student programmers\n", "abstract": " Automated grading systems are useful for conveying debugging feedback to students, but the manner in which this feedback is displayed can be problematic for students. Automated systems usually report failures in student code, whether it be the results of test case failures or runtime errors. However, since most students are not explicitly taught how to debug, many get stuck. They know the defects exist, but they don't have to experience to know how to find them. Much work has been done in software engineering research using automatic fault localization to programmatically locate bugs within a piece of code under test, as well as research into validating those detection models when applied to student code.", "num_citations": "8\n", "authors": ["2183"]}
{"title": "Adaptively identifying non-terminating code when testing student programs\n", "abstract": " Infinite looping problems that keep student programs from termi-nating may occur in many kinds of programming assignments. While non-terminating code is easier to diagnose interactively, it poses different concerns when software tests are being run auto-matically in batch. The common strategy of using a timeout to preemptively kill test runs that execute for too long has limita-tions, however. When one test case gets stuck in an infinite loop, forcible termination prevents any later test cases from running. Worse, when test results are buffered inside a test execution framework, forcible termination may prevent any information from being produced. Further, overly generous timeouts can de-lay the availability of results, and when tests are executed on a shared server, one non-terminating program can delay results for many people. This paper describes an alternative strategy that uses a fine-grained timeout on the\u00a0\u2026", "num_citations": "8\n", "authors": ["2183"]}
{"title": "Component-Based System Design and Analysis\n", "abstract": " Component-based system design, like all modern engineering design, involves pre-dicting and reasoning about the behavior of possible systems, that is, systems that have not been built yet. Similarly, component-level maintenance of these systems involves predicting and reasoning about the behavioral impacts of possible changes (for example, component substitutions). The need for tractable reasoning about sys-tem behavior and the central role of mathematical modeling in meeting this need together suggest a new framework for component-based system design: one that captures both the behaviors of components and systems and the meanings of asso-ciated symbolic design artifacts such as behavioral specifications. Such a framework is related intuitively to popular views of component-based systems from software architecture. It is related technically to more formal aspects of software engineering, such as formal specifications and formal semantics of programming languages.", "num_citations": "8\n", "authors": ["2183"]}
{"title": "The state of reuse: perceptions of the reuse community\n", "abstract": " The Ninth Workshop on Institutionalizing Software Reuse (WISR9) was held January 7-9, 1999, bringing together established reuse researchers from academia and industry. On the first day of the workshop, a survey was taken to collect feedback about the reuse community's collective beliefs and disagreements. Preliminary results were then shared with the participants during the last plenary session of the workshop. This article presents the results of the survey, which capture the opinions of an important segment of the reuse community.", "num_citations": "8\n", "authors": ["2183"]}
{"title": "Good mental models are necessary for understandable software,\"\n", "abstract": " People form internal mental models of the things they interact with in order to understand those interactions. This psychological insight has been used by the human-computer interaction (HCI) community to build computer systems that are more intuitive for end users, but it has not yet been applied to the problems of software designers, programmers, and maintainers. In fact, conventional programming languages do little to help client programmers develop good mental models of software subsystems.The main problem is that the conventional wisdom that software modules are merely a syntactic mechanism for organizing declarations and controlling visibility is wrong. This skewed view of the nature of software modules limits their utility as e ective building-blocks for creating large, complex software systems that are comprehensible to human readers. To constitute e ective building-blocks, modules must present\u00a0\u2026", "num_citations": "8\n", "authors": ["2183"]}
{"title": "Common interface models for reusable software\n", "abstract": " Related reusable components are often based on different conceptual models of behavior. This may unduly restrict the ways in which they can be composed. The conceptual model underlying the specification of one module\u2019s parameter requirements may differ significantly from the model underlying the specification of another module\u2019s exported features, even if the two modules intuitively seem compatible. There is no well understood groundwork of common models for component interaction, and the lack of guidance for applying these models exacerbates the composability problem. This article describes how varying interface models and techniques for describing a component\u2019s interface requirements affect composability. These problems are illustrated in the context of common interface properties that are exhibited even in simple ADT components.", "num_citations": "8\n", "authors": ["2183"]}
{"title": "Checked coverage and object branch coverage: New alternatives for assessing student-written tests\n", "abstract": " Many educators currently use code coverage metrics to assess student-written software tests. While test adequacy criteria such as statement or branch coverage can also be used to measure the thoroughness of a test suite, they have limitations. Coverage metrics assess what percentage of code has been exercised, but do not depend on whether a test suite adequately checks that the expected behavior is achieved. This paper evaluates checked coverage, an alternative measure of test thoroughness aimed at overcoming this limitation, along with object branch coverage, a structure code coverage metric that has received little discussion in educational assessment. Checked coverage works backwards from behavioral assertions in test cases, measuring the dynamic slice of the executed code that actually influences the outcome of each assertion. Object branch coverage (OBC) is a stronger coverage criterion\u00a0\u2026", "num_citations": "7\n", "authors": ["2183"]}
{"title": "Experiences From the OSSIE Open Source Software Defined Radio Project\n", "abstract": " This article briefly describes OSSIE, a university-based open source Software Defined Radio (SDR) project based on the US Department of Defense's Software Communications Architecture (SCA). The OSSIE software has proven useful for rapid prototyping by industry as well as for published research and education of hundreds of graduate and undergraduate students and short course participants. In addition to examples of OSSIE's successes, the project's challenges and approaches to mitigating and overcoming them are described.", "num_citations": "7\n", "authors": ["2183"]}
{"title": "An online teacher peer review system\n", "abstract": " We describe the development of an online peer review module for the Moodle (http://moodle. org) course management system. We have designed the system to be quite flexible for many different methods of peer review. One important feature is a rubric authoring tool that allows instructors to create a table of criteria in an online form which students can use to submit their feedback. We discuss some peer review literature and then present some scenarios of use for this tool. We cover some design issues and how we addressed them and conclude with a discussion of evaluation and future work.", "num_citations": "7\n", "authors": ["2183"]}
{"title": "PATTERN NAME: STREAMS\n", "abstract": " Design The idea of a stream of homogeneous objects has been in use as a practical Rationale programming abstraction for a very long time and is well known to LISP and functional programmers. Abelson and Sussman give a textbook description of streams in this context (AS85). The streams they describe are composite data structures designed to help organize and structure computations on serial collections of data \u201cin a way that corresponds in spirit to an electrical engineer's concept of a signal-processing system\u201d(p. 242). Conceptually, a stream is simply a sequence of data objects. It differs from a regular list in the way it is represented and in the fact that the sequence might be arbitrarily long. This stream concept is used in many functional programming languages for structuring computations that can be thought of in terms of a data flow model, where data objects flow through computational\" stages\" or filters.The longevity and versatility of streams as programming objects leads to the questions of whether there is a higher-level abstract pattern here and, if so, what problems it addresses and in what contexts. The problem that streams best address can be uncovered by further examining the\" signalprocessing\" analogy made by Abelson and Sussman (AS85). Streams allow one to structure computations on (usually long) sequences of data in an intuitive way, using simple data flow ideas, without regard for the details of how the computation will actually be carried out at run time. Conceptually, a stream denotes an entire sequence of data objects, and operations on streams take as input an entire sequence and produce an entire sequence\u00a0\u2026", "num_citations": "7\n", "authors": ["2183"]}
{"title": "Can industrial-strength static analysis be used to help students who are struggling to complete programming activities?\n", "abstract": " Static analysis tools evaluate source code to identify potential problems or issues beyond typical compiler errors. Prior work has shown a statistically significant relationship between the correctness of a student's work and statically identifiable flaws or \"code smells\" that are likely to indicate programming errors. This paper presents a comprehensive study of this relationship in the context of small programming exercises intended for use in student skill building. We use FindBugs, a static analysis tool that identifies program features that are likely to represent actual bugs in professional software.  Our goal is to identify the extent to which FindBugs warnings might help novices struggling to solve short programming exercises.  In this study, we ran FindBugs against 149,054 answers submitted by 516 students on 57 drill-and-practice coding exercises. We identify the specific FindBugs warnings that are inversely correlated with correctness. We confirm that presence of these warnings is significantly associated with struggling on an exercise, as indicated by taking more time, making more submissions, and receiving lower scores. Finally, every exercise exhibited answers that trigger these warnings, and 92.4% of students would experience these warnings over a full semester. Our results indicate that static analysis with tools designed for use in industry offers an untapped opportunity to provide hints or suggestions to students who are measurably struggling.", "num_citations": "6\n", "authors": ["2183"]}
{"title": "Adaptive and social mechanisms for automated improvement of eLearning materials\n", "abstract": " Online environments introduce unprecedented scale for formal and informal learning communities. In these environments, user-contributed content enables social constructivist approaches to education. In particular, students can help each other by providing hints and suggestions on how to approach problems, by rating each other's suggestions, and by engaging in discussions about the questions. In addition, students can also learn through composing their own questions. Furthermore, with grounding in Item Response Theory, data mining and statistical student models can assess questions and hints for their quality and effectiveness. As a result, internet-scale learning environments allow us to move from simple, canned quizzing systems to a new model where automated, data-driven analysis continuously assesses and refines the quality of teaching material. Our poster describes a framework and prototype of an\u00a0\u2026", "num_citations": "6\n", "authors": ["2183"]}
{"title": "Scheduling and student performance\n", "abstract": " We present data showing strong correlation between students' time management and a successful outcome on programming assignments. Students who spread their work over more time will produce a better result without additional expenditure of total effort. We examined performance of students who sometimes did well and sometimes did poorly, and found that their good performance occurred on the projects where they displayed better time management. While these results will not surprise most instructors, hard data is more compelling than intuition when trying to train students to use good time management.", "num_citations": "6\n", "authors": ["2183"]}
{"title": "Formal Foundations of Reuse and Domain Engineering: 11th International Conference on Software Reuse, ICSR 2009, Falls Church, VA, USA, September 27-30, 2009. Proceedings\n", "abstract": " ICSR is the premier international conference in the? eld of software reuse. The main goal of ICSR is to present the advances and improvements within the software reuse domain, as well as to promote interaction between researchers and practitioners. The 11th International Conference on Software Reuse (ICSR 2009) was held during September 27\u201330, 2009 in Falls Church, VA, USA. 2009 was the year that ICSR went back to its roots. The theme was \u201cFormal Foundations of Reuse and Domain Engineering.\u201d We explored the theory and formal foundations that underlie current reuse and domain engineering practice and looked at current advancements to get an idea of where the? eld of reuse was headed. Manyof the papers in these proceedings directly re? ect that theme. The following workshops were held in conjunction with ICSR 2009:\u2013Second Workshop on Knowledge Reuse (KREUSE 2009)\u2013RESOLVE 2009: Software Veri? cation\u2013the Cornerstone of Reuse\u2013First International Workshop on Software Ecosystems\u2013International Workshop on Software Reuse and Safety (RESAFE 2009) Aside from these workshops and the papers found here, the conference also included? ve tutorials, eight tool demos, and a doctoral symposium. Links to all of this information and more can be found at the ICSR 11 conference website at icsr11. isase. org.", "num_citations": "6\n", "authors": ["2183"]}
{"title": "It seemed like a good idea at the time\n", "abstract": " We often learn of successful pedagogical experiments, but we seldom hear of the the ones that failed. From an epistemological point of view, learning from failures can be at least as effecitive as learning from good examples. This special session has a structure similar to that of Parlante\u2019s Nifty Assignments, ie we solicited submissions from the SIGCSE membership, selected the best from among these, and have presentations at the session by the selected authors. Our contributions describe pedagogical approaches that seemed to be good ideas but turned out as failures. Contributors will describe their pedagogical experiment, the rationale for the experiment, evidence of failure, and lessons learned.", "num_citations": "6\n", "authors": ["2183"]}
{"title": "DARK: Designing a high performance micro-kernel for power electronics controllers\n", "abstract": " Dataflow is a style of software architecture ideally suited for embedded control. The Dataflow Architecture Realtime Kernel (DARK) is a lightweight RTOS specifically designed to support such designs in power electronics control. DARK\u2019s high performance design is presented along with performance comparisons against a commercial real-time operating system.", "num_citations": "6\n", "authors": ["2183"]}
{"title": "Applying object-oriented techniques in embedded software design\n", "abstract": " Efficiency is a major concern for real-time systems. Realtime software is often written in assembly or other low level languages like C. Programmers hesitate to use newer objectoriented techniques since these are perceived as less efficient. This work explores the OO design techniques for embedded operating system, taking into account real-time goals so that the design is efficient and meets system deadlines. The embedded system kernel being designed is based on Dataflow Architecture. This architecture, which supports asynchronous communication amongst the various components through communication channels, was chosen since it addresses the objectives of modularity, standardization and reusability of Power Electronics Building Block (PEBB) systems, by the use of Elementary Control Objects (ECOs). An ECO is a functional entity in the PEBB system that can be used independent of the system details, in a variety of systems. It thereby serves as a modular, standardized and reusable component. An entity like the ECO comes across as ideal to be modeled and implemented as an object; ie, using the OO approach. More over, since the advantages of objectorientation are in line with our objectives of modularity, standardization and reusability, it is ideal to implement the system as an object-oriented one. For instance, an ECO can be represented by a class. If this class is used to represent the general attributes and certain generic functions of all ECOs, then we can inherit specific types of ECOs from this class, that differ in their implementation code due to their functional differences. The ECOs are connected with each other to form the\u00a0\u2026", "num_citations": "6\n", "authors": ["2183"]}
{"title": "An analysis of a course-oriented electronic mailing list\n", "abstract": " To understand how course-oriented e-mail lists contribute to the learning experience and, more importantly, to understand how to improve the value of listservs in courses, it is important to critically examine their behavior under actual classroom conditions. We present an empirical study of listserv usage in a sophomore-level computer science data structures class. This study provides experimental evidence that: the list was an important information source for students, students were major contributors in answering the questions of others, students generally provided correct answers instead of incorrect help, and traffic on the list was driven by concrete tasks the students had to perform. As a result, the listserv was an effective tool for peer-to-peer learning, not just a mechanism for faculty to broadcast announcements. After presenting the study and results, we conclude by describing the lessons we learned on how to\u00a0\u2026", "num_citations": "6\n", "authors": ["2183"]}
{"title": "Experiences Using Heat Maps to Help Students Find Their Bugs: Problems and Solutions\n", "abstract": " Automated grading systems provide feedback to students in a variety of ways, but usually focus on identifying incorrect program behaviors. Such systems provide notices of test case failures or runtime errors, but without debugging skills, students often become frustrated when they don't know where to start. They know their code has defects, but finding the problem may be beyond their experience, especially for beginners. An additional concern is balancing the need to provide enough direction to be useful, without giving the student so much direction that you effectively give them the answer. This paper presents our experience using heat maps to visually guide student attention to parts of their code that are most likely to contain problems. These visualizations are generated using existing tools that capture execution traces from instructor-written tests to identify which portions of the code are executed during tests that\u00a0\u2026", "num_citations": "5\n", "authors": ["2183"]}
{"title": "Mode of presentation rather than the'weekend effect'is a major determinant of in-hospital mortality\n", "abstract": " BackgroundThe influence of patient demographics and mode of admission on the \u2018weekend effect\u2019 remains unclear. This study examins the relationship between day of admission, patient demographics, mode of presentation and survival.MethodsHospital admissions over a three-year period were studied. Patients with an inpatient stay less than 24\u00a0h and those who were discharged from the emergency department were excluded. In-hospital mortality was correlated with day of admission, age, gender and mode of presentation in a binary logistical regression analysis.ResultsThere were 448,827 admissions, of which 350,648 (85.7%) occurred during a weekday. 256,777 (62.7%) were emergency presentations, which was closely related to a weekend admission (92.3% vs 57.8%, p\u00a0<\u00a00.001). There were 8099 deaths of which 6336 (78.2%) related to a weekday admission and 1736 (21.4%) related a weekend\u00a0\u2026", "num_citations": "5\n", "authors": ["2183"]}
{"title": "Sofia: the simple open framework for inventive android applications\n", "abstract": " Mobile application development in general, and the Android platform in particular, are hot topics among educators because of their power to motivate and engage students. Unfortunately, Android's software API is not designed for beginners and presents a number of stumbling blocks to classroom use. Sofia is a new abstraction layer over the Android API that provides a cleaner, simpler, easier to use API for beginners and professionals alike. It includes a novel event dispatch design that eliminates the glue code required by more conventional frameworks, provides a powerful 2D shape package with declarative animation support and physics simulation, streamlines the process of writing multi-activity apps for Android, and addresses a number of other issues that make Android hard to use in introductory courses.", "num_citations": "5\n", "authors": ["2183"]}
{"title": "Adding software testing to programming assignments\n", "abstract": " This tutorial provides a practical introduction to how one can incorporate software testing activities as a regular part of programming assignments, supported by live demonstrations, with a special focus on early introduction in CS1 and/or CS2 courses. It presents five different models for how one can incorporate testing into assignments, provides examples of each technique, and discusses the corresponding advantages and disadvantages. The focus is on unit testing, test-driven development, and incremental testing, all of which work well in a classroom environment. Examples will use Java, although participant discussion regarding support in other languages such as Python and C++ is welcome. Approaches to assessment- using testing to assess student code, assessing tests that students write, and automated grading-are all discussed. A live demonstration of automatic assignment grading based on student\u00a0\u2026", "num_citations": "5\n", "authors": ["2183"]}
{"title": "Re-imagining CS1/CS2 with Android using the Sofia framework\n", "abstract": " Android has seen increased use in introductory CS courses to motivate and excite students about their programming assignments, but using the standard Android libraries as a GUI platform in CS2 presents numerous challenges and using it in CS1 is nearly impossible. This workshop introduces participants to Sofia, the Simplified Open Framework for Innovative Android Applications, developed by the Web-CAT team at Virginia Tech. Sofia abstracts out many of the advanced concepts normally required to develop interesting applications, using a unique approach to event handling, binding GUI elements to Java code, and user interaction. The goal is to allow students to focus entirely on using Java programming skills to solve problems in the application domain, instead of writing monotonous glue code typically required to construct an Android application. Laptop optional.", "num_citations": "5\n", "authors": ["2183"]}
{"title": "Making the case for assertion checking wrappers\n", "abstract": " Defensive programming practices have not kept up with the evolution of current programming languages or techniques. While appropriate for use by the original developer, embedded assertions are difficult to use and control for clients of reusable components distributed in binary form--a perspective that is increasingly important with the rise of component-based development. A new strategy for using run-time assertion checks based on design by contract is proposed where checking code is placed in a separate wrapper class that can easily be inserted or removed. Use of a factory pattern for component creation allows client code to remain unchanged when switching between enabled or disabled checking (typically without requiring recompilation). There is no run-time penalty for checks when they are disabled, yet full control over when to enable checks--and how thoroughly checking is performed--can be left up to the client of the component. Further, both the checking wrapper and the underlying component can be distributed in compiled form, giving the client control without requiring source code access or recompilation of the component itself.", "num_citations": "5\n", "authors": ["2183"]}
{"title": "Specifying and verifying collaborative behavior in component-based systems\n", "abstract": " In a parameterized collaboration design, one views software as a collection of components that play specific roles in interacting, giving rise to collaborative behavior. From this perspective, collaboration designs revolve around reusing collaborations that typify certain design patterns. Unfortunately, verifying that active, concurrently executing components obey the synchronization and communication requirements needed for the collaboration to work is a serious problem. At least two major complications arise in concurrent settings:(1) it may not be possible to analytically identify components that violate the synchronization constraints required by a collaboration, and (2) evolving participants in a collaboration independently often gives rise to unanticipated synchronization conflicts. This work presents a solution technique that addresses both of these problems. Local (that is, role-to-role) synchronization consistency\u00a0\u2026", "num_citations": "5\n", "authors": ["2183"]}
{"title": "Board 43: Designing Boosters and Recognition to Promote a Growth Mind-set in Programming Activities\n", "abstract": " When one first learns to program, feedback on early assignments can easily induce a fixed mindset---where one believes programming is a fixed ability you either have or you don't. However, possessing a fixed mindset perspective has negative consequences for learning. The alternative is to foster a growth mindset, where one believes ability can be improved through practice, effort, and hard work. However, automated grading tools used on programming assignments currently focus on objectively assessing functional correctness and other performance-oriented features of student programs. This encourages students to adopt performance-oriented goals, which are characteristic of a fixed mindset. By building on existing measures of\" productive effort\", we design a new kind of feedback approach that focuses on recognizing, encouraging, and rewarding diligence and productive actions based on those indicators. The goal is to add such elements to existing feedback in an emotionally supportive way that recognizes the efforts a student expends and values these practices. The feedback design presented here consists of two main components: textual/verbal feedback that recognizes productive effort students spend on a problem, or that encourages students to be strategic about expending effort to improve their own skills. The point of this feedback is to convey to the student that constructive practice to improve one's skills is valued and recognized, independently of the final product they are creating. In addition to the textual feedback, the feedback also includes boosters, or rewards in the form of perks that enhance parts of the student work\u00a0\u2026", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Approaches for coordinating eTextbooks, online programming practice, automated grading, and more into one course\n", "abstract": " We share approaches for coordinating the use of many online educational tools within a CS2 course, including an eTextbook, automated grading system, programming practice website, diagramming tool, and debugger. These work with other commonly used tools such as a response system, forum, version control system, and our learning management system. We describe a number of approaches to deal with the potential negative effects of adopting so many tools. To improve student success we scaffold tool use by staging the addition of tools and by introducing individual tools in phases, we test tool assignments before student use, and we adapt tool use based on student feedback and performance. We streamline course management by consulting mentors who have used the tools before, starting small with room to grow, and choosing tools that simplify student account and grade management across multiple\u00a0\u2026", "num_citations": "4\n", "authors": ["2183"]}
{"title": "The effects of extra credit opportunities on student procrastination\n", "abstract": " Many techniques have been attempted to encourage students to exercise better time management on class projects, such as staging an assignment into multiple deliverables, requiring students to keep records of the time they spend, and offering extra credit for early completion. This paper reports on a study of the effects of offering extra credit for early completion. Students in an introductory course completed four programming assignments throughout the term. For two assignments, no extra credit was offered. For the other two, students were offered a 10% bonus if they finished at least three days before the deadline. While one might expect this incentive to encourage students to shift their work habits, we found that there was no positive change in their time management. In fact, students started on the assignments where extra credit was offered later than on those where it was not offered. This leads us to believe\u00a0\u2026", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Bringing creative web 2.0 programming into CS1: conference workshop\n", "abstract": " Improving recruitment and retention depends on linking activities to real-world contexts that illustrate the social and societal impact of computer science. The sleek interaction and underlying technologies that define Web 2.0 applications offer a unique opportunity to teach CS concepts in a real-world context. Learn how students can create engaging Web 2.0 applications using simple Java programming and basic XHTML, without learning JavaScript or AJAX. See a full set of CS1 assignments leveraging this strategy. See how students can write a personal \"Facebook-lite\" they can show to friends. Play with live demos yourself. Leave with new assignment ideas.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Using a Rubric-based assessment system to improve feedback and student performance in course management systems\n", "abstract": " Writing skills are critical to student success both in university as well as after graduation. The importance of feedback to students on writing assignments has been well established, but the typical feedback students receive on assignments submitted via a course management system (CMS) is disconnected from the actual content of the student\u2019s work. As instructors move more towards managing assignments electronically, this disconnect has become more pronounced. Instructors have developed a variety of methods for providing feedback on electronically submitted assignments, but the bulk of these processes do not provide the feedback within the context of the original assignment. There have been some efforts to provide methods to markup assignments online, but those efforts have been limited to custom toolsets as opposed to additions to popular CMS packages. Another issue faced by instructors, centers on\u00a0\u2026", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Scheduling, Pair Programming, and Student Programming Assignment Performance\n", "abstract": " We seek to address poor performance by under-graduate students on major programming projects caused by procrastination and inadequate time management skills related to scheduling and pacing in project development. During Fall, 2006 we introduced two innovations into our Sophomore-level Data Structures course: Pair programming and a simple scheduling form. Our efforts do not appear to have had a significant difference in overall outcomes. However, the information gathered during this intervention makes a compelling case that students who spread their work over more time will produce a better result without additional expenditure of total effort. Pair programming did not have an identifiable impact on project outcomes or student behavior.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Note taking and the tablet PC\n", "abstract": " Note taking is a common and important classroom activity. The Tablet PC seems to be an obvious choice to support this task. In this paper, we explore its use and some of effects on note taking. To do this, we surveyed students about their note taking styles and observed the Tablet PC\u2019s use as a note taking device in lecture settings. From this we found that, due to variations in the speed at which they could use the device, in the size of their handwriting, and in how they dealt with the digital nature of the platform, the Tablet PC does not meet everyone\u2019s needs equally. While our evaluations occurred at the college level, the findings are relevant to many other educational venues.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Graphing performance on programming assignments to improve student understanding\n", "abstract": " Within computer science education, automated grading systems are used by many institutions. This paper summarizes an investigation into how the data collected by an electronic submission system can be used to aid students and instructors. Rather than simply providing feedback on a single submission, a grading system can give a student summary information about individual improvement over time, as well as where the student stands with respect to his or her peers. We explore graphical presentations\u2014in the form of bar charts, histograms, and line charts\u2014of a student\u2019s personal progress over time, as well as the student\u2019s current performance in relationship to the remainder of the class body. Particular attention is paid to how graphs can help the student understand likely future outcomes on assignments based on current effort expended, and on \u201ccalibrating\u201d one\u2019s own understanding of how the rest of the class is performing.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Lessons Learned by Comparing On-line Education Strategies Across Disciplines\n", "abstract": " When choosing how best to employ educational technologies for on-line learning, there is much to be gained by examining the experience of educators in other disciplines. This paper presents four brief case studies in the disciplines of computer science and social work. Lessons learned by comparing these diverse experiences are discussed, including creating a community of learners, supporting asynchronous student communication, using synchronous on-line meetings, and providing social support. In addition, the experiences presented indicate that stereotypes of student capabilities and expectations may often be inaccurate, and revising one\u2019s views may be helpful in achieving better results in on-line education.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Protocol design of dual ring PESNet (DRPESNet)\n", "abstract": " Abstract\u2212 A new version of PESNet is presented that uses dual, counter-rotating fiber optic rings to address critical issues in earlier solutions for distributed power electronics control applications. The new protocol supports fault tolerance and network synchronization features. The protocol packet structure, commands and operating modes will be described and analyzed using an example application.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Improved architecture of PEBB plug and play power electronics systems: Elementary control object (ECO) and dataflow\n", "abstract": " This paper presents a reconfigurable and reusable decentralized architecture, ECO\u2014Dataflow architecture, for control of power electronics systems. Under this architecture, the control of a power electronics system is composed of elementary control objects (ECOs), and the connections between ECOs is implemented by Dataflow. Software implementations of ECOs and Dataflow will be discussed. A 3-phase inverter will be constructed under ECO\u2014Dataflow architecture, and the system under the proposed architecture will be compared to the system designed in the legacy architecture.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Common interface models for components are necessary to support composability\n", "abstract": " Unfortunately, reusable components are often based on di erent conceptual models of behavior. The model underlying the speci cation of one module's parameter requirements may signi cantly di er from the model underlying the speci cation of another module's exported features, even if the two modules intuitively seem compatible. There is no well understood groundwork of common models for component interaction, and the lack of guidelines for applying these models exacerbate the composability problem. This paper will describe how varying interface models and techniques for describing a component's interface requirements a ect composability. These problems will be illustrated in the context of common interface properties that are exhibited even in simple components.", "num_citations": "4\n", "authors": ["2183"]}
{"title": "Pedagogical Agent as a Teaching Assistant for Programming Assignments\n", "abstract": " Pedagogical agents have received a large amount of interest in the recent years. Equipped with the ability to express emotions, these agents can influence the user attitudes, perceptions and behaviour. In our study, we are leveraging these emotionally-intelligent pedagogical agents to deliver effective and efficient feedback to students about their programming assignments and also act as a teaching assistant for any general programming related queries. We have integrated the pedagogical agent as part of Web-CAT-an automated online grading tool for students' programs. One of our main objectives is to communicate clearly the feedback about student programs while motivating them to perform better. Displaying the feedback and motivational messages to students all the time can quickly become noise and students tend to ignore them. Our study is to strategically have the pedagogical agent communicate with\u00a0\u2026", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Open source software-defined radio tools for education, research, and rapid prototyping\n", "abstract": " Software-defined radios (SDR) offer several advantages over traditional, hardware-based radios, most notably flexibility and reconfigurability. Developing SDR applications can be a difficult process, however, for several reasons. First, much of the work involved deals with standards compliance, rather than radio functionality. This portion of the work is very detailed and error prone, leading to wasted time and effort. Second, there is little to no support available for the debugging and refinement portions of the development cycle. There is no easy way to monitor or control SDR applications at runtime. The Waveform Workshop was created to address these issues. A part of the OSSIE SDR project, the Waveform Workshop drastically reduces the time and effort involved in SDR development. It automatically generates the portions of the software related to standards compliance, letting developers concentrate on\u00a0\u2026", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Continuous Data-driven Learning Assessment\n", "abstract": " As educators of novice programmers, we are constantly seeking ways to improve the educational experience of our students. Regardless of what intervention we employ\u2014whether it is a lab-centric model of instruction, a multiple-choice approach to assessment, or the use of pair programming in the classroom\u2014we lack tools to evaluate the effectiveness of our interventions with respect to our students\u2019 programming practices. Our best assessment often comes from grades on examinations, which rarely provide a lens into the day-to-day experiences and learning of our students. The teaching and study of novice programmers is rife with claims regarding the benefits of learning to program and the power of [insert pedagogic intervention here]. While automatic, on-line protocols are commonplace in human-computer interaction studies, no framework for automatically collecting and analyzing student programming behavior\u2014beginning with code authoring and ending with assessment\u2014exists today. The systematic collection of this data is critical to the teaching of programming from three different perspectives:", "num_citations": "3\n", "authors": ["2183"]}
{"title": "RoboLIFT: simple GUI-based unit testing of student-written android applications\n", "abstract": " Many computer science educators have adopted test-driven development practices in their introductory computer science courses, as a way of encouraging incremental development and decreasing defects in student code. This practice is straightforward for basic data-driven objects, but making unit testing of GUI applications approachable for students poses a larger challenge. We have previously addressed this problem for Swing applications by developing LIFT, a library that allows students to easily write JUnit tests for Swing interfaces. Since then, we have transitioned away from Swing to Android as the development platform in CS2 to better motivate and excite our students about their assignments. To fully support this change, we had to ensure that our students could fully test the GUI portions of their solutions on that platform as well. The Android operating system has significant built-in support for GUI testing\u00a0\u2026", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Ensemble: a distributed portal for the distributed community of computing education\n", "abstract": " NSF\u2019s NSDL is composed of domain-oriented pathways. Ensemble is the pathway for computing and supports the full range of computing education communities, providing a base for the development of programs that blend computing with other STEM areas (e.g., X-informatics and Computing + X), and producing digital library innovations that can be propagated to other NSDL pathways. Computing is a distributed community, including computer science, computer engineering, software engineering, information science, information systems, and information technology. Ensemble aims to provide much needed support for the many distinct yet overlapping educational programs in computing and their associated communities. To do this, Ensemble takes the form of a distributed portal providing access to the broad range of existing educational resources while preserving the collections and their associated\u00a0\u2026", "num_citations": "3\n", "authors": ["2183"]}
{"title": "An infrastructure for teaching CS1 in the cloud\n", "abstract": " A key goal of entry level computer science classes is the recruitment and retention of potential computer science graduates. Many entry level classes struggle to show students the real world context and social and societal impact of computer science. Modern Web 2.0 applications provide an attractive way of putting computer science in a realistic context. However, efforts to teach such applications in a first CS course are hampered by the fact that they require a deep understanding of multiple and complex concepts and technologies. Rather than focusing on learning core computer science concepts, students would need to learn transient and technology-specific knowledge.This paper presents the initial design of CloudSpace, a teaching environment that allows students to understand core computer science concepts in the context of modern web applications. CloudSpace presents entry-level CS students with a virtual environment to develop web applications in a manner similar to the development process of desktop user interface applications. For example, CloudSpace allows students to work with abstractions such as a console and or a file system that mimic the environment in which traditional programs run. This virtual environment also shields students from the distributed nature of the web technologies with which they work.", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Implementation and evaluation of laboratory/tutorial exercises for software defined radio education\n", "abstract": " Software defined radio (SDR) integrates several areas of electrical engineering, computer engineering, and computer science. Graduate courses at the Naval Postgraduate School and Virginia Tech survey SDR concepts and enabling technologies and provide hands-on experience via a project-oriented approach. The institutions have developed exercises that use the OSSIE open source SDR software, based on the Software Communications Architecture (SCA), an open US Department of Defense standard and prevalent industry approach to SDR engineering. The exercises are suitable for use in university and short courses, and for individual study. Introductory exercises reinforce SDR and SCA concepts while familiarizing students with SDR infrastructure and rapid prototyping tools and preparing students for design and implementation projects. Later exercises include development of SDR broadcast receivers and digital transceivers, remote monitoring of SDR applications, and distributed SDR applications. The exercises are assessed based on retrospective pre-and post-tests, student evaluations, and analysis of download data.", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Changes in Australian attitudes towards global warming\n", "abstract": " CSIRO Research Publications Repository - Changes in Australian attitudes towards global warming Skip to Main Content CSIRO Home Research Publications Repository Contact Us Help CSIRO Login Username Password Search Publications Advanced Search Browse Publications Selected Records () Changes in Australian attitudes towards global warming Description Select | OK Print Author: Power, SB; Plummer, N.; Pearce, KB; Walland, D.; Edwards, S.; Jones, D.; Gipton, S.; Holper, PN; Whitehead, R. Date of Publication: 2008 Publication Type: Journal Article Journal Title: MeteoWorld Keywords: Marine and Atmospheric Research Identifier: procite:425c4d3e-006e-44fd-824f-f6217fdbcaad Attribution Statement: Power, SB; Plummer, N.; Pearce, KB; Walland, D.; Edwards, S.; Jones, D.; Gipton, S.; Holper, PN; Whitehead, R. Changes in Australian attitudes towards global warming. MeteoWorld. 2008. http://hdl.\u2026", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Helping students test programs that have graphical user interfaces\n", "abstract": " Within computer science education, many educators are incorporating software testing activities into regular programming assignments. Tools like JUnit and its relatives make software testing tasks much easier, bringing them into the realm of even introductory students. At the same time, many introductory programming courses are now including graphical interfaces as part of student assignments to improve student interest and engagement. Unfortunately, writing software tests for programs that have significant graphical user interfaces is beyond the skills of typical students (and many educators). This paper presents initial work at combining educationally oriented and open-source tools to create an infrastructure for writing tests for Java programs that have graphical user interfaces. Critically, these tools are intended to be appropriate for introductory (CS1/CS2) student use, and to dovetail with current teaching approaches that incorporate software testing in programming assignments. We also include in our findings our proposed approach to evaluating our techniques.", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Supporting on-line direct markup and evaluation of students' projects\n", "abstract": " Automated grading systems have been in use for several years. These systems automate part of the grading process by compiling, executing and testing student submitted source code. However, such systems often fail to include a mechanism to allow instructors or grader to provide free form comments on student work. One must resort to other methods to provide feedback to students.This paper presents the development of a feedback mechanism that streamlines the grading process for instructors and teaching assistants. A web-based grading tool has been developed that allows course staff to enter comments for student programs directly through a web browser. This tool is tightly integrated with Web-CAT, an automated grader. The result is a one-stop web-based interface for students to receive all of their feedback.", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Transparent distributed messaging for power electronics systems\n", "abstract": " This paper presents a distributed transparent messaging protocol for plug and play power electronics building blocks (PEBBs). The protocol provides for transparent messaging between processors across a network for any multicontroller application. The protocol works for an application with any number of controllers and processor allocation strategy, without any code change. The paper further includes an assessment of network parameters to determine system performance.", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Differential charge pump for providing a low charge pump current\n", "abstract": " A differential charge pump for providing a low charge pump current. The present invention operates in one embodiment as part of an integrated circuit of a semiconductor chip by providing very small magnitude currents to other on-chip circuitry. Specifically, one embodiment of the present invention utilizes an R-2R resistor ladder circuit having moderate sized resistors to progressively reduce a large magnitude current into a very small magnitude current of accurate size. In this manner, available on-chip circuitry voltage can be used to produce the desired small magnitude of current without utilizing excessively large resistors, which can occupy too much die area. This is advantageous when dealing with specific types of on-chip components and circuitry which require accurate currents having very small magnitudes. For example, it may be desirable to integrate filter components (eg, capacitors) on-chip together with\u00a0\u2026", "num_citations": "3\n", "authors": ["2183"]}
{"title": "Low side current sink circuit having improved output impedance to reduce effects of leakage current\n", "abstract": " A low side, low voltage current sink circuit having improved output impedance to reduce effects of leakage current. A current sink circuit is described having a transistor having its emitter coupled to an emitter degeneration resistor which is coupled to the low side (eg, ground) of a power supply. The output of the current sink is taken at the collector of the transistor. In one embodiment, the transistor is an NPN transistor device. The base of the transistor is coupled to the output of an operational amplifier. One input of the operational amplifier is coupled in a feedback loop to the emitter of the transistor. A direct current bias voltage is applied to the other input of the operational amplifier. In this arrangement, the output impedance (R \u2033o) of the current is sink is based on the open loop gain of the operational amplifier (eg, about 35 dB) and is therefore orders of magnitude larger than the output impedance of other prior art\u00a0\u2026", "num_citations": "3\n", "authors": ["2183"]}
{"title": "BTRecurTutor: a tutorial for practicing recursion in binary trees\n", "abstract": " Background and Context Recursion in binary trees has proven to be a hard topic. There was not much research on enhancing student understanding of this topic.Objective We present a tutorial to enhance learning through practice of recursive operations in binary trees, as it is typically taught post-CS2.Method We identified the misconceptions students have in recursive operations on binary trees. We designed a code writing exam question to measure those misconceptions. We built a tutorial that trains students on avoiding those misconceptions through the use of a semantic code analyzer that detects misconceptions and provides appropriate feedback.Findings Our results show an improvement in student performance when using the tutorial along with the practice exercises, and even more improvement when the same exercises are used with a semantic code analyzer.Implications The best way to use our tutorial\u00a0\u2026", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Applying recent-performance factors analysis to explore student effort invested in programming assignments\n", "abstract": " Automatic programming assessment systems are widely used. Feedback mechanisms in these systems are objective, performance-based, and may encourage a fixed mindset-encouraging the belief that programming ability is an innate trait, rather than a skill that can be improved. To address this, a group of progress indicators were developed to recognize the productive effort students invest in developing their work. This paper applies Recent-Performance Factors Analysis (R-PFA) to investigate student effort gains demonstrated by these indicators. The analysis was performed using historical data collected from a CS2 course. Among twelve indicators, learning curve analysis shows five indicators reflect improvements in student programming effort over time, while seven others do not show consistent gains, which may be due to lack of feedback given to students on those aspects of performance, or to intrinsic\u00a0\u2026", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Dereferee: instrumenting C++ pointers with meaningful runtime diagnostics\n", "abstract": " Proper memory management and pointer usage often prove to be the most difficult concepts for students learning C++ to grasp. Compounding this problem is the fact that the compilers and runtime environments traditionally used to introduce these concepts leave much to be desired with regard to generating meaningful diagnostics to assist students in tracking down and fixing memory\u2010related logical errors. To alleviate this, we have developed Dereferee, an advanced yet thin wrapper around C++ pointers that greatly increases the quality of these runtime diagnostics, but with only a small amount of intrusion into the development process. With regard to performance, memory\u2010intensive programs will experience execution times approximately 20\u201330 times slower when using Dereferee, which is comparable with other similar tools. Furthermore, the library has been designed to be customizable and easily disabled to\u00a0\u2026", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Using and sharing programming exercises to improve introductory courses\n", "abstract": " Short, automatically-assessed programming exercises, and other types of short practice problems, are a useful way to introduce and reinforce concepts and techniques in introductory programming courses. When delivered over the web, they allow students to learn and practice, with immediate feedback, at any time and place where they have access to a web browser. However, such exercises do not seem to be as widely used as they could be. Similarly, there is not a lot of literature on the effectiveness of these types of problems. The purpose of this BOF is to bring together users (and potential users) of programming exercises with developers of programming exercise systems to discuss how exercises could be used more widely and effectively. Possible discussion topics include: What features are absolutely essential for faculty to consider adoption? What are the major obstacles preventing more widespread\u00a0\u2026", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Improving exception messages with exceptiondoctor\n", "abstract": " Beginning programmers often have difficulty interpreting exceptions and using the associated messages to pinpoint the cause of incorrect program behavior. When an interactive development environment (IDE) presents a novice developer with a runtime time exception, it generally provides with a stack trace and a limited, cryptic exception message that is hard for a beginner to interpret. This paper describes ExceptionDoctor, a Java utility that solves this problem. ExceptionDoctor intercepts exceptions thrown by student code and improves the embedded exception messages to provide levelappropriate descriptions. ExceptionDoctor also examines the source code that produced the exception (if available) in order to describe the immediate cause of the exception in student-level terms.", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Comparison of dataflow architecture and Real-Time Workshop Embedded Coder in power electronics system control software design\n", "abstract": " Dataflow software architecture has been proposed to design reusable and reconfigurable control software for power electronics systems. Mathwork\u2019s Real-time Workshop is a commercial software tool supports fast prototyping and automatic program building. In this paper, the proposed dataflow architecture approach will be compared with the Realtime Workshop from software infrastructure, control functionality and flexibility. Several power electronics control applications will be used to compare the performance of code generated from the two approaches.", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Automatically assessing assignments that use test-driven development\n", "abstract": " Automatically Assessing Assignments That Use Test-Driven Development Page 1 3A-1 1 Automatically Assessing Assignments That Use Test-Driven Development Stephen H. Edwards Virginia Tech, Dept. of CS edwards@cs.vt.edu http://people.cs.vt.edu/~edwards/ \u220e Automatically Assessing TDD Assignments \u220e 2 Overview \u220e Need: \u220e Better software testing skills for our undergraduates \u220e Idea: \u220e Require test-driven development in assignments across a variety of courses \u220e Problem: \u220e How can we assess test suites to provide timely, effective feedback that encourages TDD? \u220e Automatically Assessing TDD Assignments \u220e 3 Why a Comprehensive Approach? \u220e Students cannot test their own code \u220e Didn\u2019t want a single \u201ctesting course\u201d \u220e Probably optional to students \u220e Upper division course has little impact on practices in other classes \u220e Deeper training, but less impact on actions \u220e Instead, want a culture shift in \u2026", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Method and circuit for an improved adaptive comb filter for separation of chrominance and luminance components from a composite video signal\n", "abstract": " A method and circuit thereof for detecting uncorrelated lines of chrominance of a composite video signal. A threshold level for determining whether lines of chrominance are correlated is defined. A comb filter is then used to separate the chrominance information from the luminance information of a composite video signal. In one embodiment, readings for three consecutive scan lines of chrominance are taken. If any of the adjacent scan lines contain the same color information or the difference is less than the threshold level, the scan lines are correlated. Otherwise, the adjacent scan lines are uncorrelated. If the lines are uncorrelated, a band pass filter is used to separate the chrominance component from the composite video signal. If the lines are correlated, the separation performed by the comb filter was appropriate and no other action is necessary. The present invention is an improved method of identifying\u00a0\u2026", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Designing Reusable, Reconfigurable Control Software for Power Electronics Systems\n", "abstract": " This paper presents dataflow architecture to design reusable and reconfigurable control software of power electronics systems. Reasons that traditional \u201cmain-programand-subroutine\u201d architecture causes lots of software issues of power electronics control software are analyzed. The infrastructure of dataflow architecture will be discussed. And a 3-phase inverter application is used as an example to evaluate the proposed software architecture vs. the legacy \u201cmainprogram-and-subroutine\u201d approach.", "num_citations": "2\n", "authors": ["2183"]}
{"title": "Incorporating Practical Computing Skills Into a Supplemental CS2 Problem Solving Course\n", "abstract": " Computer scientists are often expected to obtain practical technical skills on their own. We have updated our supplemental CS2 problem-solving course to introduce students to technical skills across a variety of computer science topics in order to expand their incidental skills that often fall through the cracks. The goal of the course is for students to feel comfortable taking their problem solving skills to unfamiliar computing situations. This course helps bridge the gap for students with less computing experience by introducing them to current computer science tools and demystifying potentially intimidating topics such as version control, security, command line tools, web development and machine learning. This experience report details our motivation and approaches for this contemporary problem-solving course. We discuss outcomes regarding student perceptions of the course, and our innovative approach of measuring student comfort in situations that require solving problems with computer science such as undergraduate research, hackathons, and personal programming projects.", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Using the\" Daily Missions\" Gamification Strategy To Promote Incremental Progress on Programming Assignments\n", "abstract": " Automatic assessment tools are increasingly utilized in undergraduate programming courses to evaluate software solutions, streamlining the grading process for both students and professors. In spite of their benefits of speed and convenience, such online systems for providing instant feedback have the tendency to draw attention to performance-based outcomes while failing to reliably recognize the effort and hard work a student puts into a solution. For the many struggling students who are new to programming, this type of objective feedback can be discouraging and may decrease their motivation to stay engaged towards success. To address this issue, this paper explores strategies for more effectively recognizing student progress on programming assignments and identifying small tasks for students to complete that will steer them in the right direction. Further, this paper presents the design of a\" Daily Missions\" gamification strategy that was added to an automated program grading system. A pilot study shows feasibility of the approach and suitability of the design, indicating a statistically significant increase in the rate of completing tasks assigned as daily missions, and that students believe daily missions reinforce good practices while giving them better ideas on how to improve their work. An evaluation of experiences from using the strategy in the classroom is presented, along with student perceptions from using the system.", "num_citations": "1\n", "authors": ["2183"]}
{"title": "The Relationship Between Voluntary Practice of Short Programming Exercises and Exam Performance\n", "abstract": " Learning to program can be challenging. Many instructors use drill-and-practice strategies to help students develop basic programming techniques and improve their confidence. Online systems that provide short programming exercises with immediate, automated feedback are seeing more frequent use in this regard. However, the relationship between practicing with short programming exercises and performance on larger programming assignments or exams are unclear. This paper describes an evaluation of short programming questions in the context of a CS1 course where they were used on both homework assignments, for practice and learning, and on exams, for assessing individual performance. The open-source drill-and-practice system used here provides for full feedback during practice exercises. During exams, it allows limiting feedback to compiler errors and to a very small number of example inputs\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Student Debugging Practices and Their Relationships with Project Outcomes\n", "abstract": " Debugging is an important part of the software development process, studied by both the CS education and software engineering communities. Most prior work has focused either on novice or professional programmers. Intermediate-to-advanced students (such as those enrolled in post-CS2 Data Structures courses) who are working on large and complex projects have largely been ignored. We present results from an empirical observational study that examined junior-level undergraduate students' debugging practices on relatively large (4-week lifecycle) projects, using IDE clickstream data collected by a custom Eclipse plugin. Specifically, we hypothesize that there are differing debugging behaviors exhibited, and that differing behaviors lead to differing project out-comes. For example, how often do students use the symbolic debugger available in modern IDEs, versus how often do they use diagnostic print\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "The absolute beginner's guide to JUnit in the classroom\n", "abstract": " Software testing has become popular in introductory courses, but many educators are unfamiliar with how to write software tests or how they might be used in the classroom. This workshop provides a practical introduction to JUnit for educators. JUnit is the Java testing framework that is most commonly used in the classroom. Participants will learn how to write and run JUnit test cases; how-to's for common classroom uses (as a behavioral addition to an assignment specification, as part of manual grading, as part of automated grading, as a student-written activity, etc.); and common solutions to tricky classroom problems (testing standard input/output, randomness, main programs, assignments with lots of design freedom, assertions, and code that calls exit ()).", "num_citations": "1\n", "authors": ["2183"]}
{"title": "A new event dispatch strategy to eliminate dispatch \u201cglue\u201d\n", "abstract": " In statically typed object-oriented languages such as Java, GUI event handling is traditionally handled through listener interfaces or similar types of polymorphic delegation. In the case of events that pass information about their source to the handling method, the programmer is required to perform runtime type checks to determine the true types of the components involved. This produces poorly designed code that contains a second layer of hand-written type-based dispatch before events can actually be handled. In this paper we present an alternative approach that builds this second dispatch layer into the underlying framework. The approach uses run-time reflection and overload resolution to automatically distinguish events based on method argument types, and to implicitly bind them to the event publishers. This approach combines the type safety of a statically typed language with the run-time flexibility of modern\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "CoPractice: An Adaptive and Versatile Practice Tool\n", "abstract": " Intelligent tutoring systems and other adaptive instructional technologies facilitate learning by customizing feedback to students\u2019 struggles. However, adaptability of expert systems can come at the sake of versatility. Developing software to assist students in a particular domain can be challenging; to then apply its expertise and pedagogical approach to another domain can be both challenging and inappropriate. CoPractice is a web-centered practice environment that uses community-contributed content to establish a versatile system that adapts to learners based on measurements of their knowledge. Selection of both questions and feedback are based on persistent measurements of their effectiveness. This paper describes CoPractice's measurements and design for both adaptability and versatility.", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Going Beyond Algorithm Visualization to Algorithm Exploration\n", "abstract": " While algorithm visualizations have proved valuable to the CS education community, even the better algorithm visualizations today are typically limited to instruction in the mechanics of how a given data structure or algorithm behaves. We present the concept of an \u201calgorithm exploration,\u201d which goes beyond the scope of algorithm visualizations to provide students with an opportunity to explore the relative merits of alternative solutions for a particular problem. As an illustration of what an algorithm exploration might look like, we describe a hashing tutorial that we have implemented. We discuss why algorithm explorations are more difficult to implement than standard algorithm visualizations. Results are presented for an evaluation comparing performance on a post test by students that used the hashing tutorial versus students receiving instruction through standard lecture and a textbook.", "num_citations": "1\n", "authors": ["2183"]}
{"title": "A data type to exploit online data sources\n", "abstract": " Recent work in developing student assignments has involved making use of online data resources to make them more interesting and to give students real world information to interact with in some manner. While definitely a practical approach, the work that has been done so far is either for \"CS0\" courses targeted at non-majors, often using tools like Microsoft Excel, or courses that require a level of skill at programming from the students. Additionally, existing tools are specific to a particular structure of the data (CSV, XML, and others). As a result, these constraints make on-line real-world data sets difficult to use in typical introductory programming courses for majors. Objects-first approaches to teaching introductory programming advocate the use of objects early on. Consequently, students are able to take advantage of using data types early on. We have created an interface that allows students to access real-world\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Genetic susceptibility to prostate cancer due to rare mutations in genes in the DNA repair pathway.\n", "abstract": " 1816The causes of prostate cancer (PrCa) are still not well understood, but there is strong evidence that a proportion of cases occur due to a genetic predisposition and the associated disease manifests at a young age of onset and/or in familial clusters. Linkage studies suggest multiple candidate loci, but so far none have identified high-risk PrCa predisposition genes. The first convincing high risk PrCa predisposition gene, BRCA2, was identified using a candidate gene analysis approach which showed that about 2% of men who are diagnosed with PrCa at <55 years have germline mutation in their BRCA2 gene. Since BRCA2 has a direct role in DNA damage repair we are investigating the possibility that other genes in this pathway or genes coding for proteins which interact with BRCA2 might be involved in PrCa predisposition.\u2028 We have screened 7 such genesfor germline mutations in blood DNA samples from\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Mining the Data in Programming Assignments for Educational Research\n", "abstract": " In computer science and information technology education, instructors often use electronic tools to collect, compile, execute, and analyze student assignments. The assessment results produced by these tools provide a large body of data about student work habits, the quality of student work, and the areas where students are struggling. This paper reports on efforts to extract significantly more useful data from electronically collected assignments in computer programming courses. The work is being performed in the context of the most widely used open-source automated grading system: Web-CAT. We have enhanced a Web-CAT plug-in to allow collection of data about the frequency and types of run-time errors produced by students, the frequency and types of test case failures that occur during grading, basic code size metrics, test coverage metrics, and more. This information can be combined with the results of \u201cby-hand\u201d grading activities to form a large, rich data corpus characterizing student behavior over many assignments in one course, over many courses, and even across semesters. The data collected in this way is a valuable resource for researchers in computer science education.", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Helping Students Visualize Their Grade Performance\n", "abstract": " NOTE: The first page of text has been automatically extracted and included below in lieu of an abstract", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Standard-Cell, Open-Architecture Power Conversion Systems\n", "abstract": " This Final Report compiles all the work carried out at the Center for Power Electronics Systems (CPES), corresponding to the\" Standard-Cell, Open-Architecture Power Conversion Systems\" project sponsored by the Office of Naval Research (ONR). This project was purposefully aimed to develop a standardized hierarchical design and analysis methodology for modular power electronics conversion systems using as basis the ISO/OSI seven-layer reference model. The foundational ideas of this engineering vision came from the Power Electronics Building Block (PEBB), seeking to expand the usage of this concept while exploiting the numerous advantages offered by it, namely modularity, scalability, reconfiguration and reduced design cycles. The means to the end chosen was the actual embracing of the hierarchical nature of PEBB-based converters by applying it to the modeling approach, control software, and energy processing characterization of power electronics systems. The resultant two-dimensional hierarchical reference model pursues the complete analysis and design of power electronics systems, covering not only the electromagnetic, thermal and mechanical interactions from semiconductors up to complete power systems, but also their associated controls, modeling and communications at every hierarchy level. In order to achieve these objectives several tasks were identified and undertaken in this project. Specifically, several studies were conducted in order to fully characterize the energy processing functions observed in shipboard power systems, individually addressing the PEBB, power converter and power system levels. The\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "High side current source circuit having improved output impedance to reduce effects of leakage circuit\n", "abstract": " A high side low voltage current source circuit having improved output impedance to reduce effects of leakage current. A current source circuit is described with a transistor having an emitter coupled to an emitter degeneration resistor which is coupled to a power supply voltage. The output of the current source is taken at the collector of the transistor. In one embodiment, the transistor is a PNP transistor device. The base of the transistor is coupled to the output of an operational amplifier. One input of the operational amplifier is coupled in a feedback loop to the emitter of the transistor. A direct current bias voltage is applied to the other input of the operational amplifier. The output impedance (R \u2033o) of the current is source is based on the open loop gain of the operational amplifier (eg, about 35 dB) and is therefore orders of magnitude larger than the output impedance of other prior art current source designs. Also\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "High input impedance buffer circuit having a high-side current source circuit with RCB cancellation\n", "abstract": " A buffer circuit having a high input impedance. The buffer circuit comprises an input lead, a first stage having a first emitter follower transistor and a first level shifter transistor, a second stage having a second emitter follower transistor and a second level shifter transistor, and an output lead coupled to said second stage. The first emitter follower transistor is coupled to the input lead and coupled to the first level shifter transistor. The first and second stage of the buffer circuit acts as a voltage follower. The second emitter follower transistor is coupled to the second level shifter transistor, while the second emitter follower transistor is coupled to the first emitter follower transistor. The buffer circuit has a high input impedance and very low leakage current. Hence, it is ideal for sampling filter components of a phase lock loop circuit within a high frequency clock generation circuit thereby reducing clock jitter.", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Palette: A reuse-oriented specification language for real-time systems\n", "abstract": " We present Palette, a reusable specification language for real-time control systems. Palette is a meta-language that is programming language independent and has generic, reusable functional abstractions that can be customized to construct a real-time system in a given context. The abstractions allow modeling of the interactions of the system with its physical environment, including the specification of data and event stream properties, and allow expression of quality of service (QoS) requirements such as timeliness and survivability. Palette supports mechanisms that allow construction of new abstractions from existing ones. The set of reusable, domain specific abstractions provided by the language thus serves as an implementation vehicle for constructing new real-time control systems\u2014promoting reuse-in-the-large\u2014or enhance existing systems within the domain by reusing individual components\u00a0\u2026", "num_citations": "1\n", "authors": ["2183"]}
{"title": "Strategic Defense Initiative Architecture Dataflow Modeling Technique Version 1.5.\n", "abstract": " IDA Paper P-2035 presents the SDI Architecture Dataflow Modeling Technique SADMT, a uniform formal notation for the description of SDI system architectures and Battle Management and Command, Control and Communications BMC3 architectures. SADMT is a technique for thinking about and describing architectural processes and structures that use the typing and functional facilities of the Ada programming language. This document defines SADMT and the programming interface to the SADMT Simulation Facility SADMTSF. The issues addressed here are those relevant to providing formal descriptions of system structure and behavior for interface consistency checking, system simulation, and system evaluation.Descriptors:", "num_citations": "1\n", "authors": ["2183"]}