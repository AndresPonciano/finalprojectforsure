{"title": "Ownership, encapsulation and the disjointness of type and effect\n", "abstract": " Ownership types provide a statically enforceable notion of object-level encapsulation. We extend ownership types with computational effects to support reasoning about object-oriented programs. The ensuing system provides both access control and effects reporting. Based on this type system, we codify two formal systems for reasoning about aliasing and the disjointness of computational effects. The first can be used to prove that evaluation of two expressions will never lead to aliases, while the latter can be used to show the non-interference of two expressions.", "num_citations": "328\n", "authors": ["1747"]}
{"title": "Towards type inference for JavaScript\n", "abstract": " Object-oriented scripting languages like Javascript and Python are popular partly because of their dynamic features. These include the runtime modification of objects and classes through addition of fields or updating of methods. These features make static typing difficult and so usually dynamic typing is used. Consequently, errors such as access to non-existent members are not detected until runtime.               We first develop a formalism for an object based language, JS0 with features from Javascript, including dynamic addition of fields and updating of methods. We give an operational semantics and static type system for JS0using structural types. Our types allow objects to evolve in a controlled manner by classifying members as definite or potential.               We define a type inference algorithm for JS0 that is sound with respect to the type system. If the type inference algorithm succeeds, then the program\u00a0\u2026", "num_citations": "250\n", "authors": ["1747"]}
{"title": "Session types for object-oriented languages\n", "abstract": " A session takes place between two parties; after establishing a connection, each party interleaves local computations with communications (sending or receiving) with the other. Session types characterise such sessions in terms of the types of values communicated and the shape of protocols, and have been developed for the \u03c0-calculus, CORBA interfaces, and functional languages. We study the incorporation of session types into object-oriented languages through Moose, a multi-threaded language with session types, thread spawning, iterative and higher-order sessions. Our design aims to consistently integrate the object-oriented programming style and sessions, and to be able to treat various case studies from the literature. We describe the design of Moose, its syntax, operational semantics and type system, and develop a type inference system. After proving subject reduction, we establish the progress\u00a0\u2026", "num_citations": "190\n", "authors": ["1747"]}
{"title": "More dynamic object reclassification: Fickle\u2225\n", "abstract": " Reclassification changes the class membership of an object at run-time while retaining its identity. We suggest language features for object reclassification, which extend an imperative, typed, class-based, object-oriented language.We present our proposal through the language Fickle\u22c4\u22c4. The imperative features, combined with the requirement for a static and safe type system, provided the main challenges. We develop a type and effect system for Fickle\u22c4\u22c4 and prove its soundness with respect to the operational semantics. In particular, even though objects may be reclassified across classes with different members, there will never be an attempt to access nonexisting members.", "num_citations": "117\n", "authors": ["1747"]}
{"title": "Deny capabilities for safe, fast actors\n", "abstract": " Combining the actor-model with shared memory for performance is efficient but can introduce data-races. Existing approaches to static data-race freedom are based on uniqueness and immutability, but lack flexibility and high performance implementations. Our approach, based on deny properties, allows reading, writing and traversing unique references, introduces a new form of write uniqueness, and guarantees atomic behaviours.", "num_citations": "116\n", "authors": ["1747"]}
{"title": "Chai: Traits for Java-like languages\n", "abstract": " Traits support the factoring out of common behaviour, and its integration into classes in a manner that coexists smoothly with inheritance-based structuring mechanisms.               We designed the language Chai, which incorporates statically typed traits into a simple Java-inspired base language, and we discuss three versions of the language: Chai                         1, where traits are only a mechanism for the creation of classes; Chai                         2 where traits are a mechanism for the creation of classes, and can also introduce types, and Chai                         3 where traits play a role at runtime, and can can be applied to objects, and change the objects\u2019 behaviour. We give formal models for these languages, outline the proof of soundness, and our prototype implementation.", "num_citations": "88\n", "authors": ["1747"]}
{"title": "A distributed object-oriented language with session types\n", "abstract": " In the age of the world-wide web and mobile computing, programming communication-centric software is essential. Thus, programmers and program designers are exposed to new levels of complexity, such as ensuring the correct composition of communication behaviours and guaranteeing deadlock-freedom of their protocols.             This paper proposes the language , a simple distributed object-oriented language augmented with session communication primitives and types.  provides a flexible object-oriented programming style for structural interaction protocols by prescribing channel usages within signatures of distributed classes.             We develop a typing system for  and prove its soundness with respect to the operational semantics. We also show that in a well-typed  program, there will never be a connection error, a communication error, nor an incorrect completion between server\u00a0\u2026", "num_citations": "83\n", "authors": ["1747"]}
{"title": "Automatic generation of self-monitoring MASs from multiparty global session types in Jason\n", "abstract": " Global session types are behavioral types designed for specifying in a compact way multiparty interactions between distributed components, and verifying their correctness. We take advantage of the fact that global session types can be naturally represented as cyclic Prolog terms - which are directly supported by the Jason implementation of AgentSpeak - to allow simple automatic generation of self-monitoring MASs: given a global session type specifying an interaction protocol, and the implementation of a MAS where agents are expected to be compliant with it, we define a procedure for automatically deriving a self-monitoring MAS. Such a generated MAS ensures that agents conform to the protocol at run-time, by adding a monitor agent that checks that the ongoing conversation is correct w.r.t. the global session type.               The feasibility of the approach has been experimented in Jason for a non-trivial\u00a0\u2026", "num_citations": "67\n", "authors": ["1747"]}
{"title": "A unified framework for verification techniques for object invariants\n", "abstract": " Object invariants define the consistency of objects. They have subtle semantics because of call-backs, multi-object invariants and subclassing. Several visible-state verification techniques for object invariants have been proposed. It is difficult to compare these techniques and ascertain their soundness because of differences in restrictions on programs and invariants, in the use of advanced type systems (e.g. ownership types), in the meaning of invariants, and in proof obligations.               We develop a unified framework for such techniques. We distil seven parameters that characterise a verification technique, and identify sufficient conditions on these parameters which guarantee soundness. We instantiate our framework with three verification techniques from the literature, and use it to assess soundness and compare expressiveness.", "num_citations": "64\n", "authors": ["1747"]}
{"title": "A model for Java with wildcards\n", "abstract": " Wildcards are a complex and subtle part of the Java type system, present since version\u00a05.0. Although there have been various formalisations and partial type soundness results concerning wildcards, to the best of our knowledge, no system that includes all the key aspects of Java wildcards has been proven type sound. This paper establishes that Java wildcards are type sound. We describe a new formal model based on explicit existential types whose pack and unpack operations are handled implicitly, and prove it type sound. Moreover, we specify a translation from a subset of Java to our formal model, and discuss how several interesting aspects of the Java type system are handled.", "num_citations": "63\n", "authors": ["1747"]}
{"title": "Bounded session types for object oriented languages\n", "abstract": " Earlier work explored the introduction of session types into object oriented languages. Following the session types literature, two parties would start communicating, provided the types attached to that communication, i.e. the corresponding session types, were dual of each other. Then, the type system was able to ensure soundness, in the sense that two communicating partners were guaranteed to receive/send sequences of values following the order specified by their session types.               In the current paper we improve upon our earlier work in two ways: we extend the type system to support bounded polymorphism, and we make the selection more object-oriented, so that control structures determine how to continue evaluation, depending on the class of the object being sent/received.               Interestingly, although our notion of selection is more powerful than that in earlier work, the ensuing system\u00a0\u2026", "num_citations": "63\n", "authors": ["1747"]}
{"title": "BabyJ: From object based to class based programming via types\n", "abstract": " Object oriented programming can be classified into the object based, and the class based paradigm. Object based languages typically are weakly typed and interpreted, allow member addition and removal, and thus they support flexibility and prototyping. Class based languages are usually strongly typed and compiled, require a rigid class structure and class membership, and thus they support more robust, type safe programs.The two paradigms therefore address the needs of different stages in the programming lifecycle: object based programming better fits the earlier, exploratory phases, whereas class based better fits the latter, consolidation and maintenance phases. Because the transition from one paradigm to the other is not straightforward, programs tend to be developed in one of the two paradigms, thus foregoing the advantages of the other.We suggest that this need not be so, and that the benefits of the\u00a0\u2026", "num_citations": "57\n", "authors": ["1747"]}
{"title": "An attribute grammar for the semantic analysis of Ada\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "54\n", "authors": ["1747"]}
{"title": "Objects and session types\n", "abstract": " A session takes place between two parties; after establishing a connection, each party interleaves local computations and communications (sending or receiving) with the other. Session types characterise such sessions in terms of the types of values communicated and the shape of protocols, and have been developed for the \u03c0-calculus, CORBA interfaces, and functional languages. We study the incorporation of session types into object-oriented languages through MOOSE, a multi-threaded language with session types, thread spawning, iterative, and higher-order sessions. Our design aims to consistently integrate the object-oriented programming style and sessions, and to be able to treat various case studies from the literature. We describe the design of MOOSE, its syntax, operational semantics, and type system, and develop a type inference system. After proving subject reduction, we establish the progress\u00a0\u2026", "num_citations": "49\n", "authors": ["1747"]}
{"title": "Simple dependent types: Concord\n", "abstract": " The organisation of code at an object level has long been considered a prudent approach to software development. However, in many situations the single-class perspective is too fine grained a perspective on a system and collaborations or families of classes are a better unit of organisation.Concord is a calculus designed to handle families, collaborations between multiple classes, and subsequent specialisations of this family concept. The calculus is a simple model for a restricted form of dependent types in object oriented languages. We introduce groups to represent this notion of a family, whereby classes belong to groups and dependency is introduced via intra-group references using the MyGrp", "num_citations": "41\n", "authors": ["1747"]}
{"title": "Fully concurrent garbage collection of actors on many-core machines\n", "abstract": " Disposal of dead actors in actor-model languages is as important as disposal of unreachable objects in object-oriented languages. In current practice, programmers are required to either manually terminate actors, or they have to rely on garbage collection systems that monitor actor mutation through write barriers, thread coordination through locks etc. These techniques, however, prevent the collector from being fully concurrent.", "num_citations": "39\n", "authors": ["1747"]}
{"title": "Amalgamating sessions and methods in object-oriented languages with generics\n", "abstract": " We suggest an amalgamation of communication-based programming (centered on sessions) and object-oriented programming, whereby sessions between concurrent threads are amalgamated with methods. In our proposal, threads consist of the execution of session bodies on objects and communicate with each other by asynchronously sending/receiving objects on channels. The response to a session request is based on the name of the request and the class of the object receiving the request. The decision of how to continue a session is based on the class of the object sent/received. Sessions can be delegated to other sessions, although sessions themselves are not first class objects. We demonstrate our ideas through a core language with generic types, SAM g, and an example. We then formalize a small calculus, F SAM g, and prove subject reduction and progress. The latter property is notoriously difficult to\u00a0\u2026", "num_citations": "39\n", "authors": ["1747"]}
{"title": "An abstract model of java dynamic linking and loading\n", "abstract": " We suggest a model for dynamic loading and linking as in Java. We distinguish five components in a Java implementation: evaluation, resolution, loading, verification, and preparation \u2014 with their associated checks. We demonstrate how these five together guarantee type soundness.               We take an abstract view, and base our model on a language nearer to Java source than to bytecode. We consider the following features of Java: classes, subclasses, fields and hiding, methods and inheritance, and interfaces.", "num_citations": "38\n", "authors": ["1747"]}
{"title": "Considerate reasoning and the composite design pattern\n", "abstract": " We propose Considerate Reasoning, a novel specification and verification technique based on object invariants. This technique supports succinct specifications of implementations which follow the pattern of breaking properties of other objects and then notifying them appropriately. It allows the specification to be concerned only with the properties directly relevant to the current method call, with no need to explicitly mention the concerns of subcalls. In this way, the specification reflects the division of responsibility present in the implementation, and reflects what we regard as the natural argument behind the design.               We specify and prove the well-known Composite design pattern using Considerate Reasoning. We show how to encode our approach in Boogie2. The resulting specification verifies automatically within a few seconds; no manual guidance is required beyond the careful representation of\u00a0\u2026", "num_citations": "32\n", "authors": ["1747"]}
{"title": "The need for flexible object invariants\n", "abstract": " Specification and verification of object oriented programs usually features in some capacity the concept of an object invariant, used to describe the consistent states of an object. Unavoidably, an object\u2019s invariant will be broken at some points in its lifetime, and as a result, invariant protocols have been suggested, which prescribe the times at which object invariants may be broken, and the points at which they have to be re-established. The fact that currently available invariant protocols do not handle well some known examples, together with the fact that object invariants and invariant protocols can largely be encoded through methods\u2019 pre-and post-conditions has recently raised the question of whether they still have a role to play, or should be replaced by more explicit pre-and postconditions for methods.In this paper we argue that invariant protocols express programmers\u2019 intuitions, lead to better design, allow more succinct specifications and proofs, and allow the expression of properties which involve many objects in a localised manner. In particular, the resulting verification conditions can be made simpler and more modular through the use of invariant-based reasoning.", "num_citations": "29\n", "authors": ["1747"]}
{"title": "Towards an existential types model for Java wildcards\n", "abstract": " Wildcards extend Java generics by softening the mismatch between subtype and parametric polymorphism. Although they are a key part of the Java 5.0 programming language, a type system including wildcards has never been proven type sound. Wildcards have previously been formalised as existential types. In this paper we extend FGJ, a featherweight formalisation of Java with generics, with existential types. We prove that this calculus,\u2203 J, is type sound, and illustrate how it models wildcards in the Java Programming Language.\u2203 J is not a full model for Java wildcards, because it does not support lower bounds for wildcards. We discuss why\u2203 J can not be easily extended with lower bounds, and how full Java wildcards could be modelled in a type sound way.", "num_citations": "28\n", "authors": ["1747"]}
{"title": "Refined Effects for Unanticipated Object Re-classification: \n", "abstract": " In previous work on the language  and its extension  Dezani and us introduced language features for object re-classification for imperative, typed, class-based, object-oriented languages.               In this paper we present the language , which on one side refines  with more expressive effect annotations, and on the other eliminates the need to declare explicitly which are the classes of the objects that may be re-classified. Therefore,  allows to correctly type meaningful programs which  rejects. Moreover, re-classification may be decided by the client of a class, allowing unanticipated object re-classification. As for , also the type and effect system for  guarantees that, even though objects may be re-classified across classes with different members, they will never attempt to access non existing members.               The type and effect system of  has some\u00a0\u2026", "num_citations": "25\n", "authors": ["1747"]}
{"title": "Java exceptions throw no surprises\n", "abstract": " We present a summary of our formalization of the static and dynamic semantics of Java related to exceptions. We distinguish between normal execution, where no exception is thrown - or, more precisely, any exception thrown is handled - and abnormal execution, where an exception is thrown and not handled. The type system distinguishes normal types which describe the possible outcomes of normal execution, and abnormal types which describe the possible outcomes of abnormal execution. The type of a term consists of its normal type and its abnormal type.    The meaning of our subject reduction theorem we prove with this set-up is stronger than usual: it guarantees that normal execution returns a value of a type compatible with the normal type of the term, and that abnormal execution throws an exception compatible with the abnormal type of the term.", "num_citations": "24\n", "authors": ["1747"]}
{"title": "Towards an abstract model of Java dynamic linking and verification\n", "abstract": " We suggest a model for dynamic linking and verification as in Java. We distinguish five components in a Java implementation: evaluation, resolution, loading, verification, and preparation\u2013with their associated checks. We demonstrate how these five together guarantee type soundness. We take an abstract view, and base our model on a language nearer to Java source than to bytecode. We consider the following features of Java: classes, subclasses, fields and hiding, methods and inheritance, and interfaces.", "num_citations": "22\n", "authors": ["1747"]}
{"title": "Orca: GC and type system co-design for actor languages\n", "abstract": " ORCA is a concurrent and parallel garbage collector for actor programs, which does not require any STW steps, or synchronization mechanisms, and that has been designed to support zero-copy message passing and sharing of mutable data. ORCA is part of a runtime for actor-based languages, which was co-designed with the Pony programming language, and in particular, with its data race free type system. By co-designing an actor language with its runtime, it was possible to exploit certain language properties in order to optimize performance of garbage collection. Namely, ORCA relies on the guarantees of absence of race conditions in order to avoid read/write barriers, and it leverages the actor message passing, for synchronization among actors.   In this paper we briefly describe Pony and its type system. We use pseudo-code in order to introduce how ORCA allocates and deallocates objects, how it shares\u00a0\u2026", "num_citations": "21\n", "authors": ["1747"]}
{"title": "Amalgamating the session types and the object oriented programming paradigms\n", "abstract": " We suggest an amalgamation of the session type and the object oriented paradigm whereby sessions are amalgamated with methods; where threads consist of the execution of session bodies on objects and communicate with each other through asynchronously sending/receiving objects on channels; where the choice on how to respond to a session request is based on the name of the request and the class of the object receiving the request; where the choice on how to continue a session is made on the basis of the class of the object sent/received; and where sessions are not first class, but can be delegated to other sessions. We demonstrate our ideas through a small language, STOOP, and an example. We formalize a smaller calculus, Feather STOOP, and give a formal definition, and prove subject reduction and progress. The latter property is notoriously difficult and sometimes impossible to achieve in sessions languages, however it holds in", "num_citations": "21\n", "authors": ["1747"]}
{"title": "Type inference for Javascript\n", "abstract": " Object-oriented scripting languages like JavaScript are popular, in part because of their dynamic features. These include the runtime modification of objects and classes, through addition of fields or updating of methods. These features make static typing difficult and usually dynamic typing is used. Consequently, errors such as access to non-existent members, are not detected until runtime.We provide a static type system that can cope with dynamic features such as member addition, while providing the usual safety guarantees. Since the structure of objects may change over time, we employ a structural type system to track the changes. We show how type inference can be used to infer the structure of objects and give corresponding structural types. Therefore, the programmer can enjoy the safety offered by static typing, without having to give explicit types in their programs.", "num_citations": "20\n", "authors": ["1747"]}
{"title": "A formal semantics for isorecursive and equirecursive state abstractions\n", "abstract": " Methodologies for static program verification and analysis often support recursive predicates in specifications, in order to reason about recursive data structures. Intuitively, a predicate instance represents the complete unrolling of its definition; this is the equirecursive interpretation. However, this semantics is unsuitable for static verification, when the recursion becomes unbounded. For this reason, most static verifiers differentiate between, e.g., a predicate instance and its corresponding body, while providing a facility to map between the two; this is the isorecursive semantics. While this latter interpretation is usually implemented in practice, only the equirecursive semantics is typically treated in theoretical work.               In this paper, we provide both an isorecursive and an equirecursive formal semantics for recursive definitions in the context of Chalice, a verification methodology based on implicit dynamic\u00a0\u2026", "num_citations": "19\n", "authors": ["1747"]}
{"title": "Can Addresses be Types?: A case study: objects with delegation\n", "abstract": " We adapt the aliasing constraints approach for designing a flexible typing of evolving objects. Types are singleton types (addresses of objects, as a matter of fact) whose relevance is mainly due to the sort of safety property they guarantee. In particular we provide a type system for an imperative object based calculus with delegation and which supports method and delegate overriding, addition, and removal.", "num_citations": "19\n", "authors": ["1747"]}
{"title": "Existential quantification for variant ownership\n", "abstract": " Ownership types characterize the topology of objects in the heap, through a characterization of the context to which an object belongs. They have been used to support reasoning, memory management, concurrency, etc. Subtyping is traditionally invariant w.r.t. contexts, which has often proven inflexible in some situations. Recent work has introduced restricted forms of subtype variance and unknown context, but in a rather ad-hoc and restricted way.               We develop Jo\u2203, a calculus which supports parameterisation of types, as well as contexts, and allows variant subtyping of contexts based on existential quantification. Jo\u2203 is more expressive, general, and uniform than previous works which add variance to ownership languages. Our explicit use of existential types makes the connection to type-theoretic foundations from existential types more transparent. We prove type soundness for Jo\u2203 and extend it\u00a0\u2026", "num_citations": "18\n", "authors": ["1747"]}
{"title": "Flexible dynamic linking\n", "abstract": " Dynamic linking, as in Java and C#, allows users to execute the most recent versions of software without re-compilation or re-linking. Dynamic linking is guided by type names stored in the bytecode.In current dynamic linking schemes, these type names are hard-coded into the bytecode. Thus, the bytecode reflects the compilation environment that produced it. However, the compilation environment need not be the same as the execution environment: a class may be replaced by one that offers the \u201csame\u201d services but has a different name. Such changes are not supported by current linking schemes.", "num_citations": "17\n", "authors": ["1747"]}
{"title": "Cheaper reasoning with ownership types\n", "abstract": " CiteSeerX \u2014 Cheaper Reasoning with Ownership Types Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA Cheaper Reasoning with Ownership Types (2003) Cached Download as a PDF Download Links [www.cs.uu.nl] [slurp.doc.ic.ac.uk] [homepages.cwi.nl] [pubs.doc.ic.ac.uk] [dev.pubs.doc.ic.ac.uk] Save to List Add to Collection Correct Errors Monitor Changes by Matthew Smith , Sophia Drossopoulou Venue: Utrecht University Citations: 12 - 4 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract We use ownership types to facilitate program verification. Keyphrases ownership type program verification Powered by: Apache Solr About CiteSeerX Submit and Index \u2026", "num_citations": "16\n", "authors": ["1747"]}
{"title": "Overloading in preliminary Ada\n", "abstract": " Ada permits the overloading of enumeration literals, aggregates, subprograms and operators, i.e. the declaration of the same designator with different meanings in the same scope. This leads to difficulties during the semantic analysis of expressions and subprogram calls. For selecting the meaning not only the designator but also the types of its operands or parameters and the type of its result must be used. We show that the identification of expressions is possible in two passes, the first bottom-up, the second top-down.", "num_citations": "16\n", "authors": ["1747"]}
{"title": "Inner classes visit aliasing\n", "abstract": " Inner classes appear nested within class de nitions. They may access any members of the classes in which they are contained. The interplay between inner classes, aliasing and subclasses can make resolution of such accesses intricate.", "num_citations": "14\n", "authors": ["1747"]}
{"title": "On subtyping, wildcards, and existential types\n", "abstract": " Wildcards are an often confusing part of the Java type system: the behaviour of wildcard types is not fully specified by subtyping, due to wildcard capture, and the rules for type checking are often misunderstood. Their very formulation seems somehow'different'from the rest of the Java type system, which is based on a simple, nominal hierarchy.", "num_citations": "13\n", "authors": ["1747"]}
{"title": "Overloading and inheritance\n", "abstract": " Overloading allows several function definitions for the same name, distinguished primarily through different argument types; it is typically resolved at compile-time. Inheritance allows subclasses to define more special versions of the same function; it is typically resolved at run-time. Modern object-oriented languages incorporate both features, usually in a type-safe manner. However, the combination of these features sometimes turns out to have surprising, and even counterintuitive, effects. We discuss why we consider these effects inappropriate, and suggest alternatives. We explore the design space by isolating the main issues involved and analyzing their interplay and suggest a formal framework describing static overloading resolution and dynamic function selection, abstracting from other language features. We believe that our framework clarifies the thought process going on at language design level.We introduce a notion of soundness and completeness of an overloading resolution policy wrt the underlying dynamic semantics, and a way of comparing the flexibility of different resolution policies. We apply these concepts to some non-trivial issues raised in concrete languages. We also argue that the semantics of overloading and inheritance is \u201cclean\u201d only if it can be understood through a copy semantics, whereby programs are transformed to equivalent programs without subclasses, and the effect of inheritance is obtained through copying.", "num_citations": "13\n", "authors": ["1747"]}
{"title": "Ownership and reference counting based garbage collection in the actor world\n", "abstract": " We propose Pony-ORCA, a fully concurrent protocol for garbage collection in the actor paradigm. It allows actors to perform garbage collection concurrently with any number of other actors. It does not require any form of synchronization across actors except those introduced through the actor paradigm, ie message send and message receive.Pony-ORCA is based on ideas from ownership and deferred, distributed, weighted reference counting. It adapts the messaging system of actors to keep the reference count consistent. We introduce a formal model and describe the invariants on which it relies. We illustrate these invariants through an example and sketch how they are maintained. We show some benchmarks and argue that the protocol can be implemented efficiently.", "num_citations": "12\n", "authors": ["1747"]}
{"title": "A provenly correct translation of Fickle into Java\n", "abstract": " We present a translation from Fickle, a small object-oriented language allowing objects to change their class at runtime, into Java. The translation is provenly correct in the sense that it preserves the static and dynamic semantics. Moreover, it is compatible with separate compilation, since the translation of a Fickle class does not depend on the implementation of used classes. Based on the formal system, we have developed an implementation. The translation turned out to be a more subtle problem than we expected. In this article, we discuss four possible approaches we considered for the design of the translation and to justify our choice, we present formally the translation and proof of preservation of the static and dynamic semantics, and discuss the prototype implementation. Moreover, we outline an alternative translation based on generics that avoids most of the casts (but not all) needed in the previous\u00a0\u2026", "num_citations": "12\n", "authors": ["1747"]}
{"title": "An attribute grammar for Ada\n", "abstract": " We describe the development of a formal specification of the static semantics of Ada in form of an attribute grammar. This specification is complete, and was tested extensively with automatically generated equivalent Pascal programs. From this specification we systematically developed the semantic analysis part of our Ada Compiler Front End. We outline the general proceeding when specifying semantic analysis with attribute grammars and then discuss to some extent examples about declaration elaboration and overloading resolution. CR Categories and Subject Descriptors: D.3.1 [Programming Languages]: Formal definitions and Theory - semantics; D.3.4 [Programming Languages]: Processors - Translator writing systems and compiler generators; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages - algebraic approaches to semantics.", "num_citations": "12\n", "authors": ["1747"]}
{"title": "Towards a semantic model for Java wildcards\n", "abstract": " Wildcard types enrich the types expressible in Java, and extend the set of typeable Java programs. Syntactic models and proofs of soundness for type systems related to Java wildcards have been suggested in the past, however, the semantics of wildcards has not yet been studied.", "num_citations": "10\n", "authors": ["1747"]}
{"title": "A Separate Compilation System for Ada\n", "abstract": " The programming language Ada provides a concept for the separate compilation of program units where checks have to be done across the unit bounds at compile time. Here we describe the Separate Compilation System which was developed for the Ada Compiler Project at the University of Karlsruhe. The realization of the separate compilation facility of Ada is mainly based on the use of a library which contains information about previously compiled units. The separate compilation system maintains the library and provides the functions to support the compiler and other programming tools.", "num_citations": "10\n", "authors": ["1747"]}
{"title": "Snmalloc: a message passing allocator\n", "abstract": " snmalloc is an implementation of malloc aimed at workloads in which objects are typically deallocated by a different thread than the one that had allocated them. We use the term producer/consumer for such workloads. snmalloc uses a novel message passing scheme which returns deallocated objects to the originating allocator in batches without taking any locks. It also uses a novel bump pointer-free list data structure with which just 64-bits of meta-data are sufficient for each 64 KiB slab. On such producer/consumer benchmarks our approach performs better than existing allocators. Snmalloc is available at< a href=\" https://github. com/Microsoft/snmalloc\"> https://github. com/Microsoft/snmalloc.", "num_citations": "9\n", "authors": ["1747"]}
{"title": "Tree topologies for causal message delivery\n", "abstract": " Causal message delivery, ie the requirement that messages are delivered in an order respecting their causal (logical) dependencies, is often mandated in the distributed setting. So far, causal message delivery has been implemented by augmenting messages with meta data information that allows the receiver (or the platform) to re-order, and if necessary hold back, messages upon receipt before processing.", "num_citations": "9\n", "authors": ["1747"]}
{"title": "A principled design of capabilities in Pony\n", "abstract": " A formal model of a programming language gives confidence that the language fulfils any guarantees it claims about safety or liveness, also helping to uncover bugs or inconsistencies within the language design or implementation. We focus on the programming language Pony: a relatively new, actor-model, concurrent programming language with an existing partial model showing that Pony\u2019s type system guarantees freedom from data-races but lacking a number of important features found in the language itself.In this thesis we describe PonyG, a formal model for a significantly larger subset of the Pony language. We begin by revisiting the existing formal model, simplifying and enhancing the model considerably in several ways with a number of novel components. Firstly, we introduce the explicit extracting viewpoint adaptation operator, which allows us to distinguish between field read and write operations and allows us to type such expressions in a less restrictive way than that enforced by the old model. Secondly, we introduce the distinction between temporaries at the focus of the execution, which we refer to as active temporaries, and other passive temporaries such as those being passed as arguments to a method call. By combining these two new distinctions we are able to considerably simplify the definition of well-formed runtime configurations and more easily reason about the heap at arbitrary points during execution, allowing us to prove that our well-formedness definitions are preserved through execution of the program.", "num_citations": "9\n", "authors": ["1747"]}
{"title": "An Effective Translation of Fickle into Java\n", "abstract": " We present a translation from Fickle (a Java-like language allowing dynamic object re-classi.cation, that is, objects that can change their class at run-time) into plain Java. The translation is proved to preserve static and dynamic semantics; moreover, it is shown to be effective, in the sense that the translation of a Fickle class does not depend on the implementation of used classes, hence can be done in a separate way, that is, without having their sources, exactly as it happens for Java compilation. The aim is to demonstrate that an extension of Java supporting dynamic object re-classi.cation could be fully compatible with the existing Java environment.", "num_citations": "9\n", "authors": ["1747"]}
{"title": "An LALR (1) grammar for (revised) Ada\n", "abstract": " Our LALR (1) parser generator[PGS] determines 484 states for the grammar given below. The number of productions is 397, there are 93 (including the stop symbol) terminal symbols, and 181 nonterminals which can be reduced to 124 by elimination of chain productions. The size of the resulting tables including automatic error recovery is about 12 KB.", "num_citations": "9\n", "authors": ["1747"]}
{"title": "Three case studies in FickleII\n", "abstract": " In this paper we explore the use of object reclassification as in Fickleii [3] through the study of three examples. These examples are normal and privileged accounts, empty or nonempty lists, and adventure games where dragons turn into princes. The examples show how Fickle supports the expression of radical change in an object\u2019s behaviour through the possibility of an object changing class, rather than through the state pattern.Although this paper deals with the same cases as \u201cExamples in Fickle\u201d[5], it differs because it follows the more liberal approach supported by Fickleii.. Fickleii differs from Fickle [4] in that it allows state class types for the result types and for argument types of methods. These additions are crucial: the examples dealing with linked lists can be expressed without type casts in Fickleii, while they required type casts in Fickle.", "num_citations": "8\n", "authors": ["1747"]}
{"title": "Behavioural types for non-uniform memory accesses\n", "abstract": " Concurrent programs executing on NUMA architectures consist of concurrent entities (e.g. threads, actors) and data placed on different nodes. Execution of these concurrent entities often reads or updates states from remote nodes. The performance of such systems depends on the extent to which the concurrent entities can be executing in parallel, and on the amount of the remote reads and writes. We consider an actor-based object oriented language, and propose a type system which expresses the topology of the program (the placement of the actors and data on the nodes), and an effect system which characterises remote reads and writes (in terms of which node reads/writes from which other nodes). We use a variant of ownership types for the topology, and a combination of behavioural and ownership types for the effect system.", "num_citations": "7\n", "authors": ["1747"]}
{"title": "delta: an imperative object based calculus with delegation\n", "abstract": " Object based, imperative languages with delegation (eg SELF) support exploratory programming: composition of objects, sharing of attributes and modification of objects' behaviour at run-time are easily expressible.", "num_citations": "7\n", "authors": ["1747"]}
{"title": "Formalising Composition Oriented Programming\n", "abstract": " We present a snapshot of work in progress to define a formal model of the composition technology which underpins Subject-oriented and Aspectoriented programming.", "num_citations": "7\n", "authors": ["1747"]}
{"title": "Overloading and inheritance in Java\n", "abstract": " The combination of overloading and inheritance in Java introduces questions about function selection, and makes some function calls ambiguous. We believe that the approach taken by Java designers is counterintuitive. We explore an alternative, and argue that it is more intuitive and agrees with the Java rules for the cases where Java considers the function calls unambiguous, but gives meaning to more calls than Java does.", "num_citations": "6\n", "authors": ["1747"]}
{"title": "Examples in Fickle\n", "abstract": " Note: This work is preliminary, and in particular, it may not follow the same syntax as that in the main paper, since we keep improving that syntax. The examples are not complete, as we try to outline the issues related to the use of fickle features.1 st Example: Accounts", "num_citations": "6\n", "authors": ["1747"]}