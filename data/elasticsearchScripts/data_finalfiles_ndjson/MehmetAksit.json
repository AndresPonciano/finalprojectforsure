{"title": "Aspect-oriented programming\n", "abstract": " We have found many programming problems for which neither procedural nor object-oriented programming techniques are sufficient to clearly capture some of the important design decisions the program must implement. This forces the implementation of those design decisions to be scattered throughout the code, resulting in \u201ctangled\u201d code that is excessively difficult to develop and maintain. We present an analysis of why certain design decisions have been so difficult to clearly capture in actual code. We call the properties these decisions address aspects, and show that the reason they have been hard to capture is that they cross-cut the system's basic functionality. We present the basis for a new programming technique, called aspect-oriented programming, that makes it possible to clearly express programs involving such aspects, including appropriate isolation, composition and reuse of the aspect code\u00a0\u2026", "num_citations": "11017\n", "authors": ["626"]}
{"title": "Aspect-oriented software development\n", "abstract": " Software development is changing. The opportunities of the Internet, computerized businesses, and computer-savvy consumers, the exponential decline in the cost of computation and communication, and the increasingly dynamic environment for longer-living systems are pressing software developers to come up with better ways to create and evolve systems. There is fomenting in software development process, system structure, programming, quality assurance, and maintenance. Software is about building computational models of some part of the elements or information flow of the world. For all but the most trivial software systems, conquering the engineering of the system requires (perhaps recursively) dividing the system into chunks that can be (by and large) separately created and managed. The last decade of the twentieth century saw the rise (and perhaps dominance) of the object-oriented perspective on system modularization. Object-orientation focuses on selecting objects as the primary unit of modularity and associating with these objects all the system's behavior. Objects are typically elements of the domain or of the computational process. Object-orientation is reaching its limits. Many things one cares about in creating a software system (concerns) are not neatly localized to the behavior of specific\" things.\" Building diverse systems requires simultaneously manipulating many concerns. Examples of concerns range from non-functional notions such as security, reliability, and manageability to precise implementation techniques such as concurrency control, caching, and error recovery. Since conventional programming technologies are\u00a0\u2026", "num_citations": "1165\n", "authors": ["626"]}
{"title": "Technological spaces: An initial appraisal\n", "abstract": " In this paper, we propose a high level view of technological spaces (TS) and relations among these spaces. A technological space is a working context with a set of associated concepts, body of knowledge, tools, required skills, and possibilities. It is often associated to a given user community with shared know-how, educational support, common literature and even workshop and conference regular meetings. Although it is difficult to give a precise definition, some TSs can be easily identified, eg the XML TS, the DBMS TS, the abstract syntax TS, the meta-model (OMG/MDA) TS, etc. The purpose of our work is not to define an abstract theory of technological spaces, but to figure out how to work more efficiently by using the best possibilities of each technology. To do so, we need a basic understanding of the similarities and differences between various TSs, and also of the possible operational bridges that will allow transferring the results obtained in one TS to other TS. We hope that the presented industrial vision may help us putting forward the idea that there could be more cooperation than competition among alternative technologies. Furthermore, as the spectrum of such available technologies is rapidly broadening, the necessity to offer clear guidelines when choosing practical solutions to engineering problems is becoming a must, not only for teachers but for project leaders as well.", "num_citations": "412\n", "authors": ["626"]}
{"title": "7 LAW AND ECONOMICS\n", "abstract": " One of the truly remarkable stories of academic scholarship of the late twentieth century is the rise of the field of law and economics. First of the several notable characteristics of this field is its very rapid growth. There were early harbingers of the field's subject matter [1]\u2014the use of mi-croeconomic analysis to evaluate the economic efficiency of the common law rules of property, contract, and tort and various topics in civil and criminal procedure, substantive criminal law, the law of corporations, and so on\u2014and isolated but seminal articles by Ronald Coase and others in the 1950s and 1960s. But I think that it is fair to say that law and economics was born and brought to adolescence in the course of a single decade, the 1970s. Very few innovations in economic or legal scholarship of the recent past have grown so rapidly. Second, the field of law and economics has had a profound impact on legal scholarship. Several leading legal scholars, notably Bruce Acker-man, have remarked that law and economics is the most important change in the field of law since the rise and fall of legal realism. A compendium of the legal issues upon which economics has thrown new light would include such fundamental matters as the choice of legal", "num_citations": "215\n", "authors": ["626"]}
{"title": "Dynamic, adaptive and reconfigurable systems overview and prospective vision\n", "abstract": " Systems are more and more expected to work in dynamic environment, to deal with fluctuation of their characteristics and to guaranty functional and nonfunctional requirements. Systems should also keep compliant with the contracted quality of service. Moreover, when necessary, services and aspects should be added or removed on line. In this paper, we overview major approaches to deploy, reconfigure and adapt applications and underlying software platforms. These changes should be realized according to the evolving context and execution environment so that systems can stay compliant with the specifications and requirements of the application. We end this position paper with a vision on future directions and developments.", "num_citations": "137\n", "authors": ["626"]}
{"title": "Computational intelligence in software engineering\n", "abstract": " This unique volume is the first publication on software engineering and computational intelligence (CI) viewed as a synergistic interplay of neurocomputing, granular computation (including fuzzy sets and rough sets), and evolutionary methods. It presents a unified view of CI in the context of software engineering. The book addresses a number of crucial issues: what is CI, what role does it play in software development, how are CI elements built into successive phases of the software life cycle, and what is the role played by CI in quantifying fundamental features of software artifacts? With contributions from leading researchers and practitioners, the book provides the reader with a wealth of new concepts and approaches, complete algorithms, in-depth case studies, and thought-provoking exercises. The topics coverage include neurocomputing, granular as well as evolutionary computing, object-oriented analysis and design in software engineering. There is also an extensive bibliography.", "num_citations": "108\n", "authors": ["626"]}
{"title": "Data abstraction mechanisms in Sina/st\n", "abstract": " This paper describes a new data abstraction mechanism in an object-oriented model of computing. The data abstraction mechanism described here has been devised in the context of the design of Sina/st language. In Sina/st no language constructs have been adopted for specifying inheritance or delegation, but rather, we introduce simpler mechanisms that can support a wide range of code sharing strategies without selecting one among them as a language feature. Sina/st also provides a stronger data encapsulation than most of the existing object-oriented languages. This language has been implemented on the SUN 3 workstation using Smalltalk.", "num_citations": "95\n", "authors": ["626"]}
{"title": "Synthesis-based software architecture design\n", "abstract": " Software architectures provide the gross-level design and as such impact the quality of the entire system. To support the quality factors such as robustness, adaptability and maintainability, a proper scoping of the architecture boundaries and likewise the identification of the relevant architectural abstractions is necessary. Several architecture design approaches have been introduced whereby the scoping of the architecture is merely based on the stakeholder\u2019s perspective. This chapter introduces a novel software architecture design approach that aims to scope the architecture boundaries from a systematic problem-solving perspective instead. In this so-called synthesis-based architecture design approach (Synbad), the client\u2019s perspective is abstracted to derive the technical problems. The technical problems define the scope of the solution domains from which the architectural abstractions are derived. The\u00a0\u2026", "num_citations": "94\n", "authors": ["626"]}
{"title": "Composing synchronization and real-time constraints\n", "abstract": " There have been a number of publications illustrating the successes of object-oriented techniques in creating highly reusable software systems. Several concurrent languages have been proposed for specifying reusable synchronization specifications. Recently, a number of real-time object-oriented languages have been introduced for building object-oriented programs with real-time behavior. Composing and reusing object-oriented programs with both synchronization and real-time constraints has not been addressed adequately, although most real-time systems are concurrent. This paper analyzes the origins of the problems in composing and reusing synchronization and real-time specifications, first as separate concerns, and later as composed behavior. To overcome the so-called inheritance anomaly problems, this paper proposes modular and composable synchronization and real-time specification\u00a0\u2026", "num_citations": "81\n", "authors": ["626"]}
{"title": "Factors affecting ELT reforms: The case of the Philippines basic education curriculum\n", "abstract": " A number of recent studies, especially within the East Asian region, have chronicled                 the problems involved in successful implementation of the English language teaching                 component of large-scale, system-wide educational innovations. This paper reports on                 the findings of research into the implementation, in both general and ELT-related                 terms, of another similar recent initiative, the Philippines Basic Education                 Curriculum (BEC). The data indicate that classroom-level implementation of the BEC                 has been difficult to achieve, principally because (i) the curriculum design is                 insufficiently compatible with teaching situation constraints and, (ii) the                 necessary levels of professional support and instructional materials have not been                 provided. The data also show that both drawbacks can be traced in the first instance                 to a shortage of\u00a0\u2026", "num_citations": "80\n", "authors": ["626"]}
{"title": "Solving the modeling problems of object-oriented languages by composing multiple aspects using composition filters\n", "abstract": " Building software from reusable components is considered important in reducing development costs. Object-oriented languages such as C++, Smalltalk and Java, however, are not capable of expressing certain aspects of applications in a reusable way. Software engineers may experience difficulties in composing and reusing applications from components, for example if components implement code for multiple views, dynamic inheritance and synchronization [6]. If these aspects have to be programmed, then object-oriented languages may require a considerable amount of redefinition although this may not be intuitively necessary. Several researchers termed these problems as inheritance anomalies, cross-cutting, etc.[12][8][10][11]. Aspectoriented programming aims at addressing these problems by specifying and composing the aspects of a program in a systematic way [10]. Composition-Filters is an aspect-oriented programming technique where different aspects are expressed in Filters as declarative and orthogonal message transformation specifications. The aspect-composition process of the Composition-Filters approach is general. Different aspects can be expressed in filters and then be composed together without building dedicated generators. Composition-Filters can be attached to the objects programmed in different object-oriented languages. This paper first illustrates some practical problems of the conventional objectoriented languages and then introduces Composition-Filters solutions to overcome these problems.", "num_citations": "63\n", "authors": ["626"]}
{"title": "Aspect-oriented programming using composition-filters\n", "abstract": " Software engineers may experience problems in modeling certain aspects while applying object-oriented techniques [4, 10, 11]. Composition-Filters are capable of expressing various different kinds of aspects in a uniform manner. These aspects are, for example, inheritance and delegation [1] and atomic delegation [2], multiple views, dynamic inheritance and queries on objects [3], coordinated behavior and inter-object constraints [5], real-time [6] and composing real-time and synchronization together [9], synchronization [8] and distributed synchronization [7], and client-server architectures [10]. Each filter provides extensibility within its aspect domain, such as reusable synchronization specification [8]. In addition, each aspect expressed by a filter can be composed easily with other aspects [9]. Since filters are declarative aspect specifications, the aspect composition process can be realized both at run-time\u00a0\u2026", "num_citations": "53\n", "authors": ["626"]}
{"title": "Software architecture reliability analysis using failure scenarios\n", "abstract": " With the increasing size and complexity of software in embedded systems, software has now become a primary threat for the reliability. Several mature conventional reliability engineering techniques exist in literature but traditionally these have primarily addressed failures in hardware components and usually assume the availability of a running system. Software architecture analysis methods aim to analyze the quality of software-intensive system early at the software architecture design level and before a system is implemented. We propose a Software Architecture Reliability Analysis Approach (SARAH) that benefits from mature reliability engineering techniques and scenario-based software architecture analysis to provide an early software reliability analysis at the architecture design level. SARAH defines the notion of failure scenario model that is based on the Failure Modes and Effects Analysis method (FMEA\u00a0\u2026", "num_citations": "52\n", "authors": ["626"]}
{"title": "Strategic directions in object-oriented programming\n", "abstract": " Object-oriented programming (OOP) is a technique for improving productivity, quality, and innovation in software development. Whereas procedures are sequences of statements that specify a transformation from inputs to outputs, objects are collections of operations sharing a state that provide persistent services over time. A procedure-oriented system consists of sequentially executed procedures, while an object-oriented system consists of a collection of interacting objects. Procedures express algorithms that implement computable functions, while objects express embedded systems that implement services over time, like banking or airline-reservation applications. Objects typically possess mutable state, operations that change their state, and operations that cause them to in turn invoke operations on other objects. Operations may be described through a well-defined interface providing information about\u00a0\u2026", "num_citations": "52\n", "authors": ["626"]}
{"title": "Atomic delegation: Object-oriented transactions\n", "abstract": " Atomic delegation, an object-oriented linguistic mechanism that allows the creation of dynamically defined classes of atomic actions is presented. When a type is modified, atomic delegation updates functionalities of the the types that delegate to the modified type. This mechanism permits dynamic binding and code reuse in atomic actions. The Sina language is used to illustrate the utility of atomic delegation in the modeling of a real-world problem, involving an office with a number of departments, using object-oriented techniques. Implementation issues are discussed.< >", "num_citations": "52\n", "authors": ["626"]}
{"title": "Composition and separation of concerns in the object-oriented model\n", "abstract": " This is a position statement for the workshop on strategic directions in computing research held at MIT in June 1996.", "num_citations": "49\n", "authors": ["626"]}
{"title": "Separation and composition of concerns in the object-oriented model\n", "abstract": " This is a position statement for the workshop on strategic directions in computing research held at MIT in June 1996.", "num_citations": "49\n", "authors": ["626"]}
{"title": "Deriving design aspects from conceptual models\n", "abstract": " Two fundamental issues in aspect orientation are the identification and the composition of aspects. We argue that aspects must be identified at the requirement and the domain analysis phases. We also propose a mechanism for gradually composing aspects throughout the software development process. We illustrate our ideas for the design of a transaction framework.", "num_citations": "38\n", "authors": ["626"]}
{"title": "Runtime verification in distributed computing\n", "abstract": " Runtime verification aims to check whether an application executes its behaviour as specified. Thereby the active execution trace of an application is checked in terms of the actual execution context; diagnosis and, possibly, recovery actions are taken when the specification is violated. In today\u2019s practices, software is increasingly distributed over multiple processes, potentially running at different locations. This is supported by middleware that, to some extent, allows implementing applications in a distribution-transparent way. To enable effective runtime verification in distributed software we focus in this paper on three requirements:(1) distribution-transparent specification of software behaviour, as software is also implemented in such a way,(2) end-to-end verification of behaviour, and (3) automatic generation of verification modules for arbitrary process and distribution structures. We present a novel runtime verification approach satisfying these requirements and present its implementation in the EventChaser system. Furthermore we present an approach that at least minimizes the distribution-awareness of specifications to an acceptable level for software not using supported middleware for inter-process communication. 1", "num_citations": "36\n", "authors": ["626"]}
{"title": "On the design of the object-oriented language Sina.\n", "abstract": " Degree: Dr.DegreeYear: 1989Institute: Universiteit Twente (The Netherlands)This thesis is concerned with the development of software tools to design distributed information systems. The software tools presented here have been devised in the context of the design of the object-oriented language Sina.", "num_citations": "36\n", "authors": ["626"]}
{"title": "Adaptability in object-oriented software development: Workshop report\n", "abstract": " This paper is a report of the ECOOP \u201896 adaptability in object-oriented software development workshop held on July, 8th, 1996 in Linz. The basic topics raised during the workshop are summarized. Conclusions and a list of attendees are given as well.", "num_citations": "35\n", "authors": ["626"]}
{"title": "An implementation of the object\u2010oriented concurrent programming language SINA\n", "abstract": " SINA is an object\u2010oriented language for distributed and concurrent programming. The primary focus of this paper is on the object\u2010oriented concurrent programming mechanisms of SINA and their implementation. This paper presents the SINA constructs for concurrent programming and inter\u2010object communication, some illustrative examples and a message\u2010based implementation model for SINA that we have used in our current implementation.", "num_citations": "35\n", "authors": ["626"]}
{"title": "Characterization of early aspects approaches\n", "abstract": " Research at the early stages of aspectual software development is in a progressing state and some interesting results have been published. This paper presents an overview of various selected approaches and compares these using criteria derived from a software development framework. The characterization provides a set of open issues that are important for tackling the problems in the identification, specification and evaluation of early aspects.", "num_citations": "32\n", "authors": ["626"]}
{"title": "Deferring elimination of design alternatives in object\u2010oriented methods\n", "abstract": " While developing systems, software engineers generally have to deal with a large number of design alternatives. Current object\u2010oriented methods aim to eliminate design alternatives whenever they are generated. Alternatives, however, should be eliminated only when sufficient information to take such a decision is available. Otherwise, alternatives have to be preserved to allow further refinements along the development process. Too early elimination of alternatives results in loss of information and excessive restriction of the design space. This paper aims to enhance the current object\u2010oriented methods by modeling and controlling the design alternatives through the application of fuzzy\u2010logic\u2010based techniques. By using an example method, it is shown that the proposed approach increases the adaptability and reusability of design models. The method has been implemented and tested in our experimental CASE\u00a0\u2026", "num_citations": "31\n", "authors": ["626"]}
{"title": "Software architectures and component technology\n", "abstract": " Software architectures have gained wide popularity in the last decade. They generally play a fundamental role in coping with the inherent difficulties of the development of large-scale and complex software systems. Component-oriented and aspect-oriented programming enables software engineers to implement complex applications from a set of pre-defined components. Software Architectures and Component Technology collects excellent chapters on software architectures and component technologies from well-known authors, who not only explain the advantages, but also present the shortcomings of the current approaches while introducing novel solutions to overcome the shortcomings. The unique features of this book are: evaluates the current architecture design methods and component composition techniques and explains their shortcomings; presents three practical architecture design methods in detail; gives four industrial architecture design examples; presents conceptual models for distributed message-based architectures; explains techniques for refining architectures into components; presents the recent developments in component and aspect-oriented techniques; explains the status of research on Piccola, Hyper/J\u00ae, Pluggable Composite Adapters and Composition Filters. Software Architectures and Component Technology is a suitable text for graduate level students in computer science and engineering, and as a reference for researchers and practitioners in industry.", "num_citations": "30\n", "authors": ["626"]}
{"title": "Software development with imperfect information\n", "abstract": " Delivering software systems that fulfill all requirements of the stakeholders is very difficult, if not at all impossible. We consider the problem of coping with imperfect information, like interpreting incomplete requirement specifications or vagueness in decisions, one of the main reasons that makes software design difficult. We define a method for tracing design decisions under imperfect information. To model and compare requirements with estimations, we present fuzzy and stochastic techniques. This approach offers adequate decision support that can deal with imperfect information during software design. The approach is illustrated by a real-world example, based on a storm surge barrier system.", "num_citations": "30\n", "authors": ["626"]}
{"title": "Making aspects natural: events and composition\n", "abstract": " Language extensions are proposed to make aspects more natural for programmers. The extensions involve two main elements:(1) Completely separating the identification of events and locally accumulating information about them from any possible response to the events, and (2) composing both events and aspects into hierarchies that loosen the connection to code-level methods and field names. The combination of these extensions are shown (in preliminary experiments) to increase modularity, and facilitate using terminology natural for each concern. Extensions to AspectJ and Compose* are shown to illustrate how the concepts can be easily embodied in particular languages. The execution model of ALIA4J is used to present the concepts in a language-independent way, providing a prototype generic implementation of the extensions, that can be used to implement them for both AspectJ and Compose*. The\u00a0\u2026", "num_citations": "26\n", "authors": ["626"]}
{"title": "Classifying and evaluating architecture design methods\n", "abstract": " The concept of software architecture has gained a wide popularity and is generally considered to play a fundamental role in coping with the inherent difficulties of the development of large-scale and complex software systems. This chapter provides a classification and evaluation of existing software architecture design methods. For this, contemporary definitions on software architectures are analyzed and a general definition of software architecture is introduced. Further, a meta-model for architecture design methods is presented, which is used as a basis for comparing various architecture design approaches. The problems of each architecture design method are described and the corresponding conclusions are given.", "num_citations": "25\n", "authors": ["626"]}
{"title": "Communication, scheduling, and resource management in SINA\n", "abstract": " In this article we present the object-oriented constructs for communication and concurrent programming in the SINA programming language. The object encapsulation mechanism of SINA allows implementations of hierarchically structured resource management systems and alleviates some of the problems that arise in using nested monitor structures [13, 28, 31]. SINA supports capability-based communication between objects using object pointers. This permits building systems in which the communication topology can change dynamically. Using these constructs we present object-oriented solutions to various problems in interprocess communication, scheduling, and resource management. A number of examples of such problems have been implemented and tested using our SINA system on the SUN 3 workstations.", "num_citations": "24\n", "authors": ["626"]}
{"title": "A graph-based aspect interference detection approach for UML-based aspect-oriented models\n", "abstract": " Aspect-Oriented Modeling (AOM) techniques facilitate separate modeling of concerns and allow for a more flexible composition of the resulting models than traditional techniques. While this improves the understandability of each submodel, in order to reason about the behavior of the composed system and to detect conflicts among submodels, automated tool support is required.             We propose a technique and tool support for fully automatic detection of conflicts between aspects at the model level; more specifically, our approach works on models defined in UML with an extension for modeling pointcuts and advice. As back-end we use a graph-based model checker, for which we have defined an operational semantics of UML diagrams, pointcuts and advice. In order to simulate the system, we automatically derive a graph model from the diagrams. The simulation result is another graph, which represents\u00a0\u2026", "num_citations": "23\n", "authors": ["626"]}
{"title": "Leaving inconsistency using fuzzy logic\n", "abstract": " Current software development methods do not provide adequate means to model inconsistencies and therefore force software engineers to resolve inconsistencies whenever they are detected. Certain kinds of inconsistencies, however, are desirable and should be maintained as long as possible. For instance, when multiple conflicting solutions exist for the same problem, each solution should be preserved to allow further refinements along the development process. An early resolution of inconsistencies may result in loss of information and excessive restriction of the design space. This paper aims to enhance the current methods by modeling and controlling the desired inconsistencies through the application of fuzzy logic-based techniques. It is shown that the proposed approach increases the adaptability and reusability of design models.", "num_citations": "22\n", "authors": ["626"]}
{"title": "Applying the composition filter model for runtime verification of multiple-language software\n", "abstract": " Complex software, especially the embedded one, is composed of multiple collaborating subsystems that are possibly developed in multiple languages. To verify the behavior of such software, a run-time verification system must deal with multiple-language environments both in its specifications and in its generated runtime verification modules. In this paper, we present the E-Chaser runtime verification system, whose front-end provides language-independent specifications, and whose backend provides an extendable toolset with new implementation languages. E-Chaser is built based on the Composition Filter Model and extends it with the notion of synchronization messages and synchronization filters to verify the synchronization properties of multiple subsystems. The first prototype of EChaser was successfully used to verify various properties.", "num_citations": "21\n", "authors": ["626"]}
{"title": "The 7 C's for creating living software: A research perspective for quality-oriented software engineering\n", "abstract": " This article proposes the 7 C's for realizing quality-oriented software engineering practices. All the desired qualities of this approach are expressed in short by the term living software. The 7 C's are: Concern-oriented processes, Canonical models, Composable models, Certifiable models, Constructible models, Closure property of models and Controllable models. Each C is explained by the help of a set of definitions, a short overview of the background work and the problems that software engineers may experience in realizing the corresponding C. Further, throughout the article, a software development example is presented for illustrating the realization of the 7 C's. Finally, this article concludes by infomally justifying the necessity of the 7 C's.", "num_citations": "20\n", "authors": ["626"]}
{"title": "Compiler generation based on grammar inheritance\n", "abstract": " The concept of grammar inheritance is introduced. Grammar inheritance is a structural organization of grammar rules by which a grammar inherits rules from ancestor grammars or may have its own rules inherited by descendant grammars. Grammar inheritance supports reusability and extensibility of grammar rules. The concept of grammar inheritance is especially useful in combination with a compiler generator. A compiler generator tool for the SMALLTALK language which supports grammar inheritance is discussed. This tool was implemented on a Sun3 workstation and extensively tested.", "num_citations": "20\n", "authors": ["626"]}
{"title": "Event Modules\n", "abstract": " Runtime verification (RV) facilitates detecting the failures of software during its execution. Due to the complexity of RV techniques, there is an increasing interest in achieving abstractness, modularity, and compose-ability in their implementations by means of dedicated linguistic mechanisms. This paper defines a design space to evaluate the existing domain-specific languages for implementing RV techniques, and identifies the shortcomings of a representative set of these languages with respect to the design space. This paper advocates the need for a language composition framework, which offers the necessary mechanisms to achieve abstractness, modularity, and compose-ability in the implementation of domain-specific crosscutting concerns such as the concerns of RV techniques. We explain event modules as novel linguistic abstractions for modular implementation of domain-specific crosscutting\u00a0\u2026", "num_citations": "19\n", "authors": ["626"]}
{"title": "Optimizing decomposition of software architecture for local recovery\n", "abstract": " The increasing size and complexity of software systems has led to an amplified number of potential failures and as such makes it harder to ensure software reliability. Since it is usually hard to prevent all the failures, fault tolerance techniques have become more important. An essential element of fault tolerance is the recovery from failures. Local recovery is an effective approach whereby only the erroneous parts of the system are recovered while the other parts remain available. For achieving local recovery, the architecture needs to be decomposed into separate units that can be recovered in isolation. Usually, there are many different alternative ways to decompose the system into recoverable units. It appears that each of these decomposition alternatives performs differently with respect to availability and performance metrics. We propose a systematic approach dedicated to optimizing the decomposition of\u00a0\u2026", "num_citations": "19\n", "authors": ["626"]}
{"title": "An In-Depth Look at ALIA4J.\n", "abstract": " New programming languages supporting advanced modularization mechanisms are often implemented as transformations to the imperative intermediate representation of an already established language. But while their core constructs largely overlap in semantics, re-using the corresponding transformations requires re-using their syntax as well; this is limiting. In the ALIA4J approach, we identified dispatching as fundamental to most modularization mechanisms and provide a meta-model of dispatching as a rich, extensible intermediate language. Based on this meta-model, one can modularly implement the semantics of dispatchingrelated constructs. From said constructs a single execution model can then be derived which facilitates interpretation, bytecode generation, and even optimized machine-code generation. We show the suitability of our approach by mapping five popular languages to this meta-model and find that most of their constructs are shared across multiple languages. We furthermore present implementations of the three different execution strategies together with a generic visual debugger available to any ALIA4J-based language implementation. Intertwined with this paper is a tutorial-style running example that illustrates our approach.", "num_citations": "19\n", "authors": ["626"]}
{"title": "Impact of evolution of concerns in the model-driven architecture design approach\n", "abstract": " Separation of concerns is an important principle for designing high quality software systems and is both applied in the Model-Driven Architecture (MDA) and Aspect-Oriented Software Development (AOSD). The AOSD and MDA techniques seem to be complementary to each other; historically AOSD has focused on modeling crosscutting concerns whereas MDA has focused on the explicit separation of platform independent concerns from platform specific concerns and the model-driven generation processes. In order to assess the benefits of AOSD for MDA we provide a systematic analysis on crosscutting concerns within the MDA context. The analysis consists of three steps. First, we define an abstract model of MDA transformation with respect to concerns. Second, we define a number of evolution scenarios that correspond to a selected list of crosscutting concerns. Third, we analyze the model transformations in\u00a0\u2026", "num_citations": "19\n", "authors": ["626"]}
{"title": "Developing object-oriented framworks using domain models\n", "abstract": " In this paper we present an integrated approach to model the domain knowledge related to a framework and to map the identified domain models into objectoriented concepts. We applied this approach to three pilot projects. We discuss the problems we encountered in mapping domain models into objectoriented frameworks. Our experience indicates that deriving a framework from the related domain knowledge reduces the amount of framework refinement time considerably.", "num_citations": "19\n", "authors": ["626"]}
{"title": "FLORA: A framework for decomposing software architecture to introduce local recovery\n", "abstract": " The decomposition of software architecture into modular units is usually driven by the required quality concerns. In this paper we focus on the impact of local recovery concern on the decomposition of the software system. For achieving local recovery, the system needs to be decomposed into separate units that can be recovered in isolation. However, it appears that this required decomposition for recovery is usually not aligned with the decomposition based on functional concerns. Moreover, introducing local recovery to a software system, while preserving the existing decomposition, is not trivial and requires substantial development and maintenance effort. To reduce this effort we propose a framework that supports the decomposition and implementation of software architecture for local recovery. The framework provides reusable abstractions for defining recoverable units and the necessary coordination and\u00a0\u2026", "num_citations": "18\n", "authors": ["626"]}
{"title": "Modeling traceability of concerns in architectural views\n", "abstract": " Software architecture modeling includes the description of different views that represent the architectural concerns from different stakeholder perspectives. In case of evolution of the software system the related architectural views need to be adapted accordingly. For this it is necessary that the dependency links among the architectural concerns in the architectural views can be easily traced. Unfortunately, despite the ongoing efforts for modeling concerns in architectural views, the traceability of concerns remains a challenging issue in architecture design. We propose the concern traceability metamodel (CTM) that enables traceability of concerns within and across architectural views. The metamodel can be used for modeling the concerns, the architectural elements and the trace links among the elements in architectural views. We have implemented CTM in the tool M-Trace, that uses XML-based representations of\u00a0\u2026", "num_citations": "18\n", "authors": ["626"]}
{"title": "A fine-grained debugger for aspect-oriented programming\n", "abstract": " To increase modularity, aspect-oriented programming provides a mechanism based on implicit invocation: An aspect can influence runtime behavior of other modules without the need that these modules refer to the aspect. Recent studies show that a significant part of reported bugs in aspect-oriented programs are caused exactly by this implicitness. These bugs are difficult to detect because aspect-oriented source code elements and their locations are transformed or even lost after compilation. We investigate four dedicated fault models and identify ten tasks that a debugger should be able to perform for detecting aspect-orientation-specific faults. We show that existing debuggers are not powerful enough to support all identified tasks because the aspect-oriented abstractions are lost after compilation. This paper describes the design and implementation of a debugger for aspect-oriented languages using a\u00a0\u2026", "num_citations": "16\n", "authors": ["626"]}
{"title": "Models, more models, and then a lot more\n", "abstract": " With increased adoption of Model-Driven Engineering, the number of related artefacts in use, such as models, metamodels and transformations, greatly increases. To confirm this, we present quantitative evidence from both academia \u2014 in terms of repositories and datasets \u2014 and industry \u2014 in terms of large domain-specific language ecosystems. To be able to tackle this dimension of scalability in MDE, we propose to treat the artefacts as data, and apply various techniques \u2014 ranging from information retrieval to machine learning \u2014 to analyse and manage those artefacts in a holistic, scalable and efficient way.", "num_citations": "15\n", "authors": ["626"]}
{"title": "Modeling Traceability of Concerns for Synchronizing Architectural Views.\n", "abstract": " Software architecture modeling includes the description of different views that represent the architectural concerns from different stakeholder perspectives. In case of evolution of the software system the related architectural views need to be adapted accordingly. To synchronize the architectural views it is necessary that the dependency links among the architectural concerns in the architectural views can be easily traced. Unfortunately, despite the ongoing efforts for modeling concerns in architectural views, the traceability of concerns remains a challenging issue in architecture design. We propose the concern traceability metamodel (CTM) that enables traceability of concerns within and across architectural views. The metamodel can be used for modeling the concerns, the architectural elements and the traceability links among the elements in architectural views. We have implemented CTM in the tool M-Trace, that uses XML-based representations of the models and XQuery queries to represent tracing information. CTM and M-Trace are illustrated for analyzing the impact of concerns of a Climate Control System case and synchronizing the architectural views.", "num_citations": "15\n", "authors": ["626"]}
{"title": "Extending failure modes and effects analysis approach for reliability analysis at the software architecture design level\n", "abstract": " Several reliability engineering approaches have been proposed to identify and recover from failures. A well-known and mature approach is the Failure Mode and Effect Analysis (FMEA) method that is usually utilized together with Fault Tree Analysis (FTA) to analyze and diagnose the causes of failures. Unfortunately, both approaches seem to have primarily focused on failures of hardware components and less on software components. Moreover, for utilizing FMEA and FTA very often an existing implementation of the system is required to perform the reliability analysis. We propose extensions to FMEA and FTA to utilize them for the reliability analysis of software at the architecture design level. We present the software architecture reliability analysis approach (SARAH) that incorporates the extended FMEA and FTA. The approach is illustrated using an industrial case for analyzing reliability of the software\u00a0\u2026", "num_citations": "15\n", "authors": ["626"]}
{"title": "Improving object-oriented methods by using fuzzy logic\n", "abstract": " Object-oriented methods create software artifacts through the application of a large number or rules. Rules are typically formulated in two-valued logic. There are a number of problems on how rules are defined and applied in current methods. First, two-valued logic can capture completely neither method developers' intuition nor software engineers' perception or artifact types. Second, artifacts are generally produced based only on a subset of relevant properties. Third, two-valued logic does not modal explicitly contextual factors, which can affect the validity of methodological rules. Fourth, no means is supplied to deal with multiple design alternatives and to measure the quality of each alternative during the development process. High loss of information, early elimination of artifacts and process iterations are some of possible fastidious effects. To reduce these problems, this paper proposes fuzzy logic-based\u00a0\u2026", "num_citations": "15\n", "authors": ["626"]}
{"title": "A model for variability design rationale in SPL\n", "abstract": " The management of variability in software product lines goes beyond the definition of variations, traceability and configurations. It involves a lot of assumptions about the variability and related models, which are made by the stakeholders all over the product line but almost never handled explicitly. In order to better manage the design with variability, we must consider the rationale behind its specification. In this paper we present a model for the specification of variability design rationale and its application to the modelling of architectural variability in software product lines.", "num_citations": "14\n", "authors": ["626"]}
{"title": "Concern-oriented analysis and refactoring of software architectures using dependency structure matrices\n", "abstract": " Current scenario-based architecture analysis methods analyze the architecture with respect to scenarios that relate to stakeholder concerns. Albeit the primary motivation is to analyze the impact of stakeholders' concerns, it appears that concerns are not explicitly represented as first class abstractions. The lack of an explicit notion of concern in scenario-based analysis approaches can result in an incomplete analysis because scenarios are too specific and can only partially represent the concerns. We propose the concern-oriented architecture analysis method (COSAAM) that builds on scenario-based approaches but includes an explicit notion of concern in the analysis. COSAAM applies Dependency Structure Matrices (DSMs) to represent and analyze the dependencies among scenarios, concerns and architectural elements. Further, COSAAM extends DSMs by introducing explicit DSM patterns and heuristic rules\u00a0\u2026", "num_citations": "14\n", "authors": ["626"]}
{"title": "Metamodel for tracing concerns across the life cycle\n", "abstract": " Several aspect-oriented approaches have been proposed to specify aspects at different phases in the software life cycle. Aspects can appear within a phase, be refined or mapped to other aspects in later phases, or even disappear. Tracing aspects is necessary to support understandability and maintainability of software systems. Although several approaches have been introduced to address traceability of aspects, two important limitations can be observed. First, tracing is not yet tackled for the entire life cycle. Second, the traceability model that is applied usually refers to elements of specific aspect languages, thereby limiting the reusability of the adopted traceability model. We propose the concern traceability metamodel (CTM) that enables traceability of concerns throughout the life cycle, and which is independent from the aspect languages that are used. CTM can be enhanced to provide additional\u00a0\u2026", "num_citations": "14\n", "authors": ["626"]}
{"title": "Providing automatic support for heuristic rules of methods\n", "abstract": " In method-based software development, software engineers create artifacts based on the heuristic rules of the adopted method. Most CASE tools, however, do not actively assist software engineers in applying the heuristic rules. To provide an active support, the rules must be formalized, implemented and integrated within the framework of current CASE tools. In this paper we describe an approach for formalizing the heuristic rules of methods.", "num_citations": "13\n", "authors": ["626"]}
{"title": "Event-based modularization of reactive systems\n", "abstract": " There is a large number of complex software systems that have reactive behavior. As for any other software system, reactive systems are subject to evolution demands. This paper defines a set requirements that must be fulfilled so that reuse of reactive software systems can be increased. Detailed analysis of a set of representative languages reveals that these requirements are not completely fulfilled by the current programming languages and as such reuse of reactive systems remains a challenge. This paper explains Event Composition Model and its implementation the EventReactor language, which fulfill the requirements. By means of an example, the suitability of the EventReactor language in creating reusable reactive systems is illustrated.", "num_citations": "12\n", "authors": ["626"]}
{"title": "A Taxonomy for a Constructive Approach to Software Evolution.\n", "abstract": " In many software design and evaluation techniques, either the software evolution problem is not systematically elaborated, or only the impact of evolution is considered. Thus, most of the time software is changed by editing the components of the software system, ie breaking down the software system. The software engineering discipline provides many mechanisms that allow evolution without breaking down the system; however, the contexts where these mechanisms are applicable are not taken into account. Furthermore, the software design and evaluation techniques do not support identifying these contexts. In this paper, we provide a taxonomy of software evolution that can be used to identify the context of the evolution problem. The identified contexts are used to retrieve, from the software engineering discipline, the mechanisms, which can evolve the software software without breaking it down. To build such a taxonomy, we build a model for software evolution and use this model to identify the factors that effect the selection of software evolution mechanisms. Our approach is based on solution sets, however; the contents of these sets may vary at different stages of the software life-cycle. To address this problem, we introduce perspectives; that are filters to select relevant elements from a solution set. We apply our taxonomy to a parser tool to show how it coped with problematic evolution problems.", "num_citations": "12\n", "authors": ["626"]}
{"title": "Imperfect requirements in software development\n", "abstract": " Requirement Specifications are very difficult to define. Due to lack of information and differences in interpretation, software engineers are faced with the necessity to redesign and iterate. This imperfection in software requirement specifications is commonly addressed by incremental design. In this paper, we advocate an approach where the imperfect requirements in requirement specifications are modeled by fuzzy sets. By supporting this approach with a requirement tracing and an optimization approach, the necessity for design iteration can be reduced.", "num_citations": "12\n", "authors": ["626"]}
{"title": "Fuzzy logic-based object-oriented methods to reduce quantization error and contextual bias problems in software development\n", "abstract": " During the last several years, a considerable number of software development methods have been introduced to produce robust, reusable and adaptable software systems. Methods create software artifacts through the application of a large number of heuristic rules. These rules are generally expressed in two-valued logic. In object-oriented methods, for instance, candidate classes are identified by applying the following intuitive rule: \u201cIf an entity in a requirement specification is relevant and can exist autonomously in the application domain, then select it as a class\u201d. In this paper, we identify and define two major problems regarding how rules are defined and applied in current methods. First, two-valued logic cannot effectively express the approximate and inexact nature of a typical software development process. Although software engineers can perceive partial relevance of an entity and possibly select the entity as a\u00a0\u2026", "num_citations": "12\n", "authors": ["626"]}
{"title": "Market-driven approach based on Markov decision theory for optimal use of resources in software development\n", "abstract": " Changes in requirements may have a severe impact on development processes. For example, if requirements change during the course of a software development activity, it may be necessary to reschedule development activities so that the new requirements can be addressed in a timely manner. Unfortunately, current software development methods do not provide explicit means to adapt development processes with respect to changes in requirements. The paper proposes a method based on Markov decision theory, which determines the estimated optimal development schedule with respect to probabilistic product demands and resource constraints. This method is supported by a tool and applied to an industrial case.", "num_citations": "12\n", "authors": ["626"]}
{"title": "Reducing quantization error and contextual bias problems in software development processes by applying fuzzy logic\n", "abstract": " Object-oriented methods define a considerable number of rules, which are generally expressed using two-valued logic. For example, an entity in a requirement specification is either accepted or rejected as a class. There are two major problems of how rules are defined and applied in current methods. Firstly, two-valued logic cannot effectively express the approximate and inexact nature of a typical software development process. Secondly, the influence of contextual factors on rules is generally not modeled explicitly. We term these problems as quantization error and contextual bias problems, respectively. To reduce these problems, we adopt fuzzy logic-based methodological rules. This approach is method independent and is useful for evaluating and enhancing current methods. In addition, the use of fuzzy logic increases the adaptability and reusability of design models.", "num_citations": "12\n", "authors": ["626"]}
{"title": "Composing domain-specific physical models with general-purpose software modules in embedded control software\n", "abstract": " A considerable portion of software systems today are adopted in the embedded control domain. Embedded control software deals with controlling a physical system, and as such models of physical characteristics become part of the embedded control software. In current practices, usually general-purpose languages (GPL), such as C/C++ are used for embedded systems development. Although a GPL is suitable for expressing general-purpose computation, it falls short in expressing the models of physical characteristics as desired. This reduces not only the readability of the code but also hampers reuse due to the lack of dedicated abstractions and composition operators. Moreover, domain-specific static and dynamic checks may not be applied effectively. There exist domain-specific modeling languages (DSML) and tools to specify models of physical characteristics. Although they are commonly used for\u00a0\u2026", "num_citations": "11\n", "authors": ["626"]}
{"title": "Evolution of composition filters to event composition\n", "abstract": " Various different aspect-oriented (AO) languages are introduced in the literature, and naturally are evolved due to the research activities and the experiences gained in applying them to various domains. Achieving modularity, composability and abstractness in the implementation of crosscut-ting concerns are typical requirements that these languages aim to fulfill; and the degree to which they are fulfilled differs per language. Therefore, we always face two questions: what are the limitations of current AO languages from the perspective of these requirements, and what kinds of changes and/or new language mechanisms are necessary to address the limitations. This paper elaborates on the limitations of the current AO languages by means of runtime enforcement as an example domain. Via a new computation model termed as Event Composition Model, which is a successor of the Composition Filters Model, we\u00a0\u2026", "num_citations": "11\n", "authors": ["626"]}
{"title": "Issues in aspect-oriented software development\n", "abstract": " It is a common practice to decompose software development activities into various phases. Typically, these are Requirement Specification, Domain Analysis, Architecture Definition, Design, Implementation and Maintenance. Requirement Specification looks at the problem from the perspective of the user, Domain Analysis aims at finding background information related to the problem being solved, Architecture Definition tries to find out the essential structures in the system, Design is concerned with how to solve the problem, Implementation puts the design into an executable code, and finally, Maintenance tries to cope with the necessary changes after the deployment of the system.These phases are defined based on the concerns of the software engineer, and managing these are considered essential for reducing the maintenance costs. Since, these concerns have a major impact on the final structure and quality of software, they must be recognized as aspects. It is generally known that going from one phase to another is a difficult step. The so-called seamless design principle, generally a property attributed to object-oriented software development, aims at a smooth transition from one phase to another. Any practical designer, however, soon realizes that object-oriented development is not as seamless as it is claimed. Going one phase to another is actually an aspect weaving process.", "num_citations": "11\n", "authors": ["626"]}
{"title": "Extension of petri nets by aspects to apply the model driven architecture approach\n", "abstract": " Within MDA models are usually created in the UML. However, one may prefer to use different notations such as Petri-nets, for example, for modelling concurrency and synchronization properties of systems. This paper claims that techniques that are adopted within the context of MDA can also be beneficial in modelling systems by using notations other than the UML. Petri-Nets are widely used for modelling of business and application logic of information systems with web services. For certain kinds of applications, therefore, Petri Nets can be more suitable for building Computation Independent, Platform Independent and Platform Specific Models (CIM, PIM and PSM). Unfortunately, the well-known problems with separation of concerns in Petri Nets and keeping track of changes may hinder achieving the aim of MDA: building reusable, portable and interoperable models. In this paper we define Aspect Petri Nets as a structure of several Petri Nets and quantification rules for weaving of those Petri Nets. Aspect Petri Nets are suitable for application of MDA; they support traceability of changes and reusability, portability and interoperability of models. We illustrate advantages of modelling in Aspect Petri Nets for MDA application and describe necessary tool support.", "num_citations": "10\n", "authors": ["626"]}
{"title": "Verification and analysis of domain-specific models of physical characteristics in embedded control software\n", "abstract": " ContextA considerable portion of the software systems today are adopted in the embedded control domain. Embedded control software deals with controlling a physical system, and as such models of physical characteristics become part of the embedded control software.ObjectiveDue to the evolution of system properties and increasing complexity, faults can be left undetected in these models of physical characteristics. Therefore, their accuracy must be verified at runtime. Traditional runtime verification techniques that are based on states/events in software execution are inadequate in this case. The behavior suggested by models of physical characteristics cannot be mapped to behavioral properties of software. Moreover, implementation in a general-purpose programming language makes these models hard to locate and verify. Therefore, this paper proposes a novel approach to perform runtime verification of\u00a0\u2026", "num_citations": "9\n", "authors": ["626"]}
{"title": "Guiding architects in selecting architectural evolution alternatives\n", "abstract": " Although there exist methods and tools to support architecture evolution, the derivation and evaluation of alternative evolution paths are realized manually. In this paper, we introduce an approach, where architecture specification is converted to a graph representation. Based on this representation, we automatically generate possible evolution paths, evaluate quality attributes for different architectural configurations, and optimize the selection of a particular path accordingly. We illustrate our approach by modeling the software architecture evolution of a crisis management system.", "num_citations": "9\n", "authors": ["626"]}
{"title": "The role of computer science and software technology in organizing universities for industry 4.0 and beyond\n", "abstract": " Based on intensive cooperation with four large companies, a comparative analysis of the recent developments in industry, university organizations, computer science and software technology is presented. Within this context, also the Industry 4.0 phenomena is discussed. This paper further identifies the necessary organizational structures of universities to assist companies in their transition processes, defines the relevant sub-disciplines in computer science and finally describes the software engineering and technology challenges in designing and implementing economical and robust industrial systems.", "num_citations": "8\n", "authors": ["626"]}
{"title": "Runtime verification of domain-specific models of physical characteristics in control software\n", "abstract": " Control logic of embedded systems is nowadays largely implemented in software. Such control software implements, among others, models of physical characteristics, like heat exchange among system components. Due to evolution of system properties and increasing complexity, faults can be left undetected in these models. Therefore, their accuracy must be verified at runtime. Traditional runtime verification techniques that are based on states and/or events in software execution are inadequate in this case. The behavior suggested by models of physical characteristics cannot be mapped to behavioral properties of software. Moreover, implementation in a general-purpose programming language makes these models hard to locate and verify. This paper presents a novel approach to explicitly specify models of physical characteristics using a domain-specific language, to define monitors for inconsistencies by\u00a0\u2026", "num_citations": "8\n", "authors": ["626"]}
{"title": "Checking the correspondence between uml models and implementation\n", "abstract": " UML class and sequence diagrams are used as the basis for runtime profiling along with either offline or online analysis to determine whether the execution conforms to the diagrams. Situations where sequence diagrams are intended to characterize all possible executions are described. The approach generates an execution tree of all possible sequences, using a detailed collection of graph transformations that represent a precise operational semantics for sequence diagrams, including treatment for polymorphism, multiple activations, reference to other diagrams, and the use of frames in sequence diagrams. The sequence diagrams are also used to determine the information that should be gathered about method calls in the system. Aspects that can follow the flow of messages in a distributed system, are generated and the results of execution are recorded. The execution tree is used to automatically\u00a0\u2026", "num_citations": "8\n", "authors": ["626"]}
{"title": "An architectural style for optimizing system qualities in adaptive embedded systems using multi-objective optimization\n", "abstract": " Customers of today's complex embedded systems demand the optimization of multiple system qualities under varying operational conditions. To be able to influence the system qualities, the system must have parameters that can be adapted. Constraints may be defined on the value of these parameters. Optimizing multiple system qualities under the given set of parameters and constraints is called multi-objective optimization (MOO). This is a well-known mathematical problem, for which numerous solutions have been proposed. The application of an MOO solution in an embedded system involves specific design decisions. It is preferable that these design decisions are documented in the architectural description. Therefore, this paper presents an architectural style, which specializes the component-and-connector viewtype, to enable the analysis and design of an architecture from an MOO point of view. A case study\u00a0\u2026", "num_citations": "8\n", "authors": ["626"]}
{"title": "Integrating the concept of synthesis in the software architecture design process\n", "abstract": " Synthesis is a widely applied problem-solving approach of mature engineering disciplines including the sub-processes of technical problem analysis, identification and composition of solution domain concepts, and alternative-space analysis. Current software development processes do not adopt an explicit synthesis process and as such may fall short in identifying, composing and evaluating the relevant concerns. In order to advance ad hoc software development process to a mature engineering discipline it is necessary to integrate the concept of synthesis in current software engineering processes. In software engineering, software architecture design forms a key artifact including the early design decisions, which embodies the overall structure that impacts the quality of the overall system. For ensuring the quality of software architecture, it is necessary to identify and compose the relevant concerns. For this, we\u00a0\u2026", "num_citations": "8\n", "authors": ["626"]}
{"title": "Systematic analysis of crosscutting concerns in the model-driven architecture design approach\n", "abstract": " \u2751 Introduce an example: Concurrent file versioning system\u2751 PIM of the concurrent file versioning system\u2751 Relational PSM of the concurrent file versioning system\u2751 Java PSM of the concurrent file versioning system\u2751 Evolution of PIM by adding security of logging\u2751 Evolution of the relational PSM\u2751 Evolution of the Java PSM\u2751 Observations", "num_citations": "8\n", "authors": ["626"]}
{"title": "Reducing Quantization Error and Contextual Bias Problems in Object-Oriented Methods by Applying Fuzzy-Logic Techniques\n", "abstract": " Object-oriented methods define a considerable number of rules which are generally expressed using two-valued logic. For example, an entity in a requirement specification is either accepted or rejected as a class. There are two major problems how rules are defined and applied in current methods. Firstly, twovalued logic cannot effectively express the approximate and inexact nature of a typical software development process. Secondly, the influence of contextual factors on rules is generally not modeled explicitly. This article terms these problems as quantization error and contextual bias problems, respectively. To reduce these problems, fuzzy-logic techniques are proposed. This approach is method independent and is useful for evaluating and enhancing current methods. In addition, fuzzy-logic based techniques increase the adaptability and reusability of design models. Quantization error and contextual bias problems, and the usefulness of the fuzzy-logic based approach in reducing these problems are illustrated first formally, and then intuitively through a simple example. The fuzzylogic based method is implemented and tested by using our fuzzy-logic based experimental CASE environment.", "num_citations": "8\n", "authors": ["626"]}
{"title": "Emergent gummy modules: modular representation of emergent behavior\n", "abstract": " Emergent behavior is generally defined as the appearance of complex behavior out of multiplicity of relatively simple interactions. Nowadays, there are various kinds of software systems that deal with detecting the emergence of certain behavior in environment, representing it in the software and providing means to manipulate the behavior. Where significant amount of research has been dedicated to develop algorithms for detecting emergent behavior, there is no dedicated attempt to provide suitable linguistic abstractions to modularize emergent behavior and its related concerns. This results in implementations that are complex and hard to maintain. In this paper, we identify three characteristic features of emergent behavior, and outline the shortcomings of current languages to properly program and modularize emergent behavior. We introduce emergent gummy modules as dedicated linguistic abstractions, which\u00a0\u2026", "num_citations": "7\n", "authors": ["626"]}
{"title": "A pointcut language for setting advanced breakpoints\n", "abstract": " In interactive debugging, it is an essential task to set breakpoints specifying where a program should be suspended at runtime to allow interaction. A debugging session may use multiple logically related breakpoints so that the sequence of their (de) activations leads to the expected suspension with the least irrelevant suspensions. A (de) activation is sometimes decided by some runtime context values related to that breakpoint. However, existing breakpoints, which are mainly based on line locations, are not expressive enough to describe the logic and the collaboration. Programmers have to manually perform some repeated tasks, thus debugging efficiency is decreased. In this paper, we identify five frequently encountered debugging scenarios that require to use multiple breakpoints. For such scenarios, it is often easier than using the traditional debugger to write pointcuts in an aspect-oriented language, and to\u00a0\u2026", "num_citations": "7\n", "authors": ["626"]}
{"title": "Dealing with imprecise quality factors in software design\n", "abstract": " During the design of a software system impreciseness can manifest itself in for instance the requirements or performance estimations. While it is common to eliminate the impreciseness by information that can not be justified, it is better to model the impreciseness since it is the most accurate description that is available at the current point in time. In this paper we present an approach, which allows the explicit specification of quality estimations and quality requirements including the imprecise nature. In this approach the impreciseness is modeled and addressed using representations from probability theory and fuzzy set theory.", "num_citations": "7\n", "authors": ["626"]}
{"title": "Dealing with fuzzy information in software design methods\n", "abstract": " Software design methods incorporate a large set of heuristic rules that should result in stable software architecture of high quality. In general, clearly defined inputs are required to deliver the desired results. Unfortunately, especially in the early phases of software development, it is very difficult or even impossible to provide precisely defined information. Since methods cannot deal with imprecision, the designers need to make approximations which are generally not justifiable. In this paper, we will advocate an approach where the inputs for software design methods are modeled by using fuzzy sets. This approach renders the need for introduction of extra information for removal of inexactness obsolete.", "num_citations": "7\n", "authors": ["626"]}
{"title": "Separation and composition of concerns through synthesis-based design\n", "abstract": " A fundamental principle in software engineering in managing complexity and improving quality is the separation of concerns principle. Despite the general consensus on the importance of this principle, its application remains difficult. In this paper we discuss the origin of concerns and propose a synthesis-based design process for the identification, specification and realization of concerns. Synthesis is a widely applied problemsolving technique of mature engineering disciplines and aims to find the relevant concerns of a problem, using the sub-processes of technical problem analysis, identification and composition of solution domain concerns, and alternative-space analysis. We will explain the approach for the analysis of the concerns for failure recovery in atomic transaction systems.", "num_citations": "7\n", "authors": ["626"]}
{"title": "Strategic research directions in object oriented programming\n", "abstract": " This report is an overview of the field of object oriented programming. It presents a brief historical perspective of the field, then summarizes some major achievements. Four strategic research directions are then presented: technologies integration, software components, distributed programming, and open implementations.", "num_citations": "7\n", "authors": ["626"]}
{"title": "Event-based modularization: how emergent behavioral patterns must be modularized?\n", "abstract": " Nowadays, detecting emergent behavioral patterns in the environment, representing and manipulating them become the main focus of many software systems such as traffic monitoring systems, runtime verification techniques and self-adaptive systems. In this paper, we discuss the need for dedicated linguistic constructs to modularly represent emergent behavioral patterns and their lifetime semantics. We explain the shortcomings of current languages with this regard. Inspired from the evolution of procedural languages to object-oriented and aspect-oriented languages, we explain the concept of event-based modularization, which can be regarded as the successor of the aspect-oriented modularization for representing emergent behavioral patterns and their lifetime semantics. We report on our work on event modules and their successor gummy modules, which facilitate representing behavioral patterns as a holistic\u00a0\u2026", "num_citations": "6\n", "authors": ["626"]}
{"title": "Feature-based rationale management system for supporting software architecture adaptation\n", "abstract": " Each software architecture design is the result of a broad set of design decisions and their justifications, that is, the design rationale. Capturing the design rationale is important for a variety of reasons such as enhancing communication, reuse and maintenance. Unfortunately, it appears that there is still a lack of appropriate methods and tools for effectively capturing and managing the architecture design rationale. In this paper we present a feature-based rationale management approach and the corresponding tool environment ArchiRationale for supporting software architecture adaptation. The approach takes as input an existing architecture and captures the design rationale for adapting the architecture for a given quality concern. For this we define a feature model that includes the possible set of architectural tactics to realize the quality concern. The presented approach captures the rationale for deciding on feature\u00a0\u2026", "num_citations": "6\n", "authors": ["626"]}
{"title": "Framework for computer-aided evolution of object-oriented designs\n", "abstract": " In this paper, we describe a framework for the computer-aided evolution of the designs of object-oriented software systems. Evolution mechanisms are software structures that prepare software for certain type of evolutions. The framework uses a database which holds the evolution mechanisms, modeled as template graph transformations, with the supported evolution types. To evolve the software, the designer enters the type of evolution and provides the names of the software entities that are going to be evolved. The framework fetches the evolution mechanisms, converts the design to a graph model and applies the transformations. As an application of the framework, we implemented a tool for computer-aided evolution that uses object-oriented evolution mechanisms.", "num_citations": "6\n", "authors": ["626"]}
{"title": "Transactions on Aspect-Oriented Software Development III: Focus: Early Aspects\n", "abstract": " Welcome to Volume III of Transactions on Aspect-Oriented Software Development. Since its launch in 2006 the journal has attracted a steady stream of submissions, both to its indefinitely open call for papers and to calls pertaining to special issues focusing on key topics in AOSD. At the time of writing this editorial, the total number of submissions to the journal stands at 78. This is very healthy given that it is only the second year of the journal.The journal aims to maintain the highest standards expected of an archival work in AOSD while ensuring timely feedback and notification to the authors. Each paper is handled by an associate editor, appointed by the co-editors-in-chief, who is a specialist on the specific topic. We ensure that the associate editor does not have a conflict of interest relating to the paper assigned to him/her. If the associate editor deems the paper to be worthy of a review, s/he solicits reviews from at\u00a0\u2026", "num_citations": "6\n", "authors": ["626"]}
{"title": "Managing variability in product line scoping using design space models\n", "abstract": " Product-line engineering aims to reduce the cost of manufacturing of software products by exploiting their common properties. Obviously, to define a product line, the product alternatives that need to be produced must be identified first. This is generally realized either by a product requirements analysis or a domain analysis process. Product requirements analysis focuses on specific products or product characteristics and therefore may fail short to identify those products that are not explicitly stated in the product requirements. Domain models on the other hand are inherently too abstract to identify the product alternatives and reason about these explicitly. To provide a balanced scoping we propose to integrate both approaches and present the socalled design space models (DSMs) as a complementary technique to existing product line scoping techniques. We explain our ideas using an illustrative example for scoping the product-line of insurance systems.", "num_citations": "6\n", "authors": ["626"]}
{"title": "The DESARC method: An effective approach for university-industry cooperation\n", "abstract": " Achieving excellence in software development techniques is an important issue for the organizations that develop advanced software-intensive products. Within this context, software excellence is defined as the adoption of advanced software techniques and methods to cope with the complexity and the needs of modern software systems. However, this is not trivial due to the rapidly changing software technology, continuously increasing existence of large and complex software systems and difficulty in following the developments of the stateof-the-art in computer science. This paper focuses on the last aspect. To overcome this problem, it is necessary to define new ways for efficient university-software industry cooperation since advancements in computer science are largely carried out by universities. The existing university-industry cooperation methods are usually triggered after writing grant proposals to financing organizations and passing through strict selection processes. This is, in general, a very inefficient and tedious process to undertake. Even in a perfect review process, many good ideas may not go through simply because they do not fulfill the necessary procedural requirements. Moreover, industrial people may not be familiar with the methods and jargon used in the selection processes. Even if a project is approved, many times it does not result in a technology transfer to industry since accomplishing academic results is the main objective of such projects. This paper presents an overview of a pilot implementation of our approach termed as \u201cDescribe, Search and Acquire the Required Capability\u201d(DESARC), which aims at establishing a\u00a0\u2026", "num_citations": "5\n", "authors": ["626"]}
{"title": "A fine-grained, customizable debugger for aspect-oriented programming\n", "abstract": " To increase modularity, many aspect-oriented programming languages provide a mechanism based on implicit invocation: An aspect can influence runtime behavior of other modules without the need that these modules refer to the aspect. Recent studies show that a significant part of reported bugs in aspect-oriented programs are caused exactly by this implicitness. These bugs are difficult to detect, because aspect-oriented source code elements and their locations are transformed or even lost after compilation. We investigate four dedicated fault models and identify 11 tasks that a debugger should be able to perform for detecting aspect-orientation-specific faults. We show that existing debuggers are not powerful enough to support all identified tasks, because the aspect-oriented abstractions are lost after compilation.             This paper describes the design and implementation of a debugger for aspect\u00a0\u2026", "num_citations": "5\n", "authors": ["626"]}
{"title": "Debugging scandal-the next generation\n", "abstract": " In 1997, the general lack of debugging tools was termed the debugging scandal. Today, as new languages are emerging to support software evolution, once more debugging support is lagging. The powerful abstractions offered by new languages are compiled away and transformed into complex synthetic structures. Current debugging tools only allow inspection in terms of this complex synthetic structure; they do not support observation of program executions in terms of the original development abstractions. In this position paper, we outline this problem and present two emerging lines of research that ease the burden for debugger implementers and enable developers to debug in terms of development abstractions. For both approaches we identify language-independent debugger components and those that must be implemented for every new language. One approach restores the abstractions by a tool external to the program. The other maintains the abstractions by using a dedicated execution environment, supporting the relevant abstractions. Both approaches have the potential of improving debugging support for new languages. We discuss the advantages and disadvantages of both approaches, outline a combination thereof and also discuss open challenges.", "num_citations": "5\n", "authors": ["626"]}
{"title": "Graph-based verification of static program constraints\n", "abstract": " Software artifacts usually have static program constraints and these constraints should be satisfied in each reuse. In addition to this, the developers are also required to satisfy the coding conventions used by their organization. Because in a complex software system there are too many coding conventions and program constraints to be satisfied, it becomes a cumbersome task to check them all manually. This paper presents a process and tools that allow computer-aided program constraint checking that work on the source code.", "num_citations": "5\n", "authors": ["626"]}
{"title": "Deriving design alternatives based on quality factors\n", "abstract": " Software is rarely designed for ultimate adaptability or performance but rather it is a compromise of multiple considerations. At almost every stage of the software development lifecycle, software engineers have to cope with various design alternatives. Current object-oriented design practices, however, rely mainly on the intrinsic quality factors of the object-oriented abstractions rather than considering quality factors as explicit design concerns. It is considered important to support software engineers in identifying, comparing and selecting the alternatives using quality factors such as adaptability and performance. This chapter introduces a new technique to depict, compare and select among the design alternatives, based on their adaptability and time performance factors. This technique is formally specified and implemented by a number of tools.", "num_citations": "5\n", "authors": ["626"]}
{"title": "Minimizing Quantization Error and Contextual Bias Problems of Object-Oriented Methods by Applying Fuzzy-Logic Techniques\n", "abstract": " Object-oriented methods define a considerable number of rules which are generally expressed using two-valued logic. For example, an entity in a requirement specification is either accepted or rejected as a class. There are two major problems how rules are defined and applied in current methods. Firstly, twovalued logic cannot effectively express the approximate and inexact nature of a typical software development process. Secondly, the influence of contextual factors on rules is generally not modeled explicitly. This article terms these problems as quantization error and contextual bias problems, respectively. To reduce these problems, fuzzy-logic techniques are proposed. This approach is method independent and is useful for evaluating and enhancing current methods. In addition, fuzzy-logic based techniques increase the adaptability and reusability of design models. Quantization error and contextual bias problems, and the usefulness of the fuzzy-logic based approach in reducing these problems are illustrated first formally, and then intuitively through a simple example. The fuzzylogic based method is implemented and tested by using our fuzzy-logic based experimental CASE environment. Index terms: Object-oriented methods, fuzzy-logic based reasoning, quantization error, adaptable design models, development environments, reuse", "num_citations": "5\n", "authors": ["626"]}
{"title": "Availability analysis of software architecture decomposition alternatives for local recovery\n", "abstract": " We  present an efficient and easy-to-use methodology to predict\u2014at design time\u2014the availability of systems that support local recovery. Our analysis techniques work at the architectural level, where the software designer simply inputs the software modules\u2019 decomposition annotated with failure and repair rates. From this decomposition, we automatically generate an analytical model (a continuous-time Markov chain), from which an availability measure is then computed, in a completely automated way. A crucial step is the use of intermediate models in the input/output interactive Markov chain formalism, which makes our techniques efficient, mathematically rigorous, and easy to adapt. In particular, we use aggressive minimization techniques to keep the size of the generated state spaces small. We have applied our methodology on a realistic case study, namely the MPlayer open-source software. We have\u00a0\u2026", "num_citations": "4\n", "authors": ["626"]}
{"title": "A feature model and development approach for schedulers\n", "abstract": " Schedulers decide when to execute what in a system. They often work in constrained environments, where these decisions have high impact on performance. Since schedulers should be designed according to a system's needs, it is imperative that scheduling requirements are well defined. Building a scheduler that satisfies these requirements is not a trivial task. In this position paper we present our initial work and ideas on a domain-specific framework for scheduling. We introduce our feature model of the problem space of scheduling and explain how it fits within a framework. Furthermore we present our ideas on how to make the scheduler framework modular by using an aspect oriented approach", "num_citations": "4\n", "authors": ["626"]}
{"title": "Runtime verification of component-based embedded software\n", "abstract": " To deal with increasing size and complexity, component-based software development has been employed in embedded systems. Due to several faults, components can make wrong assumptions about the working mode of the system and the working modes of the other components. To detect mode inconsistencies at runtime, we propose a \u201clightweight\u201d error detection mechanism, which can be integrated with component-based embedded systems. We define links among three levels of abstractions: the runtime behavior of components, the working mode specifications of components and the specification of the working modes of the system. This allows us to detect the user observable runtime errors. The effectiveness of the approach is demonstrated by implementing a software monitor integrated into a TV system.", "num_citations": "4\n", "authors": ["626"]}
{"title": "Increasing system availability with local recovery based on fault localization\n", "abstract": " Due to the fact that software systems cannot be tested exhaustively, software systems must cope with residual defects at run-time. Local recovery is an approach for recovering from errors, in which only the defective parts of the system are recovered while the other parts are kept operational. To be efficient, local recovery must be aware of which component is at fault. In this paper, we combine a fault localization technique (spectrum-based fault localization, SFL) with local recovery techniques to achieve fully autonomous fault detection, isolation, and recovery. A framework is used for decomposing the system into separate units that can be recovered in isolation, while SFL is used for monitoring the activities of these units and diagnose the faulty one whenever an error is detected. We have applied our approach to MPlayer, a large open-source software. We have observed that SFL can increase the system availability\u00a0\u2026", "num_citations": "4\n", "authors": ["626"]}
{"title": "Component composability issues in object-oriented programming\n", "abstract": " The conventional objectoriented model is considered unsatisfactory with respect to reusability of software components. Current reuse strategies by aggregation or inheritance require an overload of method redefinitions. As a consequence, OO languages have to be extended without sacrificing their useful features. The concept of composition-filter is an language independent enhancement to the OO model; it avoids unnecessary method re-definition when components are reused.", "num_citations": "4\n", "authors": ["626"]}
{"title": "ECOOP'97-Object-Oriented Programming: 11th European Conference, Jyv\u00e4skyl\u00e4, Finland, June 9-13, 1997, Proceedings\n", "abstract": " 'When do the Lebesgue-Bochner function spaces contain a copy or a complemented copy of any of the classical sequence spaces?'This problem and the analogous one for vector-valued continuous function spaces have attracted quite a lot of research activity in the last twenty-five years. The aim of this monograph is to give a detailed exposition of the answers to these questions, providing a unified and self-contained treatment. It presents a great number of results, methods and techniques, which are useful for any researcher in Banach spaces and, in general, in Functional Analysis. This book is written at a graduate student level, assuming the basics in Banach space theory.", "num_citations": "4\n", "authors": ["626"]}
{"title": "A Comparative Analysis of Software Engineering with Mature Engineering Disciplines Using a Problem-Solving Perspective\n", "abstract": " Software engineering is compared with traditional engineering disciplines using a domain specific problem-solving model called Problem-Solving for Engineering Model (PSEM). The comparative analysis is performed both from a historical and contemporary view. The historical view provides lessons on the evolution of problem-solving and the maturity of an engineering discipline. The contemporary view provides the current state of engineering disciplines and shows to what extent software development can actually be categorized as an engineering discipline. The results from the comparative analysis show that like mature engineering, software engineering also seems to follow the same path of evolution of problem-solving concepts, but despite promising advances it has not reached yet the level of mature engineering yet. The comparative analysis offers the necessary guidelines for improving software\u00a0\u2026", "num_citations": "3\n", "authors": ["626"]}
{"title": "Behaviour modelling in model driven architecture\n", "abstract": " Behaviour modelling in model driven architecture Proceedings of the first Twente Data Management Workshop on XML Databases & Information Retrieval 21 June 2004 Enschede The Netherlands Editors: Vojkan Mihajlovic Djoerd Hiemstra Secretariat CTIT: University of Twente CTIT PO Box 217 7500 AE Enschede The Netherlands Phone+ 31 53 489 80 31 ISSN 1574-0846 CTIT Workshop Proceedings TDM 2004 Secretariat CTIT: University of Twente CTIT PO Box 217 7500 AE Enschede The Netherlands Phone+ 31 53 489 80 31 ISSN 1574-0846 June 23-24, 2009 Amsterdam The Netherlands Editors: Mehmet Aksit Ekkart Kindler Ashley McNeile Ella Roubtsova First European W orkshop on B ehaviour M odelling in M odelD riven A rchitecture (B M -M D A ) First European Workshop on Behaviour Modelling in Model Driven Architecture (BM-MDA) CTIT Workshop Proceedings Secretariat CTIT: University of \u2026", "num_citations": "3\n", "authors": ["626"]}
{"title": "Elsevier special issue on foundations and applications of model driven architecture\n", "abstract": " Model Driven Architecture (MDA) is an approach for software development proposed by Object Management Group (OMG). The basic principle of MDA is the separation of the specification of system functionality from the specification of the implementation of that functionality on a specific platform. The goal of the approach is to produce software assets that are more resilient to changes caused by the emerging technologies. MDA makes the role of modeling and models in the current software development much more important. It builds upon the existing OMG standards such as UML and UML profiles, MOF, CWM, and OCL. In addition, the MDA approach puts forward the need for additional technologies that support the realization of this vision for software development. As a result we have witnessed the emergence of several new OMG standards related to model-to-model transformations (the QVT transformation language), model-to-text transformations (MOF Model-to-Text transformation language), Architecture-Driven Modernization (ADM), and others. The MDA initiative covers a wide spectrum of research areas, some of them already well established and some are newly emerged. Further efforts are required to bring them into a coherent approach based on open standards and supported by matured tools and techniques.", "num_citations": "3\n", "authors": ["626"]}
{"title": "Detecting mode inconsistencies in component-based embedded software\n", "abstract": " To deal with increasing size and complexity, componentbased software development has been employed in embedded systems. These systems comprise a set of components each of which implements a particular functionality. The system utilizes the components to provide the functionalities that are required in a set of working modes. Components can also be considered to have a set of working modes. They should work in harmony and consistent with the working mode of the system. Due to several errors that remain undetected during the design and implementation phases, components can make wrong assumptions about the working mode of the system and the working modes of the other components. These errors may lead to severe failures. Fault tolerance is required to prevent these failures at runtime. The first step to achieve fault tolerance is error detection. To detect mode inconsistencies at run-time, we propose a\" lightweight\" error detection mechanism, which can be integrated with component-based embedded systems. We define three dependent levels of abstractions: the run-time behavior of components, the working mode specifications of components and the specification of the working modes of the system. We define explicit links among these levels by specifying a mutual consistency condition. This allows us to detect the user observable run-time errors. The effectiveness of the approach is demonstrated by implementing a software monitor integrated into a TV system.", "num_citations": "3\n", "authors": ["626"]}
{"title": "Automating Software Development Process Using Fuzzy Logic\n", "abstract": " Today\u2019s software projects are typically characterized by overrunning schedules and budget. In addition, software products in general suffer from high maintenance costs. To make software development and maintenance processes manageable, a number of methods [7, 12, 14, 17, 31] and Computer-Aided Software Engineering (CASE) environments have been proposed [6, 8, 25, 27]. CASE environments aim to automate the tedious and labor intensive part of the design process, and allow software engineers to concentrate only on the tasks that require human intuition.", "num_citations": "3\n", "authors": ["626"]}
{"title": "Applying fuzzy logic techniques in object-oriented software development\n", "abstract": " In the last several years, a considerable number of object-oriented methods have been introduced to create robust, reusable and adaptable software systems [1], [2], [3], [4]. Object-oriented methods define a considerable number of rules which are generally expressed by using two-valued logic. For instance, an entity in a requirement specification is either accepted or rejected as a class. We consider two major problems in the way how rules are defined and applied in current object-oriented methods. The first problem, termed quantization problem, is a natural result of the incapacity of two-valued logic to express the approximate and inexact nature of a typical software development process. The second problem, termed contextual bias problem, arises because most of methods are not able to model the effects of the context on the validity of the method. To reduce these problems, we propose a new fuzzy logic\u00a0\u2026", "num_citations": "3\n", "authors": ["626"]}
{"title": "Introduction to model management and analytics\n", "abstract": " Model management and analytics (MMA) aims to use models and related artifacts to derive relevant information to support decision making processes of organizations. Various different models as well as analytics approaches could be identified. In addition, MMA systems will have different requirements and as such apply different architecture design configurations. In this chapter we will discuss the key concepts related to MMA by referring also to existing data analytics approaches. We present and discuss the current key data analytics reference architectures in the literature and the key requirements for MMA. Subsequently, we provide the reference architecture of MMA using multiple architecture viewpoints. We illustrate the framework using a real-world example.", "num_citations": "2\n", "authors": ["626"]}
{"title": "Model Management and Analytics for Large Scale Systems\n", "abstract": " Model Management and Analytics for Large Scale Systems covers the use of models and related artefacts (such as metamodels and model transformations) as central elements for tackling the complexity of building systems and managing data. With their increased use across diverse settings, the complexity, size, multiplicity and variety of those artefacts has increased. Originally developed for software engineering, these approaches can now be used to simplify the analytics of large-scale models and automate complex data analysis processes. Those in the field of data science will gain novel insights on the topic of model analytics that go beyond both model-based development and data analytics. This book is aimed at both researchers and practitioners who are interested in model-based development and the analytics of large-scale models, ranging from big data management and analytics, to enterprise domains. The book could also be used in graduate courses on model development, data analytics and data management. Identifies key problems and offers solution approaches and tools that have been developed or are necessary for model management and analytics Explores basic theory and background, current research topics, related challenges and the research directions for model management and analytics Provides a complete overview of model management and analytics frameworks, the different types of analytics (descriptive, diagnostics, predictive and prescriptive), the required modelling and method steps, and important future directions", "num_citations": "2\n", "authors": ["626"]}
{"title": "On liberating programs from the von neumann architecture via event-based modularization\n", "abstract": " From the early days of computers, researchers have been trying to invent effective and efficient means for expressing software systems through the introduction of new programming languages. In the early days, due to the limitations of the technology, the abstractions of the programming languages were conceptually close to the abstractions of the von Neumann based realization platforms. With the advancement of the technology, computers have been increasingly applied for complex problems in different application domains. This required the challenge of designing programming languages that resemble more the semantics of software rather than the concepts of underlying machinery. To this aim, various new language concepts, such as object-oriented, aspect-oriented, and event-based languages have been introduced. While these languages were successful in enhancing the expression power of languages\u00a0\u2026", "num_citations": "2\n", "authors": ["626"]}
{"title": "A constructive approach to software evolution\n", "abstract": " In many software design and evaluation techniques, either the software evolution problem is not systematically elaborated, or only the impact of evolution is considered. Thus, most of the time software is changed by editing the components of the software system, ie breaking down the software system. The software engineering discipline provides many mechanisms that allow evolution without breaking down the system; however, the contexts where these mechanisms are applicable are not taken into account. Furthermore, the software design and evaluation techniques do not support identifying these contexts. In this paper, we provide a taxonomy of software evolution that can be used to identify the context of the evolution problem. The identified contexts are used to retrieve, from the software engineering discipline, the mechanisms, which can evolve the software software without breaking it down. To build such a taxonomy, we build a model for software evolution and use this model to identify the factors that effect the selection of software evolution mechanisms.", "num_citations": "2\n", "authors": ["626"]}
{"title": "Principles of aspect-oriented programming languages, design dimensions and the composition filters approach.\n", "abstract": " In traditional engineering disciplines, design is a problem solving process. It aims at mapping problems to realizable solutions, expressed using the artifacts in the corresponding engineering domain. Traditional engineering disciplines have introduced the concepts of canonical component models, systemic models, system construction rules and multiple (simultaneous) models. The emerging phenomena of the aspect-oriented software development techniques can be explained and motivated within this context. The concepts of component models, systemic models, system construction rules, multiple models as defined in traditional engineering disciplines correspond respectively to the concepts of base-level models, aspect models, join point models and multi-dimensional separation of concerns of aspect-oriented languages. Aspect-oriented languages can model the natural systemic properties of problem domains\u00a0\u2026", "num_citations": "2\n", "authors": ["626"]}
{"title": "Optimising software development policies for evolutionary system requirements\n", "abstract": " Anticipating future software requirements might support the evolution of software systems and as such reduce the cost of development and maintenance in due time. Unfortunately identifying the right set of evolution scenarios is difficult due to the uncertainty of occurrence of future requirements. In this paper we propose the Software Evolution Analysis Model (SEAM) that provides a probabilistic model for evolution requirements, which can more precisely anticipate future requirements and as such reduce the chance on unanticipated requirements. In SEAM the cost of each individual evolution requirement is defined and an optimal set of evolution scenarios is calculated using dynamic programming techniques.", "num_citations": "2\n", "authors": ["626"]}
{"title": "A global perspective on technological spaces\n", "abstract": " In this paper, we propose a high level view of technological spaces (TS) and relations between these spaces. A technological space is a working context with a set of associated concepts, body of knowledge, tools, required skills, and possibilities. It is often associated to a given user community with shared know-how, educational support, common literature and even conference meetings. Although such a framework is difficult to define precisely, it may be easily recognized. To give some examples, we may quote the XML TS, the DBMS TS, the abstract syntax TS, the meta-model (OMG/MDA) TS, etc. The purpose of our work is not to define an abstract theory of technological spaces, but on the contrary and much more pragmatically to understand how to work more efficiently by using the best possibilities of each technology. To do so, we need a basic understanding of the similarities and differences between various\u00a0\u2026", "num_citations": "2\n", "authors": ["626"]}
{"title": "On the notion of software engineering: A problem solving perspective\n", "abstract": " To grasp the essence of software engineering and understand its inherent problems, this paper provides a thorough and critical analysis of software engineering from a broad perspective. To this aim, a problem solving perspective is adopted and software engineering is analyzed and compared with the mature problem solving disciplines of philosophy and the traditional engineering disciplines such as electrical engineering, mechanical engineering, civil engineering and chemical engineering. Several lessons and the concepts that were derived from this analysis are described and proposed to integrate in the software engineering paradigm.", "num_citations": "2\n", "authors": ["626"]}
{"title": "Reusing and composing components: Problems and solutions\n", "abstract": " Building software from reusable components is considered important in reducing development costs. Object-oriented languages such as C++, Smalltalk and Java, however, are not capable of expressing certain aspects of applications in a composable way. Software engineers may experience difficulties in composing applications from components, for example if components implement code for multiple views, dynamic inheritance and synchronization [Aksit96]. If these aspects have to be programmed, then object-oriented languages may require a considerable amount of redefinition although this may not be intuitively necessary. To solve the composability problems, languages must be enhanced modularly without losing their basic characteristics. In addition, since more than one problem can be experienced for the same object, enhancements must be independent from each other. We have extended the conventional objectoriented model using the concept of composition-filters. Composition-filters can be attached to objects expressed for example in Smalltalk and Java. A number of different filter types have been defined, each addressing a certain concern. This paper first illustrates some practical problems and then introduces composition-filters solutions to overcome these problems.", "num_citations": "2\n", "authors": ["626"]}
{"title": "Identifying the Research Needs of Four Large High-Technology Companies\n", "abstract": " Software excellence is defined as the adoption of advanced software techniques and methods to cope with the complexity and the needs of modern software systems. To accomplish this objective, the companies that develop software intensive systems must be able to follow and adopt the state-ofthe-art developments in computer science and technology. In general, this implies carrying out research activities with the relevant universities. This paper presents an overview of a pilot implementation of the approach termed as \u201cDescribe, Search and Acquire the Required Capability\u201d(DESARC), which aims at establishing a more effective identification of research projects, allocation of these research projects to research groups and the cooperation between universities and industry. In our previous publication [1], we have presented the initial results of the method. Currently, we have extended this study and applied it in total to four large high-technology companies. This paper can be useful for the strategic developers who are interested in setting up university-industry cooperation and for the researchers who want to have an industrial view of the trends on computer science and software engineering.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Introduction to special issue on software engineering aspects of green computing (SEAGC)\n", "abstract": " Introduction to special issue on software engineering aspects of green... (2015) | www.narcis.nl KNAW KNAW Narcis Back to search results University of Twente Publication Introduction to special issue on software engineering aspects of green... (2015) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Introduction to special issue on software engineering aspects of green computing (SEAGC) Published in Sustainable computing, 7, 1 - 1. Elsevier. ISSN 2210-5379. Author Malakuti Khah Olun Abadi, Somayeh; Lohmann, Wolfgang; Aksit, Mehmet Date issued 2015-9 Access Closed Access Reference(s) CR-D.2, EWI-26786, METIS-316033, IR-99475, Green Computing, Software engineering Language und Type Article Publisher Elsevier Publication https://research.utwente.nl/en/publications/introduction-to-... OpenURL Search this publication in \u2026", "num_citations": "1\n", "authors": ["626"]}
{"title": "Trace-based debugging for advanced-dispatching programming languages\n", "abstract": " Advanced-dispatching programming languages allow to implicitly alter the behaviour of a program, depending on run-time program context. While this improves modularity, it also impedes comprehensibility. The use of advanced-dispatching programming languages can give rise to complex debugging scenarios, which cannot efficiently be resolved with traditional debugging approaches such as breakpoint-based debugging. Therefore, tool support for analysing the full history of runtime behaviour of advanced-dispatching programs is of importance for efficient debugging.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Trace-based debugging for advanced-dispatching programming languages\n", "abstract": " Advanced-dispatching programming languages allow to implicitly alter the behaviour of a program, depending on runtime program context. While this improves modularity, it also impedes comprehensibility. The use of advanced-dispatching programming languages can give rise to complex debugging scenarios, which cannot efficiently be resolved with traditional debugging approaches such as breakpoint-based debugging. Therefore, tool support for analysing the full history of runtime behaviour of advanced-dispatching programs is of importance for efficient debugging. In this paper, we characterise debugging scenarios for which existing work does not apply well, because they require access to the program execution history for efficient resolution. We present our design and implementation of a trace-based debugger for advanced-dispatching that supports such debugging scenarios efficiently. Our approach is the first one based on an XML-representation of the execution trace, giving rise to using very powerful standard tools such as the XQuery language for searching and navigating the trace, or scalable visualisations such as tree-maps.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Aspect-Oriented Language Mechanisms for Component Binding.\n", "abstract": " Domain Specific Languages (DSLs) are programming languages customized for a problem/solution domain, which allow development of software modules in high-level specifications. Code generation is a common practice for making DSL programs executable: A DSL specification is transformed to a functionally equivalent GPL (general-purpose programing language) representation. Integrating the module generated from a DSL specification to a base system poses a challenge, especially in a case where the DSL and the base system are developed independently. In this paper we describe the problem of integrating domainspecific modules to a system non-intrusively and promote loose coupling between these to allow software evolution. We present our on-going work on aspect-oriented language mechanisms for defining object selectors and object adapters as a solution to this problem.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Execution constraint verification of exception handling on UML sequence diagrams\n", "abstract": " Exception handling alters the control flow of the program. As such, errors introduced in exception handling code may influence the overall program in undesired ways. To detect such errors early and thereby decrease the programming costs, it is worthwhile to consider exception handling at design level. Preferably, design models must be extended to incorporate exception handling behavior and the control flow must be verified accordingly. Common practices for verification require a formal model and semantics of the design. Defining semantics and manually converting design models to formal models are costly. We propose an approach for verifying exception handling in UML design models, where we extend UML with exception handling notations, define execution and exception handling semantics, and automatically transform UML models to a formal model. The formal model is used for generating execution\u00a0\u2026", "num_citations": "1\n", "authors": ["626"]}
{"title": "Distribution-Transparency in Runtime Verification\n", "abstract": " Run-time verification checks whether the active execution traces of an application fulfills its specified behavior and is especially applicable when one needs to consider the actual execution context in the verification. In today's practices, software is more and more distributed over multiple processes, possibly running at different locations. This is supported by middleware that, to some extend, allows implementing applications in a distribution-transparent way. We define four requirements for the effective verification of such software: 1) abstraction of less-critical details of software behavior due to the complexity of software behavior, 2) distribution-transparent specification of software behavior, as software is also implemented in such a way, 3) end-to-end verification of behavior, and 4) automatic generation of verification modules for arbitrary process and distribution structures. The existing runtime verification systems fall\u00a0\u2026", "num_citations": "1\n", "authors": ["626"]}
{"title": "Distribution-Transparency in Runtime Verification\n", "abstract": " Run-time verification checks whether the active execution traces of an application fulfills its specified behavior and is especially applicable when one needs to consider the actual execution context in the verification. In today\u2019s practices, software is more and more distributed over multiple processes, possibly running at different locations. This is supported by middleware that, to some extend, allows implementing applications in a distribution-transparent way. We define four requirements for the effective verification of such software: 1) abstraction of less-critical details of software behavior due to the complexity of software behavior, 2) distribution-transparent specification of software behavior, as software is also implemented in such a way, 3) end-to-end verification of behavior, and 4) automatic generation of verification modules for arbitrary process and distribution structures. The existing runtime verification systems fall in short to fulfill these requirements, therefore their applicability is limited. We develop the E-Chaser runtime verification system to facilitate the verification of distributed software by addressing these requirements. This paper explains the approach and the prototype implementation of E-Chaser based on the Java-RMI technology.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Architectural Framework for Energy Optimization in Embedded Systems\n", "abstract": " Energy consumption has become one of the important system properties that should be controlled by embedded control software. There is usually an inherent trade-off between energy consumption and several system qualities. As such, optimization techniques should be adopted for making the desired trade-off among quality attributes. Implementations of these techniques are usually ad-hoc and system-specific, leading to implicit design decisions distributed over several software components. We propose an architectural framework for custom synthesis of control software from reusable and programmable elements. The goal is to facilitate systematic reuse of knowledge in the optimization domain and explicit management of quality trade-offs for energy optimization of embedded systems.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Verifying Runtime Reconfiguration Requirements on UML Models\n", "abstract": " Runtime reconfiguration is a method used for changing the structure and the call pattern such that the software can adapt itself to the client\u2019s computing environment. The current practice of verifying software models with respect to the reconfiguration requirements is rather subjective: based on the stakeholders\u2019 needs, architects define a set of reconfiguration scenarios and manually trace the models. This chapter presents a novel process and a tool for automating the verification of the UML class and sequence diagrams with respect to runtime reconfiguration requirements. In this process, the models are simulated, which generates the execution tree. In the execution tree, each path from root to a leaf node is an execution sequence. The branching in this tree is caused by the reconfiguration of the structure and the call pattern. The runtime reconfiguration requirements are expressed with a visual state-based\u00a0\u2026", "num_citations": "1\n", "authors": ["626"]}
{"title": "A rule set to detect interference of runtime enforcement mechanisms\n", "abstract": " Runtime enforcement aims at verifying the active execution trace of executing software against formally specified properties of the software, and enforcing the properties in case that they are violated in the active execution trace. Enforcement mechanism of individual properties may interfere with each other, causing the overall behavior of the executing software to be erroneous. As the number and the complexity of the properties to be enforced increase, manual detection of the inferences becomes an error-prone and effort-consuming task. Hence, we aim at providing a framework for automatic detection of interferences. As the initial steps to create such a framework, in this paper we first provide formal definitions of an enforcement mechanism and enforcement operators. Second, we define a rule set to detect the interference among properties.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Aksit, M.: Software development with imperfect information. Soft Computing 12, 3-28\n", "abstract": " Delivering software systems that fulfill all requirements of the stakeholders is very difficult, if not at all impossible. We consider the problem of coping with imperfect information, like interpreting incomplete requirement specifications or vagueness in decisions, one of the main reasons that makes software design difficult. We define a method for tracing design decisions under imperfect information. To model and compare requirements with estimations, we present fuzzy and stochastic techniques. This approach offers adequate decision support that can deal with imperfect information during software design. The approach is illustrated by a real-world example, based on a storm surge barrier system.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Aspect-based and Model-based Separation of Concerns in Software Systems\n", "abstract": " Preliminary Proceedings of the 1st International Workshop on Aspect-Based and Model-Based Separation of Concerns in Software Systems (ABMB) the 7th of November 2005, Nuremberg, Germany", "num_citations": "1\n", "authors": ["626"]}
{"title": "A case study on Optimization of Resource Distribution to cope with Unanticipated Changes in Requirements\n", "abstract": " It is a known fact that requirements change continuously, and as a consequence, it may be necessary to reschedule development activities so that the new requirements can be addressed in a costeffective manner. Unfortunately, changes in requirements cannot be specified precisely. Moreover, current software development methods do not provide explicit means to adapt development processes with respect to unanticipated changes in requirements. This article first proposes a method based on Markov Decision Theory, which determines the estimated optimal development schedule with respect to probabilistic product demands and resource constraints. Second, a tool is described that is built to support the method. Finally, some experimental results are presented on the applicability of the proposed method.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Computational Intelligence in Software Engineering\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "1\n", "authors": ["626"]}
{"title": "Special issue on computational intelligence in telecommunications networks and Internet services. I\n", "abstract": " In recent years, we have witnessed a rapidly growing role of the Internet that has already formed a conceptual backbone of the society in the information era. What becomes apparent and highly visible is a broad range of services and their enormous diversity being seamlessly available to those surfing cyberspace. The ongoing developments not only have enabled a different way of doing business but also pushed toward ambient intelligence where the user fully interacts with his or her surrounding information environment. The three special issues bring together the ideas of CI to the network area in a systematic, coherent, and comprehensive fashion that will help us move one step closer to the realization of the vision of ambient intelligence.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Building Application Frameworks: Object-Oriented Foundations of Framework Design (M. Fayad, D. Schmidt, R. Johnson (eds.)\n", "abstract": " Building Application Frameworks: Object-Oriented Foundations of... (1999) | www.narcis.nl KNAW KNAW Narcis Back to search results University of Twente Publication Building Application Frameworks: Object-Oriented Foundations of... (1999) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Building Application Frameworks: Object-Oriented Foundations of Framework Design (M. Fayad, D. Schmidt, R. Johnson (eds.) Published in Building Application Frameworks: Object-Oriented Foundations of Framework Design, 169 - 198 Author Aksit, Mehmet; Tekinerdogan, B. Date issued 1999 Access Restricted Access Reference(s) METIS-118895 Language und Type Book Part Publisher Wiley Publication https://research.utwente.nl/en/publications/building-applica... OpenURL Search this publication in (your) library ISBN 0471-24875-4 Persistent Identifier \u2026", "num_citations": "1\n", "authors": ["626"]}
{"title": "Automating the Object-Oriented Software Development Process: Workshop Report\n", "abstract": " Cost-effective realization of robust, adaptable and reusable software systems demands efficient and effective management of the overall software production process. Current object-oriented methods are not completely formalized and lack the ability of reasoning about the quality of processes and software products (artifacts). There is a need for new modeling formalisms, which enable the quantification of the required quality attributes and support the automation of the object-oriented development process (AOOSD). The ECOOP\u201998 AOOSD workshop was organized to identify the important issues in this direction.", "num_citations": "1\n", "authors": ["626"]}
{"title": "The analysis and design of distributed systems\n", "abstract": " The design of distributed object-oriented systems involves a number of considerations that rarely arise in sequential object-oriented design or in non-object-oriented languages. The tutorial describes analysis and design techniques for data abstraction, inheritance, delegation, persistence, atomicity, concurrency, synchronization, and coordinated behavior in a distributed object-oriented framework. Special attention will be paid to the uniform integration of these concepts with the object-oriented paradigm. Discussions will be accompanied by examples that arose from constructing such systems.", "num_citations": "1\n", "authors": ["626"]}
{"title": "Formalizing adaptability aspects\n", "abstract": " In [Kiczales et al. 97], aspects are defined as properties that affect the performance or semantics of the components in systemic ways. Systemic characteristic of aspects implies that they can be considered as concepts. The term performance is a special case of the general term quality. Other quality examples are adaptability and reusability. From this point of view, aspects are concepts which affect the quality and/or semantics of software components.We define the term software component as a programming language abstraction. Examples of software components are procedures, data structures and objects. Programming languages are vehicles to express abstract executable mechanisms. An aspect language is a language whose abstractions can directly represent one or more aspects. A trivial aspect is an aspect, which can be directly represented by a software component. This means that an aspect can show up as a software component (or can become trivial) if a suitable programming language can be designed for that aspect.", "num_citations": "1\n", "authors": ["626"]}