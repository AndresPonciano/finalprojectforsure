{"title": "Solving SAT and SAT Modulo Theories: From an abstract Davis--Putnam--Logemann--Loveland procedure to DPLL(T)\n", "abstract": " We first introduce Abstract DPLL, a rule-based formulation of the Davis--Putnam--Logemann--Loveland (DPLL) procedure for propositional satisfiability. This abstract framework allows one to cleanly express practical DPLL algorithms and to formally reason about them in a simple way. Its properties, such as soundness, completeness or termination, immediately carry over to the modern DPLL implementations with features such as backjumping or clause learning.We then extend the framework to Satisfiability Modulo background Theories (SMT) and use it to model several variants of the so-called lazy approach for SMT. In particular, we use it to introduce a few variants of a new, efficient and modular approach for SMT based on a general DPLL(X) engine, whose parameter X can be instantiated with a specialized solver SolverT for a given theory T, thus producing a DPLL(T) system. We describe the high-level design\u00a0\u2026", "num_citations": "1052\n", "authors": ["1621"]}
{"title": "DPLL(T): Fast Decision Procedures\n", "abstract": " The logic of equality with uninterpreted functions (EUF) and its extensions have been widely applied to processor verification, by means of a large variety of progressively more sophisticated (lazy or eager) translations into propositional SAT. Here we propose a new approach, namely a general DPLL(X) engine, whose parameter X can be instantiated with a specialized solver Solver                                       T                for a given theory T, thus producing a system DPLL(T). We describe this DPLL(T) scheme, the interface between DPLL(X) and Solver                                       T               , the architecture of DPLL(X), and our solver for EUF, which includes incremental and backtrackable congruence closure algorithms for dealing with the built-in equality and the integer successor and predecessor symbols. Experiments with a first implementation indicate that our technique already outperforms the previous methods on\u00a0\u2026", "num_citations": "418\n", "authors": ["1621"]}
{"title": "A new correctness proof of the Nelson-Oppen combination procedure\n", "abstract": " The Nelson-Oppen combination procedure, which combines satisfiability procedures for a class of first-order theories by propagation of equalities between variables, is one of the most general combination methods in the field of theory combination. We describe a new non- deterministic version of the procedure that has been used to extend the Constraint Logic Programming Scheme to unions of constraint theories. The correctness proof of the procedure that we give in this paper not only constitutes a novel and easier proof of Nelson and Oppen\u2019s original results, but also shows that equality sharing between the satisfiability procedures of the component theories, the main idea of the method, can be confined to a restricted set of variables.             While working on the new correctness proof, we also found a new characterization of the consistency of the union of first-order theories. We discuss and give a proof\u00a0\u2026", "num_citations": "197\n", "authors": ["1621"]}
{"title": "StarExec: A cross-community infrastructure for logic solving\n", "abstract": " We introduce StarExec, a public web-based service built to facilitate the experimental evaluation of logic solvers, broadly understood as automated tools based on formal reasoning. Examples of such tools include theorem provers, SAT and SMT solvers, constraint solvers, model checkers, and software verifiers. The service, running on a compute cluster with 380 processors and 23 terabytes of disk space, is designed to provide a single piece of storage and computing infrastructure to logic solving communities and their members. It aims at reducing duplication of effort and resources as well as enabling individual researchers or groups with no access to comparable infrastructure. StarExec allows community organizers to store, manage and make available benchmark libraries; competition organizers to run logic solver competitions; and community members to do comparative evaluations of logic solvers on\u00a0\u2026", "num_citations": "179\n", "authors": ["1621"]}
{"title": "The smt-lib standard: Version 1.2\n", "abstract": " The SMT-LIB initiative is an international effort, coordinated by these authors and supported by several research groups world-wide, with the main goal of producing an extensive on-line library of benchmarks for satisfiability modulo theories. This paper defines syntax and semantics of the language used by SMT-LIB for writing theory specifications and benchmarks.", "num_citations": "146\n", "authors": ["1621"]}
{"title": "Abstract DPLL and abstract DPLL modulo theories\n", "abstract": " We introduce Abstract DPLL, a general and simple abstract rule-based formulation of the Davis-Putnam-Logemann-Loveland (DPLL) procedure. Its properties, such as soundness, completeness or termination, immediately carry over to the modern DPLL implementations with features such as non-chronological backtracking or clause learning. This allows one to formally reason about practical DPLL algorithms in a simple way. In the second part of this paper we extend the framework to Abstract DPLL modulo theories. This allows us to express\u2014and formally reason about\u2014state-of-the-art concrete DPLL-based techniques for satisfiability modulo background theories, such as the different lazy approaches, or our DPLL(T) framework.", "num_citations": "137\n", "authors": ["1621"]}
{"title": "Scaling up the formal verification of Lustre programs with SMT-based techniques\n", "abstract": " We present a general approach for verifying safety properties of Lustre programs automatically. Key aspects of the approach are the choice of an expressive first-order logic in which Lustre's semantics is modeled very naturally, the tailoring to this logic of SAT-based k-induction and abstraction techniques, and the use of SMT solvers to reason efficiently in this logic. We discuss initial experimental results showing that our implementation of the approach is highly competitive with existing verification solutions for Lustre.", "num_citations": "122\n", "authors": ["1621"]}
{"title": "A DPLL-based calculus for ground satisfiability modulo theories\n", "abstract": " We describe and discuss DPLL(T ), a parametric calculus for proving the satisfiability of ground formulas in a logical theory T. The calculus tightly integrates a decision procedure for the satisfiability in T of sets of literals into a sequent calculus based on the well-known method by Davis, Putman, Logemann and Loveland for proving the satisfiability of propositional formulas. For being based on the DPLL method, DPLL(T ) can incorporate a number of very effective search heuristics developed by the SAT community for that method. Hence, it can be used as the formal basis for novel and efficient implementations of satisfiability checkers for theories with decidable ground consequences.", "num_citations": "121\n", "authors": ["1621"]}
{"title": "The model evolution calculus\n", "abstract": " The DPLL procedure is the basis of some of the most successful propositional satisfiability solvers to date. Although originally devised as a proof-procedure for first-order logic, it has been used almost exclusively for propositional logic so far because of its highly inefficient treatment of quantifiers, based on instantiation into ground formulas. The recent FDPLL calculus by Baumgartner was the first successful attempt to lift the procedure to the first-order level without resorting to ground instantiations. FDPLL lifts to the first-order case the core of the DPLL procedure, the splitting rule, but ignores other aspects of the procedure that, although not necessary for completeness, are crucial for its effectiveness in practice. In this paper, we present a new calculus loosely based on FDPLL that lifts these aspects as well. In addition to being a more faithful lifting of the DPLL procedure, the new calculus contains a more\u00a0\u2026", "num_citations": "116\n", "authors": ["1621"]}
{"title": "Unions of non-disjoint theories and combinations of satisfiability procedures\n", "abstract": " In this paper we outline a theoretical framework for the combination of decision procedures for constraint satisfiability. We describe a general combination method which, given a procedure that decides constraint satisfiability with respect to a constraint theory T 1 and one that decides constraint satisfiability with respect to a constraint theory T 2, produces a procedure that (semi-) decides constraint satisfiability with respect to the union of T 1 and T 2. We provide a number of model-theoretic conditions on the constraint language and the component constraint theories for the method to be sound and complete, with special emphasis on the case in which the signatures of the component theories are non-disjoint. We also describe some general classes of theories to which our combination results apply, and relate our approach to some of the existing combination methods in the field.", "num_citations": "101\n", "authors": ["1621"]}
{"title": "PKind: A parallel k-induction based model checker\n", "abstract": " PKind is a novel parallel k-induction-based model checker of invariant properties for finite- or infinite-state Lustre programs. Its architecture, which is strictly message-based, is designed to minimize synchronization delays and easily accommodate the incorporation of incremental invariant generators to enhance basic k-induction. We describe PKind's functionality and main features, and present experimental evidence that PKind significantly speeds up the verification of safety properties and, due to incremental invariant generation, also considerably increases the number of provable ones.", "num_citations": "92\n", "authors": ["1621"]}
{"title": "Combining nonstably infinite theories\n", "abstract": " The Nelson\u2013Oppen combination method combines decision procedures for first-order theories over disjoint signatures into a single decision procedure for the union theory. In order to be correct, the method requires that the component theories be stably infinite. This restriction makes the method inapplicable to many interesting theories such as, for instance, theories having only finite models.                 In this paper, we describe two extensions of the Nelson\u2013Oppen method that address the problem of combining theories that are not stably infinite. In our extensions, the component decision procedures exchange not only equalities between shared variables but also certain cardinality constraints.                 Applications of our results include the combination of theories having only finite models, as well as the combination of nonstably infinite theories with the theory of equality, the theories of total and partial\u00a0\u2026", "num_citations": "90\n", "authors": ["1621"]}
{"title": "Computing finite models by reduction to function-free clause logic\n", "abstract": " Recent years have seen considerable interest in procedures for computing finite models of first-order logic specifications. One of the major paradigms, MACE-style model building, is based on reducing model search to a sequence of propositional satisfiability problems and applying (efficient) SAT solvers to them. A problem with this method is that it does not scale well because the propositional formulas to be considered may become very large.We propose instead to reduce model search to a sequence of satisfiability problems consisting of function-free first-order clause sets, and to apply (efficient) theorem provers capable of deciding such problems. The main appeal of this method is that first-order clause sets grow more slowly than their propositional counterparts, thus allowing for more space efficient reasoning.In this paper we describe our proposed reduction in detail and discuss how it is integrated into the\u00a0\u2026", "num_citations": "84\n", "authors": ["1621"]}
{"title": "The Kind 2 model checker\n", "abstract": " Kind\u00a02 is an open-source, multi-engine, SMT-based model checker for safety properties of finite- and infinite-state synchronous reactive systems. It takes as input models written in an extension of the Lustre language that allows the specification of assume-guarantee-style contracts for system components. Kind\u00a02 was implemented from scratch based on techniques used by its predecessor, the PKind model checker. This paper discusses a number of improvements over PKind in terms of invariant generation. It also introduces two main features: contract-based compositional reasoning and certificate generation.", "num_citations": "83\n", "authors": ["1621"]}
{"title": "Implementing the model evolution calculus\n", "abstract": " Darwin is the first implementation of the Model Evolution Calculus by Baumgartner and Tinelli. The Model Evolution Calculus lifts the DPLL procedure to first-order logic. Darwin is meant to be a fast and clean implementation of the calculus, showing its effectiveness and providing a base for further improvements and extensions.         Based on a brief summary of the Model Evolution Calculus, we describe in the main part of the paper Darwin's proof procedure and its data structures and algorithms, discussing the main design decisions and features that influence Darwin's performance. We also report on practical experiments carried out with problems from the CASC-J2 system competition and parts of the TPTP Problem Library, and compare the results with those of other state-of-the-art theorem provers.", "num_citations": "80\n", "authors": ["1621"]}
{"title": "Finding conflicting instances of quantified formulas in SMT\n", "abstract": " In the past decade, Satisfiability Modulo Theories (SMT) solvers have been used successfully in a variety of applications including verification, automated theorem proving, and synthesis. While such solvers are highly adept at handling ground constraints in several decidable background theories, they primarily rely on heuristic quantifier instantiation methods such as E-matching to process quantified formulas. The success of these methods is often hindered by an overproduction of instantiations which makes ground level reasoning difficult. We introduce a new technique that alleviates this shortcoming by first discovering instantiations that are in conflict with the current state of the solver. The solver only resorts to traditional heuristic methods when such instantiations cannot be found, thus decreasing its dependence upon E-matching. Our experimental results show that our technique significantly reduces the number\u00a0\u2026", "num_citations": "75\n", "authors": ["1621"]}
{"title": "Finite model finding in SMT\n", "abstract": " SMT solvers have been used successfully as reasoning engines for automated verification. Current techniques for dealing with quantified formulas in SMT are generally incomplete, forcing SMT solvers to report \u201cunknown\u201d when they fail to prove the unsatisfiability of a formula with quantifiers. This inability to return counter-models limits their usefulness in applications that produce quantified verification conditions. We present a novel finite model finding method that reduces these limitations in the case of quantifiers ranging over free sorts. Our method contrasts with previous approaches for finite model finding in first-order logic by not relying on the introduction of domain constants for the free sorts and by being fully integrated into the general architecture used by most SMT solvers. This integration is achieved through the addition of a novel solver for sort cardinality constraints and a module for quantifier\u00a0\u2026", "num_citations": "66\n", "authors": ["1621"]}
{"title": "An automatable formal semantics for IEEE-754 floating-point arithmetic\n", "abstract": " Automated reasoning tools often provide little or no support to reason accurately and efficiently about floating-point arithmetic. As a consequence, software verification systems that use these tools are unable to reason reliably about programs containing floating-point calculations or may give unsound results. These deficiencies are in stark contrast to the increasing awareness that the improper use of floating-point arithmetic in programs can lead to unintuitive and harmful defects in software. To promote coordinated efforts towards building efficient and accurate floating-point reasoning engines, this paper presents a formalization of the IEEE-754 standard for floating-point arithmetic as a theory in many-sorted first-order logic. Benefits include a standardized syntax and unambiguous semantics, allowing tool interoperability and sharing of benchmarks, and providing a basis for automated, formal analysis of programs\u00a0\u2026", "num_citations": "64\n", "authors": ["1621"]}
{"title": "SMT proof checking using a logical framework\n", "abstract": " Producing and checking proofs from SMT solvers is currently the most feasible method for achieving high confidence in the correctness of solver results. The diversity of solvers and relative complexity of SMT over, say, SAT means that flexibility, as well as performance, is a critical characteristic of a proof-checking solution for SMT. This paper describes such a solution, based on a Logical Framework with Side Conditions (LFSC). We describe the framework and show how it can be applied for flexible proof production and checking for two different SMT solvers, clsat and cvc3. We also report empirical results showing good performance relative to solver execution time.", "num_citations": "64\n", "authors": ["1621"]}
{"title": "Satisfiability modulo theories\n", "abstract": " Many applications of formal methods rely on generating formulas of First-Order Logic (FOL) and proving or disproving their validity. Despite the great progress in the last twenty years in automated theorem proving (and disproving) in FOL, general-purpose theorem provers, such as for instance provers based on the resolution calculus, are typically inadequate to work with the sort of formulas generated by formal methods tools. The main reason is that these tools are not interested in validity in general but in validity with respect to some background theory, a logical theory that fixes the interpretations of certain predicates and function symbols. For instance, in formal methods involving the integers, one is only interested in showing that the formula\u2200 x\u2200 y (x< y\u21d2 x< y+ y) is true in those interpretations in which the symbol< denotes the usual ordering over the integers and+ denotes the addition function. When proving the (in) validity of a formula, general-purpose reasoning methods have only one way to consider only the interpretations allowed by a background theory: add as a premise to the formula a conjunction of the theory\u2019s axioms. When this is possible at all1 the performance of generic theorem provers is usually unacceptable for realistic formal method applications. A more viable alternative is the use of specialized reasoning methods for the background theory of interest. This is particularly the case for ground formulas, FOL formulas with no variables (and so also with no quantifiers), but possibly with free constants\u2014constant symbols not in the background theory. For many theories, specialized methods actually yield decision procedures for the\u00a0\u2026", "num_citations": "58\n", "authors": ["1621"]}
{"title": "Deciding the word problem in the union of equational theories\n", "abstract": " The main contribution of this paper is a new method for combining decision procedures for the word problem in equational theories. In contrast to previous methods, this method is based on transformation rules. Furthermore, it is not limited to theories with disjoint signatures but it also applies to theories sharing constructors.", "num_citations": "51\n", "authors": ["1621"]}
{"title": "Ground interpolation for the theory of equality\n", "abstract": " Given a theory  and two formulas A and B jointly unsatisfiable in , a theory interpolant of A and B is a formula I such that (i) its non-theory symbols are shared by A and B, (ii) it is entailed by A in , and (iii) it is unsatisfiable with B in . Theory interpolants are used in model checking to accelerate the computation of reachability relations. We present a novel method for computing ground interpolants for ground formulas in the theory of equality. Our algorithm computes interpolants from colored congruence graphs representing derivations in the theory of equality. These graphs can be produced by conventional congruence closure algorithms in a straightforward manner. By working with graphs, rather than at the level of individual proof steps, we are able to derive interpolants that are pleasingly simple (conjunctions of Horn clauses) and smaller than those generated by other tools.", "num_citations": "50\n", "authors": ["1621"]}
{"title": "The SMT-LIB format: An initial proposal\n", "abstract": " This paper is a first proposal for a common format for the Satisfiability Modulo Theories Library, or SMT-LIB for short. The main goal of the SMT-LIB initiative [2], coordinated by these authors and supported by a growing number of researchers world-wide, is to produce a on-line library of benchmarks for satisfiability modulo theories. By benchmark we mean a logical formula to be checked for satisfiability modulo (combinations of) background theories of interest. Examples of background theories typically used in computer science are real and integer arithmetic and the theories of various data structures such as lists, arrays, bit vectors and so on. A lot of work has been done in the last few years by several research groups on building systems for satisfiability modulo theories. We believe that having a library of benchmarks will greatly facilitate the evaluation and the comparison of these systems, and advance the state of the art in the field, in the same way as, for instance, the TPTP library [3] has done for theorem proving, or the SATLIB library [1] has done for propositional satisfiability.", "num_citations": "48\n", "authors": ["1621"]}
{"title": "The model evolution calculus as a first-order DPLL method\n", "abstract": " The DPLL procedure is the basis of some of the most successful propositional satisfiability solvers to date. Although originally devised as a proof-procedure for first-order logic, it has been used almost exclusively for propositional logic so far because of its highly inefficient treatment of quantifiers, based on instantiation into ground formulas. The FDPLL calculus by Baumgartner was the first successful attempt to lift the procedure to the first-order level without resorting to ground instantiations. FDPLL lifts to the first-order case the core of the DPLL procedure, the splitting rule, but ignores other aspects of the procedure that, although not necessary for completeness, are crucial for its effectiveness in practice.In this paper, we present a new calculus loosely based on FDPLL that lifts these aspects as well. In addition to being a more faithful lifting of the DPLL procedure, the new calculus contains a more systematic treatment\u00a0\u2026", "num_citations": "47\n", "authors": ["1621"]}
{"title": "Combining decision procedures for sorted theories\n", "abstract": " The Nelson-Oppen combination method combines decision procedures for theories satisfying certain conditions into a decision procedure for their union. While the method is known to be correct in the setting of unsorted first-order logic, some current implementations of it appear in tools that use a sorted input language. So far, however, there have been no theoretical results on the correctness of the method in a sorted setting, nor is it obvious that the method in fact lifts as is to logics with sorts. To bridge this gap between the existing theoretical results and the current implementations, we extend the Nelson-Oppen method to (order-)sorted logic and prove it correct under conditions similar to the original ones. From a theoretical point of view, the extension is relevant because it provides a rigorous foundation for the application of the method in a sorted setting. From a practical point of view, the extension has the\u00a0\u2026", "num_citations": "47\n", "authors": ["1621"]}
{"title": "A new approach for combining decision procedures for the word problem, and its connection to the Nelson-Oppen combination method\n", "abstract": " The Nelson-Oppen combination method can be used to combine decision procedures for the validity of quantifier-free formulae in first-order theories with disjoint signatures, provided that the theories to be combined are stably infinite. We show that, even though equational theories need not satisfy this property, Nelson and Oppen's method can be applied, after some minor modifications, to combine decision procedures for the validity of quantifier-free formulae in equational theories. Unfortunately, and contrary to a common belief, the method cannot be used to combine decision procedures for the word problem. We present a method that solves this kind of combination problem. Our method is based on transformation rules and also applies to equational theories that share a finite number of constant symbols.", "num_citations": "45\n", "authors": ["1621"]}
{"title": "Darwin: A theorem prover for the model evolution calculus\n", "abstract": " Darwin is the first implementation of the Model Evolution Calculus by Baumgartner and Tinelli. The Model Evolution Calculus lifts the DPLL procedure to first-order logic. Darwin is meant to be a fast and clean implementation of the calculus, showing its effectiveness and providing a base for further improvements and extensions.Based on a brief summary of the Model Evolution Calculus, we describe in the main part of the paper Darwin\u2019s proof procedure and its data structures and algorithms, discussing the main design decisions and features that influence Darwin\u2019s performance. We also report on practical experiments carried out with problems from the CADE-18 and CADE-19 system competitions, as well as on results on parts of the TPTP Problem Library.", "num_citations": "43\n", "authors": ["1621"]}
{"title": "Instantiation-based invariant discovery\n", "abstract": " We present a general scheme for automated instantiation-based invariant discovery. Given a transition system, the scheme produces k-inductive invariants from templates representing decidable predicates over the system\u2019s data types. The proposed scheme relies on efficient reasoning engines such as SAT and SMT solvers, and capitalizes on their ability to quickly generate counter-models of non-invariant conjectures. We discuss in detail two practical specializations of the general scheme in which templates represent partial orders. Our experimental results show that both specializations are able to quickly produce invariants from a variety of synchronous systems which prove quite useful in proving safety properties for these systems.", "num_citations": "42\n", "authors": ["1621"]}
{"title": "Cooperation of background reasoners in theory reasoning by residue sharing\n", "abstract": " We propose a general way of combining background reasoners in theory reasoning. Using a restricted version of the Craig interpolation lemma, we show that background reasoner cooperation can be achieved as a form of constraint propagation, much in the spirit of existing combination methods for decision procedures. In this case, constraint information is propagated across reasoners eexchanging residues that are, in essence, disjunctions of ground literals over a common signature. As an application of our approach, we describe a multitheory version of the semantic tableau calculus, and we prove it sound and complete.", "num_citations": "41\n", "authors": ["1621"]}
{"title": "Ground interpolation for combined theories\n", "abstract": " We give a method for modular generation of ground interpolants in modern SMT solvers supporting multiple theories. Our method uses a novel algorithm to modify the proof tree obtained from an unsatifiability run of the solver into a proof tree without occurrences of troublesome \u201cuncolorable\u201d literals. An interpolant can then be readily generated using existing procedures. The principal advantage of our method is that it places few restrictions (none for convex theories) on the search strategy of the solver. Consequently, it is straightforward to implement and enables more efficient interpolating SMT solvers. In the presence of non-convex theories our method is incomplete, but still more general than previous methods.", "num_citations": "39\n", "authors": ["1621"]}
{"title": "The model evolution calculus with equality\n", "abstract": " In many theorem proving applications, a proper treatment of equational theories or equality is mandatory. In this paper we show how to integrate a modern treatment of equality in the Model Evolution calculus ( ), a first-order version of the propositional DPLL procedure. The new calculus, , is a proper extension of the  calculus without equality. Like  it maintains an explicit candidate model, which is searched for by DPLL-style splitting. For equational reasoning  uses an adapted version of the ordered paramodulation inference rule, where equations used for paramodulation are drawn (only) from the candidate model. The calculus also features a generic, semantically justified simplification rule which covers many simplification techniques known from superposition-style theorem proving. Our main result is the correctness of the  calculus in the presence of very general redundancy\u00a0\u2026", "num_citations": "37\n", "authors": ["1621"]}
{"title": "Lemma learning in the model evolution calculus\n", "abstract": " The Model Evolution  Calculus is a proper lifting to first-order logic of the DPLL procedure, a backtracking search procedure for propositional satisfiability. Like DPLL, the ME calculus is based on the idea of incrementally building a model of the input formula by alternating constraint propagation steps with non-deterministic decision steps. One of the major conceptual improvements over basic DPLL is lemma learning, a mechanism for generating new formulae that prevent later in the search combinations of decision steps guaranteed to lead to failure. We introduce two lemma generation methods for  proof procedures, with various degrees of power, effectiveness in reducing search, and computational overhead. Even if formally correct, each of these methods presents complications that do not exist at the propositional level but need to be addressed for learning to be effective in practice for . We\u00a0\u2026", "num_citations": "34\n", "authors": ["1621"]}
{"title": "Combined satisfiability modulo parametric theories\n", "abstract": " We give a fresh theoretical foundation for designing comprehensive SMT solvers, generalizing in a practically motivated direction. We define parametric theories that most appropriately express the \u201clogic\u201d of common data types. Our main result is a combination theorem for decision procedures for disjoint theories of this kind. Virtually all of the deeply nested data structures (lists of arrays of sets of ...) that arise in verification work are covered.", "num_citations": "33\n", "authors": ["1621"]}
{"title": "A new combination procedure for the word problem that generalizes fusion decidability results in modal logics\n", "abstract": " Previous results for combining decision procedures for the word problem in the non-disjoint case do not apply to equational theories induced by modal logics\u2014which are not disjoint for sharing the theory of Boolean algebras. Conversely, decidability results for the fusion of modal logics are strongly tailored towards the special theories at hand, and thus do not generalize to other types of equational theories. In this paper, we present a new approach for combining decision procedures for the word problem in the non-disjoint case that applies to equational theories induced by modal logics, but is not restricted to them. The known fusion decidability results for modal logics are instances of our approach. However, even for equational theories induced by modal logics our results are more general since they are not restricted to so-called normal modal logics.", "num_citations": "33\n", "authors": ["1621"]}
{"title": "Incremental invariant generation using logic-based automatic abstract transformers\n", "abstract": " Formal analysis tools for system models often require or benefit from the availability of auxiliary system invariants. Abstract interpretation is currently one of the best approaches for discovering useful invariants, in particular numerical ones. However, its application is limited by two orthogonal issues: (i) developing an abstract interpretation is often non-trivial; each transfer function of the system has to be represented at the abstract level, depending on the abstract domain used; (ii) with precise but costly abstract domains, the information computed by the abstract interpreter can be used only once a post fix point has been reached; this may take a long time for large systems or when widening is delayed to improve precision. We propose a new, completely automatic, method to build abstract interpreters which, in addition, can provide sound invariants of the system under analysis before reaching the end of the\u00a0\u2026", "num_citations": "26\n", "authors": ["1621"]}
{"title": "(LIA)-Model Evolution with Linear Integer Arithmetic Constraints\n", "abstract": " Many applications of automated deduction require reasoning modulo some form of integer arithmetic. Unfortunately, theory reasoning support for the integers in current theorem provers is sometimes too weak for practical purposes. In this paper we propose a novel calculus for a large fragment of first-order logic modulo Linear Integer Arithmetic (LIA) that overcomes several limitations of existing theory reasoning approaches. The new calculus \u2014 based on the Model Evolution calculus, a first-order logic version of the propositional DPLL procedure \u2014 supports restricted quantifiers, requires only a decision procedure for LIA-validity instead of a complete LIA-unification procedure, and is amenable to strong redundancy criteria. We present a basic version of the calculus and prove it sound and (refutationally) complete.", "num_citations": "26\n", "authors": ["1621"]}
{"title": "Model evolution with equality\u2014revised and implemented\n", "abstract": " In many theorem proving applications, a proper treatment of equational theories or equality is mandatory. In this paper, we show how to integrate a modern treatment of equality in the Model Evolution calculus (ME), a first-order version of the propositional DPLL procedure. The new calculus, ME E, is a proper extension of the ME calculus without equality. Like ME it maintains an explicit candidate model, which is searched for by DPLL-style splitting. For equational reasoning ME E uses an adapted version of the superposition inference rule, where equations used for superposition are drawn (only) from the candidate model. The calculus also features a generic, semantically justified simplification rule which covers many simplification techniques known from superposition-style theorem proving. Our main theoretical result is the correctness of the ME E calculus in the presence of very general redundancy elimination\u00a0\u2026", "num_citations": "24\n", "authors": ["1621"]}
{"title": "Model evolution with equality modulo built-in theories\n", "abstract": " Many applications of automated deduction require reasoning modulo background theories, in particular some form of integer arithmetic. Developing corresponding automated reasoning systems that are also able to deal with quantified formulas has recently been an active area of research. We contribute to this line of research and propose a novel instantiation-based method for a large fragment of first-order logic with equality modulo a given complete background theory, such as linear integer arithmetic. The new calculus is an extension of the Model Evolution Calculus with Equality, a first-order logic version of the propositional DPLL procedure, including its ordering-based redundancy criteria. We present a basic version of the calculus and prove it sound and (refutationally) complete under certain conditions.", "num_citations": "23\n", "authors": ["1621"]}
{"title": "Model finding for recursive functions in SMT\n", "abstract": " SMT solvers have recently been extended with techniques for finding models of universally quantified formulas in some restricted fragments of first-order logic. This paper introduces a translation that reduces axioms specifying a large class of recursive functions, including terminating functions, to universally quantified formulas for which these techniques are applicable. An evaluation confirms that the approach improves the performance of existing solvers on benchmarks from three sources. The translation is implemented as a preprocessor in the CVC4 solver and in a new higher-order model finder called Nunchaku.", "num_citations": "22\n", "authors": ["1621"]}
{"title": "Proof certificates for SMT-based model checkers for infinite-state systems\n", "abstract": " We present a dual technique for generating and verifying proof certificates in SMT-based model checkers, focusing on proofs of invariant properties. Certificates for two major model checking algorithms are extracted as k-inductive invariants, minimized and then reduced to a formal proof term with the help of an independent proof-producing SMT solver. SMT-based model checkers typically translate input problems into an internal first-order logic representation. In our approach, the correctness of translation from the model checker's input to the internal representation is verified in a lightweight manner by proving the observational equivalence between the results of two independent translations. This second proof is done by the model checker itself and generates in turn its own proof certificate. Our experimental evaluation show that, at the price of minimal instrumentation in the model checker, the approach allows one\u00a0\u2026", "num_citations": "21\n", "authors": ["1621"]}
{"title": "Combining non-stably infinite theories\n", "abstract": " The Nelson-Oppen combination method combines decision procedures for first-order theories over disjoint signatures into a single decision procedure for the union theory. To be correct, the method requires that the component theories be stably infinite. This restriction makes the method inapplicable to many interesting theories such as, for instance, theories having only finite models.In this paper we provide a new combination method that can combine any theory that is not stably infinite with another theory, provided that the latter is what we call a shiny theory. Examples of shiny theories include the theory of equality, the theory of partial orders, and the theory of total orders.An interesting consequence of our results is that any decision procedure for the satisfiability of quantifier-free \u03a3-formulae in a \u03a3-theory T can always be extended to accept inputs over an arbitrary signature \u03a9 \u2287 \u03a3.", "num_citations": "21\n", "authors": ["1621"]}
{"title": "A new combination procedure for the word problem that generalizes fusion decidability results in modal logics\n", "abstract": " Previous results for combining decision procedures for the word problem in the non-disjoint case do not apply to equational theories induced by modal logics\u2014whose combination is not disjoint since they share the theory of Boolean algebras. Conversely, decidability results for the fusion of modal logics are strongly tailored towards the special theories at hand, and thus do not generalize to other equational theories.               In this paper, we present a new approach for combining decision procedures for the word problem in the non-disjoint case that applies to equational theories induced by modal logics, but is not restricted to them. The known fusion decidability results for modal logics are instances of our approach. However, even for equational theories induced by modal logics our results are more general since they are not restricted to so-called normal modal logics.", "num_citations": "20\n", "authors": ["1621"]}
{"title": "Constraint logic programming over unions of constraint theories\n", "abstract": " In this paper, we propose an extension of the Jaffar-Lassez Constraint Logic Programming scheme that operates with unions of constraint theories with different signatures and decides the satisfiability of mixed constraints by appropriately combining the constraint solvers of the component theories. We describe the extended scheme and provide logical and operational semantics for it along the lines of those given for the original scheme. Then we show how the main soundness and completeness results of Constraint Logic Programming lift to our extension.", "num_citations": "20\n", "authors": ["1621"]}
{"title": "Extending SMTCoq, a certified checker for SMT\n", "abstract": " This extended abstract reports on current progress of SMTCoq, a communication tool between the Coq proof assistant and external SAT and SMT solvers. Based on a checker for generic first-order certificates implemented and proved correct in Coq, SMTCoq offers facilities both to check external SAT and SMT answers and to improve Coq's automation using such solvers, in a safe way. Currently supporting the SAT solver zChaff, and the SMT solver veriT for the combination of the theories of congruence closure and linear integer arithmetic, SMTCoq is meant to be extendable with a reasonable amount of effort: we present work in progress to support the SMT solver CVC4 and the theory of bit vectors.", "num_citations": "17\n", "authors": ["1621"]}
{"title": "Incremental verification with mode variable invariants in state machines\n", "abstract": " We describe two complementary techniques to aid the automatic verification of safety properties of synchronous systems by model checking. A first technique allows the automatic generation of certain inductive invariants for mode variables. Such invariants are crucial in the verification of safety properties in systems with complex modal behavior. A second technique allows the simultaneous verification of multiple properties incrementally. Specifically, the outcome of a property\u2014valid or invalid\u2014is communicated to the user as soon as it is known. Moreover, each property proven valid is used immediately as an invariant in the model checking procedure to aid the verification of the remaining properties. We have implemented these techniques as new options in the Kind model checker. Experimental evidence shows that these two techniques combine synergistically to increase Kind\u2019s precision as well as its speed.", "num_citations": "15\n", "authors": ["1621"]}
{"title": "SMT-Based Model Checking.\n", "abstract": " SMT-based Model Checking Page 1 SMT-based Model Checking Cesare Tinelli The University of Iowa 4th NASA Formal Methods Symposium, April 2012 \u2013 p.1/54 Page 2 Modeling Computational Systems Software or hardware systems can be often represented as a state transition system M = (S,I,T ,L) where \u2022 S is a set of states, the state space \u2022 I\u2286S is a set of initial states \u2022 T \u2286S\u00d7S is a (right-total) transition relation \u2022 L : S \u2192 2P is a labeling function where P is a set of state predicates Typically, the state predicates denote variable-value pairs x = v 4th NASA Formal Methods Symposium, April 2012 \u2013 p.2/54 Page 3 Model Checking Software or hardware systems can be often represented as a state transition system M = (S,I,T ,L) M can be seen as a model both 1. in an engineering sense: an abstraction of the real system and 2. in a mathematical logic sense: a Kripke structure in some modal logic 4th NASA Formal \u2026", "num_citations": "15\n", "authors": ["1621"]}
{"title": "SyGuS Techniques in the Core of an SMT Solver\n", "abstract": " We give an overview of recent techniques for implementing syntax-guided synthesis (SyGuS) algorithms in the core of Satisfiability Modulo Theories (SMT) solvers. We define several classes of synthesis conjectures and corresponding techniques that can be used when dealing with each class of conjecture.", "num_citations": "11\n", "authors": ["1621"]}
{"title": "Combining decision procedures for positive theories sharing constructors\n", "abstract": " This paper addresses the following combination problem: given two equational theories E                         1 and E                         2 whose positive theories are decidable, how can one obtain a decision procedure for the positive theory of E                         1\u222aE                         2? For theories over disjoint signatures, this problem was solved by Baader and Schulz in 1995. This paper is a first step towards extending this result to the case of theories sharing constructors. Since there is a close connection between positive theories and unification problems, this also extends to the non-disjoint case the work on combining decision procedures for unification modulo equational theories.", "num_citations": "11\n", "authors": ["1621"]}
{"title": "Deciding the word problem in the union of equational theories sharing constructors\n", "abstract": " The main contribution of this paper is a new method for combining decision procedures for the word problem in equational the- ories sharing \u201cconstructors.\u201d The notion of constructors adopted in this paper has a nice algebraic definition and is more general than a related notion introduced in previous work on the combination problem.", "num_citations": "11\n", "authors": ["1621"]}
{"title": "Non-disjoint unions of theories and combinations of satisfiability procedures: First results\n", "abstract": " In this paper we outline a theoretical framework for the combination of decision procedures for the satisfiability of constraints with respect to a constrainttheory. We describe a general combination method which, given a procedure that decides constraint satisfiability with respect to a constraint theory  and one that decides constraint satisfiability with respect to a constraint theory , is able to produce a procedure that (semi-)decides constraint satisfiability with respect to the union of  and . We also provide some model-theoretic conditions on the constraint language and the component constraint theories for the method to be sound and complete, with special emphasis on the case in which the signatures of  and  are non-disjoint.", "num_citations": "11\n", "authors": ["1621"]}
{"title": "Extending enumerative function synthesis via SMT-driven classification\n", "abstract": " Many relevant problems in formal methods can be tackled using enumerative syntax-guided synthesis (SyGuS). Algorithms for enumerative SyGuS range from universally applicable techniques based on counterexample-guided inductive synthesis (CEGIS), to more scalable but specialized techniques based on divide and conquer. This paper presents a novel algorithm for enumerative SyGuS, Unif + PI, which reaps the benefits of scalability based on divide and conquer without sacrificing generality. In this algorithm, an instance of an SMT solver is used as both a classifier and an attribute generator. Logical constraints in the form of test cases for the function-to-synthesize and failed classification attempts guide its search for new candidate solutions. We implement our approach as an extension of the CVC4SY solver and evaluate it on standard SyGuS benchmarks from different applications. We show that the new\u00a0\u2026", "num_citations": "9\n", "authors": ["1621"]}
{"title": "Certified interpolant generation for EUF\n", "abstract": " Logical interpolants have found a wide array of applications in automated verification, including symbolic model checking and predicate abstraction. It is often critical to these applications that reported interpolants exhibit desired properties, correctness being first and foremost. In this paper, we introduce a method in which interpolants are computed by type inference within the trusted core of a proof checker. Interpolants produced this way from a proof of the joint unsatisfiability of two formulas are certified as correct by construction. We focus our attention to the quantifier-free theory of equality and uninterpreted functions (EUF) and present an interpolant generating proof calculus that can be encoded in the LFSC proof checking framework with limited reliance upon computational side conditions. Our experimental results show that our method generates certified interpolants with small overhead with respect to solving.", "num_citations": "9\n", "authors": ["1621"]}
{"title": "Combining decision procedures for theories in sorted logics\n", "abstract": " The Nelson-Oppen combination method combines decision procedures for theories satisfying certain conditions into a decision procedure for their union. While the method is known to be correct in the setting of unsorted first-order logic, some current implementations of it appear in tools that use a sorted input language. So far, however, there have been no theoretical results on the correctness of the method in a sorted setting, nor it is obvious that the method in fact lifts as is to logics with sorts. To bridge this gap between the existing theoretical results and the current implementations, we extend the Nelson-Oppen method to (order-) sorted logic and prove it correct under conditions similar to the original ones. From a theoretical standpoint, the extension is relevant because it provides a rigorous foundation for the application of the method in a sorted setting. From a practical standpoint, the extension has the considerable added benefits that in a sorted setting the method\u2019s preconditions become easier to satify in practice, and the method\u2019s nondeterminism is generally reduced.", "num_citations": "9\n", "authors": ["1621"]}
{"title": "Combining equational theories sharing non-collapse-free constructors\n", "abstract": " In this paper we extend the applicability of our combination method for decision procedures for the word problem to theories sharing non-collapse-free constructors. This extension broadens the scope of the combination procedure considerably, for example in the direction of equational theories axiomatizing the equivalence of modal formulae.", "num_citations": "9\n", "authors": ["1621"]}
{"title": "Symbolic computation and satisfiability checking\n", "abstract": " The two communities of Symbolic Computation and Satisfiability Checking have recently found themselves tackling similar problems and having a growing interest in each other's technology. This special issue presents articles whose contribution is of interest to, and is influenced by, both communities. Given the context of this journal we start this editorial with a more thorough overview of Satisfiability Checking, and then turn to Symbolic Computation and the potentials and challenges for collaboration. The collection of articles in this issue is evidence of the already existing fruitful work at the intersection of these communities.", "num_citations": "8\n", "authors": ["1621"]}
{"title": "Architectural and behavioral analysis for cyber security\n", "abstract": " The asymmetric nature and ever-increasing degree of sophistication of cyber threats drive the need for assurance of critical infrastructure and systems. Current approaches that can help counter these cyber threats include the application of tools with the ability to analyze system behavior in its most general form and in the presence of wide classes of threats-at design time. In this paper we describe our tool for incorporating cyber security resiliency analysis and recommendations in the system design process that are automated, scalable, provide rich feedback, specify trade-offs and are easy to use by system architects. The architecture models and design knowledge are captured in formalisms that are expressive and amenable to automated reasoning, analysis, and analysis for cyber security. The two main components developed are Model-Based Architectural Analysis and Cyber-resiliency Verifier. The Model\u00a0\u2026", "num_citations": "8\n", "authors": ["1621"]}
{"title": "Introducing StarExec: a Cross-Community Infrastructure for Logic Solving.\n", "abstract": " Ongoing breakthroughs in a number of fields depend on continuing advances in the development of high-performance automated reasoning tools, such as SAT solvers, SMT solvers, theorem provers, constraint solvers, rewrite systems, model checkers, and so on. Typically, application problems are translated into (possibly large and complex) formulas for these tools to reason about. Different tradeoffs between linguistic expressiveness and the difficulty of the original problems have led to the adoption of different reasoning approaches and the use of different logics to encode those problems. Solver communities, formed around these different logics, have developed their own research infrastructures to encourage innovation and ease the adoption of their solver technology. Examples include standard formats for the logic problems, libraries of benchmark problems, and solver competitions to spur innovation and further advances. So far, these different infrastructures have been developed separately in the various logic communities, at significant and largely duplicated cost in development effort, equipment and support.StarExec, currently under development, is a solver execution and benchmark library service aimed at facilitating the experimental evaluation of automated reasoning tools. It will provide a single piece of storage and computing infrastructure to all logic solving communities, reducing the duplication of effort and waste of resources. StarExec will provide a custom web interface and web services running on a cluster of 150-200 compute nodes, with several terabytes of networked disk space. The service will allow community organizers to\u00a0\u2026", "num_citations": "8\n", "authors": ["1621"]}
{"title": "Foundations of Satisfiability Modulo Theories.\n", "abstract": " Foundations of Satisfiability Modulo Theories - SC2 Summer School Page 1 foundations of satisfiability modulo theories SC2 Summer School Cesare Tinelli July 31, 2017 The University of Iowa Page 2 acknowledgments Many thanks to \u2219 Clark Barrett \u2219 Dejan Jovanovic \u2219 Albert Oliveras for contributing some of the material used in these slides. Disclamer: The literature on SMT and its applications is vast. The bibliographic references provided here are just a sample. Apologies to all authors whose work is not cited. 1 Page 3 introduction Page 4 introduction Historically, automated reasoning \u2261 uniform proof-search procedures for First Order Logic 3 Page 5 introduction Historically, automated reasoning \u2261 uniform proof-search procedures for First Order Logic Limited success: is FOL the best compromise between expressivity and efficiency? 3 Page 6 introduction Historically, automated reasoning \u2261 uniform proof-search \u2026", "num_citations": "8\n", "authors": ["1621"]}
{"title": "Higher-order SMT solving (work in progress)\n", "abstract": " Satisfiability modulo theories (SMT) solvers have throughout the years been able to cope with increasingly expressive formulas, from ground logics to full first-order logic modulo theories. Nevertheless, higher-order logic within SMT (HOSMT) is still little explored. In this preliminary report we discuss how to extend SMT solvers to natively support higherorder reasoning without compromising their performances on FO problems. We present a pragmatic extension of the cvc4 solver in which we generalize existing data structures and algorithms to HOSMT, thus leveraging the extensive research and implementation efforts dedicated to efficient FO solving. Our evaluation shows that the initial implementation does not add significant overhead to FO problems and its performance is on par with the encoding-based approach for HOSMT. We also discuss an alternative extension being implemented in veriT, in which new data structures and algorithms are being developed from scratch to best support HOSMT, thus avoiding the inherent difficulties of generalizing in a graceful way existing infrastructure not indented to higher-order reasoning.", "num_citations": "6\n", "authors": ["1621"]}
{"title": "An abstract framework for satisfiability modulo theories\n", "abstract": " An Abstract Framework for Satisfiability Modulo Theories Page 1 An Abstract Framework for Satisfiability Modulo Theories Cesare Tinelli The University of Iowa Tableaux 2007 \u2013 p.1/40 Page 2 Credits Based on joint work with: Clark Barrett, Peter Baumgartner, Robert Nieuwenhuis, and Albert Oliveras Special thanks to: the TABLEAUX 2007 PC for the invitation. Tableaux 2007 \u2013 p.2/40 Page 3 Satisfiability Modulo Theories Any SAT solver can be used to decide the satisfiability of ground (ie, variable-free) first-order formulas. Tableaux 2007 \u2013 p.3/40 Page 4 Satisfiability Modulo Theories Any SAT solver can be used to decide the satisfiability of ground (ie, variable-free) first-order formulas. Often, however, one is interested in the satisfiability of certain ground formulas in a theory: Tableaux 2007 \u2013 p.3/40 Page 5 Satisfiability Modulo Theories Any SAT solver can be used to decide the satisfiability of ground (ie, variable-free\u2026", "num_citations": "6\n", "authors": ["1621"]}
{"title": "Combination results for many sorted theories with overlapping signatures\n", "abstract": " We present a combination result for many-sorted first-order theories whose signatures may share common symbols (ie overlapping or non-disjoint signatures), extending the recent results by Ghilardi for the unsorted case. Furthermore, we give practical conditions under which the combination method becomes a semi-decision procedure, and additional sufficient conditions which turn it into a decision procedure.Several theories which are practically useful in formal verification have overlapping signatures (eg linear arithmetic and bit-vectors). We demonstrate how their decision procedures can be combined using our results. In addition, we obtain a many-sorted version of the Nelson-Oppen method as a special case of our combination result.", "num_citations": "6\n", "authors": ["1621"]}
{"title": "Theory combination: beyond equality sharing\n", "abstract": " Satisfiability is the problem of deciding whether a formula has a model. Although it is not even semidecidable in first-order logic, it is decidable in some first-order theories or fragments thereof (e.g., the quantifier-free fragment). Satisfiability modulo a theory is the problem of determining whether a quantifier-free formula admits a model that is a model of a given theory. If the formula mixes theories, the considered theory is their union, and combination of theories is the problem of combining decision procedures for the individual theories to get one for their union. A standard solution is the equality-sharing method by Nelson and Oppen, which requires the theories to be disjoint and stably infinite. This paper surveys selected approaches to the problem of reasoning in the union of disjoint theories, that aim at going beyond equality sharing, including: asymmetric extensions of equality sharing, where some theories\u00a0\u2026", "num_citations": "5\n", "authors": ["1621"]}
{"title": "LFSC for SMT proofs: Work in progress\n", "abstract": " This paper presents work in progress on a new version, for public release, of the Logical Framework with Side Conditions (LFSC), previously proposed as a proof meta-format for SMT solvers and other proof-producing systems. The paper reviews the type-theoretic approach of LFSC, presents a new input syntax which hides the type-theoretic details for better accessibility, and discusses work in progress on formalizing and implementing a revised core language.", "num_citations": "5\n", "authors": ["1621"]}
{"title": "Invariant stream generators using automatic abstract transformers based on a decidable logic\n", "abstract": " The use of formal analysis tools on models or source code often requires the availability of auxiliary invariants about the studied system. Abstract interpretation is currently one of the best approaches to discover useful invariants, especially numerical ones. However, its application is limited by two orthogonal issues: (i) developing an abstract interpretation is often non-trivial; each transfer function of the system has to be represented at the abstract level, depending on the abstract domain used; (ii) with precise but costly abstract domains, the information computed by the abstract interpreter can be used only once a post fix point has been reached; something that may take a long time for very large system analysis or with delayed widening to improve precision. This paper proposes a new, completely automatic, method to build abstract interpreters. One of its nice features is that its produced interpreters can provide sound invariants of the analyzed system before reaching the end of the post fix point computation, and so act as on-the-fly invariant generators.", "num_citations": "5\n", "authors": ["1621"]}
{"title": "The impact of Craig\u2019s Interpolation Theorem in computer science\n", "abstract": " The Impact of Craig\u2019s Interpolation Theorem in Computer Science Page 1 The Impact of Craig\u2019s Interpolation Theorem in Computer Science Cesare Tinelli tinelli@cs.uiowa.edu The University of Iowa Berkeley, May 2007 \u2013 p.1/28 Page 2 The Role of Logic in Computer Science Mathematical logic is central to Computer Science Berkeley, May 2007 \u2013 p.2/28 Page 3 The Role of Logic in Computer Science Mathematical logic is central to Computer Science It provides formal foundations for Programming languages Relational databases Computational complexity Hardware design and validation Formal methods in software engineering Artificial Intelligence ... Berkeley, May 2007 \u2013 p.2/28 Page 4 Craig\u2019s Interpolation Theorem in CS has had a strong and lasting impact in several CS areas, both at the theoretical and the practical level Berkeley, May 2007 \u2013 p.3/28 Page 5 Craig\u2019s Interpolation Theorem in CS has had a \u2026", "num_citations": "4\n", "authors": ["1621"]}
{"title": "SYSLITE: syntax-guided synthesis of PLTL formulas from finite traces\n", "abstract": " We present an ef cient approach to learn past-time linear temporal logic formulas (PLTL) from a set of propositional variables and a sample of nite traces over those variables. The ef ciency of our approach can be attributed to a careful encoding of the PLTL formula learning problem as a bit-vector function synthesis problem, and the use of an enhanced Syntax-Guided Synthesis (SyGuS) engine to solve the latter. We implemented our approach in a tool called SYSLITE and empirically evaluated its ef cacy with two case studies. In these case studies, we observe that SYSLITE on average enjoys a speedup of 44x over current learning approaches for temporal formulas while learning the expected formulas in the vast majority of cases.", "num_citations": "3\n", "authors": ["1621"]}
{"title": "Description Logic, Theory Combination, and All That\n", "abstract": " This Festschrift has been put together on the occasion of Franz Baader\u2019s 60th birthday to celebrate his scientific contributions. It was initiated by Anni-Yasmin Turhan, who brought in the other four editors. We contacted Franz\u2019s friends and colleagues, asking for their contributions, and the response was enthusiastic. The result is a volume containing 30 articles from contributors all over the world, starting with an introductory article that provides our personal accounts of Franz\u2019s career and achievements and covering many of the several scientific areas Franz has worked on: description logics, unification and matching, term rewriting, and the combination of decision procedures. Although this volume does not come close to covering all of the work that Franz has done, we hope that the reader will gain some insights into the remarkable breadth and depth of his research over the past 30+ years. We thank all contributors\u00a0\u2026", "num_citations": "3\n", "authors": ["1621"]}
{"title": "Verifying bit-vector invertibility conditions in coq\n", "abstract": " This work is a part of an ongoing effort to prove the correctness of invertibility conditions for the theory of fixed-width bit-vectors, which are used to solve quantified bit-vector formulas in the Satisfiability Modulo Theories (SMT) solver CVC4. While many of these were proved in a completely automatic fashion for any bit-width, some were only proved for bit-widths up to 65, even though they are being used to solve formulas over arbitrary bit-widths. In this paper we describe our initial efforts in proving a subset of these invertibility conditions in the Coq proof assistant. We describe the Coq library that we use, as well as the extensions that we introduced to it.", "num_citations": "2\n", "authors": ["1621"]}
{"title": "Constraint solving for finite model finding in SMT solvers\n", "abstract": " Satisfiability modulo theories (SMT) solvers have been used successfully as reasoning engines for automated verification and other applications based on automated reasoning. Current techniques for dealing with quantified formulas in SMT are generally incomplete, forcing SMT solvers to report \u201cunknown\u201d when they fail to prove the unsatisfiability of a formula with quantifiers. This inability to return counter models limits their usefulness in applications that produce queries involving quantified formulas. In this paper, we reduce these limitations by integrating finite model finding techniques based on constraint solving into the architecture used by modern SMT solvers. This approach is made possible by a novel solver for cardinality constraints, as well as techniques for on-demand instantiation of quantified formulas. Experiments show that our approach is competitive with the state of the art in SMT, and orthogonal to\u00a0\u2026", "num_citations": "2\n", "authors": ["1621"]}
{"title": "Combining satisfiability procedures for automated deduction and constraint-based reasoning\n", "abstract": " Several constraint-based paradigms have been developed in Automated Reasoning which try to combine the advantages of domain-depended constraint solving with those of general-purpose reasoning. Although Constraint-based Reasoning has proven rather successful, it is often limited to frameworks operating essentially over a single constraint domain. Many potential applications of Constraint-based Reasoning, however, involve heterogeneous constraints, that is, constraints spanning over several constraint domains at once. Solving such constraints requires a cooperation of two or more constraint reasoners. In other words, it requires that the various constraint reasoners be combined into a reasoner for a constraint domain which is itself a combination of the reasoners' domains.", "num_citations": "2\n", "authors": ["1621"]}
{"title": "Barcelogic for smt\n", "abstract": " Barcelogic for SMT is the SMT-solver developed by our group at the Technical University of Catalonia. The aim of our group is the development of efficient logic-based tools, not only for verification applications (SAT, and SAT Modulo Theories), but also for other problems such as, eg, sports scheduling or optimization problems. Currently, the active members of the group are: Miquel Bofill, Robert Nieuwenhuis, Albert Oliveras, Albert Rubio and Enric Rodr\u00edguez-Carbonell.See the results of the 2005 SMT competition, where our SMT-solver won all four categories in which it could compete. In the 2006 SMT competition, Barcelogic came second in all categories it could compete in.", "num_citations": "2\n", "authors": ["1621"]}
{"title": "VERDICT: A Language and Framework for Engineering Cyber Resilient and Safe System\n", "abstract": " The ever-increasing complexity of cyber-physical systems is driving the need for assurance of critical infrastructure and embedded systems. However, traditional methods to secure cyber-physical systems\u2014eg, using cyber best practices, adapting mechanisms from information technology systems, and penetration testing followed by patching\u2014are becoming ineffective. This paper describes, in detail, Verification Evidence and Resilient Design In anticipation of Cybersecurity Threats (VERDICT), a language and framework to address cyber resiliency. When we use the term resiliency, we mean hardening a system such that it anticipates and withstands attacks. VERDICT analyzes a system in the face of cyber threats and recommends design improvements that can be applied early in the system engineering process. This is done in two steps:(1) Analyzing at the system architectural level, with respect to cyber and safety requirements and (2) by analyzing at the component behavioral level, with respect to a set of cyber-resiliency properties. The framework consists of three parts:(1) Model-Based Architectural Analysis and Synthesis (MBAAS);(2) Assurance Case Fragments Generation (ACFG); and (3) Cyber Resiliency Verifier (CRV). The VERDICT language is an Architecture Analysis and Design Language (AADL) annex for modeling the safety and security aspects of a system\u2019s architecture. MBAAS performs probabilistic analyses, suggests defenses to mitigate attacks, and generates attack-defense trees and fault trees as evidence of resiliency and safety. It can also synthesize optimal defense solutions\u2014with respect to implementation costs. In\u00a0\u2026", "num_citations": "1\n", "authors": ["1621"]}
{"title": "On solving quantified bit-vector constraints using invertibility conditions\n", "abstract": " We present a novel approach for solving quantified bit-vector constraints in Satisfiability Modulo Theories (SMT) based on computing symbolic inverses of bit-vector operators. We derive conditions that precisely characterize when bit-vector constraints are invertible for a representative set of bit-vector operators commonly supported by SMT solvers. We utilize syntax-guided synthesis techniques to aid in establishing these conditions and verify them independently by using several SMT solvers. We show that invertibility conditions can be embedded into quantifier instantiations using Hilbert choice expressions and give experimental evidence that a counterexample-guided approach for quantifier instantiation utilizing these techniques leads to performance improvements with respect to state-of-the-art solvers for quantified bit-vector constraints.", "num_citations": "1\n", "authors": ["1621"]}
{"title": "CVC4SY for SyGuS-COMP 2019\n", "abstract": " CVC4Sy is a syntax-guided synthesis (SyGuS) solver based on bounded term enumeration and, for restricted fragments, quantifier elimination. The enumerative strategies are based on encoding term enumeration as an extension of the quantifier-free theory of algebraic datatypes and on a highly optimized brute-force algorithm. The quantifier elimination strategy extracts solutions from unsatisfiability proofs of the negated form of synthesis conjectures. It uses recent counterexample-guided techniques for quantifier instantiation that make finding such proofs practically feasible. CVC4Sy implements these strategies by extending the satisfiability modulo theories (SMT) solver CVC4. The strategy to be applied on a given problem is chosen heuristically based on the problem's structure. This document gives an overview of these techniques and their implementation in the SyGuS Solver CVC4Sy, an entry for SyGuS-Comp 2019.", "num_citations": "1\n", "authors": ["1621"]}
{"title": "Frontiers of Combining Systems: 8th International Symposium, FroCoS 2011, Saarbr\u00fccken, Germany, October 5-7, 2011. Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 8th International Symposium on Frontiers of Combining Systems, FroCoS 2011, held in Saarbr\u00fccken, Germany, in October 2011. The 15 revised full papers presented together with three invited papers were carefully reviewed and selected from 22 submissions. The event builds a common forum for research activities in the general area of combination, modularization and integration of systems, with emphasis on logic-based ones, and of their practical use.", "num_citations": "1\n", "authors": ["1621"]}
{"title": "Frontiers of Combining Systems\n", "abstract": " Frontiers of Combining Systems :: MPG.PuRe English Help Privacy Policy Disclaimer Include files Advanced SearchBrowse START BASKET (0)Tools Item ITEM ACTIONSEXPORT Add to Basket Local TagsStatisticsRelease HistoryDetailsSummary Released Proceedings Frontiers of Combining Systems MPS-Authors /persons/resource/persons45516 Sofronie-Stokkermans, Viorica Automation of Logic, MPI for Informatics, Max Planck Society; External Resource No external resources are shared Fulltext (public) There are no public fulltexts stored in PuRe Supplementary Material (public) There is no public supplementary material available Citation Tinelli, C., & Sofronie-Stokkermans, V. ( Eds. ). (2011). Frontiers of Combining Systems. Berlin: Springer. Cite as: http://hdl.handle.net/11858/00-001M-0000-001A-226F-6 Abstract There is no abstract available \u2026", "num_citations": "1\n", "authors": ["1621"]}
{"title": "CVC3 Proof Conversion to LFSC\n", "abstract": " This technical report gives definitions for conversion methods for proofs generated by the SMT solver Cvc3, into a format readable by the proof checker LFSC. We will discuss proofs in the quantifier-free linear real arithmetic logic (QF LRA) of SMT.LFSC (\u201cLogical Framework with Side Conditions\u201d) is a proof checker based on the Edinburgh Logical Framework (LF), a high-level declarative language in which logics (understood as inference systems over a certain language of formulas) can be specified. LFSC increases LF\u2019s flexibility by including support for computational side conditions on inference rules. These conditions, expressed in a small functional programming language, enable some parts of a proof to be established by computation.", "num_citations": "1\n", "authors": ["1621"]}
{"title": "Bit-Precise Reasoning via Int-Blasting\n", "abstract": " The state of the art for bit-precise reasoning in the context of Satisfiability Modulo Theories (SMT) is a SAT-based technique called bit-blasting where the input formula is first simplified and then translated to an equisatisfiable propositional formula. The main limitation of this technique is scalability, especially in the presence of larger bit-widths and arithmetic operators. We introduce an alternative technique, which we call int-blasting, based on a translation to an extension of integer arithmetic rather than propositional logic. We present several alternative translations, discuss their differences, and evaluate them on benchmarks that arise from smart contract verification, verification of rewrite rule candidates for bit-vector solving, as well as benchmarks from SMT-LIB. The evaluation shows that this technique is particularly useful for benchmarks with large bit-widths and can solve benchmarks that the state of the art cannot.", "num_citations": "1\n", "authors": ["1621"]}
{"title": "Extending SMT solvers to higher-order logic (technical report)\n", "abstract": " SMT solvers have throughout the years been able to cope with increasingly expressive formulas, from ground logics to full first-order logic (FOL). In contrast, the extension of SMT solvers to higher-order logic (HOL) is mostly unexplored. We propose a pragmatic extension for SMT solvers to support HOL reasoning natively without compromising performance on FOL reasoning, thus leveraging the extensive research and implementation efforts dedicated to efficient SMT solving. We show how to generalize data structures and the ground decision procedure to support partial applications and extensionality, as well as how to reconcile quantifier instantiation techniques with higher-order variables. We also discuss a separate approach for redesigning an HOL SMT solver from the ground up via new data structures and algorithms. We apply our pragmatic extension to the CVC4 SMT solver and discuss a redesign of the veriT SMT solver. Our evaluation shows they are competitive with state-of-the-art HOL provers and often outperform the traditional encoding into FOL.", "num_citations": "1\n", "authors": ["1621"]}