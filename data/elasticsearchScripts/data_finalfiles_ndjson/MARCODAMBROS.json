{"title": "Reverse engineering with logical coupling\n", "abstract": " Evolutionary information about software systems has proven to be a good resource to complement existing reverse engineering approaches, because it helps in giving a historical perspective of the system to be reverse engineered. Moreover, it provides additional types of information that are not present when only one version of a system is considered. Logical coupling, the implicit dependency between artifacts which changed together, is one example of such information. However, the recurrent problem is that such information comes in large amounts and must be processed to be useful for the reverse engineering of a system. In this paper we propose an approach to use logical coupling information at different levels of abstraction to detect areas in the system which may lead to maintenance problems. They represent a good starting point to decrease the coupling in the system. Our approach uses an interactive\u00a0\u2026", "num_citations": "89\n", "authors": ["76"]}
{"title": "Software bugs and evolution: A visual approach to uncover their relationship\n", "abstract": " Versioning systems such as CVS exhibit a large potential to investigate and understand the evolution of large software systems. Bug reporting systems such as Bugzilla help to understand which parts of the system are affected by problems. In this article, we present a novel visual approach to uncover the relationship between evolving software and the way it is affected by software bugs. By visually putting the two aspects close to each other, we can characterize the evolution of software artifacts. We validate our approach on 3 very large open source software systems", "num_citations": "73\n", "authors": ["76"]}
{"title": "Bugcrawler: Visualizing evolving software systems\n", "abstract": " Software evolution is aimed at analyzing and understanding the present state of a software system and at predicting its future development. This knowledge supports reverse engineering activities since it allows the analyst to infer causes of problems in the system and to detect components which need to be restructured. However, effectively using evolutionary information is challenging because it typically comes in large amounts, especially when several years of evolution are considered. Techniques are needed to break down the data quantity and complexity. BugCrawler is a language independent tool which supports software evolution and reverse engineering. It is based on a combination of software metrics and interactive visualizations. BugCrawler integrates structural information computed from the source code with evolutionary information retrieved from CVS log files and Bugzilla problem reports. It has been\u00a0\u2026", "num_citations": "42\n", "authors": ["76"]}
{"title": "Telling stories about GNOME with Complicity\n", "abstract": " Traditionally, the target of software evolution research has been single software systems. However, in the recent years, researchers observed that software systems are often not developed in isolation, but within a larger context: the ecosystem level. Analyzing software evolution at the ecosystem level allows a better understanding of the evolution phenomenon, as the entire development context can be studied. Nonetheless, software ecosystem analysis is challenging because of the sheer amount of data to be processed and understood. We present Complicity, a web-based application that supports software ecosystem analysis by means of interactive visualizations. Complicity breaks down the data quantity by offering two abstraction levels: ecosystem and entity. To support a thorough exploration and analysis of ecosystem data, the tool provides a number of fixed viewpoints and the possibility of creating new\u00a0\u2026", "num_citations": "40\n", "authors": ["76"]}
{"title": "Distributed and collaborative software evolution analysis with churrasco\n", "abstract": " Analyzing the evolution of large and long-lived software systems is a complex problem that requires extensive tool support due to the amount and complexity of the data that needs to be processed. In this paper, we present Churrasco, a tool to support collaborative software evolution analysis through a web interface. After describing the tool and its architecture, we provide a usage scenario of Churrasco on a large open source software system, and we present two collaboration experiments performed with, respectively, 8 and 4 participants.", "num_citations": "35\n", "authors": ["76"]}
{"title": "Interacting with visualizations\n", "abstract": " In human-media interactions, visualizations occur in a large variety of forms. However, they remain but a single form of possible feedback towards a user. In this chapter it is argued that human-centered visualization is a fundamental part of human-media interaction and vice versa. To that end, the focus in this chapter lies first on the more general topic of interaction research, thus providing a solid literary ground for the rest of this chapter (Section\u00a03.1). In Section\u00a03.2 the focus shifts towards the question how a display technology influences the way(s) in which interaction with visualization takes place. This path is then broadened in Section\u00a03.3 by focusing on approaches towards interacting multimodally with visualizations. To that end a chronological overview of developments in that field is given, thus providing an insight of trends and required steps in realizing multimodal interactions. Also, future work in this\u00a0\u2026", "num_citations": "34\n", "authors": ["76"]}
{"title": "Visual software evolution reconstruction\n", "abstract": " The analysis of the evolution of large software systems is challenging for many reasons, such as the retrieval and processing of historical information and the large quantity of data that must be dealt with. While recent advances in research have led to the solutions to these problems, a central question remains: How do we deal with this information in a methodical way and where do we start with our analysis? We present a methodology based on interactive visualizations that support the reconstruction of the evolution of software systems. We propose several visualizations which help us to perform software evolution analysis of a system \u2018in the large\u2019 and \u2018in the small\u2019, and apply them to two large systems. Copyright \u00a9 2009 John Wiley & Sons, Ltd.", "num_citations": "32\n", "authors": ["76"]}
{"title": "A flexible framework to support collaborative software evolution analysis\n", "abstract": " To understand the evolution of software, researchers have developed a plethora of tools to parse, model, and analyze the history of systems. Despite their usefulness, a common downside of such tools is that their use comes with many strings attached, such as installation, data formats, usability, etc. The result is that many tools are only used by their creators, which is detrimental to cross-fertilization of research ideas and collaborative analysis. In this paper we present the Churrasco framework, which supports software evolution modeling, visualization and analysis through a web interface. The user provides only the URL of the Subversion repository to be analyzed and, if available, of the corresponding bug tracking system. Churrasco processes the given data and automatically creates and stores an evolutionary model in a centralized database. This database, called Meta-base is connected to Churrasco through\u00a0\u2026", "num_citations": "25\n", "authors": ["76"]}
{"title": "Supporting software evolution analysis with historical dependencies and defect information\n", "abstract": " More than 90% of the cost of software is due to maintenance and evolution. Understanding the evolution of large software systems is a complex problem, which requires the use of various techniques and the support of tools. Several software evolution approaches put the emphasis on structural entities such as packages, classes and structural relationships. However, software evolution is not only about the history of software artifacts, but it also includes other types of data such as problem reports, mailing list archives etc. We propose an approach which focuses on historical dependencies and defects. We claim that they play an important role in software evolution and they are complementary to techniques based on structural information. We use historical dependencies and defect information to learn about a software system and detect potential problems in the source code. Moreover, based on design flaws\u00a0\u2026", "num_citations": "21\n", "authors": ["76"]}
{"title": "A qualitative analysis of preemptive conflict detection\n", "abstract": " Preemptive conflict detection is the act of detecting a potential merge conflict at an earlier stage than at check in time, and informing the involved developers about it. Researchers have proposed a number of tools and techniques to detect potential merge conflicts. However, a limited number of studies have been conducted so far to investigate whether the adoption of such tools and techniques brings benefits to developers. We have conducted a qualitative user study to understand how developers behave when dealing with merging and how this behavior changes when they are exposed to preemptive conflict detection. We report on the analysis of the data collected in the user study, as well as the discussion on the findings derived from the analysis.", "num_citations": "10\n", "authors": ["76"]}
{"title": "Miler-A Tool Infrastructure to Analyze Mailing Lists.\n", "abstract": " The information that can be used to analyze software systems is not limited to the raw source code, but also to any other artifact produced during its evolution. In our recent work we have focused on how archives of e-mails that concern a system can be exploited to enhance program comprehension.", "num_citations": "9\n", "authors": ["76"]}
{"title": "A qualitative user study on preemptive conflict detection\n", "abstract": " Preemptive conflict detection is the act of detecting a potential merge conflict at an earlier stage than at check in time, and informing the involved developers about it. Researchers have proposed a number of tools and techniques to detect potential merge conflicts. However, barely any study has been conducted to investigate whether the adoption of such tools and techniques brings benefits to developers. We have conducted a qualitative user study to understand how developers behave when dealing with merging and how this behavior changes when they are exposed to preemptive conflict detection. We report on the analysis of the data collected in the user study, and provide an in-depth discussion on the findings derived from it.", "num_citations": "6\n", "authors": ["76"]}
{"title": "Applying the evolution radar to postgresql\n", "abstract": " 4. RESULTSWe consider the three biggest modules with respect to the number of files: backend (673 files), include (394 files) and interfaces (84 files). For each module we build four Evolution Radars (using the module as the center of the radar) corresponding to the last four years of development of the module. Then we study the relationships of the target module with the five other biggest modules in the system with respect to the logical coupling information. For this study we both analyze the view and compute some measures characterizing the evolution of the couplings. In details we define:", "num_citations": "5\n", "authors": ["76"]}
{"title": "Object-focused environments revisited\n", "abstract": " Developers write Object-Oriented programs using numerous tools that come as part of integrated development environments (IDEs). We focus on the tool based interfaces of a dynamic class-based language named Smalltalk. Smalltalk IDEs have remained the same for almost 30 years now, despite that they have been found to induce problems related to navigation and the loss of context. The tools work on a textual representation of a program: the source code, which makes it more difficult to comprehend and manipulate the system under construction. In reaction to that, researchers have proposed building IDEs around other metaphors. We explore the desktop metaphor applied to Object-Oriented languages in the form of an object-focused environment, and provide a detailed description of our working prototype, named Gaucho. Our goal is to depart from IDEs with tool based interfaces and fancy text editors\u00a0\u2026", "num_citations": "3\n", "authors": ["76"]}
{"title": "Ronda: A fine grained collaborative development environment\n", "abstract": " Programmers seldom work in isolation: Software development is a social human activity, which therefore requires collaboration among the involved programmers. We argue that the main vehicles for programming\u2014the integrated development environments (IDEs)\u2014were designed without collaboration in mind. IDEs focus on a single viewpoint of the system, hence team members are aware of system changes only after the code is committed to the versioning system, which delays discussions that would otherwise prevent conflicts.             We propose a novel IDE, named Ronda, devised from the ground up, to fully embrace the collaborative nature of programming. Such an IDE allows a team of developers to take part in development sessions, both individually and in a group, within the same environment, promoting awareness and coordination, by tracking, broadcasting and visualizing fine-grained changes to\u00a0\u2026", "num_citations": "3\n", "authors": ["76"]}
{"title": "Commit 2.0: enriching commit comments with visualization\n", "abstract": " Software developers use commit comments to document changes and as a mean of communication in their team. However, the support given by IDEs is restricted with this respect, as they limit the users to use only text to document changes. In this paper we propose and implement an approach to enrich commit comments with software visualization: Commit 2.0 generates visualizations of the performed changes at different granularity levels, and let the user enrich them with annotations.", "num_citations": "3\n", "authors": ["76"]}
{"title": "On the evolution of source code and software defects\n", "abstract": " Software systems are subject to continuous changes to adapt to new and changing requirements. This phenomenon, known as software evolution, leads in the long term to software aging: The size and the complexity of systems increase, while their quality decreases. In this context, it is no wonder that software maintenance claims the most part of a software system's cost. The analysis of software evolution helps practitioners deal with the negative effects of software aging. With the advent of the Internet and the consequent widespread adoption of distributed development tools, such as software configuration management and issue tracking systems, a vast amount of valuable information concerning software evolution has become available. In the last two decades, researchers have focused on mining and analyzing this data, residing in various software repositories, to understand software evolution and support maintenance activities. However, most approaches target a specific maintenance task, and consider only one of the several facets of software evolution. Such approaches, and the infrastructures that implement them, cannot be extended to address different maintenance problems. In this dissertation, we propose an integrated view of software evolution that combines different evolutionary aspects. Our thesis is that an integrated and flexible approach supports an extensible set of software maintenance activities. To this aim, we present a meta-model that integrates two aspects of software evolution: source code and software defects. We implemented our approach in a framework that, by retrieving information from source code and defect\u00a0\u2026", "num_citations": "2\n", "authors": ["76"]}
{"title": "Churrasco: Supporting collaborative software evolution analysis\n", "abstract": " Analyzing the evolution of large and long lived software systems is a complex problem which requires extensive tool support due to the sheer amount of data that needs to be processed. In this paper we present Churrasco, a tool to support collaborative software evolution analysis. After describing the tool and its architecture, we provide a usage scenario of Churrasco on a large open source software system.", "num_citations": "2\n", "authors": ["76"]}
{"title": "Software Archaeology-Reconstructing the Evolution of Software Systems\n", "abstract": " Real world software systems require continuous change to satisfy new user requirements, adapt to new technologies and repair errors. As time goes by, software increase in size and complexity, and their design gradually decay unless work is done to maintain the systems. The problem of understanding the evolution of software has become a vital matter in today\u2019s software industry.In this thesis we propose an approach to tackle this problem, composed of two self-contained parts. The first is aimed at collecting historical information regarding the system, and storing it in a structured way. The second part exploits visual techniques to analyze both evolutionary and structural aspects of the software, at different granularity levels:", "num_citations": "1\n", "authors": ["76"]}