{"title": "Model-driven software development: technology, engineering, management\n", "abstract": " Because of its great potential, model-driven software development (MDSD) has received a lot of attention in the last few years [1], including: the Object Management Group\u2019s model-driven architecture [2], Microsoft\u2019s software factories [3], or plain code generation [4]. In their book, Stahl and Voelter advocate for a more pragmatic MDSD approach, which they call architecture-centric MDSD (AC-MDSD for short). Traditional software development presents some important problems related to individual productivity, software portability, product interoperability, and system maintenance [5]. The Object Management Group (OMG) MDSD initiative, model-driven architecture (MDA), resorts to platform-independent models that separate application functionality from the technology-specific code that implements it. MDA-related standards such as meta-object facility (MOF), which is OMG\u2019s foundation specification for modeling\u00a0\u2026", "num_citations": "2085\n", "authors": ["624"]}
{"title": "Product line implementation using aspect-oriented and model-driven software development\n", "abstract": " Software product line engineering aims to reduce development time, effort, cost, and complexity by taking advantage of the commonality within a portfolio of similar products. The effectiveness of a software product line approach directly depends on how well feature variability within the portfolio is implemented and managed throughout the development lifecycle, from early analysis through maintenance and evolution. This paper presents an approach that facilitates variability implementation, management and tracing by integrating model-driven and aspect-oriented software development. Features are separated in models and composed by aspect-oriented composition techniques on model level. Model transformations support the transition from problem to solution domain. Aspect-oriented techniques enable the explicit expression and modularization of variability on model, code, and template level The presented\u00a0\u2026", "num_citations": "341\n", "authors": ["624"]}
{"title": "DSL Engineering - Designing, Implementing and Using Domain-Specific Languages\n", "abstract": " DSL Engineering - Designing, implementing and using domain-specific languages \u2014 TU Delft Research Portal Skip to main navigation Skip to search Skip to main content TU Delft Research Portal Logo Help & FAQ Home Researchers Research Units Research output Activities Datasets Press / Media Prizes Projects Search by expertise, name or affiliation DSL Engineering - Designing, implementing and using domain-specific languages M. V\u00f6lter, S Benz, C Dietrich, B Engelmann, M Helander, LCL Kats, E Visser, GH Wachsmuth Software Engineering Research output: Book/Report \u203a Book \u203a Scientific Overview Original language English Place of Publication Stuttgart, Germany Publisher M Volter / DSLBook.org Number of pages 560 ISBN (Print) Niet aanwezig Publication status Published - 2013 Publication series Name Publisher M Volter / DSLBook.org Access to Document http://www.dslbook.org/ Cite this APA \u2026", "num_citations": "286\n", "authors": ["624"]}
{"title": "oAW xText: A framework for textual DSLs\n", "abstract": " Model-Driven Software Development [SV06] consists of two major aspects. The first one is processing models, ie checking their validity, transforming them into other models as well as generating code (and other textual artifacts) from models. The other aspect addresses the creation of models. Traditionally, the processing of models has received more attention from the MDSD community. Recently, the community has started addressing the model creation aspect (beyond using UML profiles\u2026). In the Eclipse world, the Graphical Modeling Framework is a tool that allows developers to easily define graphical editors for EMF-based meta models. Graphical editors are not enough, though. Many problems are better described with textual concrete syntaxes.", "num_citations": "246\n", "authors": ["624"]}
{"title": "The state of the art in language workbenches\n", "abstract": " Language workbenches are tools that provide high-level mechanisms for the implementation of (domain-specific) languages. Language workbenches are an active area of research that also receives many contributions from industry. To compare and discuss existing language workbenches, the annual Language Workbench Challenge was launched in 2011. Each year, participants are challenged to realize a given domain-specific language with their workbenches as a basis for discussion and comparison. In this paper, we describe the state of the art of language workbenches as observed in the previous editions of the Language Workbench Challenge. In particular, we capture the design space of language workbenches in a feature model and show where in this design space the participants of the 2013 Language Workbench Challenge reside. We compare these workbenches based on a DSL for\u00a0\u2026", "num_citations": "220\n", "authors": ["624"]}
{"title": "Pedagogical patterns: advice for educators\n", "abstract": " This collection of patterns proposes some successful techniques to assist with teaching and learning, especially of technical subjects. For professional educators, these patterns may seem obvious, even trivial, because they have used them so often. But for those newer to teaching, they offer a way to obtain the deep knowledge of experienced teachers. Patterns are not step-by-step recipes. Each of these offers a format and a process for transferring knowledge that can then be used by a variety of different teachers in many different ways. While most of the authors are involved in some aspect of computing and informatics, and so the examples are mostly drawn from those fields, much of the advice is general enough to be applied to other disciplines. The advice is not restricted to formal education, but has been used in various training scenarios as well.", "num_citations": "150\n", "authors": ["624"]}
{"title": "Language and IDE Modularization and Composition with MPS\n", "abstract": " Modularization and composition of languages and their IDEs is an important building block for working efficiently with domain-specific languages. Traditionally this has been a challenge because many grammar formalisms are not closed under composition, hence syntactic composition of languages can be challenging. Composing semantics can also be hard, at least in the general case. Finally, a lot of existing work does not consider IDEs for the composed languages. This paper illustrates how JetBrains MPS addresses language and IDE modularization and composition based on a projectional editor and modular type systems and transformations. The paper also classifies composition approaches according to the dependencies between the composed languages and whether syntactic composition is supported. Each of the approaches is illustrated with an extensive example implementation in MPS.", "num_citations": "133\n", "authors": ["624"]}
{"title": "XWeave: models and aspects in concert\n", "abstract": " Model-driven software development improves the way software is developed by capturing key features of the system in models which are developed and refined as the system is created. During the system's lifecycle models are combined and transformed between different levels of abstraction and viewpoints. Aspect-oriented techniques improve software development by providing modularization constructs for the encapsulation of crosscutting concerns. Existing research has already investigated many ways of combining the two paradigms. This paper contributes by presenting XWeave, a model weaver that supports weaving of both models and meta models. XWeave supports the composition of different architectural viewpoints and eases model evolution. Furthermore, the tool plays an important role in software product line engineering, as variable parts of architectural models can be woven according to some\u00a0\u2026", "num_citations": "119\n", "authors": ["624"]}
{"title": "Server Component Patterns: Component Infrastructures Illustrated with EJB\n", "abstract": " A detailed exploration of the basic patterns underlying today's component infrastructures. The latest addition to this best-selling series opens by providing an\" Alexandrian-style\" pattern language covering the patterns underlying EJB, COM+ and CCM. It addresses not only the underlying building blocks, but also how they interact and why they are used. The second part of the book provides more detail about how these building blocks are employed in EJB. In the final section the authors fully explore the benefits of building a system based on components.* Examples demonstrate how the 3 main component infrastructures EJB, CCM and COM+ compare* Provides a mix of principles and concrete examples with detailed UML diagrams and extensive source code* Forewords supplied by industry leaders: Clemens Syzperski and Frank Buschmann", "num_citations": "118\n", "authors": ["624"]}
{"title": "Generative programming\n", "abstract": " This report describes the results of a one-day workshop on Generative Programming (GP) at ECOOP\u201902. The goal of the workshop was to discuss the state-of-the-art of generative techniques, share experience, consolidate successful techniques, and identify open issues for future work. This report gives a summary of the workshop contributions, debates, and the identified future directions.", "num_citations": "113\n", "authors": ["624"]}
{"title": "mbeddr: an extensible C-based programming language and IDE for embedded systems\n", "abstract": " While the C programming language provides good support for writing efficient, low-level code, it is not adequate for defining higher-level abstractions relevant to embedded software. In this paper we present the mbeddr technology stack that supports extension of C with constructs adequate for embedded systems. In mbeddr, efficient low-level programs can be written using the well-known concepts from C. Higher-level domain-specific abstractions can be seamlessly integrated into C by means of modular language extension regarding syntax, type system, semantics and IDE. In the paper we show how language extension can address the challenges of embedded software development and report on our experience in building these extensions. We show that language workbenches deliver on the promise of significantly reducing the effort of language engineering and the construction of corresponding IDEs. mbeddr\u00a0\u2026", "num_citations": "92\n", "authors": ["624"]}
{"title": "Modellgetriebene Softwareentwicklung: Techniken, Engineering, Management\n", "abstract": " Dieses Buch stellt einen praxisorientierten Leitfaden f\u00fcr modellgetriebene Entwicklung dar und beleuchtet das Thema aus den Perspektiven Technik, Engineering und Management. Das Buch enth\u00e4lt zwei ausf\u00fchrliche Fallstudien sowie zahlreiche kleinere Beispiele. Im Anhang werden der MDA-und der QVT-Standard der OMG beschrieben. Zielgruppe sind Softwarearchitekten, Entwickler sowie technische Projektleiter. F\u00fcr die 2. Auflage wurden gro\u00dfe Teile des Buches \u00fcberarbeitet, um auf aktuelle Entwicklungen einzugehen; besonders ber\u00fccksichtigt wurde dabei der Einsatz der Eclipse-Plattform.", "num_citations": "85\n", "authors": ["624"]}
{"title": "Language modularity with the MPS language workbench\n", "abstract": " JetBrains MPS is a comprehensive environment for language engineering. New languages can be defined as standalone languages or as modular extensions of existing languages. Since MPS is a projectional editor, syntactic forms other than text are possible, including tables or mathematical symbols. This demo will show MPS based on mbeddr C, a novel approach for embedded software development that makes use of incremental language extension on the basis of C.", "num_citations": "84\n", "authors": ["624"]}
{"title": "Best practices for DSLs and model-driven development\n", "abstract": " In this article I describe best practices I learned over the years using DSLs for developing software. Before we start, let me outline the context. I exclusively cover external domain specific languages (DSLs), languages that are custom-defined to describe aspects of a software system. These languages can be textual or graphical, the models created with the language can be used as input for code generation, validation, simulation or interpretation. The DSLs can be intended for use by developers and architects (covering mainly architectural/technical aspects of software systems), but also by business users who are not classically considered \u201cdevelopers\u201d. I explicitly exclude internal/embedded DSLs such as the ones built with Ruby, Converge or Lisp. It also does not consider tools like MPS, where you typically build DSLs by extending a Turing-complete base language (Java, in case of MPS). The article is a highly condensed collection of best practices. For each of them, I could have written a couple of pages (in fact, many pages have been written on these and other best practices, see [1, 2, 3]). However, in spite of its brevity, this article reminds you of all the things you should consider when (thinking about) starting an MD* project.Some notes on terminology. I use MD* as a common moniker for MDD, MDSD, MDE, MDA, MIC, and all the other abbreviations for basically the same approach. Models can be processed in many ways. They can be validated, transformed, generated into code, or interpreted. I use \u201cmodel processing\u201d(and the noun,\u201cmodel processor\u201d) to refer to all of these with a single term. I use the term \u201cmetaware\u201d to mean all the artifacts\u00a0\u2026", "num_citations": "80\n", "authors": ["624"]}
{"title": "Aspect-oriented model-driven software product line engineering\n", "abstract": " Software product line engineering aims to reduce development time, effort, cost, and complexity by taking advantage of the commonality within a portfolio of similar products. The effectiveness of a software product line approach directly depends on how well feature variability within the portfolio is implemented and managed throughout the development lifecycle, from early analysis through maintenance and evolution. This article presents an approach that facilitates variability implementation, management, and tracing by integrating model-driven and aspect-oriented software development. Features are separated in models and composed of aspect-oriented composition techniques on model level. Model transformations support the transition from problem to solution space models. Aspect-oriented techniques enable the explicit expression and modularization of variability on model, template, and code level\u00a0\u2026", "num_citations": "72\n", "authors": ["624"]}
{"title": "Language modularization and composition with projectional language workbenches illustrated with MPS\n", "abstract": " The language community has had a discussion about different styles of languages for a long time: big languages with many specific concepts (ABAP, Cobol), or small languages with few, but very powerful and orthogonal concepts (Lisp, Smalltalk)? With the advent of projectional language workbenches a new class of language becomes possible that can combine the best of both approaches: modular languages. Modular Languages use a relatively small general-purpose core and can be extended with more (domain specific) concepts as needed. Projectional language workbenches support this approach by alleviating the problems of language composition for parser-based languages by not using grammars and parsers at all. They also enable IDE extension as a side benefit. In this paper we argue why modular languages are useful and illustrate the idea with a couple of small examples. We also present a number of language composition techniques for JetBrains MPS, an open source projectional language workbench.", "num_citations": "70\n", "authors": ["624"]}
{"title": "Inca: A dsl for the definition of incremental program analyses\n", "abstract": " Program analyses support software developers, for example, through error detection, code-quality assurance, and by enabling compiler optimizations and refactorings. To provide real-time feedback to developers within IDEs, an analysis must run efficiently even if the analyzed code base is large.", "num_citations": "63\n", "authors": ["624"]}
{"title": "Handling variability in model transformations and generators\n", "abstract": " Software product line engineering aims to reduce development time, effort, cost, and complexity by taking advantage of the commonality within a portfolio of similar products. The effectiveness of a software product line approach directly depends on how well feature variability within the portfolio is implemented and managed throughout the development lifecycle, from early analysis through maintenance and evolution. Using DSLs and AO to implement product lines can yield significant advantages, since the variability can be implemented on a higher level of abstraction, in less detailed models. This paper illustrates how variability can be implemented in model-to-model transformations and code generators using aspect-oriented techniques. These techniques are important ingredients for the aspectoriented model-driven product line engineering approach presented in [13].", "num_citations": "59\n", "authors": ["624"]}
{"title": "mbeddr: Instantiating a language workbench in the embedded software domain\n", "abstract": " Tools can boost software developer productivity, but building custom tools is prohibitively expensive, especially for small organizations. For example, embedded programmers often have to use low-level C with limited IDE support, and integrated into an off-the-shelf tool chain in an ad-hoc way.               To address these challenges, we have built mbeddr, an extensible language and IDE for embedded software development based on C. mbeddr is a large-scale instantiation of the Jetbrains MPS language workbench. Exploiting its capabilities for language modularization and composition, projectional editing and multi-stage transformation, mbeddr is an open and modular framework that lets third parties add extensions to C with minimal effort and without invasive changes. End users can combine extensions in programs as needed.               To illustrate the approach, in this paper we discuss mbeddr\u2019s support\u00a0\u2026", "num_citations": "58\n", "authors": ["624"]}
{"title": "From programming to modeling-and back again\n", "abstract": " The authors describe an issue that they think is extremely important: the relationship between applications and solutions in the software engineering and information systems fields. In particular, they believe the fields desperately need a taxonomy of application domains, a taxonomy of solution approaches, and a mapping between the two. This article has a Web extra that offers an interview with one of the article's authors, Robert L. Glass, about the \"dark side\" of this topic.", "num_citations": "56\n", "authors": ["624"]}
{"title": "Expressing feature-based variability in structural models\n", "abstract": " Software product line engineering aims at reducing development time, effort, cost, and complexity by tak-ing advantage of the commonality within a portfolio of similar products. The effectiveness of a software prod-uct line approach directly depends on how well feature variability within the portfolio is implemented and ma-naged throughout the development lifecycle, from early analysis through maintenance and evolution. This pa-per presents a tool-supported approach that improves variability management and tracing by providing means to express feature-based variability on model level. Features are separated in models and automati-cally composed. The approach supports both positive variability, ie adding optional parts to a model, as well as negative variability, ie removing parts from a model. Tools are provided that implement the pre-sented concepts. The approach is illustrated with a case study of a home automation system. 1", "num_citations": "49\n", "authors": ["624"]}
{"title": "Supporting Diverse Notations in MPS'Projectional Editor.\n", "abstract": " To be able to build effective DSLs, these DSLs must not just use language concepts that are aligned with their respective domain, but also use notations that correspond closely to established domain notations\u2013and those are often not purely textual or graphical. The underlying language workbench must support these notations, and combining different notations in a single editor must be supported as well in order to support the coherent definitions of systems that use several DSLs. In this paper we provide an overview over the notations supported by JetBrains MPS. MPS is a language workbench that uses a projectional editor, which, by its very nature, can deal with many different notational styles, including text, prose, math tables and graphics. The various supported notations are illustrated with examples from real-world systems.", "num_citations": "45\n", "authors": ["624"]}
{"title": "Learning to teach and Learning to learn\n", "abstract": " Pedagogical1 Patterns capture successful experiences of learning and teaching OT, from industry or academia, in a homogeneous, easily accessible format. The Pedagogical Patterns Project started during OOPSLA'95, made its first public appearances at ECOOP'96 and then TOOLS USA'96; the first workshop was held at OOPSLA'96. Many sessions have been held at numerous conferences in America and Europe and more then 50 teaching techniques written in pattern format have been collected. The patterns themselves have proved to be useful, and have helped educators to explore and exchange their teaching experiences.", "num_citations": "44\n", "authors": ["624"]}
{"title": "Introduction to openArchitectureWare 4.1. 2\n", "abstract": " This paper introduces openArchitectureWare 4.1. x based on a common, predefined example. The example has been defined as part of the MDD TIF 07. The idea of this workshop is to showcase various MDD tools and compare their approaches to solving the same example problem. The paper describes using the openArchitectureWare tool chain for defining meta models, code generator, model transformations as well as for building graphical and textual editors.", "num_citations": "42\n", "authors": ["624"]}
{"title": "JetBrains MPS as a tool for extending Java\n", "abstract": " JetBrains MPS is an integrated environment for language engineering. It allows language designers to define new programming languages, both general-purpose and domain-specific, either as standalone entities or as modular extensions of already existing ones. Since MPS leverages the concept of projectional editing, non-textual and non-parseable syntactic forms are possible, including tables or mathematical symbols. This tool paper introduces MPS and shows how its novel approach can be applied to Java development. Special attention will be paid to the ability to modularize and compose languages.", "num_citations": "41\n", "authors": ["624"]}
{"title": "Generic tools, specific languages\n", "abstract": " Adapting tools to a particular domain is expensive, and the adaptation is often not very deep. To address this challenge, Generic Tools, Specific Languages shifts the focus from building and adapting tools (windows, buttons, algorithms) to building and adapting languages to a domain. The thesis applies the approach to embedded software development: mbeddr is an extensible set of integrated languages for embedded software development built with JetBrains MPS language workbench. The evaluation of mbeddr suggests that it is a productive tool for embedded software development. The evaluation of the development of mbeddr itself suggests that MPS is a suitable platform for Generic Tools, Specific Languages, and that the approach in general is worthwhile.", "num_citations": "35\n", "authors": ["624"]}
{"title": "A family of languages for architecture description\n", "abstract": " In this paper I describe how product line engineering and variant management can be applied to domain-specific languages. I introduce concepts and a tool prototype for describing a family of DSLs used for architecture description. I want to make two points in this paper: First, I want to introduce the idea of product line engineering for domain-specific languages, and second, I want to illustrate why and how this approach is especially useful for DSLs that describe software architectures. The paper is based on practical experience and not on academic research.", "num_citations": "31\n", "authors": ["624"]}
{"title": "Container-component model and XML in ALMA ACS\n", "abstract": " ALMA software, from high-level data flow applications down to instrument control, is built using the ACS framework. To meet the challenges of developing distributed software in distributed teams, ACS offers a container/component model that integrates the use of XML transfer objects. ACS containers are built on top of CORBA and are available for C++, Java, and Python, so that ALMA software can be written as components in any of these languages. The containers perform technical aspects of the software system, while components can focus on the implementation of functional requirements.  Like Web services, components can use XML to exchange structured data by value. For Java components, the container seamlessly integrates the use of XML binding classes, which are Java classes that encapsulate access to XML data through type-safe methods. Binding classes are generated from XML schemas, allowing\u00a0\u2026", "num_citations": "31\n", "authors": ["624"]}
{"title": "Implementing modular domain specific languages and analyses\n", "abstract": " Domain specific languages allow users to directly express domain concepts in their programs and thereby eliminate the accidental complexity resulting from implementation details irrelevant to the domain. Cleaner programs, written in DSLs are much easier to analyze formally. However, domain specific analyses need to be implemented over and over again for each new domain specific language. In this paper we show that the use of language engineering techniques for modularizing languages can drastically improve on this situation. Language fragments (aka. language modules) together with a set of analyses defined for them can be reused between different DSLs, making the implementation of analyses significantly easier. This paper presents our approach for using the Meta-Programming System to implement domain specific languages and analyses both as extensions of C and in the domain of intelligent\u00a0\u2026", "num_citations": "27\n", "authors": ["624"]}
{"title": "Language engineering as an enabler for incrementally defined formal analyses\n", "abstract": " There is a big semantic gap between today's general purpose programming languages on the one hand and the input languages of formal verification tools on the other hand. This makes integrating formal analyses into the daily development practice artificially complex. In this paper we advocate that the use of language engineering techniques can substantially improve this situation along three dimensions. First, more abstract and thus more analyzable domain specific languages can be defined, avoiding the need for abstraction recovery from programs written in general purpose languages. Second, restrictions on the use of existing languages can be imposed and thereby more analyzable code can be obtained and analyses can be incrementally defined. Third, by expressing verification conditions and the verification results at the domain level, they are easier to define and the results of analyses are easier to\u00a0\u2026", "num_citations": "27\n", "authors": ["624"]}
{"title": "Using language workbenches and domain-specific languages for safety-critical software development\n", "abstract": " Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also\u00a0\u2026", "num_citations": "26\n", "authors": ["624"]}
{"title": "Embedded software development with projectional language workbenches\n", "abstract": " This paper describes a novel approach to embedded software development. Instead of using a combination of C code and modeling tools, we propose an approach where modeling and programming is unified using projectional language workbenches. These allow the incremental, domain-specific extension of C and a seamless integration between the various concerns of an embedded system. The paper does not propose specific extensions to C in the hope that everybody will use them; rather, the paper illustrates the benefits of domain specific extension using projectional editors. In the paper we describe the problems with the traditional approach to embedded software development and how the proposed approach can solve them. The main part of the paper describes our modular embedded language, a proof-of-concept implementation of the approach based on JetBrains MPS. We implemented a\u00a0\u2026", "num_citations": "26\n", "authors": ["624"]}
{"title": "Language and IDE modularization, extension and composition with MPS\n", "abstract": " Abstract Language modularization, extension and composition is an important building block for working efficiently with DSLs. Historically, this has been a challenge because many grammar formalisms are not closed under composition, hence syntactic composition of languages is challenging. Composing static and dynamic semantics can also be hard, at least in the general case. Finally, a lot of existing work does not consider IDEs for the composed and extended languages. In this paper, I will show how the projectional language workbench JetBrains MPS solves most of these issues in a practically usable way. The main part of the paper is an extensive example that shows the various kinds of extension and modularization. The last section contains an evaluation that identifies the strong and weak aspects of modularization, composition and extension in MPS, and suggests a couple of improvements.", "num_citations": "25\n", "authors": ["624"]}
{"title": "Server-side components-a pattern language\n", "abstract": " CiNii \u8ad6\u6587 - Server-Side Components-A Pattern Language CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831 \u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f \u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005 \u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 Server-Side Components-A Pattern Language VOLTER M. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 VOLTER M. \u53ce\u9332\u520a\u884c\u7269 proceedings of EuroPLoP '2000 proceedings of EuroPLoP '2000, 2000 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u6587\u66f8\u9593\u985e\u4f3c\u5ea6\u306b\u3088\u308b\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30d1\u30bf\u30fc\u30f3\u9593\u95a2\u9023\u5206\u6790\u3068\u8907\u5408\u95a2\u9023\u306e\u5c0e\u51fa \u4e45\u4fdd \u6df3\u4eba , \u9df2\u5d0e \u5f18 \u5b9c , \u9ad8\u9808 \u6df3\u5b8f , \u6df1\u6fa4 \u826f\u5f70 \u60c5\u5831\u51e6\u7406\u5b66\u4f1a\u7814\u7a76\u5831\u544a. SE,\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u5de5\u5b66\u7814\u7a76\u4f1a\u5831\u544a 154, 65-72, 2006-11-27 \u53c2\u8003\u6587\u732e16\u4ef6 \u88ab\u5f15\u7528\u6587\u732e1\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10018470563 \u8cc7\u6599\u7a2e\u5225 \u4f1a\u8b70\u8cc7\u6599 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u66f8\u304d\u51fa\u3057 EndNote\u306b\u66f8\u304d\u51fa\u3057 \u2026", "num_citations": "25\n", "authors": ["624"]}
{"title": "Incrementalizing lattice-based program analyses in Datalog\n", "abstract": " Program analyses detect errors in code, but when code changes frequently as in an IDE, repeated re-analysis from-scratch is unnecessary: It leads to poor performance unless we give up on precision and recall. Incremental program analysis promises to deliver fast feedback without giving up on precision or recall by deriving a new analysis result from the previous one. However, Datalog and other existing frameworks for incremental program analysis are limited in expressive power: They only support the powerset lattice as representation of analysis results, whereas many practically relevant analyses require custom lattices and aggregation over lattice values. To this end, we present a novel algorithm called DRedL that supports incremental maintenance of recursive lattice-value aggregation in Datalog. The key insight of DRedL is to dynamically recognize increasing replacements of old lattice values by new ones\u00a0\u2026", "num_citations": "24\n", "authors": ["624"]}
{"title": "Projecting a modular future\n", "abstract": " Two innovations are enhancing programming languages' capabilities. First, modularity lets you combine independently developed languages without changing their respective definitions. A language is no longer a fixed quantity; you can extend it with domain-specific constructs as needed. Second, projectional editing lets you build editors and IDEs that don't require parsers. Such editors and IDEs support a range of tightly integrated notations, including textual, symbolic, tabular, and graphical notations. In addition, by avoiding parsers, they avoid grammar composition's well-known limitations. Three examples illustrate how these two innovations affect programming-language design. A set of modular extensions of C for embedded programming enables efficient code generation and formal analysis. A language for requirements engineering flexibly combines structured and unstructured (prose) data. Finally, a\u00a0\u2026", "num_citations": "23\n", "authors": ["624"]}
{"title": "Architecture as language\n", "abstract": " In this paper, software architects can develop domain specific languages that express the desired architecture during the definition process and use them to describe systems based on the architecture.", "num_citations": "23\n", "authors": ["624"]}
{"title": "Model driven software development in the context of embedded component infrastructures\n", "abstract": " In this chapter we motivate the need for an infrastructure platform for embedded software, supporting the development of reusable systems. Our solution is based on a component infrastructure that is implemented using model-driven software development (MDSD) techniques. This approach allows us to achieve the goal of re-usability while still providing an efficient system, tailored for the specific embedded hardware and operating system.               This chapter explains the principles of our approach and introduces model-driven software development. It illustrates the concepts by presenting an example of how to model and specify the embedded application (a simple weather station), and how to generate supporting component middleware infrastructure from these models.", "num_citations": "21\n", "authors": ["624"]}
{"title": "A Taxonomy of Components.\n", "abstract": " The notion of a component is not really well defined for practical purposes. This is, because the term is used to denote many different things. So, instead of defining the term once and for all, we present a taxonomy that shows the different features of a component.", "num_citations": "21\n", "authors": ["624"]}
{"title": "Requirements as First-Class Citizens: Integrating Requirements Directly with Implementation Artifacts\n", "abstract": " Requirements often play second fiddle in software development projects. The tools for managing requirements are only loosely integrated with the tools used for implementing the system. Furthermore, while implementation tools are based on a rich syntax and wellunderstood semantics (the programing language itself), requirements tools are often only aware of weakly structured text. This leads to accidental complexity in integrating requirements with each other and with implementation artifacts. In this paper we describe an approach based on language engineering technologies that results in integrated development environments where both requirements and the code are treated as first class entities. Parts of requirements can be used directly as the implementation, and they are managed with the same tools that are used for the implementation. The approach is illustrated by an extension of the mbeddr system, a comprehensive IDE for embedded software development, with functionality for managing requirements.", "num_citations": "20\n", "authors": ["624"]}
{"title": "Approaches and tools for implementing type systems in xtext\n", "abstract": " With the Xtext framework, building domain specific languages (DSLs) integrated into the Eclipse IDE has become increasingly popular and viable even for non-trivial domains. However, sophisticated DSLs may require advanced type checking capabilities, since they usually include expressions, types and the notion of type conformance. In this paper we compare a number of approaches and frameworks for implementing type systems for Xtext languages regarding flexibility, required effort and usability. We use a common case study to illustrate the trade-offs between the various tools.", "num_citations": "20\n", "authors": ["624"]}
{"title": "Automated testing of DSL implementations\u2014experiences from building mbeddr\n", "abstract": " Domain-specific languages promise to improve productivity and quality of software development by providing problem-adequate abstractions to developers. Projectional language workbenches, in turn, allow the definition of modular and extensible domain specific languages, generators, and development environments. While recent advances in language engineering have enabled the definition of DSLs and tooling in a modular and cost-effective way, the quality assurance of their implementation is still challenging. In this paper, we discuss our work on testing different aspects of the implementation of domain specific languages and associated tools, and present several approaches to increase the automation of language testing. We illustrate these approaches with the Jetbrains MPS language workbench and our experience with testing mbeddr, a set of domain specific languages and tools on top of C\u00a0\u2026", "num_citations": "19\n", "authors": ["624"]}
{"title": "Automated domain-specific C verification with mbeddr\n", "abstract": " When verifying C code, two major problems must be addressed. One is the specification of the verified systems properties, the other one is the construction of the verification environment. Neither C itself, nor existing C verification tools, offer the means to efficiently specify application domain-level properties and environments for verification. These two shortcomings hamper the usability of C verification, and limit its adoption in practice. In this paper we introduce an approach that addresses both problems and results in user-friendly and practically usable C verification. The novelty of the approach is the combination of domain-specific language engineering and C verification. We apply the approach in the domain of state-based software, using mbeddr and CBMC. We validate the implementation with an example from the Pacemaker Challenge, developing a functionally verified, lightweight, and deployable cardiac\u00a0\u2026", "num_citations": "19\n", "authors": ["624"]}
{"title": "Using Aspects to Model Product Line Variability.\n", "abstract": " The often crosscutting characteristics of feature implementations make effective variability management a predominant engineering challenge in software product line engineering. Features can often hardly be modularized but are spread over several other modules. In this paper we propose XWeave, an approach that facilitates variability implementation, management, and tracing by using aspects to model product line variability. In our approach we use models to describe product lines. Aspect-oriented techniques are used to help implementing the variants in the models. We argue that due to the fact that models are more abstract and hence less detailed than code, variability on model level is inherently less scattered and therefore simpler to manage than traditional variability management on code level.", "num_citations": "19\n", "authors": ["624"]}
{"title": "Extensible debugger framework for extensible languages\n", "abstract": " Language extension enables integration of new language constructs without invasive changes to a base language (e. g., C). Such extensions help to build more reliable software by using proper domain-specific abstractions. Language workbenches significantly reduce the effort for building such extensible languages by synthesizing a fully-fledged IDE from language definitions. However, in contemporary tools, this synthesis does not include interactive debugging for programs written with the base language or its extensions. This paper describes a generic framework for extensible debuggers that enables debugging of the language extensions by defining mappings between the base language and the language extensions. The architecture is designed for extensibility, so debug support for future extensions can be contributed with little effort. We show an implementation of our approach for mbeddr, which\u00a0\u2026", "num_citations": "18\n", "authors": ["624"]}
{"title": "Implementing feature variability for models and code with projectional language workbenches\n", "abstract": " Product line engineering deals with managing and implementing the variability among a set of related products. We distinguish between two kinds of variability: configuration and customization. Customization variability can be described using programming language code or creative construction DSLs, whereas configuration variability is described using configuration based approaches, such as feature models. Many product lines have both kinds of variability, and they need to be integrated efficiently. This paper describes an approach for product line engineering using projectional language workbenches. These represent code and models with the same fundamental technology, enabling the mixing of models and code. They make the tight integration between several domain-specific languages possible and simple. Since they can store arbitrary information in models, it is possible to overlay configuration\u00a0\u2026", "num_citations": "17\n", "authors": ["624"]}
{"title": "Guest Editors' Introduction: Software Patterns\n", "abstract": " Patterns have become part of the software development mainstream. They're available for all phases of the development process, including analysis, documentation, design, testing, and configuration management, to name a few. In addition to documenting the current status of software patterns, this special issue will reflect critically on and discuss the achievements of the pattern community. This article is part of a special issue on software patterns.", "num_citations": "17\n", "authors": ["624"]}
{"title": "Fusing modeling and programming into language-oriented programming\n", "abstract": " Modeling in general is of course different from programming (think: climate models). However, when we consider the role of models in the context of \u201cmodel-driven\u201d, i.e., when they are used to automatically construct software, it is much less clear that modeling is different from programming. In this paper, I argue that the two are conceptually indistinguishable, even though in practice they traditionally emphasize different aspects of the (conceptually indistinguishable) common approach. The paper discusses and illustrates language-oriented programming, the approach to {modeling|programming} we have successfully used over the last 7 years to build a range of innovative systems in domains such as insurance, healthcare, tax, engineering and consumer electronics. It relies on domain-specific languages, modular language extension, mixed notations, and in particular, the Jetbrains MPS language workbench.", "num_citations": "15\n", "authors": ["624"]}
{"title": "Integrating Prose as First-Class Citizens with Models and Code.\n", "abstract": " In programming and modeling we strive to express structures and behaviors as formally as possible to support tool-based processing. However, some aspects of systems cannot be described in a way that is suitable for tool-based consistency checking and analysis. Examples include code comments, requirements and software design documents. Because they can only be analyzed manually, they are often out-of-sync with the code and do not reflect the current state of the system. This paper demonstrates how language engineering based on language workbenches can help solve this problem by seamlessly mixing prose and program nodes. These program nodes can range from simple references to other elements over variables and formulas to embedded program fragments. The paper briefly explains the language engineering technology behind the approach as well as a number of prose-code integrated languages that are part of mbeddr, an integrated language and tool stack for embedded software engineering.", "num_citations": "14\n", "authors": ["624"]}
{"title": "The design, evolution, and use of kernelf\n", "abstract": " KernelF is a functional language built on top of MPS. It is designed to be highly extensible and embeddable in order to support its use at the core of domain-specific languages, realising an approach we sometimes call Funclerative Programming. \u201cFunclerative\u201d is of course a mash-up of \u201cfunctional\u201d and \u201cdeclarative\u201d and refers to the idea of using functional programming in the small, and declarative language constructs for the larger-scale, often domain-specific, structures in a program. We have used KernelF in a wide range of languages including health and medicine, insurance contract definition, security analysis, salary calculations, smart contracts and language-definition. In this paper, I illustrate the evolution of KernelF over the last two years. I discuss requirements on the language, and how those drove design decisions. I showcase a couple of the DSLs we built on top of KernelF to explain how MPS\u00a0\u2026", "num_citations": "13\n", "authors": ["624"]}
{"title": "Robust projectional editing\n", "abstract": " While contemporary projectional editors make sure that the edited programs conform to the programming language's metamodel, they do not enforce that they are also well-formed, that is, that they obey the well-formedness rules defined for the language. We show how, based on a constraint-based capture of well-formedness, projectional editors can be empowered to enforce well-formedness in much the same way they enforce conformance with the metamodel. The resulting robust edits may be more complex than ordinary, well-formedness breaking edits, and hence may require more user involvement; yet, maintaining well-formedness at all times ensures that necessary corrections of a program are linked to the edit that necessitated them, and that the projectional editor's services are never compromised by inconsistent programs. Robust projectional editing is not a straitjacket, however: If a programmer prefers to\u00a0\u2026", "num_citations": "13\n", "authors": ["624"]}
{"title": "Using language engineering to lift languages and analyses at the domain level\n", "abstract": " Developers who use C model checkers have to overcome three usability challenges: First, it is difficult to express application level properties as C-level verification conditions, due to the abstraction gap. Second, without advanced IDE support, it is difficult to interpret the counterexamples produced by the model checker and understand what went wrong in terms of application level properties. Third, most C model checkers support only a subset of C and it is easy for developers to inadvertently use C constructs outside this subset. In this paper we report on our preliminary experience with using the MPS language workbench to integrate the CBMC model checker with a set of domain-specific extensions of C for developing embedded software. Higher level language constructs such as components and decision tables makes it easier for end users to bridge the abstraction gap, to write verification conditions and\u00a0\u2026", "num_citations": "13\n", "authors": ["624"]}
{"title": "Xpand documentation\n", "abstract": " The Xpand generator framework provides textual languages, that are useful in different contexts in the MDSD process (eg validation, metamodel extensions, code generation, model transformation). Each language (Check, Xtend, and Xpand) is built upon a common expression language and type system. Therefore, they can operate on the same models, metamodels and meta-metamodels and you do not need to learn the syntax again and again, because it is always the same.", "num_citations": "12\n", "authors": ["624"]}
{"title": "Hope, Belief and Wizardry Three different perspectives on project management\n", "abstract": " Normally, I\u2019m not too much into project management. However, over the last couple of years, I have come across several projects that use hope, belief and wizardry as their primary management tools. You will probably not have heard about these specific projects\u2013and you probably never will. They have gone out", "num_citations": "12\n", "authors": ["624"]}
{"title": "Md*/dsl best practices update march 2011\n", "abstract": " I have written this article about best practices in Model Driven Development and Domain Specific Languages during 2008. This is already 2.5 to 3 years ago, a long time in anything relating to computers. This update looks at the original best practices paper and comments on what has changed in the last 2.5 years. My comments are highlighted, so if you have read the original paper, you can quickly glance over the paper to see my comments.Most of my comments, and my own evolution in thinking about DSLs and model driven development, has been influenced by MPS (as well as, to some extent, by the Intentional Domain Workbench and Spoofax). Modular languages are possible, languages can be extended, and the distinction between modeling and programming goes away almost completely. This has far-reaching consequences for how model driven development can and should be approached. You may want to read the following paper for a full discussion of this idea:", "num_citations": "11\n", "authors": ["624"]}
{"title": "An extensible framework for variable-precision data-flow analyses in MPS\n", "abstract": " Data-flow analyses are used as part of many software engineering tasks: they are the foundations of program under-standing, refactorings and optimized code generation. Similar to general-purpose languages (GPLs), state-of-the-art domain-specific languages (DSLs) also require sophisticated data-flow analyses. However, as a consequence of the different economies of DSL development and their typically relatively fast evolution, the effort for developing and evolving such analyses must be lowered compared to GPLs. This tension can be resolved with dedicated support for data-flow analyses in language workbenches.", "num_citations": "9\n", "authors": ["624"]}
{"title": "Preliminary experience of using mbeddr for developing embedded software\n", "abstract": " Over the last few years, and as part of the LW-ES KMU Innovativ research project, a team of developers at itemis and fortiss have developed the mbeddr system, which relies on language engineering to build a new class of environment for embedded software development. In essence, mbeddr consists of a set of extensions to C (such as state machines, units, interfaces and components) as well as a few additional languages for requirements engineering, documentation and product line engineering. mbeddr is still new, but a number of systems have been built with mbeddr. In this paper I summarize some preliminary experience with using mbeddr\u2019s default extensions to build embedded systems based on a set of case studies. The ability for mbeddr to be extended is not discussed in this paper, even though this has proven very useful as well.", "num_citations": "9\n", "authors": ["624"]}
{"title": "Using domain specific languages for product line engineering\n", "abstract": " Domain specific languages together with code generation or interpreters (aka model driven development) are becoming more and more important. Since there is a certain overhead involved in building languages and processors, this approach is especially useful in environments where a specific set of languages and generators can be reused many times. Product lines are such an environment. Consequently, the use of DSLs for SPLE is becoming more relevant.", "num_citations": "9\n", "authors": ["624"]}
{"title": "Integrating model-driven development and software product line engineering\n", "abstract": " Software product line engineering aims to reduce development time, effort, cost, and complexity by taking advantage of the commonality within a portfolio of similar products. The effectiveness of a software product line approach directly depends on how well feature variability within the portfolio is implemented and managed throughout the development lifecycle, from early analysis through maintenance and evolution. We present an approach that facilitates variability implementation, management, and tracing by integrating modeldriven development and software product line engineering. Appropriate tooling is the basis for a successful application of the new concepts. This paper illustrates how pure:: variants and openArchitectureWare are integrated to enable efficient model-driven variant management. 1", "num_citations": "9\n", "authors": ["624"]}
{"title": "Metamodellierung\n", "abstract": " Bei dieser Art der Erweiterung wird das Metamodell der UML erweitert. Dabei verwenden wir (wie immer bei der Modellierung) die Sprachmittel des n\u00e4chsth\u00f6heren Metalevels, hier also M3, MOF. Eine solche Erweiterung kann also nur im Rahmen von Tools erfolgen, die ein explizites, auf der MOF basierendes Metamodell besitzen.", "num_citations": "9\n", "authors": ["624"]}
{"title": "A generative component infrastructure for embedded systems\n", "abstract": " Component infrastructures such as Enterprise JavaBeans [27], Micorosoft\u2019s COM+[14] and the upcoming CORBA Components [17] have become the de-facto standard for enterprise applications. Reasons for this success are the clean separation of technical and functional concerns, COTS containers (applications servers), and the resulting well-defined programming model and standardization. It is desirable to have these same benefits for embedded application development. However, application servers as they are today cannot be deployed on embedded devices because of the limited resources regarding computing power, memory, etc. on the device.", "num_citations": "9\n", "authors": ["624"]}
{"title": "Jenerator-generative programming for java\n", "abstract": " Generative Programming aims at creating software components, which, after suitable configuration, generate systems or other components. This allows to build families of products (or product lines) out of which several concrete systems can be created. Compared to frameworks, this has the advantage that the configuration takes place before runtime, enhancing runtime performance. This paper introduces a tool called Jenerator, an extensible code generator for Java. By using its extension mechanisms, complete high-level, product-line-specific generators can be build, enabling the automated creation of systems on source-code basis.", "num_citations": "8\n", "authors": ["624"]}
{"title": "Extensible debuggers for extensible languages\n", "abstract": " Language extension enables integration of new language constructs without invasive changes to a base language (eg, C). Such extensions help to build more reliable software by using proper domain-specific abstractions. Language workbenches significantly reduce the effort for building such extensible languages by synthesizing a fully-fledged IDE from language definitions. However, in contemporary tools, this synthesis does not include interactive debugging for programs written with the base language or its extensions. This paper describes a generic framework for extensible debuggers that enables debugging of the language extensions by definig mappings between the base language and the language extensions. The architecture is designed for extensibility, so debug support for future extensions can be contributed with little effort. We show an implementation of our approach for mbeddr, which is an extensible version of the C programming language. We also discuss the debugger implementation for non-trivial C extensions such as components. Finally, the paper discusses the extent to which the approach can be used with other base languages, debugger backends and language workbenches.", "num_citations": "7\n", "authors": ["624"]}
{"title": "Plug-Ins\u2013applikationsspezifische Komponenten\n", "abstract": " Die Architektur eines Systems ist die technische Antwort auf die Komplexit\u00e4t des Problems, kombiniert mit dem Versuch, durch die L\u00f6sung keine zus\u00e4tzliche Komplexit\u00e4t zu erschaffen. Inzwischen haben wir uns wieder daran erinnern lassen m\u00fcssen, dass Komponentenarchitekturen nicht trivial sind, und falsch eingesetzt sogar eigene Probleme erschaffen. Komplexe Anwendungen und Systeme entstehen nicht von selbst aus Komponenten, und jegliche Integration ist mit Reibungsverlusten verbunden. Nichts kann die Kunst der Architektur ersetzen [Buschmann 2003]. Besonders in technischen", "num_citations": "7\n", "authors": ["624"]}
{"title": "Modeling and optimizing automotive electric/electronic (e/e) architectures: Towards making clafer accessible to practitioners\n", "abstract": " Modern automotive electric/electronic (E/E) architectures are growing to the point where architects can no longer manually predict the effects of their design decisions. Thus, in addition to applying an architecture reference model to decompose their architectures, they also require tools for synthesizing and evaluating candidate architectures during the design process. Clafer is a modeling language, which has been used to model variable multi-layer, multi-perspective automotive system architectures according to an architecture reference model. Clafer tools allow architects to synthesize optimal candidates and evaluate effects of their design decisions. However, since Clafer is a general-purpose structural modeling language, it does not help the architects in building models conforming to the given architecture reference model. In this paper, we present an E/E architecture domain-specific language (DSL\u00a0\u2026", "num_citations": "6\n", "authors": ["624"]}
{"title": "Mbeddr: Extensible languages for embedded software development\n", "abstract": " In this industrial presentation we will demonstrate mbeddr, an extensible set of integrated languages for embedded software development. After discussing the context of the talk, we will give details about the mbeddr architecture, which relies on the MPS language workbench. Then we will elaborate on the extension modules and show how they fit with safety-critical development processes. Finally we will point out how the existing languages can be extended by the user by giving some real-world examples, including a language construct that could have prevented the Apple'goto fail'bug as well as mathematical notations.", "num_citations": "6\n", "authors": ["624"]}
{"title": "Feedback-aware requirements documents for smart devices\n", "abstract": " [Context/ Motivation] A smart device is a software-intensive system that operates autonomously and interacts to some degree with other systems over wireless connections. Such systems are often faced with uncertainty in the environment. Runtime representations of requirements have recently gained more interested to deal with this challenge and the term requirements at runtime has been established. Runtime representations of requirements support reasoning about the requirements at runtime and adapting the configuration of a system according to changes in the environment. [Questions/Problems] The research question is how the results of runtime monitoring of requirements and the system\u2019s decisions about changes in the configuration are communicated back to the requirements engineer to better understand the environment. There is a gap between the written requirements document and\u00a0\u2026", "num_citations": "6\n", "authors": ["624"]}
{"title": "Xtext/TS-a typesystem framwork for Xtext\n", "abstract": " Starting with version 1.0, it has become absolutely feasible to build complex languages of Xtext. One aspect of a complex language is usually support for expressions. Expressions require recursive grammar definitions, for which assignment actions in Xtext provide reasonable support. However, once you have expressions, it typically also need a type system. While it can be argued that type system checks are nothing more than constraints, building a reasonable type system is a lot of work that can use additional support over plain constraint checks. This paper describes a first cut at a framework for specifying type systems for (expression) languages built with Xtext.", "num_citations": "5\n", "authors": ["624"]}
{"title": "Model Driven Engineering Languages and Systems.\n", "abstract": " Model Driven Engineering Languages and Systems. FHNW Fachhochschule Nordwestschweiz Men\u00fc Startseite Publikationen Projekte Studentische Arbeiten Login Eintraganzeige IRF Home Hochschule f\u00fcr Wirtschaft Institut f\u00fcr Wirtschaftsinformatik Eintraganzeige Hochschule f\u00fcr Wirtschaft Institut f\u00fcr Wirtschaftsinformatik Eintraganzeige Model Driven Engineering Languages and Systems. Datum 28.09.2008 Autorin/Autor Czarnecki, K Ober, I Bruel, JM Uhl, Axel V\u00f6lter, M Metadata Zur Langanzeige Type 03 - Sammelband Primary target group Sonstige Created while belonging to FHNW? unbekannt URI http://hdl.handle.net/11654/9628 St\u00f6bern Gesamter BestandBereiche & SammlungenErscheinungsdatumAutoren/AutorinnenTitelThemenDiese SammlungErscheinungsdatumAutoren/AutorinnenTitelThemen Mein Benutzerkonto EinloggenRegistrieren Statistics Most Popular ItemsStatistics by CountryMost Popular \u2026", "num_citations": "5\n", "authors": ["624"]}
{"title": "Integrating models and aspects into product line engineering\n", "abstract": " This demonstration presents an approach that facilitates variability implementation, management, and tracing from architectural modeling to implementation. A tool suite is provided that integrates aspect-oriented and model-driven software development into product line engineering.", "num_citations": "4\n", "authors": ["624"]}
{"title": "An integrated aspect-oriented model-driven software product line tool suite\n", "abstract": " Software product line engineering is mostly about the systematic management of commonality and variability between product line members. The effectiveness of this approach thus very much depends on how well variability within the family of similar products is implemented and managed. Variability often has widespread impact, crosscutting not only multiple parts of individual artifacts but also multiple artifacts in multiple stages of the product line lifecycle. This demonstration presents an approach that facilitates variability implementation, management, and tracing by integrating aspect-oriented and model-driven software development. We demonstrate means for effectively dealing with variability on model, model transformation, and code generation level. The concepts are illustrated with a case study of a home automation system.", "num_citations": "4\n", "authors": ["624"]}
{"title": "Software Architecture Documentation in the Real World\n", "abstract": " \u2022 The conceptual architecture and its concrete technological realization can be quite complex\u2013in order to satisfy all the (non-functional) requirements\u2022 Application developers have to be given a well-defined programming model that makes application programming model that makes application development based on the architecture as straight forward as possible", "num_citations": "4\n", "authors": ["624"]}
{"title": "Programming vs. that thing subject matter experts do\n", "abstract": " Allowing subject matter experts to directly contribute their domain knowledge and expertise to software through DSLs and automation is a promising way to increase overall software development efficiency and the quality of the product. However, there are doubts of whether this will force subject matter experts to become programmers. In this paper I answer this question with \u201cno\u201d. But at the same time, subject matter experts have to learn how to communicate clearly and unambiguously to a computer, and this requires some aspects of what is traditionally called programming. The main part of this paper discusses what these aspects are and why learning these does not make people programmers.", "num_citations": "3\n", "authors": ["624"]}
{"title": "Architecture as Language: A story\n", "abstract": " Architecture is typically either a very non-tangible, conceptual aspect of a software system that can primarily be found in Word documents, or it is entirely driven by technology (\u201cwe use an XML architecture\u201d). Both are bad: the former makes it hard to work with, and the latter hides architectural concepts behind technology hype.What can be done? As you develop the architecture, evolve a language that allows you to describe systems based on this architecture. Based on my experience in a number of real-world projects, this makes the architecture tangible and provides an unambiguous description of the architectural building blocks as well as the concrete system while still staying away from technology decisions (which then can be made consciously in a separate step).", "num_citations": "3\n", "authors": ["624"]}
{"title": "Mechanisms for Expressing Variability in Models and MDD Tool Chains\n", "abstract": " Building embedded systems using model-driven development is highly desirable for a number of reasons, among them performance, penalty free abstraction, architecture enforcement, and global constraint evaluation. However, embedded systems are often built in several variants. It is thus essential to be able to express variations of systems in a coherent way, even when the system is built using model-driven development. In this paper, we describe a number of mechanisms for expressing variability in the context of MDD. This includes the expression of model variants, extending models with additional information, as well as describing variants of code generators.", "num_citations": "3\n", "authors": ["624"]}
{"title": "Model-based middleware for embedded systems\n", "abstract": " In this paper we describe the advantages of a model-based approach to embedded component middleware. Component infrastructures such as Enterprise JavaBeans, Microsoft\u2019s COM+ and CORBA Components have become a de-facto standard for enterprise applications. Reasons for this success are the clean separa- tion of technical and functional concerns, COTS containers (applications servers), and the resulting well-defined programming model and standardization. To benefit from these advantages in the domain of embedded systems, the same concepts can be used, but a different implementation strategy is required. First we describe the characteristics of automotive software and explain why the implementation strategies used in enterprise systems can not simply be applied to the automotive do- main. Then we present a brief outline of the design and implementation of a model-based embedded component middleware.", "num_citations": "3\n", "authors": ["624"]}
{"title": "Broker Revisited\n", "abstract": " After having written the Remoting Patterns book [VKZ04], we felt that it was necessary to take a look at fundamental pattern in that context: Broker of [POSA1]. This revised pattern description reflects the current state of discussion. Main changes are in the responsibilities as well as the participants area of the original Broker pattern:", "num_citations": "3\n", "authors": ["624"]}
{"title": "Shadow models: incremental transformations for MPS\n", "abstract": " Shadow Models is an incremental transformation framework for MPS. The name is motivated by the realization that many analyses are easier to do on an model whose structure is different from what the user edits. To be able to run such analyses interactively in an IDE, these``shadows''of the user-facing model must be maintained in realtime, and incrementality can deliver the needed short response times. Shadow Models is an incremental model transformation engine for MPS. In the paper we motivate the system through example use cases, and outline the transformation framework.", "num_citations": "2\n", "authors": ["624"]}
{"title": "Model-Driven Development Processes and Practices: Foundations and Research Perspectives.\n", "abstract": " MD2P2 is a workshop about the interrelation of modeldriven development (MDD) and development processes. The workshop provides a forum for researchers and practitioners to exchange experiences on the questions how processes need to adapt or can be adapted when model-driven techniques are applied. We argue that the interrelation between MDD and development processes can be crucial for the success of MDD. For example, the need to adapt a process when introducing MDD can be a reason to decide against an MDD adoption. Further, we aim to give an introduction to foundations and research perspectives. MD2P2 is co-located with ACM/IEEE 17th International Conference on Model Driven Engineering Languages & Systems.", "num_citations": "2\n", "authors": ["624"]}
{"title": "Projectional language workbenches as a foundation for product line engineering\n", "abstract": " In this paper I explain the benefits of projectional language workbenches for product line engineering. The ability to extend programming languages with domain specific concepts, mix programs (i.e. descriptions written in general purpose languages) and models (i.e. descriptions expressed with DSLs) and also overlay configurative variability to both of these promises highly integrated and productive tools for product line development.", "num_citations": "2\n", "authors": ["624"]}
{"title": "Product Line Engineering with Projectional Language Workbenches\n", "abstract": " Product line engineering deals with managing and implementing the variability among a set of related products. We distinguish between two kinds of variability: structural and non-structural. Structural variability can be described using programming language code or creative construction DSLs, whereas non-structural variability is described using configuration based approaches, such as feature models. Many product lines have both kinds of variability, and they need to be integrated efficiently. This paper describes an approach for product line engineering using projectional language workbenches. These represent code and models with the same fundamental technology, enabling the mixing of models and code. They make the tight integration between several domain-specific languages possible and simple. Since they can store arbitrary information in models, it is possible to overlay non-structural variability over structural variability (ie apply feature model-based configuration to code and models). Because of the projectional approach to editing, programs can be shown with or without the dependencies on feature models, they can even be rendered (and edited) for a specific variant. This approach leads to highly integrated and productive tools for product line development. The paper explains the approach, outlines the implementation of a prototype tool based on Jetbrains MPS and illustrates the benefits using a small product line for embedded systems.", "num_citations": "2\n", "authors": ["624"]}
{"title": "Managing variability in productlines\n", "abstract": " Managing Variability in Product-Lines Page 1 Managing Variability in Product Lines Managing Variability in Product-Lines Markus Voelter voelter@acm.org http://www.voelter.de p // This work is supported by \u00a9 2005-7 Markus V\u00f6lter - 1 - Page 2 Managing Variability in Product Lines About me Markus V\u00f6lter \u2022 Independent Consultant Markus V\u00f6lter voelter@acm.org www.voelter.de Independent Consultant \u2022 Based out of G\u00f6ppingen, Germany \u2022 Focus on \u2022 Model-Driven Software Development and DSLs \u2022 Software Architecture \u2022 P dt Li E i i \u00a9 2005-7 Markus V\u00f6lter - 2 - \u2022 Product Line Engineering Page 3 Managing Variability in Product Lines About AMPLE \u2022 AMPLE == Aspect-Oriented, Model-Driven Product Line E i i Engineering (buzzwords are important to get funded \u263a) \u2022 EU fdd h jt \u2022 EU-funded research project \u2022 I am working with SIEMENS, building practically useful t li d if i it ith td tooling and verifying it with a case \u2026", "num_citations": "2\n", "authors": ["624"]}
{"title": "Writing adaptable software: Mechanisms for implementing variabilities in code and models\n", "abstract": " Writing Adaptable Software: Mechanisms for Implementing pg Variabilities in Code and Models Page 1 1 Product Line Implementation: Variabiliy in Code and Models Writing Adaptable Software: Mechanisms for Implementing p g Variabilities in Code and Models OOPSLA 2007 Tutorial Markus Voelter \u00a9 2005-7 Markus V\u00f6lter -1 - a us oe te voelter@acm.org http://www.voelter.de This work is supported by Copyright is held by the author/owner(s). OOPSLA 2007, October 21\u201325, 2007, Montr\u00e9al, Qu\u00e9bec, Canada. ACM 07/0010. Product Line Implementation: Variabiliy in Code and Models About me Markus V\u00f6lter voelter@acm.org www.voelter.de \u2022 Independent Consultant \u2022 Based out of G\u00f6ppingen, Germany \u00a9 2005-7 Markus V\u00f6lter -2 - \u2022 Focus on \u2022 Model-Driven Software Development \u2022 Software Architecture \u2022 Product Lines Page 2 2 Product Line Implementation: Variabiliy in Code and Models CONTENTS \u2022 PLE \u2026", "num_citations": "2\n", "authors": ["624"]}
{"title": "Model-Driven Development of Component Infrastructures for Embedded Systems.\n", "abstract": " Component infrastructures such as Enterprise JavaBeans, Micorosoft\u2019s COM+ and CORBA Components have become a de-facto standard for enterprise applications. Reasons for this success are the clean separation of technical and functional concerns, COTS containers (applications servers), and the resulting well-defined programming model and standardization. To benefit from these advantages in the domain of embedded systems, the same concepts can be used, but a different implementation strategy is required: monolithic application servers are not suitable because of the limited resources regarding computing power, memory, etc. on the device. An alternative can be based on using a family of code-generated containers. The container is generated from models that specify interfaces, components, system topologies and deployments. In addition to motivating the problem and looking at related work, this paper gives general guidelines for the design and implementation of such infrastructures and describes a prototype implementation that has been implemented recently. We also look at the advantages of using such an approach for the electronic control units in vehicles and the benefits the approach could have with regards to vehicle diagnostics.The rest of the paper is structured as follows: The introduction in section 1 briefly describes embedded software development stateof-the-art and outlines some problems with this approach. Section 2 describes the solution proposed in this paper in a general fashion. The prototype implementation is descrbed in section 3, including the concrete motivation for its implementation. Section 4 describes\u00a0\u2026", "num_citations": "2\n", "authors": ["624"]}
{"title": "Models and Aspects.\n", "abstract": " Models and Aspects - Handling Cross-Cutting Concerns in the context of MDSD Page 1 ingenieurb \u00fcr of \u00fcr so ftw are te chnologie www.voelter.de \u00a9 2004 Markus V\u00f6lter . - 1 - Models and Aspects Markus V\u00f6lter voelter@acm.org www.voelter.de Martin Lippert lippert@acm.org www.martinlippert.org Models And Aspects Handling Cross-Cutting Concerns in the context of MDSD Page 2 ingenieurb \u00fcr of \u00fcr so ftw are te chnologie www.voelter.de \u00a9 2004 Markus V\u00f6lter . - 2 - Models and Aspects \u2022 Independent Consultant \u2022 Based out of Heidenheim, Germany \u2022 Focus on \u2022 Software Architecture \u2022 Middleware \u2022 Model-Driven Software Development About us Markus V\u00f6lter voelter@acm.org www.voelter.de Martin Lippert lippert@acm.org www.martinlippert.org \u2022 Consultant at it-agile GmbH \u2022 Hamburg, Germany \u2022 Focus on \u2022 Software Architecture \u2022 Agile Software Development \u2022 Eclipse-Technology Page 3 ingenieurb \u00fcr of \u00fcr so \u2026", "num_citations": "2\n", "authors": ["624"]}
{"title": "Hope, Belief et Wizardry\n", "abstract": " Normally, I\u2019m not too much into project management. However, over the last couple of years, I have come across several projects that use hope, belief and wizardry as their primary management tools. You will probably not have heard about these specific projects\u2013and you probably never will. They have gone out of existence, maybe because of too successful management techniques. However, if you\u2019re a consultant or a developer, I\u2019m sure you have experienced your own hope/belief/wizardry project and you could probably tell the same story as I do here.This paper is mostly a product of personal frustration. I simply had to write down these things. I did not include \u201cthree known uses\u201d, as you might guess, because the cited projects and their staff might feel offended. However, for me there is no doubt that these things here are really patterns. I have seen many instances, and you have probably also come across some. The pattern form used in the paper consists of a narrative, a kind of story, interleaved with short pattern thumbnails that capture the essence.", "num_citations": "2\n", "authors": ["624"]}
{"title": "Command Revisited\n", "abstract": " Example GUI libraries provide reusable widgets for building graphical user interfaces. These libraries have to be independent of specific application code. Nonetheless, many user interface elements have to interact with application code. For example, when a button is pressed, application code has to be executed. In addition, it is often required to trigger the same functionality from several GUI widgets. In many cases, a piece of functionality must be triggered from the main menu, a toolbar as well as a context menu in a tree view.", "num_citations": "2\n", "authors": ["624"]}
{"title": "Building EJB Applications-A Collection of Patterns\n", "abstract": " Although Enterprise JavaBeans provide simple APIs for relatively complex tasks, designing and implementing a scalable, maintainable and reasonably fast application based on EJB is not trivial. Over time, a set of proven patterns has emerged\u2013this paper presents some of them. The patterns will be part of a book about EJB architecture and application patterns which is currently being written by the authors of this paper. We do not address other parts of J2EE such as Servlets or JMS, we solely focus on the \u201cmiddle tier\u201d made up of EJBs.", "num_citations": "2\n", "authors": ["624"]}
{"title": "A Domain-Specific Language for Payroll Calculations: an Experience Report from DATEV\n", "abstract": " Over the last three years, DATEV, a leading German payroll services provider, has been developing a domain-specific language (DSL) for expressing the calculation logic at the core of their payroll systems. The goal is to allow business programmers to express and test the calculations and their evolution over time in a way that is completely independent of the technical infrastructure that is used to execute them in the data center. Business programmers are people who are experts in the intricacies of the payroll domain and its governing laws and regulations (LaR), but not in software development. This leads to interesting tradeoffs in the design of the DSL. The specific set of challenges that motivated the development of the DSL are given in Sec. 3.2. Payroll might seem dull and not too complicated (\u201cjust a bunch of decisions and some math\u201d). However, the need to work on data that changes over time, to follow the evolution of the LaR, and to keep the language understandable for non-expert programmers makes it interesting from a language design perspective. The need for execution independent of the deployment infrastructure in the data center and on other devices plus the required flexibility in terms of", "num_citations": "2\n", "authors": ["624"]}
{"title": "Languages\n", "abstract": " Trends in Page 1 Trends in Markus Voelter Independent/itemis voelter@acm.org Programming ICALEPCS 2011 Languages Page 2 A single language to rule them all An ecosystem of languages Page 3 An ecosystem of languages The Pendulum Swings Page 4 An ecosystem of languages The need for Concurreny Page 5 An ecosystem of languages The need for Productivity Page 6 An ecosystem of languages Separation Platform - Language Page 7 An ecosystem of languages Building Languages is easier. Page 8 \u278a Interesting GPL Features Page 9 Type Inference Let the compiler figure out types. Page 10 Map<String, MyType> m = new HashMap<String, MyType>(); Classic Java Page 11 Map<String, MyType> m = new HashMap<String, MyType>(); var m = new HashMap[String, MyType](); Scala Classic Java Page 12 Map<String, MyType> m = new HashMap<String, MyType>(); var m = new HashMap[String, \u2026", "num_citations": "1\n", "authors": ["624"]}
{"title": "An Overview of Program Analysis using Formal Methods\n", "abstract": " 4 Abstract Interpretation 15 4.1 Interpreters and Program Analyses... 15 4.2 Sensitivity Properties........... 20 4.3 Implementing Dataflow Analyses.... 23 4.4 Incremental Analyses........... 24 4.5 Symbolic Execution........... 25", "num_citations": "1\n", "authors": ["624"]}
{"title": "Towards improving software security using language engineering and mbeddr c\n", "abstract": " This paper explores the use of domain-specific languages for improving software security, which deals with developing software in a way that is not maliciously exploitable. Specifically we demonstrate how modular extension of the C programming language can help with technical and process-related aspects of software security. Some of these examples are already implemented, some are analytical extrapolations from related work we have done in the past; a detailed empirical evaluation has not yet been done. We rely on mbeddr, an extensible version of C developed with the JetBrains MPS language workbench. We conclude the paper with a discussion of the potential drawbacks of the approach and how these can be addressed in the future.", "num_citations": "1\n", "authors": ["624"]}
{"title": "DSLs for Product Lines: Approaches, Tools, Experiences\n", "abstract": " Domain-Specific Languages are languages narrowly focused on a particular problem domain. Compared to feature models they are more expressive, but possibly not as easy to use. Compared to source code, they are usually simpler, more targeted and hence easier to use - although not quite as flexible. DSLs can play an important role in PLE, filling the gap between configuration via feature models and low-level programming. This tutorial covers approaches, tools and experiences of using DSLs in PLE. I will start with briefly introducing DSLs and their role in PLE. We will then look at a real-world DSL that has been used to describe a product line of electrical devices. We will then spend some time extending a DSL built with Eclipse Xtext to get some hands-on tool experience. Then we will look at another DSL, one for robot control, that integrates nicely with feature models. We will then finally spend some time\u00a0\u2026", "num_citations": "1\n", "authors": ["624"]}
{"title": "Domain specific: a binary decision?\n", "abstract": " It is often considered a binary decision whether something is domain specific or not. Consequently, there are domain specific languages (DSL) and general purpose languages (GPL), there are domain specific and non-domain specific modeling tools, there are domain specific and non-domain specific methodologies etc. In this paper we argue, that domain specificity is not a hard decision, but rather one extreme on a continuum. We also argue that many systems can be more efficiently described with a mix of domain specific and non-domain specific abstractions. This view of the world has consequences for languages, tools and methodologies, specifically the ability to modularize and compose languages. Additionally we outline these consequences and provide an extensive example based on embedded systems.", "num_citations": "1\n", "authors": ["624"]}
{"title": "The model craftsman\n", "abstract": " Everyone would like to have craftsman-level quality, but few are willing to devote the time or spend the money craftsmanship requires. Craftsmen working in hard goods, such as leather or silver, mitigate these factors by using devices such as patterns or molds that they can use to quickly replicate a high-quality design many times over. They have built these patterns based on their past experience. They\u2019ve\u2015materialized\u2016 experience into a tool. Using the tool still requires judgment, but the manual work of creating a product takes significantly less time and money.Programmers can use the same approach as the hard goods craftsman. Domain-specific languages (DSLs), together with their execution environments, can provide the same benefits for the software craftsman. Just as with the specialized tools used by traditional craftsmen, DSLs are optimized for certain tasks in a programmer\u2019s field of experience. An effective way to make the development and maintenance more efficient is to reduce the number of lines of code people have to write, review, and maintain. DSLs help significantly with this, especially in the context of a software product line (SPL) where repeated use of DSLs amortizes the effort of creating them!", "num_citations": "1\n", "authors": ["624"]}
{"title": "A textual domain specific language for AUTOSAR.\n", "abstract": " AUTOSAR is a development partnership formed by leading OEMs and suppliers. The AUTOSAR specifications include a meta-model and a graphical notation that is used to specify E/E systems. However, experience from other software projects has shown that textual DSL have several advantages over graphical modelling. We address the problems of modelling AUTOSAR systems with graphical tools and show how these problems can be mended by a textual domain specific language. We suggest a number of steps that are necessary to design a textual DSL for AUTOSAR. This document focuses on AUTOSAR, but its results and conclusions can be applied to all complex embedded systems.", "num_citations": "1\n", "authors": ["624"]}
{"title": "Models and Aspects-Handling Crosscutting Concerns in MDSD\n", "abstract": " This report summarizes the presentations and discussions of the Third Workshop on Models and Aspects Handling Crosscutting Concerns in MDSD, held in conjunction with the 21st European Conference on Object-Oriented Programming (ECOOP) in Berlin, Germany on July, 31, 2007. This workshop was motivated by the fact that both Model-Driven Software Development (MDSD) and Aspect-Oriented Software Development (AOSD) are important new paradigms that both promise to change the way software is developed. Both approaches provide opportunities for concern separation. AOSD separates concerns horizontally and MDSD enables concern separation vertically. This workshop identified two key integration strategies to achieve the complementary benefits of both aspect-oriented and model-driven development. The first is the use of aspects within transformation languages to separate\u00a0\u2026", "num_citations": "1\n", "authors": ["624"]}
{"title": "Models and aspects-handling crosscutting concerns in MDSD\n", "abstract": " This report summarizes the presentations and discussions of the Second Workshop on Models and Aspects \u2013 Handling Crosscutting Concerns in MDSD, held in conjunction with the 20th European Conference on Object-Oriented Programming (ECOOP) in Nantes, France on July, 3, 2006. This workshop was motivated by the fact that both Model-Driven Software Development (MDSD) and Aspect-Oriented Software Development (AOSD) are important new paradigms that both promise to change the way software is developed. While the two approaches are different in many ways \u2013 MDSD adds domain-specific abstractions, while AOSD is currently primarily seen as domain independent (de)composition mechanism \u2013 they also have many things in common \u2013 for example both approaches integrate models on different levels of abstraction and in this transformation step both have a query phase followed by a\u00a0\u2026", "num_citations": "1\n", "authors": ["624"]}
{"title": "Feedback-Aware Requirements Documents for Smart Devices\n", "abstract": " [Context/Motivation] A smart device is a software-intensive system, which operates autonomously and interacts to some degree with other systems over wireless connections (eg, a iRobot Roomba vacuum cleaner). These systems are often faced with uncertainty in the environment. Runtime representations of requirements have recently gained more interested to deal with this challenge and the term requirements at runtime was coined. These representations allow to reason about the requirements at runtime and to adapt the configuration of a system according to changes in the environment.[Questions/Problems] The research question is how the results of online monitoring of requirements and the system\u2019s decisions about changes in the configuration are communicated to the requirements engineer to better understand the environment. There is a gap between the written requirements document and the dynamic requirements model inside the system. This problem is exacerbated by the fact that a requirements document are mostly informal while the dynamic requirements model is formal.[Principal ideas/results] This paper introduces an approach to bridge the gap between development time and runtime representations in order to keep them consistent and to facilitate a better understanding. We suggest to weave the feedback from the runtime system into requirements documents using a domainspecific language which keeps the informal nature of requirements. An annotated requirements document helps get a better understanding of the system\u2019s actual behavior in a given environment. The approach is implemented using mbeddr, a novel\u00a0\u2026", "num_citations": "1\n", "authors": ["624"]}