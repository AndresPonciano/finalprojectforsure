{"title": "Model checking Z specifications using SAL\n", "abstract": " The Symbolic Analysis Laboratory (SAL) is a suite of tools for analysis of state transition systems. Tools supported include a simulator and four temporal logic model checkers. The common input language to these tools was originally developed with translation from other languages, both programming and specification languages, in mind. It is, therefore, a rich language supporting a range of type definitions and expressions. In this paper, we investigate the translation of Z specifications into the SAL language as a means of providing model checking support for Z. This is facilitated by a library of SAL definitions encoding the Z mathematical toolkit.", "num_citations": "71\n", "authors": ["2271"]}
{"title": "A taxonomy of attacks on secure devices\n", "abstract": " Evaluating the security of hardware devices requires an organised assessment of which attacks the device might be exposed to. This in turn requires a structured body of knowledge about such attacks, classified in such a way that an evaluator can easily determine which attacks are applicable to a particular device. This paper presents such a collection, organised as a taxonomy of attacks on secure devices. The taxonomy covers many attacks applicable to hardware which are frequently overlooked in a software or protocol-centric evaluation.", "num_citations": "43\n", "authors": ["2271"]}
{"title": "A method for verifying concurrent Java components based on an analysis of concurrency failures\n", "abstract": " The Java programming language supports concurrency. Concurrent programs are harder to verify than their sequential counterparts due to their inherent non\u2010determinism and a number of specific concurrency problems, such as interference and deadlock. In previous work, we have developed the ConAn testing tool for the testing of concurrent Java components. ConAn has been found to be effective at testing a large number of components, but there are certain classes of failures that are hard to detect using ConAn. Although a variety of other verification tools and techniques have been proposed for the verification of concurrent software, they each have their strengths and weaknesses. In this paper, we propose a method for verifying concurrent Java components that includes ConAn and complements it with other static and dynamic verification tools and techniques. The proposal is based on an analysis of common\u00a0\u2026", "num_citations": "42\n", "authors": ["2271"]}
{"title": "Mutation-based exploration of a method for verifying concurrent Java components\n", "abstract": " Summary form only given. The Java programming language supports concurrency. Concurrent programs are harder to verify than their sequential counterparts due to their inherent nondeterminism and a number of specific concurrency problems such as interference and deadlock. In previous work, we proposed a method for verifying concurrent Java components based on a mix of code inspection, static analysis tools, and the ConAn testing tool. The method was derived from an analysis of concurrency failures in Java components, but was not applied in practice. In this paper, we explore the method by applying it to an implementation of the well-known readers-writers problem and a number of mutants of that implementation. We only apply it to a single, well-known example, and so we do not attempt to draw any general conclusions about the applicability or effectiveness of the method. However, the exploration\u00a0\u2026", "num_citations": "30\n", "authors": ["2271"]}
{"title": "Towards libraries for Z\n", "abstract": " We consider adding parametrised libraries to Z as a strict extension to the current notation. We examine a simple modularisation facility with only generic sets as parameters, similar to current Z generic schemas.               In examining parameters other than generic sets we consider both an explicit parameter section at the beginning of the library and a more general alternative allowing any variable in the library to be instantiated as a parameter. It turns out, however, that the same effect as the latter form of parametrisation can be achieved with just the simple modularisation, that is, with only generic set parameters.               Finally, we consider interactions between the modularisation facility and current Z notation. In particular, we consider the problem of allowing flexibility in using free types and schema types as parameters.", "num_citations": "29\n", "authors": ["2271"]}
{"title": "A UML approach to the generation of test sequences for Java-based concurrent systems\n", "abstract": " Starting with a UML specification that captures the underlying functionality of some given Java-based concurrent system, we describe a systematic way to construct, from this specification, test sequences for validating an implementation of the system. The approach is to first extend the specification to create UML state machines that directly address those aspects of the system we wish to test. To be specific, the extended UML state machines can capture state information about the number of waiting threads or the number of threads blocked on a given object. Using the SAL model checker we can generate from the extended UML state machines sequences that cover all the various possibilities of events and states. These sequences can then be directly transformed into test sequences suitable for input into a testing tool such as ConAn. As an illustration, the methodology is applied to generate sequences for testing a\u00a0\u2026", "num_citations": "27\n", "authors": ["2271"]}
{"title": "UQ2: a multilingual document editor\n", "abstract": " Audiovisual material available from this site has been copied and communicated to you under a Screenrights licence pursuant to Section 113P of the Copyright Act 1968 solely for the educational purposes of your institution. No other use is authorised. For more information please contact Screenrights at [email protected] or at www. screenrights. org.", "num_citations": "24\n", "authors": ["2271"]}
{"title": "SIFA: A tool for evaluation of high-grade security devices\n", "abstract": " We describe a tool for analysing information flow in security hardware. It identifies both sub-circuits critical to the preservation of security as well as the potential for information flow due to hardware failure. The tool allows for the composition of both logical and physical views of circuit designs. An example based on a cryptographic device is provided.", "num_citations": "16\n", "authors": ["2271"]}
{"title": "Model-based generation of interlocking controller software from control tables\n", "abstract": " Railroad interlocking software drives specialised micro-devices, known as interlocking controllers. These controllers primarily actuate railroad points and change signal aspects in real-time, based on sensor and timer input. Due to their central function in railroad control, interlocking controllers and their firmware are safety-critical. The firmware programs, which mimic physical relays, are written in variants of domain-specific programming languages based on ladder logic. The programs have to comply with a more abstract specification of allowable states of sections of railroad track and equipment, known as a control table. The translation of a track layout and associated control tables into ladder logic-based code is manual, and hence subject to costly review and rework cycles. In this report, we describe a case study that uses a model-driven tool-chain as an automated alternative to the existing process. The\u00a0\u2026", "num_citations": "14\n", "authors": ["2271"]}
{"title": "Modelling java concurrency with object-z\n", "abstract": " In this paper, we present a formal model of Java concurrency using the Object-Z specification language. This model captures the Java thread synchronization concepts of locking, blocking, waiting and notification. In the model, we take a viewpoints approach, first capturing the role of the objects and threads, and then taking a system view where we capture the way the objects and threads cooperate and communicate. As a simple illustration of how the model can, in general be applied, we use Object-Z inheritance to integrate the model with the classical producer-consumer system to create a specification directly incorporating the Java concurrency constructs.", "num_citations": "13\n", "authors": ["2271"]}
{"title": "The Cogito development system\n", "abstract": " The Cogito system provides comprehensive support for the development of specifications written in the Sum language (a modular extension of Z). The tool-set provides technology to aid in the construction, analysis and development of Sum specifications. Ada code is the final result of a development in Cogito.", "num_citations": "13\n", "authors": ["2271"]}
{"title": "Towards integrated model-driven testing of scada systems using the eclipse modeling framework and modelica\n", "abstract": " Testing SCADA (supervisory control and data acquisition) near real-time systems is challenging, as it involves complex interactions and the simulation of the supervised and controlled environment. Model-driven testing techniques can help to achieve clarity about the inner workings of the system and facilitate test construction, but these models are currently disconnected from those of the environmental simulation, leading to a paradigm break. This paper presents a strategy to remedy this situation. To this end, it leverages Modelica and the Eclipse Modeling Framework. Modelica is an object-oriented mathematical modeling language for component-oriented modeling of complex physical systems. It is an open standard and implementation, and provides a rendering of its input language in Ecore, the meta-language of the Eclipse Modeling Framework (EMF). It also offers convenient visual editors, whose notation via\u00a0\u2026", "num_citations": "12\n", "authors": ["2271"]}
{"title": "A complete formal development using Cogito\n", "abstract": " This paper gives an overview of a case study in fully formal development from high level specification to executable code using the Cogito formal development system. The case study demonstrates a significant advance in integrated support for fully formal development.", "num_citations": "12\n", "authors": ["2271"]}
{"title": "Fault evaluation for security-critical communication devices\n", "abstract": " Communications devices for government or military applications must keep data secure, even when their electronic components fail. Combining information flow and risk analyses could make fault-mode evaluations for such devices more efficient and cost-effective. Conducting high-grade information security evaluations for computer communications devices is intellectually challenging, time-consuming, costly, and error prone. We believe that our structured approach can reveal potential fault modes because it simplifies evaluating a device's logical design and physical construction. By combining information-flow and risk-analysis techniques, evaluators can use the process to produce a thorough and transparent security argument. In other work, we have applied static analysis techniques to the evaluation problem, treating a device's schematic circuitry diagram as an information flow graph. This work shows how to\u00a0\u2026", "num_citations": "11\n", "authors": ["2271"]}
{"title": "Testing Java interrupts and timed waits\n", "abstract": " Testing concurrent software is difficult due to problems with inherent nondeterminism. In previous work, we have presented a method and tool support for the testing of concurrent Java components. In this paper, we extend that work by presenting and discussing techniques for testing Java thread interrupts and timed waits. Testing thread interrupts is important because every Java component that calls wait must have code dealing with these interrupts. For a component that uses interrupts and timed waits to provide its basic functionality, the ability to test these features is clearly even more important. We discuss the application of the techniques and tool support to one such component, which is a nontrivial implementation of the readers-writers problem.", "num_citations": "11\n", "authors": ["2271"]}
{"title": "Requirements reformulation using formal specification: A case study\n", "abstract": " The Nulka Electronic Decoy is a joint Australian/US project being developed to counter anti-ship missiles. Thc rocket-powercd decoy is launched from its host ship and lures incoming missiles away from the ship. The Decoy PIDS establishes the performance, design, development and test requirements for the Decoy prime item of the Nulka ship launched Electronic Decoy. It has been prepared in accordance with MIL-STD-490A \u201cSpecification Practices\u201d(Department of Defense 1985). This standard establishes uniform practice for the format and content of specifications prepared for the Department of Defence in order to ensure the inclusion of essential requirements, and to", "num_citations": "10\n", "authors": ["2271"]}
{"title": "Dealing with non-determinism in testing concurrent java components\n", "abstract": " The testing of concurrent software components can be difficult due to the inherent non-determinism present in these components. For example, if the same test case is run multiple times, it may produce different results. This non-determinism may lead to problems with determining expected outputs. In this paper, we present and discuss several possible solutions to this problem in the context of testing concurrent Java components using the ConAn testing tool. We then present a recent extension to the tool that provides a general solution to this problem that is sufficient to deal with the level of non-determinism that we have encountered in testing over 20 components with ConAn.", "num_citations": "9\n", "authors": ["2271"]}
{"title": "A formal basis for a program compilation proof tool\n", "abstract": " This paper presents a case study in verified program compilation from high-level language programs to assembler code using the Cogito formal development system. A form of window-inference based on the Z schema is used to perform the compilation. Data-refinement is used to change the representation of integer variables to assembler word locations.", "num_citations": "9\n", "authors": ["2271"]}
{"title": "Computer-aided development of a real-time program\n", "abstract": " The refinement calculus is a well-established theory for formal development of imperative program code and is supported by a number of automated tools. Via a detailed case study, this article shows how refinement theory and tool support can be extended for a program with real-time constraints. The approach adapts a timed variant of the refinement calculus and makes corresponding enhancements to a theorem-prover based refinement tool.", "num_citations": "9\n", "authors": ["2271"]}
{"title": "From formal specifications to Ada programs\n", "abstract": " This paper describes an approach to embedding the semantics of a target programming language within the Z-based formal specification and development language Sum. The approach enables formal tool-supported refinement from specifications to a Sum subset which is then translated to Ada.", "num_citations": "8\n", "authors": ["2271"]}
{"title": "MDA-based re-engineering with object-Z\n", "abstract": " This paper describes a practical application of MDA and reverse engineering based on a domain-specific modelling language. A well defined metamodel of a domain-specific language is useful for verification and validation of associated tools. We apply this approach to SIFA, a security analysis tool. SIFA has evolved as requirements have changed, and it has no metamodel. Hence, testing SIFA\u2019s correctness is difficult. We introduce a formal metamodelling approach to develop a well-defined metamodel of the domain. Initially, we develop a domain model in EMF by reverse engineering the SIFA implementation. Then we transform EMF to Object-Z using model transformation. Finally, we complete the Object-Z model by specifying system behavior. The outcome is a well-defined metamodel that precisely describes the domain and the security properties that it analyses. It also provides a reliable basis for\u00a0\u2026", "num_citations": "6\n", "authors": ["2271"]}
{"title": "Supporting contexts in the sequential real-time refinement calculus\n", "abstract": " s and compressed postscript les are available via http://svrc. it. uq. edu. au Supporting Contexts in the Sequential Real-Time Renement Calculus Luke Wildman and Ian Hayes Abstract. Program window inference provides support for contextual information such as preconditions and the scope and types of variables during derivations in the renement calculus. Sequential real-time programs may be developed using a real-time renement calculus in which variables are modelled by their traces over time. We introduce support for the contextual information required for derivations in the real-time renement calculus, providing integrated support for the specication, renement, and validation of sequential real-time programs. 1 Introduction The renement calculus [Bac80, Mor94] enables the systematic derivation of programs from specications via a series of correctness preserving transformations. The real-time renement calculus [Mah92] allows the speci-cation of real-time systems an...", "num_citations": "6\n", "authors": ["2271"]}
{"title": "Comparing the cost-effectiveness of statically analysing and model checking concurrent Java components for deadlocks\n", "abstract": " Verifying concurrent Java programs is difficult due to the many possible interleavings of threads and a number of specific concurrency defects such as interference and deadlock. To verify concurrent Java components, the TestCon method combines code inspection, static analysis and dynamic analysis. The deadlock detection steps of TestCon include static analysis (using Jlint) that may result in false positives or false negatives; therefore code inspection is combined with Jlint, but inspection can be time-consuming and depends on the inspector's skills. In this paper, we evaluate the cost-effectiveness of the Java PathFinder 2 (JPF 2) model checker for the detection of deadlocks in the context of the TestCon method. The results of the study show that using JPF 2 can improve TestCon's effectiveness but a trade-off has to be made in terms of cost in the development of the driver and analysis of its output. General\u00a0\u2026", "num_citations": "5\n", "authors": ["2271"]}
{"title": "based testing of concurrent components\n", "abstract": " The use of multiple partial viewpoints is recommended for specification. We believe they also can be useful for devising strategies for testing. In this paper, we use Object-Z to formally specify concurrent Java components from viewpoints based on the separation of application and synchronisation concerns inherent in Java monitors. We then use the Test-Template Framework on the Object-Z viewpoints to devise a strategy for testing the components. When combining the test templates for the different viewpoints we focus on the observable behaviour of the application to systematically derive a practical testing strategy. The Producer-Consumer and Readers-Writers problems are considered as case studies.", "num_citations": "5\n", "authors": ["2271"]}
{"title": "The Sum reference manual\n", "abstract": " Your current browser is not on UQ Library's list of supported browsers. If you experience any problems with this site, please try using the site with a different browser, or upgrade your current browser to the latest version.", "num_citations": "5\n", "authors": ["2271"]}
{"title": "Verifying abstract information flow properties in fault tolerant security devices\n", "abstract": " The verification of information flow properties of security devices is difficult because it involves the analysis of schematic diagrams, artwork, embedded software, etc. In addition, a typical security device has many modes, partial information flow, and needs to be fault tolerant. We propose a new approach to the verification of such devices based upon checking abstract information flow properties expressed as graphs. This approach has been implemented in software, and successfully used to find possible paths of information flow through security devices.", "num_citations": "4\n", "authors": ["2271"]}
{"title": "Composing grammar transformations to construct a specification of a parser\n", "abstract": " As part of a project with the aim of scaling up formal methods, we have developed a library construct for the specification language Z. This paper reports on the result of using libraries to structure a specification of a relatively complicated parser for a language-based editor. The parser is complicated by the need to cope with multiple languages as well as tolerate errors in the input. Our goal in producing the specification of the parser has been to separate each of the major concepts on which the specification is based (eg, multiple languages and error-tolerance) into a separate library. To achieve the separation of concerns we have applied the novel technique of specifying each of the major concepts of the parser as grammar transformations. The full parser can then be specified by composing the separate transformations to give a grammar incorporating all the desired features. 1 Introduction In working towards a suitable framework for writing large specifications we have devel...", "num_citations": "4\n", "authors": ["2271"]}
{"title": "Guidance for Def (Aust) 5679 Issue 2\n", "abstract": " The Australian Standard for safety-critical systems development, Def (Aust) 5679, was first released in 1998. As part of the release of Issue 2 (Department of Defence 2008) of the Standard, guidance material has been prepared to assist those who need to apply the Standard. The guidance is made up of three main parts: a case study that demonstrates how the Standard can be applied to an example safety critical system, Issues Guidance Papers that further explain key concepts or requirements of the Standard, and Data Item Descriptions (DIDs) that, for each of the documents required by the Standard, describe how the document is to be structured. This paper describes the guidance material that was prepared for Issue 2 of the Standard.", "num_citations": "3\n", "authors": ["2271"]}
{"title": "A combined approach for information flow analysis in fault tolerant hardware\n", "abstract": " Fault tolerance in information security devices is difficult to establish due to the large number of possible interactions in the device (e. g. embedded code, boolean logic, electromagnetic interference, etc.) In previous work we examined information flow as a graph problem by composing orthogonal views of the device under analysis. In other work we used fault-tree analysis to reason about information flow as a systemic failure arising from certain configurations (or faults) in either the control logic or data flow 'backbone'. In this paper we combine these approaches by taking advantage of an alternative representation of fault trees as reliability block diagrams.", "num_citations": "2\n", "authors": ["2271"]}
{"title": "Testing concurrent Java components\n", "abstract": " Testing concurrent software is notoriously difficult due to problems with non-determinism and synchronisation. While tools and techniques for the testing of sequential components are well-understood and widely used, similar tools and techniques for concurrent components are not commonly available. This tutorial will look at the problems associated with testing concurrent components and propose techniques for dealing with these problems. The ConAn (Concurrency Analyser) testing tool supports these techniques for the testing of concurrent Java components and will be discussed and demonstrated in the tutorial. The limitations of the techniques and ConAn, as well as additional V&V tools and techniques to address these limitations will be presented.", "num_citations": "2\n", "authors": ["2271"]}
{"title": "A literate rigorous program case study\n", "abstract": " Audiovisual material available from this site has been copied and communicated to you under a Screenrights licence pursuant to Section 113P of the Copyright Act 1968 solely for the educational purposes of your institution. No other use is authorised. For more information please contact Screenrights at [email protected] or at www. screenrights. org.", "num_citations": "2\n", "authors": ["2271"]}
{"title": "Common Criteria Compliance for the Trusted Filter at EAL7-Formal Arguments\n", "abstract": " Method. The formal security policy of the trusted filter is also supplied. Formal proofs were completed that show that the formal specification and the high-level design satisfy the security policy and that the high-level design satisfies the formal specification. This document also describes how the formal parts above correspond to documents required by the CC.", "num_citations": "1\n", "authors": ["2271"]}
{"title": "The variety of variables in automated real-time refinement\n", "abstract": " The refinement calculus is a well-established theory for deriving program code from specifications. Recent research has extended the theory to handle timing requirements, as well as functional ones, and we have developed an interactive programming tool based on these extensions. Through a number of case studies completed using the tool, this paper explains how the tool helps the programmer by supporting the many forms of variables needed in the theory. These include simple state variables as in the untimed calculus, trace variables that model the evolution of properties over time, auxiliary variables that exist only to support formal reasoning, subroutine parameters, and variables shared between parallel processes.", "num_citations": "1\n", "authors": ["2271"]}
{"title": "The variety of variables in computer-aided real-time programming\n", "abstract": " The refinement calculus is a well-established theory for translating specifications to program code. Recent research has extended the calculus to handle real-time requirements and we have developed an interactive support tool based on these extensions. Via a case study, this paper shows how the tool helps the programmer by supporting the many forms of variables used in the theory. These include simple state variables as in the untimed calculus, timed-trace variables that model the evolution of properties over time, and auxiliary variables that exist to support formal reasoning only.", "num_citations": "1\n", "authors": ["2271"]}