{"title": "A powerful strategy for deriving efficient programs by transformation\n", "abstract": " We present a method for deriving efficient iterative programs by transformation from recursive equation specifications. It consists of two phases: i) the transformation of general recursive programs into linear recursive ones, and ii) the transformation of linear recursive programs into iterative ones.", "num_citations": "79\n", "authors": ["1757"]}
{"title": "Deriving very efficient algorithms for evaluating linear recurrence relations using the program transformation technique\n", "abstract": " Using the program transformation technique we derive some algorithms for evaluating linear recurrence relations in logarithmic time. The particular case of the Fibonacci function is first considered and a comparison with the conventional matrix exponentiation algorithm is made. This comparison allows us also to contrast the transformation technique and the stepwise refinement technique underlining some interesting features of the former one. Through the examples given we also explain why those features are interesting for a useful and reliable program construction methodology.", "num_citations": "33\n", "authors": ["1757"]}
{"title": "Higher order generalization in program derivation\n", "abstract": " We define and study a particular kind of generalization strategy for deriving efficient functional programs. It is called higher order generalization because it consists in generalizing variables or expressions into functions. That strategy allows us to derive efficient one-pass algorithms with low time\u00d7space complexity.             Through some examples we show the power of our generalization strategy and its use together with the tupling strategy. Applying those strategies one may avoid the introduction of circular programs [Bir84].", "num_citations": "25\n", "authors": ["1757"]}
{"title": "Methodologies for transformations and memoing in applicative languages\n", "abstract": " Methodologies for transformations and memoing in applicative languages Edinburgh Research Archive logo Edinburgh Research Archive University of Edinburgh homecrest Toggle navigation View Item ERA Home Informatics, School of Informatics thesis and dissertation collection View Item ERA Home Informatics, School of Informatics thesis and dissertation collection View Item Login Toggle navigation Methodologies for transformations and memoing in applicative languages View/Open Pettorossi1984.Pdf (7.168Mb) Date 1984 Author Pettorossi, Alberto Metadata Show full item record Abstract URI http://hdl.handle.net/1842/15643 Collections Informatics thesis and dissertation collection Library & University Collections Home University of Edinburgh Information Services Home Privacy & Cookies | Takedown Policy | Accessibility | Contact Privacy & Cookies Takedown Policy Accessibility Contact feed RSS Feeds \u2026", "num_citations": "19\n", "authors": ["1757"]}
{"title": "The lambda abstraction strategy for program derivation\n", "abstract": " In a previous paper of ours [Pettorossi-Skowron 87] we have introduced the higher order generalization strategy (also called lambda abstraction strategy) and we have indicated through some examples its use for the automatic derivation of programs. Here we study that strategy in more detail and we analyze its capabilities for obtaining highly efficient programs, considering also some cases in which other known strategies for program development do not work.", "num_citations": "15\n", "authors": ["1757"]}
{"title": "Derivation of an O (k2 log n) algorithm for computing order-k fibonacci numbers from the O (k3log n) matrix multiplication method\n", "abstract": " This paper arises from our work on systematic devclopmcnr of algorithms by transformations. Wilson and Shortt have published [4] a O (iog n) algorit llm for computing general order-k Fibonacci r, t&crs P \u2018(n) for k> 2 and n 2 0. These are defined; 1\\follows: f-~ ri)-E \u2018\u201c(2)=\u201c..=~ k (k_ 1)=(-j,", "num_citations": "13\n", "authors": ["1757"]}
{"title": "Program development using lambda abstraction\n", "abstract": " We study the problem of avoiding multiple traversals of data structures in functional programming. A solution proposed in [Bir84] makes use of lazy evaluation and local recursion. We show that analogous perfomances can be achieved using higher order functions and lambda abstractions. The solution we propose works for the call-by-value evaluation rule and it does not require local recursion. We also show through some examples that higher order functions allow us to simulate the use of pointers of a Pascal-like language. We finally spend a few words on a theory of strategies for program development.", "num_citations": "12\n", "authors": ["1757"]}
{"title": "Improving memory utilization in transforming recursive programs\n", "abstract": " In this paper we present some ideas for improving memory utilization in recursive programs. We give a method for transforming programs into \"destructive\" ones, in which variable values are discarded (by means of special operations) as soon as they are no longer necessary for computing other values. The corresponding memory cells may then be reused for storing results which will be obtained later on. We first extend the language of first order recursion equations, so that destructive operations may be represented in it, and we introduce its denotational semantics. We then study, under given hypotheses, the correctness problem of destructive programs and consider algorithms and heuristics for making their memory efficiency as high as possible.", "num_citations": "12\n", "authors": ["1757"]}
{"title": "Categorical models of process cooperation\n", "abstract": " We propose a categorical structure for comparing and giving models to Milner's CCS [11], Hoare's CSP [3], and various other languages for parallelism and synchronization. We consider a generic category C of\" processes\" with morphisms which are labelled by strings of a monoid A of\" actions\". We define the synchronization between two processes in C as a functor (if it exists) from a subcategory of C x C into C. We introduce the notion of categorical semantics and optimal categorical semantics for processes. We show that the\" tree semantics\", defined here, is optimal for most synchronizations described in the literature.", "num_citations": "11\n", "authors": ["1757"]}
{"title": "Comparing and putting together recursive path ordering, simplification orderings and Non-Ascending Property for termination proofs of term rewriting systems\n", "abstract": " We give a sufficient condition for proving strong termination in Combinatory Logic and Rewriting Systems which solves an open problem [B\u00f6h 77]. We also compare, in the context of general rewriting systems, the power of that condition and other known methods, as the recursive path orderings and simplification orderings, presenting original results.             A new technique for proving strong termination, called Diagram of Matchings, is also introduced. In many cases it allows to combine together the strength of various methods of proof.", "num_citations": "11\n", "authors": ["1757"]}
{"title": "Meta-Programming in Logic: Third International Workshop, META-92, Uppsala, Sweden, June 10-12, 1992. Proceedings\n", "abstract": " This volume contains lectures and papers delivered at Meta 92, the Third International Workshop on Metaprogramming in Logic, held in Uppsala, Sweden, June 1992. The topics covered include foundations of metaprogramming in logic, proposals for metaprogramming languages, techniques for knowledgerepresentation and belief systems, and program transformation and analysis in logic. Particular topics include belief revision systems, intensionaldeduction, belief systems and metaprogramming, principles of partial deduction, termination in logic programs, semantics of the\" vanilla\" metainterpreter, a complete resolution method for metaprogramming, semanticsof\" demo\", hierarchical metalogics, the naming relation in metalevel systems, modules, reflective agents, compiler optimizations, metalogic and object-oriented facilities, parallel logic languages, the use of metaprogramming for legal reasoning, representing objects and inheritance, transformation of normal programs, negation in automatically generated logic programs, reordering of literals in deductive databases, abstract interpretations, and interarguments in constraint logic programs.", "num_citations": "10\n", "authors": ["1757"]}
{"title": "Observers, Experiments, and Agents: A comprehensive approach to parallelism\n", "abstract": " The aim of this paper is to introduce an enriched categorical approach which provides a unifying theory for many notions of parallelism and concurrency. Our constructions are based on a concept of observational equivalence induced by a set of observers, which perform experiments over agents. The outcome of those experiments is a set of computations together with an agreement information. In order to model parallel agents and their behaviours we use categories enriched over a bicategory. They provide an abstract framework with entities at three levels: i) observers at level 0, ii) experiments at level 1, and iii) computing agents at level 2. This comprehensive framework is parametric with respect to the nature of the observers, which may observe totally or partially ordered sets of actions in a discrete or continuous manner. The relationship between various models for parallelism can be expressed in terms\u00a0\u2026", "num_citations": "9\n", "authors": ["1757"]}
{"title": "Derivation of programs which traverse their input data only once\n", "abstract": " Publisher SummaryThe process of deriving programs from specifications can sometimes be viewed as a simplification process. However, not all program derivations are simplifications. Some other derivations described in the literature are (1) the synchronizations of computations like die ones based on the tupling strategy or (2) the definitions of more general computations, like the ones based on the generalization strategy. Lambda abstraction is a transformation strategy based on the idea of forced folding, which is a method for obtaining efficient recursive programs and inventing suitable auxiliary functions when transforming programs. The application of the lambda abstraction consists in the introduction of a new function that is obtained by breaking a given expression into a lambda formula applied to suitable arguments. The expression to be broken is often the one that does not allow a folding step because of a\u00a0\u2026", "num_citations": "9\n", "authors": ["1757"]}
{"title": "Enriched categories for local and interaction calculi\n", "abstract": " The construction of models for distributed computations plays a very important role in designing and developing parallel computing systems. Various algebraic approaches have been proposed in the past as, for instance, the communicating computing agents of [Mil80], [BeK85], and [BHR84].             In our work we propose a general method for defining the categorical models for classes of algebras of distributed computing agents. If the static and dynamic operations [Mil80] of the algebras enjoy suitable properties, we can construct enriched categories which are models of distributed computations, including also the case of concurrent finite automata which cooperate via protocols. The construction is uniform with respect to the particular algebra one may wish to consider.", "num_citations": "8\n", "authors": ["1757"]}
{"title": "Rules and strategies for transforming functional and logic programs\n", "abstract": " Rules and strategies for transforming functional and logic programs - OpenGrey fra | eng OpenGrey Open System for Information on Grey literature in Europe Home Search Subjects Partners Export Help Search XML To cite or link to this reference: http://hdl.handle.net/10068/316381 Title : Rules and strategies for transforming functional and logic programs Authors : Pettorossi, A. ; Proietti, M ; Corporate author : Consiglio Nazionale delle Ricerche, Rome (Italy). Istituto di Analisi dei Sistemi ed Informatica ; Publication year : 1995 Language : English ; Pagination/Size : 87 p. ; SIGLE classification : 12B - Statistics, operations research ; Document type : Y - Progress report ; Report number : CNR-IASI-R--423 ; Other identifier : IT_ 1996:288 ; IT ; handle : http://hdl.handle.net/10068/316381 Provenance : SIGLE ; Get a copy : CNR - Consiglio Nazionale delle Richerche Availability : Consiglio Nazionale delle Ricerche (CNR). \u2026", "num_citations": "7\n", "authors": ["1757"]}
{"title": "Towers of Hanoi problems: Deriving iterative solutions by program transformations\n", "abstract": " We present the iterative solutions of the Towers of Hanoi problems (standard, cyclic, and generalized) using the program transformation methodology of Burstall-Darlington. We derive algorithms with minimal time \u00d7 space requirements. Their correctness proofs are trivial, as usual when applying the program transformation technique.", "num_citations": "7\n", "authors": ["1757"]}
{"title": "Elements of computability, decidability, and complexity\n", "abstract": " These lecture notes are intended to introduce the reader to the basic notions of computability theory, decidability, and complexity. More information on these subjects can be found in classical books such as [6, 8, 15, 16, 33]. The results reported in these notes are taken from those books and in various parts we closely follow their style of presentation. The reader is encouraged to look at those books for improving his/her knowledge on these topics. Some parts of the chapter on complexity are taken from the lecture notes of a beautiful course given by Prof. Leslie Valiant at Edinburgh University, Scotland, in 1979. It was, indeed, a very stimulating and enjoyable course. For the notions of Predicate Calculus we have used in this book the reader may refer to [26].", "num_citations": "6\n", "authors": ["1757"]}
{"title": "Future directions in program transformation\n", "abstract": " The program transformation methodology can provide valuable techniques and tools for the development of programs from specifications and the reuse and customization of software products. Also various approaches to program optimization and program verification can be based on transformation techniques.", "num_citations": "6\n", "authors": ["1757"]}
{"title": "Verifying infinite state systems by specializing constraint logic programs\n", "abstract": " We propose a method for the specification and the automated verification of temporal properties of infinite state reactive systems. Given a reactive system K and a formula \u03d5 of the branching time temporal logic CTL, we construct a locally stratified constraint logic program PK [\u03d5] such that the system K verifies \u03d5 if and only if prop\u2208 M (PK [\u03d5]), where prop is a predicate symbol defined in PK [\u03d5] and M (PK [\u03d5]) is the perfect model of PK [\u03d5]. Then we check whether or not prop\u2208 M (PK [\u03d5]) by specializing the program PK [\u03d5] wrt prop and deriving a new program Psp containing either the fact prop\u2190(in which case the temporal formula \u03d5 is verified by the system) or no clause for prop (in which case the temporal formula \u03d5 is not verified by the system). Our specialization method makes use of:(i) a set of specialization rules that preserve the perfect model of constraint logic programs, and (ii) an automatic strategy that guides the application of these rules for deriving the specialized program Psp. Our strategy always terminates and is sound for verifying CTL formulas. Due to the undecidability of CTL formulas in the case of infinite state systems, our strategy is incomplete, that is, we may derive a specialized program Psp containing a clause for prop different from the fact prop\u2190. However, as indicated by the", "num_citations": "5\n", "authors": ["1757"]}
{"title": "Strategical derivation of on-line programs\n", "abstract": " Strategical derivation of on-line programs | The IFIP TC2/WG 2.1 Working Conference on Program specification and transformation ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsThe IFIP TC2/WG 2.1 Working Conference on Program specification and transformationStrategical derivation of on-line programs ARTICLE Strategical derivation of on-line programs Share on Author: Alberto Pettorossi profile image A. Pettorossi View Profile Authors Info & Affiliations Publication: The IFIP TC2/WG 2.1 Working Conference on Program specification and transformationJune 1987 Pages 73\u201388 1citation 0 Downloads Metrics Total \u2026", "num_citations": "5\n", "authors": ["1757"]}
{"title": "Derivation of efficient programs for computing sequences of actions\n", "abstract": " We consider a class of programs whose output is a sequence of elementary actions or moves. For that class we provide some transformation strategies for deriving efficient iterative programs with on-line behaviour, that is, programs which produce the output moves, one at the time, according to a given sequence ordering.Using the proposed methods it is possible to answer Hayes' long-standing challenge for deriving a very fast on-line program for the Towers of Hanoi and similarly defined problems.", "num_citations": "5\n", "authors": ["1757"]}
{"title": "Communicating agents for applicative concurrent programming\n", "abstract": " A good program methodology should allow easy proofs of program correctness and should also incorporate methods for improving program efficiency. We try to achieve both aims by proposing, in the framework of the applicative programming style, a language by which one can specify a system of computing agents, which communicate by sending and receiving messages.             The contents of these messages are \"facts\", or \"pieces of truth\" about computations. They are formally defined in the paper.             When communications occur, the system of agents achieves better performances in executing programs, and the task of showing correctness of the resulting computations remains relatively simple. We will give some examples for illustrating these points.             The proposed language supports a program methodology for writing concurrent programs in a reliable way. A basis for a theory of\u00a0\u2026", "num_citations": "5\n", "authors": ["1757"]}
{"title": "Logic Based Program Synthesis and Transformation: 11th International Workshop, LOPSTR 2001, Paphos, Cyprus, November 28-30, 2001. Selected Papers\n", "abstract": " This book constitutes the thoroughly refereed post-proceedings of the 11th International Workshop on Logic-Based Program Synthesis and Transformation, LOPSTR 2001, held in Paphos, Cyprus, in November 2001. The 13 revised full papers presented together with an invited paper were carefully selected and improved during two rounds of reviewing and revision. The papers are organized in topical sections on program transformation and equivalence, program verification, program analysis, program development, and program synthesis.", "num_citations": "4\n", "authors": ["1757"]}
{"title": "A property which guarantees termination in weak combinatory logic and subtree replacement systems.\n", "abstract": " 1 Introduction It is well-known that recursive equations may be conveniently used for defining functions and specifying their computations. A particular syntactic system for writing such equations is Weak Combinatory Logic. Such logical formalism, even if not particularly appealing to computer scientists because of its syntactical characteristics, could be useful when we want to consider also untyped functions and would like to avoid the extra problems due to the presence of variables and their bindings, as in type-free X-calculus [1].", "num_citations": "4\n", "authors": ["1757"]}
{"title": "Enhancing predicate pairing with abstraction for relational verification\n", "abstract": " Relational verification is a technique that aims at proving properties that relate two different program fragments, or two different program runs. It has been shown that constrained Horn clauses (CHCs) can effectively be used for relational verification by applying a CHC transformation, called predicate pairing, which allows the CHC solver to infer relations among arguments of different predicates. In this paper we study how the effects of the predicate pairing transformation can be enhanced by using various abstract domains based on linear arithmetic (i.e., the domain of convex polyhedra and some of its subdomains) during the transformation. After presenting an algorithm for predicate pairing with abstraction, we report on the experiments we have performed on over a hundred relational verification problems by using various abstract domains. The experiments have been performed by using the VeriMAP transformation and verification system, together with the Parma Polyhedra Library (PPL) and the Z3 solver for CHCs.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "Techniques for searching, parsing, and matching\n", "abstract": " These lecture notes present some basic techniques for:(i) exploring search spaces,(ii) parsing context-free languages, and (iii) matching patterns in strings. These techniques are taught in a course on Automata, Languages, and Translators at the University of Roma \u201cTor Vergata\u201d. We assume that the reader is familiar with the basic notions of Automata Theory and Formal Languages. These notions can be found in many books such as [9, 10, 21]. Some of the algorithms we have presented in these notes are written in Java 1.5 and some others in Prolog. For the Java language the reader may refer to the Java Tutorial at http://java. sun. com/docs/books/tutorial/.(Recall that this Java version allows the use of parametrized types, also called generics.) All Java programs have been compiled using the Java compiler 1.5. 0 13 running under Mac OS X 10.4. 11 Darwin 8.11. 1.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "A Folding Algorithm for Eliminating Existential Variables from Constraint Logic Programs\n", "abstract": " The existential variables of a clause in a constraint logic program are the variables which occur in the body of the clause and not in its head. The elimination of these variables is a transformation technique which is often used for improving program efficiency and verifying program properties. We consider a folding transformation rule which ensures the elimination of existential variables and we propose an algorithm for applying this rule in the case where the constraints are linear inequations over rational or real numbers. The algorithm combines techniques for matching terms modulo equational theories and techniques for solving systems of linear inequations. We show that an implementation of our folding algorithm performs well in practice.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "Transformational verification of parameterized protocols using array formulas\n", "abstract": " We propose a method for the specification and the automated verification of temporal properties of parameterized protocols. Our method is based on logic programming and program transformation. We specify the properties of parameterized protocols by using an extension of stratified logic programs. This extension allows premises of clauses to contain first order formulas over arrays of parameterized length. A property of a given protocol is proved by applying suitable unfold/fold transformations to the specification of that protocol. We demonstrate our method by proving that the parameterized Peterson\u2019s protocol among\u00a0N processes, for any N\u2009\u2265\u20092, ensures the mutual exclusion property.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "First order predicate calculus and logic programming\n", "abstract": " These lecture notes are intended to introduce the reader to the basic notions of the first order predicate calculus and logic programming. We present the axioms and the inference rules of the first order predicate calculus in two different styles:(i) the Classical style (\u00e0 la Hilbert), and (ii) the Natural Deduction style (\u00e0 la Gentzen). We also present the semantics of this calculus following Tarski\u2019s approach. The Skolem Theorem, the Herbrand Theorem, and the Robinson Theorem are the three steps which lead us to the study of the Definite Logic programs. For these programs we give the denotational semantics via the least Herbrand models, the fixpoint semantics via the so called TP operator, and the operational semantics via SLD trees. Finally, we consider the issue of deriving negative information from Definite Logic programs, and we present the theory of normal programs and the theory of programs as conjunctions of statements.Sections are devoted to the G\u00f6del\u2019s Completeness Theorem, the first order predicate calculus with equality, and the Peano Arithmetic. We would like to thank Andrea Bastoni, Lorenzo Clemente, Simone D\u2019Uffizi, Alessandro Papaleo, Giorgio Ventrella, and the other students of the Theoretical Computer Science courses during the academic years 2002-03 and 2003-04 for pointing out to us a few mistakes.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "Techniques for the automatic improvement of logic programs\n", "abstract": " Techniques for the automatic improvement of logic programs - OpenGrey fra | eng OpenGrey Open System for Information on Grey literature in Europe Home Search Subjects Partners Export Help Search XML To cite or link to this reference: http://hdl.handle.net/10068/313121 Title : Techniques for the automatic improvement of logic programs Authors : Proietti, Maurizio ; Pettorossi, Alberto ; Corporate author : Consiglio Nazionale delle Ricerche, Rome (Italy). Istituto di Analisi dei Sistemi ed Informatica ; Publication year : 1988 Language : English ; Pagination/Size : 50 p. ; SIGLE classification : 09H - Computer software, programming ; 09B - Circuits ; Document type : Y - Progress report ; Report number : CNR-IASI-R--231 ; Other identifier : IT_ 1989:101 ; IT ; handle : http://hdl.handle.net/10068/313121 Provenance : SIGLE ; Get a copy : CNR - Consiglio Nazionale delle Richerche Country : Italy ; CNRS INIST Creative \u2026", "num_citations": "3\n", "authors": ["1757"]}
{"title": "Transformation strategies for deriving on line programs\n", "abstract": " We consider a class of programs whose output is a sequence of \"elementary actions\" or \"moves\". We provide some transformation strategies for deriving efficient iterative programs which exhibit a \"on-line behaviour\", i.e. producing the output moves, one at the time, according to a given sequence ordering. Our methods also give an answer to a long standing challenge [Hay77] for deriving a very fast on-line program for the Towers of Hanoi (and similarly defined) problems.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "Categorical models for handshaking communications\n", "abstract": " Various languages, formalisms and algebraic structures have been recently proposed for denoting parallel computations and communications among processes. As in [LaP 83] we restrict our attention to the CCS [Mil 80] and CSP [Hoa 78] languages. We provide categorical models for their basic constructs and operations. The parallel composition and other kinds of interactions among computing processes will be interpreted as categorical constructions in suitable categories.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "Towards a theory of parallelism and communications for increasing efficiency in applicative languages\n", "abstract": " A new methodology for writing efficient programs is proposed through various examples. The basic ideas are:i) the use of the appli cative stile of programming, so that correctness of programs can easily be proved, and ii) the improvement of program efficiency by the evaluation of functions applications using concurrent computing agents.             For increasing efficiency, communications among those agents are necessary, so that redundant evaluations of common subexpressions can be avoided.             In this paper we also introduce some preliminary ideas for a theory of such communications. We call them \"helpful communications\". They include \"compulsory\" communications, which effect program correctness, and \"optional\" communications, which do not effect program correctness, but only program efficiency.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "On subrecursiveness in weak combinatory logic\n", "abstract": " In this paper weak combinatory logic as an algorithmic language is considered and various notions of structural and computational complexity are introduced. Particular attention is devoted to the definitional power of a system of combinators,that is to the concept of \u201csubbase\u201d. Some results concerning the relations between specific subbases and their generative power are presented.", "num_citations": "3\n", "authors": ["1757"]}
{"title": "Analysis and transformation of constrained Horn clauses for program verification\n", "abstract": " This paper surveys recent work on applying analysis and transformation techniques that originate in the field of constraint logic programming (CLP) to the problem of verifying software systems. We present specialization-based techniques for translating verification problems for different programming languages, and in general software systems, into satisfiability problems for constrained Horn clauses (CHCs), a term that has become popular in the verification field to refer to CLP programs. Then, we describe static analysis techniques for CHCs that may be used for inferring relevant program properties, such as loop invariants. We also give an overview of some transformation techniques based on specialization and fold/unfold rules, which are useful for improving the effectiveness of CHC satisfiability tools. Finally, we discuss future developments in applying these techniques.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Bounded symbolic execution for runtime error detection of Erlang programs\n", "abstract": " Dynamically typed languages, like Erlang, allow developers to quickly write programs without explicitly providing any type information on expressions or function definitions. However, this feature makes those languages less reliable than statically typed languages, where many runtime errors can be detected at compile time. In this paper, we present a preliminary work on a tool that, by using the well-known techniques of metaprogramming and symbolic execution, can be used to perform bounded verification of Erlang programs. In particular, by using Constraint Logic Programming, we develop an interpreter that, given an Erlang program and a symbolic input for that program, returns answer constraints that represent sets of concrete data for which the Erlang program generates a runtime error.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Verifying Relational Program Properties by Transforming Constrained Horn clauses.\n", "abstract": " We present a method for verifying relational program properties, that is, properties that relate the input and the output of two programs. Our verification method is parametric with respect to the definition of the semantics of the programming language in which the programs are written. That definition consists of a set Int of constrained Horn clauses (CHC) that encode the interpreter of the programming language. Then, given the programs and the relational property we want to verify, we generate, by using Int, a set of constrained Horn clauses whose satisfiability is equivalent to the validity of the property. Unfortunately, state-of-the-art solvers for CHC have severe limitations in proving the satisfiability, or the unsatisfiability, of such sets of clauses. We propose some transformation techniques that increase the power of CHC solvers when verifying relational properties. We show that these transformations, based on unfolding and folding rules, preserve satisfiability. Through an experimental evaluation we also show that in many cases CHC solvers are able to prove the (un) satisfiability of sets of clauses obtained by applying the transformations we propose, whereas the same solvers are unable to perform those proofs when given as input the original sets of constrained Horn clauses.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Verification of Imperative Programs through Transformation of Constraint Logic Programs.\n", "abstract": " In the last decade formal techniques have received a renewed attention as the basis of a methodology for increasing the reliability of software artifacts and reducing the cost of software production. In particular, great efforts have been made to devise automatic techniques such as software model checking [20], for verifying the correctness of programs with respect to their specifications.In many software model checking techniques, the use of constraints has been very effective both for constructing models of programs and for reasoning about them [1, 7, 8, 10, 15, 17, 19, 30, 31]. Several kinds of constraints have been considered, such as equalities and inequalities over booleans, integers, reals, and finite or infinite trees. By using constraints we can represent in a symbolic, compact way the (possibly infinite) sets of values computed by programs and, in general, the sets of states which are reached during program executions. Then, by using powerful solvers specifically designed for the classes of constraints we have mentioned above, we can reason about program properties in an efficient way. In this paper we consider a simple imperative programming language with integer and array variables and we use Constraint Logic Programming (CLP)[18] as a metalanguage for representing imperative programs, their executions, and the properties to be verified. We use constraints consisting of linear equalities and inequalities over integers. Note, however, that the method presented here is parametric with respect to the constraint domain which is used. By following an approach originally presented in [30], a given imperative program prog and its interpreter\u00a0\u2026", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Automata theory and formal languages\n", "abstract": " These lecture notes present some basic notions and results on Automata Theory, Formal Languages Theory, Computability Theory, and Parsing Theory. I prepared these notes for a course on Automata, Languages, and Translators which I am teaching at the University of Roma Tor Vergata. More material on these topics and on parsing techniques for context-free languages can be found in standard textbooks such as [1, 8, 9]. The reader is encouraged to look at those books. A theorem denoted by the triple kmn is in Chapter k and Section m, and within that section it is identified by the number n. Analogous numbering system is used for algorithms, corollaries, definitions, examples, exercises, figures, and remarks. We use \u2018iff\u2019to mean \u2018if and only if\u2019.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Transformational verification of linear temporal logic\n", "abstract": " We present a new method for verifying Linear Temporal Logic (LTL) properties of finite state reactive systems based on logic programming and program transformation. We encode a finite state system and an LTL property which we want to verify as a logic program on infinite lists. Then we apply a verification method consisting of two steps. In the first step we transform the logic program that encodes the given system and the given property into a new program belonging to the class of the so-called linear monadic !-programs (which are stratified, linear recursive programs defining nullary predicates or unary predicates on infinite lists). This transformation is performed by applying rules that preserve correctness. In the second step we verify the property of interest by using suitable proof rules for linear monadic !-programs. These proof rules can be encoded as a logic program which always terminates, if evaluated by using tabled resolution. Although our method uses standard program transformation techniques, the computational complexity of the derived verification algorithm is essentially the same as the one of the Lichtenstein-Pnueli algorithm [9], which uses sophisticated ad-hoc techniques.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Totally correct logic program transformations via well-founded annotations\n", "abstract": " We address the problem of proving the total correctness of transformations of definite logic programs. We consider a general transformation rule, called clause replacement, which consists in transforming a program P into a new program Q by replacing a set \u0393                         1 of clauses occurring in P by a new set \u0393                         2 of clauses, provided that \u0393                         1 and \u0393                         2 are equivalent in the least Herbrand model M(P) of the program P.               We propose a general method for proving that transformations based on clause replacement are totally correct, that is, M(P)=M(Q). Our method consists in showing that the transformation of P into Q can be performed by: (i)\u00a0adding extra arguments to predicates, thereby deriving from the given program P an annotated program   , (ii)\u00a0applying a variant of the clause replacement rule and transforming the annotated program    into a terminating\u00a0\u2026", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Automatic Program Development: A Tribute to Robert Paige\n", "abstract": " \u201cAutomatic Program Development\u201d is a tribute to Robert Paige (1947-1999), our accomplished and respected colleague, and moreover our good friend, whose untimely passing was a loss to our academic and research community. We have collected the revised, updated versions of the papers published in his honor in the Higher-Order and Symbolic Computation Journal in the years 2003 and 2005. Among them there are two papers by Bob:(i) a retrospective view of his research lines, and (ii) a proposal for future studies in the area of the automatic program derivation. The book also includes some papers by members of the IFIP Working Group 2.1 of which Bob was an active member. All papers are related to some of the research interests of Bob and, in particular, to the transformational development of programs and their algorithmic derivation from formal specifications.\u201cAutomatic Program Development\u201d offers a renewed stimulus for continuing and deepening Bob's research visions. A familiar touch is given to the book by some pictures kindly provided to us by his wife Nieba, the personal recollections of his brother Gary and some of his colleagues and friends.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Elements of concurrent programming\n", "abstract": " These lecture notes are intended to introduce the reader to the basic notions of nondeterministic and concurrent programming. We start by giving the operational semantics of a simple deterministic language and the operational semantics of a simple nondeterministic language based on guarded commands. Then we consider concurrent computations based on:(i) vectorization,(ii) shared variables, and (iii) handshaking communications \u00e0 la CCS (Calculus for Communicating Systems)[16]. We also address the problem of mutual exclusion and for its solution we analyze various techniques such as those based on semaphores, critical regions, conditional critical regions, and monitors. Finally, we study the problem of detecting distributed termination and the problem of the serializability of database transactions.Sections 1, 2, and 6 are based on [16, 22]. The material of Sections 3 and 4 is derived from [1, 2, 4, 5, 7, 8, 13, 18, 20]. Section 5 is based on [10] and is devoted to programming examples written in Java where the reader may see in action some of the basic techniques described in these lecture notes. In Section 7 we closely follow [3]. We would like to thank Dr. Maurizio Proietti for his many suggestions and his encouragement, Prof. Robin Milner and Prof. Matthew Hennessy for introducing me to CCS, Prof. Vijay K. Garg from whose book [10] I learnt concurrent programming in Java, my colleagues at Roma Tor Vergata University for their support and friendship, and my students for their patience and help.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Transformations of logic programs with goals as arguments\n", "abstract": " We consider a simple extension of logic programming where variables may range over goals and goals may be arguments of predicates. In this language we can write logic programs which use goals as data. We give practical evidence that, by exploiting this capability when transforming programs, we can improve program efficiency. We propose a set of program transformation rules which extend the familiar unfolding and folding rules and allow us to manipulate clauses with goals which occur as arguments of predicates. In order to prove the correctness of these transformation rules, we formally define the operational semantics of our extended logic programming language. This semantics is a simple variant of LD-resolution. When suitable conditions are satisfied this semantics agrees with LD-resolution and, thus, the programs written in our extended language can be run by ordinary Prolog systems. Our\u00a0\u2026", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Combining logic programs and monadic second order logics by program transformation\n", "abstract": " We present a program synthesis method based on unfold/fold transformation rules which can be used for deriving terminating definite logic programs from formulas of the Weak Monadic Second Order theory of one successor (WS1S). This synthesis method can also be used as a proof method which is a decision procedure for closed formulas of WS1S. We apply our synthesis method for translating CLP(WS1S) programs into logic programs and we use it also as a proof method for verifying safety properties of infinite state systems.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Transformation rules for logic programs with goals as arguments\n", "abstract": " We introduce a logic language where predicate symbols may have both terms and goals as arguments. We define its operational semantics by extending SLD-resolution with the leftmost selection rule, and we propose a set of transformation rules for manipulating programs written in that language. These transformation rules are shown to be correct in the sense that they preserve the chosen operational semantics. This logic language has higher order capabilities which turn out to be very powerful for the derivation of efficient logic programs. In particular, in our language we can avoid the problem of goal rearrangement which is often encountered during program transformation. Moreover, goals as arguments allow us to perform on logic programs transformation steps similar to the ones performed on functional programs when using higher order generalizations and continuation arguments.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "MAP: a Tool for Program Derivation based on Transformation Rules and Strategies\n", "abstract": " Since 1987 the Department of Informatics of the University of Rome Tor Vergata and the IASI Institute of the National Research Council (CNR), Rome, have been cooperating on the development of techniques and tools for automatic program derivation and validation. This work has used a transformation methodology based on the so-called \u2018rules+ strategies\u2019 approach.The basic idea for this approach goes back to the seminal papers by Burstall-Darlington in 1977 (for the case of functional programs) and Tamaki-Sato in 1984 (for the case of logic programs). These papers show how a given specification, written as a set of recursive equations or a set of Horn clauses, can be transformed into an efficient program by applying suitable transformation rules which are guaranteed to preserve the intended semantics. The application of these rules should be guided by suitable strategies that, for some classes of initial\u00a0\u2026", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Developing correct and efficient logic programs by transformation\n", "abstract": " The complex process of deriving programs from specifications is often divided into the following three steps: (i) the derivation of formal specifications from the informal ones; (ii) the validation of the formal specifications; and (iii) the derivation of executable programs from the formal specifications.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "An automatic transformation strategy for avoiding unnecessary variables in logic programs\n", "abstract": " When writing programs one uses variables for storing input and output data. They can be considered as necessary variables, because they are needed for expressing the meaning of programs. Often one also uses variables which are unnecessary, in the sense that they are not required for describing the input-output relation. Unnecessary variables are used by the programmer because they often allow for a more transparent way of writing programs or an easier proof of their correctness.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "A methodology for improving parallel programs by adding communications\n", "abstract": " We propose a programming methodology for improving the efficiency of applicative parallel programs.             The basic idea comes from the program transformation approach \u00e0 la Burstall-Darlington, in which \"new and more efficient\" versions of the programs are derived from \"old\" ones.             We extend that approach in the following two respects:                                    we consider parallel concurrent programs, and                                                     we provide a calculus for ensuring that the derived versions are more efficient.                                              We consider that the programmer provides a first version of his/her program and then he/she discovers, maybe in an incremental way, some \"facts\" about it. Facts are then tested by the calculus and, if they are \"accepted\", they will be incorporated into the given version of the program via a translation algorithm, and a new version is thereby derived.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "A transformational approach for developing parallel programs\n", "abstract": " We analyze the motto: \"efficiency = parallelism + communications\" as an approach for developing parallel programs. Communications are used for deriving suitable program transformations via definition of \"eureka\" functions or synthesis of \"annotations\". We also introduce a strategy, called minimal extension strategy, for obtaining new auxiliary functions, and some preliminary ideas for a new theory of communications, which do not effect program correctness, but only program efficiency.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "An approach to communications and parallelism in applicative languages\n", "abstract": " Applicative languages possess very attractive features with respect to program readability and correctness proofs. Sometimes, however, they do not seem to allow very high levels of efficiency. In this paper we consider how one can embed concepts of parallel evaluation and communications in applicative languages, so that program efficiency may be improved. We also studied a novel theory of communications among concurrent computing agents. In general, such communications are optional in the sense that only program efficiency (not program correctness) is effected, if they do not take place.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Combinators as Tree-transducers\n", "abstract": " In this paper we consider combinators as tree transducers: this approach is based on the one-to-one corrispondence between terms and trees and on the fact that combinators can be considered as transformers of terms. Since combinators are terms themselves, we are going to deal with trees as objects to be transfor med and trees transformers as well. Methods for defining and studying tree re-writing systems inside Weak Combinatory Logic (WCL) are also analyzed and parti cular attention is devoted to the problem of finiteness vs. infinity of the generated tree languages. This implies the study of the termination of the re-writing process (ie reduction) among combinators.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Branching Preserving Specialization for Software Model Checking\n", "abstract": " We present a method for verifying properties of imperative programs by using techniques based on constraint logic programming (CLP). We consider a simple imperative language, called SIMP, extended with a nondeterministic choice operator and we address the problem of checking whether or not a safety property \u03d5 (that specifies that an unsafe configuration cannot be reached) holds for a SIMP program P. The operational semantics of the language SIMP is specified via an interpreter I written as a CLP program. The first phase of our verification method consists in specializing I with respect to P, thereby deriving a specialized interpreter IP. Then, we specialize IP with respect to the property \u03d5 and the input values of P, with the aim of deriving a program whose least model can be computed as a finite set of constrained facts. To this purpose we introduce a novel generalization strategy which, during specialization, preserves the so called branching behaviour of the predicate definitions. We have fully automated our method and we have made its experimental evaluation on some examples taken from the literature. The evaluation shows that our method is competitive with respect to state-of-the-art software model checkers.", "num_citations": "2\n", "authors": ["1757"]}
{"title": "Semantics and Controllability of Time-Aware Business Processes\n", "abstract": " We present an operational semantics for time-aware business processes, that is, processes modeling the execution of business activities, whose durations are subject to linear constraints over the integers. We assume that some of the durations are controllable, that is, they can be determined by the organization that executes the process, while others are uncontrollable, that is, they are determined by the external world.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Proving theorems by program transformation\n", "abstract": " In this paper we present an overview of the unfold/fold proof method, a method for proving theorems about programs, based on program transformation. As a metalanguage for specifying programs and program properties we adopt constraint logic programming (CLP), and we present a set of transformation rules (including the familiar unfolding and folding rules) which preserve the semantics of CLP programs. Then, we show how program transformation strategies can be used, similarly to theorem proving tactics, for guiding the application of the transformation rules and inferring the properties to be proved. We work out three examples:(i) the proof of predicate equivalences, applied to the verification of equality between CCS processes,(ii) the proof of first order formulas via an extension of the quantifier elimination method, and (iii) the proof of temporal properties of infinite state concurrent systems, by using a\u00a0\u2026", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Verification of Imperative Programs by Transforming Constraint Logic Programs.\n", "abstract": " We present a method for verifying partial correctness properties of imperative programs that manipulate integers and arrays by using techniques based on the transformation of constraint logic programs (CLP). We use CLP as a metalanguage for representing imperative programs, their executions, and their properties. First, we encode the correctness of an imperative program, say prog, as the negation of a predicate incorrect defined by a CLP program T. By construction, incorrect holds in the least model of T if and only if the execution of prog from an initial configuration eventually halts in an error configuration. Then, we apply to program T a sequence of transformations that preserve its least model semantics. These transformations are based on well-known transformation rules, such as unfolding and folding, guided by suitable transformation strategies, such as specialization and generalization. The objective of the transformations is to derive a new CLP program TransfT where the predicate incorrect is defined either by (i) the fact \u2018incorrect.\u2019(and in this case prog is not correct), or by (ii) the empty set of clauses (and in this case prog is correct). In the case where we derive a CLP program such that neither (i) nor (ii) holds, we iterate the transformation. Since the problem is undecidable, this process may not terminate. We show through examples that our method can be applied in a rather systematic way, and is amenable to automation by transferring to the field of program verification many techniques developed in the field of program transformation.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Semantics of programming languages\n", "abstract": " In these lecture notes we present a few basic approaches to the definition of the semantics of programming languages. In particular, we present:(i) the operational semantics and the axiomatic semantics for a simple imperative language, and (ii) the operational semantics and the denotational semantics for some first order and higher order, typed functional languages. We then present some basic techniques for proving properties of imperative, functional, and concurrent programs. We closely follow the presentation done in the book by Glynn Winskel [19]. I express my gratitude to my colleagues at the Department of Informatics, Systems, and Production of the University of Roma Tor Vergata, and to my students and my co-workers Fabio Fioravanti, Fulvio Forni, Maurizio Proietti, and Valerio Senni for their support and encouragement. Thanks to Michele Ranieri and Massimiliano Macchia for pointing out some imprecisions in a preliminary version of these lecture notes.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "A folding rule for eliminating existential variables from constraint logic programs\n", "abstract": " The existential variables of a clause in a constraint logic program are the variables which occur in the body of the clause and not in its head. The elimination of these variables is a transformation technique which is often used for improving program efficiency and verifying program properties. We consider a folding transformation rule which ensures the elimination of existential variables and we propose an algorithm for applying this rule in the case where the constraints are linear inequations over rational or real numbers. The algorithm combines techniques for matching terms modulo equational theories and techniques for solving systems of linear inequations. Through some examples we show that an implementation of our folding algorithm has a good performance in practice.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Folding transformation rules for constraint logic programs\n", "abstract": " We consider the folding transformation rule for constraint logic programs. We propose an algorithm for applying the folding rule in the case where the constraints are linear equations and inequations over the rational or the real numbers. Basically, our algorithm consists in reducing a rule application to the solution of one or more systems of linear equations and inequations. We also introduce two variants of the folding transformation rule. The first variant combines the folding rule with the clause splitting rule, and the second variant eliminates the existential variables of a clause, that is, those variables which occur in the body of the clause and not in its head. Finally, we present the algorithms for applying these variants of the folding rule.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Proofs of Program Properties via Unfold/Fold Transformations of Constraint Logic Programs\n", "abstract": " In the literature there are various papers which illustrate the relationship between the unfold/fold program transformation techniques and the proofs of program properties both in the case of logic programs and in the case of functional programs. In this paper we illustrate that relationship in the case of constraint logic programs. We build up on results already presented, ie, where we have considered logic programs with locally stratified negation. The constraint logic programming paradigm significantly extends the logic-programming paradigm by allowing some of the atoms to denote constraints in a suitably chosen constraint domain. By using those constraints it is often possible to get simple and direct formulations of problem solutions.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Automatic proofs of protocols via program transformation\n", "abstract": " We propose a method for the specification and the automated verification of temporal properties of protocols which regulate the activities of multiagent systems. The set of states of those systems may be infinite so that, in general, the verification of a property of a multiagent system cannot be performed by an exhaustive inspection. We specify a given multiagent system by means of a constraint logic program P with locally stratified negation, and we specify a given temporal property to be verified by means of an atomic formula A. In order to verify that the given temporal property holds, we transform the program P into an equivalent program T such that the fact A \u2190 belongs to T. Our transformation method consists of a set of rules and an automatic strategy that guides the application of the rules. Our method is sound for verifying properties of protocols that are expressible in the CTL logic [5]. Although our method\u00a0\u2026", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Quaderni di informatica\n", "abstract": " Questo libro \u00e8 indirizzato in modo particolare, ma non esclusivo, agli studenti del corso di Programmazione dei Calcolatori Elettronici. Esso serve a completare la trattazione di alcuni argomenti non sufficientemente sviluppati in altri libri di testo, quali, ad esempio: N. Wirth:\u201cAlgorithms+ Data Structures= Programs\u201d Prentice Hall (1976) e J. Welsh and J. Elder:\u201cIntroduction to Pascal\u201d Prentice Hall (1986).Il materiale presentato \u00e8 relativo ad alcuni aspetti fondamentali dell\u2019arte della programmazione. Di essi sono stati messi in luce i principi logici e quelli algebrici. Tra gli scopi del libro c\u2019\u00e8 anche quello di indicare al lettore che la programmazione non \u00e8 frutto di piccole invenzioni o di trucchi ad hoc. Essa \u00e8 parte della matematica, forse di una matematica non molto conosciuta.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Theory of Computation\n", "abstract": " These lecture notes introduce the reader to some basic notions of Analysis of Algorithms and Complexity Theory. They are based on the references listed at the end of each chapter. We also derived some material from the notes of a course given by L. Valiantat Edinburgh, Scotland, in 1979.In the first chapter we look at sorting and searching algorithms and we study their complexity. The second chapter is devoted to the backtracking technique for exploring search spaces of various kinds. In the third chapter we present some preliminary notions of computational complexity, including NP and NP-complete problems. Finally, in the last chapter we consider the digital Fourier Transform and the problem of fast integer, polynomial, and matrix multiplication.", "num_citations": "1\n", "authors": ["1757"]}
{"title": "Universal models in categories for process synchronization\n", "abstract": " In the first part of the paper we show how to construct categorical models for Milner's CCS [Mil80], Hoare's CSP [Hoa78], and similarly defined calculi for synchronized and parallel computations.             We consider a generic category C of processes with morphisms which are labelled by strings of actions belonging to a monoid A. We define the synchronization between two processes in C as a functor (if it exists) from a subcategory of C \u00d7 C into C. We introduce the notions of categorical semantics and good categorical semantics for processes.             In the second part of the paper we show that the Categories of Trees we will define, is optimal for most synchronizations described in the literature. That result is presented also in the framework of the Enriched Category Theory [Law74] for indicating its meaning in terms of an internal logic [Law74].", "num_citations": "1\n", "authors": ["1757"]}
{"title": "On the definition of hierarchies of infinite sequential computations.\n", "abstract": " A method for defining hierarchies of infinite sequential comput ations is introduced. We applied the method to computations defined in Weak Combinatory Logic and we showed that it is useful for studying term ination and non-termination properties of subrecursive classes of algor-ithms.", "num_citations": "1\n", "authors": ["1757"]}