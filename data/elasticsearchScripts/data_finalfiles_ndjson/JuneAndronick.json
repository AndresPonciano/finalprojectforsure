{"title": "seL4: Formal verification of an OS kernel\n", "abstract": " Complete formal verification is the only known way to guarantee that a system is free of programming errors.", "num_citations": "2295\n", "authors": ["675"]}
{"title": "Using Coq to Verify Java CardTM Applet Isolation Properties\n", "abstract": " This paper reports on the use of the Coq proof assistant for the formal verification of applet isolation properties in Java Card technology. We focus on the confidentiality property. We show how this property is verified by the card manager and the APIs, extending our former proof addressing the Java Card virtual machine. We also show how our verification method allows to complete specifications and to enhance the secure design of the platform. For instance, we describe how the proof of the integrity puts the light on a known bug. Finally, we present the benefits of the use of high order modelling to handle the complexity of the system, to prove security properties and eventually to construct generic re-usable proof architectures.", "num_citations": "35\n", "authors": ["675"]}
{"title": "Towards Proving Security in the Presence of Large Untrusted Components.\n", "abstract": " Towards proving security in the presence of large untrusted components Page 1 Towards proving security in the presence of large untrusted components June Andronick David Greenaway Kevin Elphinstone Page 2 NICTA Copyright 2010 From imagination to impact Computers and Trust 2 Page 3 NICTA Copyright 2010 From imagination to impact Computers and Trust 2 Page 4 NICTA Copyright 2010 From imagination to impact Computers and Trust 3 Page 5 NICTA Copyright 2010 From imagination to impact Computers and Trust 3 Page 6 NICTA Copyright 2010 From imagination to impact Computers and Trust 3 Page 7 NICTA Copyright 2010 From imagination to impact Computers and Trust \u2022 Advances in formal methods techniques give us hope \u2022 The seL4 microkernel is one such example: around 10 thousand lines of code formally proven \u2013 approximately 25 person years of effort 4 Page 8 \u2022 A typical smartphone \u2026", "num_citations": "28\n", "authors": ["675"]}
{"title": "Formal verification of security properties of smart card embedded source code\n", "abstract": " This paper reports on a method to handle the verification of various security properties of imperative source code embedded on smart cards. The idea is to combine two program verification approaches: the functional verification at the source code level and the verification of high level properties on a formal model built from the program and its specification. The method presented uses the Caduceus tool, built on top of the Why tool. Caduceus enables the verification of an annotated C program and provides a validation process that we used to generate a high level formal model of the C source code. This method is illustrated by an example extracted from the verification of a smart card embedded operating system.", "num_citations": "23\n", "authors": ["675"]}
{"title": "An Access Control Model Based Testing Approach for Smart Card Applications: Results of the {POS\u00c9} Project\n", "abstract": " This paper is about generating security tests from the Common Criteria expression of a security policy, in addition to functional tests previously generated by a model-based testing approach. The method that we present re-uses the functional model and the concretization layer developed for the functional testing, and relies on an additional security policy model. We discuss how to produce the security policy model from a Common Criteria security target. We propose to compute the tests by using some test purposes as guides for the tests to be extracted from the models. We see a test purpose as the combination of a security property and a test need issued from the know-how of a security engineer. We propose a language based on regular expressions for the expression of such test purposes. We illustrate our approach by means of the IAS case study, a smart card application dedicated to the operations of Identification, Authentication and electronic Signature.", "num_citations": "21\n", "authors": ["675"]}
{"title": "Proof of OS scheduling behavior in the presence of interrupt-induced concurrency\n", "abstract": " We present a simple yet scalable framework for formal reasoning and machine-assisted proof of interrupt-driven concurrency in operating-system code, and use it to prove the principal scheduling property of the embedded, real-time eChronos OS: that the running task is always the highest-priority runnable task. The key differentiator of this verification is that the OS code itself runs with interrupts on, even within the scheduler, to minimise latency. Our reasoning includes context switching, interleaving with interrupt handlers and nested interrupts; and it is formalised in Isabelle/HOL, building on the Owicki-Gries method for fine-grained concurrency. We add support for explicit concurrency control and the composition of multiple independently-proven invariants. Finally, we discuss how scalability issues are addressed with proof engineering techniques, in order to handle thousands of proof obligations.", "num_citations": "20\n", "authors": ["675"]}
{"title": "Controlled Owicki-Gries concurrency: Reasoning about the preemptible eChronos embedded operating system\n", "abstract": " We introduce a controlled concurrency framework, derived from the Owicki-Gries method, for describing a hardware interface in detail sufficient to support the modelling and verification of small, embedded operating systems (OS's) whose run-time responsiveness is paramount. Such real-time systems run with interrupts mostly enabled, including during scheduling. That differs from many other successfully modelled and verified OS's that typically reduce the complexity of concurrency by running on uniprocessor platforms and by switching interrupts off as much as possible. Our framework builds on the traditional Owicki-Gries method, for its fine-grained concurrency is needed for high-performance system code. We adapt it to support explicit concurrency control, by providing a simple, faithful representation of the hardware interface that allows software to control the degree of interleaving between user code, OS code, interrupt handlers and a scheduler that controls context switching. We then apply this framework to model the interleaving behavior of the eChronos OS, a preemptible real-time OS for embedded micro-controllers. We discuss the accuracy and usability of our approach when instantiated to model the eChronos OS. Both our framework and the eChronos model are formalised in the Isabelle/HOL theorem prover, taking advantage of the high level of automation in modern reasoning tools.", "num_citations": "20\n", "authors": ["675"]}
{"title": "Complx: A verification framework for concurrent imperative programs\n", "abstract": " We propose a concurrency reasoning framework for imperative programs, based on the Owicki-Gries (OG) foundational shared-variable concurrency method. Our framework combines the approaches of Hoare-Parallel, a formalisation of OG in Isabelle/HOL for a simple while-language, and Simpl, a generic imperative language embedded in Isabelle/HOL, allowing formal reasoning on C programs. We define the Complx language, extending the syntax and semantics of Simpl with support for parallel composition and synchronisation. We additionally define an OG logic, which we prove sound wrt the semantics, and a verification condition generator, both supporting involved low-level imperative constructs such as function calls and abrupt termination. We illustrate our framework on an example that features exceptions, guards and function calls. We aim to then target concurrent operating systems, such as the\u00a0\u2026", "num_citations": "13\n", "authors": ["675"]}
{"title": "Formally proved anti-tearing properties of embedded C code\n", "abstract": " In smart card embedded programs, some operations must not be suddenly interrupted, because if they are, the card is left in an inconsistent state. Since the card can be removed at any time from the terminal, which interrupts any running program, some instructions must be executed at each reset in order to verify if a tearing occurred and to restore a consistent state if necessary. In this case, the card is said to ensure the anti-tearing property. This paper presents a method to formally prove that a C program verifies the anti-tearing property for a given \"tearing- sensitive\" operation. The background methodology, presented in (J. Andronick, 2006), (J. Andronick et al., 2005), enables to prove global properties from source code. It is here illustrated by the proof of anti-tearing properties, which requires an extension of the method in order to specify and verify functions behaviour in the case of a sudden interruption of their\u00a0\u2026", "num_citations": "12\n", "authors": ["675"]}
{"title": "Modelisation et Verification Formelles de Systemes Embarqu\u00e9s dans les Cartes \u00e0 Microprocesseur\u2013Plate-Forme Java Card et Syst\u00e8me d'Exploitation\n", "abstract": " The work presented in this thesis aims at strengthening the security and safety level of smart card embedded systems, with the use of Formal Methods. On one hand, we present the formal verification of the isolation of the data belonging to different applets loaded on the same card. More precisely, we describe the formal proof, in the Coq proof system, that the run-time access control, performed by the Java Card platform, ensures data confidentiality and integrity. On the other hand, we study the correctness and the safety of low level source code of an embedded operating system. Such source code is illustrated by a case study of a Flash memory management module, using a journalling mechanism and ensuring the memory consistency in the case of a card tear. The verification of functional and local properties has been developed using the Caduceus program verification tool. Since this tool does not support some\u00a0\u2026", "num_citations": "9\n", "authors": ["675"]}
{"title": "Certifying an embedded remote method invocation protocol\n", "abstract": " This paper describes an approach to formally prove that an implementation of the Java Card Remote Method Invocation protocol on smart cards fulfills its functional and security specification. For that, we refine the specification in two intermediate formal models: the functional specification and the high level design. These two models are both defined upon an existing complete formal model of the Java Card virtual machine, allowing to formalize all the security requirements. We focus on certifying the Java code portion since the native portion has been handled in a previous work. The correctness is showed to be preserved while composing the native and Java codes. Our refinement scheme has been designed to fulfill the requirements of a high-level Common Criteria security evaluation.", "num_citations": "4\n", "authors": ["675"]}
{"title": "Successes in deployed verified software (and insights on key social factors)\n", "abstract": " In this talk, we will share our experience in the successful deployment of verified software in a wide range of application domains, and, importantly, our insights on the key factors enabling such successful deployment, in particular the importance of the social aspects of a group working effectively together. Our formally verified microkernel, seL4, is now used across the world in a number of applications that keeps growing. Our experience is that such an uptake is enabled not only by a technical strategy, but also by a tight integration of people from multiple disciplines and with both research and engineering profiles. This requires a strong social culture, with well designed processes, for working as one unified team. We share our observations on what concrete social structures have been key for us in creating real-world impact from research breakthroughs.", "num_citations": "1\n", "authors": ["675"]}
{"title": "A Million Lines of Proof About a Moving Target (Invited Talk)\n", "abstract": " In the last ten years, we have been porting, maintaining, and evolving the world's largest proof base, the formal proof in Isabelle/HOL of the seL4 microkernel. But actually, there is no such thing as\" the seL4 proof\"; there are a number of proofs (functional correctness, binary translation validation, integrity and confidentiality proofs, etc) about a number of instances of seL4 (depending on the hardware platform it runs on, the features it includes, the extensions it supports). We will give an overview of the current state of these proofs, and, importantly, the challenges we face in keeping to maintain, evolve and extend them, and the processes we have put in place to manage their dependence on the evolving implementation.", "num_citations": "1\n", "authors": ["675"]}
{"title": "From a proven correct microkernel to trustworthy large systems\n", "abstract": " The seL4 microkernel was the world\u2019s first general-purpose operating system kernel with a formal, machine-checked proof of correctness. The next big step in the challenge of building truly trustworthy systems is to provide a framework for developing secure systems on top of seL4. This paper first gives an overview of seL4\u2019s correctness proof, together with its main implications and assumptions, and then describes our approach to provide formal security guarantees for large, complex systems.", "num_citations": "1\n", "authors": ["675"]}