{"title": "Dynamine: finding common error patterns by mining software revision histories\n", "abstract": " A great deal of attention has lately been given to addressing software bugs such as errors in operating system drivers or security bugs. However, there are many other lesser known errors specific to individual applications or APIs and these violations of application-specific coding rules are responsible for a multitude of errors. In this paper we propose DynaMine, a tool that analyzes source code check-ins to find highly correlated method calls as well as common bug fixes in order to automatically discover application-specific coding patterns. Potential patterns discovered through mining are passed to a dynamic analysis tool for validation; finally, the results of dynamic analysis are presented to the user.The combination of revision history mining and dynamic analysis techniques leveraged in DynaMine proves effective for both discovering new application-specific patterns and for finding errors when applied to very\u00a0\u2026", "num_citations": "483\n", "authors": ["143"]}
{"title": "Persuasive technology in the real world: a study of long-term use of activity sensing devices for fitness\n", "abstract": " Persuasive technology to motivate healthy behavior is a growing area of research within HCI and ubiquitous computing. The emergence of commercial wearable devices for tracking health-and fitness-related activities arguably represents the first widespread adoption of dedicated ubiquitous persuasive technology. The recent ubiquity of commercial systems allows us to learn about their value and use in truly\" in the wild\" contexts and understand how practices evolve over long-term, naturalistic use. We present a study with 30 participants who had adopted wearable activity-tracking devices of their own volition and had continued to use them for between 3 and 54 months. The findings, which both support and contrast with those of previous research, paint a picture of the evolving benefits and practices surrounding these emerging technologies over long periods of use. They also serve as the basis for design\u00a0\u2026", "num_citations": "456\n", "authors": ["143"]}
{"title": "Preprocessing CVS Data for Fine-Grained Analysis.\n", "abstract": " All analyses of version archives have one phase in common: the preprocessing of data. Preprocessing has a direct impact on the quality of the results returned by an analysis. In this paper we discuss four essential preprocessing tasks necessary for a fine-grained analysis of CVS archives:(a) data extraction,(b) transaction recovery,(c) mapping of changes to fine-grained entities, and (d) data cleaning. We formalize the concept of sliding time windows and show how commit mails can relate revisions to transactions. We also present two approaches that map changes to the affected building blocks of a file, eg functions or sections.", "num_citations": "322\n", "authors": ["143"]}
{"title": "Information needs in bug reports: improving cooperation between developers and users\n", "abstract": " For many software projects, bug tracking systems play a central role in supporting collaboration between the developers and the users of the software. To better understand this collaboration and how tool support can be improved, we have quantitatively and qualitatively analysed the questions asked in a sample of 600 bug reports from the MOZILLA and ECLIPSE projects. We categorised the questions and analysed response rates and times by category and project. Our results show that the role of users goes beyond simply reporting bugs: their active and ongoing participation is important for making progress on the bugs they report. Based on the results, we suggest four ways in which bug tracking systems can be improved.", "num_citations": "260\n", "authors": ["143"]}
{"title": "Extraction of bug localization benchmarks from history\n", "abstract": " Researchers have proposed a number of tools for automatic bug localization. Given a program and a description of the failure, such tools pinpoint a set of statements that are most likely to contain the bug. Evaluating bug localization tools is a difficult task because existing benchmarks are limited in size of subjects and number of bugs. In this paper we present iBUGS, an approach that semiautomatically extracts benchmarks for bug localization from the history of a project. For ASPECTJ, we extracted 369 bugs, 223 out of these had associated test cases. We demonstrate the relevance of our dataset with a case study on the bug localization tool AMPLE", "num_citations": "251\n", "authors": ["143"]}
{"title": "Information needs for software development analytics\n", "abstract": " Software development is a data rich activity with many sophisticated metrics. Yet engineers often lack the tools and techniques necessary to leverage these potentially powerful information resources toward decision making. In this paper, we present the data and analysis needs of professional software engineers, which we identified among 110 developers and managers in a survey. We asked about their decision making process, their needs for artifacts and indicators, and scenarios in which they would use analytics. The survey responses lead us to propose several guidelines for analytics tools in software development including: Engineers do not necessarily have much expertise in data analysis; thus tools should be easy to use, fast, and produce concise output. Engineers have diverse analysis needs and consider most indicators to be important; thus tools should at the same time support many different types of\u00a0\u2026", "num_citations": "236\n", "authors": ["143"]}
{"title": "Analyze this! 145 questions for data scientists in software engineering\n", "abstract": " In this paper, we present the results from two surveys related to data science applied to software engineering. The first survey solicited questions that software engineers would like data scientists to investigate about software, about software processes and practices, and about software engineers. Our analyses resulted in a list of 145 questions grouped into 12 categories. The second survey asked a different pool of software engineers to rate these 145 questions and identify the most important ones to work on first. Respondents favored questions that focus on how customers typically use their applications. We also saw opposition to questions that assess the performance of individual employees or compare them with one another. Our categorization and catalog of 145 questions can help researchers, practitioners, and educators to more easily focus their efforts on topics that are important to the software industry.", "num_citations": "206\n", "authors": ["143"]}
{"title": "Software developers' perceptions of productivity\n", "abstract": " The better the software development community becomes at creating software, the more software the world seems to demand. Although there is a large body of research about measuring and investigating productivity from an organizational point of view, there is a paucity of research about how software developers, those at the front-line of software construction, think about, assess and try to improve their productivity. To investigate software developers' perceptions of software development productivity, we conducted two studies: a survey with 379 professional software developers to help elicit themes and an observational study with 11 professional software developers to investigate emergent themes in more detail. In both studies, we found that developers perceive their days as productive when they complete many or big tasks without significant interruptions or context switches. Yet, the observational data we\u00a0\u2026", "num_citations": "182\n", "authors": ["143"]}
{"title": "The emerging role of data scientists on software development teams\n", "abstract": " Creating and running software produces large amounts of raw data about the development process and the customer usage, which can be turned into actionable insight with the help of skilled data scientists. Unfortunately, data scientists with the analytical and software engineering skills to analyze these large data sets have been hard to come by; only recently have software companies started to develop competencies in software-oriented data analytics. To understand this emerging role, we interviewed data scientists across several product groups at Microsoft. In this paper, we describe their education and training background, their missions in software engineering contexts, and the type of problems on which they work. We identify five distinct working styles of data scientists: (1) Insight Providers, who work with engineers to collect the data needed to inform decisions that managers make; (2) Modeling Specialists\u00a0\u2026", "num_citations": "180\n", "authors": ["143"]}
{"title": "Software analytics: so what?\n", "abstract": " The guest editors of this special issue of IEEE Software invited submissions that reflected the benefits (and drawbacks) of software analytics, an area of explosive growth. They had so many excellent submissions that they had to split this special issue into two volumes--you'll see even more content in the September/October issue. They divided the articles on conceptual grounds, so both volumes will feature equally excellent work. The Web extra at http://youtu.be/nO6X0azR0nw is a video interview in which IEEE Software editor in chief Forrest Shull speaks with Tim Menzies about the growing importance of software analytics.", "num_citations": "159\n", "authors": ["143"]}
{"title": "Social media for software engineering\n", "abstract": " Social media has changed the way that people collaborate and share information. In this paper, we highlight its impact for enabling new ways for software teams to form and work together. Individuals will self-organize within and across organizational boundaries. Grassroots software development communities will emerge centered around new technologies, common processes and attractive target markets. Companies consisting of lone individuals will able to leverage social media to conceive of, design, develop, and deploy successful and profitable product lines. A challenge for researchers who are interested in studying, influencing, and supporting this shift in software teaming is to make sure that their research methods protect the privacy and reputation of their stakeholders.", "num_citations": "148\n", "authors": ["143"]}
{"title": "Mining aspects from version history\n", "abstract": " Aspect raining identifies cross-culling concerns in a program, to help migrating it to an aspect-oriented design. Such concerns may not exist from the beginning, but emerge over time. By analysing where developers add code to a program, our history-based aspect mining (BAM) identifies and ranks cross-cutting concerns. We evaluated the effectiveness of our approach with the history of three open-source projects. BAM scales up to Industrial-sized projects: for example, we were able to identify a locking concern that cross-cuts 1284 methods in Eclipse. Additionally, the precision of HAM increases with project size and history: for Eclipse, it reaches 90% for the top-10 candidates", "num_citations": "147\n", "authors": ["143"]}
{"title": "Security trend analysis with cve topic models\n", "abstract": " We study the vulnerability reports in the Common Vulnerability and Exposures (CVE) database by using topic models on their description texts to find prevalent vulnerability types and new trends semi-automatically. In our study of the 39,393 unique CVEs until the end of 2009, we identify the following trends, given here in the form of a weather forecast: PHP: declining, with occasional SQL injection. Buffer Overflows: flattening out after decline. Format Strings: in steep decline. SQL Injection and XSS: remaining strong, and rising. Cross-Site Request Forgery: a sleeping giant perhaps, stirring. Application Servers: rising steeply.", "num_citations": "131\n", "authors": ["143"]}
{"title": "Assessing the value of branches with what-if analysis\n", "abstract": " Branches within source code management systems (SCMs) allow a software project to divide work among its teams for concurrent development by isolating changes. However, this benefit comes with several costs: increased time required for changes to move through the system and pain and error potential when integrating changes across branches. In this paper, we present the results of a survey to characterize how developers use branches in a large industrial project and common problems that they face. One of the major problems mentioned was the long delay that it takes changes to move from one team to another, which is often caused by having too many branches (branchmania). To monitor branch health, we introduce a novel what-if analysis to assess alternative branch structures with respect to two properties, isolation and liveness. We demonstrate with several scenarios how our what-if analysis can\u00a0\u2026", "num_citations": "126\n", "authors": ["143"]}
{"title": "Mining usage expertise from version archives\n", "abstract": " In software development, there is an increasing need to find and connect developers with relevant expertise. Existing expertise recommendation systems are mostly based on variations of the Line 10 Rule: developers who changed a file most often have the most implementation expertise. In this paper, we introduce the concept of usage expertise, which manifests itself whenever developers are using functionality, eg, by calling API methods. We present preliminary results for the ECLIPSE project that demonstrate that our technique allows to recommend experts for files with no or little history, identify developers with similar expertise, and measure the usage of API methods.", "num_citations": "126\n", "authors": ["143"]}
{"title": "Data scientists in software teams: State of the art and challenges\n", "abstract": " The demand for analyzing large scale telemetry, machine, and quality data is rapidly increasing in software industry. Data scientists are becoming popular within software teams, e.g., Facebook, LinkedIn and Microsoft are creating a new career path for data scientists. In this paper, we present a large-scale survey with 793 professional data scientists at Microsoft to understand their educational background, problem topics that they work on, tool usages, and activities. We cluster these data scientists based on the time spent for various activities and identify 9 distinct clusters of data scientists, and their corresponding characteristics. We also discuss the challenges that they face and the best practices they share with other data scientists. Our study finds several trends about data scientists in the software engineering context at Microsoft, and should inform managers on how to leverage data science capability effectively\u00a0\u2026", "num_citations": "110\n", "authors": ["143"]}
{"title": "Improving developer participation rates in surveys\n", "abstract": " Doing high quality research about the human side of software engineering necessitates the participation of real software developers in studies, but getting high levels of participation is a challenge for software engineering researchers. In this paper, we discuss several factors that software engineering researchers can use when recruiting participants, drawn from a combination of general research on survey design, research on persuasion, and our experience in conducting surveys. We study these factors by performing post-hoc analysis on several previously conducted surveys. Our results provide insight into the factors associated with increased response rates, which are neither wholly composed of factors associated strictly with persuasion research, nor those of conventional wisdom in software engineering.", "num_citations": "104\n", "authors": ["143"]}
{"title": "Improving bug tracking systems\n", "abstract": " It is important that information provided in bug reports is relevant and complete in order to help resolve bugs quickly. However, often such information trickles to developers after several iterations of communication between developers and reporters. Poorly designed bug tracking systems are partly to blame for this exchange of information being stretched over time. Our paper addresses the concerns of bug tracking systems by proposing four broad directions for enhancements. As a proof-of-concept, we also demonstrate a prototype interactive bug tracking system that gathers relevant information from the user and identifies files that need to be fixed to resolve the bug.", "num_citations": "95\n", "authors": ["143"]}
{"title": "The work life of developers: Activities, switches and perceived productivity\n", "abstract": " Many software development organizations strive to enhance the productivity of their developers. All too often, efforts aimed at improving developer productivity are undertaken without knowledge about how developers spend their time at work and how it influences their own perception of productivity. To fill in this gap, we deployed a monitoring application at 20 computers of professional software developers from four companies for an average of 11 full work day in situ. Corroborating earlier findings, we found that developers spend their time on a wide variety of activities and switch regularly between them, resulting in highly fragmented work. Our findings extend beyond existing research in that we correlate developers' work habits with perceived productivity and also show productivity is a personal matter. Although productivity is personal, developers can be roughly grouped into morning, low-at-lunch and afternoon\u00a0\u2026", "num_citations": "91\n", "authors": ["143"]}
{"title": "Discovering and exploiting relationships in software repositories\n", "abstract": " Software development items can be represented in a graph data structure. Relationships between the represented items can be detected and reflected in the graph data structure. Queries can be run against the data structure to determine which software development items are related to each other. Implicit query can be implemented in a software development context. A graph browser can present panes showing related items.", "num_citations": "89\n", "authors": ["143"]}
{"title": "The art and science of analyzing software data\n", "abstract": " The Art and Science of Analyzing Software Data provides valuable information on analysis techniques often used to derive insight from software data. This book shares best practices in the field generated by leading data scientists, collected from their experience training software engineering students and practitioners to master data science. The book covers topics such as the analysis of security data, code reviews, app stores, log files, and user telemetry, among others. It covers a wide variety of techniques such as co-change analysis, text analysis, topic analysis, and concept analysis, as well as advanced topics such as release planning and generation of source code comments. It includes stories from the trenches from expert data scientists illustrating how to apply data analysis in industry and open source, present results to stakeholders, and drive decisions. Presents best practices, hints, and tips to analyze data and apply tools in data science projects Presents research methods and case studies that have emerged over the past few years to further understanding of software data Shares stories from the trenches of successful data science initiatives in industry", "num_citations": "73\n", "authors": ["143"]}
{"title": "Expert recommendation with usage expertise\n", "abstract": " Global and distributed software development increases the need to find and connect developers with relevant expertise. Existing recommendation systems typically model expertise based on file changes (implementation expertise). While these approaches have shown success, they require a substantial recorded history of development for a project. Previously, we have proposed the concept of usage expertise, i.e., expertise manifested through the act of calling (using) a method. In this paper, we assess the viability of this concept by evaluating expert recommendations for the ASPECTJ and ECLIPSE projects. We find that both usage and implementation expertise have comparable levels of accuracy, which suggests that usage expertise may be used as a substitute measure. We also find a notable overlap of method calls across both projects, which suggests that usage expertise can be leveraged to recommend\u00a0\u2026", "num_citations": "72\n", "authors": ["143"]}
{"title": "Quantifying developers' adoption of security tools\n", "abstract": " Security tools could help developers find critical vulnerabilities, yet such tools remain underused. We surveyed developers from 14 companies and 5 mailing lists about their reasons for using and not using security tools. The resulting thirty-nine predictors of security tool use provide both expected and unexpected insights. As we expected, developers who perceive security to be important are more likely to use security tools than those who do not. But that was not the strongest predictor of security tool use, it was instead developers' ability to observe their peers using security tools.", "num_citations": "71\n", "authors": ["143"]}
{"title": "Analytics for software development\n", "abstract": " Despite large volumes of data and many types of metrics, software projects continue to be difficult to predict and risky to conduct. In this paper we propose software analytics which holds out the promise of helping the managers of software projects turn their plentiful information resources, produced readily by current tools, into insights they can act on. We discuss how analytics works, why it's a good fit for software engineering, and the research problems that must be overcome in order to realize its promise.", "num_citations": "65\n", "authors": ["143"]}
{"title": "Mining workspace updates in CVS\n", "abstract": " The version control archive CVS records not only all changes in a project but also activity data such as when developers create or update their workspaces. Furthermore, CVS records when it has to integrate changes because of parallel development. In this paper, we analyze the CVS activity data of four large open-source projects CCC, JBOSS, JEDIT, and PYTHON to investigate parallel development: What is the degree of parallel development? How frequently do conflicts occur during updates and how are they resolved? How do we identify changes that contain integrations?", "num_citations": "61\n", "authors": ["143"]}
{"title": "How documentation evolves over time\n", "abstract": " Good source code documentation, especially of programming interfaces, is essential for using and maintaining software components. In this paper, we present the Quasoledo tool that automatically measures the quality of documentation with respect to completeness, quantity, and readability. We applied our set of metrics to the Eclipse project, and benchmarked against the well-documented Java class library. The result of Quasoledo is a map of documentation quality in Eclipse, showing the best documentation for its core components. Additionally, we looked at the evolution of Eclipse and identified batch updates that caused jumps in documentation quality. For Eclipse, only 32.6% of all changes touched documentation.", "num_citations": "51\n", "authors": ["143"]}
{"title": "The Beauty and the Beast: Vulnerabilities in Red Hat's Packages.\n", "abstract": " In an empirical study of 3241 Red Hat packages, we show that software vulnerabilities correlate with dependencies between packages. With formal concept analysis and statistical hypothesis testing, we identify dependencies that decrease the risk of vulnerabilities (\u201cbeauties\u201d) or increase the risk (\u201cbeasts\u201d). Using support vector machines on dependency data, our prediction models successfully and consistently catch about two thirds of vulnerable packages (median recall of 0.65). When our models predict a package as vulnerable, it is correct more than eight times out of ten (median precision of 0.83). Our findings help developers to choose new dependencies wisely and make them aware of risky dependencies.", "num_citations": "47\n", "authors": ["143"]}
{"title": "Predicting software build errors\n", "abstract": " Systems and methods for predicting a software build error are described herein. In one example, a method includes detecting a plurality of changes in software. The method also includes identifying a plurality of change lists, wherein a change list is identified for each of the plurality of changes in the software. Additionally, the method includes identifying a characteristic for each change list in the plurality of change lists. Furthermore, the method includes calculating a plurality of probabilities based at least in part on the characteristic of each of the plurality of change lists, wherein each of the probabilities indicates the likelihood of one of the plurality of change lists creating the software build error. The method also includes reporting the plurality of probabilities of the software build error.", "num_citations": "44\n", "authors": ["143"]}
{"title": "Fine-grained processing of CVS archives with APFEL\n", "abstract": " In this paper, we present the APFEL plug-in that collects fine-grained changes from version archives in a database. APFEL is built upon the Eclipse infrastructure for CVS and Java. In order to describe changes, APFEL uses tokens such as method calls, exceptions, and variable usages. We demonstrate the usefulness of APFEL's database with several case studies.", "num_citations": "41\n", "authors": ["143"]}
{"title": "Card-sorting: From text to themes\n", "abstract": " Suppose you just ran a survey with the question \u201cWhat problems are stopping us from meeting our deadlines?\u201d Since you didn\u2019t know the problems in advance, you asked participants to simply write the problems into a textbox. This type of question is called an open-ended question; in contrast to closed-ended questions, which limit participants to a list of predefined answer choices. Your survey was very successful and you received hundreds of responses. Now you want to make sense of the data. How can you do this in a systematic way? In this essay, I will show you how card sorting can infer themes from text responses. You will learn everything you need to know for your first card sort.", "num_citations": "34\n", "authors": ["143"]}
{"title": "Mining eclipse for cross-cutting concerns\n", "abstract": " Software may contain functionality that does not align with its architecture. Such cross-cutting concerns do not exist from the beginning but emerge over time. By analysing where developers add code to a program, our history-based mining identifies cross-cutting concerns in a two-step process. First, we mine CVS archives for sets of methods where a call to a specific single method was added. In a second step, such simple cross-cutting concerns are combined to complex cross-cutting concerns. To compute these efficiently, we apply formal concept analysis---an algebraic theory. History-based mining scales well: we are the first to report aspects mined from an industrial-sized project like ECLIPSE. For example, we identified a locking concern that crosscuts 1284 methods.", "num_citations": "34\n", "authors": ["143"]}
{"title": "Design recommendations for self-monitoring in the workplace: Studies in software development\n", "abstract": " One way to improve the productivity of knowledge workers is to increase their self-awareness about productivity at work through self-monitoring. Yet, little is known about expectations of, the experience with, and the impact of self-monitoring in the workplace. To address this gap, we studied software developers, as one community of knowledge workers. We used an iterative, user-feedback-driven development approach (N=20) and a survey (N=413) to infer design elements for workplace self-monitoring, which we then implemented as a technology probe called WorkAnalytics. We field-tested these design elements during a three-week study with software development professionals (N=43). Based on the results of the field study, we present design recommendations for self-monitoring in the workplace, such as using experience sampling to increase the awareness about work and to create richer insights, the need for\u00a0\u2026", "num_citations": "29\n", "authors": ["143"]}
{"title": "The effect of work environments on productivity and satisfaction of software engineers\n", "abstract": " The physical work environment of software engineers can have various effects on their satisfaction and the ability to get the work done. To better understand the factors of the environment that affect productivity and satisfaction of software engineers, we explored different work environments at Microsoft. We used a mixed-methods, multiple stage research design with a total of 1,159 participants: two surveys with 297 and 843 responses respectively and interviews with 19 employees. We found several factors that were considered as important for work environments: personalization, social norms and signals, room composition and atmosphere, work-related environment affordances, work area and furniture, and productivity strategies. We built statistical models for satisfaction with the work environment and perceived productivity of software engineers and compared them to models for employees in the Program\u00a0\u2026", "num_citations": "26\n", "authors": ["143"]}
{"title": "Understanding and improving software build teams\n", "abstract": " Build, creating software from source code, is a fundamental activity in software development. Build teams manage this process and ensure builds are produced reliably and efficiently. This paper presents an exploration into the nature of build teams--how they form, work, and relate to other teams--through three multi-method studies conducted at Microsoft. We also consider build team effectiveness and find that many challenges are social, not technical: role ambiguity, knowledge sharing, communication, trust, and conflict. Our findings validate theories from group dynamics and organization science, and using a cross-discipline approach, we apply learnings from these fields to inform the design of engineering tools and practices to improve build team effectiveness", "num_citations": "26\n", "authors": ["143"]}
{"title": "Rethinking productivity in software engineering\n", "abstract": " Get the most out of this foundational reference and improve the productivity of your software teams. This open access book collects the wisdom of the 2017 \"Dagstuhl\" seminar on productivity in software engineering, a meeting of community leaders, who came together with the goal of rethinking traditional definitions and measures of productivity. The results of their work, Rethinking Productivity in Software Engineering, includes chapters covering definitions and core concepts related to productivity, guidelines for measuring productivity in specific contexts, best practices and pitfalls, and theories and open questions on productivity. You'll benefit from the many short chapters, each offering a focused discussion on one aspect of productivity in software engineering. Readers in many fields and industries will benefit from their collected work. Developers wanting to improve their personal productivity, will learn effective strategies for overcoming common issues that interfere with progress. Organizations thinking about building internal programs for measuring productivity of programmers and teams will learn best practices from industry and researchers in measuring productivity. And researchers can leverage the conceptual frameworks and rich body of literature in the book to effectively pursue new research directions. What You'll Learn Review the definitions and dimensions of software productivity See how time management is having the opposite of the intended effect Develop valuable dashboards Understand the impact of sensors on productivity Avoid software development waste Work with human-centered methods to measure productivity Look at\u00a0\u2026", "num_citations": "25\n", "authors": ["143"]}
{"title": "A perspective on blending programming environments and games: Beyond points, badges, and leaderboards\n", "abstract": " Programming environments and game environments share many of the same characteristics, such as requiring their users to understand strategies and solve difficult challenges. Yet, only game designers have been able to capitalize on methods that are consistently able to keep their users engaged. Consequently, software engineers have been increasingly interested in understanding how these game experiences can be transferred to programming experiences, a process termed gamification. In this perspective paper, we offer a formal argument that gamification as applied today is predominately narrow, placing emphasis on the reward aspects of game mechanics at the expense of other important game elements, such as framing. We argue that more authentic game experiences are possible when programming environments are re-conceptualized and assessed as holistic, serious games. This broad\u00a0\u2026", "num_citations": "24\n", "authors": ["143"]}
{"title": "Frequently asked questions in bug reports\n", "abstract": " Bug tracking systems play a central role in software development since they allow users and developers to submit and discuss bugs and new features. To better understand information and communication needs in bug tracking, we analysed what questions are asked in bug reports. We sampled 600 bug reports from the MOZILLA and ECLIPSE projects and located 947 questions in the reports. Next, we used an open card sort and identified eight categories of questions, which can further be broken down into forty groups. We show the value of this catalogue of frequently asked questions with a large quantitative and qualitative study on when questions are asked and how they are answered. A consequence of our results is that constant user involvement is crucial for successful bug reports and that better tools are needed to support this.", "num_citations": "24\n", "authors": ["143"]}
{"title": "Today was a good day: The daily life of software developers\n", "abstract": " What is a good workday for a software developer? What is a typical workday? We seek to answer these two questions to learn how to make good days typical. Concretely, answering these questions will help to optimize development processes and select tools that increase job satisfaction and productivity. Our work adds to a large body of research on how software developers spend their time. We report the results from 5971 responses of professional developers at Microsoft, who reflected about what made their workdays good and typical, and self-reported about how they spent their time on various activities at work. We developed conceptual frameworks to help define and characterize developer workdays from two new perspectives: good and typical. Our analysis confirms some findings in previous work, including the fact that developers actually spend little time on development and developers' aversion for\u00a0\u2026", "num_citations": "23\n", "authors": ["143"]}
{"title": "Goldfish bowl panel: Software development analytics\n", "abstract": " Gaming companies now routinely apply data mining to their user data in order to plan the next release of their software. We predict that such software development analytics will become commonplace, in the near future. For example, as large software systems migrate to the cloud, they are divided and sold as dozens of smaller apps; when shopping inside the cloud, users are free to mix and match their apps from multiple vendors (e.g. Google Docs' word processor with Zoho's slide manager); to extend, or even retain, market share cloud vendors must mine their user data in order to understand what features best attract their clients. This panel will address the open issues with analytics. Issues addressed will include the following. What is the potential for software development analytics? What are the strengths and weaknesses of the current generation of analytics tools? How best can we mature those tools?", "num_citations": "23\n", "authors": ["143"]}
{"title": "Building software cost estimation models using homogenous data\n", "abstract": " Several studies have been conducted to determine if company-specific cost models deliver better prediction accuracy than cross-company cost models. However, mixed results have left the question still open for further investigation. We suspect this to be a consequence of heterogenous data used to build cross-company cost models. In this paper, we build cross-company cost models using homogenous data by grouping projects by their business sector. Our results suggest that it is worth to train models using only homogenous data rather than all projects available.", "num_citations": "22\n", "authors": ["143"]}
{"title": "Characterizing software developers by perceptions of productivity\n", "abstract": " Understanding developer productivity is important to deliver software on time and at reasonable cost. Yet, there are numerous definitions of productivity and, as previous research found, productivity means different things to different developers. In this paper, we analyze the variation in productivity perceptions based on an online survey with 413 professional software devel-opers at Microsoft. Through a cluster analysis, we identify and describe six groups of developers with similar perceptions of productivity: social, lone, focused, balanced, leading, and goal-oriented developers. We argue why personalized recommendations for improving software developers' work is important and discuss design implications of these clusters for tools to support developers' productivity.", "num_citations": "21\n", "authors": ["143"]}
{"title": "Towards a theory of software developer job satisfaction and perceived productivity\n", "abstract": " Developer satisfaction and work productivity are important considerations for software companies. Enhanced developer satisfaction may improve the attraction, retention and health of employees, while higher productivity should reduce costs and increase customer satis- faction through faster software improvements. Many researchers and companies assume that perceived productivity and job satisfaction are related and may be used as proxies for one another, but these claims are a current topic of debate. There are also many social and technical factors that may impact satisfaction and productivity, but which factors have the most impact is not clear, especially for specific development contexts. Through our research, we developed a theory articulating a bi-directional relationship between software developer job satisfaction and perceived productivity, and identified what additional social and technical factors\u00a0\u2026", "num_citations": "20\n", "authors": ["143"]}
{"title": "Software analytics: What\u2019s next?\n", "abstract": " Knowing what factors control software projects is very useful because humans might not understand those factors. Developers sometimes develop their own ideas about good and bad software, on the basis of just a few past projects. Using software analytics, we can correct those misconceptions. Software analytics lets software engineers learn about AI techniques. Once they learn those techniques, they can build and ship innovative AI tools. That is, software analytics is the training ground for the next generation of AI-literate software engineers. This article is part of a special issue on software engineering's 50th anniversary.", "num_citations": "20\n", "authors": ["143"]}
{"title": "A theory of branches as goals and virtual teams\n", "abstract": " A common method of managing the complexity of both technical and organizational relationships in a large software project is to use branches within the source code management system to partition the work into teams and tasks. We claim that the files modified on a branch are changed together in a cohesive way to accomplish some task such as adding a feature, fixing a related set of bugs, or implementing a subsystem, which we collectively refer to as the goal of the branch. Further, the developers that work on a branch represent a virtual team. In this paper, we develop a theory of the relationship between goals and virtual teams on different branches. Due to expertise, ownership, and awareness concerns, we expect that if two branches have similar goals, they will also have similar virtual teams or be at risk for communication and coordination breakdowns with the accompanying negative effects. In contrast, we\u00a0\u2026", "num_citations": "20\n", "authors": ["143"]}
{"title": "Keeping up with your friends: Function foo, library bar. dll, and work item 24\n", "abstract": " Development teams who work with others need to be aware of what everyone is doing in order to manage the risk of taking on dependencies. Using newsfeeds of software development activities mined from software repositories, teams can find relevant information to help them make well-informed decisions that affect the success of their endeavors. In this paper, we describe the architecture of a newsfeed system that we are currently building on top of the Codebook software repository mining platform. We discuss the design, construction and aggregation of newsfeeds, and include other important aspects such as summarization, filtering, context, and privacy.", "num_citations": "20\n", "authors": ["143"]}
{"title": "Beliefs, practices, and personalities of software engineers: a survey in a large software company\n", "abstract": " In this paper we present the results from a survey about the beliefs, practices, and personalities of software engineers in a large software company. The survey received 797 responses. We report statistics about beliefs of software engineers, their work practices, as well as differences in those with respect to personality traits. For example, we observed no personality differences between developers and testers; managers were conscientious and more extraverted. We observed several differences for engineers who are listening to music and for engineers who have built a tool. We also observed that engineers who agree with the statement\" Agile development is awesome\" were more extroverted and less neurotic.", "num_citations": "18\n", "authors": ["143"]}
{"title": "Build it yourself! Homegrown tools in a large software company\n", "abstract": " Developers sometimes take the initiative to build toolsto solve problems they face. What motivates developers to buildthese tools? What is the value for a company? Are the tools builtuseful for anyone besides their creator? We conducted a qualitativestudy of tool building, adoption, and impact within Microsoft. Thispaper presents our findings on the extrinsic and intrinsic factorslinked to toolbuilding, the value of building tools, and the factorsassociated with tool spread. We find that the majority of developersbuild tools. While most tools never spread beyond their creator'steam, most have more than one user, and many have more than onecollaborator. Organizational cultures that are receptive towardstoolbuilding produce more tools, and more collaboration on tools.When nurtured and spread, homegrown tools have the potential tocreate significant impact on organizations.", "num_citations": "16\n", "authors": ["143"]}
{"title": "Collaborative software development in ten years: Diversity, tools, and remix culture\n", "abstract": " Over the next ten years, collaboration in software engineering will change in a number of ways and research will need to shift its focus to enable and enhance such collaboration. Specifically, we claim that software in the small will become more popular and even large software will be built by fewer people due to better tools. For large projects, research will need to address the collaboration needs of project members other than just developers, including quality assurance engineers, build engineers, architects, and operations managers. Finally, code reuse and sharing will change as a result of a growing software remix culture, leading to more loosely coupled and indirect collaboration.", "num_citations": "15\n", "authors": ["143"]}
{"title": "Changes and bugs\u2014Mining and predicting development activities\n", "abstract": " Software development results in a huge amount of data: changes to source code are recorded in version archives, bugs are reported to issue tracking systems, and communications are archived in e-mails and newsgroups. We present techniques for mining version archives and bug databases to understand and support software development. First, we introduce the concept of co-addition of method calls, which we use to identify patterns that describe how methods should be called. We use dynamic analysis to validate these patterns and identify violations. The co-addition of method calls can also detect cross-cutting changes, which are an indicator for concerns that could have been realized as aspects in aspect-oriented programming. Second, we present techniques to build models that can successfully predict the most defect-prone parts of large-scale industrial software, in our experiments Windows Server 2003\u00a0\u2026", "num_citations": "14\n", "authors": ["143"]}
{"title": "Open Source und Freie Software\u2013soziale Bewegung im virtuellen Raum\n", "abstract": " 4. Die Freiheit zur Verteilung ver\u00e4nderter Versionen (vgl. Stallman 1999). Im Angesicht der historischen Entwicklung sozialer Bewegungen zu einer gesellschaftspolitischen Formation mit bis heute bedeutender Funktion f\u00fcr \u201epolitischen Wandel von Unten \u201cin Demokratien soll dieser Anspruch hier einer sozialwissenschaftlichen \u00dcberpr\u00fcfung unterzogen werden. F\u00fcr den Themenkomplex \u201esoziale Bewegung \u201csind die Sozialwissenschaften zust\u00e4ndig. Diese existieren bereits l\u00e4nger als die Informatik. Im Vergleich zu den Naturwissenschaften sind sie jedoch ebenfalls eine verh\u00e4ltnism\u00e4\u00dfig junge Disziplin. So erkl\u00e4rt sich auch, dass die Bewegungsforschung als Fachrichtung f\u00fcr die Untersuchung sozialer Bewegungen erst zu Beginn des 20. Jahrhunderts entstand. Sie ist urspr\u00fcnglich als der Versuch zu interpretieren, das f\u00fcr den damaligen Zeitraum politisch bedeutendste Ph\u00e4nomen der sozio\u00f6konomischen Entwicklung zu erkl\u00e4ren: die Arbeiterbewegung\u2013\u201edie Mutter der sozialen Bewegung \u201c. Die Industrielle Revolution hatte zu diesem Zeitpunkt \u00fcber einen Zeitraum von gut 100 Jahren die wirtschaftlichen und gesellschaftlichen Strukturen Europas grundlegend ver\u00e4ndert. Die zentrale technische Innovation dieser Zeit war die mechanische Maschine, die, angetrieben durch die Verbrennung fossiler Energietr\u00e4ger, den Kern einer neuen \u00f6konomischen \u00c4ra stellte. Diese Entwicklung hatte mit zeitlicher Verz\u00f6gerung einschneidende Auswirkungen auf die ehemals durch agrarische Verh\u00e4ltnisse bestimmte Lebenswelt eines Gro\u00dfteils der Bev\u00f6lkerung Europas. Urbanisierung und Proletarisierung weiter Bev\u00f6lkerungsschichten sind in diesem\u00a0\u2026", "num_citations": "14\n", "authors": ["143"]}
{"title": "Dwelling in software: Aspects of the felt-life of engineers in large software projects\n", "abstract": " The organizational and social aspects of software engineering (SE) are now increasingly well investigated. This paper proposes that there are a number of approaches taken in research that can be distinguished not by their method or topic but by the different views they construct of the human agent acting in SE. These views have implications for the pragmatic outcome of the research, such as whether systems design suggestions are made, proposals for the development of practical reasoning tools or the effect of Social Network Systems on engineer\u2019s sociability. This paper suggests that these studies tend to underemphasize the felt-life of engineers, a felt-life that is profoundly emotional though played in reference to ideas of moral propriety and ethics. This paper will present a study of this felt-life, suggesting it consists of a form of digital dwelling. The perspective this view affords are contrasted with process\u00a0\u2026", "num_citations": "12\n", "authors": ["143"]}
{"title": "Knowledge collaboration by mining software repositories\n", "abstract": " We will give a short overview on recent approaches to support developers by mining software repositories and outline current and future challenges from which knowledge collaboration can benefit.", "num_citations": "12\n", "authors": ["143"]}
{"title": "Locating matching method calls by mining revision history data\n", "abstract": " Developing an appropriate fix for a software bug often requires a detailed examination of the code as well as generation of appropriate test cases. However, certain categories of bugs are usually easy to fix. In this paper we focus on bugs that can be corrected with a one-line code change. As it turns out, one-line source code changes very often represent bug fixes. Moreover, a significant fraction of previously known bug categories can be addressed with one-line fixes. Careless use of file manipulation routines, failing to call free to deallocate a data structure, failing to use strncpy instead of strcpy for safer string manipulation, and using tainted character arrays as the format argument of fprintf calls are all well-known types of bugs that can typically be corrected with a one-line change of the program source. This paper proposes an analysis of software revision histories to find highly correlated pairs of method calls that naturally form application-specific useful coding patterns. Potential patterns discovered through revision history mining are passed to a runtime analysis tool that looks for pattern violations. We focus our pattern discovery efforts on matching method pairs. Matching pairs such as (fopen, fclose),(malloc, free), as well as (lock, unlock)-function calls require exact matching: failing to call the second function in the pair or calling one of the two functions twice in a row is an error. We use common bug fixes as a heuristic that allows us to focus on patterns that caused bugs in the past. The user is presented with a choice of patterns to validate at runtime. Dynamically obtained information about which patterns were violated and which ones held at\u00a0\u2026", "num_citations": "11\n", "authors": ["143"]}
{"title": "Products, developers, and milestones: how should I build my N-Gram language model\n", "abstract": " Recent work has shown that although programming languages enable source code to be rich and complex, most code tends to be repetitive and predictable. The use of natural language processing (NLP) techniques applied to source code such as n-gram language models show great promise in areas such as code completion, aiding impaired developers, and code search. In this paper, we address three questions related to different methods of constructing language models in an industrial context. Specifically, we ask:(1) Do application specific, but smaller language models perform better than language models across applications?(2) Are developer specific language models effective and do they differ depending on what parts of the codebase a developer is working in?(3) Finally, do language models change over time, ie, does a language model from early development model change later on in development\u00a0\u2026", "num_citations": "10\n", "authors": ["143"]}
{"title": "Aspect mining for large systems\n", "abstract": " The Eclipse plugin HAM identifies potential aspects in large programs. It analyzes the program's history and obtains sets of function calls that are likely to be cross-cutting. Later during programming, HAM informs the programmer when she is about to extend or change such a problematic concern.", "num_citations": "10\n", "authors": ["143"]}
{"title": "An explanatory analysis on eclipse beta-release bugs through in-process metrics\n", "abstract": " Failures after the release of software products are expensive and time-consuming to fix. Each of these failures has different reasons pointing into different portions of code. We conduct a retrospective analysis on bugs reported after beta release of Eclipse versions. Our objective is to investigate what went wrong during the development process. We identify six in-process metrics that have explanatory effects on beta-release bugs. We conduct statistical analyses to check relationships between files and metrics. Our results show that files with beta-release bugs have different characteristics in terms of in-process metrics. Those bugs are specifically concentrated on Eclipse files with little activity: few edits by few committers. We suggest that in-process metrics should be investigated individually to identify beta-release bugs. Companies may benefit from such a retrospective analysis to understand characteristics of failures\u00a0\u2026", "num_citations": "8\n", "authors": ["143"]}
{"title": "Investigating information needs to improve cooperation between developers and bug reporters\n", "abstract": " For many software projects, bug tracking systems play a central role in supporting collaboration between the developers and the users of the software. To better understand this collaboration and how tool support can be improved, we have quantitatively and qualitatively analysed the questions asked in a sample of 600 bug reports from the MOZILLA and ECLIPSE projects. We categorised the questions and analysed response rates and times by category and project. Our results show that the role of users goes beyond simply reporting bugs: their active and ongoing participation is important for making progress on the bugs they report. Based on the results, we suggest four ways in which bug tracking systems can be improved. Copyright 2010 ACM.", "num_citations": "8\n", "authors": ["143"]}
{"title": "Drawing Graphs Within Graphs.\n", "abstract": " The task of drawing subgraphs is often underestimated and they are simply emphasized using different colors or line styles. In this paper, we present an approach for drawing graphs within graphs that first produces a layout for the subgraphs thus increasing their locality. We introduce connection sets stressing relationships between several subgraphs. In a case study, we demonstrate how they can be used to visualize connections between many small network motifs.", "num_citations": "8\n", "authors": ["143"]}
{"title": "Enabling good work habits in software developers through reflective goal-setting\n", "abstract": " Software developers are generally interested in developing better habits to increase their workplace productivity and well-being, but have difficulties identifying concrete goals and actionable strategies to do so. In several areas of life, such as the physical activity and health domain, self-reflection has been shown to be successful at increasing people's awareness about a problematic behavior, motivating them to define a self-improvement goal, and fostering goal-achievement. We therefore designed a reflective goal-setting study to learn more about developers' goals and strategies to improve or maintain good habits at work. In our study, 52 professional software developers self-reflected about their work on a daily basis during two to three weeks, which resulted in a rich set of work habit goals and actionable strategies that developers pursue at work. We also found that purposeful, continuous self-reflection not only\u00a0\u2026", "num_citations": "7\n", "authors": ["143"]}
{"title": "Belief and evidence: How software engineers form their opinions\n", "abstract": " A study at Microsoft revealed how developers' opinions about software engineering truths can be subjectively based.", "num_citations": "6\n", "authors": ["143"]}
{"title": "Past, present, and future of analyzing software data\n", "abstract": " This chapter introduces the book and offers some context for the rest of the chapters. Specifically, we explore different definitions of \u201dsoftware analytics\u201d as well the historical evolution of the data science for software engineering.", "num_citations": "6\n", "authors": ["143"]}
{"title": "The many faces of software analytics\n", "abstract": " Articles regarding the many faces of software analytics highlight the power of analytics for different types of organizations: large organizations and open source projects, as well as small- to medium-sized projects.", "num_citations": "5\n", "authors": ["143"]}
{"title": "Developers\u2019 Diverging Perceptions of Productivity\n", "abstract": " To overcome the ever-growing demand for software, software development organizations strive to enhance the productivity of their developers. But what does productivity mean in the context of software development? A substantial amount of work on developer productivity has been undertaken over the past four decades. The majority of this work considered productivity from a top-down perspective (the manager view) in terms of the artifacts and code created per unit of time. Common examples of such productivity measures are the lines of source code modified per hour, the resolution time for modification requests, or function points created per month. These productivity measures focus on a single, output-oriented factor for quantifying productivity, and do not take into account developers\u2019 individual work roles, practices and other factors that might affect their productivity, such as work fragmentation, the tools\u00a0\u2026", "num_citations": "4\n", "authors": ["143"]}
{"title": "Introduction to the special issue on mining software repositories in 2010\n", "abstract": " This special issue of Empirical Software Engineering consists of revised and extended versions of three selected papers originally presented at the 7th IEEE Working Conference on Mining Software Repositories (MSR 2010). The conference was held in Cape Town, South Africa, on May 2\u20133, and was co-located with the 32nd ACM/IEEE International Conference on Software Engineering (ICSE 2010). This conference brings together researchers who share an interest in advancing the science and practice of software engineering via the analysis of data stored in software repositories.The Mining Software Repositories field analyzes the rich data available in software repositories to uncover interesting and actionable information about software systems and projects. Thanks to the ready availability of software configuration management, mailing list, and bug tracking repositories from open source projects, it has gained\u00a0\u2026", "num_citations": "4\n", "authors": ["143"]}
{"title": "Mining additions of method calls in ArgoUML\n", "abstract": " In this paper we refine the classical co-change to the addition of method calls. We use this concept to find usage patterns and to identify cross-cutting concerns for ArgoUML.", "num_citations": "4\n", "authors": ["143"]}
{"title": "The sound of software development: Music listening among software engineers\n", "abstract": " Listening to music is a common phenomenon among software developers in today's work environments. Music can reduce stress, improve happiness, and even increase performance. We conducted two surveys with 2,242 professional software developers and found that between 63 and 88.2% of participants listen to music at work at least some of the time often when writing code or doing repetitive tasks, and that these listeners tend to be more extroverted.", "num_citations": "3\n", "authors": ["143"]}
{"title": "Health and productivity insight generation\n", "abstract": " A method for generating productivity insights includes receiving health data for a user of a productivity evaluation service. From the health data, health behaviors and health effects of the user are determined. Productivity data for the user is received, and from the productivity data, productivity behaviors and productivity effects of the user are determined. Associations between changes in the health data and changes in the productivity data are identified. Based on one of the associations, a productivity insight is generated for the user including a prompt to engage in a health behavior that is associated with a desirable productivity effect.", "num_citations": "3\n", "authors": ["143"]}
{"title": "HAM: cross-cutting concerns in Eclipse\n", "abstract": " As programs evolve, newly added functionality sometimes no longer aligns with the original design, ending up scattered across the software system. Aspect mining tries to identify such cross-cutting concerns in a program to support maintenance, or as a first step towards an aspect-oriented program. Previous approaches to aspect mining applied static or dynamic program analysis techniques to a single version of a system. We exploit all versions from a system's CVS history to mine aspect candidates; we are about to extend our research prototype to an Eclipse plug-in called HAM: when a single CVS commit adds calls to the same (small) set of methods in many unrelated locations, these method calls are likely to be cross-cutting. HAM employs formal concept analysis to identify aspect candidates. Analysing one commit operation at a time makes the approach scale to industrial-sized programs. In an evaluation we\u00a0\u2026", "num_citations": "3\n", "authors": ["143"]}
{"title": "Automatic extraction of bug localization benchmarks from history\n", "abstract": " Researchers have proposed a number of tools for automatic bug localization. Given a program and a description of the failure, such tools pinpoint a set of statements that are most likely to contain the bug. Evaluating bug localization tools is a difficult task because existing benchmarks are limited in size of subjects and number of bugs. In this paper we present iBugs, an approach that automatically extracts benchmarks for bug localization from the history of a project. For ASPECTJ, we extracted 369 bugs, 223 out of these had associated test cases (useful to test dynamic tools). We demonstrate the relevance of our dataset for both static and dynamic bug localization tools with case studies on FINDBUGS and AMPLE.", "num_citations": "3\n", "authors": ["143"]}
{"title": "Behavioral science of software engineering\n", "abstract": " Large-scale software development is a sociotechnical activity only bounded by human imagination, ingenuity, and creativity. It involves teams of developers progressing by coordinating their activities and communicating their bottlenecks, goals, and advancements toward the wider goal of creating large, high-quality software systems. The stakeholders they serve are diverse (for example, clients, infrastructure providers, open source communities, project managers, and regulatory authorities), and often they have many competing, implicit requirements. But, as the political and legal implications of algorithms and data (https://harvardmagazine.com/2000/01/code-is-law-html) increasingly affect society, it is imperative that the systems the developers build are high quality in terms of accurately embodying all of those requirements.", "num_citations": "2\n", "authors": ["143"]}
{"title": "Detecting Developers' Task Switches and Types\n", "abstract": " Developers work on a broad variety of tasks during their workdays and constantly switch between them. While these task switches can be beneficial, they can also incur a high cognitive burden on developers, since they have to continuously remember and rebuild task context - the artifacts and applications relevant to the task. Researchers have therefore proposed to capture task context more explicitly and use it to provide better task support, such as task switch reduction or task resumption support. Yet, these approaches generally require the developer to manually identify task switches. Automatic approaches for predicting task switches have so far been limited in their accuracy, scope, evaluation, and the time discrepancy between predicted and actual task switches. In our work, we examine the use of automatically collected computer interaction data for detecting developers' task switches as well as task types. In\u00a0\u2026", "num_citations": "2\n", "authors": ["143"]}
{"title": "Software productivity decoded: how data science helps to achieve more (keynote)\n", "abstract": " Many companies are looking into understanding and improving productivity of individual software developers as well as software teams. In this talk, I will motivate the need for data analytics in software teams and describe how data scientists work in a large software companies helping software teams to infer actionable insights. I will then show how data from software development can be used to learn more about the productivity of organizations, teams, and individuals and help them to become more effective in building software.", "num_citations": "2\n", "authors": ["143"]}
{"title": "Rethinking Productivity in Software Engineering (Dagstuhl Seminar 17102)\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 17102\" Rethinking Productivity in Software Engineering\". In the following, we briefly summarize the goals and format of the of the seminar, before we provide insights and an outlook, including a few grand challenges, based on the results and statements collected during the seminar.", "num_citations": "2\n", "authors": ["143"]}
{"title": "Dynamine: Finding usage patterns and their violations by mining software repositories\n", "abstract": " A great deal of attention has been given lately to addressing applicationspecific software bugs such as errors in operating system drivers [4, 14], security errors [24, 43], or errors in reliability-critical embedded software in domains like avionics [7, 8]. These represent critical errors in widely used software and tend to get fixed relatively quickly when found. A variety of static and dynamic analysis tools have been developed to address these high-profile bugs. However, many other errors are specific to individual applications or platforms. This is especially true when it comes to extensible development platforms such as J2EE, .NET, and others that have a variety of programmers at all skill levels writing code to use the same sets of APIs. Violations of these application-specific coding rules, referred to as error patterns, are responsible for a multitude of errors. Error patterns tend to be re-introduced into the code over and over\u00a0\u2026", "num_citations": "2\n", "authors": ["143"]}
{"title": "Information needs for software development analytics,\u201d Microsoft Research\n", "abstract": " Software development is a data rich activity with many sophisticated metrics. Yet engineers often lack the tools and techniques necessary to leverage these potentially powerful information resources toward decision making. In this paper, we present the data and analysis needs of professional software engineers, which we identified among 110 developers and managers in a survey. We asked about their decision making process, their needs for artifacts and indicators, and scenarios in which they would use analytics. The survey responses lead us to propose several guidelines for analytics tools in software development including: Engi-neers do not necessarily have much expertise in data analysis; thus tools should be easy to use, fast, and produce concise output. Engineers have diverse analysis needs and consider most indicators to be important; thus tools should at the same time support many different types of artifacts and many indicators. In addition, engineers want to drill down into data based on time, organizational structure, and system architecture. I.", "num_citations": "2\n", "authors": ["143"]}
{"title": "The landscape of concurrent development\n", "abstract": " The version control archive CVS records not only all changes in a project but also activity data such as when developers create or update their workspaces. Furthermore, CVS records when it has to integrate changes because of parallel development. In this paper, we analyze the CVS activity data of for large open-source projects GCC, JBOSS, JEDIT, and PYTHON to investigate parallel development: How frequently do developers update their workspaces? What is the degree of parallel development? How many workspaces do developers have? How frequently do conflicts occur during updates and how are they resolved? How do we identify changes that contain integrations?", "num_citations": "2\n", "authors": ["143"]}
{"title": "Identifying Cross-Cutting Concerns from History\n", "abstract": " As object-oriented programs evolve, they may suffer from the \u201ctyranny of dominant decomposition\u201d: The program can be modularised only one way at a time, leaving cross-cutting concerns scattered across many modules and tangled with one another. Aspectoriented programming (AOP) tries to remedy this by encapsulating these concerns into aspects. Aspect mining identifies such cross-cutting concerns and thus helps to migrate existing software to an aspectoriented program.Aspect mining of large software system like Eclipse is a problem: dynamic approaches depend on test cases and have trouble covering all code and thus detecting all cross-cutting functionality. And static approaches simply cannot analyse systems this big unless they work incrementally. We offer a new approach based on the observation that cross-cutting functionality does not exist from the beginning. Instead, it is introduced over time. More specifically, we speculate that considerable cross-cutting functionality is introduced within short periods of time. To find these, we analyse code additions from development tasks as they are recorded in a software repository like CVS. Since we analyse one task at a time, our approach is independent of a project\u2019s total size. This enables us to report crosscutting functionality for Eclipse, a 1.6 MLOC Java program. In this paper we sketch the basic idea of history-based aspect mining and some initial results.", "num_citations": "2\n", "authors": ["143"]}
{"title": "Leaving My Fingerprints: Motivations and Challenges of Contributing to OSS for Social Good\n", "abstract": " When inspiring software developers to contribute to open source software, the act is often referenced as an opportunity to build tools to support the developer community. However, that is not the only charge that propels contributions\u2014 growing interest in open source has also been attributed to software developers deciding to use their technical skills to benefit a common societal good. To understand how developers identify these projects, their motivations for contributing, and challenges they face, we conducted 21 semi-structured interviews with OSS for Social Good (OSS4SG) contributors. From our interview analysis, we identified themes of contribution styles that we wanted to understand at scale by deploying a survey to over 5765 OSS and Open Source Software for Social Good contributors. From our quantitative analysis of 517 responses, we find that the majority of contributors demonstrate a distinction\u00a0\u2026", "num_citations": "1\n", "authors": ["143"]}
{"title": "Fitbit for Developers: Self-Monitoring at Work\n", "abstract": " Recently, we have seen an explosion in the number of devices and apps that we can use to track various aspects of our lives, such as the steps we walk, the quality of our sleep, or the calories we consume. People use devices such as the Fitbit activity tracker to increase and maintain their physical activity level by tracking their behavior, setting goals (e.g. 10'000 steps a day) and competing with friends. Many of these approaches have been shown to successfully encourage users to change their behaviors, often motivated through persuasive technologies, such as goal-setting, social encouragement and sharing mechanisms. We explored how we can map the tremendous success of these smart devices to the workplace, with the aim to increase software developers' self-awareness about productivity through self-monitoring. Yet, little is known about expectations of, the experience with, and the impact of self\u00a0\u2026", "num_citations": "1\n", "authors": ["143"]}
{"title": "One size does not fit all\n", "abstract": " Not every prediction model can be transferred from one context to another. I've learned this the hard way in my work on defect prediction. The good news is that while prediction models might not always be applicable to other contexts, the methods typically are.", "num_citations": "1\n", "authors": ["143"]}
{"title": "Software analytics for digital games\n", "abstract": " Software and its development generates an inordinate amount of data. Development activities such as check-ins, work items, bug reports, code reviews, and test executions are recorded in software repositories. User interactions that reflect how customers experience software are recorded in telemetry data, run-time traces, and log files and helps to track application and feature usage and expose performance and reliability. Software analytics takes this data and turns it into actionable insight to better inform decisions related to software. In this talk, I will summarize our efforts in the area of software analytics with a special focus on digital games. I will present several examples of games studies, which we have worked on at Microsoft Research such as how players are engaged in Project Gotham Racing, how skill develops over time in Halo Reach and Forza Motor sports, and the initial experience of game play. I will\u00a0\u2026", "num_citations": "1\n", "authors": ["143"]}
{"title": "1st international workshop on big data software engineering (BIGDSE 2015)\n", "abstract": " Big Data is about extracting valuable information from data in order to use it in intelligent ways such as to revolutionize decision-making in businesses, science and society. BIGDSE 2015 discusses the link between Big Data and software engineering and critically looks into issues such as cost-benefit of big data.", "num_citations": "1\n", "authors": ["143"]}
{"title": "Analyzing software data: after the gold rush (a goldfish-bowl panel)\n", "abstract": " Over the past few years, the volume and types of data related to software engineering has grown at an unprecedented rate and shows no sign of slowing. This turn of events has led to a veritable gold rush, as researchers attempt to mine raw data and extract nuggets of insight. A very real danger is that the landscape may become a Wild West where inexperienced software\" cowboys\" sell hastily generated models to unsophisticated business users, without any concern for best or safe practices. Given the current enthusiasm for data analysis in software engineering, it is time to review how we using those techniques and can we use them better. While there may be no single best\" right\" way to analyze software data, there are many wrong ways. As data techniques mature, we need to move to a new era where data scientists understand and share the strengths and drawbacks of the many methods that might be\u00a0\u2026", "num_citations": "1\n", "authors": ["143"]}
{"title": "The art of collecting bug reports\n", "abstract": " Kids love bugs, and some kids even collect bugs and keep them in precious \u201ckill jars.\u201d Over a period of time, bug collectors can amass a large number of different species of bugs. Some kids study the bugs they collected and label them based on such characteristics as shape, size, color, number of legs, whether it can fly, and so on. The bugs may be valued differently depending upon how rare they are or how difficult they are to catch. The collection may have some duplicate bugs. But duplicates are rarely identical, as characteristics such as appearance and size can differ widely.But we software developers do not like bugs. We hope to have none in our software, and when they are found, we squash them! Unfortunately, squashing bugs, or more politely, responding to software change requests, is rarely easy. Developers have to study the information about the bug in detail, conduct a thorough investigation on how to resolve the bug, examine its side effects, and eventually decide on and take a course of action. This is a difficult task because, like earthly bugs, software bugs differ widely. Often software bugs that are collected in bug databases of projects are studied in isolation because they are different from the other bugs in their effects on the software system, their cause and location, and their severity. Over time, a project will accumulate duplicate bugs, just as a live-bug collector may have multiple bugs of the same species. And finally, nearly every project knows about more bug reports than it can fix, just as there are too many live bugs to be collected by a single person.", "num_citations": "1\n", "authors": ["143"]}
{"title": "Taking lessons from history\n", "abstract": " Mining of software repositories has become an active research area. However, most past research considered any change to software as beneficial. This thesis will show how we can benefit from a classification into good and bad changes. The knowledge of bad changes will improve defect prediction and localization. Furthermore, we will describe how to learn project-specific error patterns that will help reducing future errors.", "num_citations": "1\n", "authors": ["143"]}
{"title": "Drawing graphs within graphs: A contribution to the graph drawing contest 2003\n", "abstract": " This paper is a contribution to the Graph Drawing Contest 2003. Frequently, the drawing of subgraphs is underestimated and subgraphs are simply emphasized using different colors or line styles. In this paper, we present an approach for drawing graphs within graphs that layouts the subgraphs first and therefore increases their locality. In two case studies, we demonstrate how this approach can be used to visualize connections between subgraphs or to highlight many similar subgraphs.", "num_citations": "1\n", "authors": ["143"]}
{"title": "Algorithmisches Debugging II\n", "abstract": " Fehler in Programmen zu suchen kostet Zeit, Geld und Nerven. Ein Versuch, die Fehlersuche durch Automatisierung zu vereinfachen, war algorithmisches Debugging. Das von Shapiro eingefuhrte Verfahren war in der Lage, Fehler in logischen Programmen mit wenig Benutzerinteraktionen zu finden. Das algorithmische Debugging wurde von Fritzson, Shahmehri und Kamkar auf imperative Programme erweitert. Um imperative Programme automatisch zu debuggen, mussen diese zuerst von Seiteneffekten befreit werden. Um zusatzlich die Anzahl der Benutzerinteraktionen zu reduzieren, wurde das algorithmische Debugging mit Assertions, Testdaten und Slicing kombiniert.", "num_citations": "1\n", "authors": ["143"]}