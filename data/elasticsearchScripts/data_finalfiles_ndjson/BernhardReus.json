{"title": "Monadic presentations of lambda terms using generalized inductive types\n", "abstract": " We present a definition of untyped \u03bb-terms using a heterogeneous datatype, i.e. an inductively defined operator. This operator can be extended to a Kleisli triple, which is a concise way to verify the substitution laws for \u03bb-calculus. We also observe that repetitions in the definition of the monad as well as in the proofs can be avoided by using well-founded recursion and induction instead of structural induction. We extend the construction to the simply typed \u03bb-calculus using dependent types, and show that this is an instance of a generalization of Kleisli triples. The proofs for the untyped case have been checked using the LEGO system.", "num_citations": "189\n", "authors": ["1776"]}
{"title": "Classical logic, continuation semantics and abstract machines\n", "abstract": " One of the goals of this paper is to demonstrate that denotational semantics is useful for operational issues like implementation of functional languages by abstract machines. This is exemplified in a tutorial way by studying the case of extensional untyped call-by-name \u03bb-calculus with Felleisen's control operator [Cscr ]. We derive the transition rules for an abstract machine from a continuation semantics which appears as a generalization of the \u00ac\u00ac-translation known from logic. The resulting abstract machine appears as an extension of Krivine's machine implementing head reduction. Though the result, namely Krivine's machine, is well known our method of deriving it from continuation semantics is new and applicable to other languages (as e.g. call-by-value variants). Further new results are that Scott's D\u221e-models are all instances of continuation models. Moreover, we extend our continuation semantics to Parigot's \u03bb\u03bc\u00a0\u2026", "num_citations": "164\n", "authors": ["1776"]}
{"title": "An event-based structural operational semantics of multi-threaded Java\n", "abstract": " A structural operational semantics of a significant sublanguage of Java is presented, including the running and stopping of threads, thread interaction via shared memory, synchronization by monitoring and notification, and sequential control mechanisms such as exception handling and return statements. The operational semantics is parametric in the notion of \u201cevent space\u201d [6], which formalizes the rules that threads and memory must obey in their interaction. Different computational models are obtained by modifying the well-formedness conditions on event spaces while leaving the operational rules untouched. In particular, we implement the prescient stores described in [10, \u00a717.8] which allow certain intermediate code optimizations, and prove that such stores do not affect the semantics of properly synchronized programs.", "num_citations": "105\n", "authors": ["1776"]}
{"title": "Continuation semantics or expressing implication by negation\n", "abstract": " Starting from the ideas of JY Girard on making classical logic constructive, we isolate a fragment of intuitionistic logic with negation instead of implication, and we investigate the corresponding programming paradigm. In particular, we get a nice continuation passing style translation of lambda calculus, from which we derive a semantics of non-functional features in functional programming, such as inputs/outputs and Felleisen's C operator.", "num_citations": "77\n", "authors": ["1776"]}
{"title": "A Hoare calculus for verifying Java realizations of OCL-constrained design models\n", "abstract": " The Object Constraint Language OCL offers a formal notation for constraining the modelling elements occurring in UML diagrams. In this paper we apply OCL for developing Java realizations of UML design models and introduce a new Hoare-Calculus for Java classes which uses OCL as assertion language. The Hoare rules are as usual for while programs, blocks and (possibly recursive) method calls. Update of instance variables is handled by an explicit substitution operator which also takes care of aliasing. For verifying a Java subsystem w.r.t. a design subsystem specified using OCL constraints we define an appropriate realization relation and illustrate our approach by an example.", "num_citations": "56\n", "authors": ["1776"]}
{"title": "General synthetic domain theory\u2013a logical approach\n", "abstract": " Synthetic domain theory (SDT) is a version of Domain Theory where \u2018all functions are continuous\u2019. Following the original suggestion of Dana Scott, several approaches to SDT have been developed that are logical or categorical, axiomatic or model-oriented in character and that are either specialised towards Scott domains or aim at providing a general theory axiomatising the structure common to the various notions of domains studied so far.In Reus and Streicher (1993), Reus (1995) and Reus (1998), we have developed a logical and axiomatic version of SDT, which is special in the sense that it captures the essence of Domain Theory \u00e0 la Scott but rules out, for example, Stable Domain Theory, as it requires order on function spaces to be pointwise. In this article we will give a logical and axiomatic account of a general SDT with the aim of grasping the structure common to all notions of domains.As in loc.cit., the\u00a0\u2026", "num_citations": "42\n", "authors": ["1776"]}
{"title": "From sequential to multi-threaded Java: An event-based operational semantics\n", "abstract": " A structural operational semantics of a non trivial sublanguage of Java is presented. This language includes dynamic creation of objects, blocks, and synchronization of threads. First we introduce a simple operational description of the sequential part of the language, where the memory is treated as an algebra with suitably axiomatized operations. Then, the interaction between threads via a shared memory is described in terms of structures, called \u201cevent spaces,\u201d whose wellformedness conditions formalize directly the rules given in the Java language specification. Event spaces are included in the operational judgements to develop the semantics of the full multi-threaded sublanguage, which is shown to extend the one for sequential Java conservatively. The result allows sequential programs to be reasoned about in a simplified computational framework without loss of generality.", "num_citations": "41\n", "authors": ["1776"]}
{"title": "Separation logic for higher-order store\n", "abstract": " Separation Logic is a sub-structural logic that supports local reasoning for imperative programs. It is designed to elegantly describe sharing and aliasing properties of heap structures, thus facilitating the verification of programs with pointers. In past work, separation logic has been developed for heaps containing records of basic data types. Languages like C or ML, however, also permit the use of code pointers. The corresponding heap model is commonly referred to as \u201chigher-order store\u201d since heaps may contain commands which in turn are interpreted as partial functions between heaps.               In this paper we make Separation Logic and the benefits of local reasoning available to languages with higher-order store. In particular, we introduce an extension of the logic and prove it sound, including the Frame Rule that enables specifications of code to be extended by invariants on parts of the heap that are\u00a0\u2026", "num_citations": "37\n", "authors": ["1776"]}
{"title": "CD28null pro-atherogenic CD4 T-cells explain the link between CMV infection and an increased risk of cardiovascular death\n", "abstract": " An increased risk of cardiovascular death in Cytomegalovirus (CMV)-infected individuals remains unexplained, although it might partly result from the fact that CMV infection is closely associated with the accumulation of CD28 null T-cells, in particular CD28 null CD4 T-cells. These cells can directly damage endothelium and precipitate cardiovascular events. However, the current paradigm holds that the accumulation of CD28 null T-cells is a normal consequence of aging, whereas the link between these T-cell populations and CMV infection is explained by the increased prevalence of this infection in older people. Resolving whether CMV infection or aging triggers CD28 null T-cell expansions is of critical importance because, unlike aging, CMV infection can be treated.Methods: We used multi-color flow-cytometry, antigen-specific activation assays, and HLA-typing to dissect the contributions of CMV infection and\u00a0\u2026", "num_citations": "26\n", "authors": ["1776"]}
{"title": "Program verification in synthetic domain theory\n", "abstract": " Synthetic Domain Theory provides a setting to consider domains as sets with certain closure properties for computing suprema of ascending chains. As a consequence the notion of domain can be internalized which allows one to construct and reason about solutions of recursive domain equations. Moreover, one can derive that all functions are continuous.In this thesis such a synthetic theory of domains (\u03a3-domains) is developed based on a few axioms formulated in an adequate intuitionistic higher-order logic. This leads to an elegant theory of domains. It integrates the positive features of several approaches in the literature. In contrast to those, however, it is model independent and can therefore be formalized. A complete formalization of the whole theory of \u03a3-domains has been coded into a proof-checker (Lego) for impredicative type theory. There one can exploit dependent types in order to express program modules and modular specifications.", "num_citations": "26\n", "authors": ["1776"]}
{"title": "Semantics and logic of object calculi\n", "abstract": " The main contribution of this paper is a formal characterization of recursive object specifications and their existence based on a denotational untyped semantics of the object calculus. Existence is not guaranteed but can be shown employing Pitts\u2019 results on relational properties of domains. The semantics can be used to analyse and verify Abadi and Leino's object logic but it also suggests extensions. For example, specifications of methods may not only refer to fields but also to methods of objects in the store. This can be achieved without compromising the existence theorem. An informal logic of predomains is in use intentionally in order to avoid any commitment to a particular syntax of specification logic.", "num_citations": "24\n", "authors": ["1776"]}
{"title": "Modular semantics and logics of classes\n", "abstract": " The semantics of class-based languages can be defined in terms of objects only [1,7,8] if classes are viewed as objects with a constructor method. One obtains a store in which method closures are held together with field values. Such a store is also called \u201chigher-order\u201d and does not come for free [13]. It is much harder to prove properties of such stores and as a consequence (soundness of) programming logics can become rather contrived (see [2]).             A simpler semantics separates methods from the object store [4,12]. But again, there is a drawback. Once the semantics of a package of classes is computed it is impossible to add other classes in a compositional way. Modular reasoning principles are therefore not obtainable either.             In this paper we improve a simple class-based semantics to deal with extensions compositionally and derive modular reasoning principles for a logic of classes. The\u00a0\u2026", "num_citations": "21\n", "authors": ["1776"]}
{"title": "About Hoare logics for higher-order store\n", "abstract": " We present a Hoare logic for a simple imperative while-language with stored commands, ie. stored parameterless procedures. Stores that may contain procedures are called higher-order. Soundness of our logic is established by using denotational rather than operational semantics. The former is employed to elegantly account for an inherent difficulty of higher-order store, namely that assertions necessarily describe recursive predicates on a recursive domain. In order to obtain proof rules for mutually recursive procedures, assertions have to explicitly refer to the code of the procedures.", "num_citations": "20\n", "authors": ["1776"]}
{"title": "Limits of Computation\n", "abstract": " About 12 years ago a student 1 asked me after one of my lectures in Computability and Complexity why he had to write tedious Turing machine programs, given that everyone programmed in languages like Java. He had a point. What is the best way to teach a Computability and Complexity module in the twenty-first century to a cohort of students who are used to programming in high level languages with modern tools and libraries; to students who live in a world of smart phones and 24h connectivity, and, even more importantly maybe, who have not been exposed to very much formal reasoning and mathematics? Turn the clock back only two or three decades. Then, a first year in a computer science Bachelor degree mainly consisted of mathematics (analysis and linear algebra, later discrete maths, numerical analysis, and basic probability theory). When computability and complexity was taught in the second or third\u00a0\u2026", "num_citations": "19\n", "authors": ["1776"]}
{"title": "Formal reasoning about runtime code update\n", "abstract": " We show how dynamic software updates can be modelled using a \u201chigher order store\u201d programming language where procedures can be written to the heap. We then show how such updates can be proved correct with a Hoare-calculus that allows for keeping track of behavioural specifications of such stored procedures.", "num_citations": "19\n", "authors": ["1776"]}
{"title": "Class-based versus object-based: A denotational comparison\n", "abstract": " In object-oriented programming one distinguishes two kinds of languages. Class-based languages are centered around the concept of classes as descriptions of objects. In object-based languages the concept of a class is substituted by constructs for the creation of individual objects. Usually, the object-based languages attract interest because of their \u201csimplicity\u201d. This paper contains a thorough denotational analysis which reveals that simplicity is quickly lost if one tackles verification issues. This is due to what is sometimes called \u201crecursion through the store\u201d. By providing a denotational semantics for a simple class-based and a simple object-based language it is shown that the denotational semantics of the object-based language needs much more advanced domain theoretic machinery than the class based one. The gap becomes even wider when we define concepts of specification and appropriate\u00a0\u2026", "num_citations": "14\n", "authors": ["1776"]}
{"title": "A complete temporal and spatial logic for distributed systems\n", "abstract": " In this paper, we introduce a spatial and temporal logic for reasoning about distributed computation. The logic is a combination of an extension of hybrid logic, that allows us to reason about the spatial structure of a computation, and linear temporal logic, which accounts for the temporal aspects. On the pragmatic side, we show the wide applicability of this logic by means of many examples. Our main technical contribution is completeness of the logic both with respect to spatial/temporal structures and a class of spatial transition systems.", "num_citations": "13\n", "authors": ["1776"]}
{"title": "General synthetic domain theory\u2014a logical approach\n", "abstract": " Synthetic Domain Theory (SDT) is a version of Domain Theory where \u201call functions are continuous\u201d. In [14, 12] there has been developed a logical and axiomatic version of SDT which is special in the sense that it captures the essence of Domain Theory \u00e0 la Scott but rules out other important notions of domain.             In this article we will give a logical and axiomatic account of General Synthetic Domain Theory (GSDT) aiming to grasp the structure common to all notions of domain as advocated by various authors. As in [14, 12] the underlying logic is a sufficiently expressive version of constructive type theory. We start with a few basic axioms giving rise to a core theory on top of which we study various notions of predomains as well-complete and replete S-spaces [9], define the appropriate notion of domain and verify the usual induction principles.", "num_citations": "13\n", "authors": ["1776"]}
{"title": "Synthetic domain theory in type theory: Another logic of computable functions\n", "abstract": " We will present a Logic of Computable Functions based on the idea of Synthetic Domain Theory such that all functions are automatically continuous. Its implementation in the Lego proof-checker \u2014 the logic is formalized on top of the Extended Calculus of Constructions \u2014 has two main advantages. First, one gets machine checked proofs verifying that the chosen logical presentation of Synthetic Domain Theory is correct. Second, it gives rise to a LCF-like theory for verification of functional programs where continuity proofs are obsolete. Because of the powerful type theory even modular programs and specifications can be coded such that one gets a prototype setting for modular software verification and development.", "num_citations": "13\n", "authors": ["1776"]}
{"title": "Na\u00efve Synthetic Domain Theory: A Logical Approach\n", "abstract": " We present two dioeerent approaches to Synthetic Domains. First we give a synthetic, axiomatic version of extensional PERs which [Freyd et al. 92] introduced model theoretically. Second we rephrase the theory of replete objects (cf.[Hyland 91],[Taylor 91]). If the category of predomains is small and internally complete two logical characterizations of repletion are possible. Closure properties of the corresponding predomains and domains are stated and finally the most important proofs of traditional domain theory are sketched in the synthetic setting. So this paper might serve as an introduction into Synthetic Domain Theory also for readers unfamiliar with topos or category theory.", "num_citations": "13\n", "authors": ["1776"]}
{"title": "Verifying properties of module construction in type theory\n", "abstract": " This paper presents a comparison between algebraic specifications-in-the-large and a type theoretical formulation of modular specifications, called deliverables. It is shown that the laws of module algebra can be translated to laws about deliverables which can be proved correct in type theory. The adequacy of the Extended Calculus of Constructions as a possible implementation of type theory is discussed and it is explained how the reformulation of the laws is influenced by this choice.", "num_citations": "12\n", "authors": ["1776"]}
{"title": "Crowfoot: A verifier for higher-order store programs\n", "abstract": " We present Crowfoot, an automatic verification tool for imperative programs that manipulate procedures dynamically at runtime; these programs use a heap that can store not only data but also code (commands or procedures). Such heaps are often called higher-order store, and allow for instance the creation of new recursions on the fly. One can use higher-order store to model phenomena such as runtime loading and unloading of code, runtime update of code and runtime code generation. Crowfoot\u2019s assertion language, based on separation logic, features nested Hoare triples which describe the behaviour of procedures stored on the heap. The tool addresses complex issues like deep frame rules and recursion through the store, and is the first verification tool based on recent developments in the mathematical foundations of Hoare logics with nested triples.", "num_citations": "10\n", "authors": ["1776"]}
{"title": "Denotational semantics for Abadi and Leino\u2019s logic of objects\n", "abstract": " Abadi-Leino Logic is a Hoare-calculus style logic for a simple imperative and object-based language where every object comes with its own method suite. Consequently, methods need to reside in the store (\u201dhigher-order store\u201d). We present a new soundness proof for this logic using a denotational semantics where object specifications are recursive predicates on the domain of objects. Our semantics reveals which of the limitations of Abadi and Leino\u2019s logic are deliberate design decisions and which follow from the use of higher-order store. We discuss the implications for the development of other, more expressive, program logics.", "num_citations": "9\n", "authors": ["1776"]}
{"title": "Realizability models for type theories\n", "abstract": " This tutorial aims at giving an account on the realizability models for several constructive type theories. These range from simply typed \u03bb-calculus over second-order polymorphic \u03bb-calculus to the Calculus of Constructions as an example of dependent type theory. The models are made from partial equivalence relations (pers) and realizability sets over an arbitrary partial combinatory algebra. Realizability semantics does not only provide intuitive models but can also be used for proving independence results of type theories. Finally, by considering complete extensional pers, an approach to bridge the gap from type theory to constructive domain theory is discussed.", "num_citations": "9\n", "authors": ["1776"]}
{"title": "Specification patterns and proofs for recursion through the store\n", "abstract": " Higher-order store means that code can be stored on the mutable heap that programs manipulate, and is the basis of flexible software that can be changed or re-configured at runtime. Specifying such programs is challenging because of recursion through the store, where new (mutual) recursions between code are set up on the fly. This paper presents a series of formal specification patterns that capture increasingly complex uses of recursion through the store. To express the necessary specifications we extend the separation logic for higher-order store given by Schwinghammer et al. (CSL, 2009), adding parameter passing, and certain recursively defined families of assertions. Finally, we apply our specification patterns and rules to an example program that exploits many of the possibilities offered by higher-order store; this is the first larger case study conducted with logical techniques based on work\u00a0\u2026", "num_citations": "8\n", "authors": ["1776"]}
{"title": "Denotational semantics for a program logic of objects\n", "abstract": " The object-calculus is an imperative and object-based programming language in which every object comes equipped with its own method suite. Consequently, methods need to reside in the store (\u2018higher-order store\u2019), which complicates the semantics. Abadi and Leino defined a program logic for this language enriching object types by method specifications. We present a new soundness proof for their logic using denotational semantics. It turns out that denotations of store specifications are predicates defined by mixed-variant recursion. A benefit of our approach is that derivability and validity can be kept distinct. Moreover, it reveals which of the limitations of Abadi and Leino's logic are incidental design decisions and which follow inherently from the use of a higher-order store. We discuss the implications for the development of other, more expressive, program logics.", "num_citations": "8\n", "authors": ["1776"]}
{"title": "Formalizing synthetic domain theory\n", "abstract": " Synthetic Domain Theory (SDT) is a constructive variant of Domain Theory where all functions are continuous following Dana Scott\u2032s idea of \u201cdomains as sets\u201d. Recently there have been suggested more abstract axiomatizations encompassing alternative notions of domain theory as, for example, stable domain theory.               In this article a logical and axiomatic version of SDT capturing the essence of Domain Theory \u00e0 la Scott is presented. It is based on a sufficiently expressive version of constructive type theory and fully implemented in the proof checker Lego. On top of this \u201ccore SDT\u201d denotational semantics and program verification can be \u2013 and in fact has been \u2013 developed in a purely formal machine-checked way.               The version of SDT we have chosen for this purpose is based on work by Reus and Streicher and can be regarded as an axiomatization of complete extensional PERs. This\u00a0\u2026", "num_citations": "8\n", "authors": ["1776"]}
{"title": "Extensional \u03a3-spaces in type theory\n", "abstract": " Synthetic Domain Theory provides a setting for denotational semantics following Dana Scott's slogan \u2018domains as sets\u2019 in which all functions are continuous. Several approaches can be found in the literature, but they are either model-dependent or if they use an axiomatic setting then not uniformly and not explicitly. We present a completely logical approach to Synthetic Domain Theory (SDT), axiomatizing (complete) Extensional PERs. On these grounds some basic domain theory is developed. Special attention is devoted to admissibility. The axiomatic approach is advantageous since it allows for easy formalization and comparison to other axiomatic settings.               The consistency of the theory is shown by providing an appropriate realizability model. It is discussed how to get from this \u2018special kind\u2019 of SDT \u2018{\u00e0 la Scott}\u2019 to a more general form which unifies several approaches.", "num_citations": "7\n", "authors": ["1776"]}
{"title": "A deeper understanding of the deep frame axiom\n", "abstract": " Separation logic [7] is well known to provide a local reasoning principle for local store, the frame rule. Local reasoning is extended to programs with modules and higher-order functions respectively by the hypothetical frame rule [4] and higher-order frame rule [2]. This means, for instance, that the private state of a library module can be hidden, so that clients do not need to know or worry about the private state; this leads to modular proofs.Higher-order functions can be expressed in low level languages using code pointers and recursion through the store, as in [1, 8]. However, local reasoning for such languages is surprisingly tricky: in [8], a version of the (higher-order) deep frame rule is observed to hold only as a rule and not as an axiom. This means one can only apply the rule to the top level triple under consideration, but not to nested triples appearing inside assertions. Assuming the axiom version allows one to \u201claunder\u201d specifications [6, 8] and thus derive memory-safety of programs that actually crash. On the other hand, it appears that without a reasoning principle resembling the axiom version, there are safe programs whose correctness cannot be shown.", "num_citations": "5\n", "authors": ["1776"]}
{"title": "Verifying the reflective visitor pattern\n", "abstract": " Computational reflection allows a program to inspect and manipulate the structure or behaviour of itself at runtime. Often this means that it is possible to create more generic or adaptable programs in an elegant way. However, there is little support for specification and automatic verification of reflective programs. We address this problem by implementing, specifying, and verifying a reflective library using a Hoare-logic for a simple language with stored procedures. The latter is important since reflective metadata is modelled on the heap, thus method objects will be realised as stored procedures. We verify memory safety as well as functional correctness of an instance of the reflective visitor pattern, including the reflective library. The entire verification is carried out in our (semi-) automatic verification tool Crowfoot.", "num_citations": "4\n", "authors": ["1776"]}
{"title": "Towards a machine-checked Java specification book\n", "abstract": " The semantics of the object-oriented, multi-threaded language Java is informally described in the Java Specification Book [5] where the memory model for concurrent threads is explained abstractly by means of asynchronous events and informal rules relating their occurrences. A formalization has been presented in [3] using certain posets of events (called event spaces) and a structural operational (small-step) semantics. Such an exact formal counterpart of the informal axiomatization of the Specification Book may not only serve as a reference semantics for different, possibly simplified, semantics, but also as a basis for language analysis. In this paper we present a machine-checked version of the formalization using Isabelle/HOL. Some proofs showing the redundancy of axioms in the Java Specification Book are discussed. As usual, by Isabelle\u2019s austerity some tacit assumptions and few minor mistakes were\u00a0\u2026", "num_citations": "4\n", "authors": ["1776"]}
{"title": "How to Solve NP-Complete Problems\n", "abstract": " There are hundreds of important problems that have been shown to be NP-complete. If we believe that P  NP, then no efficient algorithms exist to solve them. In this chapter we discuss how this affects the working programmer. As many of these NP-complete problems are relevant to business and industry, one needs coping strategies, which are the topic of this chapter. It is discussed what exact and approximation algorithms, can achieve and how parallelism and randomisation might help. Some new complexity classes will be defined along the way. The effectivity of the presented strategies are evaluated for the Travelling Salesman problem. Finally, it is discussed how the fact that there are no efficient algorithms known to factorise a number can be viewed as good news.", "num_citations": "3\n", "authors": ["1776"]}
{"title": "Relative completeness for logics of functional programs\n", "abstract": " We prove a relative completeness result for a logic of functional programs extending D. Scott's LCF. For such a logic, contrary to results for Hoare logic, it does not make sense to ask whether it is complete relative to the full theory of its first-order part, since the first order part does not determine uniquely the model at higher-order types. Therefore, one has to fix a model and choose an appropriate data theory wrt which the logic is relatively complete. We establish relative completeness for two models: for the Scott model we use the theory of Baire Space as data theory, and for the effective Scott model we take first-order arithmetic. In both cases we need to extend traditional LCF in order to capture a sufficient amount of domain theory.", "num_citations": "3\n", "authors": ["1776"]}
{"title": "A logic of recursive objects\n", "abstract": " A denotational semantics of an untyped functional object calculus according to Abadi & Cardelli is endowed with a higher-order logic and some proof principles in order to obtain a Iogic of (recursive) objects in the spirit of the Logic of Computable Functions (LCF). Contrary to the work of Abadi & Leino the logic also allows for recursive objects and specifications. In this paper we focus on recursive interface specifications with invariants. This is extended to an imperative object calculus that is appropriate for a sublanguage of sequential Java. lt provides us with a denotational basis for the different axiomatic calculi that have been suggested by several authors.", "num_citations": "3\n", "authors": ["1776"]}
{"title": "Molecular Computing\n", "abstract": " This chapter is dedicated to molecular computing. Molecular computing uses DNA and molecular biology and chemistry as hardware. Historically, its beginnings are rooted in the attempt to solve NP-complete problems efficiently. Those attempts and the overall potential and the major challenges of DNA computing are reviewed. One particular abstract model of molecular computing, Chemical Reaction Networks, are introduced in more detail and compared to other notions of computations. The programming techniques for Chemical Reaction Networks are very different from traditional approaches presented earlier, as the programmer has no control over the order of reactions executed. A concrete \u201csynthetic chemistry\u201d implementation of this abstract model that uses DNA strand displacement is briefly explained.", "num_citations": "2\n", "authors": ["1776"]}
{"title": "A decidable class of verification conditions for programs with higher order store\n", "abstract": " Recent years have seen a surge in techniques and tools for automatic and semi-automatic static checking of imperative heap-manipulating programs. At the heart of such tools are algorithms for automatic logical reasoning, using heap description formalisms such as separation logic. In this paper we work towards extending these static checking techniques to languages with procedures as first class citizens. To do this, we first identify a class of entailment problems which arise naturally as verification conditions during the static checking of higher order heap-manipulating programs. We then present a decision procedure for this class and prove its correctness. Entailments in our class combine simple symbolic heaps, which are descriptions of the heap using a subset of separation logic, with (limited use of) nested Hoare triples to specify properties of higher order procedures.", "num_citations": "2\n", "authors": ["1776"]}
{"title": "Verifying a compiler optimization for multi-threaded Java\n", "abstract": " The specification for the object-oriented concurrent language Java [3] is rather loose with respect to the interaction of shared memory and the local working memories of different threads. This allows maximal freedom in the language implementation. Such freedom is reflected in the semantics provided in [2], where threads-memory interaction is formalized in terms of structures called event spaces. Two kinds of memories are described in the Java specification: a \u201cnormal\u201d memory and a more liberal one, where values can sometimes be stored even before they are produced as results of computation. Here we compare two structural operational semantics of a sublanguage of Java modelling the two types of memory. The two semantics share the same set of operational rules but put different requirements (expressed as first order theories) on the notion of event space. We prove a result which is informally stated in", "num_citations": "2\n", "authors": ["1776"]}
{"title": "Cytomegalovirus infection is associated with an increase in aortic stiffness in older men which may be mediated in part by CD4 memory T-cells\n", "abstract": " Human Cytomegalovirus (CMV) infection is associated with atherosclerosis, higher cardiovascular disease (CVD) risk, and an increase in memory T-cells (T mem). T-cells have also been implicated in CVD, independently of CMV infection. To better understand the CMV-associated CVD risk, we examined the association between CMV (IgG) serostatus and central aortic (carotid-to-femoral) pulse wave velocity (cfPWV), an early, independent predictor of CVD. We also investigated if such an association might be reflected by the distribution of T mem and/or other T-cell subsets.Methods: Healthy older volunteers (60-93 years) underwent routine clinical and laboratory evaluation, including assessment of cfPWV in eligible participants. Flow-cytometry was used to assess proportions of memory T-cells, CD28 null T-cells, and CMV-specific T-cells. The following associations were examined; CMV serostatus/cfPWV, CMV\u00a0\u2026", "num_citations": "1\n", "authors": ["1776"]}
{"title": "Towards Model Checking Real-World Software-Defined Networks\n", "abstract": " In software-defined networks (SDN), a controller program is in charge of deploying diverse network functionality across a large number of switches, but this comes at a great risk: deploying buggy controller code could result in network and service disruption and security loopholes. The automatic detection of bugs or, even better, verification of their absence is thus most desirable, yet the size of the network and the complexity of the controller makes this a challenging undertaking. In this paper, we propose MOCS, a highly expressive, optimised SDN model that allows capturing subtle real-world bugs, in a reasonable amount of time. This is achieved by (1) analysing the model for possible partial order reductions, (2) statically pre-computing packet equivalence classes and (3) indexing packets and rules that exist in the model. We demonstrate its superiority compared to the state of the art in terms of expressivity, by\u00a0\u2026", "num_citations": "1\n", "authors": ["1776"]}
{"title": "Towards model checking real-world software-defined networks (version with appendix)\n", "abstract": " In software-defined networks (SDN), a controller program is in charge of deploying diverse network functionality across a large number of switches, but this comes at a great risk: deploying buggy controller code could result in network and service disruption and security loopholes. The automatic detection of bugs or, even better, verification of their absence is thus most desirable, yet the size of the network and the complexity of the controller makes this a challenging undertaking. In this paper we propose MOCS, a highly expressive, optimised SDN model that allows capturing subtle real-world bugs, in a reasonable amount of time. This is achieved by (1) analysing the model for possible partial order reductions, (2) statically pre-computing packet equivalence classes and (3) indexing packets and rules that exist in the model. We demonstrate its superiority compared to the state of the art in terms of expressivity, by providing examples of realistic bugs that a prototype implementation of MOCS in UPPAAL caught, and performance/scalability, by running examples on various sizes of network topologies, highlighting the importance of our abstractions and optimisations.", "num_citations": "1\n", "authors": ["1776"]}
{"title": "Robustness of P\n", "abstract": " Does it matter for a problem\u2019s complexity which model of computation is used to decide it? In this chapter we show that the class of polynomially decidable problems is robust under compilation between the various languages we have encountered. Stipulating that all notions of computation can simulate each other up\u00a0to a polynomial factor is known as the Extended Church\u2013Turing Thesis. It can be weakened to sequential models and is then called Cook\u2019s thesis. A third, more questionable, thesis, often called Cobham\u2013Edmonds thesis, states that the class of polynomially decidable problems is the class of feasible problems. The above mentioned theses will be discussed and evaluated.", "num_citations": "1\n", "authors": ["1776"]}
{"title": "Symbolic execution proofs for higher order store programs\n", "abstract": " Higher order store programs are programs which store, manipulate and invoke code at runtime. Important examples of higher order store programs include operating system kernels which dynamically load and unload kernel modules. Yet conventional Hoare logics, which provide no means of representing changes to code at runtime, are not applicable to such programs. Recently, however, new logics using nested Hoare triples have addressed this shortcoming. In this paper we describe, from top to bottom, a sound semi-automated verification system for higher order store programs. We give a programming language with higher order store features, define an assertion language with nested triples for specifying such programs, and provide reasoning rules for proving programs correct. We then present in full our algorithms for automatically constructing correctness proofs. In contrast to earlier work, the\u00a0\u2026", "num_citations": "1\n", "authors": ["1776"]}
{"title": "Specification patterns for reasoning about recursion through the store\n", "abstract": " Higher-order store means that code can be stored on the mutable heap that programs manipulate, and is the basis of flexible software that can be changed or reconfigured at runtime.Specifying such programs is challenging because higher-order store allows recursion through the store, where new (mutual) recursions between code are set up on the fly.This paper presents a series of formal specification patterns that capture increasingly complex uses of recursion through the store. To express the necessary specifications we extend the separation logic for higher-order store given by Schwinghammer et al. (CSL, 2009), adding parameter passing, and certain recursively defined families of assertions.We give proof rules for our extended logic and show their soundness. Finally, we apply our specification patterns and rules to an example program that exploits many of the possibilities offered by higher-order store; this is\u00a0\u2026", "num_citations": "1\n", "authors": ["1776"]}
{"title": "Implementing higher-order functions in an algebraic specification language with narrowing\n", "abstract": " The presented HO-RAP system combines \u03bb-calculus with Horn clause specifications interpreted by rewriting and narrowing techniques. Therefore, higher-order programming becomes available for the prototyper together with logic programming features introduced via narrowing. Still unification is first-order and accordingly not satisfactory with regard to functional equality.", "num_citations": "1\n", "authors": ["1776"]}