{"title": "Automatic verification of a behavioural subset of UML statechart diagrams using the SPIN model-checker\n", "abstract": " Statechart Diagrams provide a graphical notation for describing dynamic aspects of system behaviour within the Unified Modelling Language (UML). In this paper we present a translation from a subset of UML Statechart Diagrams - covering essential aspects of both concurrent behaviour, like sequentialisation, parallelism, non-determinism and priority, and state refinement - into PROMELA, the specification language of the SPIN model checker. SPIN is one of the most advanced analysis and verification tools available nowadays. Our translation allows for the automatic verification of UML Statechart Diagrams. The translation is simple, proven correct, and promising in terms of state space representation efficiency.", "num_citations": "442\n", "authors": ["680"]}
{"title": "Towards a formal operational semantics of UML statechart diagrams\n", "abstract": " Statechart Diagrams are a notation for describing behaviours in the framework of UML, the Unified Modeling Language of object-oriented systems. UML is a semi-formal language, with a precisely defined syntax and static semantics but with an only informally specified dynamic semantics. UML Statechart Diagrams differ from classical statecharts, as defined by Harel, for which formalizations and results are available in the literature. This paper sets the basis for the development of a formal semantics for UML Statechart Diagrams based on Kripke structures. This forms the first step towards model checking of UML Statechart Diagrams. We follow the approach proposed by Mikk and others: we first map Statechart Diagrams to the intermediate format of extended hierarchical automata and then we define an operational semantics for these automata. We prove a number of properties of such semantics which\u00a0\u2026", "num_citations": "315\n", "authors": ["680"]}
{"title": "VIATRA-visual automated transformations for formal verification and validation of UML models\n", "abstract": " The VIATRA (visual automated model transformations) framework is the core of a transformation-based verification and validation environment for improving the quality of systems designed using the Unified Modeling Language by automatically checking consistency, completeness, and dependability requirements. In the current paper, we present an overview of (i) the major design goals and decisions, (ii) the underlying formal methodology based on metamodeling and graph transformation, (iii) the software architecture based upon the XMI standard, and (iv) several benchmark applications of the VIATRA framework.", "num_citations": "298\n", "authors": ["680"]}
{"title": "Dependability analysis in the early phases of UML-based system design\n", "abstract": " A thorough system specification is insufficient to guarantee that a computer system will adequately perform its tasks during its entire life cycle. The early evaluation of system characteristics like dependability, correctness and performance is necessary to assess the conformance of the system under development to its targets. This paper presents the results achieved so far to develop an integrated environment, where design tools based on the UML (Unified Modeling Language) are augmented with validation and analysis techniques that provide useful information in the early phases of system design. Automatic transformations are defined for the generation of models to capture system behavioral properties, dependability and performance.", "num_citations": "180\n", "authors": ["680"]}
{"title": "Stochastic dependability analysis of system architecture based on UML models\n", "abstract": " The work in this paper1 is devoted to the definition of a dependability modeling and model based evaluation approach based on UML models. It is to be used in the early phases of the system design to capture system dependability attributes like reliability and availability, thus providing guidelines for the choice among different architectural and design solutions. We show how structural UML diagrams can be processed to filter out the dependability related information and how a system-wide dependability model is constructed. Due to the modular construction, this model can be refined later as more detailed information becomes available. We discuss the model refinement based on the General Resource Model, an extension of UML. We show that the dependability model can be constructed automatically by using graph transformation techniques.", "num_citations": "100\n", "authors": ["680"]}
{"title": "Automated dependability analysis of UML designs\n", "abstract": " The paper deals with the automatic dependability analysis of systems designed using UML. An automatic transformation is defined for the generation of models to capture systems dependability attributes, like reliability. The transformation concentrates on structural UML views, available early in the design, to operate at different levels of refinement, and tries to capture only the information relevant for dependability to limit the size (state space) of the models. Due to the modular construction, these models can be refined later as more detailed, relevant information becomes available. Moreover a careful selection of those critical parts to be detailed allows one to avoid explosion of the size. An implementation of the transformation is in progress and will be integrated in the toolsets available for the ESPRIT LTR HIDE project.", "num_citations": "77\n", "authors": ["680"]}
{"title": "Automatic dependability analysis for supporting design decisions in UML\n", "abstract": " Even though a thorough system specification improves the quality of the design, it is not sufficient to guarantee that a system will satisfy its reliability targets. Within this paper, we present an application example of one of the activities performed in the European ESPRIT project HIDE, aiming at the creation of an integrated environment where design toolsets based on UML are augmented with modeling and analysis tools for the automatic validation of the system under design. We apply an automatic transformation from UML diagrams to Timed Petri Nets for model based dependability evaluation. It allows a designer to use UML as a front-end for the specification of both the system and the user requirements, and to evaluate dependability figures of the system since the early phases of the design, thus obtaining precious clues for design refinement. The transformation completely hides the mathematical background\u00a0\u2026", "num_citations": "73\n", "authors": ["680"]}
{"title": "Quantitative analysis of UML statechart models of dependable systems\n", "abstract": " The paper introduces a method which allows quantitative dependability analysis of systems modeled by using the Unified Modeling Language (UML) statechart diagrams. The analysis is performed by transforming the UML model to stochastic reward nets (SRNs). A large subset of statechart model elements is supported including event processing, state hierarchy and transition priorities. The transformation is presented by a set of SRN patterns. Performance-related measures can be directly derived using SRN tools, while dependability analysis requires explicit modeling of erroneous states and faulty behavior.", "num_citations": "71\n", "authors": ["680"]}
{"title": "Formal verification of safety PLC based control software\n", "abstract": " Programmable Logic Controllers (PLCs) are widely used in the industry for various industrial automation tasks. Besides non-safety applications, the usage of PLCs became accepted in safety-critical installations, where the cost of failure is high. In these cases the used hardware is special (so-called fail-safe or safety PLCs), but also the software needs special considerations. Formal verification is a method that can help to develop high-quality software for critical tasks. However, such method should be adapted to the special needs of the safety PLCs, that are often particular compared to the normal PLC development domain. In this paper we propose two complementary solutions for the formal verification of safety-critical PLC programs based on model checking and equivalence checking using formal specification. Furthermore, a case study is presented, demonstrating our approach.", "num_citations": "48\n", "authors": ["680"]}
{"title": "UML-based design and formal analysis of a safety-critical railway control software module\n", "abstract": " A new equipment of safety relevance has been developed to upgrade ageing relay-based railway interlocking systems in Hungary. In course of the design process formal methods have been used in the development of a module realising a well-separable function of the system. Namely, the UML-based design process was extended by model based analysis and validation. The first kind of analysis checked the completeness and consistency of the behavioural description of the module. In the subsequent phases, the functional design was enriched by modelling the potential faults and their effects. This kind of extension allowed the analysis of the error propagation and testability.", "num_citations": "45\n", "authors": ["680"]}
{"title": "Checking general safety criteria on UML statecharts\n", "abstract": " This paper describes methods and tools for automated safety analysis of UML statechart specifications. The general safety criteria described in the literature are reviewed and automated analysis techniques are proposed. The techniques based on OCL expressions and graph transformations are detailed and their limitations are discussed. To speed up the checker methods, a reduced form for UML statecharts is introduced. Using this form, the correctness and completeness of some checker methods can be proven. An example illustrates the application of the tools developed so far.", "num_citations": "44\n", "authors": ["680"]}
{"title": "Completeness and consistency analysis of UML statechart specifications\n", "abstract": " This paper describes methods and tools for automatic safety analysis of UML statechart specifications. Two types of analysis are presented. The first one checks completeness and consistency based on the static structure of the specification, thus it does not requires the generation of the reachability graph. Accordingly, this method scales up well to large systems. The second one performs dynamic analysis by checking safety related reachability properties with the help of a model checker. It is restricted to core critical parts of the system. Two approaches of the implementation of the static checking are discussed. The use of the tools is presented by a case study.", "num_citations": "33\n", "authors": ["680"]}
{"title": "Watchdog processors in parallel systems\n", "abstract": " A watchdog processor (WDP) is a relatively simple coprocessor built for concurrent, information compaction based error detection in the main program control flow. A new algorithm called SEIS (Signature Encoded Instruction Stream) is presented for assigning signatures to high level-instructions. The main idea of this method is to embed the information necessary to the program flow check into the signatures themselves, thus avoiding large reference databases in the WDP and allowing high operational speed. Solutions for a fault-tolerant multiprocessing and multi-tasking implementation are described as well.", "num_citations": "32\n", "authors": ["680"]}
{"title": "Program code generation based on UML statechart models\n", "abstract": " Since visual modelling languages are getting more and more popular, the automatic generation of the program code on the basis of high-level models is an important issue. This article discusses implementation possibilities of statecharts, the graphical notation for describing state-based event-driven behaviour in the Unified Modelling Language (UML). The first part of the article outlines common approaches published in the literature and identifies their weaknesses. In the second part an implementation pattern is proposed that is capable of efficiently instantiating most of the statechart features. The pattern developed by us poses low hardware requirements therefore applicable even in embedded systems.", "num_citations": "31\n", "authors": ["680"]}
{"title": "Theta: a framework for abstraction refinement-based model checking\n", "abstract": " In this paper, we present Theta, a configurable model checking framework. The goal of the framework is to support the design, execution and evaluation of abstraction refinement-based reachability analysis algorithms for models of different formalisms. It enables the definition of input formalisms, abstract domains, model interpreters, and strategies for abstraction and refinement. Currently it contains front-end support for transition systems, control flow automata and timed automata. The built-in abstract domains include predicates, explicit values, zones and their combinations, along with various refinement strategies implemented for each. The configurability of the framework allows the integration of several abstraction and refinement methods, this way supporting the evaluation of their advantages and shortcomings. We demonstrate the applicability of the framework by use cases for the safety checking of PLC\u00a0\u2026", "num_citations": "30\n", "authors": ["680"]}
{"title": "Model-based integration, execution and certification of development tool-chains\n", "abstract": " Software development processes are typically supported by a set of different tools that assist the designer in various phases of development like modeling, verification, source code generation, testing. Tool-chains can be formed by the integration of tools that are related to the subsequent steps of the process. In this paper, we present a tool integration framework which applies metamodel-driven and process-centric design patterns. Motivated by our research activities in various projects, our framework is based on standard process models, which allows the re-use of tool integration patterns as well as automated checking of the conformance of tool-chains to development standards. We make use of the state-of-the-art Rational Jazz platform as a technological basis.", "num_citations": "30\n", "authors": ["680"]}
{"title": "Methods of checking general safety criteria in UML statechart specifications\n", "abstract": " This paper describes methods and tools for safety analysis of UML statechart specifications. A comprehensive set of general safety criteria including completeness and consistency is applied in automated analysis. Analysis techniques are based on OCL expressions, graph transformations and reachability analysis. Two canonical intermediate representations of the statechart specification are introduced. They are suitable for straightforward implementation of checker methods and for the support of the proof of the correctness and soundness of the applied analysis. One of them also serves as a basis of the metamodel of a variant of UML statecharts proposed for the specification of safety-critical control systems. The analysis is extended to object-oriented specifications. Examples illustrate the application of the checker methods implemented by an automated tool-set.", "num_citations": "30\n", "authors": ["680"]}
{"title": "Workflow-driven tool integration using model transformations\n", "abstract": " The design of safety-critical systems and business-critical services necessitates to coordinate between a large variety of tools used in different phases of the development process. As certification frequently prescribes to achieve justified compliance with regulations of authorities, integrated tool chain should strictly adhere to the development process itself. In order to manage complexity, we follow a model-driven approach where the development process is captured using a precise domain-specific modeling language. Each individual step within this process is represented transparently as a service. Moreover, to carry out individual tasks, systems engineers are guided by semi-automated transformation steps and well-formedness constraint checking. Both of them are formalized by graph patterns and graph transformation rules as provided by the Viatra2 framework. In our prototype implementation, we use\u00a0\u2026", "num_citations": "27\n", "authors": ["680"]}
{"title": "Form\u00e1lis m\u00f3dszerek az informatik\u00e1ban\n", "abstract": " Form\u00e1lis m\u00f3dszerek az informatik\u00e1ban Page 1 Form\u00e1lis m\u00f3dszerek az informatik\u00e1ban dr. Pataricza Andr\u00e1s \u00e9s dr. Bartha Tam\u00e1s el\u0151ad\u00e1sa alapj\u00e1n BME M\u00e9r\u00e9stechnika \u00e9s Inform\u00e1ci\u00f3s Rendszerek Tansz\u00e9k Page 2 Id\u0151rend \u2022 Febru\u00e1r \u2013 11 \u2013 25 \u2022 M\u00e1rcius \u2013 12 \u2013 26 \u2022 \u00c1prilis \u2013 2 (Zh) \u2013 9 \u2013 23 \u2022 M\u00e1jus \u2013 5 Page 3 Komplex IT alkalmaz\u00e1s \u2022 Tervez\u00e9s (specifik\u00e1ci\u00f3): \u2013 egy\u00fcttm\u0171k\u00f6d\u00e9s \u2194 interdiszciplinarit\u00e1s \u2022 egy\u00e9rtelm\u0171s\u00e9g \u2022 \u00e9rthet\u0151s\u00e9g \u2022 teljess\u00e9g, ellentmond\u00e1s-mentess\u00e9g \u2013 szolg\u00e1ltat\u00e1sbiztons\u00e1g \u2022 Fejleszt\u00e9s (implement\u00e1ci\u00f3): \u2013 bizony\u00edtottan helyes rendszer: \u2022 verifik\u00e1ci\u00f3 \u2022 valid\u00e1ci\u00f3 \u2013 min\u0151s\u00e9g \u2194 k\u00f6lts\u00e9g \u2194 id\u0151 \u2013 automatiz\u00e1l\u00e1s/komponens integr\u00e1ci\u00f3 iterat\u00edv folyamat (\u00e9letciklus) fokozatos finom\u00edt\u00e1ssal (refinement) Page 4 \u2022 Mi\u00e9rt van sz\u00fcks\u00e9g \u00e9letciklus modellre? \u2013 Komplexit\u00e1s kezel\u00e9se \u2013 V\u00e1ltoz\u00e1sok kezel\u00e9se \u2022 k\u00f6vetelm\u00e9nyek, \u00faj megold\u00e1sok \u2013 J\u00f3l defini\u00e1lt fejleszt\u00e9si f\u00e1zisok \u2022 M\u00e9rf\u00f6ldk\u00f6vek \u2013 ellen\u0151rizhet\u0151s\u00e9g, sz\u00e1monk\u00e9rhet\u0151s\u00e9g \u2013 \u2026", "num_citations": "27\n", "authors": ["680"]}
{"title": "Multiprocessor checking using watchdog processors\n", "abstract": " A new control flow checking scheme is presented, based on assigned-signature checking using a watchdog processor. This scheme is suitable for a multitasking, multiprocessor environment. The hardware overhead is comparatively low because of three reasons: first, hierarchically structured, the scheme uses only a single watchdog processor to monitor multiple processes on multiple processors. Second, as an assigned-signature scheme, it does not require monitoring the instruction bus of the processors. Third, the run-time and reference signatures are embedded into the checked program; thus, in the watchdog processor neither a reference database nor a time-consuming search and compare engine is required.", "num_citations": "25\n", "authors": ["680"]}
{"title": "Automatic generation of executable assertions for runtime checking temporal requirements\n", "abstract": " Checking various temporal requirements is a key dependability concern in safety-critical systems. As model-checking approaches do not scale well to systems of high complexity the runtime verification of temporal requirements has received a growing attention recently. This paper presents a code-generation based method for runtime evaluation of linear temporal logic formulae over program execution traces. The processing-power requirements of our solution are much lower than in case of previous approaches enabling its application even in resource-restricted embedded environments.", "num_citations": "24\n", "authors": ["680"]}
{"title": "Automatic code generation based on formally analyzed UML statechart models\n", "abstract": " This paper aims at providing an efficient implementation pattern for source code level instantiation of UML statcharts. The code generation is based on extended hierarchical automata, the formal description method used as an intermediate representation of statecharts for model checking purposes, this way enabling automatic implementation of formally analyzed models. Since statecharts can automatically be mapped to extended hierarchical automata, a code generator based on our pattern could be used as a module that can be inserted into any UML modeling tool equipped with model export capabilities. This approach enables the modeler to use the usual design environment and hides the transformation required for model checking and code generation steps.", "num_citations": "24\n", "authors": ["680"]}
{"title": "Modeling and analysis of redundancy management in distributed object-oriented systems by using UML statecharts\n", "abstract": " The paper presents techniques that enable the modeling and analysis of redundancy schemes in distributed object-oriented systems. The replication manager, as a core part of the redundancy scheme, is modeled by using UML statecharts. The flexibility of the statechart-based modeling, which includes event processing and state hierarchy, enables an easy and efficient modeling of replication strategies as well as repair and recovery policies. The statechart is transformed to a Petri-net based dependability model, which also incorporates the models of the replicated objects. By the analysis of the Petri-net model the designer can obtain reliability and availability measures that can be used in the early phases of the design to compare alternatives and find dependability bottlenecks. Our approach is illustrated by an example.", "num_citations": "24\n", "authors": ["680"]}
{"title": "Model-based automatic test generation for event-driven embedded systems using model checkers\n", "abstract": " Testing is an essential, but time and resource consuming activity in the software development process. In the case of model-based development, among other subtasks test construction and test execution can be partially automated. Our paper describes the implementation of a test generator framework that uses an external model checker to construct test sequences. The possible configurations of the model checker are examined by measuring the efficiency of test construction in the case of different statechart models of event-driven embedded systems. The generated test cases are transformed and executed on common testing frameworks (JUnit, rational robot) and the effectiveness of tests are measured using code coverage metrics", "num_citations": "23\n", "authors": ["680"]}
{"title": "PLC code generation based on a formal specification language\n", "abstract": " The complexity and quality needs of PLC-based control system software have largely increased. Formal specification methods can help to cope with these needs. Besides formal verification, another benefit of a formal specification language is the possibility to provide automatic generation of the final source code. This paper overviews PLCspecif, our formal specification language for PLC programs and presents a code generation method for the language. The result of the code generator is a Structured Text (ST) code that not only corresponds to the formal semantics of the specification, but is also configurable, readable, understandable, and follows development conventions and standards. The code generation method shows that PLC-specif is applicable and well-adapted to the PLC domain.", "num_citations": "21\n", "authors": ["680"]}
{"title": "An integrated framework for the dependability evaluation of distributed mobile applications\n", "abstract": " Current distributed mobile systems are usually characterized by a huge number of nodes, different network domains, different applications running, variability of the users' behavior, and dynamicity and heterogeneity of the communication networks. A typical example can be found in the automotive context, considering car-to-car and car-to-infrastructure communication scenarios. In this paper we propose a model-based approach for the dependability evaluation of distributed applications in a mobile environment. The final Multiple Phased System model representing the analyzed mobile scenario is automatically derived from high-level UML specifications through a sequence of model transformation steps. The evaluation workflow is based on i) a hierarchical modelling approach that analyzes the system at different levels, namely communication, architecture, application and user level; ii) a time-based system\u00a0\u2026", "num_citations": "21\n", "authors": ["680"]}
{"title": "Modeling and analysis of exception handling by using UML statecharts\n", "abstract": " Our paper aims at proposing a framework that allows programmers to exploit the benefits of exception handling throughout the entire development chain of Java programs by modeling exception handling in the abstract UML statechart model of the application, enabling the use of automatic model checkers for checking the behavioral model for correctness even in exceptional situations, and utilizing automatic code generators for implementing the Java source of exception-aware statecharts.", "num_citations": "21\n", "authors": ["680"]}
{"title": "Robustness testing techniques for high availability middleware solutions\n", "abstract": " To increase the interoperability of availability management software (also known as high availability middleware) the Service Availability Forum has released a set of open specifications. With the development of a common interface the comparison of multiple products can be achieved. For high availability (HA) solutions, assessing the robustness of the HA middleware is as important as measuring its performance. This paper investigates the sources of inputs that can activate robustness faults of a HA middleware and recommends the corresponding testing techniques to check the existence of such faults. We investigated the automated construction of the robustness test suites and compared the efficiency of different techniques using a case study with an open-source HA middleware.", "num_citations": "19\n", "authors": ["680"]}
{"title": "Verification of UML statechart models of embedded systems\n", "abstract": " This paper presents a method for verification of UML statechart models generated in the development process of embedded systems containing hardware and software components. The method allows the automated verification of behavioral requirements through model transformation and application of an off-the-shelf model checker. The transformation tools have been implemented and the method was applied successfully in the design verification of an interrupt controller. The paper deals with the details of the verification method and introduces the application example as well.", "num_citations": "19\n", "authors": ["680"]}
{"title": "A configurable CEGAR framework with interpolation-based refinements\n", "abstract": " Correctness of software components in a distributed system is a key issue to ensure overall reliability. Formal verification techniques such as model checking can show design flaws at early stages of development. Abstraction is a key technique for reducing complexity by hiding information, which is not relevant for verification. Counterexample-Guided Abstraction Refinement (CEGAR) is a verification algorithm that starts from a coarse abstraction and refines it iteratively until the proper precision is obtained. Many abstraction types and refinement strategies exist for systems with different characteristics. In this paper we show how these algorithms can be combined into a configurable CEGAR framework. In our framework we also present a new CEGAR configuration based on a combination of abstractions, being able to perform better for certain models. We demonstrate the use of the framework by comparing\u00a0\u2026", "num_citations": "18\n", "authors": ["680"]}
{"title": "Comparing robustness of AIS-based middleware implementations\n", "abstract": " To enable the interoperability of high availability (HA) middleware systems the Service Availability Forum has released a set of open specifications. The benefit of having open specifications is the choice of implementations available from different vendors. When one chooses a product, one of the selection criteria (besides performance) is the robustness of the implementation, as the crashing or hanging of such a HA middleware causes the failure of the whole system. The challenge is to develop the appropriate technology for measuring and comparing robustness of HA middleware implementations. Based on our earlier results, we present a set of automatic testing tools and a benchmark suite constructed using these tools. We demonstrate the robustness testing approach by comparing the results of benchmarking carried out on three HA middleware implementations.", "num_citations": "17\n", "authors": ["680"]}
{"title": "The Gamma statechart composition framework: Design, verification and code generation for component-based reactive systems\n", "abstract": " The Gamma Statechart Composition Framework is an integrated tool to support the design, verification and validation as well as code generation for component-based reactive systems. The behavior of each component is captured by a statechart, while assembling the system from components is driven by a domain-specific composition language. Gamma automatically synthesizes executable Java code extending the output of existing statechart-based code generators with composition related parts, and it supports formal verification by mapping composite statecharts to a back-end model checker. Execution traces obtained as witnesses during verification are back-annotated as test cases to replay an error trace or to validate external code generators.", "num_citations": "15\n", "authors": ["680"]}
{"title": "Scenario-based automated evaluation of test traces of autonomous systems\n", "abstract": " Testing the robustness and safety of autonomous systems (like do-mestic or manufacturing robots) is a challenging task since these systems can make decisions on their own depending on their environment. We proposed a model based testing approach to capture the context and basic safety-related be-havioural requirements of such systems, and to generate test data representing stressful contexts. During the execution of these tests in a real or simulator based test environment, the captured test traces shall be checked by comparison with the requirements in order to detect the violation of any requirement in each situation. In this paper we analyse this test evaluation problem and propose a method that can be used for efficient comparison.", "num_citations": "15\n", "authors": ["680"]}
{"title": "Runtime verification of statechart implementations\n", "abstract": " Our paper introduces a runtime verification framework for concurrent monitoring of applications specified by UML statecharts. The approach offers a considerable degree of granularity by (i) enabling the modeler to focus on specific key dependability criteria by defining temporal logic formulae over a behavioral model that is available even in early phases of the development and (ii) by supporting the verification of the final implementation against the fully elaborated UML statechart model. The paper presents an extension of the propositional linear temporal logic that fits to the advanced constructs of UML statecharts and an advanced watchdog scheme for concurrent supervision of program execution based on the statechart specification.", "num_citations": "15\n", "authors": ["680"]}
{"title": "Towards dependability modeling of FT-CORBA architectures\n", "abstract": " The paper presents techniques to support the dependability modeling and analysis of distributed object-oriented applications that are designed according to the Fault Tolerant CORBA (FT-CORBA) specification. First the construction of a high-level dependability model is described. It is based on the architecture of the application and allows the analysis of the fault tolerance strategies and properties that are directly supported by the standard infrastructure. Then a technique to construct a refined dependability model is presented. It exploits the detailed behavioral model of the object responsible for replica maintenance. The UML statechart of this object is transformed to a stochastic Petri net that forms the core of the dependability model. In this way the designer is allowed to utilize the full power of statecharts to construct models of application-dependent replication strategies and recovery policies.", "num_citations": "15\n", "authors": ["680"]}
{"title": "Towards system-level testing with coverage guarantees for autonomous vehicles\n", "abstract": " Since safety-critical autonomous vehicles need to interact with an immensely complex and continuously changing environment, their assurance is a major challenge. While systems engineering practice necessitates assurance on multiple levels, existing research focuses dominantly on component-level assurance while neglecting complex system-level traffic scenarios. In this paper, we aim to address the system-level testing of the situation-dependent behavior of autonomous vehicles by combining various model-based techniques on different levels of abstraction. (1) Safety properties are continuously monitored in challenging test scenarios (obtained in simulators or field tests) using graph query and complex event processing techniques. To precisely quantify the coverage of an existing test suite with respect regulations of safety standards, (2) we provide qualitative abstractions of causal, temporal, or geospatial\u00a0\u2026", "num_citations": "13\n", "authors": ["680"]}
{"title": "A formal specification method for PLC-based applications\n", "abstract": " The correctness of the software used in control systems has been always a high priority, as a failure can cause serious expenses, injuries or loss of reputation. To improve the quality of these applications, various development and verification methods exist. All of them necessitate a deep understanding of the requirements which can be achieved by a well-adapted formal specification method. In this paper we introduce a state machine and data-flow-based formal specification method tailored to PLC modules. This paper presents the practical benefits and new possibilities of this method, comprising consistency checking, PLC code generation, and checking equivalence between the specification and its previous versions or legacy code. The usage of these techniques can improve the level of understanding of the requirements and increase the confidence in the correctness of the implementation. Furthermore, they can help to apply formal verification techniques by providing formalised requirements.", "num_citations": "13\n", "authors": ["680"]}
{"title": "Design and analysis of fault tolerant architectures by model weaving\n", "abstract": " Aspect-oriented modeling is proposed to design the architecture of fault tolerant systems. Notations are introduced that support the separate and modularized design of functional and dependability aspects in UML class diagrams. This notation designates sensitive parts of the architecture and selected architecture patterns that implement common redundancy techniques. A model weaver is presented that constructs both the integrated model of the system and the dependability model on the basis of the analysis sub-models attached to the architecture patterns. In this way fault tolerance mechanisms can be systematically analyzed when they are integrated into the system.", "num_citations": "13\n", "authors": ["680"]}
{"title": "Hierarchical checking of multiprocessors using watchdog processors\n", "abstract": " A new control flow checking scheme, based on assigned-signature checking by a watchdog processor, is presented. This scheme is suitable for a multitasking, multiprocessor environment. The hardware overhead is comparatively low because of three reasons: first, hierarchically structured, the scheme uses only a single watchdog processor to monitor multiple processes or processors. Second, as an assigned-signature scheme it does not require monitoring the instruction bus of the processors. Third, the run-time and reference signatures are embedded into the checked program; thus, in the watchdog processor neither a reference database nor a time-consuming search and compare engine is required.", "num_citations": "13\n", "authors": ["680"]}
{"title": "PLC program translation for verification purposes\n", "abstract": " Programmable logic controllers are typically programmed in one of the five languages defined in the IEC 61131 standard. While the ability to choose the appropriate language for each program unit may be an advantage for the developers, it poses a serious challenge to verification methods. In this paper we analyse and compare these languages to show that the ST programming language can efficiently and conveniently represent all PLC languages for formal verification purposes. Furthermore, we provide a translation method from IL to ST programming languages (for the Siemens implementation), together with a sketch of proof for its correctness. This allows the usage of the ST-based PLCverif model checking method for safety PLC programs.", "num_citations": "12\n", "authors": ["680"]}
{"title": "Design and evaluation of a safe driver machine interface\n", "abstract": " Driver Machine Interface (DMI) is a slave unit of the train onboard computer in the ERTMS automatic train control system. The SAFEDMI project aimed at the development of a DMI which fulfills the requirements of Safety Integrity Level 2 according to the CENELEC development standards. The main challenges were (i) the reduction of the hardware complexity and costs by implementing the safety mechanisms in software and (ii) provide a safe and secure wireless communication interface to support diagnostics and maintenance. This paper presents the requirements, the design of the architecture and the wireless communication protocol, and the evaluation of the applied solutions.", "num_citations": "12\n", "authors": ["680"]}
{"title": "Tool-supported dependability evaluation of redundant architectures in computer based control systems\n", "abstract": " Architectural choices have a profound influence on the dependability of a computer system. Dependability modelling and analysis is a method proposed for the early evaluation of the system architecture and the related design decisions. We describe the design, implementation and application of a tool that is able to construct automatically a dependability model (in the form of Generalized Stochastic Petri Nets) on the basis of a system architecture model. The dependability model can be solved by an external solver, computing in this way the system-level reliability or availability measures. The tool is modular, extensible and supports the aspect-oriented design of redundancy structures.", "num_citations": "12\n", "authors": ["680"]}
{"title": "The hidenets holistic approach for the analysis of large critical mobile systems\n", "abstract": " Dealing with large, critical mobile systems and infrastructures where ongoing changes and resilience are paramount leads to very complex and difficult challenges for system evaluation. These challenges call for approaches that are able to integrate several evaluation methods for the quantitative assessment of QoS indicators which have been applied so far only to a limited extent. In this paper, we propose the holistic evaluation framework developed during the recently concluded FP6-HIDENETS project. It is based on abstraction and decomposition, and it exploits the interactions among different evaluation techniques including analytical, simulative, and experimental measurement approaches, to manage system complexity. The feasibility of the holistic approach for the analysis of a complete end-to-end scenario is first illustrated presenting two examples where mobility simulation is used in combination with\u00a0\u2026", "num_citations": "11\n", "authors": ["680"]}
{"title": "Concurrent error detection using watchdog processors\n", "abstract": " The trustworthiness of a computer system is characterized by its dependability. A system is dependable if''reliance can justifiably be placed the service it delivers''[Lap92]. Different attributes of the dependability are availability (readiness for usage), reliability (continuity of service), safety (avoidance of catastrophic consequences on the environment) and security (prevention of unauthorized access). The reliability of a system is a time dependent function, the probability that the lifetime of the system exceeds a predefined time (assumed that at zero system time its was operational). Availability is the probability that the system is operational at the given point in time.A system failure occurs when the service of the system does not comply with the specification, the behavior of the system deviates from that required by the user. The cause of a system failure is an erroneous transition of the system state, caused either the failure of a system component or an erroneous design. An error is that part of the system state (a defective value) which is liable to lead to failure. Whether or not an error leads to a failure depends on the system composition (applied redundancy) or on the activity of the system (an error may be overwritten). The adjudged or hypothesized cause of an error is a fault.", "num_citations": "11\n", "authors": ["680"]}
{"title": "Concurrent Error Detection of Program Execution Based on Statechart Specification\n", "abstract": " In common procedural and object-oriented programming languages the control flow of a program is a hierarchical structure. Concurrent error detectors proposed in previous works were able to check the sequence of statements in procedures and the procedure return addresses, but the problem of checking the allowed sequence of procedure calls and inter-process synchronization remained unsolved. In this paper we propose an approach of checking the higher-level program control flow using reference information based on UML statechart specification.", "num_citations": "10\n", "authors": ["680"]}
{"title": "Automatic Dependability Modelling of Systems Described in UML\n", "abstract": " Personal use of the material in this paper is permitted. However, permission to reprint or republish this material for advertising or promotional purposes or for creating new works for resale or redistribution, or to reuse any copyrighted component of this work in other works must be obtained from the authors of this paper.", "num_citations": "10\n", "authors": ["680"]}
{"title": "Efficient decomposition algorithm for stationary analysis of complex stochastic Petri net models\n", "abstract": " Stochastic Petri nets are widely used for the modeling and analysis of non-functional properties of critical systems. The state space explosion problem often inhibits the numerical analysis of such models. Symbolic techniques exist to explore the discrete behavior of even complex models, while block Kronecker decomposition provides memory-efficient representation of the stochastic behavior. However, the combination of these techniques into a stochastic analysis approach is not straightforward. In this paper we integrate saturation-based symbolic techniques and decomposition-based stochastic analysis methods. Saturation-based exploration is used to build the state space representation and a new algorithm is introduced to efficiently build block Kronecker matrix representation to be used by the stochastic analysis algorithms. Measurements confirm that the presented combination of the two\u00a0\u2026", "num_citations": "9\n", "authors": ["680"]}
{"title": "Uml based design of time triggered systems\n", "abstract": " This paper presents how the platform-specific development environment of time-triggered (TT) systems can be integrated with a visual design toolkit based on UML. The built-in facilities of UML and the modeling extensions introduced by us enable the unification of the advantages provided by both the embedded development environment and the UML tools. UML offers visual design, automatic code and documentation generation, while the underlying TT development environment offers platform-specific task and communication scheduling and fault tolerance middleware construction. This results in an integrated system that is capable of supporting the entire development within the framework of the UML tool", "num_citations": "9\n", "authors": ["680"]}
{"title": "Mixed-semantics composition of statecharts for the component-based design of reactive systems\n", "abstract": " The increasing complexity of reactive systems can be mitigated with the use of components and composition languages in model-driven engineering. Designing composition languages is a challenge itself as both practical applicability (support for different composition approaches in various application domains), and precise formal semantics (support for verification and code generation) have to be taken into account. In our Gamma Statechart Composition Framework, we designed and implemented a composition language for the synchronous, cascade synchronous and asynchronous composition of statechart-based reactive components. We formalized the semantics of this composition language that provides the basis for generating composition-related Java source code as well as mapping the composite system to a back-end model checker for formal verification and model-based test case generation\u00a0\u2026", "num_citations": "8\n", "authors": ["680"]}
{"title": "Industrial applications of the PetriDotNet modelling and analysis tool\n", "abstract": " Since their invention, Petri nets have provided modelling and analysis methods to support the design of correct, reliable and robust systems. This motivated our work to develop PetriDotNet, a Petri net editor and analysis tool. In this paper we overview the supported modelling formalisms and the analysis methods included in PetriDotNet. Next, we present eight different industrial case studies, demonstrating the wide variety of scenarios where Petri nets and PetriDotNet can help the design, development and analysis of industrial systems. Our original goal with PetriDotNet was to provide an educational tool to our students, however our efforts led to a framework being able to serve both academic and industrial needs.", "num_citations": "8\n", "authors": ["680"]}
{"title": "Lazy reachability checking for timed automata using interpolants\n", "abstract": " To solve the reachability problem for timed automata, model checkers usually apply forward search and zone abstraction. To ensure efficiency and termination, the computed zones are generalized using maximal constants obtained from guards either by static analysis or lazily for a given path. In this paper, we propose a lazy method based on zone abstraction that, instead of the constants in guards, considers the constraints themselves. The method is a combination of forward search, backward search and interpolation over zones: if the zone abstraction is too coarse, we propagate a zone representing bad states backwards using backward search, and use interpolation to extract a relevant zone to strengthen the current abstraction. We propose two refinement strategies in this framework, and evaluate our method on the usual benchmark models for timed automata. Our experiments show that the proposed\u00a0\u2026", "num_citations": "8\n", "authors": ["680"]}
{"title": "PetriDotNet 1.5: Extensible Petri Net Editor and Analyser for Education and Research\n", "abstract": " PetriDotNet is an extensible Petri net editor and analysis tool originally developed to support the education of formal methods. The ease of use and simple extensibility fostered more and more algorithmic developments. Thanks to the continuous interest of developers (especially M.Sc. and Ph.D. students who choose PetriDotNet as the framework of their thesis project), by now PetriDotNet became an analysis platform, providing various cutting-edge model checking algorithms and stochastic analysis algorithms. As a result, industrial application of the tool also emerged in recent years. In this paper we overview the main features and the architecture of PetriDotNet, and compare it with other available tools.", "num_citations": "8\n", "authors": ["680"]}
{"title": "A resilient SIL 2 driver machine interface for train control systems\n", "abstract": " In railway train-borne equipment, the driver machine interface (DMI) acts like a bridge between the train driver and the onboard automatic train control system (European Vital Computer, EVC). While the DMI is required to operate in a critical context, current DMIs have no safety requirements. This implies that the EVC may automatically stop the train whenever the DMI is suspected to misbehave, leading to delay of the train, inconvenience for passengers and consequent possible profit loss. For these reasons a DMI with higher safety requirements is worth to be taken into account, even if it implies higher costs. The SAFEDMI European project aims at developing (i) a DMI at Safety Integrity Level 2 (SIL 2) using off-the-shelf components and a simple hardware architecture to reduce costs, and (ii) a SIL 2 wireless communication support for maintenance. This paper describes the architecture of a DMI which satisfies\u00a0\u2026", "num_citations": "8\n", "authors": ["680"]}
{"title": "Impact of statechart implementation techniques on the effectiveness of fault detection mechanisms\n", "abstract": " This work presents the analysis of an experiment series aiming at the discovery of the impact of two inherently different statechart implementation methods on the behavior of the resulting executables in the presence of faults. The discussion identifies the key features of implementation techniques influencing the effectiveness of standard fault detection mechanisms (memory protection, assertions etc.) and an advanced statechart-level watchdog scheme used for detecting the deviations from the abstract implementation-independent behavioral specification.", "num_citations": "8\n", "authors": ["680"]}
{"title": "Conformance checking for programmable logic controller programs and specifications\n", "abstract": " Verification of industrial control systems' software is an important task, as the cost of failure in these systems is typically high. Formal verification methods can complement the currently used testing techniques, especially if requirements are formally specified. Behavioural specifications can be used to perform conformance checking against the implementation. However, the typical conformance relations are often more sensitive to differences than the controlled processes in case of many control systems, resulting in counterexamples during verification that are considered as false positives in practice. To overcome this issue, we introduce conformance relations adapted to control systems based on programmable logic controllers (PLCs) with different levels of permissibility. The relations can be selected by the control engineers, depending on the required compliance levels. Defining the new relations and a model\u00a0\u2026", "num_citations": "7\n", "authors": ["680"]}
{"title": "Component-wise incremental LTL model checking\n", "abstract": " Efficient symbolic and explicit-state model checking approaches have been developed for the verification of linear time temporal logic (LTL) properties. Several attempts have been made to combine the advantages of the various algorithms. Model checking LTL properties usually poses two challenges: one must compute the synchronous product of the state space and the automaton model of the desired property, then look for counterexamples that is reduced to finding strongly connected components (SCCs) in the state space of the product. In case of concurrent systems, where the phenomenon of state space explosion often prevents the successful verification, the so-called saturation algorithm has proved its efficiency in state space exploration. This paper proposes a new approach that leverages the saturation algorithm both as an iteration strategy constructing the product directly, as well as in a new fixed\u00a0\u2026", "num_citations": "7\n", "authors": ["680"]}
{"title": "MDD-based design, configuration, and monitoring of resilient cyber-physical systems\n", "abstract": " Traditional embedded system design relies on a strict design time resource allocation in providing a sufficiently dependable platform for critical applications. In contrast, the dynamic nature of cloud platforms necessitates not only the deployment of functional components of applications, but also for an extension with appropriate measures to maintain the required level of service during the operation phase. In this way, the core problem addressed in the current chapter deals with the creation of a virtually \u201ccarrier grade\u201d platform even if the underlying physical cloud is not of a distinguishably high service level. Provisioning a high Service Level Agreement (SLA) over inexpensive computing platforms is one of the problems addressed previously in the context of autonomic computing. Kephart and Chess [1] identifies four main self-* strategies (self-configuration, selfhealing, self-protection, and self-optimization) to achieve\u00a0\u2026", "num_citations": "6\n", "authors": ["680"]}
{"title": "Generic representation of PLC programming languages for formal verification\n", "abstract": " Programmable Logic Controllers are typically programmed in one of the five languages defined in the IEC 61131 standard. While the ability to choose the appropriate language for each program unit may be an advantage for the developers, it poses a serious challenge to verification methods. In this paper we analyse and compare these languages to show that the ST programming language can efficiently and conveniently represent all PLC languages for formal verification purposes.", "num_citations": "6\n", "authors": ["680"]}
{"title": "Control flow checking in multitasking systems\n", "abstract": " The control flow checking technique presented in our paper is based on the new watchdog-processor method SEIS1 (Signature Encoded Instruction Stream). This method is in-tended to check the still uncovered area of state-of-the-art microprocessors using on-chip caches or instruction pipelines, since the processor instruction bus needs not be monitored. The control flow is checked using assigned actual signatures and embedded reference sig-natures. Since the actual and reference signatures are embedded in the checked program, the usual reference database and the time-consuming search/compare engine in the watch-dog can be omitted. The evaluation of the actual signature is a simple combinatorial task allowing high speed and thus the sharing of the watchdog between different tasks and processors. The checking method has been extended to higher levels of the application like simultaneous check of different processes and their synchronization in multitasking systems.", "num_citations": "6\n", "authors": ["680"]}
{"title": "Model checking-based software-FMEA: Assessment of fault tolerance and error detection mechanisms\n", "abstract": " Failure Mode and Effects Analysis (FMEA) is a systematic  technique to explore the possible failure modes of individual  components or subsystems and determine their potential  effects at the system level. Applications of FMEA are common  in case of hardware and communication failures, but analyzing  software failures (SW-FMEA) poses a number of challenges.  Failures may originate in permanent software faults commonly  called bugs, and their effects can be very subtle and hard to  predict, due to the complex nature of programs. Therefore, a  behavior-based automatic method to analyze the potential  effects of different types of bugs is desirable. Such a  method could be used to automatically build an FMEA report  about the fault effects, or to evaluate different failure  mitigation and detection techniques. This paper follows the  latter direction, demonstrating the use of a model checking- based automated SW-FMEA approach to evaluate error detection  and fault tolerance mechanisms, demonstrated on a case study  inspired by safety-critical embedded operating systems.", "num_citations": "5\n", "authors": ["680"]}
{"title": "Requirements towards a formal specification language for PLCs\n", "abstract": " One of the main obstacles of using formal verification for complex PLC (Programmable Logic Controller) programs is the lack of formal requirements. There are no widely used specification methods that could serve as input for formal verification; also that could help the developers to capture the behaviour and handle the complexity of these programs.The goal of this research is to bring formal specification closer to the PLC domain in order to help the development, verification and maintenance. This paper aims to briefly overview the particularities of the PLC domain and the state of the art in formal specification. Then it collects the requirements towards a PLC-specific formal specification language based on general works, comparative case studies and own experiences at CERN. Also, it draws up a sketch of a possible specification method that follows the collected requirements.", "num_citations": "5\n", "authors": ["680"]}
{"title": "Tool support for engineering certifiable software\n", "abstract": " Formal methods can effectively support the model driven develoment and analysis of IT applications in many domains. Typically, the domain-specific engineering models are transformed to formal analysis models (to compute measures that help the designer in verifying the design decisions) and verified models are mapped to test and implementation related software artefacts. An overview of four European projects demonstrates the use of support tools and tool integration facilities in development processes of systems having in sight the demand of certification according to domain-specific standards.", "num_citations": "5\n", "authors": ["680"]}
{"title": "High-level supervision of program execution based on formal specification\n", "abstract": " This paper presents an approach for concurrently supervising the execution of applications specified by UML statecharts and a corresponding instrumentation scheme. The run-time verification is implemented by a statechart-level monitor while the instrumentation is based on Aspect-Oriented Programming.", "num_citations": "5\n", "authors": ["680"]}
{"title": "UML based Visual Design of Embedded Systems\n", "abstract": " This paper presents an approach for connecting visual UML modeling environments and platform-specific toolkits of embedded systems. The resulting development suite promises the unification of advantages of the two areas: UML CASE tools with the modeling extensions proposed in the paper offer visual design, automatic code and documentation generation, while the platform-specific environments provide means for task and communication scheduling and fault-tolerant middleware construction. Our approach is illustrated by a case study.", "num_citations": "5\n", "authors": ["680"]}
{"title": "Stochastic Dependability Analysis of System Architecture based on UML Designs\n", "abstract": " The work in this paper1 is devoted to the definition of a dependability modeling and model based evaluation approach based on UML models. It is to be used in the early phases of the system design to capture system dependability attributes like reliability and availability, thus providing guidelines for the choice among different architectural and design solutions. We show how structural UML diagrams can be processed to filter out the dependability related information and how a system-wide dependability model is constructed. Due to the modular construction, this model can be refined later as more detailed information becomes available. We discuss the model refinement based on the General Resource Model, an extension of UML. We show that the dependability model can be constructed automatically by using graph transformation techniques.", "num_citations": "5\n", "authors": ["680"]}
{"title": "Software monitoring and debugging using compressed signature sequences\n", "abstract": " Signature based error detection techniques (e.g. the application of watchdog processors) can be easily extended to support software debugging. The run-time sequence of signatures is stored in an extension of the traditional checker. As the signatures identify the states of the program, a trace of the statements executed by the checked processor is available. The signature buffer can be efficiently utilized if the signature sequence is compressed. In the paper, two real-time compression methods are presented and compared. The general method uses predefined dictionaries, while the other one utilizes the structural information encoded in the signatures.", "num_citations": "5\n", "authors": ["680"]}
{"title": "Lazy reachability checking for timed automata with discrete variables\n", "abstract": " Systems and software with time dependent behavior are often formally specified using timed automata. For practical real-time systems, these specifications typically contain discrete data variables with nontrivial data flow besides real-valued clock variables. In this paper, we propose a lazy abstraction method for the location reachability problem of timed automata that can be used to efficiently control the visibility of discrete variables occurring in such specifications, this way alleviating state space explosion. The proposed abstraction refinement strategy is based on interpolation for variable assignments and symbolic backward search. We combine in a single algorithm our abstraction method with known efficient lazy abstraction algorithms for the handling of clock variables. Our experiments show that the proposed method performs favorably when compared to other lazy methods, and is suitable to\u00a0\u2026", "num_citations": "4\n", "authors": ["680"]}
{"title": "What is special about PLC software model checking?\n", "abstract": " Model checking is a formal verification technique to check given properties of models, designs or programs with mathematical precision. Due to its high knowledge and resource demand, the use of model checking is restricted mainly to core parts of highly critical systems. However, we and many other authors have argued that automated model checking of PLC programs is feasible and beneficial in practice. In this paper we aim to explain why model checking is applicable to PLC programs even though its use for software in general is too difficult. We present an overview of the particularities of PLC programs which influence the feasibility and complexity of their model checking. Furthermore, we list the main challenges in this domain and the solutions proposed in previous works.", "num_citations": "4\n", "authors": ["680"]}
{"title": "Model-based regression testing of autonomous robots\n", "abstract": " Testing is a common technique to assess quality of systems. Regression testing comes into view, when changes are introduced to the system under test and re-running all tests is not practical. Numerous techniques have been introduced to select tests only relevant to a given set of changes. These are typically based on source code, however, model-based development projects use models as primary artifacts described in various domain-specific languages. Thus, regression test selection should be performed directly on these models. We present a method and a case study on how model-based regression testing can be achieved in the context of autonomous robots. The method uses information from several domain-specific languages for modeling the robot\u2019s context and configuration. Our approach is implemented in a prototype tool, and its scalability is evaluated on models from the case study.", "num_citations": "4\n", "authors": ["680"]}
{"title": "Constraint programming with multi-valued decision diagrams: a saturation approach\n", "abstract": " Constraint programming is a declarative way of modeling and solving optimization and satisfiability problems over finite domains. Traditional solvers use search-based strategies enhanced with various optimizations to reduce the search space. One of such techniques involves multi-valued decision diagrams (MDD) to maintain a superset of potential solutions, gradually discarding combinations of values that fail to satisfy some constraint. Instead of the relaxed MDDs representing a superset, we propose to use exact MDDs to compute the set of solutions directly without search, compactly encoding all the solutions instead of enumerating them. Our solution relies on the main idea of the saturation algorithm used in model checking to reduce the required computational cost. Preliminary results show that this strategy can keep the size of intermediate MDDs small during the computation.", "num_citations": "4\n", "authors": ["680"]}
{"title": "Configurable numerical analysis for stochastic systems\n", "abstract": " Stochastic aspects of complex systems require more and more involved analysis approaches. Answering reachability and related analysis questions can often be reduced to steady-state, transient, reward or sensitivity value analysis of stochastic models. In this paper we introduce a configurable stochastic analysis framework which supports the user to combine explicit, symbolic and numerical algorithms to efficiently compute the measures of stochastic models. Beyond the well-known algorithms from the field, we also developed an experimental version of an Induced Dimensionality Reduction Stabilized numerical solver to compute steady-state probabilities of Markovian models. As far as we know, this is the first attempt to exploit this algorithm in stochastic analysis. We have conducted experiments on different combinations of the algorithms on various models to assess their advantages and disadvantages in the\u00a0\u2026", "num_citations": "4\n", "authors": ["680"]}
{"title": "Modelling and model-based assessment\n", "abstract": " This chapter provides an overview of the state of knowledge related to stochastic model-based assessment approaches, which are most commonly used for resiliency evaluation of current computing systems. The chapter first introduces a set of representative surveys developed in recent European projects, and then it provides a deeper description of common techniques used in model-based assessment of resilient systems. The most widely used modelling formalisms are reviewed, with a particular focus on state-based formalisms like Stochastic Petri Nets and its extensions. Techniques used in model construction and solution are also discussed, as well as the different classes of analysis tools and frameworks. The techniques analyzed in the chapter span from largeness avoidance and largeness tolerance techniques to more comprehensive modelling approaches that are integrated in the system\u2019s\u00a0\u2026", "num_citations": "4\n", "authors": ["680"]}
{"title": "Model-based Integration Framework for Development and Testing Tool-chains \u2605\n", "abstract": " System development processes are typically supported by dozens of different tools that assist the designer in various phases of development like modeling, verification, source code generation, testing. Tool-chains can be formed by the integration of tools that are related to the subsequent steps of the process. In this paper, we present a service-oriented, metamodel-driven, process-centric approach for the definition and execution of these tool-chains. Related data are handled as an important part of the process as the traceability of these is needed for the certification of the systems. The implementation is provided as an open, extensible framework. The approach is demonstrated using a model based test case generation process applied for automotive and railway systems.", "num_citations": "4\n", "authors": ["680"]}
{"title": "Modular construction of dependability models from system architecture models: a tool-supported approach\n", "abstract": " Model based dependability analysis can be used to evaluate the effects of architectural choices on system level availability and reliability. In component based systems the dependability model is built typically from sub-models that are assigned to components or subsystems and represent the local fault occurrences and error propagation. We describe the design and application of a tool that is able to construct the system level dependability model from these sub-models automatically, on the basis of the architecture model of the system. In our tool currently UML architecture model and stochastic activity networks dependability model formalism are supported.", "num_citations": "4\n", "authors": ["680"]}
{"title": "Temporal analysis of data flow control systems\n", "abstract": " Due to their distributed/parallel and data-driven nature, control systems can easily be modeled according to a data flow approach. Control systems are very often real-time systems; therefore, a formalism able to capture timing is required. In this paper we introduce a data flow model that includes time and priority for specifying real-time control systems and we give its formal semantics. The control system is specified by a data flow network which, beside the controller, may include the model of the plant at some abstraction level. Time is associated to any computational activity and time accounting is made directly in the model and not as a separate issue. Priorities allow to deal with events, as alarm signals, which cannot be delayed. A general framework for the indirect evaluation of the model is introduced, and a data flow network to timed Petri net transformation is defined allowing the utilization of the automatic tools of\u00a0\u2026", "num_citations": "4\n", "authors": ["680"]}
{"title": "Exploiting hierarchy in the abstraction-based verification of statecharts using SMT solvers\n", "abstract": " Statecharts are frequently used as a modeling formalism in the design of state-based systems. Formal verification techniques are also often applied to prove certain properties about the behavior of the system. One of the most efficient techniques for formal verification is Counterexample-Guided Abstraction Refinement (CEGAR), which reduces the complexity of systems by automatically building and refining abstractions. In our paper we present a novel adaptation of the CEGAR approach to hierarchical statechart models. First we introduce an encoding of the statechart to logical formulas that preserves information about the state hierarchy. Based on this encoding we propose abstraction and refinement techniques that utilize the hierarchical structure of statecharts and also handle variables in the model. The encoding allows us to use SMT solvers for the systematic exploration and verification of the abstract model, including also bounded model checking. We demonstrate the applicability and efficiency of our abstraction techniques with measurements on an industry-motivated example.", "num_citations": "3\n", "authors": ["680"]}
{"title": "K-induction based verification of real-time safety critical systems\n", "abstract": " Nowadays, safety critical systems are often complex, real-time systems requiring formal methods to prove the correctness of their behavior. This work presents a framework that supports modeling and model checking such systems. We adapted an existing formalism to provide better modeling and model checking support. Using this formalism, we extended a k-induction based model checking approach: we defined a procedure to handle both safety and liveness properties, and developed methods to find invariants. We implemented a toolchain for this workflow and evaluated our methods in an industrial case study.", "num_citations": "3\n", "authors": ["680"]}
{"title": "Development of model based tools to support the design of railway control applications\n", "abstract": " The development standard for railway control software requires several design and verification methods. To support these methods we elaborated a coherent set of tools based on UML state diagrams. To avoid the problems of the ambiguous UML semantics, we propose a subset of UML state machines that includes the practical modeling concepts and has well-defined operational semantics elaborated definitely for software engineers. Based on this formalism we developed a tool chain supporting (i) the simulation of the behavior specified by the state diagram, (ii) static checking the completeness and consistency of the specification, (iii) generation of the C source of the application control flow, (iv) automatic construction of test cases on the basis of structural test coverage criteria and (v) automatic construction of the source code of run-time verification procedures that aim at checking high-level safety\u00a0\u2026", "num_citations": "3\n", "authors": ["680"]}
{"title": "Model based automatic code generation for embedded systems\n", "abstract": " Our paper presents a method for the automatic generation of program source code for embedded systems on the basis of behavioral models. The solution is based the UML\u2019s statechart formalism focusing on embedded systems with limited computing resources as target platform. Our approach follows OMG\u2019s Model Driven Architecture (MDA) initiative by (i) first defining the platform independent (PIM) metamodel and semantics of statechart models,(ii) then introducing platform specific (PSM) metamodel and semantics that are fitted to specialties of resource constrained systems finally (iii) implementing the PSM data model and algorithms in a programming language.", "num_citations": "3\n", "authors": ["680"]}
{"title": "Automatic implementation of extended hierarchical automata\n", "abstract": " This paper introduces an implementation strategy for UML statecharts developed by us. The code generation is based on Extended Hierarchical Automata, the intermediate representation of statecharts. The driving force of this development was our always recurring need for an efficient code generation strategy that is completely controlled by us and can be the base of our future research. The solution presented here can be considered to be neither a fine-tuned implementation nor a finished work just a prototype, the backbone of a future code generator framework that is capable of supporting our advanced goals. This way several design and implementation issues are left open by the approach presented here.", "num_citations": "3\n", "authors": ["680"]}
{"title": "A High-speed Watchdog Processor for Multitasking Systems\n", "abstract": " A new watchdog processor scheme for concurrent checking of program control flow is presented. This method is intended to check state of the art processor architectures with on-chip caches as building blocks of multiprocessor systems. The signatures are assigned, so that the processor instruction bus needs not be monitored. The run-time and reference signatures are embedded into the checked program, making obsolete the reference database and the time-consuming search and compare engine in the watchdog processor. The scheme is extended to check multitasking and multiprocessor systems.", "num_citations": "3\n", "authors": ["680"]}
{"title": "Saturation enhanced with conditional locality: application to Petri Nets\n", "abstract": " The saturation algorithm for symbolic state space generation has proved to be an efficient way to tackle the state space explosion problem in the verification of concurrent, asynchronous systems. Since its original publication in 2001, several variants and extensions have been introduced. The reason for altering the algorithm in these variants is often specific to how it handles transitions. Saturation heavily relies on the notion of locality: transitions tend to affect only some of the state variables. The saturation effect, however, can be achieved and even enhanced with a weaker notion of locality, which we call conditional locality. In this paper, we define a generalized version of the saturation algorithm (GSA) for multi-valued decision diagrams that works with conditional locality and show that it enables the direct usage of transition relations that previously required a specialized algorithm such as variants of\u00a0\u2026", "num_citations": "2\n", "authors": ["680"]}
{"title": "Constructing dependability analysis models of reconfigurable production systems\n", "abstract": " Model-driven engineering methodologies are often used for the design and integration of the software and hardware components in automated production systems. Architecture models in general purpose or domain specific modeling languages allow the modular and systematic construction of formal analysis models for the evaluation of dependability and performability. The on-line reconfiguration and fault handling actions in the system introduce changes in the architecture and parameters, and thus result in a multi-phased operation. We propose a mission automaton formalism to describe reconfigurations, fault handling and parameter changes over architecture models. By maintaining the architecture model, which is modified by the reconfigurations, along with the corresponding analysis models, a stochastic phased-mission system (PMS) is obtained and solved for dependability.", "num_citations": "2\n", "authors": ["680"]}
{"title": "Getting the priorities right: saturation for prioritised Petri Nets\n", "abstract": " Prioritised Petri net is a powerful modelling language that often constitutes the core of even more expressive modelling languages such as GSPNs (Generalized Stochastic Petri nets). The saturation state space traversal algorithm has proved to be efficient for non-prioritised concurrent models. Previous works showed that priorities may be encoded into the transition relation, but doing so defeats the main idea of saturation by spoiling the locality of transitions. This paper presents an extension of saturation to natively handle priorities by considering the priority-related enabledness of transitions separately, adopting the idea of constrained saturation. To encode the highest priority of enabled transitions in every state we introduce edge-valued interval decision diagrams. We show that in case of Petri nets, this data structure can be constructed offline. According to preliminary measurements, the proposed\u00a0\u2026", "num_citations": "2\n", "authors": ["680"]}
{"title": "A Decomposition Method for the Verification of a Real-Time Safety-Critical Protocol\n", "abstract": " Formal methods, especially model checking techniques, are often used for the verification of the resilience of safety critical systems. The usual complexity of the verification problem in real life systems (due to state space explosion and the handling of time dependent behavior) demands efficient techniques. In this paper we propose a decomposition approach: the layered structure of the system is exploited to decompose the verification problem to smaller and tractable ones. In addition, the structure of the requirements (formalized as the combination of reachability and liveness properties) is also exploited to construct simpler verification problems for the model checker. The decomposition approach is demonstrated in case of the verification of a distributed protocol in a SCADA system that shall provide functionality even after the occurrence of a finite number of transient faults.", "num_citations": "2\n", "authors": ["680"]}
{"title": "Automated evaluation of the test traces of autonomous systems\n", "abstract": " Autonomous systems can make and execute decisions to achieve their goals without direct human control [Connelly 2006]. A significant part of these systems, for example autonomous robots used in the household or manufacturing, operate in real, uncontrolled environment, thus they must properly react to unexpected combinations of environmental objects and events: they shall be robust to be capable of correctly handling unforeseen situations and safe to avoid harmful effects with respect to humans. This way the evaluation of their robustness (precisely, the degree to which they can function correctly in the presence of invalid inputs or stressful environmental conditions) and functional safety forms an important part of their verification and validation.To support the testing of the robustness and safety of the context-aware behaviour of autonomous robots, in the R3-COP project [R3-COP] we developed a model based testing concept [Micskei 2012]. It is characterized by three main components:(1) context and requirements modelling to represent test requirements,(2) a search based test generation method to derive stressful contexts for robustness testing, and (3) an automated off-line test evaluation approach. We focused on the systematic generation of the stressful contexts that can be derived from the context model and the behavioural requirements, in order to satisfy robustness related test goals and related coverage criteria.", "num_citations": "2\n", "authors": ["680"]}
{"title": "The integra tool integration framework\n", "abstract": " System development processes\u2013especially in case of model-based development\u2013are typically supported by dozens of different tools that assist the designer in the modeling, verification, source code generation, and testing tasks. Tool-chains can be formed by the integration of tools that are related to the subsequent steps of the development process. INTEGRA is our service-oriented, metamodel-driven, process-centric tool integration framework that supports the definition and execution of these tool-chains. In this paper, we present how process modeling and process management is targeted in this framework. The underlying approach is based on platform independent, UML activity compliant process models, that are transformed automatically to platfom specific process models executable by widely used workflow engines. These engines are also integrated with the execution and monitoring part of the framework\u00a0\u2026", "num_citations": "2\n", "authors": ["680"]}
{"title": "Ontology-based assessment of software models and development processes for safety-critical systems\n", "abstract": " Ontology-based assessment of software models and development processes for safety-critical systems Toggle navigation M\u0171egyetemi Digit\u00e1lis Archivum magyar English English magyar English Login Toggle navigation View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item Ontology-based assessment of software models and development processes for safety-critical systems Thumbnail View/Open 88962.doc (1.436Mb) Metadata Show full item record Link to refer to this document: http://hdl.handle.net/10890/4012 Collections BME PA dokumentumai [3731] Title Ontology-based assessment of software models and development processes for safety-critical systems Author Szatm\u00e1ri, Zolt\u00e1n Izs\u00f3, Benedek Polg\u00e1r, Bal\u00e1zs Majzik, Istv\u00e1n Date of issue 2010 Language en Identifiers \u2026", "num_citations": "2\n", "authors": ["680"]}
{"title": "Formal methods in the evaluation of a safe driver-machine interface\n", "abstract": " Driver Machine Interface (DMI) is a slave unit of the train onboard computer (EVC) in the ERTMS-ATC system. The SAFEDMI project aimed at the development of a DMI which fulfills the requirements of Safety Integrity Level 2 according to the CENELEC development standards. Formal methods were successfully applied in the quantitative evaluation of the DMI. This paper presents an overview of these methods applied for the evaluation of the architecture, the wireless communication protocol, and the detection codes and residual errors.", "num_citations": "2\n", "authors": ["680"]}
{"title": "Automated Verification of Complex Behavioral Models Using the SAL Model Checker\n", "abstract": " Automated Verification of Complex Behavioral Models Using the SAL Model Checker Toggle navigation M\u0171egyetemi Digit\u00e1lis Archivum magyar English English magyar English Login Toggle navigation View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item Automated Verification of Complex Behavioral Models Using the SAL Model Checker Thumbnail View/Open 39780.pdf (322.7Kb) Metadata Show full item record Link to refer to this document: http://hdl.handle.net/10890/2997 Collections BME PA dokumentumai [3731] Title Automated Verification of Complex Behavioral Models Using the SAL Model Checker Author Sisak, \u00c1ron Pint\u00e9r, Gergely Majzik, Istv\u00e1n Date of issue 2008 Publisher L'Harmattan Kiad\u00f3 Language en Identifiers MTMT: 2628979 Title of the container \u2026", "num_citations": "2\n", "authors": ["680"]}
{"title": "Aspect-oriented modelling and analysis of information systems\n", "abstract": " In this paper we introduce an approach of aspect-oriented modelling and analysis of information systems. First we give an overview of the concepts of Aspect Oriented Programming and provide an outlook to model aspect-oriented programs. On the basis of this introduction, we describe a method of using aspects at the modelling level and weaving them into a single integrated model. Finally, we extend this framework with the automatic construction of analysis models based on separate aspect models. In our example, fault tolerance structures are modelled by aspects and the analysis model is a dependability model that is used to determine the non-functional properties of the system like reliability and availability. In this way the separate design of the functionality and the dependability is supported and the design decisions concerning fault tolerance can be analysed on the basis of the dependability model.", "num_citations": "2\n", "authors": ["680"]}
{"title": "Error Detection in Control Flow of Event-Driven State Based Applications\n", "abstract": " This chapter presents two runtime error detection techniques for UML 2.0 statechart implementations. The first technique aims at detecting errors caused by model refinement faults (introduced in early phases of the development) by proposing a temporal logic language to be used for defining and checking temporal correctness criteria on statecharts. The second solution is a watchdog structure aiming at detection of errors caused by implementation faults. The solutions can detect a subset of errors emerging from operational fault as well.", "num_citations": "2\n", "authors": ["680"]}
{"title": "Supporting Design and Development of Safety Critical Applications\n", "abstract": " Application of computer based systems in such safety critical areas like power plants, railway control, aerospace, defense etc. poses extraordinary high de-pendability requirements against the corresponding software artifacts. This paper outlines a coherent chain of tools providing formally well-established support for the key phases of dependable software development involving simulation, static model checking, automatic code generation, automatic test case synthesis and run-time error detection. Our approach focuses on modeling behavioral aspects by UML 2.0 statecharts as specification formalism. The application example ana-lyzed in the paper was taken from the railway control domain.", "num_citations": "2\n", "authors": ["680"]}
{"title": "Automated construction of dependability models by aspect-oriented modeling and model transformation\n", "abstract": " In order to support the dependability analysis of a system under design in an early phase of the design process, so-called fault tolerance libraries can be created that contain both the architecture and the analysis model of a given fault tolerance pattern. The concepts of the Aspect Oriented Programming paradigm can be applied at the modeling level to designate how the patterns in the fault tolerance library and the architectural UML model can be integrated. A model transformation is applied to \u201cweave\u201d the architecture model and the fault tolerance scheme into an integrated model, and to transform it into a Stochastic Petri Net dependability model. This paper discusses the implementation aspects of model weaving and analysis model construction.", "num_citations": "2\n", "authors": ["680"]}
{"title": "Abstract Model-Based Checkpoint and Recovery\n", "abstract": " The most frequent cause of service unavailability in computer systems is related to transient hardware or software faults. A common way for addressing these issues is based on introducing a checkpoint and recovery schema. Checkpoint generation means the periodic saving the process state into a stable storage. This image can be used for restarting the process from the previously saved state reducing this way the processing time loss to the interval between the checkpoint creation and the failure. Although the core idea is relatively simple, its implementation can get very complicated in case of complex internal data structures since the representation of an object model in the non-volatile storage and the transmission between the memory and the storage requires significant programming effort. This paper aims at proposing an automatic code generation scheme that provides a transparent and platformindependent facility for persisting object structures of arbitrary complexity in stable storage.There are several function libraries supporting the checkpoint creation and state recovery directly. These approaches typically do not address the problem of storage and reconstruction of complex data structures, usually provide the capability of saving and loading unstructured blocks of memory only [1]. These low-level methods make the persistent storage of many interconnected objects difficult and error-prone. The solution proposed in [2] depends on a service of the UNIX operating system for saving the entire memory image and register set in a file. The drawback of this strategy is the dependence on a specific operating system feature therefore lack of\u00a0\u2026", "num_citations": "2\n", "authors": ["680"]}
{"title": "Code Generation Based on UML Statecharts\n", "abstract": " This article discusses implementation possibilities of UML statecharts. After a short introduction to UML statecharts the common implementation approaches are introduced with emphasis on their hardware requirements and features covered by them. At the end of the discussion a modified form of a design pattern outlined previously is suggested resulting in an efficient solution that is capable of implementing most of the UML statechart elements. The problem has emerged in a research targeting implementation possibilities of automatic self checking of program execution. The expected outcome of this project is a code generator extension that is able to create not only the control core of the application but to implement modules for run-time self checking, inserting methods supporting testing (observers, invariant checks) and to create test cases and harnesses for classic testing as well. This way the UML model serves\u00a0\u2026", "num_citations": "2\n", "authors": ["680"]}
{"title": "Hardware Accelerators for Petri-net Analysis\n", "abstract": " For reachability analysis of Petri-nets an FPGAbased accelerator is proposed. Since the simple components of Petri-nets can be easily realized in high-density FPGAs, the complete problem can be mapped to silicon providing a solution environment faster than the traditional softwarebased simulators. Some classes of Petri-nets support the compositional analysis, this way the limited capacity of the FPGA does not prevent the investigation of real-life problems. Keywords: Petri-nets, veri# cation, hardware accelerators I", "num_citations": "2\n", "authors": ["680"]}
{"title": "Modeling and analysis of an industrial communication protocol in the Gamma framework\n", "abstract": " Communication protocols are often designed on the basis of state-based models. During protocol design, the use of formal verification is indispensable, as concurrent behavior is notorious for hidden and sophisticated bugs. This paper presents a formal verification approach to verify an industrial communication protocol using the Gamma Statechart Composition Framework. Gamma is a modeling toolset for the design and analysis of reactive systems. It supports a family of modeling languages with formal semantics for the componentbased definition of state-based behavior. It also supports formal verification by automatically mapping the defined models to the input formalisms of verification backends and back-annotating the results. The verification approach is presented in the context of the Orion industrial communication protocol. The verification approach supports the introduction of channel models with different message transmission characteristics and failure modes. Different execution modes of the components are also analyzed.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Timed automata verification using interpolants\n", "abstract": " The behavior of safety critical systems is often constrained by real time requirements. To model time dependent behavior and enable formal verification, timed automata are widely used as a formal model of such systems. However, due to real-valued clock variables, the state space of these systems is not finite, thus model checkers for timed automata are usually based on zone abstraction. The coarseness of the abstraction profoundly impacts performance of the analysis. In this paper, we propose a lazy abstraction algorithm based on interpolation for zones to enable efficient reachability checking for timed automata. In order to efficiently handle zone abstraction, we define interpolation in terms of difference bound matrices. We extend the notion of zone interpolants to sequences of transitions of a timed automaton, thus enabling the use of zone interpolants for abstraction refinement.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Well-Formedness and Invariant Checking of PLCspecif Specifications\n", "abstract": " Developers of industrial control systems constantly quest for quality in order to improve availability and safety. Some of the threats to quality are the development errors due to incorrect, ambiguous or misunderstood requirements. Formal specification methods may reduce the number of such issues by having unambiguous, mathematically sound semantics, which also allows the development of precise analysis methods. In this paper we present two of the analysis methods developed for PLCspecif, our formal specification language targeting PLC modules: well-formedness analysis and invariant analysis.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Formal modeling of real-time systems with data processing\n", "abstract": " The behavior of practical safety critical systems usually combines real-time behavior with structured data flow. To ensure correctness of such systems, both aspects have to be modeled and formally verified. Time related behavior can be efficiently modeled and analyzed in terms of timed automata. At the same time, program verification techniques like abstract interpretation and software model checking can efficiently handle data flow. In this paper, we describe a simple formalism that is able to model both aspects of such systems and enables the combination of formal verification techniques for real-time systems and software. We also outline a straightforward method for building efficient verifiers for the formalism based on the combination of analyses for the respective aspects.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Evaluation of fault tolerance mechanisms with model checking\n", "abstract": " Failure Mode and Effects Analysis (FMEA) is a systematic technique for failure analysis. It aims to explore the possible failure modes of individual components or subsystems and determine their potential effects at the system level. Applications of FMEA are common in case of hardware and communication failures, but analyzing software failures (SWFMEA) poses a number of challenges. Failures may originate in permanent software faults commonly called bugs, and their effects can be very subtle and hard to predict, due to the complex nature of programs. Therefore, an automatic method to analyze the potential effects of different types of bugs is desirable. Such a method could be used to automatically build an FMEA report, or to evaluate different failure mitigation techniques based on their effects on the outcome of faults. This paper follows the latter direction, demonstrating the use of a model checkingbased automated SW-FMEA approach to assess error detection mechanisms of safety-critical embedded operating systems.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Application of Data Mining in Failure Data Analysis\n", "abstract": " Our paper outlines the application of two data mining techniques for the automatic processing of failure data. The first solutions aims at identifying those parts of a complex HW/SW system built up of COTS components whose incompatibilities or undesired interactions lead to system failures. The second approach is proposed for automatic discovery of those scenarios (involving user interaction, diagnostic messages and error detection signals) that typically result in failures.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Test data generation using metaheuristics\n", "abstract": " Software testing is the process of evaluating the quality of the software under test by controlled execution, usually with the primary aim to reveal inadequate behavior or performance problems. Obviously, testing is an essential step of all software development models, however, writing tests is expensive, labor-intensive and time consuming, thus contributors often skimp on testing phase. One of the most important task in a testing is test data generation. In software testing, test data generation is the process of identifying input data which satisfy certain criterion, eg coverage of selected program code. Test data generation is roughly equivalent with the simple case of test case generation, where the goal is to find an input sequence, that will drive the execution along a particular path in the control flow graph. Nevertheless, a test case is usually more than a simple input data, eg test case usually contain the desired output of the system under test. Unfortunately, it\u2019s usually difficult to create realistic production data, especially early in the development stage, when discovering software bugs would be important in order to avoid expensive redesigns in later phases. Enormous effort have been made to overcome these difficulties. Through the last decades, several approaches have appeared for automatic software test data generation. In paper [1] authors divided these methods into three classes: random, path-oriented and goal-oriented automatic test data generation methods.In this paper we present a novel automatic test data generation approach, which utilizes the idea behind model based test generation. In MBT, test cases are generated using the\u00a0\u2026", "num_citations": "1\n", "authors": ["680"]}
{"title": "Automated code synthesis for run-time verification of distributed embedded systems\n", "abstract": " Automated Code Synthesis for Run-Time Verification of Distributed Embedded Systems Toggle navigation M\u0171egyetemi Digit\u00e1lis Archivum magyar English English magyar English Login Toggle navigation View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item Automated Code Synthesis for Run-Time Verification of Distributed Embedded Systems Thumbnail View/Open 121354.pdf (236.0Kb) Metadata Show full item record Link to refer to this document: http://hdl.handle.net/10890/4500 Collections BME PA dokumentumai [3731] Title Automated Code Synthesis for Run-Time Verification of Distributed Embedded Systems Author Majzik, Istv\u00e1n G Hor\u00e1nyi Date of issue 2011 Publisher TUT Press Language en Identifiers MTMT: 2675600 Scopus: 84869788708 Title of the container \u2026", "num_citations": "1\n", "authors": ["680"]}
{"title": "Supporting design and development of safety critical applications by model based tools\n", "abstract": " Application of computer based systems in safety critical areas like automotive on-board equipments, railway control etc. poses high dependability requirements against software artifacts. This paper outlines a coherent tool-chain providing formally well-established support for the key phases of developing dependable software involving simulation, static model checking, automatic code generation, test case synthesis and runtime error detection. Our approach focuses on modeling behavioral aspects of event triggered state-based systems using UML 2.0 statecharts as specification formalism. The application example analyzed in the paper was taken from the railway control domain.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Assessing the impact of cyclic/acyclic EVC-DMI interactions in Automatic Train Control systems\n", "abstract": " The ERTMS-ATC system is a distributed system where the Driver Machine Interface (DMI) is a slave unit of the train onboard vital computer (EVC). Consequently, as for the information visualization and the input data acquisition, the data transfer between DMI and EVC must also be safe. A safe communication protocol stack has therefore to be provided for connecting safety-related peer agents as part of the architectural design. In this paper we analyze two types of communication protocols that could be used for the EVC-DMI interactions, based, respectively, on cyclic and acyclic messages\u2019 exchange. Using the Stochastic Activity Network formalism, we adopt a modular modeling methodology to assess their impact on some significant dependability-related indicators, like the probability to successfully complete a mission without failures (unscheduled train stops), the steady-state system availability and the probability that a DMI failure causes a mission failure. The analysis of the obtained results allows the early design refinement of the system architecture, pointing out the improvements in adopting an acyclic protocol, possibly with one spare DMI component.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Analysis of the Impact of Communication Protocols on Service Quality in ERTMS Automatic Train Control Systems\n", "abstract": " The ERTMS-ATC system is a distributed system where the Driver Machine Interface (DMI) is a slave unit of the train onboard vital computer (EVC). In this paper we analyze two types of communication protocols for the EVC-DMI interactions, based, respectively, on cyclic and acyclic messages\u2019 exchange. Adopting a modular modeling methodology, we assess their impact on significant dependability-related indicators. The analysis of the obtained results allows to quantify the improvements in adopting an acyclic protocol, possibly with one spare DMI component.", "num_citations": "1\n", "authors": ["680"]}
{"title": "Run-Time Verification of UML 2.0 Statechart Implementations\n", "abstract": " Note In Hungarian; original title:``\u00c1llapott\u00e9rk\u00e9p megval\u00f3s\u00edt\u00e1sok fut\u00e1si idej [H] u ellen [H] orz\u00e9se''; prepared as a report for the``GVOP-3.1. 1-2004-05-0523/3.0''project, type:``GVOP AKF K\u00d6Z, 2005-2006''; title:``K\u00f6t\u00f6ttp\u00e1ly\u00e1s k\u00f6zleked\u00e9si rendszerek konstrukt\u00edv, EU-konform biztons\u00e1gi min [H] os\u00edt\u00e9se''", "num_citations": "1\n", "authors": ["680"]}
{"title": "Form\u00e1lis m\u00f3dszerek az informatik\u00e1ban\n", "abstract": " Form\u00e1lis m\u00f3dszerek az informatik\u00e1ban - SZTAKI Publication Repository SZTAKI Publication Repository MTA SZTAKI ELKH SZTAKI E\u00f6tv\u00f6s Lor\u00e1nd Research Network Institute for Computer Science and Control Home About Browse Login Magyar Clear Cookie - decide language by browser settings Form\u00e1lis m\u00f3dszerek az informatik\u00e1ban Bartha, Tam\u00e1s and Csert\u00e1n, GY and Gyapay, SZ and Majzik, I. and Pataricza, A. and Varr\u00f3, D. (2004) Form\u00e1lis m\u00f3dszerek az informatik\u00e1ban. Typotex, Budapest, p. 312. Full text not available from this repository. Item Type: Book Subjects: Q Science > QA Mathematics and Computer Science > QA75 Electronic computers. Computer science / sz\u00e1m\u00edt\u00e1stechnika, sz\u00e1m\u00edt\u00f3g\u00e9ptudom\u00e1ny Divisions: Systems and Control Lab Depositing User: Eszter Nagy Date Deposited: 11 Dec 2012 15:16 Last Modified: 11 Dec 2012 15:16 URI: http://eprints.sztaki.hu/id/eprint/3416 Update Item Update Item \u2026", "num_citations": "1\n", "authors": ["680"]}
{"title": "From UML class diagrams to timed Petri nets\n", "abstract": " Dependability modelling and analysis is useful for the understanding and assessment of the system in all phases of its life cycle. The two main quantitative dependability attributes of interest for a UML designer are availability (the delivery of correct service with respect to the alternation of correct and incorrect service) and reliability (the continuous delivery of the correct service). During design phases, models allow to compare different architectural and design solutions, to select the most suitable one, and to highlight dependability problems in the design. In our approach, both software and hardware components are modeled in UML. In the early phase of the design process, architectural models are typically created (such as class and object diagrams), implementation models (ie statecharts) are created later. Dependability modeling requires the extension of the standard UML diagrams with a set of tagged values representing the dependability attributes of model elements such as the fault occurrence, error latency, the ratio of permanent faults and the repair delay.The system design may also contain fault-tolerant structures such as N-version programming etc. These are stored in a fault-tolerance library and the dependability analysis is carried out with respect to the attributes of the applied fault-tolerance scheme. UML class diagrams are used to identify relations between classes, which are traced to objects (instantiated from the given classes). Class diagrams provide a good description of the system architecture, therefore, they form the primary basis for dependability analysis. The diagrams are transformed to timed Petri nets to be used for the\u00a0\u2026", "num_citations": "1\n", "authors": ["680"]}
{"title": "Checkpoint and Recovery in Diverse Software\n", "abstract": " The most frequent cause of service unavailability in computer systems is related to transient hardware or software faults. A common way for addressing these issues is based on introducing a checkpoint and recovery schema. Checkpoint generation means the periodic saving the process state into a stable storage. This image can be used for restarting the process from the previously saved state reducing this way the processing time loss to the interval between the checkpoint creation and the failure. Although the core idea is relatively simple, its implementation can get very complicated in case of complex internal data structures since the representation of an object model in the non-volatile storage and the transmission between the memory and the storage requires significant programming effort. This paper aims at proposing an automatic code generation scheme that provides a transparent and platform\u00a0\u2026", "num_citations": "1\n", "authors": ["680"]}
{"title": "Model Checking of Replication Management\n", "abstract": " Model Checking of Replication Management Toggle navigation M\u0171egyetemi Digit\u00e1lis Archivum magyar English English magyar English Login Toggle navigation View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item DSpace Home 1. Tudom\u00e1nyos k\u00f6zlem\u00e9nyek, publik\u00e1ci\u00f3k BME PA dokumentumai View Item Model Checking of Replication Management Thumbnail View/Open 16339.pdf (53.91Kb) Metadata Show full item record Link to refer to this document: http://hdl.handle.net/10890/2599 Collections BME PA dokumentumai [3731] Title Model Checking of Replication Management Author Majzik, Istv\u00e1n Darvas \u00c1 Date of issue 2002 Publisher LAAS-CNRS Language en Identifiers MTMT: 2614715 Title of the container document Supplement of the EDCC-4 Conference - Fast Abstracts. Fourth European Dependable Computing Conference Document type egy\u00e9b \u2026", "num_citations": "1\n", "authors": ["680"]}
{"title": "Efficient decomposition algorithm for stationary analysis of complex stochastic Petri net models\n", "abstract": " Stochastic Petri nets are widely used for the modelling and analysis of non-functional properties of critical systems. The state space explosion problem often inhibits the numerical analysis of such models. Symbolic techniques exist to explore the discrete behaviour of even complex models, while block Kronecker decomposition provides memoryefficient representation of the stochastic behaviour. However, the combination of these techniques into a stochastic analysis approach is not straightforward. In this paper we compare various combinations of symbolic techniques and decomposition based analysis methods. Saturationbased exploration is used to build the state space representation and a new algorithm is introduced to efficiently build block Kronecker matrix representation to be used by the stochastic analysis algorithms. Measurements confirm that the novel combination of the two representations can expand the limits of previous approaches.", "num_citations": "1\n", "authors": ["680"]}