{"title": "A fast string searching algorithm\n", "abstract": " An algorithm is presented that searches for the location, \u201cil\u201d of the first occurrence of a character string, \u201cpat,\u201d in another string, \u201cstring.\u201d During the search operation, the characters of pat are matched starting with the last character of pat. The information gained by starting the match at the end of the pattern often allows the algorithm to proceed in large jumps through the text being searched. Thus the algorithm has the unusual property that, in most cases, not all of the first i characters of string are inspected. The number of characters actually inspected (on the average) decreases as a function of the length of pat. For a random English pattern of length 5, the algorithm will typically inspect i/4 characters of string before finding a match at i. Furthermore, the algorithm has been implemented so that (on the average) fewer than i + patlen machine instructions are executed. These conclusions are supported with empirical\u00a0\u2026", "num_citations": "3710\n", "authors": ["1589"]}
{"title": "A computational logic\n", "abstract": " ACM Monograph Series: A Computational Logic focuses on the use of induction in proving theorems, including the use of lemmas and axioms, free variables, equalities, and generalization. The publication first elaborates on a sketch of the theory and two simple examples, a precise definition of the theory, and correctness of a tautology-checker. Topics include mechanical proofs, informal development, formal specification of the problem, well-founded relations, natural numbers, and literal atoms. The book then examines the use of type information to simplify formulas, use of axioms and lemmas as rewrite rules, and the use of definitions. Topics include nonrecursive functions, computing values, free variables in hypothesis, infinite backwards chaining, infinite looping, computing type sets, and type prescriptions. The manuscript takes a look at rewriting terms and simplifying clauses, eliminating destructors and irrelevance, using equalities, and generalization. Concerns include reasons for eliminating isolated hypotheses, precise statement of the generalization heuristic, restricting generalizations, precise use of equalities, and multiple destructors and infinite looping. The publication is a vital source of data for researchers interested in computational logic.", "num_citations": "1843\n", "authors": ["1589"]}
{"title": "A computational logic handbook: Formerly notes and reports in computer science and applied mathematics\n", "abstract": " Perspectives in Computing: A Computational Logic Handbook contains a precise description of the logic and a detailed reference guide to the associated mechanical theorem proving system, including a primer for the logic as a functional programming language, an introduction to proofs in the logic, and a primer for the mechanical theorem. The publication first offers information on a primer for the logic, formalization within the logic, and a precise description of the logic. Discussions focus on induction and recursion, quantification, explicit value terms, dealing with features and omissions, elementary mathematical relationships, Boolean operators, and conventional data structures. The text then takes a look at proving theorems in the logic, mechanized proofs in the logic, and an introduction to the system. The text examines the processes involved in using the theorem prover, four classes of rules generated from lemmas, and aborting or interrupting commands. Topics include executable counterparts, toggle, elimination of irrelevancy, heuristic use of equalities, representation of formulas, type sets, and the crucial check points in a proof attempt. The publication is a vital reference for researchers interested in computational logic.", "num_citations": "1147\n", "authors": ["1589"]}
{"title": "Computer-aided reasoning: ACL2 case studies\n", "abstract": " Computer-Aided Reasoning: ACL2 Case Studies illustrates how the computer-aided reasoning system ACL2 can be used in productive and innovative ways to design, build, and maintain hardware and software systems. Included here are technical papers written by twenty-one contributors that report on self-contained case studies, some of which are sanitized industrial projects. The papers deal with a wide variety of ideas, including floating-point arithmetic, microprocessor simulation, model checking, symbolic trajectory evaluation, compilation, proof checking, real analysis, and several others. Computer-Aided Reasoning: ACL2 Case Studies is meant for two audiences: those looking for innovative ways to design, build, and maintain hardware and software systems faster and more reliably, and those wishing to learn how to do this. The former audience includes project managers and students in survey-oriented courses. The latter audience includes students and professionals pursuing rigorous approaches to hardware and software engineering or formal methods. Computer-Aided Reasoning: ACL2 Case Studies can be used in graduate and upper-division undergraduate courses on Software Engineering, Formal Methods, Hardware Design, Theory of Computation, Artificial Intelligence, and Automated Reasoning. The book is divided into two parts. Part I begins with a discussion of the effort involved in using ACL2. It also contains a brief introduction to the ACL2 logic and its mechanization, which is intended to give the reader sufficient background to read the case studies. A more thorough, textbook introduction to ACL2 may be found in the\u00a0\u2026", "num_citations": "1071\n", "authors": ["1589"]}
{"title": "Proving theorems about LISP functions\n", "abstract": " Program verification is the 1den that propertms of programs can be precisely stated and proved in the mathematical sense. In th~ s paper, some simple heuristics combimng evaluation and mathematical reduction are described, which the authors have implemented in a program that automatlcally proves a wide varietyof theorems about recursive Lisp functions. The method the program uses to generate induction formulas is described at length The theorems proved by the program include that REVERSE is its own inverse and that a particular SORT program is correct. A list of theorems proved by the program is given", "num_citations": "351\n", "authors": ["1589"]}
{"title": "MJRTY\u2014a fast majority vote algorithm\n", "abstract": " A new algorithm is presented for determining which, if any, of an arbitrary number of candidates has received a majority of the votes cast in an election. The number of comparisons required is at most twice the number of votes. Furthermore, the algorithm uses storage in a way that permits an efficient use of magnetic tape. A Fortran version of the algorithm is exhibited. The Fortran code has been proved correct by a mechanical verification system for Fortran. The system and the proof are discussed.", "num_citations": "321\n", "authors": ["1589"]}
{"title": "An industrial strength theorem prover for a logic based on Common Lisp\n", "abstract": " ACL2 is a reimplemented extended version of R.S. Boyer and J.S. Moore's (1979; 1988) Nqthm and M. Kaufmann's (1988) Pc-Nqthm, intended for large scale verification projects. The paper deals primarily with how we scaled up Nqthm's logic to an industrial strength\" programming language-namely, a large applicative subset of Common Lisp-while preserving the use of total functions within the logic. This makes it possible to run formal models efficiently while keeping the logic simple. We enumerate many other important features of ACL2 and we briefly summarize two industrial applications: a model of the Motorola CAP digital signal processing chip and the proof of the correctness of the kernel of the floating point division algorithm on the AMD5/sub K/86 microprocessor by Advanced Micro Devices, Inc.", "num_citations": "312\n", "authors": ["1589"]}
{"title": "The sharing structure in theorem-proving programs.\n", "abstract": " CiNii \u8ad6\u6587 - The sharing structure in theorem-proving programs. CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853 \u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005 \u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3 \u696d\u52d9\u306e\u518d\u958b\u306b\u3064\u3044\u3066 The sharing structure in theorem-proving programs. BOYER R. \u88ab\u5f15\u7528\u6587\u732e : 1\u4ef6 \u8457\u8005 BOYER R. \u53ce\u9332\u520a\u884c\u7269 Machine Intelligence Machine Intelligence 7, 101-116, 1972 Edinburgh University Press \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u7d20\u6027\u69cb\u9020(2) \u5c0f\u66ae \u6f54 , Kiyoshi Kogure \u4eba\u5de5\u77e5\u80fd\u5b66\u4f1a\u8a8c = Journal of Japanese Society for Artificial Intelligence 8(3), 305-311, 1993-05-01 \u53c2\u8003\u6587\u732e23\u4ef6 \u88ab\u5f15\u7528\u6587\u732e5\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10006400851 \u8cc7\u6599\u7a2e\u5225 \u56f3\u66f8\u306e\u4e00\u90e8 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u66f8\u304d\u51fa\u3057 EndNote\u306b\u66f8\u304d\u51fa\u3057 \u2026", "num_citations": "267\n", "authors": ["1589"]}
{"title": "Integrating decision procedures into heuristic theorem provers: A case study of linear arithmetic\n", "abstract": " We discuss the problem of incorporating into a heuristic theorem prover a decision procedure for a fragment of the logic. An obvious goal when incorporating such a procedure is to reduce the search space explored by the heuristic component of the system, as would be achieved by eliminating from the system's data base some explicitly stated axioms. For example, if a decision procedure for linear inequalities is added, one would hope to eliminate the explicit consideration of the transitivity axioms. However, the decision procedure must then be used in all the ways the eliminated axioms might have been. The difficulty of achieving this degree of integration is more dependent upon the complexity of the heuristic component than upon that of the decision procedure. The view of the decision procedure as a\" black box\" is frequently destroyed by the need pass large amounts of search strategic information back and forth between the two components. Finally, the efficiency of the decision procedu...", "num_citations": "251\n", "authors": ["1589"]}
{"title": "An approach to systems verification\n", "abstract": " The term systems verification refers to the specification and verification of the components of a computing system, including compilers, assemblers, operating systems and hardware. We outline our approach to systems verification, and summarize the application of this approach to several systems components. These components consist of a code generator for a simple high-level language, an assembler and linking loader, a simple operating system kernel, and a microprocessor design.", "num_citations": "214\n", "authors": ["1589"]}
{"title": "Metafunctions: Proving Them Correct and Using Them Efficiently as New Proof Procedures.\n", "abstract": " We describe a sound method for permitting the users of a mechanical theorem-proving system to add executable code to the system, thereby implementing a new proof strategy and modifying the behavior of the system. The new code is mechanically derived from a function definition conceived by the user but proved correct by the system before the new code is added. We present a simple formal method for stating within the theory of the system the correctness of such functions. The method avoids the complexity of embedding the rules of inference of the logic in the logic. Instead, we define a meaning function that maps from objects denoting expressions to the values of those expressions under a given assignment. We demonstrate that if the statement of correctness for a given metafunction is proved, then the code derived from functions definition can be used as a new proof procedure. We explain how we have implemented the technique so that the actual application of a metafunction is as efficient as hand-coded procedures in the implementation language. We prove the correctness of our implementation. We discuss a useful metafunction that our system has proved correct and now uses routinely. We discuss the main obstacle to the introduction of metafunctions proving them correct by machine. AuthorDescriptors:", "num_citations": "211\n", "authors": ["1589"]}
{"title": "A mechanically checked proof of the AMD5K86TM floating-point division program\n", "abstract": " In this article, we report the successful application of a mechanical theorem prover to the problem of verifying the division microcode program used on the AMD5K86 microprocessor. The division algorithm is an iterative shift and subtract type. It was implemented using floating-point microcode instructions. As a consequence, the floating quotient digits have data dependent precision. This breaks the constraints of conventional SRT division theory. Hence, an important question was whether the algorithm still provided perfectly rounded results at 24, 53, or 64 bits. The mechanically checked proof of this assertion is the central topic of this paper. The proof was constructed in three steps. First, the divide microcode was translated into a formal intermediate language. Then, a manually created proof was transliterated into a series of formal assertions in the ACL2 dialect. After many expansions and modifications to the\u00a0\u2026", "num_citations": "204\n", "authors": ["1589"]}
{"title": "ACL2 theorems about commercial microprocessors\n", "abstract": " ACL2 is a mechanized mathematical logic intended for use in specifying and proving properties of computing machines. In two independent projects, industrial engineers have collaborated with researchers at Computational Logic, Inc. (CLI), to use ACL2 to model and prove properties of state-of-the-art commercial microprocessors prior to fabrication. In the first project, Motorola, Inc., and CLI collaborated to specify Motorola's complex arithmetic processor (CAP), a single-chip, digital signal processor (DSP) optimized for communications signal processing. Using the specification, we proved the correctness of several CAP microcode programs. The second industrial collaboration involving ACL2 was between Advanced Micro Devices, Inc. (AMD) and CLI. In this work we proved the correctness of the kernel of the floating-point division operation on AMD's first Pentium-class microprocessor, the AMD5                 K\u00a0\u2026", "num_citations": "187\n", "authors": ["1589"]}
{"title": "A mechanically verified language implementation\n", "abstract": " This paper briefly describes a programming language, its implementation on a microprocessor via a compiler and link-assembler, and the mechanically checked proof of the correctness of the implementation. The programming language, called Piton, is a high-level assembly language designed for verified applications and as the target language for high-level language compilers. It provides executeonly programs, recursive subroutine call and return, stack based parameter passing, local variables, global variables and arrays, a user-visible stack for intermediate results, and seven abstract data types including integers, data addresses, program addresses and subroutine names. Piton is formally specified by an interpreter written for it in the computational logic of Boyer and Moore. Piton has been implemented on the FM8502, a general purpose microprocessor whose gate-level design has been\u00a0\u2026", "num_citations": "182\n", "authors": ["1589"]}
{"title": "ACL2: An industrial strength version of Nqthm\n", "abstract": " ACL2 (\"A Computational Logic for Applicative Common Lisp\") is a reimplemented extended version of Boyer and Moore's (1979, 1988) Nqthm and Kaufmann's (1988, 1990, 1992) Pc-Nqthm, intended for large-scale verification projects. However, the logic supported by ACL2 is compatible with the applicative subset of Common Lisp. The decision to use an \"industrial strength\" programming language as the foundation of the mathematical logic is crucial to our advocacy of ACL2 in the application of formal methods to large systems. However, one of the key reasons Nqthm has been so successful, we believe, is its insistence that functions be total. Common Lisp functions are not total and this is one of the reasons Common Lisp is so efficient. This paper explains how we scaled up Nqthm's logic to Common Lisp, preserving the use of total functions within the logic but achieving Common Lisp execution speeds.", "num_citations": "175\n", "authors": ["1589"]}
{"title": "The Boyer-Moore theorem prover and its interactive enhancement\n", "abstract": " The so-called Boyer-Moore Theorem Prover (otherwise known as Nqthm) has been used to perform a variety of verification tasks for two decades. We give an overview of both this system and an interactive enhancement of it, Pc-Nqthm, from a number of perspectives. First, we introduce the logic in which theorems are proved. Then, we briefly describe the two mechanized theorem proving systems. Next, we present a simple but illustrative example in some detail in order to give an impression of how these systems may be used successfully. Finally, we give extremely short descriptions of a large number of applications of these systems, in order to give an idea of the breadth of their uses. This paper is intended as an informal introduction to systems that have been described in detail and similarly summarized in many other books and papers; no new results are reported here. Our intention here is to present Nqthm to a\u00a0\u2026", "num_citations": "142\n", "authors": ["1589"]}
{"title": "Piton: a mechanically verified assembly-level language\n", "abstract": " Mountaineers use pitons to protect themselves from falls. The lead climber wears a harness to which a rope is tied. As the climber ascends, the rope is paid out by a partner on the ground. As described thus far, the climber receives no protection from the rope or the partner. However, the climber generally carries several spike-like pitons and stops when possible to drive one into a small crack or crevice in the rock face. After climbing just above the piton, the climber clips the rope to the piton, using slings and carabiners. A subsequent fall would result in the climber hanging from the piton\u2014if the piton stays in the rock, the slings and carabiners do not fail, the rope does not break, the partner is holding the rope taut and secure, and the climber had not climbed too high above the piton before falling. The climber's safety clearly depends on all of the components of the system. But the piton is distinguished because it connects the natural to the artificial. In 1987 I designed an assembly-level language for Warren Hunt's FM8501 verified microprocessor. I wanted the language to be conveniently used as the object code produced by verified compilers. Thus, I envisioned the language as the first software link in a trusted chain from verified hardware to verified applications programs. Thinking of the hardware as the\" rock\" I named the language\" Piton.", "num_citations": "117\n", "authors": ["1589"]}
{"title": "Mechanical stretch activates nuclear factor\u2010kappaB, activator protein\u20101, and mitogen\u2010activated protein kinases in lung parenchyma: implications in asthma\n", "abstract": " We investigated the effects of mechanical stretch and induced stimulation of lung parenchyma on the activation of proinflammatory transcription factors in normal mice and in a mouse model of asthma. Mechanical stretching of lung parenchyma led to increased activation of NF\u2010\u03baB and AP\u20101 transcription factors. Incubation of lung parenchyma with methacholine increased the activation of NF\u2010\u03baB, which was further augmented by stretch. Activation of NF\u2010\u03baB in response to mechanical stretch was associated with the phosphorylation and degradation of I\u03baB\u03b1 and the activation of I\u03baB kinase. Stretch\u2010induced activation of NF\u2010\u03baB involves activation of stretch\u2010activated (SA) channels and the production of free radicals. Mechanical stretch and/or treatment with methacholine resulted in an increased activation of ERK1/2 and p38 MAP kinase, and the inhibition of the activity of these kinases partially blocked the stretch\u00a0\u2026", "num_citations": "117\n", "authors": ["1589"]}
{"title": "System verification\n", "abstract": " System verification | Journal of Automated Reasoning ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Journal of Automated Reasoning Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsJournal of Automated ReasoningVol. , No. System verification article System verification Share on Author: J Strother Moore profile image J. Strother Moore View Profile Authors Info & Affiliations Publication: Journal of Automated ReasoningNovember 1989 13citation 0 Downloads Metrics Total Citations13 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and will be sent to: \u2026", "num_citations": "110\n", "authors": ["1589"]}
{"title": "The correctness problem in computer science\n", "abstract": " The Correctness Problem in Computer Science | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksThe Correctness Problem in Computer Science ABSTRACT No abstract available. Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide books cover image The Correctness Problem in Computer Science January 1982 279 pages ISBN:0121229203 Authors: Robert S. Boyer, J. Strother Moore Copyright \u00a9 1982 Publisher Academic Press, Inc. United States \u2026", "num_citations": "103\n", "authors": ["1589"]}
{"title": "Structured theory development for a mechanized logic\n", "abstract": " Experience has shown that large or multi-user interactive proof efforts can benefit significantly from structuring mechanisms, much like those available in many modern programming languages. Such a mechanism can allow some lemmas and definitions to be exported, and others not. In this paper we address two such structuring mechanisms for the ACL2 theorem prover: encapsulation and books. After presenting an introduction to ACL2, this paper justifies the implementation of ACL2's structuring mechanisms and, more generally, formulates and proves high-level correctness properties of ACL2. The issues in the present paper are relevant not only for ACL2 but also for other theorem-proving environments.", "num_citations": "100\n", "authors": ["1589"]}
{"title": "A theorem prover for a computational logic\n", "abstract": " We briefly review a mechanical theorem-prover for a logic of recursive functions over finitely generated objects including the integers, ordered pairs, and symbols. The prover, known both as NQTHM and as the Boyer-Moore prover, contains a mechanized principle of induction and implementations of linear resolution, rewriting, and arithmetic decision procedures. We describe some applications of the prover, including a proof of the correct implementation of a higher level language on a microprocessor defined at the gate level. We also describe the ongoing project of recoding the entire prover as an applicative function within its own logic.", "num_citations": "87\n", "authors": ["1589"]}
{"title": "Proof checking the RSA public key encryption algorithm\n", "abstract": " The development of mathematics toward greater precision has Jed, as is well known, to the formalization of large tracts of it, so that one can prove any theorem using nothing but a few mechanical rules.-Godel [11] But formalized mathematics cannot in practice be written down in full, and therefore we must have confidence in what might be called the common sense of the mathematician... We shall therefore very quickly abandon formalized mathematics...-Bourbaki [1].1. Introduction. A formal mathematical proof is a finite sequence of formulas, each element of which is either an axiom or the result of applying one of a fixed set of mechanical rules to previous formulas in the sequence. It is thus possible to write a computer program to check mechanically whether a given sequence is a formal proof. However, formal proofs are rarely used. Instead, typical proofs in journal articles, textbooks, and day-to-day mathematical\u00a0\u2026", "num_citations": "87\n", "authors": ["1589"]}
{"title": "Design goals for ACL2\n", "abstract": " ACL2 is a theorem proving system under development at Computational Logic, Inc., by the authors of the Boyer-Moore system, Nqthm, and its interactive enhancement, Pc-Nqthm, based on our perceptions of some of the inadequacies of Nqthm when used in large-scale veri cation projects. Foremost among those inadequacies is the fact that Nqthm's logic is an ine cient programming language. We now recognize that the e ciency of the logic as a programming language is of great importance because the models of microprocessors, operating systems, and languages typically constructed in veri cation projects must be executed to corroborate them against the realities they model. Simulation of such large scale systems stresses the logic in ways not imagined when Nqthm was designed. In addition, Nqthm does not adequately support certain proof techniques, nor does it encourage the reuse of previously developed libraries or the collaboration of semi-autonomous workers on di erent parts of a veri cation project. Finally, Nqthm is implemented in an informally speci ed programming language (Common Lisp) and hence is not subject to mechanical veri cation. ACL2 is our response to these perceived inadequacies. While the logic of Nqthm is based on pure Lisp, the logic of ACL2 is based on the applicative subset of Common Lisp. By adding to the applicative subset of Common Lisp a single-threaded notion of state, fast applicative arrays and property lists, and e ciently implemented multiple values, an e cient and practical applicative programming language is produced. By axiomatizing the primitives and introducing appropriate rules of inference\u00a0\u2026", "num_citations": "86\n", "authors": ["1589"]}
{"title": "Functional instantiation in first-order logic\n", "abstract": " We here describe CONSTRAIN and FUNCTIONALLY\u2014INSTANTIATE, two new user commands (events) that we have added to the \u201cNQTHM\u201d prover [Bo-M088]. FUNCTIONALLY\u2014INSTANTIATE implements a derived rule of inference that provides something of the flavor of higher-order logic by permitting one to infer new theorems by the instantiation of function symbols instead of variables. To ensure that such an instantiation actually produces a theorem, we first check that the formulas that result from similarly instantiating certain axioms about the function symbols being replaced are also theorems. Intuitively speaking, the correctness of this derived rule of inference consists of little more than the trivial observation that one may systematically change the name of a function symbol to a new name in a \ufb01rst-order theory without losing any theorems, modulo the renaming. However, we have found that this trivial observation has important, potentially practical rami\ufb01cations in reducing mechanical proof efforts. We also \ufb01nd that this observation leads to super\ufb01cially shocking results, such as the proof of the associativity of APPEND by instantiation rather than induction. Finally, we are intrigued by the extent to which such techniques permit one to capture the power of higher-order logic Within \ufb01rst-order logic. To make effective use of FUNCTIONALLY\u2014INSTANTIATE, we have found it necessary to augment our facility for de\ufb01ning functions, DEFN, with a", "num_citations": "86\n", "authors": ["1589"]}
{"title": "Symbolic simulation: An ACL2 approach\n", "abstract": " Executable formal specification can allow engineers to test (or simulate) the specified system on concrete data before the system is implemented. This is beginning to gain acceptance and is just the formal analogue of the standard practice of building simulators in conventional programming languages such as C. A largely unexplored but potentially very useful next step is symbolic simulation, the \u201cexecution\u201d of the formal specification on indeterminant data. With the right interface, this need not require much additional training of the engineers using the tool. It allows many tests to be collapsed into one. Furthermore, it familiarizes the working engineer with the abstractions and notation used in the design, thus allowing team members to speak clearly to one another. We illustrate these ideas with a formal specification of a simple computing machine in ACL2. We sketch some requirements on the interface, which\u00a0\u2026", "num_citations": "83\n", "authors": ["1589"]}
{"title": "A mechanical proof of the unsolvability of the halting problem\n", "abstract": " A proof by a computer program of the unsolvability of the halting problem is described. The halting problem is posed in a construcUve, formal language. The computational paradigm formalized~ s Pure LISP, not Tunng machines. The machine was led to the proof by the authors, who suggested certain function definitions and stated certain intermediate lemmas. The machine checked to ascertain that every suggested definition was admissible and the machine proved the main theorem and every lemma. It is beheved this is the first instance of a machine checking that a given problem is not solvable by machine.", "num_citations": "77\n", "authors": ["1589"]}
{"title": "A pattern-matched Twitter analysis of US cancer-patient sentiments\n", "abstract": " BackgroundTwitter has been recognized as an important source of organic sentiment and opinion. This study aimed to (1) characterize the content of tweets authored by the United States cancer patients; and (2) use patient tweets to compute the average happiness of cancer patients for each cancer diagnosis.MethodsA large sample of English tweets from March 2014 through December 2014 was obtained from Twitter. Using regular expression software pattern matching, the tweets were filtered by cancer diagnosis. For each cancer-specific tweetset, individual patients\u00a0were extracted, and the content of the tweet was categorized. The patients' Twitter identification numbers were used to gather all tweets for each patient, and happiness values for patient tweets were calculated using a quantitative hedonometric analysis.ResultsThe most frequently tweeted cancers were breast (n\u00a0=\u00a015,421, 11% of total cancer tweets\u00a0\u2026", "num_citations": "73\n", "authors": ["1589"]}
{"title": "Partial functions in ACL2\n", "abstract": " We describe a method for introducing \u201cpartial functions\u201d into ACL2, that is, functions not defined everywhere. The function \u201cdefinitions\u201d are actually admitted via the encapsulation principle: the new function symbol is constrained to satisfy the appropriate equation. This is permitted only when a witness function can be exhibited, establishing that the constraint is satisfiable. Of particular interest is the observation that every tail recursive definition can be witnessed in ACL2. We describe a macro that allows the convenient introduction of arbitrary tail recursive functions, and we discuss how such functions can be used to prove theorems about state machine models without reasoning about \u201cclocks\u201d or counting the number of steps until termination. Our macro for introducing \u201cpartial functions\u201d also permits a variety of other recursive schemes, and we briefly illustrate some of them.", "num_citations": "73\n", "authors": ["1589"]}
{"title": "A grand challenge proposal for formal methods: A verified stack\n", "abstract": " We propose a grand challenge for the formal methods community: build and mechanically verify a practical computing system, from transistors to software. The challenge is both competitive and collaborative. It is collaborative because practical systems are too large for any one group or tool to handle in isolation: groups will have to team together. Furthermore, the vertical integration of systems at different levels of abstractions \u2013 from transistors to software \u2013 will encourage the team to adopt different tools for different levels and connect them. It is competitive because there are many systems from which to choose and different teams may form around different target systems.", "num_citations": "69\n", "authors": ["1589"]}
{"title": "Single-threaded objects in ACL2\n", "abstract": " ACL2 is a first-order applicative programming language based on Common Lisp. It is also a mathematical logic for which a mechanical theorem-prover has been implemented in the style of the Boyer-Moore theorem prover. The ACL2 system is used primarily in the modeling and verification of computer hardware and software, where the executability of the language allows models to be used as prototype designs or \u201csimulators.\u201d To support efficient execution of certain kinds of models, especially models of microprocessors, ACL2 provides \u201csinglethreaded objects,\u201d structures with the usual \u201ccopy on write\u201d applicative semantics but for which writes are implemented destructively. Syntactic restrictions insure consistency between the formal semantics and the implementation. The design of single-threaded objects has been influenced both by the need to make execution efficient and the need to make proofs\u00a0\u2026", "num_citations": "65\n", "authors": ["1589"]}
{"title": "A Verification Condition Generator for FORTRAN.\n", "abstract": " This paper provides both a precise specification of a subset of FORTRAN 66 and FORTRAN 77 and a specification of the verification condition generator we have implemented for that subset. Our subset includes all the statements in FORTRAN 66 except the following READ, WRITE, REWIND, BACKSPACE, ENDFILE, FORMAT, EQUIVALENCE, DATA, and BLOCK DATA. We place some restrictions on the remaining statements however, our subset includes certain uses of COMMON, adjustable array dimensions, function subprograms, subroutine subprograms with side effects, and computed and assigned GO TOs. Unusual features of our system include a syntax checker that enforces all our syntactic restrictions on the language, the thorough analysis of aliasing, the generation of verification conditions to prove termination, and the generation of verification conditions to ensure against such run-time errors as array bound violations and arithmetic overflow. We have used the system to verify several running FORTRAN programs. We present one such program and discuss its verification. AuthorDescriptors:", "num_citations": "64\n", "authors": ["1589"]}
{"title": "Executable JVM model for analytical reasoning: A study\n", "abstract": " To study the properties of the Java Virtual Machine (JVM) and Java programs, our research group has produced a series of JVM models written in a functional subset of Common Lisp. In this paper, we present our most complete JVM model from this series, namely, M6, which is derived from a careful study of the J2ME KVM [Connected Limited Device Configuration (CLDC) and the K Virtual Machine, http://java.sun.com/products/cldc/] implementation.On the one hand, our JVM model is a conventional machine emulator. M6 implements dynamic class loading, class initialization and synchronization via monitors. It executes most J2ME CLDC Java programs that do not use any I/O or floating point operations. Engineers may consider M6 an implementation of the JVM. The June 2003 version is implemented with around 10K lines of Lisp in 28 modules.On the other hand, M6 is novel because it allows for analytical\u00a0\u2026", "num_citations": "60\n", "authors": ["1589"]}
{"title": "Proving theorems about Java and the JVM with ACL2\n", "abstract": " We describe a methodology for proving theorems mechanically about Java methods. The theorem prover used is the ACL2 system, an industrial-strength version of the Boyer-Moore theorem prover. An operational semantics for a substantial subset of the Java Virtual Machine (JVM) has been defined in ACL2. Theorems are proved about Java methods and classes by compiling them with javac and then proving the corresponding theorem about the JVM. Certain automatically applied strategies are implemented with rewrite rules (and other proof-guiding pragmas) in ACL2 \u201cbooks\u201d to control the theorem prover when operating on problems involving the JVM model.", "num_citations": "60\n", "authors": ["1589"]}
{"title": "A formal model of asynchronous communication and its use in mechanically verifying a biphase mark protocol\n", "abstract": " We present a formal model of asynchronous communication between two digital hardware devices. The model takes the form of a function in the Boyer-Moore logic. The function transforms the signal stream generated by one processor into that consumed by an independently clocked processor, given the phases and rates of the two clocks and the communications delay. The model can be used quantitatively to derive concrete performance bounds on communications at ISO protocol level 1 (physical level). We use the model to show that an 18-bit/cell biphase mark protocol reliably sends messages of arbitrary length between two processors provided the ratio of the clock rates is within 5% of unity.", "num_citations": "60\n", "authors": ["1589"]}
{"title": "Java program verification via a JVM deep embedding in ACL2\n", "abstract": " In this paper, we show that one can \u201cdeep-embed\u201d the Java bytecode language, a fairly complicated language with a rich semantics, into the first order logic of ACL2 by modeling a realistic JVM. We show that with proper support from a semi-automatic theorem prover in that logic, one can reason about the correctness of Java programs. This reasoning can be done in a direct and intuitive way without incurring the extra burden that has often been associated with hand proofs, or proofs that make use of less automated proof assistance. We present proofs for two simple Java programs as a showcase.", "num_citations": "58\n", "authors": ["1589"]}
{"title": "Mechanized formal reasoning about programs and computing machines\n", "abstract": " The behavior of regular aggregate data structures (for example, square matrices, complete binary trees, and powerlists [20]), as well as semantic data structures (for example, sorted lists and priority lists), cannot be captured elegantly by using existing specification techniques and languages such as Larch, Z, OBJ, VDM, or LOTOS. Typically such a data structure is denned as a subsort of a larger data structure. For instance, complete binary trees can be denned as a subsort of binary trees, and powerlists as well as sorted lists can be defined as subsorts of lists. For reasoning about algorithmic descriptions using such data structures, it then becomes necessary to explicitly carry subsort conditions. As shown in [14], this approach makes reasoning about them cumbersome, and the resulting proofs get complex.It is argued in this article that regularity should be exploited while reasoning about specifications based on regular data structures (see also [20]). That does not seem to be possible if regular data structures are modeled using subsorts, perhaps because of incompatibility between regularity and subsorts. Instead of being a benefit, regularity becomes a burden. This situation is somewhat similar to an experience one would have in expressing a specification involving many data types in an unsorted (single-sorted) notation. Different types would have to be characterized by different unary predicates, and conditions expressed using these unary predicates would have to be carried around wherever terms of particular data types are used. A multisorted notation and logic are instead preferred. The main idea of this article is to propose a simple\u00a0\u2026", "num_citations": "58\n", "authors": ["1589"]}
{"title": "A precise description of the ACL2 logic\n", "abstract": " The ACL2 logic is a rst-order, essentially quanti er-free logic of total recursive functions providing mathematical induction and several extension principles, including symbol package de nition and recursive function de nition. In this document we describe the logic more precisely.", "num_citations": "56\n", "authors": ["1589"]}
{"title": "Kit and the short stack\n", "abstract": " Kit is a small multi-tasking operating system kernel written in the machine language of a uni-processor von Neumann computer. The kernel is proved to implement on this shared computer a fixed number of conceptually distributed communicating processes. In addition to implementing processes, the kernel provides the following verified services: process scheduling, error handling, message passing, and an interface to asynchronous devices. We summarize the Kit project in order to discuss the place Kit could occupy in the verified stack of system components containing Micro-Gypsy, Piton and FM8502.", "num_citations": "56\n", "authors": ["1589"]}
{"title": "Verification condition generation via theorem proving\n", "abstract": " We present a method to convert (i) an operational semantics for a given machine language, and (ii) an off-the-shelf theorem prover, into a high assurance verification condition generator (VCG). Given a program annotated with assertions at cutpoints, we show how to use the theorem prover directly on the operational semantics to generate verification conditions analogous to those produced by a custom-built VCG. Thus no separate VCG is necessary, and the theorem prover can be employed both to generate and to discharge the verification conditions. The method handles both partial and total correctness. It is also compositional in that the correctness of a subroutine needs to be proved once, rather than at each call site. The method has been used to verify several machine-level programs using the ACL2 theorem prover.", "num_citations": "55\n", "authors": ["1589"]}
{"title": "Introduction to the OBDD Algorithm for the ATP Community\n", "abstract": " We describe in terms familiar to the automated reasoning community the graph-based algorithm for deciding propositional equivalence published by R. E. Bryant in 1986. Such algorithms, based onordered binary decision diagrams orOBDDs, are among the fastest known ways to decide whether two propositional expressions are equivalent and are generally hundreds or thousands of times faster on such problems than most automatic theorem-proving systems. An OBDD is a normalized IF (\u2018if-then-else\u2019) expression in which the tests down any branch are ascending in some previously chosen fixed order. Such IF expressions represent a canonical form for propositional expressions. Three coding tricks make it extremely efficient to manipulate canonical IF expressions. The first is that two canonicalized expressions can be rapidly combined to form the canonicalized form of their disjunction (conjunction\u00a0\u2026", "num_citations": "53\n", "authors": ["1589"]}
{"title": "Proof-Checking, Theorem Proving, and Program Verification.\n", "abstract": " This article consists of three parts a tutorial introduction to a computer program that proves theorems by induction a brief description of recent applications of that theorem-prover and a discussion of several nontechnical aspects of the problem of building automatic theorem-provers. The theorem-prover described has proved such theorems as the uniqueness of prime factorizations, Fermats theorem, and the recursive unsolvability of the halting problem. The article is aimed at those who know nothing about automatic theorem-proving but would like a glimpse of one such system. The authors in opinion, the limiting factor in progress in automatic theorem-proving is the quality of the mathematicians who are attempting to build such systems. They encourage good mathematicians to work in the field.Descriptors:", "num_citations": "52\n", "authors": ["1589"]}
{"title": "The apprentice challenge\n", "abstract": " We describe a mechanically checked proof of a property of a small system of Java programs involving an unbounded number of threads and synchronization, via monitors. We adopt the output of the javac compiler as the semantics and verify the system at the bytecode level under an operational semantics for the JVM. We assume a sequentially consistent memory model and atomicity at the bytecode level. Our operational semantics is expressed in ACL2, a Lisp-based logic of recursive functions. Our proofs are checked with the ACL2 theorem prover. The proof involves reasoning about arithmetic; infinite loops; the creation and modification of instance objects in the heap, including threads; the inheritance of fields from superclasses; pointer chasing and smashing; the invocation of instance methods (and the concomitant dynamic method resolution); use of the start method on thread objects; the use of monitors to\u00a0\u2026", "num_citations": "50\n", "authors": ["1589"]}
{"title": "ACL2s:\u201cThe ACL2 Sedan\u201d\n", "abstract": " ACL2 is the latest inception of the Boyer-Moore theorem prover, the 2005 recipient of the ACM Software System Award. In the hands of experts it feels like a finely tuned race car, and it has been used to prove some of the most complex theorems ever proved about commercially designed systems. Unfortunately, ACL2 has a steep learning curve. Thus, novices tend have a very different experience: they crash and burn. As part of a project to make ACL2 and formal reasoning safe for the masses, we have developed ACL2s, the ACL2 sedan. ACL2s includes many features for streamlining the learning process that are not found in ACL2. In general, the goal is to develop a tool that is \u201cself-teaching,\u201d i.e., it should be possible for an undergraduate to sit down and play with it and learn how to program in ACL2 and how to reason about the programs she writes.", "num_citations": "46\n", "authors": ["1589"]}
{"title": "The addition of bounded quantification and partial functions to a computational logic and its theorem prover\n", "abstract": " We describe an extension to our quantifier-free computational logic to provide the expressive power and convenience of bounded quantifiers and partial functions. By quantifier we mean a formal construct which introduces a bound or indicial variable whose scope is some subexpression of the quantifier expression. A familiar quantifier is the \u03a3 operator which sums the values of an expression over some range of values on the bound variable. Our method is to represent expressions of the logic as objects in the logic, to define an interpreter for such expressions as a function in the logic, and then define quantifiers as \u2018mapping functions\u2019. The novelty of our approach lies in the formalization of the interpreter and its interaction with the underlying logic. Our method has several advantages over other formal systems that provide quantifiers and partial functions in a logical setting. The most important advantage is\u00a0\u2026", "num_citations": "46\n", "authors": ["1589"]}
{"title": "Program verification\n", "abstract": " Computer programs may be regarded as formal mathematical objects whose properties are subject to mathematical proof. Program verification is the use of formal, mathematical techniques to debug software and software specifications. AuthorDescriptors:", "num_citations": "45\n", "authors": ["1589"]}
{"title": "Linear and nonlinear arithmetic in ACL2\n", "abstract": " sec:abstractAs of version 2.7, the ACL2 theorem prover has been extended to automatically verify sets of polynomial inequalities that include nonlinear relationships. In this paper we describe our mechanization of linear and nonlinear arithmetic in ACL2. The nonlinear arithmetic procedure operates in cooperation with the pre-existing ACL2 linear arithmetic decision procedure. It extends what can be automatically verified with ACL2, thereby eliminating the need for certain types of rules in ACL2\u2019s database while simultaneously increasing the performance of the ACL2 system when verifying arithmetic conjectures. The resulting system lessens the human effort required to construct a large arithmetic proof by reducing the number of intermediate lemmas that must be proven to verify a desired theorem.", "num_citations": "44\n", "authors": ["1589"]}
{"title": "Constructivism in curriculum development\n", "abstract": " In this study constructivism is introduced and also it is examined how the components of curriculum are organized according to this approach. According to constructivism, the learners discover the knowledge from the origion. Learners direct the learning with their existing cognitive shema by constructing the knowledge effectivelly. Moreover, they assimilate the knowledge which they constructed by integrating their former learning with the new information. Knowledge is formed by the learners' existing values and experiences. Learning occurs in complex and real contexts. Content is organized through deduction way. By this way, learners can use their higher-level thinking skills. Teachers can quide their students by taking the advantage of their ideas and questions. Since organizing learning experiences are seen as the base of the study, different activities convenient for the learning situation are prepared\u00a0\u2026", "num_citations": "44\n", "authors": ["1589"]}
{"title": "Some key research problems in automated theorem proving for hardware and software verification.\n", "abstract": " top This paper sketches the state of the art in the application of mechanical theorem provers to the verification of commercial computer hardware and software. While the paper focuses on the theorem proving system ACL2, developed by the two authors, it references much related work in formal methods. The paper is intended to satisfy the curiosity of readers interested in logic and artificial intelligence as to the role of mechanized theorem proving in hardware and software design today. In addition, it points out some of the key research topics in the area. These topics transcend any one particular theorem proving system.", "num_citations": "43\n", "authors": ["1589"]}
{"title": "A Lemma Driven Automatic Theorem Prover for Recursive Function Theory.\n", "abstract": " The paper describes work in progress on an automatic theorem prover for recursive function theory that is intended to be applied in the anlaysis including verification and transformation of useful computer programs. The mathematical theory of the theorem prover is extendible by the user and serves as a logical basis of program specification analogous to, say, the predicate calculus. The theorem prover permits no interaction once given a goal, but many aspects of its behavior are influenced by previously proved results. Thus, its performance on difficult theorems can be radically improved by having it first prove relevant lemmas. The theorem prover employs such lemmas in several ways. Among the interesting theorems proved are the correctness of a simple optimizing compiler for expressions and the correctness of a big number addition algorithm.Descriptors:", "num_citations": "43\n", "authors": ["1589"]}
{"title": "Proving theorems about Java-like byte code\n", "abstract": " We describe a formalization of an abstract machine very similar to the Java Virtual Machine but far simpler. We develop techniques for specifying the properties of classes and methods for this machine. We develop techniques for mechanically proving theorems about classes and methods.We discuss two such proofs, that of a static method implementing the factorial function and of an instance method that destructively manipulates objects in a way that takes advantage of inheritance. We conclude with a brief discussion of the advantages and disadvantages of this approach. The formalization and proofs are done with the ACL2 theorem proving system.", "num_citations": "41\n", "authors": ["1589"]}
{"title": "The temporal framework for concurrent programs\n", "abstract": " This is the first in a series of reports describing the application of Temporal Logic to the specification and verification of concurrent programs. We first introduce Temporal Logic as a tool for reasoning about sequences of states. Models of concurrent programs based both on transition graphs and on linear-text representations are presented and the notions of concurrent and fair executions are defined.", "num_citations": "40\n", "authors": ["1589"]}
{"title": "Efficient execution in an automated reasoning environment\n", "abstract": " We describe a method that permits the user of a mechanized mathematical logic to write elegant logical definitions while allowing sound and efficient execution. In particular, the features supporting this method allow the user to install, in a logically sound way, alternative executable counterparts for logically defined functions. These alternatives are often much more efficient than the logically equivalent terms they replace. These features have been implemented in the ACL2 theorem prover, and we discuss several applications of the features in ACL2.", "num_citations": "39\n", "authors": ["1589"]}
{"title": "A mechanical proof of the Turing completeness of pure LISP.\n", "abstract": " The authors describe a proof by a computer program of the Turing completeness of a computational paradigm akin to Pure LISP. That is, they define formally the notions of a Turing machine and of a version of Pure LISP and prove that anything that can be computed by a Turing machine can be computed by LISP. While this result is straightforward, they believe this is the first instance of a machine proving the Turing completeness of another computational paradigm. AuthorDescriptors:", "num_citations": "39\n", "authors": ["1589"]}
{"title": "Meta reasoning in ACL2\n", "abstract": " The ACL2 system is based upon a first-order logic and implements traditional first-order reasoning techniques, notably (conditional) rewriting, as well as extensions including mathematical induction and a \u201cfunctional instantiation\u201d capability for mimicking second-order reasoning. Additionally, one can engage in meta-reasoning \u2014 using ACL2 to reason, and prove theorems, about ACL2\u2019s logic from within ACL2. One can then use these theorems to augment ACL2\u2019s proof engine with custom extensions. ACL2 also supports forms of meta-level control of its rewriter. Relatively recent additions of these forms of control, as well as extensions to ACL2\u2019s long-standing meta-reasoning capability, allow a greater range of rules to be written than was possible before, allowing one to specify more comprehensive proof strategies.", "num_citations": "37\n", "authors": ["1589"]}
{"title": "Introducing iteration into the pure LISP theorem prover\n", "abstract": " It is shown how the Lisp iterative primitives PROG, SETQ, GO, and RETURN may be introduced into the Boyer-Moore method for automatically verifying Pure Lisp programs. This is done by extending some of the previously described heuristics for dealing with recursive functions. The resulting verification procedure uses structural induction to handle both recursion and iteration. The procedure does not actually distinguish between the two and they may be mixed arbitrarily. For example, since properties are stated in terms of user-defined functions, the theorem prover will prove recursively specified properties of iterative functions. Like its predecessor, the procedure does not require user-supplied inductive assertions for the iterative programs.", "num_citations": "37\n", "authors": ["1589"]}
{"title": "Industrial hardware and software verification with ACL2\n", "abstract": " The ACL2 theorem prover has seen sustained industrial use since the mid-1990s. Companies that have used ACL2 regularly include AMD, Centaur Technology, IBM, Intel, Kestrel Institute, Motorola/Freescale, Oracle and Rockwell Collins. This paper introduces ACL2 and focuses on how and why ACL2 is used in industry. ACL2 is well-suited to its industrial application to numerous software and hardware systems, because it is an integrated programming/proof environment supporting a subset of the ANSI standard Common Lisp programming language. As a programming language ACL2 permits the coding of efficient and robust programs; as a prover ACL2 can be fully automatic but provides many features permitting domain-specific human-supplied guidance at various levels of abstraction. ACL2 specifications and models often serve as efficient execution engines for the modelled artefacts while permitting formal\u00a0\u2026", "num_citations": "36\n", "authors": ["1589"]}
{"title": "Inductive assertions and operational semantics\n", "abstract": " This paper shows how classic inductive assertions can be used in conjunction with an operational semantics to prove partial correctness properties of programs. The method imposes only the proof obligations that would be produced by a verification condition generator but does not require the definition of a verification condition generation. The paper focuses on iterative programs but recursive programs are briefly discussed. Assertions are attached to the program by defining a predicate on states. This predicate is then \u201ccompleted\u201d to an alleged invariant by the definition of a partial function defined in terms of the state transition function of the operational semantics. If this alleged invariant can be proved to be an invariant under the state transition function, it follows that the assertions are true every time they are encountered in execution and thus that the post-condition is true if reached from a state satisfying\u00a0\u2026", "num_citations": "35\n", "authors": ["1589"]}
{"title": "Computational logic: structure sharing and proof of program properties\n", "abstract": " This thesis describes the results of two studies in computational logic. The first concerns a very efficient method of implementing resolution theorem provers. The second concerns a non-resolution program which automatically proves many theorems about LISP functions, using structural induction. In Part 1, a method of representing clauses, called 'structure sharing'is presented. In this representation, terms are instantiated by binding their variables on a stack, or in a dictionary, and derived clauses are represented in terms of their parents. This allows the structure representing a clause to be used in different contexts without renaming its variables or copying it in any way. The amount of space required for a clause is (2 + n) 36-bit words, where n is the number of components in the unifying substitution made for the resolution or factor. This is independant of the number of literals in the clause and the depth of function nesting. Several ways of making the unification algorithm more efficient are presented. These  include a method od preprocessing the input terms so that the unifying substitution for derived terms can be discovered by a recursive look-up proceedure. Techniques for naturally mixing computation and deduction are presented. The structure sharing implementation of SL-resolution is described in detail. The relationship between structure sharing and programming language implementations is discussed. Part 1 concludes with the presentation of a programming language, based on predicate calculus, with structure sharing as the natural implementation. Part 2 of this thesis describes a program which automatically proves a wide variety of\u00a0\u2026", "num_citations": "35\n", "authors": ["1589"]}
{"title": "An ACL2 tutorial\n", "abstract": " We describe a tutorial that demonstrates the use of the ACL2 theorem prover. We have three goals: to enable a motivated reader to start on a path towards effective use of ACL2; to provide ideas for other interactive theorem prover projects; and to elicit feedback on how we might incorporate features of other proof tools into ACL2.", "num_citations": "33\n", "authors": ["1589"]}
{"title": "Learning and computational neuroscience: Foundations of adaptive networks\n", "abstract": " Learning and Computational Neuroscience | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksLearning and Computational Neuroscience: Foundations of Adaptive Networks Export Citation Select Citation format Download citation Copy citation Categories Journals Magazines Books Proceedings SIGs Conferences Collections People About About ACM Digital Library Subscription Information Author Guidelines Using ACM Digital Library All Holdings within the ACM Digital Library ACM Computing Classification System Join Join ACM Join SIGs Subscribe to Publications Institutions and Libraries Connect Contact \u2026", "num_citations": "31\n", "authors": ["1589"]}
{"title": "The use of a formal simulator to verify a simple real time control program\n", "abstract": " We present an initial and elementary investigation of the formal specification and mechanical verification of programs that interact with environments. We describe a formal, mechanically produced proof that a simple, real time control program keeps a vehicle on a straightline course in a variable crosswind. To formalize the specification we define a mathematical function which models the interaction of the program and its environment. We then state and prove two theorems about this function: the simulated vehicle never gets farther than three units away from the intended course and homes to the course if the wind ever remains steady for at least four sampling intervals.", "num_citations": "31\n", "authors": ["1589"]}
{"title": "A mechanical proof of the termination of Takeuchi's function\n", "abstract": " In this paper we present a new proof that Takcrrchi\u2019s reeursivc equation defines a total function for all integer (positive and negative) input. The proof is disr ingui~ hed irom earlier proofs in two respects: the \u2018measure\u2019used to prove termination is a simple lexicographic cc; abination of linear functions, and the prOOf W25 Ci rst constructed by a mechanical theorem-prover, We briefly discuss the mechanical theorem-prover that constructed the proof. I! ei\u2019) re prcscnting the work of our theorem-prover, WC E:.:: describe the brief history of Takeuchi\u2019s functii? r; In [7 j, Takeuchi describes a LISP program designed: o test various LISP implementations. The program called TAK, computes its answer according to the following recursive prescription:", "num_citations": "31\n", "authors": ["1589"]}
{"title": "Integrating external deduction tools with ACL2\n", "abstract": " We present an interface connecting the ACL2 theorem prover with external deduction tools. The ACL2 logic contains several mechanisms for proof structuring, which are important to the construction of industrial-scale proofs. The complexity induced by these mechanisms makes the design of the interface challenging. We discuss some of the challenges, and develop a precise specification of the requirements on the external tools for a sound connection with ACL2. We also develop constructs within ACL2 to enable the developers of external tools to satisfy our specifications. The interface is available with the ACL2 theorem prover starting from Version 3.2, and we describe several applications of the interface.", "num_citations": "25\n", "authors": ["1589"]}
{"title": "A self-verifying theorem prover\n", "abstract": " Programs have precise semantics, so we can use mathematical proof to establish their properties. These proofs are often too large to validate with the usual \u201csocial process\u201d of mathematics, so instead we create and check them with theorem-proving software. This software must be advanced enough to make the proof process tractable, but this very sophistication casts doubt upon the whole enterprise: who verifies the verifier?", "num_citations": "25\n", "authors": ["1589"]}
{"title": "Proof styles in operational semantics\n", "abstract": " abs We relate two well-studied methodologies in deductive verification of operationally modeled sequential programs, namely the use of inductive invariants and clock functions. We show that the two methodologies are equivalent and one can mechanically transform a proof of a program in one methodology to a proof in the other. Both partial and total correctness are considered. This mechanical transformation is compositional; different parts of a program can be verified using different methodologies to achieve a complete proof of the entire program. The equivalence theorems have been mechanically checked by the ACL2 theorem prover and we implement automatic tools to carry out the transformation between the two methodologies in ACL2.", "num_citations": "25\n", "authors": ["1589"]}
{"title": "A mechanically checked proof of a multiprocessor result via a uniprocessor view\n", "abstract": " We describe a mechanically checked correctness proof for a system of n processes, each running a simple, non-blocking counter algorithm. We prove that if the system runs longer than 5n steps, the counter is increased. The theorem is formalized in applicative Common Lisp and proved with the ACL2 theorem prover. The value of this paper lies not so much in the trivial algorithm addressed as in the method used to prove it correct. The method allows one to reason accurately about the behavior of a concurrent, multiprocess system by reasoning about the sequential computation carried out by a selected process, against a memory that is changed externally. Indeed, we prove general lemmas that allow shifting between the multiprocess and uniprocess views. We prove a safety property using a multiprocess view, project the property to a uniprocess view, and then prove a global progress property via a local\u00a0\u2026", "num_citations": "25\n", "authors": ["1589"]}
{"title": "The Semiautomatic Generation of Inductive Assertions for Proving Program Correctness.\n", "abstract": " This interim report describes progress on a project aimed at solving a serious problem that has been encountered in attempts to make program correctness proving a practical technique for software verification. The principal problem addressed here is the difficulty of synthesizing so-called loop assertions in connection with the main method now under study for program proving. Several rather diverse approaches, some of them constituting such alternatives to the present technique, are considered here transformation of programs into primitive recursive form before verification, the method of generator induction for proof of properties of complex data structures, the use of a hierarchical design methodology to structure programs so as to minimize the need for loop assertions, and methods related to subgoal induction and computational induction. The two latter methods were analyzed in detail and compared with the present approach to arrive at a better understanding of their mutual relationships.Descriptors:", "num_citations": "25\n", "authors": ["1589"]}
{"title": "The Interlisp virtual machine specification\n", "abstract": " The INTERLISP Virtual Machine is the environment in which the INTERLISP System is implemented. It includes such abstract objects as\" Literal Atoms\",\" List Cells\",\" Integers\", etc., the basic LISP functions for manipulating them, the underlying program control and variable binding mechanisms, the input/output facilities, and interrupt processing facilities. In order to Implement the INTER LISP System (as described in The INTERLISP Reference Manual by W. Teitelman, et. al.) on some physical machine, it is only necessary to implement the INTERLISP Virtual Machine, since Virtual Machine compatible source code for the rest of the INTERLISP System can be obtained from publicly available files. This document specifies the behavior of the INTER LISP Virtual Machine from the implementor's point of view. That is, it is an attempt to make explicit those things which must be implemented to allow the INTERLISP System to run on some machine.", "num_citations": "25\n", "authors": ["1589"]}
{"title": "Low-temperature thermal control for a lunar base\n", "abstract": " The lunar environment places some unique demands on a thermal management system designed for manned lunar missions. A principal concern is that for many prime base locations the effective thermal sink temperature is often near or above nominal room temperature (25\u00b0C). This is due to the fact that a conventional radiator must look at either, or both, the sun and the hot lunar surface. Direct rejection of waste heat at such temperatures is thus impossible, and some alternative approach is needed to enable a sustained mission. This paper presents three such alternative systems: a heat pump assisted central thermal bus; an innovative, selective field-of-view radiator; and use of the lunar regolith as a heat sink. All of these concepts appear feasible, but each has uncertainties associated with its practicality and weight estimate. The heat pump assisted thermal bus appears to be the most viable concept and is\u00a0\u2026", "num_citations": "24\n", "authors": ["1589"]}
{"title": "A Theorem-Prover for Recursive Functions: A User's Manual.\n", "abstract": " A users manual for an automatic theorem-proving computer program is presented. We here describe how to use the program, which is written in the INTERLISP dialect of LISP. Matters covered include our syntactic conventions starting up the theorem-prover defining functions proving and storing lemmas undoing previous work and examining and saving the theorem-provers state. More than 30 user commands are defined and described. Simple examples are given.Descriptors:", "num_citations": "24\n", "authors": ["1589"]}
{"title": "Analysing discussion forum data: a replication study avoiding data contamination\n", "abstract": " The widespread use of online discussion forums in educational settings provides a rich source of data for researchers interested in how collaboration and interaction can foster effective learning. Such online behaviour can be understood through the Community of Inquiry framework, and the cognitive presence construct in particular can be used to characterise the depth of a student's critical engagement with course material. Automated methods have been developed to support this task, but many studies used small data sets, and there have been few replication studies.", "num_citations": "21\n", "authors": ["1589"]}
{"title": "Acl2\n", "abstract": " The best way to learn how to use the ACL2 system is to learn how to do inductive proofs about recursive functions. We therefore recommend that you work your way through Recursion and Induction and solve every exercise. Our answers are also posted but we strongly recommend that you not look at them until you have worked very hard on the problem and explored every possibility you can think of!Reading our answers doesn't help you! Nevertheless, if you've really given up, you can find the answers here (in the form of an ACL2 input file) and you can see ACL2's output in response to our answers here.", "num_citations": "21\n", "authors": ["1589"]}
{"title": "An overview of automated reasoning and related fields\n", "abstract": " This article provides an overview of automated reasoning and of the various fields for which it is relevant. It takes the form of a collection of articles, each covering some field and each written by an expert in that field. A field is introduced, its elements reviewed, the current state of the art given, the basic problems discussed, and the various goals listed. Although individually the goals of each field present a wide spectrum, collectively the fields share the interest of automating the process known as reasoning.", "num_citations": "21\n", "authors": ["1589"]}
{"title": "Milestones from the pure Lisp theorem prover to ACL2\n", "abstract": " We discuss the evolutionary path from the Edinburgh Pure Lisp Theorem Prover of the early 1970s to its modern counterpart, AComputational Logic for Applicative Common Lisp, aka ACL2, which is in regular industrial use. Among the milestones in this evolution are the adoption of a first-order subset of a programming language as a logic; the analysis of recursive definitions to guess appropriate mathematical induction schemes; the use of simplification in inductive proofs; the incorporation of rewrite rules derived from user-suggested lemmas; the generalization of that idea to allow the user to affect other proof techniques soundly; the recognition that evaluation efficiency is paramount so that formal models can serve as prototypes and the logic can be used to reprogram the system; use of the system to prove extensions correct; the incorporation of decision procedures; the provision of hierarchically structured\u00a0\u2026", "num_citations": "20\n", "authors": ["1589"]}
{"title": "Formal models of Java at the JVM level a survey from the ACL2 perspective\n", "abstract": " We argue that a practical way to apply formal methods to Java is to apply formal methods to the Java Virtual Machine (JVM) instead. A Java system can be proved correct by analyzing the bytecode produced for it. We believe that this clari es the semantic issues without introducing inappropriate complexity. We say\\inappropriate\" because we believe the complexity present in the JVM view of a Java class is inherent in the Java, when accurately modeled. If it is desired to model a subset of Java or to model\\Java\" with a slightly simpler semantics, that can be done by formalizing a suitable abstraction of the JVM. In this paper we support these contentions by surveying recent applications of the ACL2 theorem proving system to the JVM. In particular, we describe how ACL2 is used to formalize operational semantics, we describe several models of the JVM, and we describe proofs of theorems involving these models. We are using these models to explore a variety of Java issues from a formal perspective, including Java's bounded arithmetic, object manipulation via the heap, class inheritance, method resolution, singleand multi-threaded programming, synchronization via monitors in the heap, and properties of the bytecode veri er.", "num_citations": "19\n", "authors": ["1589"]}
{"title": "Recurrent seasonal outbreak of an emerging serotype of Shiga toxin-producing Escherichia coli (STEC O55: H7 Stx2a) in the south west of England, July 2014 to September 2015\n", "abstract": " The first documented British outbreak of Shiga toxin-producing Escherichia coli (STEC) O55:H7 began in the county of Dorset, England, in July 2014. Since then, there have been a total of 31 cases of which 13 presented with haemolytic uraemic syndrome (HUS). The outbreak strain had Shiga toxin (Stx) subtype 2a associated with an elevated risk of HUS. This strain had not previously been isolated from humans or animals in England. The only epidemiological link was living in or having close links to two areas in Dorset. Extensive investigations included testing of animals and household pets. Control measures included extended screening, iterative interviewing and exclusion of cases and high risk contacts. Whole genome sequencing (WGS) confirmed that all the cases were infected with similar strains. A specific source could not be identified. The combination of epidemiological investigation and WGS indicated\u00a0\u2026", "num_citations": "15\n", "authors": ["1589"]}
{"title": "Formal verification of application and system programs based on a validated x86 ISA model\n", "abstract": " Two main kinds of tools available for formal software verification are point tools and general-purpose tools.  Point tools are targeted towards bug-hunting or proving a fixed set of properties, such as establishing the absence of buffer overflows.  These tools have become a practical choice in the development and analysis of serious software systems, largely because they are easy to use.  However, point tools are limited in their scope because they are pre-programmed to reason about a fixed set of behaviors.  In contrast, general-purpose tools,like theorem provers, have a wider scope.  Unfortunately, they also have a higher user overhead.  These tools often use incomplete and/or unrealistic software models, in part to reduce this overhead.  Formal verification based on such a model can be restrictive because it does not account for program behaviors that rely on missing features in the model.  The results of such formal verification undertakings may be unreliable --- consequently, they can offer a false sense of security. This dissertation demonstrates that formal verification of complex program properties can be made practical, without any loss of accuracy or expressiveness, by employing a machine-code analysis framework implemented using a mechanical theorem prover. To this end, we constructed a formal and executable model of the x86 Instruction-Set Architecture using the ACL2 theorem-proving system.  This model includes a specification of 400+ x86 opcodes and architectural features like segmentation and paging.  The model's high execution speed allows it to be validated routinely by performing co-simulations against a physical x86\u00a0\u2026", "num_citations": "15\n", "authors": ["1589"]}
{"title": "A simple method for cloning genes involved in glucan biosynthesis: isolation of structural and regulatory genes for glycogen synthesis in Escherichia coli\n", "abstract": " A simple and widely applicable method for cloning genes involved in glucan biosynthesis is described. An Escherichia coli genomic library was prepared in the low-copy plasmid, pLG339, and E. coli transformants from this library were screened by staining with iodine vapor. Colonies that stained darker than the control were isolated and characterized. The three classes of clones that were identified included: (i) plasmids encoding E. coli glycogen biosynthetic (glg) structural genes, (ii) clones that resulted in elevated glycogen levels, but did not encode glg structural genes or enhance the level of the first enzyme of the pathway, ADPglucose pyrophosphorylase (AGPP), and (iii) clones that enhanced the level of AGPP, but did not encode this enzyme. Two clones from the latter class also enhanced glgC'-'lacZ-encoded \u03b2-galactosidase activity, and may encode factors that regulate the expression of glg structural genes\u00a0\u2026", "num_citations": "15\n", "authors": ["1589"]}
{"title": "PARP inhibition combined with thoracic irradiation exacerbates esophageal and skin toxicity in C57BL6 mice\n", "abstract": " PurposePoly (ADP-ribose) polymerase (PARP) inhibitors have been shown to enhance the radiosensitivity of cancer cells in\u00a0vitro in a replication-dependent manner. Their in\u00a0vivo radiosensitizing effects have also been demonstrated in preclinical tumor models. However, whether PARP inhibition can enhance the response to radiation therapy in normal tissues has been largely neglected. We hypothesized that PARP inhibition might also potentiate the response of replicating normal tissues to radiation therapy. In this study, we examined the normal tissue response in mice treated with PARP inhibitors (BMN673 or AZD2281) in combination with thoracic irradiation.Methods and MaterialsThe antitumor effects of fractionated irradiation (5\u00a0Gy\u00a0\u00d7\u00a04) in combination with BMN673 were evaluated in nude mice bearing established Calu-6 human lung cancer xenografts. The normal tissue response was evaluated in C57BL6\u00a0\u2026", "num_citations": "14\n", "authors": ["1589"]}
{"title": "Mechanically verified hardware implementing an 8-bit parallel io byzantine agreement processor\n", "abstract": " Consider a network of four processors that use the Oral Messages (Byzantine Generals) al/gonthm of Pease, Shostak a_d Lamport to achieve agreement in the presence of faults. Bevier and Young have published a functionai dcs,: ription of a single processor that, when interconnected appropriately with three identical others, implements this network under the assumption that the four processors step in synchrony. By formalizing the original Pease, Shostak and Lamport work, Bevier and Young mechanically proved that such a network achieves fault tolerance. In this paper we develop, formalize and discuss a hardware design that has been mechanically proved to implement their processor. In particular, we formally define mapping functions from the abstract state space of the Bevier-Young processor to a concrete state space of a hardware module and state a theorem that expresses the claim that the hardware correctly implements the processor. We briefly discuss the Brock-Hunt Formal Hardware Description Language which permits designs both to be proved correct with the Boyer-Moore theorem prover and to be expressed in a commercially supported hardware description language for additional electrical analysis and layout. We briefly describe our implementation, which actually takes the form of a hardware design generator which produces a design as a function of the desired word size. We exhibit the theorem that establishes that the generator is correct. We exhibit the instance generated for sense data of width 8, in the syntax of NDL, a hardware description language supported by LSI Logic, Inc. We exhibit some results of processing the\u00a0\u2026", "num_citations": "14\n", "authors": ["1589"]}
{"title": "String searching over small alphabets\n", "abstract": " We propose a new string searching procedure inspired by the Boyer\u2013Moore algorithm. The two key ideas of our improvement are to keep track of all the previously matched characters within the current alignment and not to move the reading position unconditionally to the end of the pattern when a mismatch occurs. The result is an algorithm with increased average shift amounts and a guarantee that any character of the text is read at most once. The algorithm performs especially well when the alphabet size is small. We also discuss and test variants of the original idea aimed at practical implementations.", "num_citations": "13\n", "authors": ["1589"]}
{"title": "An exercise in graph theory\n", "abstract": " We define a function that finds a path between two given nodes of a given directed graph, if such a path exists. We prove the function terminates and we prove that it is correct. Aside from illustrating one way to formalize directed graphs in ACL2, this chapter illustrates the importance of the user\u2019s decomposition of a problem into mathematically tractable parts and the importance of defining new concepts to formalize those parts. Our proof involves such auxiliary notions as that of a simple (loop-free) path, the process for obtaining a simple path from an arbitrary path, and an algorithm for collecting all simple paths. The algorithm we analyze is a naive one that executes in time exponential in the number of edges. This chapter requires no specialized knowledge of graph theory; indeed, the main thrusts of the chapter have nothing to do with graph theory. They are: to develop your formalization skills and to refine\u00a0\u2026", "num_citations": "13\n", "authors": ["1589"]}
{"title": "Rewriting with equivalence relations in ACL2\n", "abstract": " Traditionally, a conditional rewrite rule directs replacement of one term by another term that is provably equal to it, perhaps under some hypotheses. This paper generalizes the notion of rewrite rule to permit the connecting relation to be merely an equivalence relation. We then extend the algorithm for applying rewrite rules. Applications of these generalized rewrite rules are only admissible in certain equivalential contexts, so the algorithm tracks which equivalence relations are to be preserved and admissible generalized rewrite rules are selected according to this context. We introduce the notions of congruence rule and refinement rule. We also introduce the idea of generated equivalences, corresponding to a new equivalence relation generated by a set of pre-existing ones. Generated equivalences are used to give the rewriter broad access to admissible generalized rewrite rules. We discuss the\u00a0\u2026", "num_citations": "12\n", "authors": ["1589"]}
{"title": "A mechanical analysis of program verification strategies\n", "abstract": " We analyze three proof strategies commonly used in deductive verification of deterministic sequential programs formalized with operational semantics. The strategies are (i)\u00a0stepwise invariants, (ii)\u00a0clock functions, and (iii)\u00a0inductive assertions. We show how to formalize the strategies in the logic of the ACL2 theorem prover. Based on our formalization, we prove that each strategy is both sound and complete. The completeness result implies that given any proof of correctness of a sequential program one can derive a proof in each of the above strategies. The soundness and completeness theorems have been mechanically checked with ACL2.", "num_citations": "12\n", "authors": ["1589"]}
{"title": "Overview of a theorem-prover for a computational logic\n", "abstract": " The Logic and the Implementation A brief description of our theorem-proving system may be found in [6]. The theorem prover and its logic, as of 1979, are described completely in I1]. A slight revision of the logic is presehted in [2], where ales a~ metafunction\" facility is described which permits the user to define new proof procedures in the logic, prove them correct mechanically, and have them used efficiently in subsequent proof attempts. During the period 1980-1985 a linear arithmetic decision procedure was integrated into the rule-driven simplifier. The problems of integrating a decision procedure into a heuristic theorem prover for a richer theory are discussed in [8].", "num_citations": "12\n", "authors": ["1589"]}
{"title": "A computer Proof of the Correctness of a Simple Optimizing Compiler for Expressions.\n", "abstract": " This paper presents an automatic computer proof of the correctness of a simple optimizing compiler for expressions. The proof was produced by a new theorem prover, resembling the Boyer-Moore Pure LISP Theorem Prover but operating on a much richer domain of functions and objects.Descriptors:", "num_citations": "12\n", "authors": ["1589"]}
{"title": "A mechanized program verifier\n", "abstract": " In my view, the \u201cverification problem\u201d is the theorem proving problem, restricted to a computational logic. My approach is: adopt a functional programming language, build a general purpose formal reasoning engine around it, integrate it into a program and proof development environment, and apply it to model and verify a wide variety of computing artifacts, usually modeled operationally within the functional programming language. Everything done in this approach is software verification since the models are runnable programs in a subset of an ANSI standard programming language (Common Lisp). But this approach is of interest to proponents of other approaches (e.g., verification of procedural programs or synthesis) because of the nature of the mathematics of computing. I summarize the progress so far using this approach, sketch the key research challenges ahead and describe my vision of the role and\u00a0\u2026", "num_citations": "11\n", "authors": ["1589"]}
{"title": "Finite set theory in ACL2\n", "abstract": " ACL2 is a first-order, essentially quantifier free logic of computable recursive functions based on an applicative subset of Common Lisp. It supports lists as a primitive data structure. We describe how we have formalized a practical finite set theory for ACL2. Our finite set theory \u201cbook\u201d includes set equality, set membership, the subset relation, set manipulation functions such as union, intersection, etc., a choice function, a representation of finite functions as sets of ordered pairs and a collection of useful functions for manipulating them (e.g., domain, range, apply) and others. The book provides many lemmas about these primitives, as well as macros for dealing with set comprehension and some other \u201chigher order\u201d features of set theory, and various strategies or tactics for proving theorems in set theory. The goal of this work is not to provide \u201cheavy duty set theory\u201d - a task more suited to other logics - but to allow\u00a0\u2026", "num_citations": "11\n", "authors": ["1589"]}
{"title": "An Executable Formal Java Virtual Machine Thread Model.\n", "abstract": " We discuss an axiomatic description of a simple abstract machine similar to the Java Virtual Machine (JVM). Our model supports classes, with fields and bytecoded methods, and a representative sampling of JVM bytecodes for basic operations for both data and control. The GETFIELD and PUTFIELD instructions accurately model inheritance, as does the INVOKEVIRTUAL instruction. Our model supports multiple threads, synchronized methods, and monitors. Our current model is inadequate or inaccurate in many respects (eg, we do not formalize the JVM\u2019s finite arithmetic nor do we describe class loading and initialization). But the model is a useful tool for studying the application of formal reasoning to the JVM and to Java programs.We demonstrate two useful aspects of an operational formal semantics. First, the model is executable: bytecoded methods can be run on the model. Second, the model allows us to\u00a0\u2026", "num_citations": "11\n", "authors": ["1589"]}
{"title": "Almost sure parameter estimation and convergence rates for hidden Markov models\n", "abstract": " A continuous time version of Kronecker\u2019s Lemma is established and used to give rates of convergence for parameter estimates in Hidden Markov Models.Acknowledgements: The support of NSERC grant A7964 is gratefully acknowledged. Professor Moore wishes to thank the Department of Mathematical Sciences, University of Alberta, for its hospitality in July 1996 when this work was carried out.", "num_citations": "11\n", "authors": ["1589"]}
{"title": "Dialogue attributes that inform depth and quality of participation in course discussion forums\n", "abstract": " This paper describes work in progress to answer the question of how we can identify and model the depth and quality of student participation in class discussion forums using the content of the discussion forum messages. We look at two widely-studied frameworks for assessing critical discourse and cognitive engagement: the ICAP and Community of Inquiry (CoI) frameworks. Our goal is to discover where they agree and where they offer complementary perspectives on learning.", "num_citations": "10\n", "authors": ["1589"]}
{"title": "An acl2 proof of write invalidate cache coherence\n", "abstract": " As a pedagogical exercise in ACL2, we formalize and prove the correctness of a write invalidate cache scheme. In our formalization, an arbitrary number of processors, each with its own local cache, interact with a global memory via a bus which is snooped by the caches.", "num_citations": "10\n", "authors": ["1589"]}
{"title": "Inductive assertions and operational semantics\n", "abstract": " This paper shows how classic inductive assertions can be used in conjunction with a formal operational semantics to prove partial correctness properties of programs. The method imposes only the proof obligations that would be produced by a verification condition generator \u2013 but does not require the definition of a verification condition generator. All that is required is a theorem prover, a formal operational semantics, and the object program with appropriate assertions at user-selected cut points. The verification conditions are generated in the course of the theorem-proving process by straightforward symbolic evaluation of the formal operational semantics. The technique is demonstrated by proving the partial correctness of simple bytecode programs with respect to a preexisting operational model of the Java Virtual Machine.", "num_citations": "9\n", "authors": ["1589"]}
{"title": "A computational logic for applicative common LISP\n", "abstract": " This chapter contains sections titled:   Introduction   The ACL2 System   A Modeling Problem   Case Studies", "num_citations": "9\n", "authors": ["1589"]}
{"title": "On the desirability of mechanizing calculational proofs\n", "abstract": " Dijkstra argues that calculational proofs are preferable to traditional pictorial and/or verbal proofs. First, due to the calculational proof format, incorrect proofs are less likely. Second, syntactic considerations (letting the \u201csymbols do the work\u201d) have led to an impressive array of techniques for elegant proof construction. However, calculational proofs are not formal and are not flawless. Why not make them formal and check them mechanically?", "num_citations": "9\n", "authors": ["1589"]}
{"title": "A fast majority vote algorithm\n", "abstract": " A new algorithm is presented for determining which, if any, of an arbitrary number of candidates has received a majority of the votes cast in an election. The number of comparisons required is at most twice the number of votes. Furthermore, the algorithm uses storage in a way that permits an efficient use of magnetic tape.", "num_citations": "9\n", "authors": ["1589"]}
{"title": "A mechanically checked proof of the correctness of the Boyer-Moore fast string searching algorithm\n", "abstract": " We describe a mechanically checked proof that the Boyer-Moore fast string searching algorithm is correct. This is done by expressing both the fast algorithm and the na\u00efve (obviously correct) algorithm as functions in applicative Common Lisp and proving them equivalent with the ACL2 theorem prover. The algorithm verified differs from the original Boyer-Moore algorithm in one key way: the original algorithm preprocessed the pattern into two arrays and skipped forward by the maximum of the skip distances recorded in those arrays; the algorithm verified uses one array that combines the two original arrays (and awhose size is the product of that of the original arrays). The algorithm here skips at least as far as the original Boyer-Moore algorithm and often skips further, though we do not prove that mechanically. A key fact about the original algorithm is that preprocessing can be done in time linear in the length of the\u00a0\u2026", "num_citations": "8\n", "authors": ["1589"]}
{"title": "The addition of bounded quantification and partial functions to a computational logic and its theorem prover\n", "abstract": " We describe an extension to our quantifier-free computational logic to provide the expressive power and convenience of bounded quantifiers and partial functions. By quantifier we mean a formal construct which introduces a bound or indicial variable whose scope is some subexpression of the quantifier expression. A familiar quantifier is the \u2211 operator which sums the values of an expression over some range of values on the bound variable. Our method is to represent expressions of the logic as objects in the logic, to define an interpreter for such expressions as a function in the logic, and then define quantifiers as \u201cmapping functions.\u201d The novelty of our approach lies in the formalization of the interpreter and its interaction with the underlying logic. Our method has several advantages over other formal systems that provide quantifiers and partial functions in a logical setting. The most important advantage is that proofs\u00a0\u2026", "num_citations": "8\n", "authors": ["1589"]}
{"title": "Integrating CCG analysis into ACL2\n", "abstract": " ACL2 [6\u20138] is a powerful, industrial strength theorem proving system, which has been used on numerous verification projects. It is part of the Boyer-Moore family of provers, for which its authors received the 2005 ACM Software System Award. Termination plays a central role in ACL2\u2019s logic. It is used to demonstrate the logical consistency of function definitions and allows for the admission of an induction scheme that mirrors each function\u2019s recursive structure. In previous work we introduced calling context graphs (CCGs) and showed how they can be combined with theorem proving queries to provide a powerful method for proving termination of programs written in first order, functional programming languages [15]. In this paper we describe work we are doing to integrate CCG-based termination analysis into ACL2. We begin in the next section by providing relevant background on ACL2 and its current approach to termination analysis as well as the CCG approach to termination analysis. Section 3 then describes our work on extending ACL2 to include the CCG approach, with a focus on issues encountered. We conclude in Section 4.", "num_citations": "7\n", "authors": ["1589"]}
{"title": "Automation of mathematical induction as part of the history of logic\n", "abstract": " The automation of mathematical theorem proving for deductive first-order logic started in the 1950s, and it took about half a century to develop software systems that are sufficiently strong and general to be successfully applied outside the community of automated theorem proving. 1 For more restricted logic languages, such as propositional logic and the purely equational fragment, such strong systems were not achieved much earlier. 2 Moreover, automation of theorem proving for higher-order logic has started becoming generally useful only during the last ten years. 3", "num_citations": "6\n", "authors": ["1589"]}
{"title": "How can i do that with acl2? recent enhancements to acl2\n", "abstract": " The last several years have seen major enhancements to ACL2 functionality, largely driven by requests from its user community, including utilities now in common use such as 'make-event', 'mbe', and trust tags. In this paper we provide user-level summaries of some ACL2 enhancements introduced after the release of Version 3.5 (in May, 2009, at about the time of the 2009 ACL2 workshop) up through the release of Version 4.3 in July, 2011, roughly a couple of years later. Many of these features are not particularly well known yet, but most ACL2 users could take advantage of at least some of them. Some of the changes could affect existing proof efforts, such as a change that treats pairs of functions such as 'member' and 'member-equal' as the same function.", "num_citations": "6\n", "authors": ["1589"]}
{"title": "Proof search debugging tools in ACL2\n", "abstract": " Any mechanized theorem prover with interesting automatic search features should provide the user some feedback on the search process so that failed proof attempts can be debugged. Proof search automation is a central theme of the ACL2 system: once the prover is started the user can do nothing to guide it. The prover\u2019s behavior is determined largely by previously proved theorems in its data base and user advice supplied with the goal conjecture. This design allows ACL2 to be configured to prove a class of problems in a given domain \u201cautomatically,\u201d which supports the industrial \u201creplay\u201d of big proofs about slightly modified designs. But it means that proofs often fail and the user is left wondering why. ACL2 provides a wide variety of search debugging tools to allow the user to answer the questions \u201cwhat is happening?\u201d and \u201cwhat went wrong?\u201d We discuss those tools.", "num_citations": "6\n", "authors": ["1589"]}
{"title": "Mechanized operational semantics\n", "abstract": " Fred Armisen\u2019s office at \u201cSaturday Night Live\u201d is deceptively small, barely big enough to fit a desk, a couch, and an iPod. The glorified closet, the subject of a running joke on the comedy show, now in its 31st season, can simultaneously house a wisecracking...", "num_citations": "6\n", "authors": ["1589"]}
{"title": "Integrating nonlinear arithmetic into ACL2\n", "abstract": " In this paper we present an overview of the integration of a nonlinear arithmetic reasoning package into ACL2. We provide a brief operational description of the entire arithmetic package and describe how it fits into ACL2\u2019s operation, including what was needed for the successful introduction of such a facility into an existing automated theorem prover. We describe most of the changes we made to the previous version of ACL2 as well as a couple of recent improvements to the nonlinear package we made based upon our experiences using the same. The resulting system lessens the human effort required to construct a large arithmetic proof by reducing the number of intermediate lemmas that must be proven.", "num_citations": "6\n", "authors": ["1589"]}
{"title": "Rewriting for symbolic execution of state machine models\n", "abstract": " We describe an algorithm for simplifying a class of symbolic expressions that arises in the symbolic execution of formal state machine models. These expressions are compositions of state access and change functions and if-then-else expressions, laced together with local variable bindings (e.g., lambda applications). The algorithm may be used in a stand-alone way, but is designed to be part of a larger system employing a mix of other strategies. The algorithm generalizes to a rewriting algorithm that can be characterized as outside-in or lazy, with respect both to variable instantiation and equality replacement. The algorithm exploits memoization or caching.", "num_citations": "6\n", "authors": ["1589"]}
{"title": "A mechanically checked proof of a comparator sort algorithm\n", "abstract": " We describe a mechanically checked correctness proof for the comparator sort algorithm underlying a microcode program in a commercially designed digital signal processing chip. The abstract algorithm uses an unlimited number of systolic comparator modules to sort a stream of data. In addition to proving that the algorithm produces an ordered permutation of its input, we prove two theorems that are important to verifying the microcode implementation. These theorems describe how positive and negative\\in nities\" can be streamed into the array of comparators to achieve certain e ects. Interesting generalizations are necessary in order to prove these theorems inductively. The mechanical proofs were carried out with the ACL2 theorem prover. We nd these proofs both mathematically interesting and illustrative of the kind of mathematics that must be done to verify software.", "num_citations": "6\n", "authors": ["1589"]}
{"title": "Comparison of the 5'flanking regions of the Salmonella typhimurium and Escherichia coli glgC genes, encoding ADP glucose pyrophosphorylases.\n", "abstract": " The intracellular levels of glycogen biosynthetic enzymes increase during the transition to stationary phase growth in both Escherichia coli and Salmonella typhimurium (reviewed in 1). The genes encoding the three biosynthetic enzymes glgC (ADP glucose pyrophosphorylase EC 2.7. 7.27), glgA (glycogen synthase) and glgB (glycogen branching enzyme) are clustered at 75 min in bothspecies. The structure of the E. coli glg gene cluster has been completely determined by nucleotide sequencing. It was found to include at least one catabolic gene, glgY or glgP, encoding glycogen phosphorylase (2, 3). The nucleotide sequence of a second glg gene, glgX, suggests that it encodes a glucan hydrolase or transferase (3). The arrangement of the Escherichia coli glg gene cluster is: glgB-glgX-glgC-glgA-glgP. Transcription occurs from left to right. Expression studies suggested that glgC and glgA constitute an operon\u00a0\u2026", "num_citations": "6\n", "authors": ["1589"]}
{"title": "Proof checking theorem proving and program veri\ufb01cation\n", "abstract": " This article consists of three parts: a tutorial introduction to a computer program that proves theorems by induction; a brief description of recent ap-plications of that theorem-prover; and a discussion of several nonteehnical aspects of the problem of building automatic theorem-provers. The theorem~ prover described has proved theorems such as the uniqueness of prime fac-torizations, Fermat's theorem, and the recursive unsolvability of the halting problem.The article is addressed to those who know nothing about automatic theorem-proving but would like a glimpse of one such system. This article definitely does not provide a balanced view of all automatic theorem-proving, the literature of which is already rather large and technical. 2 Nor do we describe the details of our theorem-proving system, but they can be found in the books, articles, and technical reports that we reference.", "num_citations": "6\n", "authors": ["1589"]}
{"title": "The 77 Editor\n", "abstract": " The 77 Editor \u2014 University of Edinburgh Research Explorer Skip to main navigation Skip to search Skip to main content University of Edinburgh Research Explorer Logo Help & FAQ Home Research output Profiles Research Units Projects Datasets Prizes Activities Press / Media Equipment Search by expertise, name or affiliation The 77 Editor Bob Boyer, J Strother Moore, Julian Davies Research output: Book/Report \u203a Commissioned report Overview Original language English Publisher School of Artificial Intelligence, Edinburgh Number of pages 35 Publication status Published - Feb 1973 Externally published Yes Publication series Name Department of Computational Logic Memo Publisher School of Artificial Intelligence No. 62 Access to Document 77-Editor-Users-Manual-1Final published version, 1.12 MB Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Boyer, B., Moore, JS, & Davies, J. (1973). The \u2026", "num_citations": "6\n", "authors": ["1589"]}
{"title": "Stateman: using metafunctions to manage large terms representing machine states\n", "abstract": " When ACL2 is used to model the operational semantics of computing machines, machine states are typically represented by terms recording the contents of the state components. When models are realistic and are stepped through thousands of machine cycles, these terms can grow quite large and the cost of simplifying them on each step grows. In this paper we describe an ACL2 book that uses HIDE and metafunctions to facilitate the management of large terms representing such states. Because the metafunctions for each state component updater are solely responsible for creating state expressions (i.e., \"writing\") and the metafunctions for each state component accessor are solely responsible for extracting values (i.e., \"reading\") from such state expressions, they can maintain their own normal form, use HIDE to prevent other parts of ACL2 from inspecting them, and use honsing to uniquely represent state expressions. The last feature makes it possible to memoize the metafunctions, which can improve proof performance in some machine models. This paper describes a general-purpose ACL2 book modeling a byte-addressed memory supporting \"mixed\" reads and writes. By \"mixed\" we mean that reads need not correspond (in address or number of bytes) with writes. Verified metafunctions simplify such \"read-over-write\" expressions while hiding the potentially large state expression. A key utility is a function that determines an upper bound on the value of a symbolic arithmetic expression, which plays a role in resolving writes to addresses given by symbolic expressions. We also report on a preliminary experiment with the book, which involves\u00a0\u2026", "num_citations": "5\n", "authors": ["1589"]}
{"title": "Efficient, mechanically-verified validation of satisfiability solvers\n", "abstract": " Satisfiability (SAT) solvers are commonly used for a variety of applications, including hardware verification, software verification, theorem proving, debugging, and hard combinatorial problems. These applications rely on the efficiency and correctness of SAT solvers. When a problem is determined to be unsatisfiable, how can one be confident that a SAT solver has fully exhausted the search space? Traditionally, unsatisfiability results have been expressed using resolution or clausal proof systems. Resolution-based proofs contain perfect reconstruction information, but these proofs are extremely large and difficult to emit from a solver. Clausal proofs rely on rediscovery of inferences using a limited number of techniques, which typically takes several orders of magnitude longer than the solving time. Moreover, neither of these proof systems has been able to express contemporary solving techniques such as bounded\u00a0\u2026", "num_citations": "5\n", "authors": ["1589"]}
{"title": "Rough diamond: an extension of equivalence-based rewriting\n", "abstract": " Previous work by the authors generalized conditional rewriting from the use of equalities to the use of arbitrary equivalence relations. Such (classic) equivalence-based rewriting automates the replacement of one subterm by another that may not be strictly equal to it, but is equivalent to it, where this equivalence is determined automatically to be sufficient at that subterm occurrence. We extend that capability by introducing patterned congruence rules in the ACL2 theorem prover, to provide more control over the occurrences where such a replacement may be made. This extension enables additional automation of the rewriting process, which is important in industrial-scale applications. However, because this feature is so new (introduced January, 2014), we do not yet have industrial applications to verify its utility, so we present a small example that illustrates how it supports scaling to large proof efforts.", "num_citations": "5\n", "authors": ["1589"]}
{"title": "Theorem proving for verification: The early days\n", "abstract": " Summary form only given. Since Turing, computer scientists have understood that the question \"does this program satisfy its specifications?\" could be reduced to the question \"are these formulas theorems?\" But the theorem proving technology of the 50s and 60s was inadequate for the task. In 1971, here in Edinburgh, Boyer and I started building the first general-purpose theorem prover designed for a computational logic. This project continues today, with Matt Kaufmann as a partner; the current version of the theorem prover is ACL2 (A Computational Logic for Applicative Common Lisp). In this talk I'll give a highly personal view of the four decade long \"Boyer-Moore Project,\" including our mechanization of inductive proof, support for recursive definitions, rewriting with previously proved lemmas, integration of decision procedures, efficient representation of logical constants, fast execution, and other proof techniques\u00a0\u2026", "num_citations": "5\n", "authors": ["1589"]}
{"title": "A mechanically checked proof of a comparator sort algorithm\n", "abstract": " We describe a mechanically checked correctness proof for the comparator sort algorithm underlying a microcode program in a commercially designed digital signal processing chip. The abstract algorithm uses an unlimited number of systolic comparator modules to sort a stream of data. In addition to proving that the algorithm produces an ordered permutation of its input, we prove two theorems that are important to verifying the microcode implementation. These theorems describe how positive and negative \u201cinfinities\u201d can be streamed into the array of comparators to achieve certain effects. Interesting generalizations are necessary in order to prove these theorems inductively. The mechanical proofs were carried out with the ACL2 theorem prover. We find these proofs both mathematically interesting and illustrative of the kind of mathematics that must be done to verify software.", "num_citations": "5\n", "authors": ["1589"]}
{"title": "Memory taggings and dynamic data structures\n", "abstract": " The aim of this paper is to help formal methods practitioners deal with the formal proofs of elementary properties of data structures represented in a RAM-like memory. This problem commonly arises when dealing with proofs of microcode, machine code, assembly code and compiler correctness. We formalize a version of the problem in ACL2 and discuss how to prove several important properties. In particular, our data structures are typed but the type information is not recorded in the representation. Algorithms for manipulating the representation implicitly respect the declared types. We support arbitrarily many record types within the RAM. Each eld of each record is declared to contain either a data item or a pointer to a record of some xed type. It is possible for records to be overlaid on other records and for the pointer structures to be circular. We de ne an elementary generic algorithm that recursively\\chases\" pointers and writes\\arbitrary\" values to the elds declared to contain data. The formal expression of the algorithm is complicated by both mutual recursion and reexivity, which present technical challenges. We then consider certain\\obvious\" properties, especially the property that the algorithm does not modify addresses that are\\unreachable\" from the initial pointer. Because records may be overlaid in the RAM| causing a given address to be treated sometimes as data and other times as a pointer| these obvious properties are true under only certain restrictions. If the restrictions are stated in terms of reachability the proofs are complicated, if not blocked, by the technical issues above. To prove the properties we generalize them by introducing\u00a0\u2026", "num_citations": "5\n", "authors": ["1589"]}
{"title": "Automatic proof of correctness of a binary addition algorithm\n", "abstract": " The Boyer-Moore Pure LISP Theorem Prover ([1], [2], and [3]) has recently proved the correctness of a program implementing binary addition with a carry flag. Because of the relative complexity of the binary addition algorithm and the automatic nature of the proof, this result was thought interesting enough to warrant this technical note.", "num_citations": "5\n", "authors": ["1589"]}
{"title": "Automation of mathematical induction as part of the history of logic\n", "abstract": " Automation of Mathematical Induction as part of the History of Logic - Research Collection Header Upper Right Menu Log in de jump to https://www.ethz.ch Research Collection Toggle navigation Upper Right Menu Login Help Help Language Deutsch Toggle navigation Search View Item Home Journal Contributions Journal Article View Item Home Journal Contributions Journal Article View Item Research Collection Navigational link Search Automation of Mathematical Induction as part of the History of Logic Mendeley CSV RIS BibTeX Thumbnail Metadata only Author Strother Moore, J Wirth, Claus-Peter Date 2017-06 Type Journal Article ETH Bibliography yes Altmetrics Publication status published Journal / series The IfCoLog Journal of Logics and their Applications Volume 4 (5) Pages / Article No. 1505 - 1634 Publisher College Publications Organisational unit 03874 - Hungerb\u00fchler, Norbert / Hungerb\u00fchler, \u2026", "num_citations": "4\n", "authors": ["1589"]}
{"title": "Enhancements to ACL2 in Versions 5.0, 6.0, and 6.1\n", "abstract": " We report on highlights of the ACL2 enhancements introduced in ACL2 releases since the 2011 ACL2 Workshop. Although many enhancements are critical for soundness or robustness, we focus in this paper on those improvements that could benefit users who are aware of them, but that might not be discovered in everyday practice.", "num_citations": "4\n", "authors": ["1589"]}
{"title": "Parallelizing an interactive theorem prover: functional programming and proofs with ACL2\n", "abstract": " Multi-core systems have become commonplace, however, theorem provers often do not take advantage of the additional computing resources in an interactive setting. This research explores automatically using these additional resources to lessen the delay between when users submit conjectures to the theorem prover and when they receive feedback from the prover that is useful in discovering how to successfully complete the proof of a particular theorem. This research contributes mechanisms that permit applicative programs to execute in parallel while simultaneously preparing these programs for verification by a semi-automatic reasoning system. It also contributes a parallel version of an automated theorem prover, with management of user interaction issues, such as output and how inherently single-threaded, user-level proof features can be configured for use with parallel computation. Finally, this dissertation\u00a0\u2026", "num_citations": "4\n", "authors": ["1589"]}
{"title": "An executable formal JVM thread model\n", "abstract": " We describe an axiomatic description of an abstract machine similar to the Java Virtual Machine but simpler. Our model supports classes, with elds and byte-coded methods, and a representative sampling of JVM byte codes for basic operations for both data and control. The GETFIELD and PUTFIELD instructions accurately model inheritance, as does the INVOKEVIRTUAL instruction. Our model supports multiple threads, synchronized methods, and monitors. Our current model is inadequate or inaccurate in many respects (eg, we do not formalize the JVM's nite arithmetic nor do we describe class loading and initialization). But the model is a useful tool for studying the application of formal reasoning to the JVM and JVM programs.We demonstrate two useful aspects of an operational formal semantics. First, the model is executable: byte coded methods can be run on the model. Second, the model allows us to prove\u00a0\u2026", "num_citations": "4\n", "authors": ["1589"]}
{"title": "The role of automated reasoning in integrated system verification environments\n", "abstract": " This paper focuses on \u2018\u2018system verification,\u2019\u2019the activity of mechanically proving properties of computer systems. Distinguishing characteristics of systems include their large size, their multiple layers of abstraction, and their frequent concern with multiple programming languages and, more generally, multiple models of computation. System verification systems require supreme integration of their component parts. To reason formally about systems one must be able to reason about the relations between its disparate modules, layers of abstraction, and various models of computation. Facilitating system verification is, we believe, the underlying theme of this \u2018\u2018Workshop on the Effective Use of Automated Reasoning Technology in System Development.\u2019\u2019We address that theme explicitly in this paper. We make an important, often overlooked, but essentially trivial point: to reason formally about the relations between various ideas, those ideas must be formalized. However, the popular approach to imposing formal semantics on computational models, namely the creation of \u2018\u2018formula generators,\u2019\u2019fails to formalize the very ideas allegedly being studied. In our view, this explains why so much work on system verification is thwarted by \u2018\u2018integration problems.\u2019\u2019These \u2018\u2018integration problems\u2019\u2019simply disappear when the ideas being studied are formalized and available for logical manipulation by the automated reasoning system. Our observations are supported by our experience in verifying several of the largest systems studied to date.", "num_citations": "4\n", "authors": ["1589"]}
{"title": "Should We Begin a Standardization Process for Interface Logics?\n", "abstract": " this document are those of the author (s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the US Government.", "num_citations": "4\n", "authors": ["1589"]}
{"title": "The TXDT Package-Interlisp Text Editing Primitives\n", "abstract": " The TXOT package is a collection of INTER LISP programs designed for those who wish to build text eQitors in INTERLISP. TXOT provides a new INTERLISP data type, called a buffer, and programs for efficiently inserting, deleting, searching and manipulating text in buffers. Modifications may be made undoable. A unique feature of TXOT is that an address may be\" stuck\" to a character occurrence so as to follow that character wherever it is subsequently moved. TXDT also has provisions for fonts.", "num_citations": "4\n", "authors": ["1589"]}
{"title": "Limited second-order functionality in a first-order setting\n", "abstract": " We describe how we have defined in ACL2 a weak version of the Common Lisp functional apply, which takes a function and list of actuals and applies the function to the actuals. Our version, called apply$, does not operate on functions but on ordinary objects\u2014symbols and lists representing lambda expressions\u2014some of which are interpreted as functions. We define a syntactic notion of \u201ctameness\u201d to identify the interpretable objects. This makes our apply$ weaker than a true second-order functional but we believe apply$ is powerful enough for many uses in ACL2. To maintain soundness and the conservativity of our Definitional Principle we require that certain hypotheses, called \u201cwarrants\u201d, be present in any theorem relying on the behavior of apply$ on non-primitives. Within these constraints we can define \u201cfunctionals\u201d such as sum and foldr which map tame \u201cfunctions\u201d over lists and accumulate the results. This\u00a0\u2026", "num_citations": "3\n", "authors": ["1589"]}
{"title": "SaO001 THE NIMO UK STUDY: IS 1000 MG OF INTRAVENOUS IRON ENOUGH TO ACHIEVE HB TARGETS IN PRE-DIALYSIS ANAEMIC PATIENTS?\n", "abstract": " METHODS: This was a pooled analysis of 3 trials of iron isomaltoside performed in CKD patients (391 dialysis and 249 non-dialysis CKD patients) with IDA [1-3]. Outcome measures were frequency of adverse drug reactions (ADRs) and change in haemoglobin (Hb).RESULTS: 640 patients (373 men, 267 women) were included in the analysis. Cumulative doses of either\u2264 1000 mg...", "num_citations": "3\n", "authors": ["1589"]}
{"title": "The Little Prover\n", "abstract": " An introduction to writing proofs about computer programs, written in an accessible question-and-answer style, complete with step-by-step examples and a simple proof assistant. The Little Prover introduces inductive proofs as a way to determine facts about computer programs. It is written in an approachable, engaging style of question-and-answer, with the characteristic humor of The Little Schemer (fourth edition, MIT Press). Sometimes the best way to learn something is to sit down and do it; the book takes readers through step-by-step examples showing how to write inductive proofs. The Little Prover assumes only knowledge of recursive programs and lists (as presented in the first three chapters of The Little Schemer) and uses only a few terms beyond what novice programmers already know. The book comes with a simple proof assistant to help readers work through the book and complete solutions to every example.", "num_citations": "3\n", "authors": ["1589"]}
{"title": "Enhancements to ACL2 in Versions 6.2, 6.3, and 6.4\n", "abstract": " We discuss ACL2 enhancements introduced in versions released between the ACL2 Workshops in May, 2013 and July, 2014: Versions 6.2 (June, 2013), 6.3 (October, 2013), and 6.4 (January, 2014).(These enhancements were thus made after the release of ACL2 Version 6.1 in February, 2013.) Hence this paper is analogous to two papers that correspond to earlier sets of releases [6, 5]. We summarize some of the more interesting of the roughly 100 items in the release notes for these three releases. While those release notes themselves are summaries, they are intended solely as documentation for what has changed: individual paragraphs are not generally intended to make sense except to those who have relevant background knowledge. Moreover, for the sake of completeness those paragraphs are often rather verbose and dense. This paper, on the other hand, is intended to provide a quick way to get up-todate on the more interesting of the recent ACL2 system improvements. For anyone familiar with ACL2, each brief explanation below is intended to provide sufficient information so that even inexperienced ACL2 users can get a quick sense of the enhancement. Then they can decide whether to read more in the release notes, or even to follow the provided hyperlinks to relevant documentation. ACL2 is typically revised to support soundness, robustness, and functionality of the system, often in direct response to user requests. Because of the maturity of ACL2, the system has many features, and thus improvements often pertain to aspects of ACL2 that may be unfamiliar to many ACL2 users, especially novice users. Our intention, however, is\u00a0\u2026", "num_citations": "3\n", "authors": ["1589"]}
{"title": "A symbolic simulation approach to assertional program verification\n", "abstract": " We present a method for automating deductive proofs of machine-level sequential programs modeled using operational semantics. Given programs annotated by the user with assertions at cutpoints, we show how to use the operational semantics of the machine to derive the verification conditions by symbolic simulation. No verification condition generator is required, nor is it necessary to manually specify an inductive invariant for the machine model. Both partial and total correctness are considered. The methodology has been formalized in both the ACL2 and Isabelle theorem provers, and applied to verify programs on operational machine models in ACL2.", "num_citations": "3\n", "authors": ["1589"]}
{"title": "Recent developments in distributed feedback and distributed Bragg reflector lasers for wide-band long-haul fiber-optic communication systems\n", "abstract": " The requirements for optical sources used in long-haul fiber-optic communication systems are related to the characteristics of single-mode silica fibers operated at 1.55 /spl mu/m. The elementary concepts of distributed feedback (DFB) and distributed Bragg reflector (DBR) lasers are explained. Grating resonators and reflectors are described, and the theory of the frequency-selective property of corrugated gratings is explained. The detrimental consequences of the spatial hole burning phenomenon for the performance of DFB lasers are explained. Nine experimental DFB/DBR laser structures are briefly described and compared.< >", "num_citations": "3\n", "authors": ["1589"]}
{"title": "Investigation, Development, and Evaluation of Performance Proving for Fault-Tolerant Computers\n", "abstract": " 1. Project ObjectivesThis report is concerned with the Formal Verification of computer systems. In the course of carrying out the work reported herein we have developed a number of methodologies for verifying systems, developed computer-based tools that assist users in verifying their systems, and have applied these tools to verifying in part the SIFT ultrareliable aircraft computer.By formal verification we mean showing by mathematical reasoning that a system satisfies its requirement. By a system we mean the computer hardware and the collection of programs that run on the hardware. A requirement is a description of the function to be carried out by the system. The requirement indicates the system's response to all sequences of inputs that could be applied to the system. If the verification is successfully carried out, the system is, in principle, guaranteed to be correct; no further validation (eg, testing) should be required.* However, it should be noted that the system might still contain some errors that require conventional testing to uncover eg due to: errors in the requirement, ommisions in the requirement, errors in portions of the system that are not verified. Thus one should view formal verification as a systematic approach to analyzing a system that when combined with standard methods, is potentially capable of reducing significantly the number of errors in delivered systems.", "num_citations": "3\n", "authors": ["1589"]}
{"title": "On Why It Is Impossible to Prove that the BDX90 Dispatcher Implements a Time-sharing System\n", "abstract": " The Software Implemented Fault Tolerance SIFT system, is written in PASCAL except for about a page of machine code. The SIFT system implements a small time sharing system in which PASCAL programs for separate application tasks are executed according to a schedule with real time constraints. The PASCAL language has no provision for handling the notion of an interrupt such as the B930 clock interrupt. The PASCAL language also lacks the notion of running a PASCAL subroutine for a given amount of time, suspending it, saving away the suspension, and later activating the suspension. Machine code was used to overcome these inadequacies of PASCAL. Code which handles clock interrupts and suspends processes is called a dispatcher. The time sharing/virtual machine idea is completely destroyed by the reconfiguration task. After termination of the reconfiguration task, the tasks run by the dispatcher have no relation to those run before reconfiguration. It is impossible to view the dispatcher as a time-sharing system implementing virtual BDX930s running concurrently when one process can wipe out the others.", "num_citations": "3\n", "authors": ["1589"]}
{"title": "A formal semantics for the SRI hierarchical program design methodology\n", "abstract": " A formal statement of what it means to use (a subset of) the methodology is presented. It is formally defined that some specified module exists and what it means to say that another module is paid correctly implemented on top of it. No attention is to motivation, either of the methodology or of the formal development of it. Concentration is entirely upon mathematical succinctness and precision. A discussion is presented of how to use certain INTERLISP programs which implement the formal definitions. Among these are a program which generates Floyd like verification conditions sufficient to imply the correctness of a module implementation.", "num_citations": "3\n", "authors": ["1589"]}
{"title": "Primitive recursive program transformation\n", "abstract": " We describe how to transform certain flowchart programs into equivalent explicit primitive recursive programs. The input/output correctness conditions for the transformed programs are more amenable to proof than the verification conditions for the corresponding flowchart programs. In particular, the transformed correctness conditions can often be verified automatically by the theorem prover developed by Boyer and Moore [1].", "num_citations": "3\n", "authors": ["1589"]}
{"title": "Transformation-Based Verification\n", "abstract": " The design of complex digital hardware is challenging and error-prone. With short design cycles and increasing complexity of designs, functional verification has become the most expensive and time-consuming phase of the digital design process. Functional verification is the process of validating that the design conforms to its specification. Traditional simulation-based approaches are incomplete and cannot prove the absence of errors. Formal verification techniques are exhaustive, but generally require exponential verification resources with respect to design size. Despite advances in formal verification technologies, there remains a large gap between the size of many industrial design components and the capacity of fully-automated formal tools. Transformation-based verification has been proposed to synergistically leverage various transformations to successively simplify and decompose large problems to ones\u00a0\u2026", "num_citations": "3\n", "authors": ["1589"]}
{"title": "Well-formedness guarantees for ACL2 metafunctions and clause processors\n", "abstract": " Some runtime checks can be safely removed from code if appropriate program properties are proved. We describe how we have applied this idea to the ACL2 theorem prover to speed up the application of user-defined proof procedures. In particular, we discuss how and why we have added a new feature to ACL2 that allows the user to verify certain well-formedness properties of the expressions produced by user-defined proof procedures. Of special interest are the issues of extensibility (how we know that guarantees proved in one theory are adequate in another), formalization of the problem, and design decisions affecting the user interface.", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Proof pearl: proving a simple Von Neumann machine turing complete\n", "abstract": " In this paper we sketch an ACL2-checked proof that a simple but unbounded Von Neumann machine model is Turing Complete, i.e., can do anything a Turing machine can do. The project formally revisits the roots of computer science. It requires re-familiarizing oneself with the definitive model of computation from the 1930s, dealing with a simple \u201cmodern\u201d machine model, thinking carefully about the formal statement of an important theorem and the specification of both total and partial programs, writing a verifying compiler, including implementing an X86-like call/return protocol and implementing computed jumps, codifying a code proof strategy, and a little \u201ccreative\u201d reasoning about the non-termination of two machines.", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Airways in smooth muscle \u03b1-actin null mice experience a compensatory mechanism that modulates their contractile response\n", "abstract": " We hypothesized that ablation of smooth muscle \u03b1-actin (SM \u03b1-A), a contractile-cytoskeletal protein expressed in airway smooth muscle (ASM) cells, abolishes ASM shortening capacity and decreases lung stiffness. In both SM \u03b1-A knockout and wild-type (WT) mice, airway resistance (Raw) determined by the forced oscillation technique rose in response to intravenous methacholine (Mch). However, the slope of Raw (cmH2O\u00b7ml\u22121\u00b7s) vs. log2 Mch dose (\u03bcg\u00b7kg\u22121\u00b7min\u22121) was lower (P = 0.007) in mutant (0.54 \u00b1 0.14) than in WT mice (1.23 \u00b1 0.19). RT-PCR analysis performed on lung tissues confirmed that mutant mice lacked SM \u03b1-A mRNA and showed that these mice had robust expressions of both SM \u03b3-A mRNA and skeletal muscle (SKM) \u03b1-A mRNA, which were not expressed in WT mice, and an enhanced SM22 mRNA expression relative to that in WT mice. Compared with corresponding spontaneously breathing\u00a0\u2026", "num_citations": "2\n", "authors": ["1589"]}
{"title": "A theorem proving tool for program analysis: ACL2\n", "abstract": " A Theorem Proving Tool for Program Analysis: ACL2 Page 1 A Theorem Proving Tool for Program Analysis: ACL2 J Strother Moore (with Matt Kaufmann) Department of Computer Sciences University of Texas at Austin 1 Page 2 Quick Summary \u2022 System Name and Contact Details: ACL2 (AComputational Logic for Applicative Common Lisp) {kaufmann,moore}@cs.utexas.edu http://www.cs.utexas.edu/users/moore/acl2 2 Page 3 \u2022 Logic: Quantifier-Free First Order Logic with Induction (think of Pure Lisp without apply) \u2022 Decidability: Undecidable \u2013 but ACL2 is complete on certain fragments: propositional calculus, equality and uninterpreted function symbols, rational linear arithmetic 3 Page 4 \u2022 Theorem Proving Paradigm: Rewriting using previously proved lemmas, decision procedures, and automatic induction \u2022 User Interaction Paradigm: User \u201cprograms\u201d the system\u2019s behavior by proving lemmas 4 Page 5 \u2022 Typical \u2026", "num_citations": "2\n", "authors": ["1589"]}
{"title": "ACL2 and its applications to digital system verification\n", "abstract": " We describe a methodology for using a mechanical theorem proving system, ACL2, to verify correctness properties for digital system models. After introducing some of the basic terminology and some of the decisions facing those who wish to formalize digital systems, we introduce ACL2, A Computational Logic for Applicative Common Lisp, which is a functional programming language, a first-order mathematical logic, and a proof development environment including a powerful interactive automated theorem prover. We then show how a simple digital system can be formalized in ACL2 and exhibit or describe formal properties provable about it. We conclude with some bibliographic references to examples of variations of the illustrated approach, various proof strategies, and examples of industrial interest.", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Automatically computing functional instantiations\n", "abstract": " Among the standard books distributed with ACL2 is the consider-hint book in the hints subdirectory, which implements a heuristic for computing functional instantiations. The implementation of the hint involves four basic algorithms: a second-order pattern matching algorithm that can compute instantiations for constrained and defined functions that call constrained functions, a process for generating variants of a term obtained by applying equations, a process for extending second-order matching through definitions so that when instantiating defined functions the algorithm can pick up appropriate bindings for the constrained functions inside the definitions, and an algorithm for sorting among likely functional substitutions. The second-order matching algorithm is an incomplete and slightly extended implementation of the Huet-Lang algorithm. We describe the four basic algorithms involved in guessing functional\u00a0\u2026", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Mechanized Operational Semantics: The M1 Story\n", "abstract": " In this paper we explain how to formalize an \u201coperational\u201d or \u201cstate-transition\u201d semantics of a von Neumann programming language in a functional programming language. By adopting an \u201cinterpretive\u201d style, one can execute the model in the functional language to \u201crun\u201d programs in the von Neumann language. Given the ability to reason about the functional language, one can use the model to reason about programs in the von Neumann language. In theory at least, such a formal semantics thus has a dual use: as a simulation engine and as an axiomatic basis for code proofs.The beauty of this approach is that no more logical machinery is needed than to support execution and proof in a functional language: no new program logics and no new meta-logical tools like \u201cverification condition generators\u201d are needed. In this paper we will illustrate the techniques by formalizing a simple programming language called \u201cM1,\u201d for \u201cMachine (or Model) 1.\u201d It is loosely based on the Java Virtual Machine but has been simplified for pedagogical purposes. We will demonstrate the executability of M1 models. We will develop several styles of code proofs, including direct (symbolic simulation) proofs based on Boyer-Moore \u201cclock functions\u201d and Floyd-Hoare inductive assertion proofs. We construct proofs only for the the simplest of programs, namely an iterative factorial example. But to illustrate a more realistic use of the model, we discuss the correctness proof for an M1 implementation of the Boyer-Moore fast string searching algorithm. We also define a compiler for a higher level language called \u201cJ1\u201d and show how to do proofs about J1 code without benefit of a\u00a0\u2026", "num_citations": "2\n", "authors": ["1589"]}
{"title": "How to prove theorems formally\n", "abstract": " Today it is impractical to prove\u2013formally and mechanically\u2013the correctness of entire computing systems of commercial interest. There are a variety of reasons for this, both technical and economic. However, mechanized theorem proving is nevertheless relevant in commercial hardware and software production. But practical considerations require that we focus our attention on problems that are both technically feasible within the time limits available and of interest to system designers.", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Inductive assertions and operational semantics\u2013long version\n", "abstract": " This paper shows how classic inductive assertions can be used in conjunction with an operational semantics to prove partial correctness properties of programs, without the introduction of a verication condition generator. In particular, we show how a formal statement about the operational semantics can be deduced more or less directly from verication conditions and how a\\natural\" proof strategy generates those verication conditions as subgoals. Both iterative and recursive programs are considered. Assertions are attached to the program by dening a predicate on states. This predicate is then\\completed\" to an alleged invariant by the denition of a tail-recursive partial function dened in terms of the state transition function of the operational semantics. If this alleged invariant can be proved to be an invariant under the state transition function, it follows that the assertions are true every time they are encountered in\u00a0\u2026", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Industrially Sponsored University Research in Information Technology: Some Recommendations Regarding Intellectual Property Agreements\n", "abstract": " 1 BackgroundThe Computing Research Association (CRA) annually sponsors a conference at Snowbird, Utah, for the chairs of computer science departments and industrial partners. In 2001, it was decided to form a committee to study the production of model agreements for industrially sponsored university research (typically referred to as industrial-university sponsored research agreements, or SRAs). The primary motivation was to reduce the time and effort spent in negotiating such agreements. The committee was to pay particular attention to the disposition of intellectual property (IP) generated by such sponsored research. IP issues are often stumbling blocks in the negotiation. In addition, because of the focus of CRA, only CS/ECE IP, as opposed to say, pharmaceutical IP or agricultural IP, is relevant. I am co-chair of the committee, along with Gabby Silberman, of IBM Yorktown. This document represents opinions formed on the basis reading (including the bibliography of this memo) and several dozen interviews with university researchers, industrial sponsors, OTL directors and officers, IP lawyers, and others. This report is a work-in-progress. The opinions expressed here are my own, and are not necessarily those of my co-chair, the CRA, or the University of Texas at Austin.", "num_citations": "2\n", "authors": ["1589"]}
{"title": "A commuting diagram relating threaded and non-threaded JVM models\n", "abstract": " We establish a commuting diagram that relates two models of the Java Virtual Machine (JVM). The first model, M3, supports much of Java, including classes, objects, and dynamic method resolution. The second model, M4, builds upon M3 by adding threads, monitors, and synchronized methods. We describe a theorem, Main, that asserts that running certain \u201csingle-threaded\u201d states on M4 is equivalent to transforming those states to the domain of M3, running the transformed state there, and translating the result back to the domain of M4. We define the criteria we use to determine if the resulting states are equivalent, and we define our notion of \u201csingle-threaded\u201d. We then discuss a few lessons learned during the development of Main", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Towards a mechanically checked theory of computation\n", "abstract": " Formal mathematical logic is ideally suited to describing computational processes. We discuss the use of one particular mechanized mathematical logic, namely ACL2 (A                 Computational Logic for Applicative Common Lisp) to model computational problems and to prove theorems about such models. After a few elementary examples, we explain how computational artifacts are formalized in ACL2 and we summarize the main industrial applications of ACL2 as of 1999.", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Marine Nature Conservation Review Sector 9. Inlets in the Bristol Channel and approaches: area summaries\n", "abstract": " Marine Nature Conservation Review Sector 9 Inlets in the Bristol Channel and approaches; area summaries - OpenGrey fra | eng OpenGrey Open System for Information on Grey literature in Europe Home Search Subjects Partners Export Help Search XML To cite or link to this reference: http://hdl.handle.net/10068/609916 Title : Marine Nature Conservation Review Sector 9 Inlets in the Bristol Channel and approaches; area summaries Authors : Moore, J. ; Smith, J. ; Northern, K. ; Corporate author : Joint Nature Conservation Committee, Peterborough (United Kingdom) ; Publication year : 1998 Language : English ; Pagination/Size : 140 p. ; SIGLE classification : 06F - Ecology ; Keyword(s) : MARINE ECOSYSTEMS ; BENTHIC MARINE HABITATS ; Document type : I - Miscellaneous ; ISBN : ISBN 1-86107-453-0 ; Other identifier : GB_ 1999:8164 ; GB ; handle : http://hdl.handle.net/10068/609916 Provenance : SIGLE ; \u2026", "num_citations": "2\n", "authors": ["1589"]}
{"title": "On the difficulty of automating inductive reasoning\n", "abstract": " One explanation is that many researchers in program veri cation mistakenly devoted most of their inductive research e orts to implementingveri cation condition generators', which were implicit, ad hoc, programming-language speci c, induction principles. This misplaced emphasis was perhaps based upon the mistaken notion that a veri cation condition generator was all the induction one needed to prove programs correct. Another explanation is that most theorem-proving work has beenrst order,'but a typical rst order axiomatization of induction involves an axiom schema whose naive realization would be as an in nite number of clauses, too many to type in. Or perhaps it was that theskolemization'that would be required to add such an in nite number of rst order axioms is too hideous to contemplate, much less turn into clauses.A more basic issue is that of search strategy. Which instances of the induction schema\u00a0\u2026", "num_citations": "2\n", "authors": ["1589"]}
{"title": "Iteration in ACL2\n", "abstract": " Iterative algorithms are traditionally expressed in ACL2 using recursion. On the other hand, Common Lisp provides a construct, loop, which -- like most programming languages -- provides direct support for iteration. We describe an ACL2 analogue loop$ of loop that supports efficient ACL2 programming and reasoning with iteration.", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Computing verified machine address bounds during symbolic exploration of code\n", "abstract": " When operational semantics is used as the basis for mechanized verification of machine code programs it is often necessary for the theorem prover to determine whether one expression denoting a machine address is unequal to another. For example, this problem arises when trying to determine whether a read at the address given by expression a is affected by an earlier write at the address given by b. If it can be determined that a and b are definitely unequal, the write does not affect the read. Such address expressions are typically composed of \u201cmachine arithmetic function symbols\u201d such as +, *, mod, ash, logand, logxor, etc., as well as numeric constants and values read from other addresses. In this chapter we present an abstract interpreter for machine address expressions that attempts to produce a bounded natural number interval guaranteed to contain the value of the expression. The interpreter has\u00a0\u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Machines reasoning about machines: 2015\n", "abstract": " Computer hardware and software can be modeled precisely in mathematical logic. If expressed appropriately, these models can be executable, i.e., run on concrete data. This allows them to be used as simulation engines or rapid prototypes. But because they are formal they can be manipulated by symbolic means: theorems can be proved about them, directly, with mechanical theorem provers. But how practical is this vision of machines reasoning about machines? In this highly personal talk, I will describe the 45\u00a0year history of the \u201cBoyer-Moore theorem prover,\u201d starting with its use in Edinburgh, Scotland, to prove simple list processing theorems by mathematical induction (e.g., the reverse of the reverse of x is x) to its routine commercial use in the microprocessor industry (e.g., the floating point operations of the Via Nano 64-bit X86 microprocessor are compliant with the IEEE standard). Along the way we\u00a0\u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Evaluation of NLG Systems\n", "abstract": " Q1: How clear is this description? Try to imagine someone who could see the same grid with the same pictures, but didn\u2019t know which of the pictures was the target. How easily would they be able to find it, based on the phrase given?", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Meta-level features in an industrial-strength theorem prover\n", "abstract": " The ACL2 theorem prover---the current incarnation of\" the\" Boyer-Moore theorem prover---is a theorem prover for an extension of a first-order, applicative subset of Common Lisp. The ACL2 system provides a useful specification and modeling language as well as a useful mechanical theorem proving environment. ACL2 is in use at several major microprocessor manufacturers to verify functional correctness of important components of commercial designs. This talk explores the design of ACL2 and the tradeoffs that have turned out to be pivotal to its success.", "num_citations": "1\n", "authors": ["1589"]}
{"title": "The role of human creativity in mechanized verification\n", "abstract": " The Role of Human Creativity in Mechanized Verification Page 1 The Role of Human Creativity in Mechanized Verification J Strother Moore Department of Computer Science University of Texas at Austin 1 Page 2 John McCarthy(Sep 4, 1927 \u2013 Oct 23, 2011) 2 Page 3 Contributions Lisp, mathematical semantics for programming languages, \u201cArtificial Intelligence,\u201d garbage collection, if-then-else, circumscription for non-monotonic logic, ... 3 Page 4 In order for a program to be capable of learning something it must first be capable of being told it. \u2014 John McCarthy, \u201cPrograms with Common Sense\u201d (aka \u201cThe Advice Taker\u201d), 1959 4 Page 5 Instead of debugging a program, one should prove that it meets its specifications, and this proof should be checked by a computer program. \u2014 John McCarthy, \u201cA Basis for a Mathematical Theory of Computation,\u201d 1961 5 Page 6 The meaning of a program is defined by its effect on the \u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Double rewriting for equivalential reasoning in ACL2\n", "abstract": " Several users have had problems using equivalence-based rewriting in ACL2 because the ACL2 rewriter caches its results. We describe this problem in some detail, together with a partial solution first implemented in ACL2 Version 2.9. 4. This partial solution consists of a new primitive, double--rewrite, together with a new warning to suggest possible use of this primitive.", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Maintaining the ACL2 Theorem Proving System\n", "abstract": " What sorts of challenges do we face in making our theorem prover useful in practice?", "num_citations": "1\n", "authors": ["1589"]}
{"title": "RAC\u00cb \u00c5\n", "abstract": " This paper sketches the state of the art in the application of mechanical theorem provers to the verification of commercial computer hardware and software. While the paper focuses on the theorem proving system ACL2, developed by the two authors, it references much related work in formal methods. The paper is intended to satisfy the curiosity of readers interested in logic and artificial intelligence as to the role of mechanized theorem proving in hardware and software design today. In addition, it points out some of the key research topics in the area. These topics transcend any one particular theorem proving system.", "num_citations": "1\n", "authors": ["1589"]}
{"title": "What's new in ACL2\n", "abstract": " What's New in ACL2 Page 1 What's New in ACL2 April 8, 2002 Matt Kaufmann (Advanced Micro Devices, Inc.) J Strother Moore (The University of Texas) 1 Page 2 b Introduction c We summarize these documentation topics (and subtopics): NOTE-2-6 (changes in Version 2.6) NOTE-2-7 (changes in Version 2.7, under development) GOAL: Call attention to new features of ACL2 and changes in behavior. If time permits then we may elaborate on a few of these features. To sign up for mailing lists, follow the \\Useful Addresses\" link from the ACL2 home page, http://www.cs.utexas.edu/users/moore/acl2/. Note: The new list acl2-help@lists.cc.utexas.edu is a great place for ACL2 usage questions. 2 Page 3 In this talk we reference the following people for their help, ranging from bringing problems to our attention to coming up with the idea and the initial implementation. See documentation topics for details. Michael \u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Machines reasoning about machines\n", "abstract": " Machines Reasoning about Machines Page 1 Machines Reasoning about Machines A Personal Perspective J Strother Moore Department of Computer Sciences University of Texas at Austin 1 Page 2 Is McCarthy\u2019s Dream Practical? Instead of debugging a program, one should prove that it meets its specifications, and this proof should be checked by a computer program. \u2014 John McCarthy, \u201cA Basis for a Mathematical Theory of Computation,\u201d 1961 2 Page 3 Boyer-Moore Project Kaufmann 1960 1970 1980 1990 2000 McCarthy\u2019s \u2018\u2018Theory of Computation\u2019\u2019 ACL2 Edinburgh Pure Lisp Theorem Prover A Computational Logic NQTHM Boyer Moore 3 Page 4 Theorems Proved applications 1960 1970 1980 1990 2000 simple list processing academic math and cs commercial 4 Page 5 Topics We\u2019ll Touch Upon Progressively more challenging applications. How theorem provers work. What can be done with them today. \u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "ACL2 essentials\n", "abstract": " We present here a brief, and very informal, introduction to ACL2. Our purpose is to provide just enough ACL2 background to support reading the ACL2 formulas displayed in this book's case studies. The reader interested in learning more about ACL2 is invited to take a look at the companion volume, [58], and to visit the ACL2 home page (see page 4).", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Proving properties of java threads\n", "abstract": " We describe a mechanically checked proof of a property of a system of small bytecoded programs involving an unbounded number of threads and synchronization via monitors. The bytecode programming language we study is a subset of that for the Java Virtual Machine. The formal semantics of the subset is given by an operational model expressed in ACL2, a Lisp-based logic of recursive functions. Our proofs are checked with the ACL2 theorem prover. The proof involves reasoning about arithmetic, conditionals, infinite loops, the creation and modification of instance objects in the heap, including threads, the inheritance of fields from superclasses, pointer chasing and smashing, the invocation of instance methods (and the concomitant dynamic method resolution), use of the start method on thread objects, the use of monitors to attain synchronization between threads, and consideration of all possible interleavings (at the level of atomic bytecode instructions with a sequentially consistent memory model) over an unbounded number of threads. Readers familiar with monitor-based proofs of mutual exclusion, will recognize our proof as fairly classical. The novelty here comes from (i) the complexity of the individual operations on the machine,(ii) the dependencies between threads, heap objects, and synchronization,(iii) bytecode-level interleaving,(iv) the unbounded number of threads, and (v) and proof engineering permitting \u201cautomatic\u201d mechanical verification. We discuss these issues. The problem posed here is also put forth as a benchmark against which to measure other approaches to formally proving properties of multi-threaded Java programs.", "num_citations": "1\n", "authors": ["1589"]}
{"title": "POSITION PAPER: Should We Begin a Standardization Process for Interface Logics?\n", "abstract": " This paper is a companion paper to [1]. In that paper we argue against so-called interface logics for the verification of systems, and present an alternative approach that has already enjoyed considerable success. In this document we raise concerns about the use of interface logics even for the verification of software or hardware whose scale is smaller than what one might normally call \u2018\u2018systems.\u2019\u2019We believe that it important for us to raise these concerns. There has recently been some considerable discussion of \u2018\u2018interface logics\u2019\u2019in the verification community [2, 3]. Our impression is that there could be pressure forthcoming at some point to standardize one or more interface logics. We have chosen to air our concerns here at this time in order to head off such pressure.", "num_citations": "1\n", "authors": ["1589"]}
{"title": "A second generation verification environment\n", "abstract": " A second generation verification environment Page 1 o a j . a) ,.3 \u2022 a 4 \" a > 5 0 a) p .a a) o \u2022 -0 aa3H aa. > \u2022 a 3 p V q p .~ O cd v C a d a) q a. 7 ca d .5'' x a) U q q co N w O -d ) p a 'a,- . 2 d a C~. N cd \u2022w 0\u2022 ao a.) cl a J \u2022(, LH >, 0 a) V a \u2022 T vi a U C - q o o v q a 2 2 ti p 0 0 .q a \u2022 d - Q o cmo \u2022 a aa 0. '0 cd o q 0a p L\u20220 ~,,.. a' q +~ c' \u2022 0 C 0, \u2022 a) 2 a o a O a)\u2022 ' dad 0 \u2022 q a) . 2 a) \u2022 \"!n a>' U . a a a \" T a .., 3 a 3 w '-0 _0 a\u2014 0 a) O > , . - v 5 p c - d O at \u2022 , a C a, \u2022 a) C ) oa A oo a 3 o aa > b >po \u2022 ap > a ho a) cT O w q 0\u2022 3 a ) \u2022 ho >0 a)? o a a \u2022 4 5 + o v) a) \u2022 > 0. a)a> > \u2022\u2022d a a) <I 7 to a) 7, f- ao \u2022 a, a) > 3a)va) u) d\u2022o> > o V q \u25aa oA a) a a . C7 co cd a) a) 1>3 \u2022 a 3 pa N' d _ y _0 __> q q C \u2022 \u2022ooaa F .0V a o 5 i 0\u2022 0 0 0 00 hi) OO cd +~ OL 5 a) \u2022 LU 5 q 2 a) .0 A_, \u2022 2 o ano\u2022 ~0 o oo\u2022o b > LL 0 3 \u2022\u20223 a 0 .5 p a) 3 -5 \u2022 a) 7 as 'E \u2022 0, 0 .5' 5 \u2022 a) O 0 a. .a cV (y ,' p \u2022 d d L 'a' 3 to a , \" va \u2022 3 3 '\u2022 a' L ao oAU v O p -d . ai 4, N a)C \u2022O \u2022 U b 0 13.0 a) a 0 y \u2022~ . a .0 ,.\u201e \u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Automotive fuels today and tomorrow\n", "abstract": " The efficiency is assessed of various energy alternatives to petroleum for automotive fuels including coal, oil shale, organic waste products and biomass. The energy efficiency of various resource conversion to end-use paths is examined. Such systems comprise: extraction, upgrading, or collection of the raw resource; conversion of the crude to a usable transportation fuel; distribution of the fuel; and likely uses of a particular fuel. New technology in engine design is discussed in the context of fuel compatibility, comparative evaluations are made between diesel, spark ignition and electric engines. The authors conclude that substituting light distillates for gasoline will reduce energy use. However, the production of gasoline and light distillates from any resource is interdependent; the production of one implies the production of another. Therefore, a multifuel scenario is most likely. 26 references.", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Program verification prize\n", "abstract": " Robert S. Boyer and J Strother Moore: Recipients of the 1983 John McCarthy Prize for Work in Program Verificatio n An anonymous donor has established the John McCarthy Prize, to be awarded every two years fo r outstanding work in Program Verification. The prize, is intended to recognize outstanding curren t work--not necessarily work of a milestone value. This first award is for work carried out an d published during the past 5 years.The committee has decided to give the initial award to Robert S. Boyer and J Strother Moore fo r work carried out at the following institutions: University of Edinburgh, SRI International, an d (currently) the University of Texas. Their main achievement is the development of an elegant logi c implemented in a very powerful theorem prover. Particularly noteworthy about the logic is the use of induction to express properties about the objects common to programs. Their theorem prover is\u00a0\u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "Experience in writing VCG systems\n", "abstract": " Bob Boyer and I have written many vcgs over the years and can, like the rest of us, toss off a vcg for a toy language of our own aesig n in an afternoon. However, the vcg for FORTRAN was a real challenge--not because it involved scientific research but because of the vast number of details to be learned and considered.Before discussing our experience further I would like to explain why we chose Fortran rather than some other language. Our main objective was to produce a verification system we could use to test our theorem-prover. But\" tension\" must exist to prove anything. For example, if one assumes anything one wants, it is meaningless to prove formal theorems. Similarly, if one is free to make up th e specifications of one's programming language there is not enough tension to know whether the proof of a given program is meaningful or not. More to the point in our case, such a situation would give us no\u00a0\u2026", "num_citations": "1\n", "authors": ["1589"]}
{"title": "A Grand Challenge Proposal for Formal Methods: A Veri\ufb01ed Stack\n", "abstract": " We propose a grand challenge for the formal methods community: build and mechanically verify a practical embedded system, from transistors to software. We propose that each group within the formal methods community design and verify, by the methods appropriate to that group, an embedded system of their choice. The point is not to have just one integrated formal method or just one veri\ufb01ed application, but to encourage groups to develop the techniques and methodologies necessary for system-level veri\ufb01cation.", "num_citations": "1\n", "authors": ["1589"]}