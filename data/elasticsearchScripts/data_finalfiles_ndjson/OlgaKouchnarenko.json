{"title": "Improvements on the Genet and Klay technique to automatically verify security protocols\n", "abstract": " Cryptographic protocols are widely used in open modern systems to assure secure communications. Generally, it is undecidable to certify whether a cryptographic protocol is safe or not. However the automatic verication of cryptographic protocols can be attempted using abstraction-based approximation techniques. This paper describes extensions to a specication method for cryptographic protocols based on tree automata. Additional expressiveness is added to enable the treatment of protocols that were out of reach of earlier work. New positive experimental results are presented.", "num_citations": "92\n", "authors": ["689"]}
{"title": "Using temporal logic for dynamic reconfigurations of components\n", "abstract": " Dynamic reconfigurations increase the availability and the reliability of component-based systems by allowing their architectures to evolve at run-time. This paper deals with the formal specification and verification of dynamic reconfigurations of those systems using architectural constraints and temporal logic patterns.             The proposals of the paper are applied to the Fractal component model. Given a Fractal reference implementation of a component-based system, we specify its dynamic reconfigurations using a temporal pattern logic for Fractal, called FTPL, characterizing the correct behaviour of the system under some architectural constraints. We study system reconfigurations on which we verify these requirements, in particular by reusing the FPath and FScript tools.", "num_citations": "54\n", "authors": ["689"]}
{"title": "Ready-simulation is not ready to express a modular refinement relation\n", "abstract": " The B method has been successfully used to specify many industrial applications by refinement. Previously, we proposed enriching the B event systems by formulating its dynamic properties in LTL. This enables us to combine model-checking with theorem-proving verification technologies. The model-checking of LTL formulae necessitates that the B event system semantics is a transition system. In this paper, we express the refinement relation by a relationship between transition systems. A result of our study shows that this relation is a special kind of simulation allowing us to exploit the partition of the reachable state space for a modular verification of LTL formulae. The results of the paper allow us to build a bridge between the above view of the refinement and the notions of observability characterized as simulation relations by Milner, van Glabbeek, Bloom and others. The refinement relation we define in\u00a0\u2026", "num_citations": "52\n", "authors": ["689"]}
{"title": "Automatic verification of security protocols using approximations\n", "abstract": " Security protocols are widely used in open modern networks to ensure safe communications. It is now recognized that formal analysis can provide the level of assurance required by both developers and users of the protocols. Unfortunately it is generally undecidable to certify whether a protocol is safe or not. However the automatic verification of security protocols can be attempted using abstraction-based approximation. For this purpose, tree automata approximations were introduced by Genet and Klay in 2000. In this paper, we propose an extension of their techniques making the approach efficiently automatic. Our contribution has been implementing in the TA4SP tool with a high level specification language as input format, providing positive practical results on industrial security protocols.", "num_citations": "41\n", "authors": ["689"]}
{"title": "Adapting component-based systems at runtime via policies with temporal patterns\n", "abstract": " Dynamic reconfiguration allows adding or removing components of component-based systems without incurring any system downtime. To satisfy specific requirements, adaptation policies provide the means to dynamically reconfigure the systems in relation to (events in) their environment. This paper extends event-based adaptation policies by integrating temporal requirements into them. The challenge is to reconfigure component-based systems at runtime while considering both their functional and non-functional requirements. We illustrate our theoretical contributions with an example of an autonomous vehicle location system. An implementation using the Fractal component model constitutes a practical contribution. It enables dynamic reconfigurations guided by either enforcement or reflection adaptation policies.", "num_citations": "39\n", "authors": ["689"]}
{"title": "Combining proof and model-checking to validate reconfigurable architectures\n", "abstract": " This paper deals with the formal specification and verification of dynamic reconfigurations of component-based systems. To validate such complex systems, there is a need to check model consistency and also to ensure that dynamic reconfigurations satisfy architectural and integrity constraints, invariants, and also temporal constraints over (re)configuration sequences. As architectural constraints involve first-order formulae, and a behavioural semantics of reconfigurations gives rise to infinite state systems, we propose to associate proof and model-checking within the well-established B method, to support the modelling of such systems and the (partial-)validation of their dynamic reconfigurations. The objective of the paper is twofold. First, given a hierarchical B model of component-based architectures, we validate it by proving its consistency. Second, given linear temporal logic formulae expressing the desirable\u00a0\u2026", "num_citations": "35\n", "authors": ["689"]}
{"title": "Finer is better: Abstraction refinement for rewriting approximations\n", "abstract": " Term rewriting systems are now commonly used as a modeling language for programs or systems. On those rewriting based models, reachability analysis, i.e. proving or disproving that a given term is reachable from a set of input terms, provides an efficient verification technique. For disproving reachability (i.e. proving non reachability of a term) on non terminating and non confluent rewriting models, Knuth-Bendix completion and other usual rewriting techniques do not apply. Using the tree automaton completion technique, it has been shown that the non reachability of a term t can be shown by computing an over-approximation of the set of reachable terms and prove that t is not in the over-approximation. However, when the term t is in the approximation, nothing can be said.             In this paper, we improve this approach as follows: given a term t, we try to compute an over-approximation which does not\u00a0\u2026", "num_citations": "29\n", "authors": ["689"]}
{"title": "Using CSP|| B components: application to a platoon of vehicles\n", "abstract": " This paper presents an experience report on the specification and the validation of a real case study in the context of the industrial CRISTAL project. The case study concerns a platoon of a new type of urban vehicles with new functionalities and services. It is specified using the combination, named CSP||B, of two well-known formal methods, and validated using the corresponding support tools. This large \u2013 both distributed and embedded \u2013 system typically corresponds to a multi-level composition of components that have to cooperate. We identify some lessons learned, showing how to develop and verify the specification and check some properties in a compositional way using theoretical results and support tools to validate this complex system.", "num_citations": "27\n", "authors": ["689"]}
{"title": "Refinement Preserves PLTL Properties\n", "abstract": " We are interested in verifying dynamic properties of reactive systems. The reactive systems are specified by B event systems in a refinement development. We use labelled transition systems to express the semantics of these event systems on which we define a refinement relation. The main advantage is that the user does not need to express a variant and a loop invariant to obtain automatic proofs of dynamic properties, at least for finite state event systems. Another advantage is that the model-checking is done on an abstraction with few states and the property is preserved in the following refinements of the system. The originality of this work concerns the proof that this refinement relation preserves the properties expressed with propositional linear temporal logic.", "num_citations": "27\n", "authors": ["689"]}
{"title": "Handling algebraic properties in automatic analysis of security protocols\n", "abstract": " In this paper we extend the approximation based theoretical framework in which the security problem \u2013 secrecy preservation against an intruder \u2013 may be semi-decided through a reachability verification.               We explain how to cope with algebraic properties for an automatic approximation-based analysis of security protocols. We prove that if the initial knowledge of the intruder is a regular tree language, then the security problem may by semi-decided for protocols using cryptographic primitives with algebraic properties. More precisely, an automatically generated approximation function enables us 1) an automatic normalization of transitions, and 2) an automatic completion procedure. The main advantage of our approach is that the approximation function makes it possible to verify security protocols with an arbitrary number of sessions.               The concepts are illustrated on an example of the view-only\u00a0\u2026", "num_citations": "23\n", "authors": ["689"]}
{"title": "Refinement and verification of synchronized component-based systems\n", "abstract": " This article deals with specification, refinement and verification approaches for systems designed with synchronized components. First of all, we define a synchronized composition of components. Transition systems are used to specify or/and to model synchronized component-based systems. Second, we give refinement semantics for these component-based systems before proposing a method to verify the refinement of a whole system from the weak refinement of its components. We also present SynCo: a tool we are implementing using our method. Third, a compositional way to verify safety properties is proposed: the unreachability of a (set of) state(s) can be efficiently ensured for a synchronized component-based system.               The different aspects of our work are illustrated on an industrial example of a wind-screen wipers system composed of a control lever, a rain sensor and two (left and right) wind\u00a0\u2026", "num_citations": "23\n", "authors": ["689"]}
{"title": "Automatic approximation for the verification of cryptographic protocols\n", "abstract": " This paper presents an approximation function developed for the verification of cryptographic protocols. The main properties of this approximation are that it can be build automatically and its computation is guaranteed to terminate unlike Genet and Klay\u2019s algorithm. This approximation has been used for the verification of the Needham-Schroeder, Otway-Rees and Woo Lam protocols. To be more precise, the approximation allows us to check secrecy and authenticity properties of the protocols.", "num_citations": "23\n", "authors": ["689"]}
{"title": "Synchronized parallel composition of event systems in B\n", "abstract": " A large system typically is or can be decomposed as a composition of components. Usually, these components have to cooperate so, their composition is a synchronized parallel composition. Components are often reactive systems. In the B method, each component is an event system. Then, two development paradigms \u2014 refinement and component composition \u2014 can be used. To provide both paradigms we have a compositionality result of a synchronized parallel composition with respect to refinement. We make use of this result to get an eficient approach to verify the refinement of a synchronized parallel composition between components. Therefore, our proposal allows introducing a second development paradigm in B, the component paradigm.", "num_citations": "22\n", "authors": ["689"]}
{"title": "A model for recursive-parallel programs.\n", "abstract": " We de ne a formal model for a class of recursive-parallel systems with speci c invocation and synchronization primitives. This original model is in nite-state but can still be analyzed successfully using the\\well-structured transition systems\" approach.", "num_citations": "22\n", "authors": ["689"]}
{"title": "Towards validating a platoon of cristal vehicles using csp|| b\n", "abstract": " The so-called platooning problem consists in making autonomous vehicles move in a convoy. It crosses several domains: distributed systems, embedded systems, multi-agent systems and critical systems. We thus propose to use the combination named CSP||B of two well-known formal methods to assess and verify properties of this complex system. To that end we make use of previous theoretical results on CSP||B. We also illustrate how this methodology spans the multiple composition levels of the resulting model.", "num_citations": "20\n", "authors": ["689"]}
{"title": "Approximation based tree regular model checking\n", "abstract": " This paper addresses the following general problem of tree regular model-checking: decide whether $\\R^*(L)\\cap L_p =\\emptyset$ where $\\R^*$ is the reflexive and transitive closure of a successor relation induced by a term rewriting system $\\R$, and  and  are both regular tree languages. We develop an automatic approximation-based technique to handle this -- undecidable in general -- problem in most practical cases, extending a recent work by Feuillade, Genet and Viet Triem Tong. We also make this approach fully automatic for practical validation of security protocols.", "num_citations": "20\n", "authors": ["689"]}
{"title": "Verification of class liveness properties with java modelling language\n", "abstract": " Static checking is key for the security of software components. As a component model, this paper considers a Java class enriched with annotations from the Java modelling language (JML). It defines a formal execution semantics for repetitive method invocations from this annotated class, called the class in isolation semantics. Afterwards, a pattern of liveness properties is defined, together with its formal semantics, providing a foundation for both static and runtime checking. This pattern is then inscribed in a complete language of temporal properties, called Java temporal pattern language, extending JML. The authors particularly address the verification of liveness properties by automatically translating the temporal properties into JML annotations for this class. This automatic translation is implemented in a tool called JML annotation generator. Correctness of the generated annotations ensures that the temporal\u00a0\u2026", "num_citations": "19\n", "authors": ["689"]}
{"title": "Reformulate dynamic properties during B refinement and forget variants and loop invariants\n", "abstract": " We propose a way to introduce dynamic properties into a B refinement design which differs from the approach used by J.R. Abrial and L. Mussat. First, the properties are expressed in the Propositional Linear Temporal Logic PLTL. Second, the user directs the evolution of properties through the refinement, so that a property P expressed by a formula F                      1 in the abstract system, is expressed again by a formula F                      2 in the refined system. Third, the verification combines proof and model-checking. In particular, F                      1 is model-checked, and, then, to ensure F                      2 it suffices to prove some propositions depending on the shapes of F                      1 and F                      2. In this paper, we show how to obtain these \u201csufficient propositions\u201d from a refinement relation and the semantics of PLTL formulae. The main advantage is that the user does not need a variant or a loop invariant to\u00a0\u2026", "num_citations": "17\n", "authors": ["689"]}
{"title": "Component simulation-based substitutivity managing QoS and composition issues\n", "abstract": " Several scientific bottlenecks have been identified in existing component-based approaches. Among them, we focus on the identification of a relevant abstraction for the component expression and verification of properties like substitutivity: when is it possible to formally accept or reject the substitution of a component in a composition? This paper suggests integer weighted automata to tackle this problem when considering a new factor \u2014 Quality of Service (QoS). Four notions of simulation-based substitutivity managing QoS aspects are proposed, and related complexity issues on integer weighted automata are investigated. Furthermore, the paper defines composition operators: sequential, strict-sequential and parallel compositions, bringing path costs into the analysis. New results on the compatibility of proposed substitutivity notions w.r.t. sequential and parallel composition operators are established.", "num_citations": "16\n", "authors": ["689"]}
{"title": "Reformulation: a Way to Combine Dynamic Properties and B Refinement\n", "abstract": " We are interested in verifying dynamic properties of reactive systems. The reactive systems are specified by B event systems in a refinement development. The refinement allows us to combine proof and model-checking verification techniques in a novel way. Most of the PLTL dynamic properties are preserved by refinement, but in our approach, the user can also express how a property evolves during the refinement. The preservation of the abstract property, expressed by a PLTL formula F                      1, is used as an assumption for proving a PLTL formula F                      2 which expresses an enriched property in the refined system. Formula F                      1 is verified by model-checking on the abstract system. So, to verify the enriched formula F                      2, it is enough to prove some propositions depending on the respective patterns followed by F                      1 and F                      2. In this paper, we show how\u00a0\u2026", "num_citations": "15\n", "authors": ["689"]}
{"title": "Intensional approaches for symbolic methods\n", "abstract": " We present a behavioral model for discrete event systems based on an intentional formalism, as a possible approach within the broader trend towards rich symbolic representations in verification. We define Intensional Labeled Transition Systems with associated combinators of parallel composition and event hiding, and we propose symbolic bisimulation to handle strong bisimulation intentionally. Further on, we explain how the methodology has been developed for the synchronous language Signal, via the verification tool Sigali.", "num_citations": "14\n", "authors": ["689"]}
{"title": "A rule-based system for automatic decidability and combinability\n", "abstract": " This paper deals with decision procedures specified by using a superposition calculus which is an inference system at the core of all equational theorem provers. This calculus is refutation complete: it provides a semi-decision procedure that halts on unsatisfiable inputs but may diverge on satisfiable ones. Fortunately, it may also terminate for some theories of interest in verification, and thus it becomes a decision procedure. To reason on the superposition calculus, a schematic superposition calculus has been developed to build the schematic form of the saturations allowing to automatically prove decidability of single theories and of their combinations.This paper presents a rule-based logical framework and a tool implementing a complete many-sorted schematic superposition calculus for arbitrary theories. By providing results for unit theories, arbitrary theories, and also for theories with counting operators, we show\u00a0\u2026", "num_citations": "13\n", "authors": ["689"]}
{"title": "Tree automata for detecting attacks on protocols with algebraic cryptographic primitives\n", "abstract": " This paper extends a rewriting approximations-based theoretical framework in which the security problem \u2013 secrecy preservation against an active intruder \u2013 may be semi-decided through a reachability analysis. In a recent paper, we have shown how to semi-decide whether a security protocol using algebraic properties of cryptographic primitives is safe. In this paper, we investigate the dual - insecurity - problem: we explain how to semi-decide whether a protocol using cryptographic primitive algebraic properties is unsafe. This improvement offers us to draw automatically a complete diagnostic of a security protocol with an unbounded number of sessions. Furthermore, our approach is supported by the tool TA4SP successfully applied for analysing the NSPK-xor protocol and the Diffie-Hellman protocol.", "num_citations": "13\n", "authors": ["689"]}
{"title": "Verification of liveness properties with JML\n", "abstract": " This paper proposes a way to verify liveness properties in an extension of JML. The verification is divided into two subtasks: (1) generation of appropriate JML annotations that allow to verify that the class under consideration respects the liveness property, and (2) showing that the environment preserves the liveness properties by proving a refinement. For the generation of appropriate JML annotations, we require that the liveness properties are extended with a variant and invariant (conform variants and invariants to show termination of loops). We then show that under certain assumptions on the environment, we can prove the satisfaction of the liveness property. The second subtask then boils down to showing that the environment in fact respects these assumptions. The method is illustrated by an example.", "num_citations": "13\n", "authors": ["689"]}
{"title": "Decentralised evaluation of temporal patterns over component-based systems at runtime\n", "abstract": " Self-adaptation allows systems to modify their structure and/or their behaviour depending on the environment and the system itself. Since reconfigurations must not happen at any but in suitable circumstances, guiding and controlling dynamic reconfigurations at runtime is an important issue. This paper contributes to two essential topics of the self-adaptation\u2014a runtime temporal properties evaluation, and a decentralization of control loops. It extends the work on the adaptation of component-based systems at runtime via policies with temporal patterns by providings (a) specific progressive semantics of temporal patterns and (b) a decentralised method which is suitable to deal with temporal patterns of component-based systems at runtime. The implementation with the GROOVE tool constitutes a practical contribution.", "num_citations": "12\n", "authors": ["689"]}
{"title": "Runtime verification of temporal patterns for dynamic reconfigurations of components\n", "abstract": " Dynamic reconfigurations increase the availability and the reliability of component-based systems by allowing their architectures to evolve at runtime. Recently we have proposed a temporal pattern logic, called FTPL, to characterize the correct reconfigurations of component-based systems under some temporal and architectural constraints.             As component-based architectures evolve at runtime, there is a need to check these FTPL constraints on the fly, even if only a partial information is expected. Firstly, given a generic component-based model, we review FTPL from a runtime verification point of view. To this end we introduce a new four-valued logic, called RV-FTPL (Runtime Verification for FTPL), characterizing the \u201cpotential\u201d (un)satisfiability of the architectural constraints in addition to the basic FTPL semantics. Potential true and potential false values are chosen whenever an observed behaviour\u00a0\u2026", "num_citations": "12\n", "authors": ["689"]}
{"title": "How to handle qos aspects in web services substitutivity verification\n", "abstract": " Web services (WSs) are used more and more as components of distributed applications with a goal to resolve complex tasks that simple services cannot. This use of WSs is connected to the emergence of languages like WS-BPEL which allows describing the external behaviour of WSs on top of the service interfaces. The use of WSs as components of distributed applications implies the possibility to change a failing service for another which can do at least the same thinks as the replaced service. Different solutions have been proposed during the last years to check such properties, but, to our knowledge, none of them take QoS aspects into account. This paper introduces a set of tools and techniques for verifying WSs substitutivity while taking into account service costs such as the execution time of the different operations provided by WSs.", "num_citations": "12\n", "authors": ["689"]}
{"title": "Verifying invariants of component-based systems through refinement\n", "abstract": " In areas like manufacturing, communications, transportation or aerospace, the increasing size and complexity of reactive systems make their verification difficult to handle. Compositional reasoning is a way to master this problem. In this paper, we propose an approach based on a constraint synchronized product to specify and to verify such systems. This approach supports a compositional refinement for both labelled transition systems and their composition. In this framework, we show how to verify local and global invariance properties during a refinement verification. Thus, these properties are preserved through refinement.               The different aspects of our work are illustrated on the example of a communication protocol between an integrated chip card and a reader interface device.", "num_citations": "11\n", "authors": ["689"]}
{"title": "Event-based adaptation policies for Fractal components\n", "abstract": " Component-based development is a commonly used technique to build complex systems. In order to satisfy specific requirements, adaptation policies provide a solution to dynamically reconfigure the component model with relation to its environment. This paper is dedicated to Fractal components assembling with a special emphasis on their reconfiguration. We introduce event-based adaptation policies to reconfigure Fractal components. The challenge is to build trustworthy systems and to simulate their executions when considering both functional and non-functional requirements. The contributions are illustrated on an example of an autonomous vehicle location system. Implementation details are given.", "num_citations": "9\n", "authors": ["689"]}
{"title": "Handling non left-linear rules when completing tree automata\n", "abstract": " This paper addresses the following general problem of tree regular model-checking: decide whether  where  is the reflexive and transitive closure of a successor relation induced by a term rewriting system , and  and  are both regular tree languages. We develop an automatic approximation-based technique to handle this \u2013 undecidable in general \u2013 problem in the case when term rewriting system rules are non left-linear.", "num_citations": "9\n", "authors": ["689"]}
{"title": "B 2007: Formal Specification and Development in B: 7th International Conference of B Users, Besancon, France, January 7-19, 2007, Proceedings\n", "abstract": " TheseproceedingsrecordthepaperspresentedattheSeventhInternationalC-ference of B Users (B 2007), held in the city of Besan \u0327 con in the east of France. This conference was built on the success of the previous six conferences in this series, B 1996, held at the University of Nantes, France; B 1998, held at the University of Montpellier, France; ZB 2000, held at the University of York, UK; ZB 2002, held at the University of Grenoble, France; ZB 2003, held at the U-versity of Turku, Finland; ZB 2005 held at the University of Surrey, Guildford, UK. B 2007 was held in January at the University of Franche-Comt \u0301 e, Besan \u0327 con, France, hosted by the Computer Science Department (LIFC). LIFC has always placed particular emphasis on the applicability of its research and its relati-ship with industrial partners. In this context, it created in 2003 a company called LEIRIOS Technologies, which produces an automatic test generator tool (LTG) frommodels described in the B speci? cationlanguage. Other members of LIFC work on extensions of the B method for specifying and verifying dynamic properties. All the submitted papers in these proceedings were peer reviewed by at least three reviewers drawn from the B committee, depending on the subject matter of the paper. The authorsof the papersforB 2007werefrom Australia, Canada, Finland, Germany, France, Switzerland, and the UK. The conference featured a rangeof contributions by distinguished invited speakers drawn from both ind-try and academia.", "num_citations": "9\n", "authors": ["689"]}
{"title": "When structural refinement of components keeps temporal properties over reconfigurations\n", "abstract": " Dynamic reconfigurations increase the availability and the reliability of component-based systems by allowing their architecture to evolve at runtime. Recently, a linear temporal pattern logic, called FTPL, has been defined to express desired\u2014architectural, event and temporal\u2014 properties over dynamic reconfigurations of component systems. This paper is dedicated to the preservation of the FTPL properties when refining components and introducing new reconfigurations. To this end, we use architectural reconfiguration models giving the semantics of component-based systems with reconfigurations, on which we define a new refinement relation. This relation combines: (i) a structural refinement which respects the component encapsulation within the architectures at two levels of refinement, and (ii) a behavioural refinement which links dynamic reconfigurations of a refined component-based system with their\u00a0\u2026", "num_citations": "8\n", "authors": ["689"]}
{"title": "Specifying generic Java programs: two case studies\n", "abstract": " This work investigates the question of modular specification of generic Java classes and methods. We propose extensions to the Krakatoa Modeling Language, a part of the Why platform for proving that a Java or C program is a correct implementation of some specification. The new constructs we propose for the specification of generic Java programs are presented through two significant examples: the specification of the generic method for sorting arrays which comes from the java. util. Arrays class in the Java API, and the specification of the java. util. HashMap class defining a generic hash map and its use for memoization. The key features are the introduction of parametricity both for types and for theories and an instantiation relation between theories. We discuss soundness conditions and their verification.", "num_citations": "8\n", "authors": ["689"]}
{"title": "Taged approximations for temporal properties model-checking\n", "abstract": " This paper investigates the use of tree automata with global equalities and disequalities (TAGED for short) in reachability analysis over term rewriting systems (TRSs). The reachability problem being in general undecidable on non terminating TRSs, we provide TAGED-based construction, and then design approximation-based semi-decision procedures to model-check useful temporal patterns on infinite state rewriting graphs. To show that the above TAGED-based construction can be effectively carried out, complexity analysis for rewriting TAGED-definable languages is given.", "num_citations": "8\n", "authors": ["689"]}
{"title": "Verifying modal workflow specifications using constraint solving\n", "abstract": " Nowadays workflows are extensively used by companies to improve organizational efficiency and productivity. This paper focuses on the verification of modal workflow specifications using constraint solving as a computational tool. Its main contribution consists in developing an innovative formal framework based on constraint systems to model executions of workflow Petri nets and their structural properties, as well as to verify their modal specifications. Finally, an implementation and promising experimental results constitute a practical contribution.", "num_citations": "7\n", "authors": ["689"]}
{"title": "A random testing approach using pushdown automata\n", "abstract": " Developing efficient and automatic testing techniques is one of the major challenges faced by the software validation community. Recent work by A. Denise et al. shows how to draw traces uniformly at random for testing large systems modelled by finite automata. Because finite automata are strong abstractions of systems, many test cases generated following this approach may be unconcretizable, that is, they do not correspond to any concrete execution of the system under test. In this paper, this problem is tackled by extending the approach to pushdown systems that can encode either a stack data structure or the call stack. The method is based on context\u2010free grammars and related algorithms, and relies on combinatorial techniques to guarantee the uniformity of generated traces. In addition, the combination of coverage criteria with random testing is investigated to benefit from both approaches for evaluating the\u00a0\u2026", "num_citations": "7\n", "authors": ["689"]}
{"title": "Random grammar-based testing for covering all non-terminals\n", "abstract": " In the context of software testing, generating complex data inputs is frequently performed using a grammar-based specification. For combinatorial reasons, an exhaustive generation of the data - of a given size - is practically impossible, and most approaches are either based on random techniques or on coverage criteria. In this paper, we show how to combine these two techniques by biasing the random generation in order to optimise the probability of satisfying a coverage criterion.", "num_citations": "7\n", "authors": ["689"]}
{"title": "Automatic decidability: A schematic calculus for theories with counting operators\n", "abstract": " Many verification problems can be reduced to a satisfiability problem modulo theories. For building satisfiability procedures the rewriting-based approach uses a general calculus for equational reasoning named paramodulation. Schematic paramodulation, in turn, provides means to reason on the derivations computed by paramodulation. Until now, schematic paramodulation was only studied for standard paramodulation. We present a schematic paramodulation calculus modulo a fragment of arithmetics, namely the theory of Integer Offsets. This new schematic calculus is used to prove the decidability of the satisfiability problem for some theories equipped with counting operators. We illustrate our theoretical contribution on theories representing extensions of classical data structures, eg, lists and records. An implementation within the rewriting-based Maude system constitutes a practical contribution. It enables automatic decidability proofs for theories of practical use.", "num_citations": "7\n", "authors": ["689"]}
{"title": "Specifying and proving a sorting algorithm\n", "abstract": " This work investigates the question of automaticity of algorithm proofs, through the typical example of a sorting algorithm. The first part introduces two specification languages for Java programs. In the second part one of them is used to specify a sorting algorithm by selection. The suggested specifications are enhanced until obtaining a complete solution by the current automated theorem provers. This report is a part of Elena Tushkanova's diploma project (equivalent to a master thesis) entitled \u201cModular Specification of Object Oriented Programs\u201d from the Yaroslavl State University, Russia, translated from Russian into English.", "num_citations": "7\n", "authors": ["689"]}
{"title": "JML-based Verification of Liveness Properties on a Class in Isolation\n", "abstract": " This paper proposes a way to verify temporal properties of a Java class in an extension of JML (Java Modeling Language) called JTPL (Java Temporal Pattern Language). We particularly address the verification of liveness properties by automatically translating the temporal properties into JML annotations for this class. This automatic translation is implemented in a tool called JAG (JML Annotation Generator). Correctness of the generated annotations ensures that the temporal property is established for the executions of the class in isolation.", "num_citations": "7\n", "authors": ["689"]}
{"title": "SynCo: a refinement analysis tool for synchronized component-based systems\n", "abstract": " We report on SynCo, a tool we have developped that implements a compositional analysis of the refinement of synchronized component-based systems. First, components are specified as labelled transition systems and their synchronization is given. Context-in components are automatically built. Second, SynCo analyses the weak refinement of the context-in components and concludes about the strict refinement of the whole system. While previous papers have described various features of the refinement relation, this paper presents the first description of SynCo.", "num_citations": "7\n", "authors": ["689"]}
{"title": "Component substitution through dynamic reconfigurations\n", "abstract": " Component substitution has numerous practical applications and constitutes an active research topic. This paper proposes to enrich an existing component-based framework--a model with dynamic reconfigurations making the system evolve--with a new reconfiguration operation which \"substitutes\" components by other components, and to study its impact on sequences of dynamic reconfigurations. Firstly, we define substitutability constraints which ensure the component encapsulation while performing reconfigurations by component substitutions. Then, we integrate them into a substitutability-based simulation to take these substituting reconfigurations into account on sequences of dynamic reconfigurations. Thirdly, as this new relation being in general undecidable for infinite-state systems, we propose a semi-algorithm to check it on the fly. Finally, we report on experimentations using the B tools to show the feasibility of the developed approach, and to illustrate the paper's proposals on an example of the HTTP server.", "num_citations": "6\n", "authors": ["689"]}
{"title": "Composition of services with constraints\n", "abstract": " Composition of Web services consists of the interleaving of the sequence of actions executed by the elementary services in accordance with a client specification. We model Web services as automata executing actions and also sending and receiving messages. This paper provides a theoretical study for three service composition problems, and in particular for the problem of computing a Boolean formula which exactly characterises the conditions required for services to answer the client's request. New complexity results are established for these problems within the framework of service composition with constraints.", "num_citations": "6\n", "authors": ["689"]}
{"title": "How to verify and exploit a refinement of component-based systems\n", "abstract": " In order to deal with the verification of large systems, compositional approaches postpone in part the problem of combinatorial explosion during model exploration. The purpose of the work we present in this paper is to establish a compositional framework in which the verification may proceed through a refinement-based specification and a component-based verification approaches.               First, a constraint synchronised product operator enables us an automated compositional verification of a component-based system refinement relation. Secondly, safety LTL properties of the whole system are checked from local safety LTL properties of its components. The main advantage of our specification and verification approaches is that LTL properties are preserved through composition and refinement.", "num_citations": "6\n", "authors": ["689"]}
{"title": "Test generation from event system abstractions to cover their states and transitions\n", "abstract": " Model-based testing of event systems can take advantage of considering abstractions rather than explicit models, for controlling their size. When abstracting still a test has to be a concrete connected and reachable event sequence. This paper presents a test generation method based on computing a reachable and connected under-approximation of the abstraction of an event system. We compute the under-approximation with concrete instances of the abstract transitions, that cover all the states and transitions of the predicatebased abstraction. We propose an algorithmic method that instantiates each of the abstract transitions, and maintains for widening it a frontier of concretely reached states. We present heuristics to favour the instances connectivity. The idea is to prolong whenever possible the already reached sequences of concrete transitions, and to parameterize the order in which the states and\u00a0\u2026", "num_citations": "5\n", "authors": ["689"]}
{"title": "Approximating event system abstractions by covering their states and transitions\n", "abstract": " In event systems, contrarily to sequential ones, the control flow is implicit. Consequently, their abstraction may give rise to disconnected and unreachable paths. This paper presents an algorithmic method for computing a reachable and connected under-approximation of the abstraction of a system specified as an event system. We compute the under-approximation with concrete instances of the abstract transitions, that cover all the states and transitions of the predicate-based abstraction. To be of interest, these concrete transitions have to be reachable and connected to each other. We propose an algorithmic method that instantiates each of the abstract transitions, with heuristics to favour their connectivity. The idea is to prolong whenever possible the already reached sequences of concrete transitions, and to parameterize the order in which the states and actions occur. The paper also reports on an\u00a0\u2026", "num_citations": "5\n", "authors": ["689"]}
{"title": "Reduction of workflow nets for generalised soundness verification\n", "abstract": " This paper proposes a reduction method to verify the generalised soundness of large workflows described as workflow nets\u2013a suited class of Petri nets. The proposed static analysis method is based on the application of six novel reduction transformations that transform a workflow net into a smaller one while preserving generalised soundness. The soundness of the method is proved. As practical contributions, this paper presents convincing experimental results obtained using a dedicated tool, developed to validate and demonstrate the effectiveness, efficiency and scalability of this method over a large set of industrial workflow nets.", "num_citations": "5\n", "authors": ["689"]}
{"title": "Workflow Nets Verification: SMT or CLP?\n", "abstract": " The design and the analysis of business processes commonly relies on workflow nets, a suited class of Petri nets. This paper evaluates and compares two resolution methods\u2014Satisfiability Modulo Theory (SMT) and Constraint Logic Programming (CLP)\u2014applied to the verification of modal specifications over workflow nets. Firstly, it provides a concise description of the verification methods based on constraint solving. Secondly, it presents the experimental protocol designed to evaluate and compare the scalability and efficiency of both resolution approaches. Thirdly, the paper reports on the obtained results and discusses the lessons learned from these experiments.", "num_citations": "5\n", "authors": ["689"]}
{"title": "Preserving opacity on interval Markov chains under simulation\n", "abstract": " Given a probabilistic transition system (PTS) A partially observed by an attacker, and an \u03c9-regular predicate \u03c6 over the traces of A, measuring the disclosure of the secret \u03c6 in A means computing the probability that an attacker who observes a run of A can ascertain that its trace belongs to \u03c6. We consider specifications given as Interval Markov Chains (IMCs), which are underspecified Markov chains where probabilities on edges are only required to belong to intervals. Scheduling an IMC S produces a concrete implementation as a PTS and we define the worst case disclosure of secret \u03c6 in S as the maximal disclosure of \u03c6 over all PTSs thus produced. We compute this value for a subclass of IMCs and we prove that simulation between specifications can only improve the opacity of implementations.", "num_citations": "5\n", "authors": ["689"]}
{"title": "On positive TAGED with a bounded number of constraints\n", "abstract": " Tree Automata With Global Equality Constraints (aka. positive TAGED, or TAGE) are a variety of Bottom-Up Tree Automata, with added expressive power. While there is interest in using this formalism to extend existing regular model-checking frameworks \u2013 built on vanilla tree automata \u2013 such a project can only be practical if the algorithmic complexity of common decision problems is kept tractable. Unfortunately, useful TAGE decision problems sport very high complexities: Membership is NP-complete, Emptiness and Finiteness are both ExpTime-complete, Universality and Inclusion are undecidable. It is well-known that restricting the kind of equality constraints can have a dramatic effect on complexity, as evidenced by Rigid Tree Automata. However, the influence of the number of constraints on complexity has yet to be examined. In this paper, we focus on three common decision problems: Emptiness\u00a0\u2026", "num_citations": "5\n", "authors": ["689"]}
{"title": "A rule-based framework for building superposition-based decision procedures\n", "abstract": " This paper deals with decision procedures specified as inference systems. Among them we focus on superposition-based decision procedures. The superposition calculus is a refutation-complete inference system at the core of all equational theorem provers. In general this calculus provides a semi-decision procedure that halts on unsatisfiable inputs but may diverge on satisfiable ones. Fortunately, it may also terminate for some theories of interest in verification, and thus it becomes a decision procedure. To reason on the superposition calculus, a schematic superposition calculus has been studied, for instance to automatically prove termination. This paper presents an implementation in Maude of these two inference systems. Thanks to this implementation we automatically derive termination of superposition for a couple of theories of interest in verification.", "num_citations": "5\n", "authors": ["689"]}
{"title": "Practical analysis framework for component systems with dynamic reconfigurations\n", "abstract": " Dynamic reconfigurations that modify the architecture of component-based systems without incurring any system downtime need to preserve the architectural consistency. In this context, we propose a reconfiguration model based on Hoare logic using sequences and (unlike most of the related work on reconfigurations) the alternative and the repetitive constructs.Using primitive reconfiguration operations as building blocks, this model takes advantage of the predicate-based semantics of programming language constructs and weakest preconditions to treat dynamic reconfigurations in a manner that preserves configuration consistency. Then, after enriching the model with interpreted configurations and reconfigurations in a consistency compatible manner, a conformance relation is exploited to validate component systems\u2019 implementations within the environment supporting the Fractal and FraSCAti\u00a0\u2026", "num_citations": "4\n", "authors": ["689"]}
{"title": "Random Generation of Positive TAGEDs wrt. the Emptiness Problem\n", "abstract": " Tree automata are a widely used formalism in Computer Science. Since their creation in the fifties, numerous more expressive extensions have been proposed. Unfortunately, the decision problems associated with these extensions are quite often undecidable or in prohibitive classes of algorithmic complexity (NP-complete or worse), and little work has gone into finding efficient heuristics for them. Beyond the inherent difficulty of those problems, a common hitch in this line of research is the experimental evaluation of new algorithms. As those extensions of tree automata have remained in chiefly theoretical spheres, there are no established testbeds from the \"real world\" against which to quantify the efficiency (or lack thereof) of new algorithms. Failing that, there is a need to generate suitable testbeds at random. Regrettably, there is little material in the literature regarding random generation of tree automata, and none at all regarding extensions such as Tree Automata with Global Equality and Disequality Constraints (TAGEDs). It should also be noted that what little material there is does not concern itself with the interest of the generated automata wrt. specific decision problems. In this report we present a scheme for random generation of positive TAGEDs, with a focus on making them interesting wrt. the Emptiness problem.", "num_citations": "4\n", "authors": ["689"]}
{"title": "Petri nets with may/must semantics\n", "abstract": " This two-volume book contains the Proceedings of XVIIIth Concurrency, Specification and Programming (CS P) Workshop. It is taking place from 28th to 30th September 2009 in Krak\u00f3w-Przegorza\u0142ly, some 6 km to the west of the centre of Krak\u00f3w, the famous old city in southern Poland. The Proceedings altogether contain 61 contributions. In accordance with the Call For Papers, they encompass topics roughly divided into two groups:", "num_citations": "4\n", "authors": ["689"]}
{"title": "Using acceleration to compute parameterized system refinement\n", "abstract": " In this paper, we present a verification approach for a class of parameterized systems. These systems are composed of an arbitrary number of similar processes. As in \\cite{abdulla99b} we represent the states by regular languages and the transitions by transducers over regular languages. If we can compute a symbolic model by acceleration of the actions, then we can also verify a refinement relation R between the symbolic models. We show that, under some conditions, if R is verified between two symbolic models, then refinement is verified between concrete parameterized systems. Then, we can take advantage the property (safety and PLTL properties) preservation by refinement for their verification.", "num_citations": "4\n", "authors": ["689"]}
{"title": "Mod eles formels pour les programmes r ecursifs-parall eles\n", "abstract": " R esum e Nous proposons un mod ele formel du parall elisme inspir e par le langage r ecursif-parall ele RPC. Cette mod elisation permet de valider la strat egie d'impl ementation de RPC. Plus g en eralement, il s' agit d'un mod ele original et nouveau pr esentant de bonnes propri et es de d ecidabilit e.", "num_citations": "4\n", "authors": ["689"]}
{"title": "An approximation-based approach for the random exploration of large models\n", "abstract": " System modeling is a classical approach to ensure their reliability since it is suitable both for a formal verification and for software testing techniques. In the context of model-based testing an approach combining random testing and coverage based testing has been recently introduced\u00a0[9]. However, this approach is not tractable on quite large models. In this paper we show how to use statistical approximations to make the approach work on larger models. Experimental results, on models of communicating protocols, are provided; they are very promising, both for the computation time and for the quality of the generated test suites.", "num_citations": "3\n", "authors": ["689"]}
{"title": "Opacity for linear constraint Markov chains\n", "abstract": " On a partially observed system, a secret \u03c6 is opaque if an observer cannot ascertain that its trace belongs to \u03c6. We consider specifications given as Constraint Markov Chains (CMC), which are underspecified Markov chains where probabilities on edges are required to belong to some set. The nondeterminism is resolved by a scheduler, and opacity on this model is defined as a worst case measure over all implementations obtained by scheduling. This measures the information obtained by a passive observer when the system is controlled by the smartest scheduler in coalition with the observer. When restricting to the subclass of Linear CMC, we compute (or approximate) this measure and prove that refinement of a specification can only improve opacity.", "num_citations": "3\n", "authors": ["689"]}
{"title": "Two under-approximation techniques for 3-modal abstraction coverage of event systems: Joint effort?\n", "abstract": " Model-based testing of event systems can take advantage of considering abstractions rather than explicit models, for controlling their size. A test is then a connected and reachable event sequence. This paper reports on experiments made when adapting for event systems two known under-approximation techniques of predicate tri-modal (may, must+, must-) abstractions. We first instantiate all the abstract may transitions, preferably as reachable instances. Second, we complete this under-approximation with instantiations of Ball chains, i.e. sequences in the shape of must-*may.must+* transitions, as such sequences are guaranteed to have connected instantiations. We present a backward symbolic instantiation algorithm for connecting these two under-approximations. We experimentally address the question of their complementarity. Surprisingly, our results show that Ball chains have not enhanced the coverage\u00a0\u2026", "num_citations": "3\n", "authors": ["689"]}
{"title": "Constraint solving for verifying modal specifications of workflow nets with data\n", "abstract": " For improving efficiency and productivity companies are used to work with workflows that allow them to manage the tasks and steps of business processes. Furthermore, modalities have been designed to allow loose specifications by indicating whether activities are necessary or admissible. This paper aims at verifying modal specifications of coloured workflows with data assigned to the tokens and modified by transitions. To this end, executions of coloured workflow nets are modelled using constraint systems, and constraint solving is used to verify modal specifications specifying necessary or admissible behaviours. An implementation supporting the proposed approach and promising experimental results on an issue tracking system constitute a practical contribution.", "num_citations": "3\n", "authors": ["689"]}
{"title": "Loops and overloops for tree walking automata\n", "abstract": " Tree Walking Automata (TWA) have lately received renewed interest thanks to their tight connection to XML. This paper introduces the notion of tree overloops, which is closely related to tree loops, and investigates the use of both for the following common operations on TWA: testing membership, transformation into a Bottom-Up Tree Automaton (BUTA), and testing emptiness. Notably, we argue that transformation into a BUTA is slightly less straightforward than was assumed, show that using overloops yields much smaller BUTA in the deterministic case, and provide a polynomial over-approximation of this construction which detects emptiness with surprising accuracy against randomly generated TWA.", "num_citations": "3\n", "authors": ["689"]}
{"title": "SAT solvers for queries over tree automata with constraints\n", "abstract": " Tree automata turned out to be a very convenient framework for modeling and proving properties on infinite systems like communication protocols, Java programs and also in the context of XML programming. Unfortunately, these works are not always supported by efficient verification and validation tools. This paper investigates the use of two SAT solvers --- MiniSat and picoSat --- to evaluate queries over tree automata with global equality and disequality constraints (TAGEDs for short). Unlike general tree automata, TAGEDs allow to express constraints useful for e.g., evaluating queries over XML documents, like 'in the document, two nodes do not have the same key'. These queries being based on the membership problem which is NP-complete for TAGEDs, we propose an efficient SAT encoding of the membership problem for TAGEDs and we show its correctness and soundness. The paper reports on the\u00a0\u2026", "num_citations": "3\n", "authors": ["689"]}
{"title": "How to tackle integer weighted automata positivity\n", "abstract": " This paper is dedicated to candidate abstractions to capture relevant aspects of the integer weighted automata. The expected effect of applying these abstractions is studied to build the deterministic reachability graphs allowing us to semi-decide the positivity problem on these automata. Moreover, the papers reports on the implementations and experimental results, and discusses other encodings.", "num_citations": "3\n", "authors": ["689"]}
{"title": "Handling left-quadratic rules when completing tree automata\n", "abstract": " This paper addresses the following general problem of tree regular model-checking: decide whether R\u2217(L)\u2229 L p=\u2205 where R\u2217 is the reflexive and transitive closure of a successor relation induced by a term rewriting system R, and L and L p are both regular tree languages. We develop an automatic approximation-based technique to handle this\u2013undecidable in general\u2013problem in the case when term rewriting system rules are left-quadratic. The most common practical case is handled this way.", "num_citations": "3\n", "authors": ["689"]}
{"title": "How to compute the refinement relation for parameterized systems\n", "abstract": " In this paper, we present a refinement verification for a class of parameterized systems. These systems are composed of an arbitrary number of similar processes. Following the approach by P. Abdulla et al., we represent the states by regular languages and the transitions by transducers over regular languages. If we can compute a symbolic model by acceleration of the actions, then we can also verify a refinement relation R between the symbolic models. We show that, under some conditions, if R is verified between two symbolic models, then refinement is verified between concrete parameterized systems. Then, we can take advantage the property (safety and PLTL properties) preservation by refinement for their verification.", "num_citations": "3\n", "authors": ["689"]}
{"title": "Comment limiter la sp\u00e9cification de l'\u00e9quit\u00e9 dans les syst\u00e8mes d'\u00e9v\u00e9nements B?\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "3\n", "authors": ["689"]}
{"title": "Assessing SMT and CLP approaches for workflow nets verification\n", "abstract": " In the actual business world, companies rely more and more on workflows to model the core of their business processes. In this context, the focus of workflow analysts is made on the verification of workflows specifications, in particular of modal specifications that allow the description of necessary or admissible behaviors. The design and the analysis of business processes commonly relies on workflow nets, a suited class of Petri nets. The goal of this paper is to evaluate and compare in a deep way two resolution methods\u2014satisfiability modulo theory and constraint logic programming\u2014applied to the verification of modal specifications over workflow nets. Firstly, it provides a concise description of the verification methods based on constraint solving. Secondly, it introduces the toolchain developed to automate the full verification process. Thirdly, it describes the experimental protocol designed to evaluate and\u00a0\u2026", "num_citations": "2\n", "authors": ["689"]}
{"title": "Under-approximation generation driven by relevance predicates and variants\n", "abstract": " In test generation, when computing a reachable concrete under-approximation of an event system\u2019s predicate abstraction, we aim at covering each reachable abstract transition with at least one reachable concrete instance. As this is in general undecidable, an algorithm must finitely instantiate the abstract transitions for it to terminate. The approach defended in this paper is to first concretely explore the abstract graph, while concretizing the abstract transitions met at most once. However, some abstract transitions would require that loops were taken previously for them to become reached. To this end, in a second phase, a test engineer guides the exploration by describing a relevance predicate able to travel such loops. We give hints on how to design and express a relevance predicate, and provide a method for automatically extracting a variant out of it. A relevance guided concretization algorithm is given\u00a0\u2026", "num_citations": "2\n", "authors": ["689"]}
{"title": "The emptiness problem for tree automata with at least one global disequality constraint is NP-hard\n", "abstract": " The model of tree automata with global equality and disequality constraints was introduced in 2007 by Filiot, Talbot and Tison, and extended in various ways since then. In this paper we show that if there is at least one disequality constraint, the emptiness problem is NP-hard.", "num_citations": "2\n", "authors": ["689"]}
{"title": "Probabilistic opacity in refinement-based modeling\n", "abstract": " Given a probabilistic transition system (PTS)  partially observed by an attacker, and an -regular predicate over the traces of , measuring the disclosure of the secret  in  means computing the probability that an attacker who observes a run of  can ascertain that its trace belongs to . In the context of refinement, we consider specifications given as Interval-valued Discrete Time Markov Chains (IDTMCs), which are underspecified Markov chains where probabilities on edges are only required to belong to intervals. Scheduling an IDTMC  produces a concrete implementation as a PTS and we define the worst case disclosure of secret  in  as the maximal disclosure of  over all PTSs thus produced. We compute this value for a subclass of IDTMCs and we prove that refinement can only improve the opacity of implementations.", "num_citations": "2\n", "authors": ["689"]}
{"title": "From linear temporal logic properties to rewrite propositions\n", "abstract": " In the regular model-checking framework, reachability analysis can be guided by temporal logic properties, for instance to achieve the counter example guided abstraction refinement (CEGAR) objectives. A way to perform this analysis is to translate a temporal logic formula expressed on maximal rewriting words into a \u201crewrite proposition\u201d \u2013 a propositional formula whose atoms are language comparisons, and then to generate semi-decision procedures based on (approximations of) the rewrite proposition. This approach has recently been studied using a nonautomatic translation method. The extent to which such a translation can be systematised needs to be investigated, as well as the applicability of approximated methods wherever no exact translation can be effected. This paper presents contributions to that effect: (1) we investigate suitable semantics for LTL on maximal rewriting words and their\u00a0\u2026", "num_citations": "2\n", "authors": ["689"]}
{"title": "TAGED approximations for veriying temporal patterns\n", "abstract": " This paper investigates the use of tree automata with global equalities and disequalities (TAGED for short) in reachability analysis over term rewriting systems (TRSs). The reachability problem being in general undecidable on non terminating TRSs, we provide TAGED-based construction, and then design approximation-based semi-decision procedures to model-check useful temporal patterns on infinite state rewriting graphs. To show that the above TAGED-based construction can be effectively carried out, complexity analysis for rewriting TAGED-definable languages is given.", "num_citations": "2\n", "authors": ["689"]}
{"title": "Online testing of dynamic reconfigurations wrt adaptation policies\n", "abstract": " Self-adaptation of complex systems is a very active domain of research with numerous application domains. Component systems are designed as sets of components that may reconfigure themselves according to adaptation policies, which describe needs for reconfiguration. In this context, an adaptation policy is designed as a set of rules that indicate, for a given set of configurations, which reconfiguration operations can be triggered, with fuzzy values representing their utility. The adaptation policy has to be faithfully implemented by the system, especially wrt the utility occurring in the rules, which are generally specified for optimizing some extra-functional properties (eg minimizing resource consumption).In order to validate adaptive systems' behaviour, this paper presents a model-based testing approach, which aims to generate large test suites in order to measure the occurrences of reconfigurations and compare\u00a0\u2026", "num_citations": "1\n", "authors": ["689"]}
{"title": "Component-Based Systems Reconfigurations Using Graph Transformations with GROOVE\n", "abstract": " Component-based systems permit standardisation and re-usability of code through the use of components. The architecture of component-based systems can be modified thanks to dynamic reconfigurations, which contribute to systems\u2019 (self-)adaptation by adding or removing components without incurring any system downtime. In this context, the present article describes a formal model for dynamic reconfigurations of component-based systems. It provides a way of expressing runtime reconfigurations of a system and proving their correctness according to a static invariant for consistency constraints and/or a user-provided post-condition. Guarded reconfigurations allow us to build reconfigurations based on primitive reconfiguration operations using sequences of reconfigurations and the alternative and the repetitive constructs, while preserving configuration consistency. A practical contribution consists of\u00a0\u2026", "num_citations": "1\n", "authors": ["689"]}
{"title": "Approximer des abstractions de syst\u00e8mes d'\u00e9v\u00e9nements en couvrant leurs \u00e9tats et leurs transitions\n", "abstract": " Dans les syst\u00e8mes \u00e9v\u00e9nementiels le flot de contr\u00f4le est implicite. Par cons\u00e9quent leur abstraction peut engendrer des traces d\u00e9connect\u00e9es et inatteignables depuis l'\u00e9tat initial. Cet article pr\u00e9sente une m\u00e9thode algorithmique permettant le calcul d'une sous-approximation connect\u00e9e et atteignable de l'abstraction d'un syst\u00e8me \u00e9v\u00e9nementiel. La sous-approximation est calcul\u00e9e avec des instances concr\u00e8tes des transitions abstraites d'une abstraction par pr\u00e9dicats, dans l'objectif d'en couvrir tous les \u00e9tats et toutes les transitions. Pour \u00eatre utilisables, ces transitions concr\u00e8tes doivent \u00eatre atteignables et connect\u00e9es les unes aux autres. Cet article propose une m\u00e9thode permettant d'instancier chaque transition abstraite \u00e0 l'aide d'heuristiques favorisant leur connectivit\u00e9. Cet article confirme l'int\u00e9r\u00eat de l'approche par des r\u00e9sultats exp\u00e9rimentaux comparant la m\u00e9thode sans heuristique et avec.", "num_citations": "1\n", "authors": ["689"]}
{"title": "Comparing clp (fd) and smt approaches applied to workflow nets verification\n", "abstract": " Cet  article  propose  une   \u00e9valuation  et  une  comparaison  de  deux m\u00e9thodes de r\u00e9solution de syst\u00e8mes de contraintes, SMT (Satisfiability Modulo Theory) et CSP (Constraint Satisfaction Problem), appliqu\u00e9es \u00e0 la v\u00e9rification de sp\u00e9cifications modales. Ce processus de v\u00e9rification vise \u00e0 garantir la conformit\u00e9 de processus m\u00e9tier, repr\u00e9sent\u00e9s sous la forme  de  r\u00e9seaux  de  Petri  de  type  Workflow,  vis-\u00e0-vis  de  comportements n\u00e9cessaires ou admissibles, mod\u00e9lis\u00e9s par des formules modales.", "num_citations": "1\n", "authors": ["689"]}
{"title": "Component-based systems reconfigurations using graph grammars\n", "abstract": " Dynamic reconfigurations can modify the architecture of component-based systems without incurring any system downtime. In this context, the main contribution of the present article is the establishment of correctness results proving component-based systems reconfigurations using graph grammars. New guarded reconfigurations allow us to build reconfigurations based on primitive reconfiguration operations using sequences of reconfigurations and the alternative and the repetitive constructs, while preserving configuration consistency. A practical contribution consists of the implementation of a component-based model using the GROOVE graph transformation tool. Then, after enriching the model with interpreted configurations and reconfigurations in a consistency compatible manner, a simulation relation is exploited to validate component systems\u2019 implementations. This sound implementation is illustrated on a\u00a0\u2026", "num_citations": "1\n", "authors": ["689"]}
{"title": "Automatic Decidability for Theories Modulo Integer Offsets\n", "abstract": " Many verification problems can be reduced to a satisfiability problem modulo theories. For building satisfiability procedures the rewriting-based approach uses a general calculus for equational reasoning named superposition. Schematic superposition, in turn, provides a mean to reason on the derivations computed by superposition. Until now, schematic superposition was only studied for standard superposition. We present a schematic superposition calculus modulo a fragment of arithmetics, namely the theory of Integer Offsets. This new schematic calculus is used to prove the decidability of the satisfiability problem for some theories extending Integer Offsets. We illustrate our theoretical contribution on theories representing extensions of classical data structures, e.g., lists and records. An implementation in the rewriting-based Maude system constitutes a practical contribution. It enables automatic decidability proofs for theories of practical use.", "num_citations": "1\n", "authors": ["689"]}
{"title": "Loops and overloops for tree-walking automata\n", "abstract": " Tree-Walking Automata (TWA) have lately received renewed interest thanks to their tight connection to XML. This paper introduces the notion of tree overloops, which is closely related to tree loops, and investigates the use of both for the following common operations on TWA: testing membership, transformation into a Bottom-Up Tree Automaton (BUTA), and testing emptiness. Notably, we argue that the transformation into a BUTA is slightly less straightforward than was previously assumed, show that using overloops yields much smaller BUTA in the deterministic case, and provide a polynomial over-approximation of this construction which detects emptiness with surprising accuracy against randomly generated TWA.", "num_citations": "1\n", "authors": ["689"]}
{"title": "Approximations par r\u00e9\u00e9criture pour deux probl\u00e8mes ind\u00e9cidables\n", "abstract": " Pour v\u00e9rifier des propri\u00e9t\u00e9s de s\u00fbret\u00e9 ou de (non-)atteignabilit\u00e9 par model-checking r\u00e9gulier, on se concentre sur une mod\u00e9lisation des configurations accessibles du syst\u00e8me par des langages r\u00e9guliers et des relations d'\u00e9volution par des syst\u00e8mes de r\u00e9\u00e9criture. Le probl\u00e8me d'atteignabilit\u00e9 est ind\u00e9cidable dans de nombreux formalismes, et l'approche g\u00e9n\u00e9rale consiste \u00e0 \u00e9tudier et/ou \u00e0 combiner des cas particuliers. Nous nous int\u00e9ressons \u00e0 l'approche par approximation pour semi-d\u00e9cider ce probl\u00e8me de v\u00e9rification. Dans ce papier, nous exploitons l'analyse d'atteignabilit\u00e9 pour deux probl\u00e8mes ind\u00e9cidables pour les machines de Turing : vacuit\u00e9 d'un langage et appartenance d'un mot \u00e0 un langage. Nous proposons une mod\u00e9lisation et montrons comment les approximations par r\u00e9\u00e9criture permettent de semi-d\u00e9cider ces probl\u00e8mes. Cette approche a \u00e9t\u00e9 implant\u00e9e et exp\u00e9riment\u00e9e.", "num_citations": "1\n", "authors": ["689"]}
{"title": "Modular specification of Java programs\n", "abstract": " This work investigates the question of modular specification of generic Java classes and methods. The first part introduces a specification language for Java programs. In the second part the language is used to specify an array sorting algorithm by selection. The third and the fourth parts define a syntax proposal for the specification a generic Java programs, through two examples. The former is the specification of the generic method for sorting arrays which comes in the java.util.Arrays class of the Java API. The latter is the specification of the java.util.HashMap class and its use for memoization.", "num_citations": "1\n", "authors": ["689"]}
{"title": "V\u00e9rifier automatiquement les protocoles de s\u00e9curit\u00e9\n", "abstract": " La d\u00e9marche qualit\u00e9/fiabilit\u00e9 n'est pas aussi exigeante en informatique que dans des domaines comme la m\u00e9canique. Toutefois dans des domaines tels que l\u2019a\u00e9rospatiale ou la s\u00e9curit\u00e9 de l\u2019information, la qualit\u00e9, la fiabilit\u00e9 et la s\u00e9curit\u00e9 priment dans tous les projets informatiques. Le projet europ\u00e9en AVISPA est d\u00e9di\u00e9 au d\u00e9veloppement de techniques de validation de protocoles de s\u00e9curit\u00e9 afin de les rendre disponibles simplement aux ing\u00e9nieurs d\u00e9veloppant ces protocoles. Le double enjeu \u00e9tait d'\u00eatre \u00e0 la fois performant dans cette validation et de mettre ces performances \u00e0 la port\u00e9e de non-sp\u00e9cialistes.", "num_citations": "1\n", "authors": ["689"]}
{"title": "Towards formalizing QoS of web services with weighted automata\n", "abstract": " Web services (WSs) are used more and more as components of distributed applications with a goal to resolve complex tasks that simple services cannot. This use of WSs is connected to the emergence of languages like WS-BPEL which allows describing the external behaviour of WSs on top of the service interfaces. The use of WSs as components of distributed applications implies the possibility to change a failing service for another which can do at least the same things as the replaced service. The composition issues are also of particular interest to WSs users. Different solutions have been proposed during the last years to check such properties, but, to our knowledge, none of them takes QoS aspects into account. This paper introduces underpinnings and a tool for verifying WSs substitutivity and well-formed composition while considering WSs costs such as the execution time of the different operations provided by WSs.", "num_citations": "1\n", "authors": ["689"]}
{"title": "Comparaison des approches SMT et CSP appliqu\u00e9esa la v\u00e9rification de r\u00e9seaux workflows\n", "abstract": " R\u00e9sum\u00e9 Cet article propose une \u00e9valuation et une comparaison de deux m\u00e9thodes de r\u00e9solution de systemes de contraintes, SMT (Satisfiability Modulo Theory) et CSP (Constraint Satisfaction Problem), appliqu\u00e9esa la v\u00e9rification de sp\u00e9cifications modales. Ce processus de v\u00e9rification visea garantir la conformit\u00e9 de processus m\u00e9tier, repr\u00e9sent\u00e9s sous la forme de r\u00e9seaux de Petri de type Workflow, vis-a-vis de comportements n\u00e9cessaires ou admissibles, mod\u00e9lis\u00e9s par des formules modales.", "num_citations": "1\n", "authors": ["689"]}