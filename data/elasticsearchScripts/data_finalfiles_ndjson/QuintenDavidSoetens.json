{"title": "Change-based FODA diagrams: bridging the gap between feature-oriented design and implementation\n", "abstract": " Feature Oriented Design Analysis (FODA) diagrams present the design of feature-oriented software applications. In some cases, however, the actual implementation of such an application does not correspond to the design that was set forward by the FODA diagram. Such discrepancies are referred to as the gap between design and implementation.", "num_citations": "8\n", "authors": ["938"]}
{"title": "Formalizing Refactorings Implemented in Eclipse\n", "abstract": " A development team of a software system is tasked with designing and implementing a product to meet the requirements of a client. When the product is finished the client puts the system to use. While the users work with the software, they note bugs that they encounter and they note features that they would like to see added to the system. These bug reports and feature requests are sent back to the development team which is now also charged with the maintenance of the system. The maintenance tasks include fixing bugs (corrective maintenance) and adding new features (perfective maintenance). When bugs are resolved and new functionalities are added to the system, a new version is released and put to use. All of this happens in iterations, and with each iteration adding new features to the system becomes increasingly harder. Indeed Lehman\u2019s laws [17] teach us that a system has to change for it to remain useful and as it evolves it will become more and more complex. So the system that was neatly designed and implemented in the beginning has gradually become a \u201cBig Ball Of Mud\u201d[9]. One of the ways we can counteract this design decay, is by refactoring the code. The eclipse IDE 1 is a very popular programming environment that offers a wide range of automatic refactorings to aid the developers in their refactoring needs. However there is little documentation available on these refactorings, let alone a formal specification. A formal specification for the refactorings in eclipse could prove to be very usefull and we therefor ask ourselves if it is feasible to formalise the refactorings that are implemented in eclipse.1 http://www. eclipse. org", "num_citations": "4\n", "authors": ["938"]}
{"title": "Change-Based Software Engineering: Using Reified Changes for Test Selection and Refactoring Reconstruction\n", "abstract": " Software evolution is inevitable. Indeed a software system needs to be constantly modified and updated, else it risks becoming less and less useful. Since change takes a leading role in software development, we consider changes as a central entity. Our approach is to consider changes as first class citizens in the software development process. As such a change becomes a tangible entity that we can analyse and manipulate. In recent years many researchers have gone down this road and have devised several applications in which the reification of changes proved beneficial including, but not limited to: replaying changes on a system to better understand its evolution; making developers aware of changes made by other developers; mining a set of changes for frequently occurring change patterns; and using those patterns to suggest or predict future changes. This thesis presents a complete overview of the state\u00a0\u2026", "num_citations": "1\n", "authors": ["938"]}