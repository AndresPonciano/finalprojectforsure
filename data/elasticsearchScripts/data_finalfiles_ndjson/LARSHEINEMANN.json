{"title": "Understanding API usage to support informed decision making in software maintenance\n", "abstract": " Reuse of third-party libraries promises significant productivity improvements in software development. However, dependencies on external libraries and their APIs also introduce risks to a project and impact strategic decisions during development and maintenance. Informed decision making therefore requires a thorough understanding of the extent and nature of dependencies on external APIs. As realistically sized applications are often heavily entangled with various external APIs, gaining this understanding is infeasible with manual inspections only. To address this, we present an automated approach to analyze the dependencies of software projects on external APIs. The approach is supported by a static analysis tool featuring a visualization of the analysis results. We evaluate the approach as well as the tooling on multiple open source Java systems.", "num_citations": "22\n", "authors": ["91"]}
{"title": "Hunting for smells in natural language tests\n", "abstract": " Tests are central artifacts of software systems and play a crucial role for software quality. In system testing, a lot of test execution is performed manually using tests in natural language. However, those test cases are often poorly written without best practices in mind. This leads to tests which are not maintainable, hard to understand and inefficient to execute. For source code and unit tests, so called code smells and test smells have been established as indicators to identify poorly written code. We apply the idea of smells to natural language tests by defining a set of common Natural Language Test Smells (NLTS). Furthermore, we report on an empirical study analyzing the extent in more than 2800 tests of seven industrial test suites.", "num_citations": "20\n", "authors": ["91"]}
{"title": "Integrating quality models and static analysis for comprehensive quality assessment\n", "abstract": " To assess the quality of software, two ingredients are available today:(1) quality models defining abstract quality characteristics and (2) code analysis tools providing a large variety of metrics. However, there exists a gap between these two worlds. The quality attributes defined in quality models are too abstract to be operationalized. On the other side, the aggregation of the results of static code analysis tools remains a challenge. We address these problems by defining a quality model based on an explicit meta-model. It allows to operationalize quality models by defining how metrics calculated by tools are aggregated. Furthermore, we propose a new approach for normalizing the results of rule-based code analysis tools, which uses the information on the structure of the source code in the quality model. We evaluate the quality model by providing tool support for both developing quality models and conducting\u00a0\u2026", "num_citations": "16\n", "authors": ["91"]}
{"title": "Evaluating a quality model for software product assessments-a case study\n", "abstract": " Background: Software quality models have been proposed as a means for describing the concept of quality. Most quality models take an abstract view on quality characteristics. Therefore, they are not able to integrate measurement tools and metrics for conducting quality assessments of real software systems. To solve this problem, we developed a quality meta-model defining the structure of quality models that are detailed enough to specify quality characteristics and their links to metrics and measurement tools. Aim: In this paper, we present our evaluation of this meta-model in terms of its usability for constructing quality models that are suitable for quality assessments of real software systems. Method: For conducting the study, we developed an initial \u201cproof-of-concept\u201d quality model on the basis of static code analysis tools. This quality model was used for conducting quality assessments of Java-based software systems. The results were analyzed regarding two criteria:(1) the diversification provided by the results and (2) the congruence of the results with an independently conducted expert-based evaluation of the systems. Results: While the difference in the assessment results between the various systems is rather small, a correlation with the expert evaluation could be proven. Furthermore, the study provided useful insights for further work and improvements. Conclusions: We conclude that quality models based on the Quamoco meta-model are, in principle, capable of being operationalized for the automated quality assessment of software systems.", "num_citations": "10\n", "authors": ["91"]}
{"title": "Facilitating reuse in model-based development with context-dependent model element recommendations\n", "abstract": " Reuse recommendation systems suggest code entities useful for the task at hand within the IDE. Current approaches focus on code-based development. However, model-based development poses similar challenges to developers regarding the identification of useful elements in large and complex reusable modeling libraries. This paper proposes an approach for recommending library elements for domain specific languages. We instantiate the approach for Simulink models and evaluate it by recommending library blocks for a body of 165 Simulink files from a public repository. We compare two alternative variants for computing recommendations: association rules and collaborative filtering. Our results indicate that the collaborative filtering approach performs better and produces recommendations for Simulink models with satisfactory precision and recall.", "num_citations": "9\n", "authors": ["91"]}
{"title": "Effective and efficient reuse with software libraries\n", "abstract": " This thesis empirically analyzes the extent and nature of third-party code reuse in practice. Motivated by the findings, a dynamic approach for detecting functionally similar code is evaluated. An API recommendation system is introduced that assists developers during programming with software libraries by providing context-specific suggestions for API methods within the development environment. This principle is transferred to model-based development.", "num_citations": "9\n", "authors": ["91"]}
{"title": "Towards a formal engineering approach for SOA\n", "abstract": " Service-oriented architectures (SOA) have received much attention for providing specification principles in order to develop flexible and interoperable software systems. This is achieved by concentrating on''non-technical''concepts of the application domain in order to structure software systems in a functional, business process-oriented manner-thereby enabling efficient reactions to changing requirements. Although there exists a common understanding and agreement on the core essentials of a...\u00bb", "num_citations": "6\n", "authors": ["91"]}
{"title": "Utilizing web search engines for program analysis\n", "abstract": " Programming involves representing domain concepts by using programming abstractions. In object-oriented programs, concepts and relations of the business domain are represented as classes, attributes and methods. However, the concepts and relations that logically belong together are scattered across different modules, interleaved with technical concepts, and distorted due to implementation details. In this paper, we present an automatic method to identify logically related concepts and the relations among them. To achieve this, we systematically transform program identifiers into fragments of natural language sentences and check whether these sentence fragments are meaningful for humans. In order to automatically perform such checks, we use the World Wide Web as a knowledge base that contains a huge number of meaningful texts, and use the Google web search engine to validate the meaningfulness\u00a0\u2026", "num_citations": "2\n", "authors": ["91"]}