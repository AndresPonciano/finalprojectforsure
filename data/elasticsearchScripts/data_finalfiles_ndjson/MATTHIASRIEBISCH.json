{"title": "Extending feature diagrams with UML multiplicities\n", "abstract": " Feature diagrams are an important product of domain analysis for product lines or system families, respectively. They describe relations between requirements and distinguish between common and variable characteristics. Feature diagrams, as part of the feature model, form the basis for configuring the system. Current principles do not supply a complete description of the semantics of relationships and dependencies between features. Thus, the development of methods and tools for elaborating configurations is not possible. This paper presents some enhancements to feature diagrams. In addition the paper deals with the inclusion of feature models in the development process of product lines.", "num_citations": "318\n", "authors": ["129"]}
{"title": "Towards a more precise definition of feature models\n", "abstract": " Feature models are a well accepted means for expressing requirements in a domain on an abstract level. They are applied to describe variable and common properties of products in a product line, and to derive and validate configurations of software systems. Their industrial importance is increasing rapidly. However, methodical usage and tool support demands for a more precise definition of features, their properties and their relations within a feature model. This position paper summarizes the state of the discussion and proposes issues for future development. Categories of features and types of their attributes and relations are presented. The represented information is limited to a customer point of view onto the feature models without excluding technically detailed features. Connections of features to other models ie design, and to implementation elements are given by traceability links. Approaches for graphical representations and data models for feature models are shown. Proposals of attaching additional information for related tasks like product line evolution, scoping, effort estimation, definition of product configurations and documenting are discussed.", "num_citations": "144\n", "authors": ["129"]}
{"title": "UML-based statistical test case generation\n", "abstract": " For incremental iterative software development processes, automated testing is necessary to enable evolution not only in terms of functionality, but in terms of software quality as well. Automation requires models to provide the necessary information. Scenarios and use cases do not only feed requirements engineering, they may also be the basis for testing. They have to be enriched by detailed behavioral information in order to be used for statistical test case generation. This paper introduces an approach for generating system-level test cases based on use case models and refined by state diagrams. These models are transformed into usage models to describe both system behavior and usage. The method is intended for integration into an iterative software development process model. The resulting test cases are suited to be carried out in conventional ways, i.e., either manually or using test tools. The\u00a0\u2026", "num_citations": "126\n", "authors": ["129"]}
{"title": "Feature-oriented development of software product lines: mapping feature models to the architecture\n", "abstract": " Software product lines (PLs) present a solid approach in large scale reuse. Due to the PLs\u2019 inherit complexity, many PL methods use the notion of \u201cfeatures\u201d to support requirements analysis and domain modelling (e.g. FODA, FORM, FeatuRSEB). Nevertheless, the link between features and architecture remains weak in all methodologies, with a large impact on the traceability of high-level concerns in respect to lower-lever architectural structures. This paper provides an analysis on the state of the art of feature-oriented PL methodologies from the point of view of the linkage between feature models and architecture. Based on the identified shortcomings it introduces an approach to allow a strong mapping between features and architecture. The approach makes use of extensions in the feature modelling techniques and adopts plug-in architectures as a means of mapping feature structures and at the same\u00a0\u2026", "num_citations": "107\n", "authors": ["129"]}
{"title": "Details of formalized relations in feature models using OCL\n", "abstract": " System families are a form of high level reuse of development assets in a specific problem domain, by making use of commonalities and variabilities. To represent assets belonging to the core of the family and assets belonging to variable parts, feature modeling is a widely used concept. Consistency checking in feature models is not yet addressed appropriately by current methods. The paper gives a brief overview of feature modeling and elaborates the problems of current approaches. Based on the applications of these approaches within an ongoing research project, the paper proposes a formalized definition for feature modeling using the Object Constraint Language (OCL) and a set of associations and constraints to be used in the feature model. The relations between features in the feature model and features to external assets are examined and a way to formally handle these relations is presented as a result of\u00a0\u2026", "num_citations": "94\n", "authors": ["129"]}
{"title": "The feature-architecture mapping (FArM) method for feature-oriented development of software product lines\n", "abstract": " Software product lines (PLs) are large, complex systems, demanding high maintainability and enhanced flexibility. Nonetheless, in the state of the art PL methods, features are scattered and tangled throughout the system components, leading to poor maintainability. Additionally, the majority of PL methods support manual product composition, while the implementation of feature-level variability in PL products influences the system's conceptual integrity. Generative programming techniques do enhance flexibility, but on the cost of maintainability. The feature-architecture mapping (FArM) method provides a stronger mapping between features and the architecture. It is based on a series of transformations on the initial PL feature model. During these transformations, architectural components are derived, encapsulating the business logic of each transformed feature and having interfaces reflecting the feature interactions\u00a0\u2026", "num_citations": "92\n", "authors": ["129"]}
{"title": "An approach for reverse engineering of design patterns\n", "abstract": " For the maintenance of software systems, developers have to completely understand the existing system. The usage of design patterns leads to benefits for new and young developers by enabling them to reuse the knowledge of their experienced colleagues. Design patterns can support a faster and better understanding of software systems. There are different approaches for supporting pattern recognition in existing systems by tools. They are evaluated by the Information Retrieval criteria precision and recall. An automated search based on structures has a highly positive influence on the manual validation of the results by developers. This validation of graphical structures is the most intuitive technique. In this paper a new approach for automated pattern search based on minimal key structures is presented. It is able to detect all patterns described by the GOF [15]. This approach is based on positive and\u00a0\u2026", "num_citations": "87\n", "authors": ["129"]}
{"title": "Modeling variability for object-oriented product lines\n", "abstract": " The concept of a software product line is a promising approach for increasing planned reusability in industry. For planning future requirements, the integration of domain analysis activities with software development for reusability turned out to be necessary, both from a process and from an economic point of view. In this context, variability of requirements in a domain is expressed by feature models. Feature models enable planning and strategic decisions both for architectural and for component development. By expressing feature dependencies, feature models are used to partition the architecture and the implementation. For industrial use, appropriate methods for modeling variability in requirements, design and implementation as well as tools for supporting feature models and for integrating them with other models are needed. The ECOOP workshop explored the possibilities and limitations of feature\u00a0\u2026", "num_citations": "71\n", "authors": ["129"]}
{"title": "Supporting evolutionary development by feature models and traceability links\n", "abstract": " During their usage, software systems have to be changed constantly. If such changes are implemented in an incomplete or inconsistent way a loss of architectural quality will occur, i.e. in terms of maintainability and understandability. The lack of traceability of the impact of changed requirements in the software enhances this effect. Traceability links have been proposed as a link between the requirements and the different parts of a solution. In practical use, these links are difficult to establish and maintain. Currently, tools cannot effectively support these links due to human-required decisions. This paper introduces feature models as an intermediate element for linking requirements to design models. They enable a more appropriate bridging of the different levels of abstraction. Feature models group sets of requirements to a feature and enable a modeling of the variability of requirements. The feature models structure\u00a0\u2026", "num_citations": "68\n", "authors": ["129"]}
{"title": "Using feature modeling for program comprehension and software architecture recovery\n", "abstract": " The available evidence in a legacy software system, which can help in its understanding and recovery of its architecture are not always sufficient. Very often the system's documentation is poor and outdated. One may argue that the most reliable resource of information is the system's source code. Nevertheless a significant knowledge about the problem domain is required in order to facilitate the extraction of the system's useful architectural information. In this approach feature modeling is introduced as an additional step in a system's architectural recovery process. Feature modeling structures the system's functionality and supports reverse engineering by detecting the relations between source code elements and requirements. Tracing these relations may lead to a better understanding of the program's behavior and the recovery of various architectural elements. In this way, by providing a mapping between source\u00a0\u2026", "num_citations": "54\n", "authors": ["129"]}
{"title": "A model-based regression testing approach for evolving software systems with flexible tool support\n", "abstract": " Model-based selective regression testing promises reduction in cost and labour by selecting a subset of the test suite corresponding to the modifications after system evolution. However, identification of modifications in the systems and selection of corresponding test cases is challenging due to interdependencies among models. State-based testing is an important approach to test the system behaviour. Unfortunately the existing state-based regression testing approaches do not care for dependencies of the state machines with other system models. This paper presents the tool support and evaluation of our state-based selective regression testing methodology for evolving state-based systems. START is an Eclipse-based tool for state-based regression testing compliant with UML 2.1 semantics. START deals with dependencies of state machines with class diagrams to cater for the change propagation. We applied\u00a0\u2026", "num_citations": "47\n", "authors": ["129"]}
{"title": "Rule-based impact analysis for heterogeneous software artifacts\n", "abstract": " Typical software engineering activities, such as program maintenance or reengineering, result in frequent changes of software which are often accompanied by unintended side effects. Consequently, research on impact analysis put forth approaches to assess the adverse effects of changes. However, understanding and implementing these changes is often aggravated by inconsistencies and dependencies between different types of software artifacts. Likewise, most impact analysis approaches are not able to detect the possible side effects of changes when different types of software artifacts are involved. We present an approach that combines impact analysis and multi-perspective modeling for analyzing the change propagation between heterogeneous software artifacts. Our approach assists developers with understanding the consequences of changes by identifying impacted artifacts and determining how they\u00a0\u2026", "num_citations": "41\n", "authors": ["129"]}
{"title": "Impact evaluation for quality-oriented architectural decisions regarding evolvability\n", "abstract": " Quality goals have to be under a special consideration during software architectural design. Evolvability constitutes a quality goal with a special relevance for business critical systems. Architectural patterns can significantly contribute to the satisfaction of quality goals. But architectural design decisions regarding these goals have to be made in a systematic, methodical way and concerning the patterns\u2019 influence on quality properties. Unfortunately, pattern catalogs do not well support quality goal-oriented design decisions. This paper presents a systematic refinement and mapping of the quality goal evolvability to properties for good architectural design. A set of architectural patterns is evaluated regarding these properties. Furthermore, a calculation scheme is provided that enables the evaluation of the patterns to support design decisions. The results have been developed, revised, and evaluated in a series\u00a0\u2026", "num_citations": "40\n", "authors": ["129"]}
{"title": "Optimisation process for maintaining evolvability during software evolution\n", "abstract": " Software systems have to be changed continuously and evolutionarily throughout the whole time of their development and usage. Meanwhile, the software systems have to remain flexible in order to retain the ability to be extended by additional new features or to be changed. To maintain this ability, known as evolvability, the architecture of such software systems and its evolution must be continuously controlled and, if necessary improved. Existing design methodologies do not provide sufficient support for controlling the evolvability. One reason for this is, that in comparison with software maintainability, evolvability characteristics are hardly defined. This paper discusses evolvability, and introduces a quality model for it. Furthermore, a meta-model-based process for controlling and optimising the evolvability characteristics of software baselines is presented. The feasibility of this approach is shown by a case study\u00a0\u2026", "num_citations": "33\n", "authors": ["129"]}
{"title": "The Hyper/UML approach for feature based software design\n", "abstract": " The market requests complex but adaptable software systems. There are different concepts to meet this demand, for example software reusability, component-based development, agile processes, generative programming and domain analysis. For similar products within a domain product lines are a very promising approach for shortening development time and cost and for improving quality. Software product lines combine some of the mentioned concepts. In a software product line there is a common core for all target products and variable components for building different products. Using product lines new products are created based on customer-ordered features. The feature driven development of software systems becomes more and more important not only for product lines but also for the better maintainability of software systems. Implementing variability by composition enables a partly automated development process of products. Extending composition techniques from source code to models and design support large systems and their evolution. In this paper the concept of Hyper/UML as UML extension is introduced for supporting the feature oriented separation of concerns, the feature driven design and the feature based automated generation of software products. The concept is based on the Hyperspace approach.", "num_citations": "33\n", "authors": ["129"]}
{"title": "Architectural knowledge for technology decisions in developer communities: An exploratory study with stackoverflow\n", "abstract": " Architectural decisions have a big influence on basic properties of a software system, and are difficult to change once implemented. Technology decisions deserve special attention because they are one of the most frequently occurring types of architectural decisions. Architectural knowledge is crucial for good decisions. Current architecture knowledge management approaches try to support architects by offering a rich base of architectural solutions and design decision rules. However, they mostly depend on manually capturing and maintaining the architectural knowledge. In this paper, we utilize the most popular online software development community (StackOverflow) as a source of knowledge for technology decisions to support architecture knowledge management approaches with a more efficient methods for knowledge capturing. We conducted an exploratory study, and followed a qualitative and quantitative\u00a0\u2026", "num_citations": "28\n", "authors": ["129"]}
{"title": "A taxonomy of change types and its application in software evolution\n", "abstract": " Changes play a central role in software evolution, where the types of changes are as multifarious as their consequences. When changing software, impact analysis and regression testing are required to preserve the quality of the system. However, without a consistent classification of types of change operations, a well-founded impact analysis methodology cannot be developed. Existing works which analyze and apply change types are typically limited to a certain aspect of software, e.g. source code or architecture. They also lack a thorough investigation of change types, which lead to duplicated proposals and the absence of a consistent taxonomy. In this paper, we review the usage of change types for impact analysis and regression testing, and illustrate how both activities are affected by different types of changes. Therefore, we outline how existing work deals with different types and granularities of changes. Our\u00a0\u2026", "num_citations": "28\n", "authors": ["129"]}
{"title": "Optimizing design for variability using traceability links\n", "abstract": " Software systems have to provide flexibility by implementing variability. Existing design methodologies do not support means for optimizing the design for variability and for measuring the overhead effort. Therefore, the solutions cannot be optimized regarding a minimal overhead for variability. Other methods are lacking of a traceability for variability mechanisms, or do not provide means for measuring and optimizing solutions. The paper introduces traceability links for variability with a special emphasis on support for implementation, build and deployment, and presents guidelines for optimizing the design with indicators for evaluating the results. The feasibility of the approach is shown by a case study from an industrial setting.", "num_citations": "28\n", "authors": ["129"]}
{"title": "Lightweight traceability for the agile architect\n", "abstract": " Although traceability information is vital to many software engineering activities, agile development approaches rarely use it because of the extra effort required. In this industry case study, the authors report the results of applying their lightweight semiautomated method that integrates traceability into software architecture developed with an agile process like Scrum.", "num_citations": "26\n", "authors": ["129"]}
{"title": "Software architectural design meets security engineering\n", "abstract": " Security requirements strongly influence the architectural design of complex IT systems in a similar way as other non-functional requirements. Both security engineering as well as software engineering provide methods to deal with such requirements. However, there is still a critical gap concerning the integration of the methods of these separate fields. In this paper we close this gap with respect to security requirements by proposing a method that combines software engineering approaches with state-of-the-art security engineering principles. This method establishes an explicit alignment between the non-functional goal, the principles in the field of security engineering, and the implementation of a security architecture. The method aims at designing a system's security architecture based on a small, precisely defined, and application-specific trusted computing base. We illustrate this method by means of a case study\u00a0\u2026", "num_citations": "26\n", "authors": ["129"]}
{"title": "Design pattern recovery in architectures for supporting product line development and application\n", "abstract": " Product lines can improve the efficiency of software development. Product lines offer reference architecture for the development of similar products. This architecture is developed in an evolutionary process while using existing systems and reusable components. The start of the development of product lines very often is based on the reengineering and generalization of several similar existing applications. Design Patterns can support the understanding of former architectures and the application of product line reference architectures. In this paper a short explanation of the development and application of product lines points out the relevance of patterns. The paper discusses existing pattern search methods and describes an approach suitable for the automated search. This approach enlarges the existing search criterion based methods for pattern recognition for the automated detection of all Gamma Patterns.", "num_citations": "25\n", "authors": ["129"]}
{"title": "Evolution support by homogeneously documenting patterns, aspects and traces\n", "abstract": " The evolution of complex software systems is promoted by software engineering principles and techniques like separation of concerns, encapsulation, stepwise refinement, and reusability of design solutions. Design patterns capture the expertise for reusable design solutions. Aspect-oriented programming is a methodology that enables the modularization of cross-cutting concerns. Traceability links designate dependencies between requirements, design, and source code. In order to support maintenance, documentation has to enable understandability by describing these issues. Descriptions have to facilitate tool support for automating documentation activities. In this paper, we use the notion of patterns, aspects and traces for a homogeneous documentation approach. We integrate various types of documentation, keep track of traces from requirements to the source code, keep design information in the source\u00a0\u2026", "num_citations": "25\n", "authors": ["129"]}
{"title": "Supporting architectural restructuring by analyzing feature models\n", "abstract": " In order to lower the risk, reengineering projects aim at high reuse rates. Therefore, tasks like architectural restructuring have to be performed in a way that developed new system architectures allow reuse of all valuable legacy systems' parts with minimal changes. During architectural restructuring there are two major types of modification: detection of architecture disproportions and their refactoring and detection of redundancies and their fusion. We introduce a method for applying domain knowledge for supporting these restructuring steps. The method operates on feature models. Words and terms of features and of architectural documents are analyzed by cluster analysis, information retrieval and metrics techniques. In this way, the method joins the approaches of feature analysis and of enhancing reengineering with domain knowledge by applying feature models for structuring the domain knowledge. The method\u00a0\u2026", "num_citations": "24\n", "authors": ["129"]}
{"title": "Traceability for Managing Evolutionary Change.\n", "abstract": " Traceability links can provide essential support for evolutionary development of software, beyond requirements engineering eg for reuse & design decisions, design and code comprehension, effort estimation, checks for completeness and project management. For maximum support, traceability links are required not only for large grained artifacts but for fine grained ones as well. The establishment and the maintenance of these links is crucial, because inconsistent links prevent the aimed positive effects. However, a high effort for traceability links would inhibit the positive effects as well. In this paper, the state of the art approaches of definition and application of traceability links are investigated. They are integrated together with link update operations within development methods. The investigation and the integrated approach was evaluated in various projects in research and industry in the fields of both forward and reverse engineering.", "num_citations": "23\n", "authors": ["129"]}
{"title": "Architecting for evolvability by means of traceability and features\n", "abstract": " The frequent changes during the development and usage of large software systems often lead to a loss of architectural quality which hampers the implementation of further changes and thus the systemspsila evolution. To maintain the evolvability of such software systems, their architecture has to fulfil particular quality criteria. Available metrics and rigour approaches do not provide sufficient means to evaluate architectures regarding these criteria, and reviews require a high effort. This paper presents an approach for an evaluation of architectural models during design decisions, for early feedback and as part of architectural assessments. As the quality criteria for evolvability, model relations in terms of traceability links between feature model, design and implementation are evaluated. Indicators are introduced to assess these model relations, similar to metrics, but accompanied by problem resolution actions. The\u00a0\u2026", "num_citations": "22\n", "authors": ["129"]}
{"title": "Classifying architectural constraints as a basis for software quality assessment\n", "abstract": " Architectural styles and patterns have been studied since the inception of software architecture as a discipline. We generalise architectural styles, patterns and similar concepts by introducing the notion of architectural constraints. An architectural constraint is a vehicle for the reuse of architectural design knowledge and for the improvement of software quality. It may be used for improving architectural analyses of quality characteristics of the software system to be realised. We present the method for surveying the literature on architectural constraint concepts, and provide a taxonomy covering various definitions of architectural styles and patterns.", "num_citations": "22\n", "authors": ["129"]}
{"title": "Evolution of product lines using traceability\n", "abstract": " A high level of software reusability is an important contribution to achieve evolvability and maintainability of large software systems. Software product lines enable reusability driven by common requirements of a family of similar software systems. This way, software product lines are a successor of other reusability approaches. However, for successful evolution of a product line have to be influenced several technical and non-technical factors.In this paper, an evolutionary development process for product lines and appearing problems and difficulties are described. The stepwise extension of a product line by new requirements can cause a degeneration of its software architecture. To avoid this degeneration, information about dependencies and traceability have to be included into models and products. An approach is described of how to integrate activities of eliciting, managing and exploiting traceability information into the product lines development process. Based on this information, tools can perform activities like reconfiguration automatically. Other activities like change, refactoring and reconfiguration are supported to master the complexity of large systems and to achieve maturity during evolution.", "num_citations": "21\n", "authors": ["129"]}
{"title": "Improving the search for architecture knowledge in online developer communities\n", "abstract": " To make good architecture design decisions, developers need to know suitable architecture solution alternatives. However, with the rapid and continuous increase of solution alternatives (e.g. technologies, patterns, tactics), it is challenging to acquire architecture knowledge and to ensure that this knowledge is up to date. Our goal is to improve how architects search for architecturally relevant information in online developer communities. We developed a new search approach for architecturally relevant information using Stack Overflow as an example of an online developer community. Our search approach differs from a conventional keyword-based search in that it considers semantic information of architecturally relevant concepts in Stack Overflow. We also implemented the search approach as a web-based search engine. To show the effectiveness of the search approach compared to a conventional keyword\u00a0\u2026", "num_citations": "20\n", "authors": ["129"]}
{"title": "Software-Evolvability\n", "abstract": " entwickelbar ist, wenn es sich leicht warten l\u00e4sst. Im Gegensatz zu anderen tr\u00e4gt die Definition von Breivold et al.[3] dem Rechnung, indem sie f\u00fcr Evolution typische Aspekte wie strukturelle \u00c4nderungen und Erhaltung der Architekturintegrit\u00e4t ber\u00fccksichtigt:\u201cSoftware evolvability is the ability of a software system to adjust to change stimuli, ie changes in requirements and technologies that may have impact on the software system in terms of software structural and/or functional enhancements, while still taking the architectural integrity into consideration.\u201d[3] Die Evolvability eines Softwaresystems sollte hoch sein, denn dadurch kann verhindert werden, dass ein System zu einem sogenannten Legacy-System wird [9], indem es die F\u00e4higkeit zu Evolution verliert. Aktivit\u00e4ten f\u00fcr die Erh\u00f6hung der Evolvability tragen immer auch zur Verbesserung der Wartbarkeit bei, was umgekehrt nicht gilt. Beispiele sind die Entwicklung\u00a0\u2026", "num_citations": "20\n", "authors": ["129"]}
{"title": "Defining a traceability link semantics for design decision support\n", "abstract": " The development and the evolution of large, complex software systems bear several risks. Traceability links can help to master the complexity of these tasks. Currently, they are not used in a large scale, because tool support is necessary to reduce the overhead effort. At present, tools for handling traceability links cannot be effectively developed, because the syntax and the semantics of the traceability links are not sufficiently defined. In this paper we present a set of traceability link types together with a definition of their semantics. The set of link types was developed by analyzing the link evaluation and exploitation. The presented link types are customized for the support of architectural design decisions in regard to a set of non-functional design goals. The extension of the results to a wider scope is discussed. The work was performed within a large industrial project.", "num_citations": "20\n", "authors": ["129"]}
{"title": "A traceability link model for the unified process\n", "abstract": " Traceability links are widely accepted as efficient means to support an evolutionary software development. However, their usage in analysis and design is effort consuming and error prone due to lacking or missing methods and tools for their creation, update and verification. In this paper we analyse and classify Unified Process artefacts to establish a traceability link model for this process. This model defines all required links between the artefacts. Furthermore, it provides a basis for the (semi)-automatic establishment and the verification of links in Unified Process development projects. We also define a first set of rules as step towards an efficient management of the links. In the ongoing project the rule set is extended to establish a whole framework of methods and rules.", "num_citations": "20\n", "authors": ["129"]}
{"title": "Traceability-driven model refinement for test case generation\n", "abstract": " Testing complex computer-based systems is not only a demanding but a very critical task. Therefore the use of models for generating test data is an important goal. Tool support during the generation of test cases can considerably reduce the effort and the risk of errors of this task. While model the understanding of model transformation got better in the past, the analysis of the input - requirement specifications mostly consisting of natural language texts - still represents a bottleneck. In this paper a method for closing the gaps between manual techniques for structuring texts and automatic techniques based on linguistics is explained. By providing suggestions for missing or ambiguous terms the method supports the formalization within large projects. The suggestions are derived from a glossary and from an analysis of their integration in use case descriptions. Additionally the traceability links via feature models and\u00a0\u2026", "num_citations": "20\n", "authors": ["129"]}
{"title": "Customizing traceability links for the unified process\n", "abstract": " Traceability links are generally recognised as helpful means for improving the effectiveness of evolutionary development processes. However, their practical usage in analysis and design is still unsatisfying, especially due to the high effort required for creation, maintenance and verification of the links, and due to lacking or missing methods and tools for their management.               In this paper a concept for the systematic management of traceability is introduced, adapted for the and integrated into the Unified Process as one of the widely accepted software development methods. As an extension, requirements templates are applied to facilitate a tool supported analysis of natural language texts in use case descriptions. Template-based analyses enable a determination of types of terms and a check of their correct application as well as a recognition of implicit connections between development artefacts. A\u00a0\u2026", "num_citations": "19\n", "authors": ["129"]}
{"title": "Statistical usage testing based on UML\n", "abstract": " This paper shows a way to derive test cases for system level black-box-testing from the specification models already elaborated in the requirements analysis phase.", "num_citations": "19\n", "authors": ["129"]}
{"title": "Formal details of relations in feature models\n", "abstract": " System families are a form of high level reuse of development assets in a specific problem domain, by making use of commonalities and variabilities. To represent assets belonging to the core of the family and assets belonging to variable parts, feature modeling is a widely used concept. Consistency of a feature model is not addressed appropriately by current methods. This paper gives a brief overview of feature modeling and elaborates the problems of current methods. Based on these problems and an ongoing research project this paper proposes a high level view onto feature modeling and a set of associations and constraints to be used in the feature model. The relations between features in the feature model and features to external assets are examined and a way to formally handle these relations is presented as a result of a research project.", "num_citations": "17\n", "authors": ["129"]}
{"title": "Systematic definition of reusable architectures\n", "abstract": " Reusable architectures, like frameworks or product lines, can improve the efficiency of software development. In this paper, methods from the areas of software engineering, domain engineering, software architectures and tool-supported implementation are combined and integrated to successfully build reusable architectures. Special emphasis is placed on process issues and on modeling. Software product line architectures form the reusable base of similar systems, and thus a system family. This architecture is developed in an evolutionary process while using existing systems and reusable components, so-called COTS systems. Within this process, the family's reusable core is specified by the integrated domain analysis methods. The implementation of the product line architecture is done with reusable frameworks. These frameworks are automatically instantiated by means of a method and a tool based on\u00a0\u2026", "num_citations": "17\n", "authors": ["129"]}
{"title": "Extending the UML to model system families\n", "abstract": " The system family paradigm aims towards developing several applications out of a domain with just one underlying architecture. The foundation of this core architecture are common properties. With this prefabricated core, systems can be build faster. Modeling and development of common parts and variants have to be supported by methods and notations. This paper extends the Unified Modeling Language (UML) to model variants during analysis and design. The built-in extension mechanisms of the UML are used without changing the metamodel. An example demonstrates the application of the extension.", "num_citations": "17\n", "authors": ["129"]}
{"title": "Introducing impact analysis for architectural decisions\n", "abstract": " Architectural quality constitutes a critical factor for contemporary software systems, especially because of their size and the needs for frequent, quick changes. For success-critical business systems, architectural decisions are of high risk for the market share and even for the existence of enterprises. These decisions are important for design processes as well as for refactoring. Because of the complexity of the decisions, e.g., uncertain, contradicting goals, unknown effects and risky conditions, decision-making is a difficult and risky task. Risks can be minimized if the decisions are made systematically. In an earlier paper, we introduced methods of decision theory to perform such decisions in a rational way. This paper introduces a method for evaluating alternatives of architectural decisions, for both architectural design and refactoring. This method adopts elements of the scenario-based evaluation method ALMA\u00a0\u2026", "num_citations": "14\n", "authors": ["129"]}
{"title": "Comprehensive model integration for dependency identification with EMFTrace\n", "abstract": " As model-based software development becomes increasingly important, the number of models to express various aspects of software at different levels of abstraction raises. Meanwhile evolutionary development and continuous changes demand for explicit dependencies between involved models to facilitate change impact analysis, software comprehension, or coverage and consistency checks. However, there are no comprehensive approaches supporting models, dependencies, changes, and related information throughout the entire software development process. The approach presented in this paper provides a unified and modelspanning concept with a repository for model integration, model versioning, and dependency identification among models utilizing traceability techniques, enhanced with analytic capabilities. The identification is based on a rule set to provide high values for precision and recall. The approach is implemented in a tool called EMFTrace, which is based on Eclipse technology and supports different CASE tools for modeling.", "num_citations": "12\n", "authors": ["129"]}
{"title": "Developing an ontology for architecture knowledge from developer communities\n", "abstract": " Software architecting is a knowledge-intensive activity. However, obtaining and evaluating the quality of relevant and reusable knowledge (and ensuring that this knowledge is up-to-date) requires significant effort. In this paper, we explore how online developer communities (e.g., Stack Overflow), traditionally used by developers to solve coding problems, can help solve architectural problems. We develop an ontology that covers architectural knowledge concepts in Stack Overflow. The ontology provides a description of architecture-relevant information to represent and structure architectural knowledge in Stack Overflow. The ontology is empirically grounded through qualitative analyses of different Stack Overflow posts, as well as inter-coder reliability tests. Our results show that the architecture knowledge ontology in Stack Overflow captures architecture-relevant information and supports achieving practitioners'\u00a0\u2026", "num_citations": "11\n", "authors": ["129"]}
{"title": "Decision buddy: tool support for constraint-based design decisions during system evolution\n", "abstract": " Designing a software architecture is a highly complex task and associated with a high degree of uncertainty. There are a variety of reusable and established solutions, but they differ in their impact on the system's functionality and quality. The architect has to consider different aspects like stakeholders' requirements as well as numerous constraints coming, among others, from the technical environment and organization. The context of software evolution sheds a different light on constraints. The existing system with its structure based on previous decisions is a limiting factor constraining the ongoing development. However, current approaches do not sufficiently consider constraints induced by an existing system until now. To assist the architect in taking the right design decisions efficiently, tool support for the recommendation of solutions and structured documentation of the design decisions are indispensable. In our\u00a0\u2026", "num_citations": "11\n", "authors": ["129"]}
{"title": "Combining architectural design decisions and legacy system evolution\n", "abstract": " Software development is characterized by ongoing design decisions that must take into account numerous requirements, goals, and constraints. When changing long-living and legacy systems, former decisions have to be considered. In order to minimize the risk of taking wrong or misleading decisions an explicit representation of the relevant aspects is crucial. Architectural decision modeling has proven to be an effective means to represent these aspects, the required knowledge, and properties of a potential solution. However, existing approaches do not sufficiently cover the ongoing evolution of decisions and artifacts. They fail in particular to represent relations to existing systems on a fine-grained level to allow for impact analysis and a later comprehension of decisions. Furthermore, the effort for capturing and modeling of design decisions has to be reduced. In our paper we integrate existing approaches\u00a0\u2026", "num_citations": "11\n", "authors": ["129"]}
{"title": "Evaluating alternatives for architecture-oriented refactoring\n", "abstract": " Refactoring of software systems represents a fundamental way of improving their quality properties. Large-scale refactoring has to be performed at an architectural level to execute such changes for larger systems. Architecture-oriented refactoring requires decisions with multiple, partly contradicting objectives and uncertain consequences. To minimize risks and effort, the decisions about optimal refactoring alternatives have to be performed in a systematic way. In this paper decision theory is adapted to architecture-oriented refactoring. Methods for the evaluation of refactoring alternatives are shown which are applicable even to decisions with multiple and partly uncertain consequences. Furthermore, the complex decision process is structured in a rational way. In an example the effects of an increased quality requirement to architectural evolution are demonstrated", "num_citations": "11\n", "authors": ["129"]}
{"title": "Architecture enforcement concerns and activities-an expert study\n", "abstract": " Architecture enforcement is concerned with the correct and seamless implementation of architecture design decisions in order to ensure software quality. In a previous study, we conducted an empirical study in order to gain insight into the industrial practice of architecture enforcement. There, we asked 12 software architects from industry about their experience with the architecture enforcement process. As a result, we identified architecture enforcement concerns and activities. In this paper, we extend our contributions of the existing study. Firstly, we conducted five additional interviews with software architects from two different domains, namely the enterprise application and the automotive domain. This adds new architecture concerns and activities to the existing list. Secondly, we conducted a literature review. We compared our findings from the interviews with the results from the literature review and evaluated how\u00a0\u2026", "num_citations": "10\n", "authors": ["129"]}
{"title": "Feature scoping for product lines\n", "abstract": " Product Line (PL) Engineering focuses on the development of complete system families as opposed to single systems. Systems are built of a reusable platform common to the whole family, and of specific parts extending it. The benefits of short time-to-market and lower development costs for each system within the system family are achieved by reusing the platform for each new system to be developed. Therefore the scoping of features for the reusable platform and the specific parts is crucial for PL success. This paper proposes scoping with 4 priority levels and a decision-table based interpretation of the results. The interpretation is shown both for start and for evolution of product lines. The paper is based on experiences on large-scale reuse in industrial software projects.", "num_citations": "9\n", "authors": ["129"]}
{"title": "Agile Processes in Software Engineering and Extreme Programming: 18th International Conference, XP 2017, Cologne, Germany, May 22-26, 2017, Proceedings\n", "abstract": " The 18th XP conference was held 2017 in the wonderful city of Cologne, Germany. In the spirit of past XP conferences, XP 2017 was a place where researchers and practitioners met to exchange new ideas and present their work. These proceedings contain the full research papers, short research papers, and doctoral symposium papers presented at the conference.In all, 46 research papers were submitted (39 full and seven short papers). All submitted papers went through a thorough review process, with each paper receiving at least three reviews. Finally, the Program Committee accepted 14 papers as full research papers (an acceptance rate of 35%). Moreover, six papers\u2014submitted as short or full research papers\u2014were accepted as short research papers. The selected papers cover a wide range of agile techniques and approaches. Many of them present results of empirical studies aiming to systematically evaluate successful agile practices, others are technology studies that are relevant to both researchers and practitioners. In the tradition of former XP conferences, the XP 2017 conference program offered many different session topics. Besides the scientific program, ie, the research track, doctoral symposium, and scientific workshops, the conference featured an industry and practice track, experience reports, and Open Space sessions. Materials from all of these sessions are available on the conference website at www. xp2017. org. Moreover, three keynotes were given by highly renowned speakers. Andrea Goulet from Corgibytes presented a talk on \u201cMakers and Menders: Putting the Right Developers on the Right Projects\u201d focusing on a\u00a0\u2026", "num_citations": "8\n", "authors": ["129"]}
{"title": "Modeling the interactions between decisions within software architecture knowledge\n", "abstract": " Software architecture is developed as a result of a selection process for software architectural solutions. The complexity, diversity and evolution nature of architectural solutions\u2019 interactions forces the architect to make critical design decisions based only on his own experience. Even though, the same design problem has already been addressed by another architect in a similar situation. In this paper, we are presenting a model for reusable software architectural knowledge to support the architect within the design process in understanding the relationship between the different architectural solutions, and how they impact the architectural design reasoning. In addition, the model acts as a base for organizational software architectural knowledge sharing. Our contribution in this paper is classifying and modeling the solutions and decisions\u2019 interactions, as well as how the design decision can be used as a\u00a0\u2026", "num_citations": "8\n", "authors": ["129"]}
{"title": "An ontology-based approach for documenting and validating architecture rules\n", "abstract": " Architecture conformance checking is an important activity of architecture enforcement where the architect ensures that all architecture concepts are implemented correctly in the source code. In order to support the architect, a lot of tools for conformance checking are available that allow to formalize the architecture in order to perform an automated verification. Typically, the formalization uses a rigid, tool-specific architecture concept language that may strongly deviate from the project-specific architecture concept language. In addition, a high level of formal expertise is required in order to comprehend the created formalization. We present an approach that uses a controlled natural language for the formalization of architecture concepts. This language allows to flexibly express architecture rules directly with project-specific concepts. Consequently, the resulting formalization is easy to understand and might also be\u00a0\u2026", "num_citations": "7\n", "authors": ["129"]}
{"title": "Evaluation across multiple views for variable automation systems\n", "abstract": " Automation systems in industry are often software-intensive systems consisting of software and hardware components. During their development several engineers of different disciplines are involved, such as mechanical, electrical and software engineering. Each engineer focuses on specific system aspects to be developed. To enable an efficient development, product lines especially with feature models for variability modeling are promising technologies. In order to reduce the complexity of both feature models and development process, views on feature models can be applied. The use of views for filtering purposes constitutes an established method. However, views also enable further options missing in current approaches, such as evaluations regarding requirements, including non-functional ones. This paper presents an approach for evaluation across multiple views to enable collaborative development for\u00a0\u2026", "num_citations": "7\n", "authors": ["129"]}
{"title": "Architecture conformance checking with description logics\n", "abstract": " Today, a lot of commercial and open source tools exist allowing to describe the intended architecture and to check architecture conformance automatically in order to detect and eventually minimize erosion. Unfortunately, those tools are restricted in terms of which architecture concepts can be used in order to describe the intended architecture. Additionally, those approaches lack an appropriate formal foundation in terms of a well-defined syntax and semantic. Nevertheless, this is a crucial requirement for automatic support in architecture conformance checking. In this paper, we propose a formal approach enabling a) the definition of an architecture concept language that allows to capture the most important architecture concepts and their related architecture rules, b) the validation of the consistency of this language, c) the mapping of architecture concepts to source code and capturing this mapping in an explicit\u00a0\u2026", "num_citations": "6\n", "authors": ["129"]}
{"title": "Tracing the implementation of non-functional requirements\n", "abstract": " A software architecture has to enable the non-functional properties, such as flexibility, scalability, or security, because they constitute the decisive factors for its design. Unfortunately, the methodical support for the implementation of non-functional requirements into software architectures is still weak; solutions are not generally established. Recently, there are only few approaches that actually deal with non-functional requirements during design; even fewer take advantage of traceability, which supports a mapping of requirements to solutions through the development process. Therefore, in this chapter the new architectural design method TraGoSoMa is presented, which supports these issues. The method uses a so-called Goal Solution Scheme, which guides the design activities, supports conflict resolution, decision-making, and the classification of solutions. For illustration purposes the chapter uses a case study\u00a0\u2026", "num_citations": "6\n", "authors": ["129"]}
{"title": "Usability-focused architectural design for graphical user interface components\n", "abstract": " Although in recent years some progress in software engineering (SE) and human-computer interaction (HCI) has been made, there is still a gap between the two research areas and their methodologies. Today, from the engineering point of view, the specification and design of graphical user interfaces and their corresponding software architectural components is still a challenging task. The advanced component design methods are not yet integrated with HCI design methodologies to bridge the two fields. This paper presents a methodology, which extends a category-based software architectural design method by integrating HCI approaches. The methodology aims at a better design of graphical user interface (GUI) components in terms of both the architectural quality and usability. The methodology has been successfully evaluated in the development and partial reengineering of an e-commerce system.", "num_citations": "6\n", "authors": ["129"]}
{"title": "Towards an HPC certification program\n", "abstract": " The HPC community has always considered the training of new and existing HPC practitioners to be of high importance to its growth. This diversification of HPC practitioners challenges the traditional training approaches, which are not able to satisfy the specific needs of users, often coming from non-traditionally HPC disciplines, and only interested in learning a particular set of competences. Challenges for HPC centres are to identify and overcome the gaps in users\u2019 knowledge, while users struggle to identify relevant skills. We have developed a first version of an HPC certification program that would clearly categorize, define, and examine competences. Making clear what skills are required of or recommended for a competent HPC user would benefit both the HPC service providers and practitioners. Moreover, it would allow centres to bundle together skills that are most beneficial for specific user roles and scientific domains. From the perspective of content providers, existing training material can be mapped to competences allowing users to quickly identify and learn the skills they require. Finally, the certificates recognized by the whole HPC community simplify inter-comparison of independently offered courses and provide additional incentive for participation.", "num_citations": "5\n", "authors": ["129"]}
{"title": "Missing clean code acceptance and support in practice-an empirical study\n", "abstract": " Code quality is important for maintainability and sustainability of software systems, and is addressed by guidelines and peer reviews. There are well-defined methods and standards for code quality for example the Clean Code approach [1], and they are integrated with current software development process models such as SCRUM. However, developers have to be encouraged to invest effort due to the trade-off between software quality measures and projects' time pressure. Unfortunately, there are no proven hypotheses about the reasons for missing acceptance of such methods and standards by developers. To investigate hindering aspects for code quality acceptance in practice, empirical studies might help to determine the root problems and to establish solutions. However, there is a lack of empirical studies concerning this topic. Therefore, we performed an empirical study with practitioners to investigate\u00a0\u2026", "num_citations": "5\n", "authors": ["129"]}
{"title": "Towards the essentials of architecture documentation for avoiding architecture erosion\n", "abstract": " Software architecture documentation is essential for preventing architecture erosion that is a major concern of sustainable software systems. However, the high effort for elaboration and maintenance of architecture documentation hinders its acceptance in practice. Most state-of-the-art research methods assume comprehensive architecture documentation. By reducing architecture documentation to those aspects that are most important for architecture erosion, we want to achieve more acceptance for architecture documentation especially in agile projects. This reduction, however, has effects on architecture-related activities during software design and implementation.", "num_citations": "5\n", "authors": ["129"]}
{"title": "Analyzing model dependencies for rule-based regression test selection\n", "abstract": " Unintended side effects during changes of software demand for a precise test case selection to achieve both confidence and minimal effort for testing. Identifying the change related test cases requires an impact analysis across different views, models, and tests. Model-based regression testing aims to provide this analysis earlier in the software development cycle and thus enables an early estimation of test effort. In this paper, we present an approach for model-based regression testing of business processes. Our approach analyzes change types and dependency relations between different models such as Business Process Modeling Notation (BPMN), Unified Modeling Language (UML), and UML Testing Profile (UTP) models. We developed a set of impact rules to forecast the impact of those changes on the test models prior to their implementation. We discuss the implementation of our impact rules inside a prototype tool EMFTrace. The approach has been evaluated in a project for business processes on mobile devices.", "num_citations": "5\n", "authors": ["129"]}
{"title": "Leichtgewichtige Traceability im agilen Entwicklungsprozess am Beispiel von Scrum\n", "abstract": " Elke Bouillon1, Baris G\u00fcldali2, Andrea Herrmann3, Thorsten Keuler4, Daniel Moldt5, Matthias Riebisch6 1 Technische Universit\u00e4t Ilmenau, elke.bouillon@tu-ilmenau.de 2 s-lab  Software Quality Lab/Universit\u00e4t Paderborn, bguldali@s-lab.upb.de 3 Freie Software Engineering Trainerin und Forscherin, herrmann@herrmann-ehrlich.de 4 Fraunhofer IESE, Thorsten.keuler@iese.fraunhofer.de 5 Universit\u00e4t Hamburg, moldt@informatik.uni-hamburg.de 6 Universit\u00e4t Hamburg, riebisch@informatik.uni-hamburg.de Motivation Einer der wichtigsten Erfolgsfaktoren der agilen Softwareentwicklung ist die schnelle und unkomplizierte Verteilung von Informationen. Dabei reicht das Spektrum der Informationsverteilung von einfachen Dokumenten \u00fcber Wikis, Videos und Telefonaten bis hin zum 'Face-to-Face' Gespr\u00e4ch. In der traditionellen Softwareentwicklung lag der Fokus typischerweise auf einer dokument-basierten Erfassung und Verteilung von Informationen. Explizite Dokumentation beruht auf der Annahme, dass sich die festgehaltenen Informationen nur in bestimmtem Ma\u00dfe \u00e4ndern. Da dieser Umstand insbesondere in der Softwareentwicklung nicht automatisch gegeben ist, hat man dies im Kontext der agilen Vorgehensweisen als ein Kernproblem von schwergewichtigen Prozessen identifiziert. Als Konsequenz dazu wird in der agilen SoftwareEntwicklung der Umfang der Dokumentation minimiert. Dies spiegelt sich im Manifest f\u00fcr Agile Software-Entwicklung wider (s. agilemanifesto.org): Obwohl die umfassende Dokumentation als wichtig erachtet wird, wird der Wert funktionierender Software h\u00f6her eingesch\u00e4tzt. Nach den zw\u00f6lf inizialen Prinzipien\u00a0\u2026", "num_citations": "5\n", "authors": ["129"]}
{"title": "Problem-solution mapping for forward and reengineering on architectural level\n", "abstract": " Software architectures play a key role for the development and evolution of software systems because they have to enable their quality properties such as scalability, flexibility, and security. Software architectural decisions represent a transition from problem space with quality goals and requirements on one side to solution space with technical solutions on the other side. Technical solutions are reusable elements for the work of the architect as for example patterns, styles, frameworks and building blocks. For long-term evolution of the systems, an explicit mapping between goals and solutions is helpful for expressing design knowledge and fundamental decisions. Such a mapping has to bridge between the fields of requirements engineering, software architectural design, and software quality thus enabling reuse. In this paper the Goal Solution Scheme is discussed, which maps quality goals and goal refinements to\u00a0\u2026", "num_citations": "5\n", "authors": ["129"]}
{"title": "Towards comprehensive modelling by inter-model links using an integrating repository\n", "abstract": " Model-based development techniques enable a high efficiency and the mastering of complexity. For many domains more than one model has to be used to express the relevant information. Many methods use different models without a tight coupling, with a high risk of inconsistencies. Other approaches are based on metamodel extension or unified metamodels, with a limited tool support as consequence. We present an approach for the interconnection between several models in a joint repository by means of dependency relationships. The interconnection is shown between UML models, BPMN models and feature models by examples for variable workflows in mobile systems. The presented approach is implemented by the EMF-based repository EMF Trace, with XML for model representation. Dependencies are determined either automatically by a rule set or manually by explicit references.", "num_citations": "5\n", "authors": ["129"]}
{"title": "Back to the drawing board\n", "abstract": " Today, security is still poorly considered in early phases of software engineering. Architects and software engineers still lack knowledge about architectural security design as well as implementing it compliantly. However, a software system that is not designed for security or does not adhere to this design can hardly meet its security requirements. In this paper, we present an approach we are working on. The approach consists of two parts: Firstly, we improve the architecture\u2019s security level through model transformation. Secondly, we derive rules and constraints from the secured architecture in order to check the implementation\u2019s conformance. Through these activities we aim to support architects and software developers in building a secure software system. We plan to evaluate our approach in industrial case studies.", "num_citations": "4\n", "authors": ["129"]}
{"title": "Problem-Solution Mapping for Evolution Support of Software Architectural Design\n", "abstract": " Software architectures constitute a crucial factor for the development and evolution of software systems because they have to sustain their quality properties like flexibility, scalability, or security. A software architecture has to reflect the transition from the problem space with quality goals and requirements on one side to the solution space with technical solutions on the other side. A mapping between goals and solutions shall enable long-term evolution of the systems by expressing design knowledge and fundamental decisions explicitly. The gap between the fields of requirements engineering, software architectural design and software quality has not yet been closed. This paper discusses the Goal Solution Scheme, which maps quality goals and goal refinements to architectural principles and solutions. Its application in forward and re-engineering activities is shown, as well as its establishment. The concept has been evaluated in various projects including industrial case studies.", "num_citations": "4\n", "authors": ["129"]}
{"title": "Refinement and Formalization of Semi-Formal Use Case Descriptions\n", "abstract": " Behavioral models of computer systems are required for their synthesis, for verification and validation. The system behavior is usually described in requirements specifications. However, most specifications are provided in natural language or in a semi-formal way. Incompleteness and ambiguity inhibit their successful exploitation by tools. In this paper an approach for stepwise refinement and formalization of natural-language or semiformal descriptions is presented. Based on the structure of Use Case descriptions, the formalization of behavioral information is reached by a stepwise transformation of an input text to structured sentences with a well-defined syntax by performing linguistic analyses. The terms of the text are replaced by references to other items, ie of the glossary. By providing a tool-supported text output with hypertext-like navigation facilities, a verification of the result by the human experts is provided. The resulting behavioral description is suitable for a derivation of dynamic models, eg message-sequence charts and state diagrams.", "num_citations": "4\n", "authors": ["129"]}
{"title": "Adaptive Autonomous Machines-Requirements and Challenges.\n", "abstract": " In mechanical and plant engineering, the general challenge is to achieve flexibility in order to process changes in the requirements or operating conditions of a machine on the site of the plant operator. Changes to the machine and its configuration require the operator to work together with the machine builder (or plant constructor for several machines) and, if necessary, with his suppliers, which requires time and effort due to communication and delivery routes. Hence, an autonomous acting machine or component that deal with needed changes through automatically triggered adaptations would facilitate this process. In this paper, subtasks for constructing autonomous adaptive machines are identified and discussed. The underlying assumption is that changes of machines and components can be supported through configuration technologies because those handle variability and supply automatic derivation methods for computing needed changes in terms of machine and component updates.", "num_citations": "3\n", "authors": ["129"]}
{"title": "Establishing common architectures for porting mobile applications to new platforms\n", "abstract": " Currently the market of mobile operating systems is divided between several platforms and developers have to target more than one in order to achieve a large number of users [4]. Reimplementing an existing application for a second platform is no trivial task, though. Developers need to learn the second platform\u2019s API, concepts and paradigms such as an app\u2019s life cycle, the platform\u2019s caching mechanisms and the like. On the one hand, different technologies and frameworks ease cross-platform development, such as Xamarin [8], PhoneGap and many others [5]. On the other hand, reimplementing an existing app with such a framework and discarding the original one is likely to break the maturity level and the users\u2019 acceptance in consequence. Additionally there are reasons not to use tools and languages other than those supported by the operating system producers: The native API is maintained continuously and the IDEs are strictly aligned to the latest technology.This paper introduces a porting approach that aims at easing the maintenance of the original and the emerging implementation for the target operating system. Furthermore it contributes to the preservation of the flexibility of native development and the maturity level of the existing original app. This is achieved by restructuring the first app in order to subject most of the code to a semi-automated porting. It establishes a common architecture of the original and the ported implementation. This way it reduces the maintenance effort compared to a complete reimplementation. The following sections introduce this process and shortly specify related work. Finally, the currently conducted\u00a0\u2026", "num_citations": "3\n", "authors": ["129"]}
{"title": "Tracing quality-related design decisions in a category-driven software architecture\n", "abstract": " Quality properties, so-called non-functional ones, have a fundamental influence on the development of software systems because they constitute the decisive factors for the design of a system's software architecture. They earn a similar consideration like functional properties. For a high evolvability of the software systems, traceability supports changes by facilitating design decisions, software comprehension and coverage checks. In this paper a method for design traceability is presented, in which links both for functional and quality properties are established in similar ways. A software category based design method is used for a better alignment between requirements and design. As a consequence, the method leads to a reduced number of traceability links. The method has been successfully applied in the development and partial reengineering of an e-commerce system.", "num_citations": "3\n", "authors": ["129"]}
{"title": "Evolutionary Development of Frameworks\u2013from Projects to System Families\n", "abstract": " Object-oriented software engineering did not reach all productivity objectives expected in the beginning. A lack of methodical support results in low comprehensibility of code and documentation. Reusability was attained only in projects, in which a system family was the target. This paper examines different attempts with respect to their systematic support for development of system families. Based on Domain Analysis, there is introduced an evolutionary methodology for reaching multiple use of software engineering results. The approach starts from an existing system and offers a pragmatic and systematic way to describe common and variable parts of systems explicitly and comprehensively. Based on this descriptions, the development of systems with high adaptability and maintainability is attainable. Generative Programming is mentioned as a new software paradigm offering a way to simplify the implementation\u00a0\u2026", "num_citations": "3\n", "authors": ["129"]}
{"title": "Exploring Web Search Engines to Find Architectural Knowledge\n", "abstract": " Software engineers need relevant and up-to-date architectural knowledge (AK), in order to make well-founded design decisions. However, finding such AK is quite challenging. One pragmatic approach is to search for AK on the web using traditional search engines (e.g. Google); this is common practice among software engineers. Still, we know very little about what AK is retrieved, from where, and how useful it is. In this paper, we conduct an empirical study with 53 software engineers, who used Google to make design decisions using the AttributeDriven-Design method. Based on how the subjects assessed the nature and relevance of the retrieved results, we determined how effective web search engines are to find relevant architectural information. Moreover, we identified the different sources of AK on the web and their associated AK concepts.", "num_citations": "2\n", "authors": ["129"]}
{"title": "A porting method for coordinated multiplatform evolution\n", "abstract": " Cross\u2010platform development nowadays is a key issue in software engineering, since software developers have to target multiple platforms in order to reach a larger number of users. Often, software is developed initially for one platform before being extended to multiplatform development. However, most of the existing technical support and methods for cross\u2010platform development are applicable only to projects that develop a software product from scratch. They do not address the frequent situation that an existing mature software shall be ported rather than being reimplemented for an additional platform. In this article, we present a flexible transformation method from single to multiplatform development that systematically leverages existing and novel tools. For facilitating coordinated evolution of the original and the target platform code, we establish traceability across the two versions and develop a common\u00a0\u2026", "num_citations": "2\n", "authors": ["129"]}
{"title": "Modelling Technical Constraints and Preconditions for Alternative Design Desicions.\n", "abstract": " For architectural design decisions, a high number of goals and constraints has to be considered. For a proper management of their complexity and as a precondition for tool support, they have to be modeled explicitly. Existing approaches fail to provide a predictable, rigor decision-making as well as a to deal with incomplete or even partly contradicting information. This paper presents an approach for an explicit modeling of constraints for architectural reasoning and of preconditions for existing solutions based on the concept of technical terms. The preconditions are modeled within the Goal Solution Scheme, and are combined with information about the impact of existing solutions on quality goals.", "num_citations": "2\n", "authors": ["129"]}
{"title": "Aufrechterhaltung von Traceability Links w\u00e4hrend evolution\u00e4rer Softwareentwicklung\n", "abstract": " Softwaresysteme spielen in vielen Lebensbereichen eine immer wichtigere Rolle und werden immer komplexer. Sie unterliegen h\u00e4ufigen \u00c4nderungen, die notwendig sind, um weiteren Einsatz zu erm\u00f6glichen. Solche \u00c4nderungen erfordern hohen Aufwand und sind au\u00dferdem mit hohen Risiken verbunden, zB bez\u00fcglich Korrektheit, Termin-und Budgeteinhaltung. H\u00e4ufige \u00c4nderungen f\u00fchren zu Strukturverlust (englisch Architectural Decay), der wiederum nachfolgende \u00c4nderungen erschwert. Zur Vermeidung dieser Konsequenzen muss die evolution\u00e4re Weiterentwicklung von Systemen durch softwaretechnische Konzepte, Methoden und Werkzeuge unterst\u00fctzt werden. Traceability stellt ein Konzept dar, das evolution\u00e4re Softwareentwicklung f\u00f6rdert. Traceability Links verbinden Artefakte der Anforderungsanalyse, des Entwurfs und der Implementierung und tragen so zu besserer Verst\u00e4ndlichkeit bei. \u00c4nderungen werden vereinfacht, indem beispielsweise Aufwandssch\u00e4tzung, Verfolgung, Vollst\u00e4ndigkeitsanalyse und Pr\u00fcfung unterst\u00fctzt werden. Die Nutzung von Traceability Links bietet selbst dann Vorteile, wenn daf\u00fcr zus\u00e4tzlicher Aufwand notwendig ist. Um Traceability Links effektiv nutzen zu k\u00f6nnen, m\u00fcssen sie g\u00fcltig, das hei\u00dft korrekt und vollst\u00e4ndig sein. Aufgrund der hohen Anzahl erfordert die Erstellung, Konsistenzsicherung und Pr\u00fcfung der Links sehr hohen Aufwand. Die hier vorgestellten Arbeiten zielen auf eine deutliche Reduzierung dieses Aufwands ab, um einen Nutzen in der praktischen Anwendung zu erreichen. Aufgrund der nur teilweise formal definierten Semantik von verbreiteten Spezifikations-und Modellierungssprachen ist\u00a0\u2026", "num_citations": "2\n", "authors": ["129"]}
{"title": "4 Prozess der Architektur-und Komponentenentwicklung\n", "abstract": " Die Entwicklung einer Architektur ist ein sehr komplexer Prozess, bei dem viele T\u00e4tigkeiten miteinander verwoben sind. Zahlreiche Aspekte greifen bei der Entscheidungsfindung ineinander, eine Reihe von Prinzipien ist gleichzeitig zu beachten. Dies ist eine der Ursachen daf\u00fcr, dass dieser Prozess schwer verst\u00e4ndlich ist. H\u00e4ufig wird dann gesagt, dass viel Erfahrung notwendig ist, um Architekturen zu entwickeln. Erfahrungen allein sind jedoch nicht ausreichend f\u00fcr die Entwicklung von guten Software-Architekturen\u2013Programmierer mit viel Erfahrung sind nicht automatisch gute Architekten. Ein Erlernen der grundlegenden Prinzipien und Zusammenh\u00e4nge der Software-Architekturen kann und muss das Sammeln von Erfahrungen erg\u00e4nzen. Au\u00dferdem sind Entscheidungen m\u00f6glichst rational zu treffen, obwohl h\u00e4ufig deren Ziele und die Auswirkungen der Alternativen nicht vollst\u00e4ndig klar sind. Hierbei soll dieses Kapitel unterst\u00fctzen, indem der Architekturentwicklungs-Prozess zerlegt und seine grundlegenden Elemente stark vereinfacht und modellhaft beschrieben werden. Die Darstellung in diesem Kapitel entspricht damit nicht mehr dem Ablauf der Entwicklung einer Architektur in der Realit\u00e4t; durch kleine Beispiele soll der Bezug zu realen Prozessen aufrechterhalten bleiben.", "num_citations": "2\n", "authors": ["129"]}
{"title": "Featuregesteuerte Architekturgestaltung zwecks Wartbarkeit und Evolution von Produktlinien\n", "abstract": " Die Wartung und Weiterentwicklung von Software-Produktlinien stellen wegen des Umfangs und der angestrebten Nutzungsdauer herausfordernde Aufgaben dar. Die Zerlegung gem\u00e4\u00df Separation of Concerns bildet ein grundlegendes Prinzip zur Verbesserung der Wartbarkeit eines Systems, weil es zu starker Kapselung und zu geringer Kopplung von Komponenten f\u00fchrt. Features stehen bei der Entwicklung von Produktlinien wichtige Abstraktionen zur Verf\u00fcgung. Ihre direkte Verbindung mit der Architektur tr\u00e4gt zu vereinfachter Wartung und Evolution bei. In der hier vorgestellten Methode Feature-Architecture Mapping (FArM) werden Features zur Steuerung der Architekturentwicklung verwendet. Dieser Beitrag stellt die Umsetzung von (nicht-funktionalen) Qualit\u00e4ts-Features durch die Methode FArM vor. Solche Qualit\u00e4ts-bezogenen Features lassen sich \u00fcblicherweise nicht direkt in Architekturmerkmale abbilden; Defizite der Wartbarkeit sind eine h\u00e4ufige Folge. Das Vorgehen bei der Umsetzung wird anhand einer Produktlinie f\u00fcr mobile Kommunikationsger\u00e4te erl\u00e4utert, die Komponenten mit Plug-In-Schnittstellen aufweist.", "num_citations": "2\n", "authors": ["129"]}
{"title": "8 Application of Feature Modeling for Architecture Recovery\n", "abstract": " The available evidence in a legacy software system often is not sufficient for its understanding and recovery. In most cases the software documentation is outdated and poor. It is possible to argue that the most reliable information is in the source code. Nevertheless a significant knowledge about the problem domain is required to improve the facility for extraction of useful architectural information. In this paper is proposed an approach for applying system domain knowledge for program understanding. This approach determines an architecture recovery process initiated at the level of domain knowledge and supported with feature models.", "num_citations": "2\n", "authors": ["129"]}
{"title": "Erhebung von Trace Links f\u00fcr die koordinierte, plattform\u00fcbergreifende Co-Evolution portierter Software\n", "abstract": " H\u00e4ufig ist es notwendig, bestehende Software zu portieren, um Anwendungen f\u00fcr Nutzer neuer Plattformen zug\u00e4nglich zu machen, oder um einmal implementierte Konzepte auf anderen Plattformen zu nutzen. Cross-Plattform-Frameworks wie Apache Cordova [14], Xamarin [15] oder Unity k\u00f6nnen zwar eingesetzt werden, um Software von vornherein f\u00fcr mehrere Plattformen zu entwickeln. Das nachtr\u00e4gliche Einsetzen dieser Frameworks geht jedoch mit dem Austausch einer bestehenden, reifen Implementation gegen eine unreife plattform\u00fcbergreifende Implementation einher. Daher entscheiden sich Entwickler regelm\u00e4\u00dfig daf\u00fcr, eine zus\u00e4tzliche Implementation f\u00fcr die neue Plattform zu erstellen, und die urspr\u00fcngliche Implementation unangetastet zu lassen. Dieses Vorgehen birgt den Nachteil, dass zwei Implementationen parallel weiterentwickelt werden m\u00fcssen. Das Verhalten der urspr\u00fcnglichen und der\u00a0\u2026", "num_citations": "1\n", "authors": ["129"]}
{"title": "Modellbasierte und Modellgetriebene Softwaremodernisierung\n", "abstract": " Die Notwendigkeit der Software-Architekturevolution motivierte Uwe Zdun aus den bekannten Ph\u00e4nomenen des Abdriftens (Architecture Drift) und der Erosion. Als entscheidende Gegenma\u00dfnahme schlug er die Rekonstruktion der Softwarearchitektur vor, wobei architektonische Abstraktionen und Sichten wesentliche Bestandteile der Rekonstruktion sind. Er diskutierte die Vor-und Nachteile existierender Bottom-up-, Topdown-und hybrider Rekonstruktionsverfahren und leitete hieraus drei wesentliche Herausforderungen ab:(A) Abstraktionen auf verschiedenen Granularit\u00e4tsebenen,(B) Traceability zwischen Architekturmodellen und Code sowie (C) Schritthalten mit der fortschreitenden Evolution der Software. Als L\u00f6sung stellte Zdun einen modellgetriebenen Ansatz vor. Mit einer Domain-Specific Language (DSL) werden Abbildungen zwischen Architektursichten spezifiziert, so dass zB aus Klassenmodellen automatisch Komponentenmodelle generiert und ebenfalls mittels automatischer Modelltransformationen Traceability-Links erstellt werden k\u00f6nnen. Mithilfe von Modellvergleichen k\u00f6nnen dann Unterschiede zwischen Versionen des Komponentenmodells, dh dem rekonstruierten und dem existierenden oder vorherigen Architekturmodell, identifiziert werden. Durch einfache Filter, die die Abstraktion unterst\u00fctzen, und die Pr\u00fcfung von Design Constraints k\u00f6nnen effektiv Abweichungen zwischen Architekturmodell und Code im Transformationsprozess entdeckt werden. In empirischen Untersuchungen konnte gezeigt werden, dass Traceability-Links eine wichtige Rolle f\u00fcr das Verstehen der architektonischen Abstraktionen spielen.", "num_citations": "1\n", "authors": ["129"]}
{"title": "Towards Optimization of Design Decisions for Embedded Systems by Exploiting Dependency Relationships.\n", "abstract": " Design decisions for the development of embedded systems demand for a consideration of complex goals and constraints. In order to reduce risks and optimize the design, model-based approaches are needed for an explicit representation of goals and constraints as well as for early assessments. The explicit representation of dependencies is required to make design decisions in a reasonable way. Existing works do not sufficiently support the mapping between problem space and solution space together with a consideration of technological constraints. In this paper the Goal Solution Scheme approach developed for software architectural design is extended for the development of embedded systems considering specific needs for flexible decisions late in the development process. The adaptation of the approach for the relevant goals and development steps of embedded systems is illustrated by its application in a case study of a complex embedded system project.", "num_citations": "1\n", "authors": ["129"]}
{"title": "Design Decision Support for Evolvability and Variability\n", "abstract": " Introduction Business critical software systems have to be maintained for a long time in order to conserve their business value and for the constant provision of business services. However, frequent changes due to enhancements, business process optimization, or technological improvements have to be performed. As a consequence, evolvability and variability of software systems constitute important quality goals for business success.", "num_citations": "1\n", "authors": ["129"]}
{"title": "Ein F\u00fcnf-Schichten-Modell f\u00fcr Business Object Frameworks\n", "abstract": " Der folgende Beitrag fordert ein F\u00fcnf-Schichten-Modell f\u00fcr Business Object Frameworks. Es besteht aus Pr\u00e4sentations-, Gesch\u00e4ftslogik-, Gesch\u00e4ftsobjekt-, Datenzugriffs-und Persistenzschicht. Die Autoren begr\u00fcnden, warum f\u00fcr Business Object Frameworks f\u00fcnf statt der sonst \u00fcblichen drei Schichten n\u00f6tig sind. F\u00fcr jede einzelne Schicht werden Aufgaben identifiziert, Probleme beschrieben und die zu treffenden Designentscheidungen diskutiert.We advocate a 5-layer architecture for business object frameworks with the layers: presentation, business process, business entity, data access, and data storage, instead of the more common 3-layer architecture, and give reasons why the 5 layers are required. We have collected and list, for each of the layers, the responsibilities it must fulfill and problems which may arise, together with a reasoning.", "num_citations": "1\n", "authors": ["129"]}
{"title": "Methodical aspects for the development of product lines\n", "abstract": " Reuse is one of the most important aspects for improving the productivity of software development. Nowadays, reuse is mainly realized through object-oriented techniques. Software product line architectures are considered to be a very promising approach for software reuse on a high level. Despite advantages of software reuse, many problems during development and application occur in practice. The main problems in the development and application of product lines result from a poor or non-existing description and documentation. Furthermore, a suitable product line-oriented method for development and application, which is also supported by tools, is lacking. In this paper the evolutionary process for the development and application of product lines is explained and occurring problems are discussed. To support solving some of these problems two approaches are introduced. Activities based on these approaches can be integrated into software product line development processes. One approach deals with the engineering of family requirements using feature modeling techniques. The second approach supports the designing of product line components.", "num_citations": "1\n", "authors": ["129"]}
{"title": "Feature and Constraint Mapping for Configuration and Evolution of Variable Manufacturing Automation Systems\n", "abstract": " Nowadays, in the domain of manufacturing automation systems, the complexity of the design task demands for a comprehensive engineering approach. Model-based approaches are in use for detecting or even preventing design errors early to avoid costly rework later in the engineering process. Furthermore, customizability is required to meet the individual needs of customers. Current product line approaches do not cover the special challenges of the manufacturing automation system domain with several disciplines and modeling languages.This paper presents a product line approach to represent variability in the domain of manufacturing automation systems using common data exchange languages such as ReqIF and AutomationML. Firstly, we map feature model to domain artefact models. Secondly, we map constraints between domain artefacts onto constraints between features. The created feature mapping and constraint mapping enable to forward consistency checks from product level to product line level. Moreover, the mappings provide support for evolution of the feature model and the constraints. The approach is implemented by a prototype and the feasibility is evaluated in an industrial setting.", "num_citations": "1\n", "authors": ["129"]}