{"title": "Supporting model-to-model transformations: The vmt approach\n", "abstract": " The model-driven architecture approach (MDA) promotes software development as driven by a thorough modeling phase where application code is automatically generated from a platform specific UML model (PSM). The idea is that the PSM is itself derived from a platform independent UML model (PIM). Such code generation and model derivation are examples of model-to-model transformations.This paper presents the Visual Model Transformation (VMT) approach, which includes a transformation language and a tool to support UML model transformations. The transformation language is a visual declarative language that supports the specification, composition and reuse of model transformation rules. These rules make use of the OCL language and a visual notation to indicate the selection, creation, modification and removal of model elements. An abstract denotational semantics based on graph transformation is sketched for the VMT language. We also present the MEDAL tool, which is a prototype build on top of IBM/Rational XDE development environment, and is a first step towards tool support for the VMT approach.", "num_citations": "37\n", "authors": ["1521"]}
{"title": "A flexible requirements analysis approach for software product lines\n", "abstract": " Product Line Engineering (PLE) promotes the development of applications by reusing a set of software assets belonging to a given domain. Important research efforts have been devoted to the description of commonalties and variabilities among these assets yielding requirements engineering techniques such as feature modeling or use case variants. However, current product derivation techniques, which strive to automate the derivation process, are inflexible in that they fail to accommodate products that represent only a minor deviation from the original product line. Furthermore, PLE methodologies do not provide precise support to assist product derivation in such cases. In this paper, we address flexibility issues by introducing an analysis model, based on UML, OCL and use cases, that implicitly defines define product line variabilities and boundaries by means of constraints forbidding undesired products\u00a0\u2026", "num_citations": "26\n", "authors": ["1521"]}
{"title": "Abstract test case generation for behavioural testing of software product lines\n", "abstract": " In Model Based Testing (MBT), test cases are generated automatically from a partial representation of expected behaviour of the System Under Test (SUT)(ie, the model). For most industrial systems, it is impossible to generate all the possible test cases from the model. The test engineer recourse to generation algorithms that maximize a given coverage criterion, a metric indicating the percentage of possible behaviours of the SUT covered by the test cases. Our previous work redefined classical Transition Systems (TSs) criteria for SPLs, using Featured Transition Systems (FTSs), a mathematical structure to compactly represent the behaviour of a SPL, as model for test case generation. In this paper, we provide one all-states coverage driven generation algorithm and discuss its scalability and efficiency with respect to random generation. All-states and random generation are compared on fault-seeded FTSs.", "num_citations": "24\n", "authors": ["1521"]}
{"title": "SoC/SoPC development using MDD and MARTE profile\n", "abstract": " This paper presents a new methodology to develop SoC/SoPC applications. This methodology is based on UML and MDD and capitalizes the achievements of ''Electronic System Level'' community by taking into account the new MARTE profile dedicated to real-time embedded systems. In the MOPCOM SoC/SoPC research project, a tooling has been developed to support this SoC/SoPC methodology, the MARTE profile, HDL code generation and documentation generation. A Cognitive Radio demonstrator is presented to illustrate the methodologyand the tooling.", "num_citations": "23\n", "authors": ["1521"]}
{"title": "Using model transformation and architectural frameworks to support the software development process: The FIDJI approach\n", "abstract": " Framework-based development is a well-known software engineering practice which encourages reuse and thus reduces development costs. To improve maintainability and reuse, frameworks need to be modeled quite abstractly and provide specialization mechanisms to refine these models into concrete implementation. Hence they are candidates to address Model Driven Engineering (MDE) and Model Driven Architecture (MDA) challenges. Currently, few development methodologies for MDE integrate such frameworks in their processes. In this paper, we present a development approach called FIDJI, which bases its process on architectural framework specialization using model transformation and its associated CASE tool support.", "num_citations": "17\n", "authors": ["1521"]}
{"title": "Towards Formal Energy and Time Aware Behaviors in EAST-ADL: An MDE Approach\n", "abstract": " Energy-aware real-time (ERT) systems are increasingly complex and have pervaded various areas, from automotive to telecommunication systems. Dedicated UML-based modeling languages, such as EAST-ADL or MARTE have been proposed to harness this complexity. However, they provide limited support for modeling ERT constraints, in particular continuous energy consumption. To cope with this issue we introduce a formal interchange language, Extended Function-block Graphs (XFG), for modeling and analysis of ERT behaviors. An XFG UML profile augmenting EAST-ADL and MARTE is presented to facilitate modeling those behaviors by means of state machines. A set of mapping rules is proposed to automatically transform such profiled models into the XFG language.", "num_citations": "15\n", "authors": ["1521"]}
{"title": "Architecting software systems using model transformations and architectural frameworks\n", "abstract": " Software systems have become essential to many human activities and have proliferated thanks to various hardware innovations such as mobile computing (laptops, personal digital assistants, mobile phones) and networks (DSL, WIFI, GSM, etc.) enabling interactions between users and computer systems in virtually any place. This situation has created both a great complexity for such distributed systems to be designed and great expectations (mainly concerned with quality, time and induced costs of the software) from the users of these systems, requiring improvements in software engineering methods in order to meet these challenges. On the one hand, Model Driven Engineering (MDE), by allowing the description of software systems through abstractions and deriving useful system artifacts, harnesses inherent complexity of software systems and reduces time-to-market via model transformations. On the other hand, software product lines foster software reuse by proposing to develop applications based on a set of common assets belonging to a particular domain. Thus, when product line assets are carefully designed, both quality and time-to-market requirements can be achieved. Development methods that have resulted from the product line paradigm generally focus on defining common and variable assets to be reused by product line members. However, they hardly address the development of applications from the product line assets in a systematic way. Furthermore, those considering it propose automated but rather inflexible approaches that unnecessarily exclude products which, although addressab...", "num_citations": "14\n", "authors": ["1521"]}
{"title": "Model-based verification of energy-aware real-time automotive systems\n", "abstract": " EAST-ADL is an architectural description language dedicated to safety-critical automotive embedded system design with a focus on structural specification and behavioral constraints. The current concept of EAST-ADL provides limited support for modeling and analysis of Energy-aware Real-Time (ERT) behaviors due to the absence of energy constraints modeling notations and the lack of formal semantics. We address these limitations by extending the EAST-ADL notation with energy constraints and integrating this extension with formal modeling and analysis techniques. We provide a mapping scheme as the basis for automatic model transformation between the extended EAST-ADL and priced timed automata for model checking. This methodology has been implemented in a tool called A-BeTA and is demonstrated by means of the Brake-By-Wire case study. Our approach enables formal modeling and\u00a0\u2026", "num_citations": "13\n", "authors": ["1521"]}
{"title": "On quantitative requirements for product lines\n", "abstract": " Software Product Line Engineering (SPLE) aims at developing a large number of software systems that share a common and managed set of features [5]. In the past years, it has been an active area in both research and industry. SPLE aims at improving productivity and reducing the time, effort, and cost required to develop a family of products (also called variants). The key point to achieve this goal is to manage the variability among various products of a Software Product Line (SPL). Variability is commonly expressed in terms of features, ie, units of difference between software products. A product can thus be viewed as a set of features. Dependencies between features are typically represented in a Feature Model (FM)[11], whose ultimate purpose is to define which combinations of features (that is, which products) are valid [16]. Behavior of both the features and the core behavior (ie, the behavior shared by all\u00a0\u2026", "num_citations": "8\n", "authors": ["1521"]}
{"title": "Rigorous engineering of software architectures: Integrating ADLs, UML and development methodologies\n", "abstract": " Architecture engineering is an area that is under construction for being transferred to software engineers. Many results exist from high-level formal and conceptual approaches to basic good practices taken from industrial experiences. Descriptions and methodologies should be at least considered for architecture engineering. Two interesting approaches to architecture description are available: Architecture Description Languages (ADL) or modeling languages (especially UML). In the first case, efforts have been made to provide rigorous integrated languages dedicated to architecture engineering but unfortunately these languages are incomplete and not ready for technology transfer. Concerning UML, many approaches use UML models for partial architecture descriptions. In both cases, a few efforts have been made on methodology. This paper presents the current state of the art covering architecture descriptions and development methodologies for architecture engineering. We present a first integrated approach, called FIDJI that tries to take advantage from ADLs, UML, and some development methodologies. FIDJI uses UML for its models, MDA for its layering and ADLs for precision. Concerning methodology, FIDJI follows the HP recommendations and the notion of refinement and contracts taken from formal development methodologies. Finally, we briefly illustrate the use of the FIDJI approach by means of a real web-based distributed application.", "num_citations": "8\n", "authors": ["1521"]}
{"title": "Coherent Integration of Variability Mechanisms at the Require-ments Elicitation and Analysis Levels\n", "abstract": " Early phases of product line development can be separated in requirement elicitation and analysis. The former provides an abstract and informal description of the product line, while the latter provides a technical specification as precise and as complete as possible. The major problems we face are to define the content of each phase for optimal development cycle and to provide consistency between those phases. This paper aims at integrating product line variability mechanisms between requirements elicitation and analysis levels. First, we present a requirements elicitation template based on use case variants. Then, product analysis phase is done using a generative mechanism starting from the core analysis assets and specifying the variation covered by the use case variants. These mechanisms are coherently related by means of consistency rules and the same approach is employed to integrate feature models with the analysis phase. Finally elements for variability integration reasoning are derived on the basis of these rules.", "num_citations": "7\n", "authors": ["1521"]}
{"title": "XFG Language and its Profile for Modeling and Analysis of Energy-aware and real-timed behaviors\n", "abstract": " This report introduces a formal specification language XFG (extended function-block graphs), which can be used as IF (interchange format) for Timed Automata-based input modeling languages and model checkers. Section 1 informally represents a general introduction to XFG. The concrete E-BNF syntax rules are presented in Section 2. Section 3 defines complete syntax and semantics of the langauge. Section 4 gives a running example of the Brake-By-Wire (BBW) system and part of the XFG specification of the system. We propose a modelbased approach to system engineering using XFG in Section 5. Section 6 defines a UML profile for XFG language based on EAST-ADL and MARTE. Finally, Section 7 provides model-to-text transformations to convert the profiled models into XFG language.1 eXtended Function-block Graphs: XFGAn XFG (eXtended Function-block Graphs) language is an extension of timed automata [2]. It is a formal specification interchange format language for modeling and analysis of energy-aware real-time (ERT) systems. The XFG format is a textual description language and it captures the axiomatic and operational specification of function aspects, and ERT behavior. The XFG language aims to establish interoperability of various tools by means of model transformations to and from XFG: The XFG is designed as an engineering language for formal specification and verification, serving as the Hybrid and Timed Automata (TA)[2, 1] based input modeling language for various model checkers such as UPPAAL series tool [6, 21], KRONOS [8, 7], and HYTECH [12, 11, 13], etc. An XFG system consisting of a number of graphes\u00a0\u2026", "num_citations": "6\n", "authors": ["1521"]}
{"title": "Software Product Lines for creating Service Oriented Applications\n", "abstract": " Service-oriented architectures and software product lines are currently two approaches that get a lot of attention in research and practice. They both promise to aid in the development of flexible, cost-effective software systems and to support a high level of reuse.These approaches to software development share a common goal. They both encourage an organization to reuse existing assets and capabilities rather than redeveloping them again and again for new systems. These approaches enable organizations to gain enormously on reuse. They are able to achieve many desired benefits such as productivity gains, decreased development costs, and improved time to market, higher reliability, and competitive advantage [32].", "num_citations": "6\n", "authors": ["1521"]}
{"title": "AbsCon: A Test Concretizer for Model-based Testing\n", "abstract": " Test definition and execution is an essential but time-consuming task during system development. To speed up the process, model-based testing and other related approaches propose to generate/write abstract test cases and to concretize them using either transformations, an adapter, or a mixture of the two. QTaste is an industrial data-driven test case definition and execution environment used to perform black-box testing on various kinds of systems. QTaste's test cases are manually written in Python and use an adapter, called test API, to execute operations on the System Under Test (SUT) interfaces. In this paper, we describe AbsCon (Abstract test case Concretizer), a plugin used to generate test cases executable in QTaste based on their definition: i.e., sequences of abstract actions and assertions. AbsCon uses programmer friendly mappings (written in Python) for the SUT's interfaces, actions, and assertions, to\u00a0\u2026", "num_citations": "4\n", "authors": ["1521"]}
{"title": "Model-Based Mutation Operators for Timed Systems: A Taxonomy and Research Agenda\n", "abstract": " Mutation testing relies on the principle of artificially injecting faults in systems to create mutants, in order to either assess the sensitivity of existing test suites, or generate test cases that are able to find real faults. Mutation testing has been employed in a variety of application areas and at various levels of abstraction (code and models). In this paper, we focus on model-based mutation testing for timed systems. In order to cartography the field, we provide a taxonomy of mutation operators and discuss their usages on various formalisms, such as timed automata or synchronous languages. We also delineate a research agenda for the field addressing mutation costs, the impact of delays in operators specification and mutation equivalence.", "num_citations": "3\n", "authors": ["1521"]}