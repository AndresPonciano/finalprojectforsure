{"title": "Handbook of floating-point arithmetic\n", "abstract": " Floating-point arithmetic is the most widely used way of implementing real-number arithmetic on modern computers. However, making such an arithmetic reliable and portable, yet fast, is a very difficult task. As a result, floating-point arithmetic is far from being exploited to its full potential. This handbook aims to provide a complete overview of modern floating-point arithmetic. So that the techniques presented can be put directly into practice in actual coding or design, they are illustrated, whenever possible, by a corresponding program. The handbook is designed for programmers of numerical applications, compiler designers, programmers of floating-point algorithms, designers of arithmetic operators, and more generally, students and researchers in numerical analysis who wish to better understand a tool used in their daily work and research.", "num_citations": "761\n", "authors": ["1755"]}
{"title": "Certifying the floating-point implementation of an elementary function using Gappa\n", "abstract": " High confidence in floating-point programs requires proving numerical properties of final and intermediate values. One may need to guarantee that a value stays within some range, or that the error relative to some ideal value is well bounded. This certification may require a time-consuming proof for each line of code, and it is usually broken by the smallest change to the code, e.g., for maintenance or optimization purpose. Certifying floating-point programs by hand is, therefore, very tedious and error-prone. The Gappa proof assistant is designed to make this task both easier and more secure, due to the following novel features: It automates the evaluation and propagation of rounding errors using interval arithmetic. Its input format is very close to the actual code to validate. It can be used incrementally to prove complex mathematical properties pertaining to the code. It generates a formal proof of the results, which can\u00a0\u2026", "num_citations": "122\n", "authors": ["1755"]}
{"title": "Certification of bounds on expressions involving rounded operators\n", "abstract": " Gappa is a tool designed to formally verify the correctness of numerical software and hardware. It uses interval arithmetic and forward error analysis to bound mathematical expressions that involve rounded as well as exact operators. It then generates a theorem and its proof for each verified enclosure. This proof can be automatically checked with a proof assistant, such as Coq or HOL Light. It relies on a large companion library of facts that we have developed. This Coq library provides theorems dealing with addition, multiplication, division, and square root, for both fixed- and floating-point arithmetics. Gappa uses multiple-precision dyadic fractions for the endpoints of intervals and performs forward error analysis on rounded operators when necessary. When asked, Gappa reports the best bounds it is able to reach for a given expression in a given context. This feature can be used to identify where the set of facts and\u00a0\u2026", "num_citations": "120\n", "authors": ["1755"]}
{"title": "Assisted verification of elementary functions using Gappa\n", "abstract": " The implementation of a correctly rounded or interval elementary function needs to be proven carefully in the very last details. The proof requires a tight bound on the overall error of the implementation with respect to the mathematical function. Such work is function specific, concerns tens of lines of code for each function, and will usually be broken by the smallest change to the code (eg for maintenance or optimization purpose). Therefore, it is very tedious and error-prone if done by hand. This article discusses the use of the Gappa proof assistant in this context. Gappa has two main advantages over previous approaches: Its input format is very close to the actual C code to validate, and it automates error evaluation and propagation using interval arithmetic. Besides, it can be used to incrementally prove complex mathematical properties pertaining to the C code. Yet it does not require any specific knowledge about\u00a0\u2026", "num_citations": "106\n", "authors": ["1755"]}
{"title": "The design of the Boost interval arithmetic library\n", "abstract": " We present the design of the Boost interval arithmetic library, a C++ library designed to handle mathematical intervals efficiently and in a generic way. Interval computations are an essential tool for reliable computing. Increasingly a number of mathematical proofs have relied on global optimization problems solved using branch-and-bound algorithms with interval computations; it is therefore extremely important to have a mathematically correct implementation of interval arithmetic. Various implementations exist with diverse semantics. Our design is unique in that it uses policies to specify three independent variable behaviors: rounding, checking, and comparisons. As a result, with the proper policies, our interval library is able to emulate almost any of the specialized libraries available for interval arithmetic, without any loss of performance nor sacrificing the ease of use. This library is openly available at www. boost. org.", "num_citations": "77\n", "authors": ["1755"]}
{"title": "Guaranteed proofs using interval arithmetic\n", "abstract": " This paper presents a set of tools for mechanical reasoning of numerical bounds using interval arithmetic. The tools implement two techniques for reducing decorrelation: interval splitting and Taylor's series expansions. Although the tools are designed for the proof assistant system PVS, expertise on PVS is not required. The ultimate goal of the tools is to provide guaranteed proofs of numerical properties with a minimal human-theorem prover interaction.", "num_citations": "75\n", "authors": ["1755"]}
{"title": "Proving bounds on real-valued functions with computations\n", "abstract": " Interval-based methods are commonly used for computing numerical bounds on expressions and proving inequalities on real numbers. Yet they are hardly used in proof assistants, as the large amount of numerical computations they require keeps them out of reach from deductive proof processes. However, evaluating programs inside proofs is an efficient way for reducing the size of proof terms while performing numerous computations. This work shows how programs combining automatic differentiation with floating-point and interval arithmetic can be used as efficient yet certified solvers. They have been implemented in a library for the Coq proof system. This library provides tactics for proving inequalities on real-valued expressions.", "num_citations": "63\n", "authors": ["1755"]}
{"title": "Floating-point arithmetic in the Coq system\n", "abstract": " The process of proving some mathematical theorems can be greatly reduced by relying on numerically-intensive computations with a certified arithmetic. This article presents a formalization of floating-point arithmetic that makes it possible to efficiently compute inside the proofs of the Coq system. This certified library is a multi-radix and multi-precision implementation free from underflow and overflow. It provides the basic arithmetic operators and a few elementary functions.", "num_citations": "43\n", "authors": ["1755"]}
{"title": "De l\u2019arithm\u00e9tique d\u2019intervalles \u00e0 la certification de programmes\n", "abstract": " De l\u2019arithm\u00e9tique d\u2019intervalles `a la certification de programmes Page 1 Introduction Bounds Rounding Errors Conclusion De l\u2019arithm\u00e9tique d\u2019intervalles `a la certification de programmes Guillaume Melquiond Sous la direction de Marc Daumas Laboratoire de l\u2019Informatique du Parall\u00e9lisme Ar\u00e9naire, LIP, CNRS\u2013ENSL\u2013INRIA\u2013UCBL 2006-11-21 Guillaume Melquiond De l\u2019arithm\u00e9tique d\u2019intervalles `a la certification de programmes Page 2 Introduction Bounds Rounding Errors Conclusion From interval arithmetic to program certification Guillaume Melquiond Advisor: Marc Daumas Laboratoire de l\u2019Informatique du Parall\u00e9lisme Ar\u00e9naire, LIP, CNRS\u2013ENSL\u2013INRIA\u2013UCBL 2006-11-21 Guillaume Melquiond From interval arithmetic to program certification Page 3 Introduction Bounds Rounding Errors Conclusion Motivation Orientation Gappa Motivation Floating-point and fixed-point datatypes suffer from: limited range \u21d2 \u2026", "num_citations": "43\n", "authors": ["1755"]}
{"title": "Formally certified floating-point filters for homogeneous geometric predicates\n", "abstract": " Floating-point arithmetic provides a fast but inexact way of       computing geometric predicates. In order for these predicates to be       exact, it is important to rule out all the numerical situations where       floating-point computations could lead to wrong results. Taking into       account all the potential problems is a tedious work to do by hand. We       study in this paper a floating-point implementation of a filter for the       orientation-2 predicate, and how a formal and partially automatized       verification of this algorithm avoided many pitfalls. The presented       method is not limited to this particular predicate, it can easily be used       to produce correct semi-static floating-point filters for other       geometric predicates.", "num_citations": "40\n", "authors": ["1755"]}
{"title": "The Boost interval arithmetic library\n", "abstract": " We report on the design of the Boost interval arithmetic library, a C++ library designed to efficiently handle mathematical intervals in a generic way. The design of the library is unique in that it uses policies to specify the variable behaviors: rounding, checking, comparisons. As a result, with the proper policies, our interval library is able to emulate almost any of the specialized libraries available for interval arithmetic. This library is openly available at www. boost. org. Using this library, we then examine interval-based filters to compute the sign of a determinant, proposed by Burnikel and two authors of the library, and revisit and extend their experiments. We also illustrate other uses of the library.", "num_citations": "40\n", "authors": ["1755"]}
{"title": "A simplex-based extension of Fourier-Motzkin for solving linear integer arithmetic\n", "abstract": " This paper describes a novel decision procedure for quantifier-free linear integer arithmetic. Standard techniques usually relax the initial problem to the rational domain and then proceed either by projection (e.g.                 Omega-Test) or by branching/cutting methods (branch-and-bound, branch-and-cut, Gomory cuts). Our approach tries to bridge the gap between the two techniques: it interleaves an exhaustive search for a model with bounds inference. These bounds are computed provided an oracle capable of finding constant positive linear combinations of affine forms. We also show how to design an efficient oracle based on the Simplex procedure. Our algorithm is proved sound, complete, and terminating and is implemented in the alt-ergo theorem prover. Experimental results are promising and show that our approach is competitive with state-of-the-art SMT solvers.", "num_citations": "30\n", "authors": ["1755"]}
{"title": "Proving tight bounds on univariate expressions with elementary functions in Coq\n", "abstract": " The verification of floating-point mathematical libraries requires computing numerical bounds on approximation errors. Due to the tightness of these bounds and the peculiar structure of approximation errors, such a verification is out of the reach of generic tools such as computer algebra systems. In fact, the inherent difficulty of computing such bounds often mandates a formal proof of them. In this paper, we present a tactic for the Coq proof assistant that is designed to automatically and formally prove bounds on univariate expressions. It is based on a formalization of floating-point and interval arithmetic, associated with an on-the-fly computation of Taylor expansions. All the computations are performed inside Coq\u2019s logic, in a reflexive setting. This paper also compares our tactic with various existing tools on a large set of examples.", "num_citations": "29\n", "authors": ["1755"]}
{"title": "Generating formally certified bounds on values and round-off errors\n", "abstract": " We present a new tool that generates bounds on the values and the round-off errors of programs using floating point operations. The tool is based on forward error analysis and interval arithmetic. The novelty of our tool is that it produces a formal proof of the bounds that can be checked independently using an automatic proof checker such as Coq and a complete model of floating point arithmetic. For the first time ever, we can easily certify that simple numerical programs such as the ones usually found in real time applications do not overflow and that round-off errors are below acceptable thresholds. Such level of quality should be compulsory on safety critical applications. As our tool is easy to handle, it could also be used for many pieces of software.", "num_citations": "28\n", "authors": ["1755"]}
{"title": "Computing predecessor and successor in rounding to nearest\n", "abstract": " We give simple and efficient methods to compute and/or estimate the predecessor and successor of a floating-point number using only floating-point operations in rounding to nearest. This may be used to simulate interval operations, in which case the quality in terms of the diameter of the result is significantly improved compared to existing approaches.", "num_citations": "24\n", "authors": ["1755"]}
{"title": "Improving Real Analysis in Coq: a User-Friendly Approach to Integrals and Derivatives\n", "abstract": " Verification of numerical analysis programs requires dealing with derivatives and integrals. High confidence in this process can be achieved using a formal proof checker, such as Coq. Its standard library provides an axiomatization of real numbers and various lemmas about real analysis, which may be used for this purpose. Unfortunately, its definitions of derivative and integral are unpractical as they are partial functions that demand a proof term. This proof term makes the handling of mathematical formulas cumbersome and does not conform to traditional analysis. Other proof assistants usually do not suffer from this issue; for instance, they may rely on Hilbert\u2019s epsilon to get total operators. In this paper, we propose a way to define total operators for derivative and integral without having to extend Coq\u2019s standard axiomatization of real numbers. We proved the compatibility of our definitions with the standard\u00a0\u2026", "num_citations": "20\n", "authors": ["1755"]}
{"title": "A proposal to add interval arithmetic to the C++ standard library\n", "abstract": " Interval arithmetic (IA) is a basic tool for certified mathematical computations. Basic interval arithmetic is presented in many references (eg [5, 11, 15]). Rather than recalling the mathematical definition of IA, we refer the reader to our accompanying paper in which we describe the design of the Boost. Interval library. That paper [2] contains a definition of IA in the mathematical context of an ordered field (not necessarily the reals, although this proposal only touches the basic floating point types), along with a discussion of the interval representations, rounding modes, basic operations on intervals, including divisions, unbounded and empty intervals, and possible comparisons schemes.Concerning previous work, there exist many implementations of IA (see [8, 4, 9, 13, 14, 12] for six typical C++ implementations; more can be found on the Interval web page [6], including for other languages). In particular, the ancestor of this proposal is the Boost interval library [3]. They provide similar but mutually incompatible interfaces, hence the desire to define a standard interface for this functionality.", "num_citations": "20\n", "authors": ["1755"]}
{"title": "Formal certification of arithmetic filters for geometric predicates\n", "abstract": " Floating-point arithmetic provides a fast but inexact way of computing geometric predicates. In order for these predicates to be exact, it is important to rule out all the numerical situations where floating-point computations could lead to wrong results. Taking into account all the potential problems is a tedious work to do by hand. We study in this paper a floating-point implementation of a filter for the orientation-2 predicate, and how a formal and partially automatized verification of this algorithm avoided many pitfalls. The presented method is not limited to this particular predicate, it can easily be used to produce correct semi-static floating-point filters for other geometric predicates.", "num_citations": "20\n", "authors": ["1755"]}
{"title": "Formally Verified Approximations of Definite Integrals\n", "abstract": " Finding an elementary form for an antiderivative is often a difficult task, so numerical integration has become a common tool when it comes to making sense of a definite integral. Some of the numerical integration methods can even be made rigorous: not only do they compute an approximation of the integral value but they also bound its inaccuracy. Yet numerical integration is still missing from the toolbox when performing formal proofs in analysis. This paper presents an efficient method for automatically computing and proving bounds on some definite integrals inside the Coq formal system. Our approach is not based on traditional quadrature methods such as Newton\u2013Cotes formulas. Instead, it relies on computing and evaluating antiderivatives of rigorous polynomial approximations, combined with an adaptive domain splitting. Our approach also handles improper integrals, provided that a factor of the\u00a0\u2026", "num_citations": "18\n", "authors": ["1755"]}
{"title": "Diff\u00e9rentiabilit\u00e9 et int\u00e9grabilit\u00e9 en Coq. Application \u00e0 la formule de d'Alembert\n", "abstract": " La biblioth\u00e8que standard de Coq contient de nombreuses d\u00e9finitions et lemmes permettant de faire de l'analyse, mais ceux-ci se limitent \u00e0 l'\u00e9tude de fonctions totales \u00e0 une seule variable. M\u00eame si l'\u00e9tude des d\u00e9riv\u00e9es partielles de fonctions \u00e0 deux variables peut le plus souvent r\u00e9utiliser les lemmes existants, l'\u00e9tude de la formule de d'Alembert comme solution de l'\u00e9quation des ondes en dimension 1 montre les limites de cette approche. La formalisation en Coq de cette \u00e9tude a ainsi n\u00e9cessit\u00e9 de d\u00e9velopper une th\u00e9orie sur la d\u00e9rivation des int\u00e9grales \u00e0 param\u00e8tre et des fonctions \u00e0 deux variables. De plus, d\u00e9montrer en Coq la d\u00e9rivabilit\u00e9 de la formule de d'Alembert s'est r\u00e9v\u00e9l\u00e9 \u00eatre excessivement long. Nous avons donc construit une tactique par r\u00e9flexion permettant de r\u00e9sumer l'expression \"par application des th\u00e9or\u00e8mes g\u00e9n\u00e9raux de d\u00e9rivation\" souvent utilis\u00e9e dans les d\u00e9monstrations sur papier.", "num_citations": "18\n", "authors": ["1755"]}
{"title": "How to Get an Efficient yet Verified Arbitrary-Precision Integer Library\n", "abstract": " The GNU Multi-Precision library is a widely used, safety-critical, library for arbitrary-precision arithmetic. Its source code is written in C and assembly, and includes intricate state-of-the-art algorithms for the sake of high performance. Formally verifying the functional behavior of such highly optimized code, not designed with verification in mind, is challenging. We present a fully verified library designed using the Why3 program verifier. The use of a dedicated memory model makes it possible to have the Why3 code be very similar to the original GMP code. This library is extracted to C and is compatible and performance-competitive with GMP.", "num_citations": "17\n", "authors": ["1755"]}
{"title": "Some issues related to double rounding\n", "abstract": " Double rounding is a phenomenon that may occur when different floating-point precisions are available on the same system. Although double rounding is, in general, innocuous, it may change the behavior of some useful small floating-point algorithms. We analyze the potential influence of double rounding on the Fast2Sum and 2Sum algorithms, on some summation algorithms, and Veltkamp\u2019s splitting.", "num_citations": "17\n", "authors": ["1755"]}
{"title": "IEEE Interval Standard Working Group-P1788: Current Status\n", "abstract": " Late 2008, at SCAN 2008 in El Paso, TX, an effort to standardize interval computations was started by a working group of the IEEE Microprocessor Standards Committee, titled the Interval Arithmetic Working Group of the IEEE P1788 Standard. This paper describes the goals of this effort, the history of the working group, and how it relates to the IEEE 754 Standard. It gives a brief overview of the policies and procedures for constructing the standard, and its expected structure. It also presents some of the questions the group may have to solve in the future.", "num_citations": "17\n", "authors": ["1755"]}
{"title": "A three-tier strategy for reasoning about floating-point numbers in SMT\n", "abstract": " The SMT-LIB standard defines a formal semantics for a theory of floating-point (FP) arithmetic (FPA). This formalization reduces FP operations to reals by means of a rounding operator, as done in the IEEE-754 standard. Closely following this description, we propose a three-tier strategy to reason about FPA in SMT solvers. The first layer is a purely axiomatic implementation of the automatable semantics of the SMT-LIB standard. It reasons with exceptional cases (e.g. overflows, division by zero, undefined operations) and reduces finite representable FP expressions to reals using the rounding operator. At the core of our strategy, a second layer handles a set of lemmas about the properties of rounding. For these lemmas to be used effectively, we extend the instantiation mechanism of SMT solvers to tightly cooperate with the third layer, the NRA engine of SMT solvers, which provides interval information. We\u00a0\u2026", "num_citations": "16\n", "authors": ["1755"]}
{"title": "When double rounding is odd\n", "abstract": " Many general purpose processors (including Intel's) may not always produce the correctly rounded result of a floating-point operation due to double rounding. Instead of rounding the value to the working precision, the value is first rounded in an intermediate extended precision and then rounded in the working precision; this often means a loss of accuracy.  We suggest the use of rounding to odd as the first rounding in order to regain this accuracy: we prove that the double rounding then gives the correct rounding to the nearest value. To increase the trust on this result, as this rounding is unusual and this property is surprising, we formally proved this property using the Coq automatic proof checker.", "num_citations": "15\n", "authors": ["1755"]}
{"title": "Built-in Treatment of an Axiomatic Floating-Point Theory for SMT Solvers\n", "abstract": " The treatment of the axiomatic theory of floating-point numbers is out of reach of current SMT solvers, especially when it comes to automatic reasoning on approximation errors. In this paper, we describe a dedicated procedure for such a theory, which provides an interface akin to the instantiation mechanism of an SMT solver. This procedure is based on the approach of the Gappa tool: it performs saturation of consequences of the axioms, in order to refine bounds on expressions. In addition to the original approach, bounds are further refined by a constraint solver for linear arithmetic. Combined with the natural support for equalities provided by SMT solvers, our approach improves the treatment of goals coming from deductive verification of numerical programs. We have implemented it in the Alt-Ergo SMT solver.", "num_citations": "13\n", "authors": ["1755"]}
{"title": "A Why3 framework for reflection proofs and its application to GMP\u2019s algorithms\n", "abstract": " Earlier work showed that automatic verification of GMP\u2019s algorithms using Why3 exceeds the current capabilities of automatic solvers. To complete this verification, numerous cut indications had to be supplied by the user, slowing the project to a crawl. This paper shows how we have extended Why3 with a framework for proofs by reflection, with minimal impact on the trusted computing base. This framework makes it easy to write dedicated decision procedures that make full use of Why3\u2019s imperative features and are formally verified. We evaluate how much work could have been saved when verifying GMP\u2019s algorithms, had this framework been available. This approach opens the way to efficiently tackling the further verification of GMP\u2019s algorithms.", "num_citations": "11\n", "authors": ["1755"]}
{"title": "Proof and certification for an accurate discriminant\n", "abstract": " Professor William Kahan has proposed in a November 2004 file available on the Internet [1] algorithms and rationales for a precise discriminant for quadratic equations. The file includes a portable MATLAB implementation that checks for many possible host behaviors. Proofs were described as \u201cfar longer and trickier\u201d than the algorithms and programs and the author deferred their publication.", "num_citations": "8\n", "authors": ["1755"]}
{"title": "Formal Verification of a State-of-the-Art Integer Square Root\n", "abstract": " We present the automatic formal verification of a state-of-the-art algorithm from the GMP library that computes the square root of a 64-bit integer. Although it uses only integer operations, the best way to understand the program is to view it as a fixed-point arithmetic algorithm that implements Newton's method. The C code is short but intricate, involving magic constants and intentional arithmetic overflows. We have verified the algorithm using the Why3 tool and automated solvers such as Gappa.", "num_citations": "7\n", "authors": ["1755"]}
{"title": "Inductive verification of hybrid automata with strongest postcondition calculus\n", "abstract": " Safety verification of hybrid systems is a key technique in developing embedded systems that have a strong coupling with the physical environment. We propose an automated logical analytic method for verifying a class of hybrid automata. The problems are more general than those solved by the existing model checkers: our method can verify models with symbolic parameters and nonlinear equations as well. First, we encode the execution trace of a hybrid automaton as an imperative program. Its safety property is then translated into proof obligations by strongest postcondition calculus. Finally, these logic formulas are discharged by state-of-the-art arithmetic solvers (e.g., Mathematica). Our proposed algorithm efficiently performs inductive reasoning by unrolling the execution for some steps and generating loop invariants from verification failures. Our experimental results along with examples taken from\u00a0\u2026", "num_citations": "6\n", "authors": ["1755"]}
{"title": "Numerical Approximation of the Masser-Gramain Constant to Four Decimal Digits: delta= 1.819...\n", "abstract": " We prove that the constant  studied by Masser, Gramain, and Weber, satisfies , and disprove a conjecture of Gramain. This constant is a two-dimensional analogue of the Euler-Mascheroni constant; it is obtained by computing the radius  of the smallest disk of the plane containing  Gaussian integers. While we have used the original algorithm for smaller values of , the bounds above come from methods we developed to obtain guaranteed enclosures for larger values of .", "num_citations": "3\n", "authors": ["1755"]}
{"title": "Arithm\u00e9tique des ordinateurs et preuves formelles\n", "abstract": " Nous confions \u00e0 nos ordinateurs de nombreux calculs (m\u00e9t\u00e9o, simulations a\u00e9ronautiques, jeux vid\u00e9os, feuilles Excel...) et nous consid\u00e9rons naturellement que l'ordinateur fournira une r\u00e9ponse juste. Malheureusement, la machine utilise une arithm\u00e9tique dite flottante, qui a ses contraintes. Ainsi, chaque calcul est effectu\u00e9 avec un certain nombre de chiffres (souvent environ 15 chiffres d\u00e9cimaux) et donc chaque calcul peut cr\u00e9er une erreur, certes faible, mais qui peut s'accumuler avec les pr\u00e9c\u00e9dentes pour fournir un r\u00e9sultat compl\u00e8tement faux. Ce cours montrera tout d'abord la fa\u00e7on dont l'ordinateur calcule, mais aussi comment compenser ou tirer partie de ces erreurs. Il pr\u00e9sentera ensuite la notion de preuve formelle qui permet de s'assurer de la correction d'un th\u00e9or\u00e8me math\u00e9matique et de sa preuve. Avec cela, on pourra produire des preuves d'algorithmes qui utilisent l'arithm\u00e9tique des ordinateurs.", "num_citations": "3\n", "authors": ["1755"]}
{"title": "A proposal for the C++ standard: Bool_set, multi-valued logic\n", "abstract": " We propose a design for multi-valued logic, for integration into the C++ standard. The main motivation for this class comes from interval arithmetic, where it can be conveniently used as return type of comparison operators. It also has many other potential applications.", "num_citations": "3\n", "authors": ["1755"]}
{"title": "Generating certified properties for numerical expressions and their evaluations\n", "abstract": " \u041e \u0425 \u0436 \u0439\u0431 \u0437 \u0432 \u0439 \u0430\u0430 \u0439\u0431 \u0425 \u0430\u0435\u0439 \u0433\u0432 \u0432\u0433\u0436\u0431 \u0430\u0430\u043d \u0433\u0432\u0437 \u0436 \u0438 \u0438 \u0438 \u043c \u0434\u0438 \u0433\u0432 \u0430 \u043a \u0433\u0436 \u0433 \u0433\u0432 \u0433\u0434 \u0436 \u0438 \u0433\u0432 \u0414\u0437\u0439 \u0437 \u043a \u0437 \u0433\u0432 \u043d \u043e \u0436\u0433\u0418 \u0432 \u0433\u043a \u0436 \u0433\u043b \u0433\u0436 \u0432 \u0432\u043a \u0430 \u0433\u0434 \u0436 \u0432 \u0415 \u0433\u0436\u0436 \u0438\u0430\u043d \u0432 \u0430 \u043d \u0438 \u0436 \u0437\u0438 \u0433 \u0434\u0436\u0433 \u0436 \u0431 \u0430 \u0432 \u0438\u0433 \u0431 \u0432 \u0432 \u0439\u0430 \u0436 \u0437\u0439\u0430\u0438\u0437 \u0437 \u0432\u0433\u0438 \u0432 \u043c \u0434\u0438 \u0433\u0432 \u0430 \u043a \u0433\u0436 \u0433 \u0438 \u0434\u0436\u0433 \u0436 \u0431\u041a", "num_citations": "2\n", "authors": ["1755"]}
{"title": "When double rounding is odd\n", "abstract": " Double rounding consists in a first rounding in an intermediate extended precision and then a second rounding in the working precision. The natural question is then of the precision and correctness of the final result. Unfortunately, the used double rounding algorithms do not obtain a correct rounding of the initial value. We prove an efficient algorithm for the double rounding to give the correct rounding to the nearest value assuming the first rounding is to odd. As this rounding is unusual and this property is surprising, we formally proved this property using the Coq automatic proof checker.", "num_citations": "2\n", "authors": ["1755"]}
{"title": "A strong call-by-need calculus\n", "abstract": " We present a call-by-need \u03bb-calculus that enables strong reduction (that is, reduction inside the body of abstractions) and guarantees that arguments are only evaluated if needed and at most once. This calculus uses explicit substitutions and subsumes the existing strong-call-by-need strategy, but allows for more reduction sequences, and often shorter ones, while preserving the neededness. The calculus is shown to be normalizing in a strong sense: Whenever a \u03bb-term t admits a normal form n in the \u03bb-calculus, then any reduction sequence from t in the calculus eventually reaches the normal form n. We also exhibit a restriction of this calculus that has the diamond property and that only performs reduction sequences of minimal length, which makes it systematically better than the existing strategy.", "num_citations": "1\n", "authors": ["1755"]}
{"title": "WhyMP, a formally verified arbitrary-precision integer library\n", "abstract": " Arbitrary-precision integer libraries such as GMP are a critical building block of computer algebra systems. GMP provides state-of-the-art algorithms that are intricate enough to justify formal verification. In this paper, we present a C library that has been formally verified using the Why3 verification platform in about four person-years. This verification deals not only with safety, but with full functional correctness. It has been performed using a mixture of mechanically checked handwritten proofs and automated theorem proving. We have implemented and verified a nontrivial subset of GMP's algorithms, including their optimizations and intricacies. Our library provides the same interface as GMP and is almost as efficient for smaller inputs. We detail our verification methodology and the algorithms we have implemented, and include some benchmarks to compare our library with GMP.", "num_citations": "1\n", "authors": ["1755"]}