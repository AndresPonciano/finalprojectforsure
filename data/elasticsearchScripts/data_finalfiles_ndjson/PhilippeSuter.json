{"title": "A look at the dynamics of the JavaScript package ecosystem\n", "abstract": " The node package manager (npm) serves as the frontend to a large repository of JavaScript-based software packages, which foster the development of currently huge amounts of server-side Node. js and client-side JavaScript applications. In a span of 6 years since its inception, npm has grown to become one of the largest software ecosystems, hosting more than 230, 000 packages, with hundreds of millions of package installations every week. In this paper, we examine the npm ecosystem from two complementary perspectives: 1) we look at package descriptions, the dependencies among them, and download metrics, and 2) we look at the use of npm packages in publicly available applications hosted on GitHub. In both perspectives, we consider historical data, providing us with a unique view on the evolution of the ecosystem. We present analyses that provide insights into the ecosystem's growth and activity, into\u00a0\u2026", "num_citations": "119\n", "authors": ["694"]}
{"title": "Stream processing with a spreadsheet\n", "abstract": " Continuous data streams are ubiquitous and represent such a high volume of data that they cannot be stored to disk, yet it is often crucial for them to be analyzed in real-time. Stream processing is a programming paradigm that processes these immediately, and enables continuous analytics. Our objective is to make it easier for analysts, with little programming experience, to develop continuous analytics applications directly. We propose enhancing a spreadsheet, a pervasive tool, to obtain a programming platform for stream processing. We present the design and implementation of an enhanced spreadsheet that enables visualizing live streams, live programming to compute new streams, and exporting computations to be run on a server where they can be shared with other users, and persisted beyond the life of the spreadsheet. We formalize our core language, and present case studies that cover a range\u00a0\u2026", "num_citations": "40\n", "authors": ["694"]}
{"title": "Stream-enabled spreadsheet as a circuit\n", "abstract": " Converting data transformations entered in a spreadsheet program into a circuit representation of those transformations. The circuit representation can run independently of the spreadsheet program to transform input data into output data. In some cases the circuit representation is in the form of hardware, accepts and/or produces data streams, and/or the circuit and/or output data or data streams can be shared among multiple users and/or subscribers. Where data streams are processed, the transformations may include well-specified timing semantics, supporting operations that involve rate-based rate manipulation, value-based rate manipulation, and/or access to past cell values.", "num_citations": "22\n", "authors": ["694"]}
{"title": "Inferring web API descriptions from usage data\n", "abstract": " We describe a set of techniques to infer structured descriptions of web APIs from usage examples. Using trained classifiers, we identify fixed and variable segments in paths, and tag parameters according to their types. We implemented our techniques and evaluated their precision on 10 APIs for which we obtained: 1) descriptions, manually written by the API maintainers, and 2) server logs of the API usage. Our experiments show that our system is able to reconstruct the structure of both simple and complex web API descriptions, outperforming an existing tool with similar goals. Finally, we assess the impact of noise in the input data on the results of our method.", "num_citations": "18\n", "authors": ["694"]}
{"title": "Programming with Specifications\n", "abstract": " Formal specifications have at some point acquired a bad reputation as being heavy-weight and hardly cost effective. However, new generations of constraint solving and verification tools emerging in recent years are rapidly changing this view. This thesis provides an outlook into the near future where developers will no longer question the usefulness of specifications in software validation. This is not merely a matter of educating programmers, but comes through fundamental improvements to the usability of tools. First of all, the specifications considered here are not in a notation foreign to programmers, but are written in a programming language itself, making it easy for developers to write. Like in model checking for finite-state systems, the tool gives concrete counterexamples in cases of wrong code or wrong specifications. As a result, the specifications and code are guided by each other and help the developer navigate the space of reasonable programs much more effectively. Unlike heuristic bug-finding tools, these approaches can also establish rigorous proofs of correctness, using symbolic reasoning to replace an infinite number of test cases. In particular, a roadblock to reasoning about software correctness is induction. This thesis shows that seemingly inductive properties do not always require explicit induction with heuristically chosen inductive steps to be solved, but can be tackled using systematic approaches of decision procedures. Rarely do we find results that are non-obvious, but end up having very elegant solutions that work well in practice. Such results can be discovered by opportunistically pursuing natural problems that we do\u00a0\u2026", "num_citations": "18\n", "authors": ["694"]}
{"title": "Ingestible device for the release of substances at distinct locations in alimentary canal\n", "abstract": " The field of the invention is site-specific drug delivery capsules (SSDC's). The disclosure relates to a closure member (14) for a substance reservoir (12) of an SSDC (10). The SSDC (10) includes a retainer that provides a non-linear force resisting opening of the closure member (14). The non-linear force ensures that the closure member (14) unseals the reservoir (12) only when an opening force exceeds a maximal value of the resisting force, thereby preventing premature or accidental emptying of the reservoir (12). The preferred means of providing the resistive force is a rolling, elastomeric o-ring (64) that additionally seals the closure member (14) into an aperture (13).", "num_citations": "16\n", "authors": ["694"]}
{"title": "Who you gonna call? Analyzing web requests in Android applications\n", "abstract": " Relying on ubiquitous Internet connectivity, applications on mobile devices frequently perform web requests during their execution. They fetch data for users to interact with, invoke remote functionalities, or send user-generated content or meta-data. These requests collectively reveal common practices of mobile application development, like what external services are used and how, and they point to possible negative effects like security and privacy violations, or impacts on battery life. In this paper, we assess different ways to analyze what web requests Android applications make. We start by presenting dynamic data collected from running 20 randomly selected Android applications and observing their network activity. Next, we present a static analysis tool, Stringoid, that analyzes string concatenations in Android applications to estimate constructed URL strings. Using Stringoid, we extract URLs from 30, 000\u00a0\u2026", "num_citations": "12\n", "authors": ["694"]}
{"title": "Automated generation of web api descriptions from usage data\n", "abstract": " A computer-implemented method for creating a web programming interface (API) description may include parsing an API usage dataset with a processor to identify a plurality of nodes in each of a plurality of uniform resource locators (URLs), and tagging path parameters for the plurality of nodes. Tagging the path parameters may include identifying, with the processor, which nodes are static parts of the URLs, and identifying, with the processor, which of the nodes are path parameters for the URLs. The method may further include aggregating, with the processor, a plurality of node types based on the tagged path parameters and the static parts of the URLs, and outputting, via the processor, an API description based on the aggregated plurality of node types.", "num_citations": "7\n", "authors": ["694"]}
{"title": "Spreadsheets for stream processing with unbounded windows and partitions\n", "abstract": " Stream processing is a computational paradigm that allows the analysis of live data streams as they are produced. This paper describes a programming model, based on enhancements to spreadsheets, that enables users with limited programming experience to participate directly in the development of complex streaming applications. The programming model augments a conventional spreadsheet with streaming features that permit operating over unbounded data sets despite the finite interface provided by the spreadsheet. The new constructs include time-based windows and partitioning. We introduce a spreadsheet compiler that generates C++ code to achieve integration with existing stream processing systems. Our experimental study illustrates the expressivity of the new features and finds that our implementation is between 8x slower and 2x faster than hand-written stream programs.", "num_citations": "7\n", "authors": ["694"]}
{"title": "Identifying Android library dependencies in the presence of code obfuscation and minimization\n", "abstract": " The fast growth of the Android app market motivates the need for tools and techniques to analyze and improve Android apps. A basic capability in this context is to identify the libraries present in a given Android app, including their exact version. The problem of identifying library dependencies is made difficult by two common build-time transformations, namely code minimization and obfuscation. Minimization typically incorporates used library fragments into an app, while obfuscation renames symbols globally across an app. In this paper, we tackle both of these challenges via a unified approach, which abstracts app and library classes into summaries of their interactions with system libraries. The summarization technique is resistant to obfuscation, and is amenable to efficient similarity detection (matching). We lift the class-wise matches into a set of library dependencies by encoding this problem as a global\u00a0\u2026", "num_citations": "6\n", "authors": ["694"]}
{"title": "Web API recommendations based on usage in cloud-provided runtimes\n", "abstract": " A method for recommending a web application programming interface (API) includes: a cloud computing service retrieving test source code from a remote computer of the developer; the cloud computing service determining whether a call to a first web API among a plurality of web APIs is present in the test source code; and when it is determined that the call is present, the cloud computing service reading at least one log file to extract information about at least one application that has used the first web API; the cloud computing service determining a first quality of the first web API from the log file; and the cloud computing service sending a message to the remote computer recommending a second web API among the web APIs having a second quality higher than the first quality.", "num_citations": "4\n", "authors": ["694"]}
{"title": "Encoding a spreadsheet program for stream processing\n", "abstract": " A method, system and computer readable program product are disclosed for encoding a function in a spreadsheet program to execute stream processing on a computing system. In embodiments of the invention, the method comprises encoding one or more formulas in one or more cells of the spreadsheet program, each of the formulas supporting data windows and stream partitioning; designating a first group of cells of the spreadsheet program as input cells for holding input values for the one or more formulas; and designating a second group of cells of the spreadsheet program as output cells for holding output values of the one or more formulas. In embodiments of the invention, the stream partitioning includes partitioning a defined stream of data into a plurality of data stream partitions, and the one or more formulas are encoded to operate on the plurality of data stream partitions.", "num_citations": "4\n", "authors": ["694"]}
{"title": "Distributed programming in Scala with APGAS\n", "abstract": " APGAS (Asynchronous Partitioned Global Address Space) is a model for concurrent and distributed programming, known primarily as the foundation of the X10 programming language. In this paper, we present an implementation of this model as an embedded domain-specific language for Scala. We illustrate common usage patterns and contrast with alternative approaches available to Scala programmers. In particular, using two distributed algorithms as examples, we illustrate how APGAS-style programs compare to idiomatic Akka implementations. We demonstrate the use of APGAS places and tasks, distributed termination, and distributed objects.", "num_citations": "3\n", "authors": ["694"]}
{"title": "Spreadsheets for stream partitions and windows\n", "abstract": " We discuss the suitability of spreadsheet processors as tools for programming streaming systems. We argue that, while spreadsheets can function as powerful models for stream operators, their fundamental boundedness limits their scope of application. We propose two extensions to the spreadsheet model and argue their utility in the context of programming streaming systems.", "num_citations": "3\n", "authors": ["694"]}