{"title": "Using Z: Specification \u201aRefinement \u201aand Proof\n", "abstract": " Using Z: Specification\u201a Refinement\u201a and Proof - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book Using Z: Specification\u201a Refinement\u201a and Proof Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Woodcock, J., & Davies, J. (1996). Using Z: Specification\u201a Refinement\u201a \u2026", "num_citations": "1873\n", "authors": ["1598"]}
{"title": "Formal methods: Practice and experience\n", "abstract": " Formal methods use mathematical models for analysis and verification at any part of the program life-cycle. We describe the state of the art in the industrial use of formal methods, concentrating on their increasing use at the earlier stages of specification and design. We do this by reporting on a new survey of industrial use, comparing the situation in 2009 with the most significant surveys carried out over the last 20 years. We describe some of the highlights of our survey by presenting a series of industrial projects, and we draw some observations from these surveys and records of experience. Based on this, we discuss the issues surrounding the industrial adoption of formal methods. Finally, we look to the future and describe the development of a Verified Software Repository, part of the worldwide Verified Software Initiative. We introduce the initial projects being used to populate the repository, and describe the\u00a0\u2026", "num_citations": "853\n", "authors": ["1598"]}
{"title": "Systems of systems engineering: basic concepts, model-based techniques, and research directions\n", "abstract": " The term \u201cSystem of Systems\u201d (SoS) has been used since the 1950s to describe systems that are composed of independent constituent systems, which act jointly towards a common goal through the synergism between them. Examples of SoS arise in areas such as power grid technology, transport, production, and military enterprises. SoS engineering is challenged by the independence, heterogeneity, evolution, and emergence properties found in SoS. This article focuses on the role of model-based techniques within the SoS engineering field. A review of existing attempts to define and classify SoS is used to identify several dimensions that characterise SoS applications. The SoS field is exemplified by a series of representative systems selected from the literature on SoS applications. Within the area of model-based techniques the survey specifically reviews the state of the art for SoS modelling, architectural\u00a0\u2026", "num_citations": "319\n", "authors": ["1598"]}
{"title": "The semantics of Circus\n", "abstract": " Circus is a concurrent language for refinement; it is a unification of imperative CSP, Z, and the refinement calculus. We describe the language of Circus and the formalisation of its model in Hoare & He\u2019s unifying theories of programming.", "num_citations": "285\n", "authors": ["1598"]}
{"title": "Software engineering mathematics\n", "abstract": " Mathematical methods of designing programs have become more important not only in exotic fields such as artificial intelligence, but also in ordinary data processing. Only mathematics provides an adequate basis for making large programs and systems robust. Few software engineers understand the mathematical foundations of formal methods for program development. This book attempts to make formal methods understandable to the software engineer. Although it does not include deep mathematical results, the book leads the reader through mathematical formalisms, formal methods of program design, and the design of real systems with formal methods. The book is divided into four parts, with a total of 12 chapters. The first part is devoted to theoretical foundations. Chapter 1 introduces the basic notions of formal systems, syntax, semantics, derivation, theorem, and proof. The authors give two particular formal\u00a0\u2026", "num_citations": "219\n", "authors": ["1598"]}
{"title": "An electronic purse: Specification, refinement and proof\n", "abstract": " This case study is a reduced version of a real development by the NatWest Development Team (now platform seven) of a Smartcard product for electronic commerce. This development was deeply security critical: it was vital to ensure that these cards would not contain any bugs in implementation or design that would allow them to be subverted once in the field. The system consists of a number of electronic purses that carry financial value, each hosted on a Smartcard. The purses interact with each other via a communications device to exchange value. Once released into the field, each purse is on its own: it has to ensure the security of all its transactions without recourse to a central controller. All security measures have to be implemented on the card, with no real-time external audit logging or monitoring.", "num_citations": "189\n", "authors": ["1598"]}
{"title": "A refinement strategy for Circus\n", "abstract": " We present a refinement strategy for Circus, which is the combination of Z, CSP, and the refinement calculus in the setting of Hoare and He\u2019s unifying theories of programming. The strategy unifies the theories of refinement for processes and their constituent actions, and provides a coherent technique for the stepwise refinement of concurrent and distributed programs involving rich data structures. This kind of development is carried out using Circus\u2019s refinement calculus, and we describe some of its laws for the simultaneous refinement of state and control behaviour, including the splitting of a process into parallel subcomponents. We illustrate the strategy and the laws using a case study that shows the complete development of a small distributed program.", "num_citations": "180\n", "authors": ["1598"]}
{"title": "Non-interference through determinism\n", "abstract": " The standard approach to the specification of a secure system is to present a (usually state-based) abstract security model separately from the specification of the system's functional requirements, and establishing a correspondence between the two specifications. This complex treatment has resulted in development methods distinct from those usually advocated for general applications.             We provide a novel and intellectually satisfying formulation of security properties in a process algebraic framework, and show that these are preserved under refinement. We relate the results to a more familiar state-based (Z) specification methodology. There are efficient algorithms for verifying our security properties using model checking.", "num_citations": "163\n", "authors": ["1598"]}
{"title": "A UTP semantics for Circus\n", "abstract": " Circus specifications define both data and behavioural aspects of systems using a combination of Z and CSP constructs. Previously, a denotational semantics has been given to Circus; however, a shallow embedding of Circus in Z, in which the mapping from Circus constructs to their semantic representation as a Z specification, with yet another language being used as a meta-language, was not useful for proving properties like the refinement laws that justify the distinguishing development technique associated with Circus. This work presents a final reference for the Circus denotational semantics based on Hoare and He\u2019s Unifying Theories of Programming (UTP); as such, it allows the proof of meta-theorems about Circus including the refinement laws in which we are interested. Its correspondence with the CSP semantics is illustrated with some examples. We also discuss the library of lemmas\u00a0\u2026", "num_citations": "159\n", "authors": ["1598"]}
{"title": "A concurrent language for refinement\n", "abstract": " We present a combination of the well-established formal specification languages Z and CSP; our objective is to provide support for the specification of both data and behaviour aspects of concurrent systems, and a development technique. The resulting language,  Circus , distinguishes itself in that it is aimed at the calculational refinement of specifications to programs written in a language similar to occam and  Handel-C . In this paper, we present  Circus , the rationale for its design, and a case study in its use.", "num_citations": "151\n", "authors": ["1598"]}
{"title": "Refinement of state-based concurrent systems\n", "abstract": " The traces, failures, and divergences of CSP can be expressed as weakest precondition formul\u00e6 over action systems. We show how such systems may be refined up to failures-divergences, by giving two proof methods which are sound and jointly complete: forwards and backwards simulations. The technical advantage of our weakest precondition approach over the usual relational approach is in our simple handling of divergence; the practical advantage is in the fact that the refinement calculus for sequential programs may be used to calculate forwards simulations. Our methods may be adapted to state-based development methods such as VDM or Z.", "num_citations": "136\n", "authors": ["1598"]}
{"title": "ZRC\u2013a refinement calculus for Z\n", "abstract": " The fact that Z is a specification language only, with no associated program development method, is a widely recognised problem. As an answer to that, we present ZRC, a refinement calculus based on Morgan's work that incorporates the Z notation and follows its style and conventions. This work builds upon existing refinement techniques for Z, but distinguishes itself mainly in that ZRC is completely formalised. In this paper, we explain how programs can be derived from Z specifications using ZRC. We present ZRC-L, the language of our calculus, and its conversion laws, which are concerned with the transformation of Z schemas into programs of this language. Moreover, we present the weakest precondition semantics of ZRC-L, which is the basis for the derivation of the laws of ZRC. More than a refinement calculus, ZRC is a theory of refinement for Z.", "num_citations": "119\n", "authors": ["1598"]}
{"title": "First steps in the verified software grand challenge\n", "abstract": " Bugs have become an unpleasant fact for software producers. Awareness is growing in industry that something must be done about software reliability. A growing number of academic and industrial researchers believe that the way to revolutionize the production of software is by using formal methods, and they also believe that doing so is now feasible. Given the right computer-based tools, the use of formal methods will become widespread, transforming the practice of software engineering. The computer science research community is collaborating to develop verification technology that will demonstrably enhance the productivity and reliability with which software is designed, developed, integrated, and maintained", "num_citations": "113\n", "authors": ["1598"]}
{"title": "A Tutorial Introduction to CSP in Unifying Theories of Programming\n", "abstract": " In their Unifying Theories of Programming (UTP), Hoare & He use the alphabetised relational calculus to give denotational semantics to a wide variety of constructs taken from different programming paradigms. In this chapter, we give a tutorial introduction to the semantics of CSP processes, as presented in Chapter 3. We start with a summarised introduction of the alphabetised relational calculus and the theory of designs, which are pre-post specifications in the style of specification statements. Afterwards, we present in detail a theory for reactive processes. Later, we combine the theories of designs and reactive processes to provide the model for CSP processes. Finally, we compare this new model with the standard failures-divergences model for CSP.", "num_citations": "109\n", "authors": ["1598"]}
{"title": "Integrated tool chain for model-based design of Cyber-Physical Systems: The INTO-CPS project\n", "abstract": " We describe INTO-CPS, a project that aims to realise the goal of integrated tool chains for the collaborative and multidisciplinary engineering of dependable Cyber-Physical Systems (CPSs). Challenges facing model-based CPS engineering are described, focussing on the semantic diversity of models, management of the large space of models and artefacts produced in CPS engineering, and the need to evaluate effectiveness in industrial settings. We outline the approach taken to each of these issues, particularly on the use of semantically integrated multi-models, links to architectural modelling, code generation and testing, and evaluation via industry-led studies. We describe progress on the development of a prototype tool chain from baseline tools, and discuss ongoing challenges and open research questions in this area.", "num_citations": "107\n", "authors": ["1598"]}
{"title": "Randomly attracted firefly algorithm with neighborhood search and dynamic parameter adjustment mechanism\n", "abstract": " Firefly algorithm (FA) is a new swarm intelligence optimization algorithm, which has shown an effective performance on many optimization problems. However, it may suffer from premature convergence when solving complex optimization problems. In this paper, we propose a new FA variant, called NSRaFA, which employs a random attraction model and three neighborhood search strategies to obtain a trade-off between exploration and exploitation abilities. Moreover, a dynamic parameter adjustment mechanism is used to automatically adjust the control parameters. Experiments are conducted on a set of well-known benchmark functions. Results show that our approach achieves much better solutions than the standard FA and five other recently proposed FA variants.", "num_citations": "103\n", "authors": ["1598"]}
{"title": "W: a logic for Z\n", "abstract": " We present W, a logic for the Z notation (Brien & al, 1991). The soundness proof for W is still under development, but is nearing completion.", "num_citations": "101\n", "authors": ["1598"]}
{"title": "Features of CML: A formal modelling language for Systems of Systems\n", "abstract": " We discuss the initial design for CML, the first formal language specifically designed for modelling and analysing Systems of Systems (SoSs). It is presented through the use of an example: an SoS of independent telephone exchanges. Its overall behaviour is first specified as a communicating process: a centralised telephone exchange. This description is then refined into a network of telephone exchanges, each handling a partition of the set of subscribers (telephone users). The refinement is motivated by a non-functional requirement to minimise the cabling required to connect geographically distributed subscribers, who are clustered. The exchanges remain as independent systems with respect to their local subscribers, whose service is unaffected by the loss of remote exchanges.", "num_citations": "99\n", "authors": ["1598"]}
{"title": "Refinement in circus\n", "abstract": " We describe refinement in Circus, a concurrent specification language that integrates imperative CSP, Z, and the refinement calculus. Each Circus process has a state and accompanying actions that define both the internal state transitions and the changes in control flow that occur during execution. We define the meaning of refinement of processes and their actions, and propose a sound data refinement technique for process refinement. Refinement laws for CSP and Z are directly relevant and applicable to Circus, but our focus here is on new laws for processes that integrate state and control. We give some new results about the distribution of data refinement through the combinators of CSP. We illustrate our ideas with the development of a distributed system of cooperating processes from a centralised specification.", "num_citations": "94\n", "authors": ["1598"]}
{"title": "More powerful Z data refinement: pushing the state of the art in industrial refinement\n", "abstract": " We have recently completed the specification and full refinement proof of a large, industrial scale application. The application was security critical, and the modelling and proof was done to increase the client\u2019s assurance that the implemented system had no design flaws with security implications. Here we describe the application, and then discuss an essential lesson to learn concerning large proof contracts: that one must forge a path between mathematical formality on the one hand and practical achievement of results on the other. We present a number of examples of such decision points, explaining the considerations that must be made in each case.               In the course of our refinement work, we discovered that the traditional Z data refinement proof obligations [8, section 5.6], were not sufficient to prove our refinement. In particular, these obligations assume the use of a \u2018forward\u2019 (or \u2018downward\u00a0\u2026", "num_citations": "83\n", "authors": ["1598"]}
{"title": "On the refinement and simulation of data types and processes\n", "abstract": " This paper presents a behavioural semantics for abstract data types, and thus a correspondence between data types and processes. The value of this correspondence lies in the fact that simulation of the abstract data types is easily verified, and is equivalent to failures refinement of the corresponding processes.             The method of constructing a semantics, and the method of proving equivalence between notions of refinement, are independent of the chosen interpretation. The same methods can be used to establish other correspondences between state-based and behavioural descriptions.", "num_citations": "77\n", "authors": ["1598"]}
{"title": "Isabelle/UTP: A Mechanised Theory Engineering Framework\n", "abstract": " We introduce Isabelle/UTP, a novel mechanisation of Hoare and He\u2019s Unifying Theories of Programming\u00a0(UTP) in Isabelle/HOL. UTP is a framework for the study, formalisation, and unification of formal semantics. Our contributions are, firstly, a deep semantic model of UTP\u2019s alphabetised predicates, supporting meta-logical reasoning that is parametric in the underlying notions of values and types. Secondly, integration of host-logic type checking that subsumes the need for typing proof obligations in the object-language. Thirdly, proof tactics that transfer results from well-supported mathematical structures in Isabelle to proofs about UTP theories. Additionally, our work provides novel insights towards reconciliation of shallow and deep language embeddings.", "num_citations": "76\n", "authors": ["1598"]}
{"title": "Unifying theories in ProofPower-Z\n", "abstract": " The increasing interest in the combination of different computational paradigms is very well represented by Hoare & He in the Unifying Theories of Programming. In this paper, we present a mechanisation of part of that work in a theorem prover, ProofPower-Z;\u00a0the theories of alphabetised relations, designs, reactive and CSP processes are in the scope of this paper. An account of how this mechanisation is done, and more interestingly, of what issues were raised and of our decisions, is presented here. We aim at providing tool support for further explorations of Hoare & He\u2019s unification, and for the mechanisation of languages based on this unification. More specifically, Circus, a specification language that combines Z, CSP, specification statements, and Dijkstra\u2019s guarded command language is our final target.", "num_citations": "72\n", "authors": ["1598"]}
{"title": "Cyber-physical systems design: formal foundations, methods and integrated tool chains\n", "abstract": " The engineering of dependable cyber-physical systems (CPSs) is inherently collaborative, demanding cooperation between diverse disciplines. A goal of current research is the development of integrated tool chains for model-based CPS design that support co-modelling, analysis, co-simulation, testing and implementation. We discuss the role of formal methods in addressing three key aspects of this goal: providing reasoning support for semantically heterogeneous models, managing the complexity and scale of design space exploration, and supporting traceability and provenance in the CPS design set. We briefly outline an approach to the development of such a tool chain based on existing tools and discuss ongoing challenges and open research questions in this area.", "num_citations": "71\n", "authors": ["1598"]}
{"title": "Unifying classes and processes\n", "abstract": " Previously, we presented Circus, an integration of Z, CSP, and Morgan\u2019s refinement calculus, with a semantics based on the unifying theories of programming. Circus  provides a basis for development of state-rich concurrent systems; it has a formal semantics, a refinement theory, and a development strategy. The design of Circus  is our solution to combining data and behavioural specifications. Here, we further explore this issue in the context of object-oriented features. Concretely, we present an object-oriented extension of Circus  called OhCircus. We present its syntax, describe its semantics, explain the formalisation of method calls, and discuss our approach to refinement.", "num_citations": "71\n", "authors": ["1598"]}
{"title": "POSIX file store in Z/Eves: an experiment in the verified software repository\n", "abstract": " We present results from the second pilot project in the international Verification Grand Challenge: a formally verified specification of a POSIX-compliant file store using the Z/Eves theorem prover. The project\u2019s overall objective is to build a verified file store for space-flight missions. Our specification of the file store is based on Morgan and Sufrin\u2019s specification of the UNIX filing system; the proof and its mechanisation in Z/Eves are novel. We show how our work contributes towards building a verified software repository: a set of general theories, proof techniques, and experiments reusable across different domains.", "num_citations": "63\n", "authors": ["1598"]}
{"title": "Structuring specifications in Z\n", "abstract": " In the specification notation known as Z, schemas are used to structure mathematical descriptions. The article describes the language of schemas and the conventions that are employed in their use. It also describes how proof obligations are generated during specification, and how these obligations may be discharged. Many examples, mostly taken from the specification of the user interface to a small, but realistic, software component are also included.< >", "num_citations": "63\n", "authors": ["1598"]}
{"title": "The certification of the Mondex electronic purse to ITSEC Level E6\n", "abstract": " Ten years ago the Mondex electronic purse was certified to ITSEC Level E6, the highest level of assurance for secure systems. This involved building formal models in the Z notation, linking them with refinement, and proving that they correctly implement the required security properties. The work has been revived recently as a pilot project for the international Grand Challenge in Verified Software. This paper records the history of the original project and gives an overview of the formal models and proofs used.", "num_citations": "62\n", "authors": ["1598"]}
{"title": "A tutorial introduction to designs in unifying theories of programming\n", "abstract": " In their Unifying Theories of Programming (UTP), Hoare & He use the alphabetised relational calculus to give denotational semantics to a wide variety of constructs taken from different programming paradigms. A key concept in their programme is the design:\u00a0the familiar precondition-postcondition pair that describes the contract between a programmer and a client. We give a tutorial introduction to the theory of alphabetised relations, and its sub-theory of designs. We illustrate the ideas by applying them to theories of imperative programming, including Hoare logic, weakest preconditions, and the refinement calculus.", "num_citations": "62\n", "authors": ["1598"]}
{"title": "RoboChart: modelling and verification of the functional behaviour of robotic applications\n", "abstract": " Robots are becoming ubiquitous:\u00a0from vacuum cleaners to driverless cars, there is a wide variety of applications, many with potential safety hazards. The work presented in this paper proposes a set of constructs suitable for both modelling robotic applications and supporting verification via model checking and theorem proving. Our goal is to support roboticists in writing models and applying modern verification techniques using a language familiar to them. To that end, we present RoboChart, a domain-specific modelling language based on UML, but with a restricted set of constructs to enable a simplified semantics and automated reasoning. We present the RoboChart metamodel, its well-formedness rules, and its process-algebraic semantics. We discuss verification based on these foundations using an implementation of RoboChart and its semantics as a set of Eclipse plug-ins called RoboTool.", "num_citations": "57\n", "authors": ["1598"]}
{"title": "A tactic calculus\u2014abridged version\n", "abstract": " We present a very general language for expressing tactic programs. The paper describes some essential tactic combinators (tacticals), and gives them a formal semantics. Those definitions are used to produce a complete calculus for reasoning about tactics written in this language. The language is extended to coverstructural combinators which enable the tactics to be precisely targeted upon particular sub-expressions.", "num_citations": "57\n", "authors": ["1598"]}
{"title": "Non-interference through determinism\n", "abstract": " The standard approach to the specification of a secure system is to present a (usually state-based) abstract security model separately from the specification of the system's functional requirements, and establishing a correspondence between the two specifications. This complex treatment has resulted in development methods distinct from those usually advocated for general applications.", "num_citations": "55\n", "authors": ["1598"]}
{"title": "Verification in the Grand Challenge\n", "abstract": " We review Tony Hoare\u2019s verification challenge. We start in 2003 with his challenge to construct a verifying compiler and his continuing theme on unifying theo ries in computer science. We describe the industrial-scale pilot projects that were proposed to drive this challenge forward: NatWest\u2019s Mondex smart card, NASA\u2019s space-flight flash filestore, Ofcom\u2019s radio spectrum auctions, Microsoft\u2019s hypervi sor, NSA\u2019s Tokeneer identification station, Wittenstein\u2019s FreeRTOS real-time ker nel, and Boston Scientific\u2019s cardiac pacemaker. We go into detail on the conduct and achievements of the Tokeneer project. We discuss the wider impact of the ver ification challenge and the sea change since 2003. We look forward to the next 15 years and suggest a pilot project in robotics for the verification community.", "num_citations": "49\n", "authors": ["1598"]}
{"title": "Mechanising mondex with Z/Eves\n", "abstract": " We describe our experiences in mechanising the specification, refinement, and proof of the Mondex Electronic Purse using the Z/Eves theorem prover. We took a conservative approach and mechanised the original LaTEX sources without changing their technical content, except to correct errors. We found problems in the original specification and some missing invariants in the refinements. Based on these experiences, we present novel and detailed guidance on how to drive Z/Eves successfully. The work contributes to the Repository for the Verified Software Grand Challenge.", "num_citations": "49\n", "authors": ["1598"]}
{"title": "Using VDM with rely and guarantee-conditions\n", "abstract": " In his extension of VDM, Jones added a rely and a guarantee-condition to the usual pre and post-condition pair. This extension to the technique permits the specification and development of concurrent, shared-variable systems. We describe the technique in detail by giving an example of a simple, but formal, development. A description of part of a substantial system development that has been carried out on a real project is given in the full version of this paper [Woodcock & Dickinson, 1988]. Conclusions are drawn, both about the rules for concurrent data reification, and about the efficacy of the technique and of the industrial use of formal methods in general.", "num_citations": "48\n", "authors": ["1598"]}
{"title": "ArcAngel: a tactic language for refinement\n", "abstract": " Morgan's refinement calculus is a successful technique for developing software in a precise and consistent way. This technique, however, can be hard to use, as developments may be long and repetitive. Many authors have pointed out that a lot can be gained by identifying commonly used development strategies, documenting them as tactics, and using them as single transformation rules. Also, it is useful to have a notation for describing derivations, so that they can be analysed and modified. In this paper, we present ArcAngel, a language for defining such refinement tactics; we present the language, its semantics, and some of its algebraic laws. Apart from Angel, a general-purpose tactic language that we are extending, no other tactic language has a denotational semantics and proof theory of its own.", "num_citations": "47\n", "authors": ["1598"]}
{"title": "Refinement of actions in Circus\n", "abstract": " This paper presents refinement laws to support the development of actions in Circus, a combination of Z and CSP adequate to specify the data structures and behavioural aspects of concurrent systems. In this language, systems are characterised as a set of processes; each process is a unit that encapsulates state and reactive behaviour defhed by actions. Previously, we have addressed the issue of refining processes. Here, we are concerned with the actions that compose the behaviour of such processes, and that may involve both Z and CSP constructs. We present a number of useful laws, and a case study that illustrates their application.", "num_citations": "46\n", "authors": ["1598"]}
{"title": "A denotational semantics for Circus\n", "abstract": " Circus specifications define both data and behavioural aspects of systems using a combination of Z and CSP. Previously, a denotational semantics has been given to Circus; however, as a shallow embedding of Circus in Z, it was not possible to use it to prove properties like the refinement laws that justify the distinguishing development technique associated with Circus. This work presents a final reference for the Circus denotational semantics based on Hoare and He's Unifying Theories of Programming (UTP). Finally, it discusses the library of theorems on the UTP that was created and used in the proofs of the refinement laws.", "num_citations": "45\n", "authors": ["1598"]}
{"title": "A Theory of Pointers for the UTP\n", "abstract": " Hoare and He\u2019s unifying theories of programming\u00a0(UTP) provide a collection of relational models that can be used to study and compare several programming paradigms. In this paper, we add to the UTP a theory of pointers and records that provides a model for objects and sharing in languages like Java and C++. Our work is based on the hierarchical addressing scheme used to refer to record fields\u00a0(or object attributes) in conventional languages, rather than explicit notions of location. More importantly, we support reasoning about the structure and sharing of data, as well as their, possibly infinite, values. We also provide a general account of UTP theories characterised by conjunctive healthiness conditions, of which our theory is an example.", "num_citations": "43\n", "authors": ["1598"]}
{"title": "Unifying heterogeneous state-spaces with lenses\n", "abstract": " Most verification approaches embed a model of program state into their semantic treatment. Though a variety of heterogeneous state-space models exists, they all possess common theoretical properties one would like to capture abstractly, such as the common algebraic laws of programming. In this paper, we propose lenses as a universal state-space modelling solution. Lenses provide an abstract interface for manipulating data types through spatially-separated views. We define a lens algebra that enables their composition and comparison, and apply it to formally model variables and alphabets in Hoare and He\u2019s Unifying Theories of Programming (UTP). The combination of lenses and relational algebra gives rise to a model for UTP in which its fundamental laws can be verified. Moreover, we illustrate how lenses can be used to model more complex state notions such as memory stores and parallel\u00a0\u2026", "num_citations": "42\n", "authors": ["1598"]}
{"title": "Mechanising a formal model of flash memory\n", "abstract": " We present second steps in the construction of formal models of NAND flash memory, based on a recently emerged open standard for such devices. The model is intended as a key part of a pilot project to develop a verified file store system based on flash memory. The project was proposed by Joshi and Holzmann as a contribution to the Grand Challenge in Verified Software, and involves constructing a highly assured flash file store for use in space-flight missions. The model is at a level of abstraction that captures the internal architecture of NAND flash devices. In this paper, we focus on mechanising the state model and its initialisation operation, where most of the conceptual complexity resides.", "num_citations": "41\n", "authors": ["1598"]}
{"title": "Formalising flash memory: First steps\n", "abstract": " We present first steps in the construction of formal models of NAND flash memory, based on a recently emerged open standard for such devices. The model is at a level of abstraction that captures the internal architecture of such a device, as well as the commands that are used to operate it. The model is intended as a key step in a plan to develop a verified filestore system, by providing a description of the hardware devices that would be used in it implementation.", "num_citations": "41\n", "authors": ["1598"]}
{"title": "Properties of Z specifications\n", "abstract": " In this paper we show how to calculate properties of specifications written in the Z notation. In particular, we show how the precondition of an operation may be derived using rewrite rules and an application-oriented theory. As an example, we take part of the specification of an industrial-sized problem. If proofs are conducted at the level of the schema, then the structure of the proof follows the structure of the specification, and the technique scales up for verification in the large.", "num_citations": "40\n", "authors": ["1598"]}
{"title": "A weakest precondition semantics for Z\n", "abstract": " The lack of a method for developing programs from Z specifications is a widely recognized difficulty. In response to this problem, different approaches to the integration of Z with a refinement calculus have been proposed. These programming techniques are promising, but as far as we know, have not been formalized. Since they are based on refinement calculi formalized in terms of weakest preconditions, the definition of a weakest precondition semantics for Z is a significant contribution to the solution of this problem. In this paper, we actually construct a weakest precondition semantics from a relational semantics proposed by the Z standards panel. The construction provides reassurance as to the adequacy of the resulting semantics definition and additionally establishes an isomorphism between weakest preconditions and relations. Compositional formulations for the weakest precondition of some schema\u00a0\u2026", "num_citations": "39\n", "authors": ["1598"]}
{"title": "Towards semantically integrated models and tools for cyber-physical systems design\n", "abstract": " We describe an approach to the model-based engineering of embedded and cyber-physical systems, based on the semantic integration of diverse discipline-specific notations and tools. Using the example of a small unmanned aerial vehicle, we explain the need for multiple notations and collaborative modelling. Learning from experience with binary co-modelling based on a bespoke operational semantics, we describe current work delivering an extended approach that enables integration of multiple models and tools in a consistent tool chain, founded on an extensible semantic framework exploiting the Unifying Theories of Programming.", "num_citations": "38\n", "authors": ["1598"]}
{"title": "Safety-critical Java programs from Circus models\n", "abstract": " Safety-Critical Java\u00a0(SCJ) is a novel version of Java that addresses issues related to real-time programming and certification of safety-critical applications. In this paper, we propose a technique that reveals the issues involved in the formal verification of an SCJ program, and provides guidelines for tackling them in a refinement-based approach. It is based on Circus, a\u00a0combination of well established notations: Z, CSP, Timed CSP, and object orientation. We cater for the specification of timing requirements and their decomposition towards the structure of missions and event handlers of SCJ. We also consider the integrated refinement of value-based specifications into class-based designs using SCJ scoped memory areas. We present a refinement strategy, a\u00a0Circus variant that captures the essence of the SCJ paradigm, and a substantial example based approach on a concurrent version of a case study that\u00a0\u2026", "num_citations": "37\n", "authors": ["1598"]}
{"title": "Angelic nondeterminism in the unifying theories of programming\n", "abstract": " Hoare and He\u2019s unifying theories of programming (UTP) is a model of alphabetised relations expressed as predicates; it supports development in several programming paradigms. The aim of Hoare and He\u2019s work is the unification of languages and techniques, so that we can benefit from results in different contexts. In this paper, we investigate the integration of angelic nondeterminism in the UTP; we propose the unification of a model of binary multirelations, which is isomorphic to the monotonic predicate transformers model and can express angelic and demonic nondeterminism.", "num_citations": "36\n", "authors": ["1598"]}
{"title": "Z, Grammar and Concrete and Abstract Syntaxes\n", "abstract": " This monograph, which presents a grammar and an a. bstract syntax {or the Zspecification language, is produced as part of a joint project between IBM United Kingdom Labo. ratories Limited at Hursley, England and the Programming Research Group of Oxford University Computing Laboratory, into the application of formal software specification techniques to industrial problems. The work WM sopported by a research contract be tween IBM and Oxford University and is published by pennission of the Company.", "num_citations": "36\n", "authors": ["1598"]}
{"title": "POSIX and the verification grand challenge: A roadmap\n", "abstract": " We present a research roadmap for the second pilot project in the Verified Software Grand Challenge on formally verified POSIX file stores. The work is inspired by the requirements for NASA's forthcoming Mars Rover missions. The roadmap describes an integrated and comprehensive body of work, including current work, as well as further opportunities for collaboration.", "num_citations": "35\n", "authors": ["1598"]}
{"title": "Industrial practice in formal methods: A review\n", "abstract": " We examine the the industrial application of formal methods using data gathered in a review of 62 projects taking place over the last 25 years. The review suggests that formal methods are being applied in a wide range of application domains, with increasingly strong tool support. Significant challenges remain in providing usable tools that can be integrated into established development processes; in education and training; in taking formal methods from first use to second use, and in gathering and evidence to support informed selection of methods and tools.", "num_citations": "34\n", "authors": ["1598"]}
{"title": "Safety through security\n", "abstract": " This paper illustrates that the concept of noninterference, used in theories of security, may also be used to reason about safety. It presents a technique for modelling safety properties in terms of communicating processes, and develops a practical theory of system protection from failures. A simple example is presented to illustrate the application of this technique to different classes of safety property.", "num_citations": "34\n", "authors": ["1598"]}
{"title": "The steam boiler in a unified theory of Z and CSP\n", "abstract": " This paper presents a formalisation of the steam boiler problem using Circus, a unified theory of the formal specification languages Z and CSP. The aim of Circus is to provide powerful support for the specification of the data-oriented and behavioural aspects of concurrent systems, and to provide a calculational development technique for languages similar to Occam, Java, and Handel-C.", "num_citations": "33\n", "authors": ["1598"]}
{"title": "Slotted-circus\n", "abstract": " We present a generic framework of UTP theories for describing systems whose behaviour is characterised by regular time-slots, compatible with the general structure of the Circus language [WC01a]. This \u201cslotted-Circus\u201d framework is parameterised by the particular way in which event histories are observable within a time-slot, and specifies what laws a desired parameterisation must obey in order for a satisfactory theory to emerge.             Two key results of this work are:\u00a0the need to be very careful in formulating the healthiness conditions, particularly                  R2               ;\u00a0and the demonstration that synchronous theories like SCSP [Bar93] do not fit well with the way reactive systems are currently formulated in UTP and Circus.", "num_citations": "32\n", "authors": ["1598"]}
{"title": "Towards a UTP semantics for Modelica\n", "abstract": " We describe our work on a UTP semantics for the dynamic systems modelling language Modelica. This is a language for modelling a system\u2019s continuous behaviour using a combination of differential-algebraic equations and an event-handling system. We develop a novel UTP theory of hybrid relations, inspired by Hybrid CSP and Duration Calculus, that is purely relational and provides uniform handling of continuous and discrete variables. This theory is mechanised in our Isabelle implementation of the UTP, Isabelle/UTP, with which we verify some algebraic properties. Finally, we show how a subset of Modelica models can be given semantics using our theory. When combined with the wealth of existing UTP theories for discrete system modelling, our work enables a sound approach to heterogeneous semantics for Cyber-Physical systems by leveraging the theory linking facilities of the UTP.", "num_citations": "31\n", "authors": ["1598"]}
{"title": "Foundations for model-based engineering of systems of systems\n", "abstract": " The engineering of Systems of Systems presents daunting challenges. In this paper it is argued that rigorous semantic foundations for model-based techniques are potentially beneficial in addressing these. Three priorities for current research are identified: contractual interface definition, the verification of emergent behaviour, and the need to deal with semantic heterogeneity of constituent systems and their models. We describe the foundations of an approach in which architectural models in SysML may be analysed in a formal modelling language that has an extensible semantics given using the Unifying Theories of Programming (UTP).", "num_citations": "31\n", "authors": ["1598"]}
{"title": "The miracle of reactive programming\n", "abstract": " Reactive miracles are rather unexplored in Unifying Theories of Programming. We present two simple properties:\u00a0prefixing a miracle with an event, and offering an external choice between a process and a miracle. Both are strange processes, each violating an important axiom of the standard failures-divergences model for CSP.", "num_citations": "30\n", "authors": ["1598"]}
{"title": "An inconsistency in procedures, parameters, and substitution in the refinement calculus\n", "abstract": " Morgan and Back have proposed different formalisations of procedures and parameters in the context of techniques of program development based on refinement. In this paper, we investigate a surprising and intricate relationship between these works and the substitution operator that renames the free variables of a program. In this study, we reveal an inconsistency in Morgan's refinement calculus and show that Back's formalisation of procedures does not have the same problem.", "num_citations": "30\n", "authors": ["1598"]}
{"title": "Safety-critical Java in circus\n", "abstract": " This position paper proposes a refinement technique for the development of Safety-Critical Java (SCJ) programs. It is based on the Circus family of languages, which comprises constructs from Z, CSP, Timed CSP, and object-orientation. We cater for the specification of timing requirements, and their decomposition towards the structure of missions and event handlers of SCJ. We also consider the integrated refinement of value-based specifications into class-based designs using SCJ scoped memory areas. We present a refinement strategy, and a Circus variant that captures the essence of the SCJ paradigm independently from Java.", "num_citations": "29\n", "authors": ["1598"]}
{"title": "Challenges of Activity Theory\n", "abstract": " In the Soviet tradition names such as Vygotsky, Luria, and Leontiev represent the same psychological school. In the West they are the founders of \u201ccultural-historical activity theory\u201d(CHAT). In the Russian terminology this school is often divided into two camps:\u201ccultural-historical psychology\u201d and \u201cactivity theory.\u201d It was actually AN Leontiev who proposed an activity approach to the study of human psychology and developed the structural model of activity in his book Activity, Consciousness, and Personality (Leontiev, 1978). But among psychologists Leontiev\u2019s ideas have not gained as much popularity as those of Vygotsky or Luria.A serious and successful attempt to develop the activity approach in the West has been undertaken at the Center for Activity Theory and Developmental Work Research (University of Finland, Helsinki) led by Yrj\u00f6 Engestr\u00f6m. The basis of this work was laid in the theoretical elaboration of\u00a0\u2026", "num_citations": "29\n", "authors": ["1598"]}
{"title": "Operational Semantics for Model Checking Circus\n", "abstract": " Circus is a combination of Z, CSP, and the refinement calculus, and is based on Hoare & He\u2019s Unifying Theories of Programming. A model checker is being constructed for the language to conduct refinement checking in the style of FDR, but supported by theorem proving for reasoning about the complex states and data types that arise from the use of Z. FDR deals with bounded labelled transition systems (LTSs), but the Circus model checker manipulates LTSs with possibly infinite inscriptions on arcs and in nodes, and so, in general, the success or failure of a refinement check depends on interaction with a theorem prover. An LTS is generated from a source text using an operational interpretation of Circus; we present a Structured Operational Semantics for Circus, including both its process-algebraic and state-rich features.", "num_citations": "28\n", "authors": ["1598"]}
{"title": "The mechanical verification of solid state interlocking geographic data\n", "abstract": " The Mechanical Verification of Solid State Interlocking Geographic Data - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Book icon Book The Mechanical Verification of Solid State Interlocking Geographic Data Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Simpson, AC, \u2026", "num_citations": "28\n", "authors": ["1598"]}
{"title": "The safety-critical Java memory model: a formal account\n", "abstract": " Safety-Critical Java\u00a0(SCJ) is a version of Java for real-time programming that facilitates certification of implementations of safety-critical systems. It is the result of an international effort involving industry and academia. What we provide here is, as far as we know, the first formalisation of the SCJ model of memory regions. We use the Unifying Theories of Programming\u00a0(UTP) to enable the integration of our theory with refinement models for object-orientation and concurrency. In developing the SCJ theory, we also make a contribution to the UTP by providing a general theory of invariants\u00a0(of which the SCJ theory is an instance). Our results are a first essential ingredient to formalise the novel programming paradigm embedded in SCJ, and enable the justification and development of reasoning techniques based on refinement.", "num_citations": "27\n", "authors": ["1598"]}
{"title": "The rudiments of algorithm refinement\n", "abstract": " We describe the rudiments of algorithm refinement: the business of taking a specification and producing code that correctly implements it. The paper starts with a general discussion of the concepts, and then turns to a particular calculus for algorithm refinement.", "num_citations": "27\n", "authors": ["1598"]}
{"title": "Refining industrial scale systems in Circus\n", "abstract": " Circus is a new notation that may be used to specify both data and behaviour aspects of a system, and has an associated refinement calculus. Although a few case studies are already available in the literature, the industrial fire control sys-tem presented in this paper is, as far as we know, the largest case study on the Circus refinement strategy. We describe the refinement and present some new laws that were needed. Our case study makes extensive use of mutual recursion; a simplified notation for specifying such systems and proving their refinements is proposed here.", "num_citations": "26\n", "authors": ["1598"]}
{"title": "Features of integrated model-based co-modelling and co-simulation technology\n", "abstract": " Given the considerable ongoing research interest in collaborative multidisciplinary modelling and co-simulation, it is worth considering the features of model-based techniques and tools that deliver benefits to cyber-physical systems developers. The European project \u201cIntegrated Tool Chain for Model-based Design of Cyber-Physical Systems\u201d (INTO-CPS) has developed a well-founded tool chain for CPS design, based on the Functional Mock-up Interface standard, and supported by methodological guidance. The focus of the project has been on the delivery of a sound foundation, an open chain of compatible and usable tools, and a set of accessible guidelines that help users adapt the technology to their development needs.", "num_citations": "25\n", "authors": ["1598"]}
{"title": "Circus Time with Reactive Designs\n", "abstract": " The UTP theories for CSP and Circus can be built by the combination of the theories of designs and reactive processes. Defining the CSP operators using reactive design provides a more concise, readable and uniform UTP semantics, and, more importantly, exposes the pre-postcondition semantics of the operators. For Circus Time, a few operators have been defined as reactive designs, but some important operators are still be considered. In this paper, we develop the reactive design semantics of sequential composition, hiding and recursion within Circus Time, and show how to prove some subtle laws using the new semantics.", "num_citations": "25\n", "authors": ["1598"]}
{"title": "A comparison of state-based modelling tools for model validation\n", "abstract": " In model-based testing, one of the biggest decisions taken before modelling is the modelling language and the model analysis tool to be used to model the system under investigation. UML, Alloy and Z are examples of popular state-based modelling languages. In the literature, there has been research about the similarities and the differences between modelling languages. However, we believe that, in addition to recognising the expressive power of modelling languages, it is crucial to detect the capabilities and the weaknesses of analysis tools that parse and analyse models written in these languages. In order to explore this area, we have chosen four model analysis tools: USE, Alloy Analyzer, ZLive and ProZ and observed how modelling and validation stages of MBT are handled by these tools for the same system. Through this experiment, we not only concretise the tasks that form the modelling and\u00a0\u2026", "num_citations": "25\n", "authors": ["1598"]}
{"title": "Semantics of prialt in Handel-C\n", "abstract": " (2002) Semantics of Prialt in Handel-C. In: Concurrent Systems Engineering, Proceedings of the Conference on Communicating Processing Architectures.. IOS Press (The full text of this publication is not currently available from this repository. You may be able to access a copy if URLs are provided)(KAR id: 13666)", "num_citations": "25\n", "authors": ["1598"]}
{"title": "New opportunities for integrated formal methods\n", "abstract": " Formal methods have provided approaches for investigating software engineering fundamentals and also have high potential to improve current practices in dependability assurance. In this article, we summarise known strengths and weaknesses of formal methods. From the perspective of the assurance of robots and autonomous systems (RAS), we highlight new opportunities for integrated formal methods and identify threats to the adoption of such methods. Based on these opportunities and threats, we develop an agenda for fundamental and empirical research on integrated formal methods and for successful transfer of validated research to RAS assurance. Furthermore, we outline our expectations on useful outcomes of such an agenda.", "num_citations": "24\n", "authors": ["1598"]}
{"title": "Z/eves and the mondex electronic purse\n", "abstract": " We describe our experiences in mechanising the specification, refinement, and proof of the Mondex Electronic Purse using the Z/Eves theorem prover. We took a conservative approach and mechanised the original  sources, without changing their technical content, except to correct errors: we found problems in the original texts and missing invariants in the refinements. Based on these experiences, we present novel and detailed guidance on how to drive Z/Eves successfully. The work contributes to the research objectives of building the Repository for the Verified Software Grand Challenge.", "num_citations": "24\n", "authors": ["1598"]}
{"title": "Unifying theories of parallel programming\n", "abstract": " We are developing a shared-variable refinement calculus in the style of the sequential calculi of Back, Morgan, and Morris. As part of this work, we\u2019re studying different theories of shared-variable programming. Using the concepts and notations of Hoare & He\u2019s unifying theories of programming (UTP), we give a formal semantics to a programming language that contains sequential composition, conditional statements, while loops, nested parallel composition, and shared variables. We first give a UTP semantics to labelled action systems, and then use this to give the semantics of our programs. Labelled action systems have a unique normal form that allows a simple formalisation and validation of different logics for reasoning about shared-variable programs. In this paper, we demonstrate how this is done for Lamport\u2019s Concurrent Hoare Logic.", "num_citations": "24\n", "authors": ["1598"]}
{"title": "Unifying theories of reactive design contracts\n", "abstract": " Design-by-contract is an important technique for model-based design in which a composite system is specified by a collection of contracts that specify the behavioural assumptions and guarantees of each component. In this paper, we describe a unifying theory for reactive design contracts that provides the basis for modelling and verification of reactive systems. We provide a language for expression and composition of contracts that is supported by a rich calculational theory. In contrast with other semantic models in the literature, our theory of contracts allows us to specify both the evolution of state variables and the permissible interactions with the environment. Moreover, our model of interaction is abstract, and supports, for instance, discrete time, continuous time, and hybrid computational models. Being based in Unifying Theories of Programming (UTP), our theory can be composed with further computational\u00a0\u2026", "num_citations": "23\n", "authors": ["1598"]}
{"title": "Verifying the CICS File Control API with Z/Eves: An experiment in the verified software repository\n", "abstract": " Parts of the CICS transaction processing system were modelled formally in the 1980s in a collaborative project between IBM UK Hursley Park and Oxford University Computing Laboratory. Z was used to capture a precise description of the behaviour of various modules as a means of communicating requirements and design intentions. These descriptions were not mechanically verified in any way: proof tools for Z were not considered mature, and no business case was made for effort in this area. We report a recent experiment in using the Z/Eves theorem prover to construct a machine-checked analysis of one of the CICS modules: the File Control API. This work was carried out as part of the international Grand Challenge in Verified Software, and our results are recorded in the Verified Software Repository. We give a brief description of the other modules, and propose them as challenge problems for the verification\u00a0\u2026", "num_citations": "23\n", "authors": ["1598"]}
{"title": "A layered behavioural model of platelets\n", "abstract": " There is great interest in the application of nanotechnology to medicine, but concerns for safety are paramount. We present a modelling technique based on CSP and B as a starting point for simulation of networks of nano-robots. The model and the simulations are central features of our proposed approach to the construction of safety cases for nanomedicine applications, and complex networks of cooperating components in general. Our work is based on a case study: the clotting behaviour of (artificial) platelets. We present a model, and discuss its analysis and uses", "num_citations": "23\n", "authors": ["1598"]}
{"title": "Towards mobile processes in unifying theories\n", "abstract": " The paper presents a denotational semantics of mobile processes in Hoare & He's Unifying Theories of Programming (UTP). Process mobility is captured by the mobile assignment or communication of higher-order variables, in which both the source and the target are process-valued variables. Processes are moved around in the system by updating the target and losing the value of the source. The semantics can be used to guarantee the correctness of a set of algebraic of refinement laws for the step-wise development of mobile systems. We give an outline of this development method, present and prove some of the laws.", "num_citations": "23\n", "authors": ["1598"]}
{"title": "The safety-critical Java memory model formalised\n", "abstract": " Safety-Critical Java (SCJ) is a version of Java for real-time programming, restricted to facilitate certification of implementations of safety-critical systems. Its development is the result of an international effort involving experts from industry and academia. What we provide here is, as far as we know, the first formalisation of the SCJ model of memory regions. We use Hoare and He\u2019s unifying theories of programming (UTP), enabling the integration of our theory with refinement models for object orientation and concurrency. In developing the SCJ theory, we also make a contribution to UTP by providing a general theory of invariants (an instance of which is used in the SCJ theory). The results presented here are a first essential ingredient to formalise the novel programming paradigm embedded in SCJ, and enable the justification and development of formal reasoning techniques based on refinement.", "num_citations": "22\n", "authors": ["1598"]}
{"title": "Mathematics as a management tool: Proof rules for promotion\n", "abstract": " We consider how the Z notation is used to produce structured specifications. In particular, we consider the technique known as promotion, and give an example of its use in the structured specification of a file system. We then consider how the proof of this system\u2019s correctness can follow the structure of its specification. Promotion has traditionally been treated rather informally, and proofs of correctness have relied on the expansion of definitions and the subsequent loss of structure. We formalise the notion of promotion, and observe that it is a kind of data refinement calculation. We prove that promotion is monotonic, and that it distributes through the major specification combinators: disjunction, conjunction, and the precondition calculator. Finally, we apply our results to the proof of the file system.", "num_citations": "22\n", "authors": ["1598"]}
{"title": "Industrial deployment of formal methods: Trends and challenges\n", "abstract": " The DEPLOY project has provided a rare opportunity to explore and document the potential benefits of and challenges to creating and exploiting usable formal methods. Using the results of an updated review of 98 industrial applications, we identify trends relating to analytic power, robustness, stability and usability of tools, as well as to the quality of evidence on costs and benefits of deployment. A consideration of the DEPLOY applications reinforces these trends, additionally emphasising the importance of selecting formalisms suited to the problem domain and of effectively managing traceable links between requirements and models.", "num_citations": "21\n", "authors": ["1598"]}
{"title": "Mechanising a unifying theory\n", "abstract": " In this paper, we present a formalisation of a subset of the unifying theories of programming (UTP). In UTP, the alphabetised relational calculus is used to describe and relate different programming paradigms, including functional, imperative, logic, and parallel programming.             We develop a verification framework for UTP; we give a formal semantics to an imperative programming language, and use our definitions to create a deep embedding of the language in Z. We use ProofPowerZ, a theorem prover for Z to provide mechanised support for reasoning about programs in the unifying theory.", "num_citations": "21\n", "authors": ["1598"]}
{"title": "Adapting FreeRTOS for multicores: An experience report\n", "abstract": " Multicore processors are ubiquitous. Their use in embedded systems is growing rapidly, and given the constraints on uniprocessor clock speeds, their importance in meeting the demands of increasingly processor\u2010intensive embedded applications cannot be understated. To harness this potential, system designers need to have available to them embedded operating systems with built\u2010in multicore support for widely available embedded hardware. This paper documents our experience of adapting FreeRTOS, a popular embedded real\u2010time operating system, to support multiple processors. A working multicore version of FreeRTOS that is able to schedule tasks on multiple processors as well as provide full mutual\u2010exclusion support for use in concurrent applications is presented. Mutual exclusion is achieved in an almost completely platform\u2010agnostic manner, preserving one of FreeRTOS's most attractive features\u00a0\u2026", "num_citations": "20\n", "authors": ["1598"]}
{"title": "Model-based engineering of systems of systems\n", "abstract": " The term \u2018System of Systems\u2019(SoS) has been used since the 1950s to describe systems that are composed of independent constituent systems, which act jointly towards a common goal through the synergism between them. Examples of SoS arise in areas such as power grid technology, transport, production and military enterprises. SoS engineering is challenged by the independence, heterogeneity, evolution and emergence properties found in SoS. This paper focuses on the role of model-based techniques within the SoS engineering field. A review of existing attempts to define and classify SoS is used to identify several dimensions that characterise SoS applications. The SoS field is exemplified by a series of representative systems selected from the literature on SoS applications. Within the area of model-based techniques the survey specifically reviews the state of the art for SoS modelling, architectural description, simulation, verification and testing. Finally, the identified dimensions of SoS characteristics are used to identify research challenges and future research areas of model-based SoS Engineering.", "num_citations": "20\n", "authors": ["1598"]}
{"title": "Unifying semantic foundations for automated verification tools in Isabelle/UTP\n", "abstract": " The growing complexity and diversity of models used for engineering dependable systems implies that a variety of formal methods, across differing abstractions, paradigms, and presentations, must be integrated. Such an integration requires unified semantic foundations for the various notations, and co-ordination of a variety of automated verification tools. The contribution of this paper is Isabelle/UTP, an implementation of Hoare and He's Unifying Theories of Programming, a framework for unification of formal semantics. Isabelle/UTP permits the mechanisation of computational theories for diverse paradigms, and their use in constructing formalised semantics. These can be further applied in the development of verification tools, harnessing Isabelle's proof automation facilities. Several layers of mathematical foundations are developed, including lenses to model variables and state spaces as algebraic objects\u00a0\u2026", "num_citations": "19\n", "authors": ["1598"]}
{"title": "Automating verification of state machines with reactive designs and Isabelle/UTP\n", "abstract": " State-machine based notations are ubiquitous in the description of component systems, particularly in the robotic domain. To ensure these systems are safe and predictable, formal verification techniques are important, and can be cost-effective if they are both automated and scalable. In this paper, we present a verification approach for a diagrammatic state machine language that utilises theorem proving and a denotational semantics based on Unifying Theories of Programming (UTP). We provide the necessary theory to underpin state machines (including induction theorems for iterative processes), mechanise an action language for states and transitions, and use these to formalise the semantics. We then describe the verification approach, which supports infinite state systems, and exemplify it with a fully automated deadlock-freedom check. The work has been mechanised in our proof tool, Isabelle/UTP\u00a0\u2026", "num_citations": "19\n", "authors": ["1598"]}
{"title": "A refinement based strategy for local deadlock analysis of networks of CSP processes\n", "abstract": " Based on a characterisation of process networks in the CSP process algebra, we formalise a set of behavioural restrictions used for local deadlock analysis. Also, we formalise two patterns, originally proposed by Roscoe, which avoid deadlocks in cyclic networks by performing only local analyses on components of the network; our formalisation systematises the behavioural and structural constraints imposed by the patterns. A distinguishing feature of our approach is the use of refinement expressions for capturing notions of pattern conformance, which can be mechanically checked by CSP tools like FDR. Moreover, three examples are introduced to demonstrate the effectiveness of our strategy, including a performance comparison between FDR default deadlock assertion and the verification of local behavioural constraints induced by our approach, also using FDR.", "num_citations": "19\n", "authors": ["1598"]}
{"title": "prialt in Handel-C: an operational semantics\n", "abstract": " We describe an operational semantics for the hardware compilation language Handel-C [7], which is a C-like language with channel communication and parallel constructs which compiles down to mainly synchronously clocked hardware. The work in this paper builds on previous work describing the semantics of the \u201cprialt\u201d construct within Handel-C  [5] and a denotational semantics for part of the language [6]. We describe a key subset of the language and show how a design decision for the real language, namely that default guards in a prialt statement executed in \u201czero-time\u201d, has consequences for the complexity of the operational semantics. We present the operational semantics, along with a revised and completed prialt semantics, indicating clearly the interface between them. We then describe a notion of observational equivalence and present an example illustrating how we handle the complexity of\u00a0\u2026", "num_citations": "19\n", "authors": ["1598"]}
{"title": "Travelling processes\n", "abstract": " This paper describes a refinement-based development method for mobile processes. Process mobility is interpreted as the assignment or communication of higher-order variables, whose values are process constants or parameterised processes, in which target variables update their values and source variables lose their values. The mathematical basis for the work is Hoare and He\u2019s Unifying Theories of Programming (UTP). In this paper, we present a set of algebraic laws to be used for the development of mobile systems. The correctness of these laws is ensured by the UTP semantics of mobile processes. We illustrate our theory through a simple example that can be implemented in both a centralised and a distributed way. First, we present the \u03c0-calculus specification for both systems and demonstrate that they are observationally equivalent. Next, we show how the centralised system may be step-wisely\u00a0\u2026", "num_citations": "19\n", "authors": ["1598"]}
{"title": "A tutorial on the refinement calculus\n", "abstract": " In this paper we introduce the refinement calculus, 1 and describe a number of basic Laws governing its use. We describe the guarded command language and how its constructs may be introduced during the development of code from specifications. Each Law of the calculus is illustrated with an example of its use; at the end of the Section, most of these Laws are demonstrated with a suitable case study.", "num_citations": "19\n", "authors": ["1598"]}
{"title": "Crowdsourcing citizen science: Exploring the tensions between paid professionals and users\n", "abstract": " This paper explores the relationship between paid labour and unpaid users within the Zooniverse, a crowdsourced citizen science platform. The platform brings together a crowd of users to categorise data for use in scientific projects. It was initially established by a small group of academics for a single astronomy project, but has now grown into a multi-project platform that has engaged over 1.3 million users so far. The growth has introduced different dynamics to the platform as it has incorporated a greater number of scientists, developers, links with organisations, and funding arrangements\u2014each bringing additional pressures and complications. The relationships between paid/professional and unpaid/citizen labour have become increasingly complicated with the rapid expansion of the Zooniverse. The paper draws on empirical data from an ongoing research project that has access to both users and paid professionals on the platform. There is the potential through growing peer-to-peer capacity that the boundaries between professional and citizen scientists can become significantly blurred. The findings of the paper, therefore, address important questions about the combinations of paid and unpaid labour, the involvement of a crowd in citizen science, and the contradictions this entails for an online platform. These are considered specifically from the viewpoint of the users and, therefore, form a new contribution to the theoretical understanding of crowdsourcing in practice.", "num_citations": "18\n", "authors": ["1598"]}
{"title": "Unifying theories of programming in Isabelle\n", "abstract": " This is a tutorial introduction to the two most basic theories in Hoare & He\u2019s Unifying Theories of Programming and their mechanisation in the Isabelle interactive theorem prover. We describe the theories of relations and of designs (pre-postcondition pairs), interspersed with their formalisation in Isabelle and example mechanised proofs.", "num_citations": "18\n", "authors": ["1598"]}
{"title": "The tokeneer experiments\n", "abstract": " We describe an experiment conducted as part of a pilot project in the Verified Software Initiative (VSI). We begin by recounting the background to the VSI and its six initial pilot projects, and give an update on the current progress of each project. We describe one of these, the Tokeneer ID Station in greater detail. Tokeneer was developed by Praxis High Integrity Systems and SPRE for the US National Security Agency, and it has been acclaimed by the US National Academies as representing best practice in software development. To date, only five errors have been found in Tokeneer, and the entire project archive has been released for experimentation within the VSI. We describe the first experiment using the Tokeneer archive. Our objective is to investigate the dependability claims for Tokeneer as a security-critical system. Our experiment uses a model-based testing technique that exploits formal methods and\u00a0\u2026", "num_citations": "18\n", "authors": ["1598"]}
{"title": "Towards a methodology for software preservation\n", "abstract": " Only a small part of the research which has been carried out to date on the preservation of digital objects has looked specifically at the preservation of software. This is because the preservation of software has been seen as a less urgent problem than the preservation of other digital objects, and also the complexity of software artifacts makes the problem of preserving them a daunting one. Nevertheless, there are good reasons to want to preserve software. In this paper we consider some of the motivations behind software preservation, based on an analysis of software preservation practice. We then go on to consider what it means to preserve software, discussing preservation approaches, and developing a performance model which determines how the adequacy of the a software preservation method. Finally we discuss some implications for preservation analysis for the case of software artifacts.", "num_citations": "18\n", "authors": ["1598"]}
{"title": "A unified language of classes and processes\n", "abstract": " (2003) A unified language of classes and processes. In: St Eve: State-Oriented vs. Event-Oriented Thinking in Requirements Analysis, Formal Specification and Software Engineering.., Satellite Workshop at FM'03 (The full text of this publication is not currently available from this repository. You may be able to access a copy if URLs are provided)(KAR id: 13842)", "num_citations": "18\n", "authors": ["1598"]}
{"title": "Implementing promoted operations in Z\n", "abstract": " We describe the promotion technique in Z. Some of its formal properties have been investigated, and it has been shown how to perform data refinement on promoted operations. In this paper, we show how promotion is closely allied to procedures and their parameters. We take the most commonly used form of promotion, and show that it may be implemented using call-by-reference parameters.", "num_citations": "18\n", "authors": ["1598"]}
{"title": "Unifying theories of time with generalised reactive processes\n", "abstract": " Hoare and He's theory of reactive processes provides a unifying foundation for the formal semantics of concurrent and reactive languages. Though highly applicable, their theory is limited to models that can express event histories as discrete sequences. In this paper, we show how their theory can be generalised by using an abstract trace algebra. We show how the algebra, notably, allows us to consider continuous-time traces and thereby facilitate models of hybrid systems. We then use this algebra to reconstruct the theory of reactive processes in our generic setting, and prove characteristic laws for sequential and parallel processes, all of which have been mechanically verified in the Isabelle/HOL proof assistant.", "num_citations": "17\n", "authors": ["1598"]}
{"title": "Formal development of industrial-scale systems in circus\n", "abstract": " Circus is a new notation that may be used to specify both data and behavioural aspects of a system, and has an associated refinement calculus. In this work, we present rules to translate Circus programs to Java programs that use JCSP, a library that implements Communicating Sequential Processes constructs. These rules can be used as a complement to the Circus algebraic refinement technique, or as a guideline for implementation. They are a link between the results on refinement in the context of Circus and a practical programming language in current use. The rules can also be used as the basis for a tool that mechanises the translation. Although a few case studies are already available in the literature, the industrial fire control system, whose refinement and implementation is discussed in this paper, is, as far as we know, the largest case study on the Circus refinement strategy.", "num_citations": "17\n", "authors": ["1598"]}
{"title": "Mechanising the alphabetised relational calculus\n", "abstract": " In Hoare and He's unifying theories of programming, the alphabetised relational calculus is used to describe and relate different programming paradigms, including functional, imperative, logic, and parallel programming. In this paper, we give a formal semantics of the alphabetised relational calculus, and use our definition to create a deep embedding of the calculus in Z. This allows us to use one of the standard theorem provers for Z, in order to provide mechanised support for reasoning about programs in the unifying theory.", "num_citations": "17\n", "authors": ["1598"]}
{"title": "Engineering UToPiA\n", "abstract": " We describe the semantic domains for Compass Modelling Language (CML), using Hoare & He\u2019s Unifying Theories of Programming (UTP). CML has been designed to specify, design, compose, simulate, verify, test, and validate industrial systems of systems. CML is a semantically heterogeneous language, with state-rich imperative constructs based on VDM, communication and concurrency based on CSP, object orientation with object references, and discrete time based on Timed CSP. A key objective is to be semantically open, allowing further paradigms to be added, such as process mobility, continuous physical models, and stochastic processes. Our semantics deals separately with each paradigm, composing them with Galois connections, leading to a natural contract language for all constructs in all paradigms. The result is a compositional formal definition of a complex language, with the individual\u00a0\u2026", "num_citations": "16\n", "authors": ["1598"]}
{"title": "Linking VDM and Z\n", "abstract": " The International Grand Challenge in Verified Software is benchmarking current verification technology by conducting a series of experiments, and one such experiment is to build a verified POSIX-compliant flash filestore. An objective of this experiment is to combine different formal methods, and this raises issues about the different logics used. One significant area of difference is in the treatment of undefined expressions, and we show how this difference can be overcome using a unifying theory. This then allows us to use a theorem proverfor Z to verify theorems about a data type specified and refined in VDM.", "num_citations": "16\n", "authors": ["1598"]}
{"title": "Using circus for safety-critical applications\n", "abstract": " Circus is language that unifies Z, CSP, and the refinement calculus, and we describe its application in the development of safety-critical systems. We show the descriptive power of Circus with a fragment of the formalisation of the steam boiler problem. We then use Circus's refinement calculus to bridge a semantic gap in development, where we eliminate a kind of abstract event.", "num_citations": "16\n", "authors": ["1598"]}
{"title": "Simulink timed models for program verification\n", "abstract": " Simulink is widely used by engineers to provide graphical specifications of control laws;\u00a0its frequent use to specify safety-critical systems has motivated work on formal modelling and analysis of Simulink diagrams. The work that we present here is complementary:\u00a0it targets verification of implementations by providing a refinement-based model. We use CircusTime, a timed version of the Circus notation that combines Z, CSP, and Morgan\u2019s refinement calculus with a time model, and which is firmly based on Hoare\u00a0&\u00a0He\u2019s Unifying Theories of Programming. We present a modelling approach that formalises the simulation time model that is routinely used for analysis. It is distinctive in that we use a refinement-based notation and capture functionality, concurrency, and time. The models produced in this way, however, are not useful for program verification, due to an idealised simulation time model;\u00a0therefore, we\u00a0\u2026", "num_citations": "15\n", "authors": ["1598"]}
{"title": "Timed Circus: timed CSP with the miracle\n", "abstract": " Timed Circus is a compact extension to Circus, that is, it inherits only the CSP part of Circus while introducing time. Although it looks much like timed CSP from the viewpoint of syntax, its semantics is very different from that of timed CSP because it uses a complete lattice in the implication ordering instead of the complete partial order of the standard failures-divergences model of CSP. The complete lattice gives rise to a number of strange processes which violate some axioms of CSP, especially when the miracle (the top element) and SKIP meet time. In this paper, compared with timed CSP, we will extensively explore such strange processes which turn out to be very useful in specifying a distinct property that \"something must occur\". Finally, we use a simple example to demonstrate how our model can contribute to modelling temporal behaviours with multiple time scales in complex systems.", "num_citations": "15\n", "authors": ["1598"]}
{"title": "Unifying theories of interrupts\n", "abstract": " The concept of an interrupt is one that appears across many paradigms, and used in many different areas. It may be used as a device to assist specifications to model failure, or to describe complex interactions between non co-operating components. It is frequently used in hardware to allow complex scheduling patterns. Although interrupts are ubiquitous in usage, the precise behaviour of a system incorporating interrupts can be difficult to reason about and predict. In this paper, a complete theory of the interrupt operator presented by Hoare in his original treatment of CSP is proposed. The semantics are given in the CSP model in Unifying Theories of Programming. New and existing algebraic laws are proposed and justified. The contribution of the paper is therefore a denotational semantics of an interrupt operator, and a collection of algebraic laws that assist in reasoning about systems incorporating interrupts.", "num_citations": "15\n", "authors": ["1598"]}
{"title": "Pointers and records in the unifying theories of programming\n", "abstract": " We present a theory of pointers and records that provides a representation for objects and sharing in languages like Java and C++. Our approach to pointers is based on Paige\u2019s entity groups, which give an abstract view of storage as equivalence classes of variables that share the same memory location. We first define our theory as a restriction of the general theory of relations, and, as a consequence, it does not distinguish between terminating and non-terminating programs. Therefore, we link it with the theory of designs, providing a foundation for reasoning about total correctness of pointer-based sequential programs. Our work is a step towards the semantics of an object-oriented language that also integrates constructs for specifying state-rich and concurrent systems.", "num_citations": "15\n", "authors": ["1598"]}
{"title": "Semantic domains for Handel-C\n", "abstract": " Handel-C is a programming language which is a hybrid of CSP and C, designed to target hardware implementations, specifically field-programmable gate arrays (FPGAs). The language is C-like with CSP-like parallel constructs and channel communication added. All assignments and channel communication events take one clock cycle while all expression and conditional evaluations are deemed to be instantaneous. This report presents semantic domains required to give a denotational semantics of a simplified subset of the Handel-C language. We present the key domains and equations for a denotational semantics for Handel-C. The key contribution is that our semantics deals with a concurrent, deterministic language where events occur synchronously, in the presence of global shared variables. We exploit the finite and static nature of a Handel-C program s identifier space in order to define key concepts, such\u00a0\u2026", "num_citations": "15\n", "authors": ["1598"]}
{"title": "Derivation of Z refinement proof rules\n", "abstract": " The traditional set of data refinement rules for Z are stated in [Spivey 1992, section 5.6]. These are sufficient to prove many data refinements that occur in practice, but not all. In the late 1990s we performed the specification and full refinement proof of a large, industrial scale application, that of an Electronic Purse [Stepney et al. 2000]. In the course of this work we discovered that the traditional rules were not sufficient to prove our particular refinement. In particular, the traditional obligations assume the use of a \u2018forward\u2019(or \u2018downward\u2019) simulation, which was inappropriate for our application. We developed a more widely applicable set of Z data refinement proof obligations, for use on our project. These obligations allow both \u2018forward\u2019and \u2018backward\u2019simulations [Woodcock & Davies 1996, chapter 16], and also allow non-trivial initialisation, finalisation, and input/output refinement [Stepney et al. 1998].", "num_citations": "15\n", "authors": ["1598"]}
{"title": "A simpler semantics for Z\n", "abstract": " We compare two formal semantics for the Z notation: the first is Spivey\u2019s original semantics, and the second a new treament, which assigns the same meanings to language constructs. We start by recalling the varietal semantics of Z, and describe the semantic environment of a Z specification. Next, we describe a new semantic environment, and illustrate it by describing the semantic equations for schemas and schema designators. We contrast this description with the varietal approach.", "num_citations": "15\n", "authors": ["1598"]}
{"title": "Collaborative Modeling and Simulation for Cyber-Physical Systems\n", "abstract": " CONTENTS 8.1 Introduction 178 8.2 Background 179 8.3 Industrial Case Study: Distributed Interlocking 181 8.4 Toward Integrated Toolchains: The INTO-CPS Project 184 8.5 CPS Foundations 187", "num_citations": "14\n", "authors": ["1598"]}
{"title": "Refinement of the parallel CDx\n", "abstract": " The purpose of the CDx is to detect potential collisions of aircraft located by a radar device. We take the program discussed in [8] as a basis for the definition of our requirements. It uses a cyclic executive, and embeds the assumption that the radar collects (and buffers) a frame of aircraft positions that becomes available for input periodically. In each iteration, the CDx:(1) reads a frame;(2) carries out a voxel-hashing step that maps aircraft to voxels;(3) checks for collisions in each voxel; and (4) records and reports the number of detected collisions. Unlike [8], we allow aircraft to enter or leave the radar frame. Since the majority of the computation burden is in the checking for collisions in step (3), we propose a version of the CDx where this task is parallelised. As a result, we obtain an SCJ program that illustrates the features of SCJ Level 1. Our aim with the concurrent CDx is, most of all, to provide a genuine and more representative Level 1 application. Due to the novelty of the SCJ paradigm and technology, such applications are still difficult to come by in the public domain. On the other hand, even though we are not specifying a particular radar system, concurrent collision detection is a reasonable target to improve the performance of such an application. The program code is available via http://www. cs. york. ac. uk/circus/hijac/. A voxel is a volumetric element; all voxels together subdivide the entire space. The voxels in the CDx superimpose a coarse 2-dimensional grid on the xy plane with the height of a voxel extending along the entire z-axis. Thus, the altitude of aircraft is abstracted away. This reduces the number of necessary collision tests: after\u00a0\u2026", "num_citations": "14\n", "authors": ["1598"]}
{"title": "New Circus Time\n", "abstract": " The Circus family of languages is a collection of process algebras based on a combination of Z, for data modelling, and CSP, for behavioural modelling. Circus has a well-defined semantics based on Hoare and He\u2019s Unifying Theories of Programming. A refinement calculus has enabled its practical use for reasoning about implementations of control systems in a variety of languages, including Ada and Java. The work presented in this report enables the use of pre and postconditions for reasoning in the context of Circus Time, the timed version of Circus. It is based on constructs of Timed CSP, but takes advantage of the complete lattice defined by its UTP theory to cater for deadlines that capture restrictions on the environment. Here, we present a new UTP theory that builds on the existing semantics of Circus Time by providing a simpler mathematical model for capturing observations of traces and refusals, and more rigorous operators for describing behaviours of processes. For example, we change the definitions of prefix and external choice by weakening their preconditions and strengthening postconditions. Most importantly, all operators of our theory are defined in a way that allows the calculation of pre and postconditions of timed processes. This not only supports contract-based reasoning about models, but simplifies proof of Circus Time laws. We illustrate this point by exploring a comprehensive set of laws for the deadline operators.", "num_citations": "14\n", "authors": ["1598"]}
{"title": "A timed model of Circus with the reactive design miracle\n", "abstract": " We propose a timed model of Circus which is a compact extension of original Circus. Apart from introducing time, this model uses UTP-style semantics to describe each process as a reactive design. One of significant contributions of our timed model is to extensively explore the reactive design miracle, the top element of a complete lattice with respect to the implication ordering. The employment of the miracle brings a number of brand-new features such as deadline and urgent events, which provide a more powerful and flexible expressiveness in system specifications.", "num_citations": "14\n", "authors": ["1598"]}
{"title": "UTP semantics for Handel-C\n", "abstract": " Only limited progress has been made so far towards an axiomatic semantics or discovering the algebraic rules that characterise Handel-C programs. In this paper we present a UTP semantics together with extensions we needed to include in order to express Handel-C properties that were not addressable with standard UTP. We also show how our extensions can be abstracted to a more general context and prove a set of algebraic rules that hold for them. Finally, we use the semantics to prove some properties about Handel-C constructs.", "num_citations": "14\n", "authors": ["1598"]}
{"title": "FME'96: Industrial Benefit and Advances in Formal Methods: Third International Symposium of Formal Methods Europe Co-Sponsored by IFIP WG 14.3, Oxford, UK, March 18-22, 1996\u00a0\u2026\n", "abstract": " This book presents the refereed proceedings of the Third International Symposium of Formal Methods Europe, FME'96, held in Oxford, UK, in March 1996. FME'96 was co-sponsored by IFIP WG 14.3 and devoted to\" the application and demonstrated industrial benefit of formal methods, their new horizons and strengthened foundations\". The 35 full revised papers included were selected from a total of 103 submissions; also included are three invited papers. The book addresses all relevant aspects of formal methods, from the point of view of the industrial R & D professional as well as from the academic viewpoint, and impressively documents the significant progress in the use of formal methods for the solution of real-world problems.", "num_citations": "14\n", "authors": ["1598"]}
{"title": "What can agile methods bring to high-integrity software development?\n", "abstract": " Considering the issues and opportunities raised by Agile practices in the development of high-integrity software.", "num_citations": "13\n", "authors": ["1598"]}
{"title": "Robochart reference manual\n", "abstract": " The current practice of programming mobile and autonomous robots does not reflect the modern outlook of their applications. Such practice is often based on standard state machines, without formal semantics, to describe the robot controller only, with time and probabilistic properties discussed in natural language. In the design stage, the state machine guides the development of a simulation, but no rigorous connection between them is established.In this report, we present a state-machine based notation, called RoboChart, for the specification and design of robotic systems. Besides state machines, RoboChart includes elements to organise specifications, fostering reuse and taming complexity. These extra constructs embed the notions of robotic platforms and their controllers; communication between controllers can be synchronous or asynchronous. The state-machine notation is fully specified, including an action language and constructs to specify timing and probabilistic properties. Operations used in a state machine can be taken from a domain-specific API or defined by other state machines; communication between state machines inside a controller is synchronous. Operations can be given pre and postconditions.", "num_citations": "13\n", "authors": ["1598"]}
{"title": "Verified Software: Theories, Tools, Experiments: First IFIP TC 2/WG 2.3 Conference, VSTTE 2005, Zurich, Switzerland, October 10-13, 2005, Revised Selected Papers and Discussions\n", "abstract": " A Step Towards Verified Software Worries about the reliability of software are as old as software itself; techniques for allaying these worries predate even James King\u2019s 1969 thesis on \u201cA program verifier.\u201d What gives the whole topic a new urgency is the conjunction of three phenomena: the blitz-like spread of software-rich systems to control ever more facets of our world and our lives; our growing impatience with deficiencies; and the development\u2014proceeding more slowly, alas, than the other two trends\u2014of techniques to ensure and verify software quality. In 2002 Tony Hoare, one of the most distinguished contributors to these advances over the past four decades, came to the conclusion that piecemeal efforts are no longer sufficient and proposed a \u201cGrand Challenge\u201d intended to achieve, over 15 years, the production of a verifying compiler: a tool that while processing programs would also guarantee their adherence to specified properties of correctness, robustness, safety, security and other desirable properties. As Hoare sees it, this endeavor is not a mere research project, as might normally be carried out by one team or a small consortium of teams, but a momentous endeavor, comparable in its scope to the successful mission to send a man to the moon or to the sequencing of the human genome.", "num_citations": "13\n", "authors": ["1598"]}
{"title": "A denotational semantics for Handel-C hardware compilation\n", "abstract": " Handel-C is a hybrid language based on C and CSP for the high level description of hardware components. Several semantic models for the language and a non-rigorous compilation mechanism have been proposed for it. The compilation has been empirically validated and used in commercial tools, but never formally verified. This work presents a semantic model of the generated hardware and establishes the foundations for the formal verification of correctness of the transformation approach.", "num_citations": "13\n", "authors": ["1598"]}
{"title": "Operational semantics for Circus\n", "abstract": " Circus is a combination of Z, CSP, and the refinement calculus, and is based on Hoare & He\u2019s Unifying Theories of Programming. We follow their approach in defining an SOS-style operational semantics for the imperative and behavioural parts of Circus whose soundness is proved with respect to a denotational semantics. Our novelty lies in completing this work for an integrated language, combining the individual semantics. The soundness of each rule in our operational semantics depends on a particular algebraic law.", "num_citations": "13\n", "authors": ["1598"]}
{"title": "Procedures and recursion in the refinement calculus\n", "abstract": " Morgan's approach to program development is a refinement calculus: using this method, programs are developed from specifications through the successive application of refinement laws. This programming technique has been widely accepted, but it has been shown that Morgan's approach to procedures and parameters has an inconsistency. Back presents an alternative formalisation of procedures and parameters which is consistent, but does not propose any refinement law. In this paper, we present refinement laws that allow the development of (possibly parametrised and recursive) procedures in the style of Morgan, and derive these laws based on Back's formalism. Some of the refinement laws we present have a counterpart in Morgan's calculus, but some are new laws that support his approach to the development of recursive procedures", "num_citations": "13\n", "authors": ["1598"]}
{"title": "Calculational verification of reactive programs with reactive relations and Kleene algebra\n", "abstract": " Reactive programs are ubiquitous in modern applications, and so verification is highly desirable. We present a verification strategy for reactive programs with a large or infinite state space utilising algebraic laws for reactive relations. We define novel operators to characterise interactions and state updates, and an associated equational theory. With this we can calculate a reactive program\u2019s denotational semantics, and thereby facilitate automated proof. Of note is our reasoning support for iterative programs with reactive invariants, which is supported by Kleene algebra. We illustrate our strategy by verifying a reactive buffer. Our laws and strategy are mechanised in Isabelle/UTP, which provides soundness guarantees, and practical verification support.", "num_citations": "12\n", "authors": ["1598"]}
{"title": "Checking SysML models for co-simulation\n", "abstract": " Cyber-physical systems (CPSs) are often treated modularly to tackle both complexity and heterogeneity; and their validation may be done modularly by co-simulation: the coupling of the individual subsystem simulations. This modular approach underlies the FMI standard. This paper presents an approach to verify both healthiness and well-formedness of an architectural design, expressed using a profile of SysML, as a prelude to FMI co-simulation. This checks the conformity of component connectors and the absence of algebraic loops, necessary for co-simulation convergence. Verification of these properties involves theorem proving and model-checking using: Fragmenta, a formal theory for representing typed visual models, with its mechanisation in the Isabelle/HOL proof assistant, and the CSP process algebra and its FDR3 model-checker. The paper\u2019s contributions lie in: a SysML profile for architectural\u00a0\u2026", "num_citations": "12\n", "authors": ["1598"]}
{"title": "Taking our own medicine: Applying the refinement calculus to state-rich refinement model checking\n", "abstract": " In this paper, we advocate the use of formal specification and verification in software development for high-integrity and safety-critical systems, where mechanical proof plays a central role. In particular, we emphasise the crucial importance of applying verification in the development of formal verification tools themselves. We believe this approach is very useful to increase the levels of confidence and integrity of tools that are built to find bugs based on formally specified models. This follows the trend set out by a UK grand challenge in computer research for verified software repository.               In this direction, we present our experiences on a case study on the development process of a refinement model checking tool for Circus, a concurrent refinement language that combines Z, CSP, guarded commands, and the refinement calculus, with the Unifying Theories of Programming of Hoare and He as the\u00a0\u2026", "num_citations": "12\n", "authors": ["1598"]}
{"title": "Robochart: a state-machine notation for modelling and verification of mobile and autonomous robots\n", "abstract": " Autonomous and mobile robots are becoming ubiquitous. From domestic robotic vacuum cleaners to driverless cars, such robots interact with their environment and humans, leading to potential safety hazards. We propose a three-pronged solution to the problem of safety of mobile and autonomous robots:(1) domain-specific modelling with a formal underpinning;(2) automatic generation of sound simulations; and (3) verification based on model checking and theorem proving. Here, we report on a UML-like notation called RoboChart, designed specifically for modelling autonomous and mobile robots, and including timed and probabilistic primitives. We discuss a denotational semantics for a core subset of RoboChart, an approach for the development of sound simulations, and an implementation of RoboChart and its formal semantics as an Eclipse plugin supported by the CSP model checker FDR.", "num_citations": "11\n", "authors": ["1598"]}
{"title": "Rapid prototyping of a semantically well founded Circus model checker\n", "abstract": " Nowadays academia and industry use model checkers. These tools use search-based algorithms to check the satisfaction of some property f in M. Formally, M\u2009\u22a7\u2009f, where M is a transition system representation of a specification written in a language L. Such a representation may come from the semantics of L. This paper presents a rapid prototyping of a model checker development strategy for Circus\u00a0 based on its operational semantics. We capture this semantics with the Microsoft FORMULA framework and use it to analyse (deadlock, livelock, and nondeterminism of) Circus specifications. As FORMULA supports SMT-solving, we can handle infinite data communications and predicates. Furthermore, we create a semantically well founded Circus model checker as long as executing FORMULA is equivalent to reasoning with First-Order Logic (Clark completion). We illustrate the use of the model-checker with\u00a0\u2026", "num_citations": "11\n", "authors": ["1598"]}
{"title": "Formal Methods and Software Engineering: 12th International Conference on Formal Engineering Methods, ICFEM 2010, Shanghai, China, November 17-19, 2010, Proceedings\n", "abstract": " Formal methods have made significant progress in recent years with successful stories from Microsoft (SLAM project), Intel (i7 processor verification) and NICTA/OK-Lab (formal verification of an OS kernel). The main focus of formal engineering methods lies in how formal methods can be effectively integrated into mainstream software engineering. Various advanced theories, techniques and tools have been proposed, developed and applied in the specification, design and verification of software or in the construction of software. The challenge now is how to integrate them into engineering development processes to effectively deal with large-scale and complex computer systems for their correct and efficient construction and maintenance. This requires us to improve the state of the art by researching effective approaches and techniques for integration of formal methods into industrial engineering practice, including\u00a0\u2026", "num_citations": "11\n", "authors": ["1598"]}
{"title": "A Chain Datatype in Z.\n", "abstract": " We present results about a general-purpose chain datatype specified in the Z notation and mechanised using the Z/Eves theorem prover. Our particular interest comes from its use in the specification and refinement of operating system kernels for embedded real-time devices as part of a pilot project within the international Grand Challenge in Verified Software, and to contribute to the Verified Software Repository. We show\u2014at a fairly high level\u2014the sort of dogged work that is needed to get a body of results together to form a basis for future projects. Our work discusses important hidden and missing properties in the specification of the chain datatype and its relation to kernel design.", "num_citations": "11\n", "authors": ["1598"]}
{"title": "A \u201chardware compiler\u201d semantics for Handel-C\n", "abstract": " We present a denotational semantics for the hardware compilation language Handel-C that maps language constructs to a set of equations, which describe the structure of the resulting hardware. This semantics is then shown to be useful for validating various algebraic laws which should hold for Handel-C programs, as well as exposing a key principle which governs how such hardware should be operated.", "num_citations": "11\n", "authors": ["1598"]}
{"title": "From formalised state machines to implementations of robotic controllers\n", "abstract": " Controllers  for autonomous  robotic systems  can be  specified  using state machines  . However, these are typically developed in an ad hoc manner without formal semantics, which makes it difficult to analyse the controller. Simulations are often used during the development, but a rigorous connection between the designed controller and the implementation is often overlooked. This paper presents a state-machine based notation, RoboChart, together with a tool to automatically create code from the state machines, establishing a rigorous connection between specification and implementation. In RoboChart, a robot\u2019s controller is specified either graphically or using a textual description language. The controller code for simulation is automatically generated through a direct mapping from the specification. We demonstrate our approach using two case studies (self-organized aggregation and swarm taxis) in\u00a0\u2026", "num_citations": "10\n", "authors": ["1598"]}
{"title": "Behavioural models for FMI co-simulations\n", "abstract": " Simulation is a favoured technique for analysis of cyber-physical systems. With their increase in complexity, co-simulation, which involves the coordinated use of heterogeneous models and tools, has become widespread. An industry standard, FMI, has been developed to support orchestration; we provide the first behavioural semantics of FMI. We use the state-rich process algebra, $${{\\textsf {\\textit{Circus}}}}$$, to present our modelling approach, and indicate how models can be automatically generated from a description of the individual simulations and their dependencies. We illustrate the work using three algorithms for orchestration. A stateless version of the models can be verified using model checking via translation to CSP. With that, we can prove important properties of these algorithms, like termination and determinism, for example. We also show that the example provided in the FMI standard is not\u00a0\u2026", "num_citations": "10\n", "authors": ["1598"]}
{"title": "Refinement-based verification of the FreeRTOS scheduler in VCC\n", "abstract": " We describe our experience with verifying the scheduler-related functionality of FreeRTOS, a popular open-source embedded real-time operating system. We propose a methodology for carrying out refinement-based proofs of functional correctness of abstract data types in the popular code-level verifier VCC. We then apply this methodology to carry out a full machine-checked proof of the functional correctness of the FreeRTOS scheduler. We describe the bugs found during this exercise, the fixes made, and the effort involved.", "num_citations": "10\n", "authors": ["1598"]}
{"title": "Using formal reasoning on a model of tasks for FreeRTOS\n", "abstract": " FreeRTOS is an open-source real-time microkernel that has a wide community of users. We present the formal specification of the behaviour of the task part of FreeRTOS that deals with the creation, management, and scheduling of tasks using priority-based preemption. Our model is written in the Z notation, and we verify its consistency using the Z/Eves theorem prover. This includes a precise statement of the preconditions for all API commands. This task model forms the basis for three dimensions of further work: (a) the modelling of the rest of the behaviour of queues, time, mutex, and interrupts in FreeRTOS; (b) refinement of the models to code to produce a verified implementation; and (c) extension of the behaviour of FreeRTOS to multi-core architectures. We propose all three dimensions as benchmark challenge problems for Hoare\u2019s Verified Software Initiative.", "num_citations": "10\n", "authors": ["1598"]}
{"title": "An approach for managing semantic heterogeneity in systems of systems engineering\n", "abstract": " Semantic heterogeneity is a significant challenge to integration in Systems of Systems Engineering (SoSE) due the large variety of languages, domains and tools which are used in their construction. In this paper we envision a strategy for managing this heterogeneity by decomposing domain specific languages into their \u201cbuilding block\u201d theories which can be independently analysed, and used as a basis for linking with similar notations. This provides a systematic approach to building a tool-chain which integrates the different theories, methods and tools used in SoSE. Our approach has been piloted on the development of theories enabling machine-supported analysis of SysML models of SoSs. We conclude that the approach has further potential and identify lines of future research, notably in techniques for handling mixed discrete and continuous behaviour, timebands, mobility and model integration in SoSE.", "num_citations": "10\n", "authors": ["1598"]}
{"title": "State visibility and communication in unifying theories of programming\n", "abstract": " We explore the interactions between program-variable state visibility and communication behaviour in state-rich CSP-like processes, using the unifying theories of programming (UTP) framework. The key results of this work are: having variable state visible while a process is waiting to communicate, results in an operationally complex theory of behaviour; by contrast, considering state as unobservable during communication wait periods results in an elegant theory, with much cleaner operational intuitions. The language constructs most affected by this observability choice are those of external choice and parallel composition. We also discuss situations where this state hiding can prevent the adoption of interesting operators that seize control from waiting processes.", "num_citations": "10\n", "authors": ["1598"]}
{"title": "FDR explorer\n", "abstract": " We describe: (1) the internal structures of FDR, the refinement model checker for Hoare\u2019s Communicating Sequential Processes (CSP); and (2) an application-programming interface (API) that allows users to interact more closely with FDR and to have finer-grain control over its behaviour and data structures. This API makes it possible to create optimised CSP code to perform refinement checks that are more space or time efficient, enabling the analysis of more complex and data-intensive specifications. The API can be used either by those constructing CSP models or by tools that automatically generate CSP code. We present examples of using our tool, including handling advanced FDR features such as transparent functions, which compress state spaces before checking. We also show how to transform FDR\u2019s graph format into a graph notation such as JGraph, enabling visualisation of labelled transition\u00a0\u2026", "num_citations": "10\n", "authors": ["1598"]}
{"title": "Automatic generation of verified concurrent hardware\n", "abstract": " The complexity inherent to concurrent systems can turn their development into a very complex and error-prone task. The use of formal languages like CSP and tools that support them simplifies considerably the task of developing such systems. This process, however, usually aims at reaching an executable program:\u00a0a translation between the specification language and a practical programming language is still needed and is usually rather problematic. In this paper we present a translation framework and a tool, csp2hc, that implements it. This framework provides an automatic translation from a subset of CSP to Handel-C, a programming language that is similar to standard C, but whose programs can be converted to produce files to program an FPGA.", "num_citations": "10\n", "authors": ["1598"]}
{"title": "Verified Software Grand Challenge.\n", "abstract": " Introduction\u2022 industrial software usually has extensive documentation\u2022\u2026 but software behaviour is often a complete surprise!\u2022 programing is hard\u2013reduce a problem to a set of rules that can be blindly followed by a computer\u2022 components interact and interfere\u2022 undesirable properties emerge\u2022 systems fail to satisfy their users\u2019 needs", "num_citations": "10\n", "authors": ["1598"]}
{"title": "State-rich model checking\n", "abstract": " In this paper we survey the area of formal verification techniques, with emphasis on model checking due to its wide acceptance by both academia and industry. The major approaches and their characteristics are presented, together with the main problems faced while trying to apply them. With the increased complexity of systems, as well as interest in software correctness, the demand for more powerful automatic techniques is pushing the theories and tools towards integration. We discuss the state of the art in combining formal methods tools, mainly model checking with theorem proving and abstract interpretation. In particular, we present our own recent contribution on an approach to integrate model checking and theorem proving to handle state-rich systems specified using a combination of Z and CSP.", "num_citations": "10\n", "authors": ["1598"]}
{"title": "When to trust mobile objects: access control in the Jini/sup TM/Software System\n", "abstract": " Future developments in computing, and in consumer electronics, will involve a considerable degree of convergence: applications will work together to locate and provide services. If this convergence is to be implemented successfully, then a shared model for reliable service provision is required. The recently released Jini/sup TM/ Software System (1.0) is an attempt to meet this requirement through object orientation. Based entirely upon existing Java/sup TM/ 2 technology, Jini is a set of protocols and programming models for peer-to-peer service provision using downloaded code and remote method invocation. The paper examines the way in which the Jini Software System will be used. It shows that the existing mechanisms for access control and secure operation provided by Java may prove inadequate in a Jini environment: a Jini enabled device will be vulnerable to attack from its peers. Similar problems may be\u00a0\u2026", "num_citations": "10\n", "authors": ["1598"]}
{"title": "An introduction to refinement in Z\n", "abstract": " An Introduction to Refinement in Z | Proceedings of the 4th International Symposium of VDM Europe on Formal Software Development-Volume 2: Tutorials ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsVDM '91An Introduction to Refinement in Z ARTICLE An Introduction to Refinement in Z Share on Author: Jim CP Woodcock profile image Jim Woodcock View Profile Authors Info & Affiliations Publication: VDM '91: Proceedings of the 4th International Symposium of VDM Europe on Formal Software Development-Volume 2: TutorialsOctober 1991 Pages 96\u2013117 0citation 0 Downloads Metrics Total Citations0 Total \u2026", "num_citations": "10\n", "authors": ["1598"]}
{"title": "Model checking of state-rich formalism by linking to \n", "abstract": " Since state-rich formalism                                                                              is a combination of Z, CSP, refinement calculus and Dijkstra\u2019s guarded commands, its model checking is intrinsically more complicated and difficult than that of individual state-based languages or process algebras. Current solutions translate executable constructs of                                                                              programs to Java with JCSP, or translate them to CSP processes. Data aspects of                                                                              programs are expressed in the Java programming language or as CSP processes. Both of them have disadvantages. This work presents a new approach to model-checking                                                                              by linking it to ; then we utilise ProB to model-check and animate the  program. The most significant advantage of this approach is the direct mapping of the state part in\u00a0\u2026", "num_citations": "9\n", "authors": ["1598"]}
{"title": "Predicate transformers in the semantics of Circus\n", "abstract": " Circus is a combination of Z and CSP; its chief distinguishing feature is the inclusion of the ideas of the refinement calculus. The main objective is the definition of refinement methods for concurrent programs. The original semantic model for Circus is Hoare and He's unifying theories of programming. An equivalent semantics based on predicate transformers is presented. With this model, a more adequate basis for the formalisation of refinement and verification-condition generation rules is provided. Furthermore, this framework makes it possible to include logical variables and angelic nondeterminism in Circus. The consistency of the relational and predicate transformer models gives us confidence in their accuracy.", "num_citations": "9\n", "authors": ["1598"]}
{"title": "The Formal Specification in Z of Defence Standard 00\u201356\n", "abstract": " We give a formal specification of the safety analysis elements of the Revised Defence Standard 00\u201356, which describes procedures for the development of safety-critical systems. The specification is written in the Z notation, and, as it is an unusual application of formal methods, we reflect on the positive aspects of the experience as well as the main difficulties.", "num_citations": "9\n", "authors": ["1598"]}
{"title": "Model checking CML: tool development and industrial applications\n", "abstract": " A model checker is an automatic tool that traverses a specific structure (normally a Kripke structure referred as the model M) to check the satisfaction of some (temporal) logical property f. This is formally stated as . For some formal notations, the model M of a specification S (written in a formal language L) can be described as a labelled transition system (LTS). Specifically, it is not clear in general how usual tools such as SPIN, FDR, PAT, etc., create the LTS representation from a given process. Although one expects the coherence of the LTS generation with the semantics of L, it is completely hidden inside the model checker itself. In this paper we show how to create a model checker for L, using a development approach based on its operational semantics. We use a systematic semantics embedding and the formal modeling using logic programming and analysis (FORMULA) framework to this end. We\u00a0\u2026", "num_citations": "8\n", "authors": ["1598"]}
{"title": "The COMPASS modelling language: timed semantics in UTP\n", "abstract": " We describe the denotational semantics of a subset of the COMPASS Modelling Language (CML), using Hoare & He\u2019s Unifying Theories of Programming. The subset consists of rich state and operations based on VDM, concurrency and communication, based on CSP, and discrete time, based on Timed CSP. Other features of CML not treated here include object orientation, pointers and object references, and mobile processes and channels; extensions planned for the future include priority, probabilistic choice, and continuous time. A rich collection of language features such as this presents significant challenges when building a formal semantics, so the approach taken in CML is compositional: each feature is given a separate semantics and a domain-specific language is then composed from whichever features are required for the job in hand. Composition is achieved from the use of Galois connections. In this paper, we describe the semantics for the timed, imperative process algebra subset of CML. We adopt a semantic domain suggested by Lowe & Ouaknine\u2014timed testing traces\u2014as the basis for our UTP semantics. We include an example CML specification taken from industry: a leadership election protocol for a system of systems.", "num_citations": "8\n", "authors": ["1598"]}
{"title": "Formalising the timebands model in timed Circus\n", "abstract": " Complex real-time systems exhibit dynamic behaviours on many different time levels. To cope with the wide range of time scales and produce more dependable computer-based systems, we develop a timebands model that can explicitly recognise a finite set of distinct time bands in which temporal properties and associated behaviours are described. In general, the common way to deal with multiple-level behaviour of a system is to embed time granularity into a logical specification. Therefore, we propose a timed version of Circus to embody time granularity. Timed Circus is a compact extension to Circus; that is, it inherits only the CSP part of Circus while introducing time. However, this model is very different from timed CSP, since it uses a complete lattice instead of the expected complete partial order. The complete lattice gives rise to a number of strange processes which can violate many fundamental assumptions\u00a0\u2026", "num_citations": "8\n", "authors": ["1598"]}
{"title": "Embedding the timed Circus in PVS\n", "abstract": " We present an embedding of a timed model of Circus with the reactive design miracle in the PVS theorem prover. Our work, originally built on Dutertre\u2019s embedding of the traces model of CSP, provides a platform for the formal verification of various definitions and refinement laws as well as the correctness of systems specified by this model. The new timed model is given a denotational semantics based on Unifying Theories of Programming (UTP), describing each process as a reactive design and using the reactive design miracle to model some brand-new features of a system, which cannot be properly represented by the failures-divergences model of CSP.", "num_citations": "8\n", "authors": ["1598"]}
{"title": "An architecture for Circus tools\n", "abstract": " Circus is a concurrent language tailored for refinement that combines Z, CSP, and the refinement calculus using Hoare and He\u2019s Unifying Theories of Programming (UTP). In this paper we present our architecture that extends an ongoing effort of Community Z Tools (CZT) that implements tools for Standard Z. This includes: a specification processing front-end that allows parsing, prettyprinting, and typechecking of Circus; a theorem proving module; a compiler useful for animation and prototyping; and a refinement model checker.", "num_citations": "8\n", "authors": ["1598"]}
{"title": "A weakest precondition semantics for Circus\n", "abstract": " Circus is a combination of Z and CSP; its chief distinguishing feature is the inclusion of the ideas of the refinement calculus. Our main objective is the definition of refinement methods for concurrent programs. The original semantic model for Circus is Hoare and He's unifying theories of programming. In this paper, we present an equivalent semantics based on predicate transformers. With this new model, we provide a more adequate basis for the formalisation of refinement and verification condition generating rules. Furthermore, this new framework makes it possible to include logical variables and angelic nondeterminism in Circus. The consistency of the relational and predicate transformer models gives us confidence in their accuracy.", "num_citations": "8\n", "authors": ["1598"]}
{"title": "Proceedings of the Third International Symposium of Formal Methods Europe on Industrial Benefit and Advances in Formal Methods\n", "abstract": " Proceedings of the Third International Symposium of Formal Methods Europe on Industrial Benefit and Advances in Formal Methods | Guide Proceedings ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsFME '96 ABSTRACT No abstract available. Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide Proceedings cover image FME '96: Proceedings of the Third International Symposium of Formal Methods Europe on Industrial Benefit and Advances in Formal \u2026", "num_citations": "8\n", "authors": ["1598"]}
{"title": "The refinement calculus\n", "abstract": " The Refinement Calculus | Proceedings of the 4th International Symposium of VDM Europe on Formal Software Development-Volume 2: Tutorials ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsVDM '91The Refinement Calculus ARTICLE The Refinement Calculus Share on Author: Jim CP Woodcock profile image Jim Woodcock View Profile Authors Info & Affiliations Publication: VDM '91: Proceedings of the 4th International Symposium of VDM Europe on Formal Software Development-Volume 2: TutorialsOctober 1991 Pages 80\u201395", "num_citations": "8\n", "authors": ["1598"]}
{"title": "Transaction processing primitives and CSP\n", "abstract": " Several primitives for transaction processing systems are developed using the notations of Communicating Sequential Processes. The approach taken is to capture each requirement separately, in the simplest possible context: The specification is then the conjunction of all these requirements. As each is developed as a predicate over traces of the observable events in the system, it is also implemented as a simple communicating process; the implementation of the entire system is then merely the parallel composition of these processes. The laws of CSP are then used to transform the system to achieve the required degree of concurrency, to make it suitable for execution in a multiple-tasking system, for example. Finally, there is a discussion of how state-based systems may be developed using this approach together with some appropriate notation for specifying and refining data structures and operations upon them\u00a0\u2026", "num_citations": "8\n", "authors": ["1598"]}
{"title": "Probabilistic semantics for RoboChart\n", "abstract": " We outline a probabilistic denotational semantics for the RoboChart language, a diagrammatic, domain-specific notation for describing robotic controllers with their hardware platforms and operating environments. We do this using a powerful (but perhaps not so well known) semantic technique: He, Morgan, and McIver\u2019s weakest completion semantics, which is based on Hoare and He\u2019s Unifying Theories of Programming. In this approach, we do the following: (1) start with the standard semantics for a nondeterministic programming language; (2) propose a new probabilistic semantic domain; (3) propose a forgetful function from the probabilistic semantic domain to the standard semantic domain; (4) use the converse of the forgetful function to embed the standard semantic domain in the probabilistic semantic domain; (5) demonstrate that this embedding preserves program structure; (6) define the\u00a0\u2026", "num_citations": "7\n", "authors": ["1598"]}
{"title": "Towards verification of cyber-physical systems with UTP and Isabelle/HOL\n", "abstract": " In this paper, we outline our vision for building verification tools for Cyber-Physical Systems based on Hoare and He\u2019s Unifying Theories of Programming (UTP) and interactive proof technology in Isabelle/HOL. We describe our mechanisation and explain some of the design decisions that we have taken to get a convenient and smooth implementation. In particular, we describe our use of lenses to encode state. We illustrate our work with an example UTP theory and describe the implementation of three foundational theories: designs, reactive processes, and the hybrid relational calculus. We conclude by reflecting on how tools are linked by unifying theories.", "num_citations": "7\n", "authors": ["1598"]}
{"title": "Modelling temporal behaviour in complex systems with timebands\n", "abstract": " Complex real-time systems exhibit dynamic behaviours on many different time levels. To cope with the wide range of time scales and produce more dependable computer-based systems, we develop a Timebands model that can explicitly recognise a finite set of distinct time bands in which temporal properties and associated behaviours are described. In order to formalise the Timebands model, we propose a new timed model, named Timed Circus, of Circus, which is the combination of Z, CSP, and the refinement calculus in the setting of Unifying Theories of Programming. Different from most approaches such as Timed CSP, Timed Circus uses a complete lattice in the implication ordering to model the distinctive features of the Timebands model. As a result, the semantics of the Timebands model is built upon Timed Circus to guarantee soundness of each operator and maintain consistency and coordination\u00a0\u2026", "num_citations": "7\n", "authors": ["1598"]}
{"title": "Modelling and implementing complex systems with timebands\n", "abstract": " We describe how to use a timeband architecture to model real-time requirements. The architecture separates requirements that use different time units, producing a family of models. Each model is characterised by its granularity and precision. These models are then linked using superposition, a kind of event refinement, and a loose synchronisation of their time units, with respect to their precision. Our models are written using CSP and checked using the FDR model checker. More complicated models use Circus, the state-rich process algebra. We show how to implement such a timeband architecture using the JCSP Java class library.", "num_citations": "7\n", "authors": ["1598"]}
{"title": "Unifying theories of undefinedness\n", "abstract": " We propose a unifying theory of undefined expressions in logics used for formally specifying software systems. We show how to use classical logic to prove facts in a monotonic partial logic with guards, and we exhibit guards for several different semantical systems. We show how classical logic can be used to prove semi-classical facts. The mechanical theorem prover Z/Eves is used to prove facts about semi-classical Z specifications, although it uses classical logic; it does this with guards from McCarthy logic. It can also be used to prove facts about VDM specifications. The use of left-to-right guards guarantees, for example, that every theorem proved in Z/Eves is valid in VDM and in Z.", "num_citations": "7\n", "authors": ["1598"]}
{"title": "Fdr explorer\n", "abstract": " In this paper we describe the internal structures of FDR, the refinement model checker for Hoare's Communicating Sequential Processes (CSP), as well as an Application Programming Interface (API) allowing one to interact more closely with, and have fine grained control over, FDR's behaviour and data structures. With such information it is possible to create optimised CSP code to perform refinement checks that are more space/time efficient, hence enabling the analysis of more complex and data intensive specifications. This information is very valuable for both CSP users and tools that automatically generate CSP code, such as those related to security analysis generating test-cases as CSP processes. We also present a simple example of using the tool. Finally, we show how one can transform FDR's graph format into a graph notation (e.g., JGraph), hence enabling visualisation of Labelled Transition Systems\u00a0\u2026", "num_citations": "7\n", "authors": ["1598"]}
{"title": "An operational semantics for handel-c\n", "abstract": " We describe an operational semantics for the hardware compilation language Handel-C [10], which is a C-like language with channel communication and parallel constructs which compile down to mainly synchronously clocked hardware. The work in this paper builds on previous work describing the semantics of priority within Handel-C [9] and a denotational semantics for part of the language [8]. We describe a key subset of the language and show how a design decision for the real language, namely that default guards in prialt-statement executed in \"zero-time\", has consequences for the complexity of the operational semantics. We present the operational semantics, indicating clearly how it interfaces with the priority semantics of [9]. We then describe a notion of observational equivalence, and present an example illustrating how we handle the complexity of nested prialts in default guards.", "num_citations": "7\n", "authors": ["1598"]}
{"title": "Supporting rigorous reviews of formal specifications using fault trees\n", "abstract": " Reviews of specifications for fault detection can reduce the cost and risk of software projects because faults can be eliminated in the early phases of their development (eg, requirements specification, design specification). In order to make reviews on a large scale effective, it is important to use a systematic method that allows the reviewer to focus on a manageable component at each time and provides an automatic analysis based on the reviews of all the related components. In this paper we put forward a rigorous reviews method for the verification of formal specifications based on fault tree analysis. Taking SOFL as the target specification language, we describe principles for constructing fault trees, and an application of the proposed technique to the specification of a Railway Crossing Controller.", "num_citations": "7\n", "authors": ["1598"]}
{"title": "Event refinement in state-based concurrent systems\n", "abstract": " Operations on action systems may be defined corresponding to CSP hiding and renaming. These are of particular use in describing the refinement between action systems in which the granularity of actions is altered. We derive a simplified expression for hiding sets of actions and present sufficient conditions for forwards simulation in which the concrete system uses hiding and renaming. Both of these reduce the complexity of proofs of refinement. We present a case study in specification and refinement using action systems which makes use of the operations and refinement rules previously defined.", "num_citations": "7\n", "authors": ["1598"]}
{"title": "RiskStructures: A design algebra for risk-aware machines\n", "abstract": " Machines, such as mobile robots and delivery drones, incorporate controllers responsible for a task while handling risk (eg anticipating and mitigating hazards; preventing and alleviating accidents). We refer to machines with this capability as risk-awaremachines. Risk awareness includes robustness and resilience and complicates monitoring (ie, introspection, sensing, prediction), decision making, and control. From an engineering perspective, risk awareness adds a range of dependability requirements to system assurance. Such assurance mandates a correct-by-construction approach to controller design, based on mathematical theory. We introduce RiskStructures, an algebraic framework for risk modelling intended to support the design of safety controllers for risk-aware machines. Using the concept of a risk factor as a modelling primitive, this framework provides facilities to construct, examine, and assure these\u00a0\u2026", "num_citations": "6\n", "authors": ["1598"]}
{"title": "Heterogeneous semantics and unifying theories\n", "abstract": " Model-driven development is being used increasingly in the development of modern computer-based systems. In the case of cyber-physical systems (including robotics and autonomous systems) no single modelling solution is adequate to cover all aspects of a system, such as discrete control, continuous dynamics, and communication networking. Instead, a heterogeneous modelling solution must be adopted. We propose a theory engineering technique involving Isabelle/HOL and Hoare\u00a0&\u00a0He\u2019s Unifying Theories of Programming. We illustrate this approach with mechanised theories for building a contractual theory of sequential programming, a theory of pointer-based programs, and the reactive theory underpinning CSP\u2019s process algebra. Galois connections provide the mechanism for linking these theories.", "num_citations": "6\n", "authors": ["1598"]}
{"title": "Correct hardware synthesis\n", "abstract": " This paper presents an algebraic compilation approach to the correct synthesis (compilation into hardware) of a synchronous language with shared variables and parallelism. The synthesis process generates a hardware component that implements the source program by means of gradually reducing it into a highly parallel state-machine. The correctness of the compiler follows by construction from the correctness of the transformations involved in the synthesis process. Each transformation is proved sound from more basic algebraic laws of the source language; the laws are themselves formally derived from a denotational semantics expressed in the Unified Theories of Programming. The proposed approach is based on previous efforts that handle both software and hardware compilation, in a pure algebraic style, but the complexity of our source language demanded significant adaptations and extensions\u00a0\u2026", "num_citations": "6\n", "authors": ["1598"]}
{"title": "Formal Methods: Foundations and Applications\n", "abstract": " This volume contains the papers presented at SBMF 2009: the Brazilian Symposium on Formal Methods, held during August 19\u201321, 2009 in Gramado, Rio Grande do Sul, Brazil. The SBMF programme included three invited talks given by Leonardo de Moura (Microsoft Research), Sebastian Uchitel (University of Buenos Aires and Imperial College London), and Daniel Kr\u00f6ning (University of Oxford).", "num_citations": "6\n", "authors": ["1598"]}
{"title": "Proving theorems about JML classes\n", "abstract": " We present an initial link between Z and JML that has enabled us to use Z/Eves to prove theorems about JML classes. We have applied this to the JML type system and the Java HashMap class from the Java Collections Framework. We present and discuss the issues behind a more general strategy for translation in both directions between Z and JML. This work is a contribution to the Verified Software Repository, part of the Grand Challenge in Verified Software.", "num_citations": "6\n", "authors": ["1598"]}
{"title": "A Circus Semantics for Ravenscar Protected Objects\n", "abstract": " The Ravenscar profile is a subset of the Ada 95 tasking model: it is certifiable, deterministic, supports schedulability analysis, and meets tight memory constraints and performance requirements. A central feature of Ravenscar is the use of protected objects to ensure mutually exclusive access to shared data. We give a semantics to protected objects using Circus, a combination of Z and CSP, and prove several important properties; this is the first time that these properties have been verified. Interestingly, all the proofs are conducted in Z, even the ones concerning reactive behaviour.", "num_citations": "6\n", "authors": ["1598"]}
{"title": "Abstract data types and processes\n", "abstract": " (2000) Abstract Data Types and Processes. In: Roscoe, AW and Davies, Jim and Woodcock, Jim, eds. Proceedings of the Symposium in Honour of CAR Hoare.. pp. 391-405.(The full text of this publication is not currently available from this repository. You may be able to access a copy if URLs are provided)(KAR id: 21895)", "num_citations": "6\n", "authors": ["1598"]}
{"title": "3rd Refinement Workshop: Proceedings of the 3rd Refinement Workshop (organised by BCS-FACS, and Sponsored by IBM UK Laboratories, Hursley Park, and the Programming Research\u00a0\u2026\n", "abstract": " Refinement is the process of turning specifications into implementations. Of particular interest these days are refinement methods in which many small steps take a specification ever closer to a correct implementation of it. It is obvious that all users of computers should be interested in refinement, for the problem of correctness is universal. And indeed many users are\u2014they are the ones who wish to gain control over the process of making computer systems that work. They may be clients, vendors, programmers, or even academics.But alas this volume does not present a single refinement method that is guaranteed to work for all problems. Indeed, that will never be possible. Instead the reader will find here a collection of methods that individually apply to certain broad situations. Also to be found is work on the basis for refinement itself.", "num_citations": "6\n", "authors": ["1598"]}
{"title": "Learning safe neural network controllers with barrier certificates\n", "abstract": " We provide a novel approach to synthesize controllers for nonlinear continuous dynamical systems with control against safety properties. The controllers are based on neural networks (NNs). To certify the safety property we utilize barrier functions, which are also represented by NNs. We train controller-NN and barrier-NN simultaneously, achieving verification-in-the-loop synthesis. We provide a prototype tool nncontroller with a number of case studies. Preliminary experiment results confirm the feasibility and efficacy of our approach.", "num_citations": "5\n", "authors": ["1598"]}
{"title": "Java in the safety-critical domain\n", "abstract": " Abstract Safety-Critical Java (SCJ) is an Open Group standard that defines a novel version of Java suitable for programming systems with various levels of criticality. SCJ enables real-time programming and certification of safety-critical applications. This tutorial presents SCJ and an associated verification technique to prove correctness of programs based on refinement. For modelling, we use the family of notations, which combine Z, CSP, Timed CSP, and object orientation. The technique caters for the specification of functional and timing requirements, and establishes the correctness of designs based on architectures that use the structure of missions and event handlers of SCJ. It also considers the integrated refinement of value-based specifications into class-based designs using SCJ scoped memory areas. As an example, we use an SCJ implementation of a widely used leadership-election protocol.", "num_citations": "5\n", "authors": ["1598"]}
{"title": "Mechanised wire-wise verification of Handel-C synthesis\n", "abstract": " The compilation of Handel-C programs into net-list descriptions of hardware components has been extensively used in commercial tools but never formally verified. In this paper, we first introduce an extension of the compilation schema that allows the synthesis of the prioritised choice construct. Then we present a variation of the existing semantic model for Handel-C compilation that is amenable to mechanical proof and detailed enough for analysing properties of the hardware generated. We use this model to prove the correctness of the wiring schema used to interconnect the components at the hardware level and propagate control signals among them. Finally, we present the most interesting aspects of the mechanisation of the model and the correctness proofs in the HOL theorem prover.", "num_citations": "5\n", "authors": ["1598"]}
{"title": "Automation of model-based testing through model transformations\n", "abstract": " Traditionally, model transformations are done for purposes such as code generation, refinement, refactoring, etc.During these processes, either the model of a system or the actual code is used. In this study, we perform model transformation for testing purposes and the artifact used in this process is the test case model. To explain our approach better,we present a multi-platform model-based testing technique where the operations to be tested are modelled in alloy,and the complete system to be tested is specified in Z formal language. The model transformation is used within this context to transform test cases in XML format generated by alloy analyzer to ZLive commands that animate the Z specification of the system. The study not only presents a show case on how to model the test cases in a standard form, but also defines the rules for transformations from one test case model to another. The study also demonstrate\u00a0\u2026", "num_citations": "5\n", "authors": ["1598"]}
{"title": "Derivation of Z Refinement Proof Rules: Forwards and backwards rules incorporating input/output refinement\n", "abstract": " Contents 1 Introduction 1 1.1 Structure of the derivations 2 2 The relational view of refinement 3 2.1 What is refinement? 3 2.2 The definition of relational refinement 4 2.3 The rules of relational refinement 4 3 Untotalising (relaxing) 6 3.1 Choice of totalisation 6 3.2 Untotalising forward simulations 7 3.3 Untotalising backward retrieval 7 4 Incorporating the computational model (unwinding) 9 4.1 State space structure 9 4.2 Assumptions 11 4.3 Computational model in forward simulation 12 4.3. 1 Computational model in forward initialisation 12 4.3. 2 Computational model in forward finalisation 13 4.3. 3 Computational model in forward applicability 14 4.3. 4 Computational model in forward correctness 17 4.3. 5 Summary of forward rules after incorporating computational model 19 4.4 Computational model in backward simulation 19 4.4. 1 Computational model in backward initialisation 19 4.4. 2 Computational model in backward finalisation 20 4.4. 3 Computational model in backward applicabilit", "num_citations": "5\n", "authors": ["1598"]}
{"title": "A Circus steam boiler: using the unifying theory of Z and CSP\n", "abstract": " This report has been prepared for the Defence Evaluation and Research Agency, Malvern, UK, under grant number CU009-0000004344.", "num_citations": "5\n", "authors": ["1598"]}
{"title": "Industrial-strength refinement\n", "abstract": " Research in software engineering is characterised by the interplay between theory and practice: the best research finds its direct application in industry, whilst the best industrial practice provides in-teresting problems for the researcher. In this paper, we describe an industrial application as a case study in the introduction of new techniques in industry. It concerns using advanced software engineering methods to make money: literally. The project involved developing a smart-card for electronic commerce; this is a major new product and a state-of-the-art application. Formal methods were used very successfully to model behaviour to guarantee security, with the product being the first to gain certification to ITSEC Level 6. The mathematical work was completed under budget and well within the time allowed.", "num_citations": "5\n", "authors": ["1598"]}
{"title": "FME'93: Industrial-Strength Formal Methods: First International Symposium of Formal Methods Europe, Odense, Denmark, April 19-23, 1993. Proceedings\n", "abstract": " The last few years have borne witness to a remarkable diversity of formal methods, with applications to sequential and concurrent software, to real-time and reactive systems, and to hardware design. In that time, many theoretical problems have been tackled and solved, and many continue to be worked upon. Yet it is by the suitability of their industrial application and the extent of their usage that formal methods will ultimately be judged. This volume presents the proceedings of the first international symposium of Formal Methods Europe, FME'93. The symposium focuses on the application of industrial-strength formal methods. Authors address the difficulties of scaling their techniques up to industrial-sized problems, and their suitability in the workplace, and discuss techniques that are formal (that is, they have a mathematical basis) and that are industrially applicable. The volume has four parts:-Invited lectures, containing a lecture by Cliff B. Jones and a lecture by Antonio Cau and Willem-Paul de Roever;-Industrial usage reports, containing 6 reports;-Papers, containing 32 selected and refereedpapers;-Tool descriptions, containing 11 descriptions.", "num_citations": "5\n", "authors": ["1598"]}
{"title": "SPECIFICATIONS\n", "abstract": " Construction of this pipe organ, Opus 6763, was begun in Chicago by the WW Kimball Company in February, 1924. It took 8 months to build and was delivered and installed in October of that same year. Belgian-American organ virtuoso Dr. Charles Courboin served as tonal design consultant with voicing supervised by head voicer George Michel. There are 3 floors of organ pipes in this Auditorium situated in 3 spatially separated chambers. These pipes, 3,863 in number, are spread across 53 ranks in 9 divisions. Every pipe in this organ was made flexible and expressive by enclosing the entire instrument behind 128 swell shades each on its own pneumatic motor which may be operated by division or all at once. The console placement is in an elevated 3rd floor (above the Dining Room level) balcony in the northwest corner of the Auditorium, Stage Right (Audience Left) and is fixed in position. The Main chamber is home to the 41 ranks of the Great/Choir, Solo, Swell, and Pedal divisions and is located high above and to the left of the console behind large tone grilles built into the west wall at 4th and 5th floor levels. The Antiphonal chamber houses another 5 ranks, is about 170 feet from the Main pipe chamber, and is situated behind identically shaped tone grilles built into the east wall high above the 3rd floor orchestra balcony, Stage Left (Audience Right). The Echo chamber is", "num_citations": "5\n", "authors": ["1598"]}
{"title": "Analysing RoboChart with probabilities\n", "abstract": " Robotic systems have applications in many real-life scenarios, ranging from household cleaning to critical operations. RoboChart is a graphical language for describing robotic controllers designed specifically for autonomous and mobile robots, providing architectural constructs to identify the requirements for a robotic platform. It also provides a formal semantics in CSP. RoboChart has a probabilistic operator () but no associated probabilistic CSP semantics. When is used, currently a non-deterministic choice () is used as semantics; this is a conservative semantics but it does not allow the analysis of stochastic properties. In this paper we define the semantics of the operator in terms of the probabilistic CSP operator\\boxplus\u229e. We also show how this augmented CSP semantics for RoboChart can be translated into the PRISM probabilistic language to be able to check stochastic properties.", "num_citations": "4\n", "authors": ["1598"]}
{"title": "UTP by example: Designs\n", "abstract": " We present a tutorial introduction to the semantics of a basic nondeterministic imperative programming language in Unifying Theories of Programming (UTP). First, we give a simple relational semantics that accounts for a theory of partial correctness. Second, we give a semantics based on the theory of precondition-postcondition pairs, known in UTP as designs. This paper should be read in conjunction with the UTP book by Hoare & He. Our contribution lies in the large number of examples we introduce.", "num_citations": "4\n", "authors": ["1598"]}
{"title": "Contracts in CML\n", "abstract": " We describe the COMPASS Modelling Language (CML), which is used to model large-scale Systems of Systems and the contracts that bind them together. The language can be used to document the interfaces to constituent systems using formal, precise, and verifiable specifications including preconditions, postconditions, and invariants. The semantics of CML directly supports the use of these contracts for all language constructs, including the use of communication channels, parallel processes, and processes that run forever. Every process construct in CML has an associated contract, allowing clients and suppliers to check that the implementations of constituent systems conform to their interface specifications.", "num_citations": "4\n", "authors": ["1598"]}
{"title": "Test-data generation for control coverage by proof\n", "abstract": " Many tools can check if a test set provides control coverage; they are, however, of little or no help when coverage is not achieved and the test set needs to be completed. In this paper, we describe how a formal characterisation of a coverage criterion can be used to generate test data; we present a procedure based on traditional programming techniques like normalisation, and weakest precondition calculation. It is a basis for automation using an algebraic theorem prover. In the worst situation, if automation fails to produce a specific test, we are left with a specification of the compliant test sets. Many approaches to model-based testing rely on formal models of a system under test. Our work, on the other hand, is not concerned with the use of abstract models for testing, but with coverage based on the text of programs.", "num_citations": "4\n", "authors": ["1598"]}
{"title": "Towards the formal specification of a simple programming support environment\n", "abstract": " In order to make precise some of the desirable features of a programming support environment, and in order to encourage others to do likewise, this paper presents the formal specification of a small module or package manager suitable foruse in a Modula or Ada environment.", "num_citations": "4\n", "authors": ["1598"]}
{"title": "Sound simulation and co-simulation for robotics\n", "abstract": " Software engineering for modern robot applications needs attention; current practice suffers from costly iterations of trial and error, with hardware and environment in the loop. We propose the adoption of an approach to simulation and co-simulation of robotics applications where designs and (co-)simulations are amenable to verification. In this approach, designs are composed of several (co-)models whose relationship is defined using a SysML profile. Simulation is the favoured technique for analysis in industry, and co-simulation enables the orchestrated use of a variety of simulation tools, including, for instance, reactive simulators and simulators of control laws. Here, we define the SysML profile that we propose and give it a process algebraic semantics. With that semantics, we capture the properties of the SysML model that must be satisfied by a co-simulation. Our long-term goal is to support validation and\u00a0\u2026", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Mechanised Theory Engineering in Isabelle.\n", "abstract": " This is an introduction to mechanised theory engineering in Isabelle, an LCF-style interactive theorem prover. We introduce an embedding of Hoare & He\u2019s Unifying Theories of Programming (UTP) in Isabelle (named Isabelle/UTP) and show how to mechanise two key theories: relations and designs. These theories are sufficient to give an account of the partial and total correctness of nondeterministic sequential programs and of networks of reactive processes. A tutorial introduction to each theory is interspersed with its formalisation and with mechanised proofs of relevant properties and theorems. The work described here underpins specification languages such as Circus, which combines state-rich imperative operations, communication and concurrency, object orientation, references and pointers, real time, and process mobility, all with denotational, axiomatic, algebraic, and operational semantics.", "num_citations": "3\n", "authors": ["1598"]}
{"title": "An approach to software preservation\n", "abstract": " Long-term preservation of software components is a key aspect of preservation of data, as software required for processing and analyzing data also needs to be preserved in order to maintain the re-usability of data in future. However, software preservation to date is a relatively underexplored topic of research and frequently seen as a secondary activity, mainly due to the inherent complexity of software artifacts, which is generally deemed a major barrier to their preservation. In this paper, we present a conceptual framework to capture and organise the main notions of software preservation, which are required for a coherent and comprehensive approach. In particular, the framework introduces a notion of adequacy of preservation, an aspect of the OAIS concept of authenticity which tests the future performance of software against specified preservation properties. We also evaluate the application of the software preservation framework in the context of a use case involving the British Atmospheric Data Centre (BADC).", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Wire-wise correctness for handel-C synthesis in HOL\n", "abstract": " The compilation of Handel-C programs into net-list descriptions of hardware components has been extensively used in commercial tools but never formally verified. In this paper we first introduce a variation of the existing semantic model for Handel-C compilation that is amenable for mechanical proofs and detailed enough to analyse properties about the generated hardware. We then use this model to prove the correctness of the wiring schema used to interconnect the different components at the hardware level and propagate control signals among them. Finally, we present the most interesting aspects of the mechanisation of the model and the correctness proofs in the HOL theorem prover.", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Model checking circus: architecture overview\n", "abstract": " On the 10 th of March 2006, a set of deliverables envisaged for the following six, twelve, and eighteen months were agreed. We summarise those below. In the next Chapter, we explain the architecture of the current tool from each of its modules with some level of detail. Finally, in the last two Chapters we present a summary of tools with some conclusions, together with the future deliverables until the end of the project.", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Refinement: an overview\n", "abstract": " The purpose of this initial chapter is to introduce concepts and techniques assumed as general background in the remaining chapters of this book. The relevant notions are introduced using a simple and well-known programming notation:\u00a0Dijkstra\u2019s language of guarded commands [18], presented in Section [1].", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Controller synthesis for object Petri nets\n", "abstract": " A large class of real-world systems can be modelled as Petri nets, and complex systems are more conveniently modelled as object Petri nets. Ensuring that Petri net models avoid forbidden states has attracted much research effort. The work presented addresses the forbidden state problem for object Petri nets, through a method for controller synthesis. A simple illustrative example is given as well as an illustration in a flexible manufacturing system. The concept of place invariants plays an important role in Petri net theory. For the first time, place invariants are defined for object Petri nets.", "num_citations": "3\n", "authors": ["1598"]}
{"title": "An Electronic Purse\n", "abstract": " This case study is a reduced version of a real devdopment by the NatWes [Development Team (now platform seven) of a Smartcard product for electronic commerce. This development was deeply security critical: it was vital to ensure that these cards would not contain any bugs in implementation or design that would allow them to be subverted once in the field. The system consists of a number of electronic purses that carry financial value, each hosted on a Smartcard. The purses interact with each other via a communications deVice to exchange value. Once released into the field, each purse is on its own: it has to ensure the security of all Hs transactions y.,. ithout recourse to a central conttollcr. All security measures have to be implemented on the card, with no real-time external audit logging or monitoring.", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Security management via Z and CSP\n", "abstract": " Security management via Z and CSP - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Terms of Use Stats Export BibTeX EndNote RefWorks Conference item icon Conference item Security management via Z and CSP Actions Email \u00d7 Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included within the email. Send Cite \u00d7 APA Style Simpson, AC, Davies, JW, & Woodcock, JCP (1998). Security \u2026", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Procedures, parameters, and substitution in the refinement calculus\n", "abstract": " Morgan and Back have proposed di erent formalisations of procedures and parameters in the context of techniques of program development based on re nement. We investigate a surprising and intricate relationship between these works and the substitution operator that renames the free variables of a program, and reveal an inconsistency in Morgan's re nement calculus. Back's formalisation of procedures does not su er from this inconsistency, but his work is not as appealing to practising programmers as Morgan's calculus, whose distinctive feature is a large number of re nement laws. Here we bene t from both works and use Back's formalism as a model to derive the laws presented in Morgan's calculus.", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Mathematics of Program Construction Second International Conference, Oxford, UK, June 29\u2013July 3, 1992 Proceedings\n", "abstract": " Not very long ago, the uninhibited use of mathematics in the development of software was regarded as something for academics alone. Today, there is moreand more interest from industry in formal methods based on mathematics. This interest has come from the success of a number of experiments on real industrial applications. Thus, there is not only a belief, but also evidence, that the study of computer programs as mathematical objects leads to more efficient methods for constructing them. The papers in this volume were presented at the Second International Conference on the Mathematics of Program Construction, held at St. Catherine's College, Oxford, June 29-July 3, 1992. The conference was organized by the Oxford University Programming Research Group, and continued the theme set by the first-the use of crisp, clear mathematics in the discovery and design of algorithms. The second conference gives\u00a0\u2026", "num_citations": "3\n", "authors": ["1598"]}
{"title": "Compositional assume-guarantee reasoning of control law diagrams using utp\n", "abstract": " Simulink is widely accepted in industry for model-based designs. Verification of Simulink diagrams against contracts or implementations has attracted the attention of many researchers. We present a compositional assume-guarantee reasoning framework to provide a purely relational mathematical semantics for discrete-time Simulink diagrams, and then to verify the diagrams against the contracts in the same semantics in UTP. We define semantics for individual blocks and composition operators, and develop a set of calculation laws (based on the equational theory) to facilitate automated proof. An industrial safety-critical model is verified using our approach. Furthermore, all these definitions, laws, and verification of the case study are mechanised in Isabelle/UTP, an implementation of UTP in Isabelle/HOL.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "A stepwise approach to linking theories\n", "abstract": " Formal modelling of complex systems requires catering for a variety of aspects. The Unifying Theories of Programming (UTP) distinguishes itself as a semantic framework that promotes unification of results across different modelling paradigms via linking functions. The naive composition of theories, however, may yield unexpected or undesirable semantic models. Here, we propose a stepwise approach to linking theories where we deal separately with the definition of the relation between the variables in the different theories and the identification of healthiness conditions. We explore this approach by deriving healthiness conditions for via calculation, based on the healthiness conditions of CSP and a small set of principles underlying the timed model.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "CSP and Kripke structures\n", "abstract": " A runtime verification technique has been developed for CSP via translation of CSP models to Kripke structures. With this technique, we can check that a system under test satisfies properties of traces and refusals of its CSP model. This complements analysis facilities available for CSP and for all languages with a CSP-based semantics:\u00a0Safety-Critical Java, Simulink, SysML, and so on. Soundness of the verification depends on the soundness of the translation and on the traceability of the Kripke structure analysis back to the CSP models and to the property specifications. Here, we present a formalisation of soundness by unifying the semantics of the languages involved:\u00a0normalised graphs used in CSP model checking, action systems, and Kripke structures. Our contributions are the unified semantic framework and the formal argument\u00a0itself.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "A theory of refinement for ADTs with functional interfaces\n", "abstract": " We propose a theory of refinement for Abstract Data Types (ADTs) that interact with client programs via function calls. Our notion of refinement is in the spirit of Z/VDM. We provide a simulation-based refinement condition similar to that of He et al.\u2019s \u201cupward simulation\u201d, and argue that it is both sound and complete for deterministic ADTs. Our theory also facilitates compositional reasoning about complex implementations that may use several layers of sub-ADTs.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Three approaches to timed external choice in UTP\n", "abstract": " We explore different approaches to modelling external choice as a reactive process in a UTP semantics with discrete time. The standard definition of external choice cannot be simply reused in a timed semantics, since it can introduces behaviours which are not prefix-closed and urgent events which occur instantly. We first examine unstable states and urgent events in different semantics for CSP. We present the semantics for a simple timed reactive UTP language and describe the difficulties of adding external choice. We define two new process operators; strict choice, which never engages in urgent events and lazy choice, which can delay urgent events. We briefly discuss two potential modifications to the language model; a lazy semantics, in which termination is not unstable, and a semantics in which unstable states can be observed. Finally, we give a more detailed treatment to strict choice, expressing it\u00a0\u2026", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Operational Semantics for Circus Time\n", "abstract": " The Circus family of languages is a collection of process algebras based on a combination of Z, for data modelling, and CSP, for behavioural modelling. In this paper we develop a symbolic transition system for Circus Time, a timed version of Circus, whose soundness is proved with respect to a denotational semantics. Our contribution is credited not only to a combination of separate operational semantics for process algebra and for sequential programming in the UTP, but also to a full consideration of feasibility checking for Circus Time programs. We believe that this brand-new operational semantics can be easily applied to other state-rich process algebra.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "A verified protocol to implement multi-way synchronisation and interleaving in CSP\n", "abstract": " The complexity of concurrent systems can turn their development into a very complex and error-prone task. The use of formal methods like CSP considerably simplifies this task. Development, however, usually aims at reaching an executable program:\u00a0a translation into a programming language is still needed and can be challenging. In previous work, we presented a tool, csp2hc, that translates a subset of CSP into Handel-C source code, which can itself be converted to produce files to program FPGAs. This subset restricts parallel composition:\u00a0multi-synchronisation and interleaving on shared channels are not allowed. In this paper, we present an extension to csp2hc that removes these restrictions. We provide a performance analysis of our code.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Use of model transformation for the formal analysis of railway interlocking models\n", "abstract": " Model transformation is at the heart of Model-Driven Engineering (MDE). In MDE, the system model is specified using a modelling language, such as UML (Unified Modelling Language) or a DSL (Domain-Specific Language). Once a model is specified, executable code for a computing platform can be automatically generated by means of model transformation (code generation). Besides the support for incremental model development, MDE also enables the formal verification of system properties. In the context of safety-critical systems, such as railway interlockings, the system model (eg, specified in terms of UML) can be translated to a formal (mathematical) language more amendable to rigorous analysis. This paper presents a model transformation that takes a railway interlocking model (specified in Executable UML (xUML)) as input and outputs a formal model that can be mathematically analysed. This can potentially bridge the gap between well-known modelling languages (such as xUML) and formal languages, which facilitates the systematic development of safety-critical systems in terms of MDE. A small xUML railway interlocking model is used to illustrate the proposed method. Keywords: railway interlocking systems, model driven engineering (MDE), executable UML (xUML), formal languages, formal analysis. 1 Introduction Railway interlocking plays a very important role in establishing high safety for train operations in a railway system, and protecting passengers and equipment from damage. Due to its life-critical application, a rigorous verification phase is", "num_citations": "2\n", "authors": ["1598"]}
{"title": "The Verified Software Repository\u2015\n", "abstract": " \u2022 Joshi & Holzmann\u2013a pilot project should be of sufficient 1. complexity that traditional methods are inadequate to establish correctness 2. simplicity that specification, design and verification could be completed by a dedicated team within 2\u20133 years 3. importance that successful completion would have an impact beyond the verification community", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Simpler reasoning about system properties: a proof-by-refinement technique\n", "abstract": " Proofs about system specifications are difficult to conduct, particularly for large specifications. Using abstraction and refinement, we propose a proof technique that simplifies these proofs. We apply the technique to Circus (a combination of Z and CSP) specifications of different complexities. Interestingly, all the proofs are conducted in Z, even those concerning reactive behaviour.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Denotational semantics of Handel-C cores\n", "abstract": " We present a denotational semantics for a fully functional subset of the Handel-C hardware compilation language [9], based on the concept of typed assertion traces. We motivate the choice of semantic domains by illustrating the complexities of the behaviour of the language, paying particular attention to the prialt (priority-alternation) construct of Handel-C. We then define the typed assertion traces over an abstract notion of events, which we then instantiate as statetransformers. The denotational semantics is then given and some examples are discussed.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Ravenscar protected objects: a Circus semantics\n", "abstract": " The Ravenscar profile is a restricted subset of the Ada 95 tasking model\u2014designed to provide a certifiable deterministic tasking model that supports schedulability analysis and meets tight memory constraints and performance requirements. Centre to Ravenscar is the use of Ada protected objects as the means for ensuring mutually exclusive access to data shared between different tasks. In this report, Circus (a specification language that combines Z and CSP) is used to model Ada protected objects that comply with restrictions of the Ravenscar profile. Also, formal proofs showing that the Circus model exhibits the desired properties will be provided; this is the first time a model about the functional aspects of Ada protected objects has been introduced and formally verified. Finally, although some of the properties proved in this report are mainly about behaviour (eg freedom of deadlock), all the proofs in this report are conducted in Z. This is a new and interesting result as now Z tools, usually used for proofs about sequential programs, can be used to provide formal proofs of CSP properties, hence concurrent programs.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "The semantics of circus\n", "abstract": " Circus is a concurrent language for refinement; it is a unification of imperative CSP, Z, and the refinement calculus. We describe the language of Circus and the formalisation of its model in Hoare & He's unifying theories of programming.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "A predicate transformer semantics for a concurrent language of refinement\n", "abstract": " Circus is a combination of Z and CSP; its chief distinguishing feature is the inclusion of the ideas of the refinement calculus. Our main objective is the definition of refinement methods for concurrent programs. The original semantic model for Circus is Hoare and He\u2019s unifying theories of programming. In this paper, we present an equivalent semantics based on predicate transformers. With this new model, we provide a more adequate basis for the formalisation of refinement and verificationcondition generation rules. Furthermore, this new framework makes it possible to include logical variables and angelic nondeterminism in Circus. The consistency of the relational and predicate transformer models gives us confidence in their accuracy.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Interactive Distributed Multimedia Systems and Services: European Workshop, IDMS'96, Berlin, Germany, March 4-6, 1996 Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the first European Workshop on Interactive Distributed Multimedia Systems and Services, IDMS'96, held in Berlin, Germany in March 1996. The 21 revised papers included were carefully selected for presentation at the workshop; they examine current and new approaches to interactive distributed multimedia systems and services from different points of view, including research and development, management, and users. Among the topics addressed are application development support, multimedia services on demand, multimedia conferencing, multimedia networking, continuous-media streams, multimedia experiments.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "A tactic calculus\u2014full version\n", "abstract": " We present a very general language for expressing tactic programs. The paper describes some essential tactic combinators (tacticals), and gives them a formal semantics. Those de nitions are used to produce a complete calculus for reasoning about tactics written in this language. The language is extended to cover structural combinators which enable the tactics to be precisely targeted upon particular sub-expressions.", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Two Refinement Case Studies\n", "abstract": " Two Refinement Case Studies | Proceedings of the 4th International Symposium of VDM Europe on Formal Software Development-Volume 2: Tutorials ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsVDM '91Two Refinement Case Studies Article Two Refinement Case Studies Share on Author: Jim Woodcock View Profile Authors Info & Affiliations Publication: VDM '91: Proceedings of the 4th International Symposium of VDM Europe on Formal Software Development-Volume 2: TutorialsOctober 1991 Pages 118\u2013140 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get \u2026", "num_citations": "2\n", "authors": ["1598"]}
{"title": "Verification and uncertainties in self-integrating system\n", "abstract": " Self-integrating and self-improving system are required to verify their state in order to understand whether they have achieved their goal or need to adapt themselves to reach it. In this short position paper, we outline the main challenges specifically when verifying systems interacting with each other and operating under uncertainties. A short outline of the uncertainties is given as well as a brief roadmap to overcome the main challenges faced by autonomous interwoven systems, operating in an open world with incomplete knowledge.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Automated verification of reactive and concurrent programs by calculation\n", "abstract": " Reactive programs combine traditional sequential programming constructs with primitives to allow communication with other concurrent agents. They are ubiquitous in modern applications, ranging from components systems and web services, to cyber-physical systems and autonomous robots. In this paper, we present an algebraic verification strategy for concurrent reactive programs, with a large or infinite state space. We define novel operators to characterise interactions and state updates, and an associated equational theory. With this we can calculate a reactive program's denotational semantics, and thereby facilitate automated proof. Of note is our reasoning support for iterative programs with reactive invariants, based on Kleene algebra, and for parallel composition. We illustrate our strategy by verifying a reactive buffer. Our laws and strategy are mechanised in Isabelle/UTP, our implementation of Hoare and\u00a0\u2026", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Development automation of real-time java: Model-driven transformation and synthesis\n", "abstract": " Many applications in emerging scenarios, such as autonomous vehicles, intelligent robots, and industrial automation, are safety-critical with strict timing requirements. However, the development of real-time systems is error prone and highly dependent on sophisticated domain expertise, making it a costly process. This article utilises the principles of model-driven engineering (MDE) and proposes two methodologies to automate the development of real-time Java applications. The first one automatically converts standard time-sharing Java applications to real-time Java applications, using a series of transformations. It is in line with the observed industrial trend, such as for the big data technology, of redeveloping existing software without the real-time notion to realise the real-time features. The second one allows users to automatically generate real-time Java application templates with a lightweight modelling\u00a0\u2026", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Cyber-physical systems engineering: an introduction\n", "abstract": " Cyber-Physical Systems (CPSs) [1] connect the real world to software systems through a network of sensors and actuators in which physical and logical components interact in complex ways. There is a diverse range of application domains [2], including health [3], energy [4], transport [5], autonomous vehicles [6] and robotics [7]; and many of these include safety critical requirements [8]. Such systems are, by definition, characterised by both discrete and continuous components. The development and verification processes must, therefore, incorporate and integrate discrete and continuous models.                 The development of techniques and tools to handle the correct design of CPSs has drawn the attention of many researchers. Continuous modelling approaches are usually based on a formal mathematical expression of the problem using dense reals and differential equations to model the behaviour of the\u00a0\u2026", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Reactive Designs in Isabelle/UTP\n", "abstract": " Stateful-Failure Reactive Designs specialise reactive design contracts with failures traces, as present in languages like CSP and Circus. A failure trace consists of a sequence of events and a refusal set. It intuitively represents a quiescent observation, where certain events have previously occurred, and others are currently being accepted. Following the UTP book, we add an observational variable to represent refusal sets, and healthiness conditions that ensure their well-formedness. Using these, we also specialise our theory of reactive relations with operators to characterise both completed and quiescent interactions, and an accompanying equational theory. We use these to define the core operators \u2014 including assignment, event occurrence, and external choice \u2014 and specialise our proof strategy to support these. We also demonstrate a link with the CSP failures-divergences semantic model.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "UTP semantics of reactive processes with continuations\n", "abstract": " Based on the Unifying Theories of Programming (UTP) semantic framework, Hoare and He have defined (a means for constructing) a high-level language with labels and jumps, using the concept of continuations. The language permits placing labels at given points within a program and making jumps to these labels when desired. In their work, Hoare and He have limited themselves to the definition of continuations for sequential programs. This paper is concerned with the extension of that work to reactive programs. We first extend their results to include parallelism and Higher Order programs. This is achieved by designing a new control variable  whose value follows the parallel structure of programs. We then proceed to define reactive (CSP) processes that contain the new control variable , resulting in the theory of Reactive (Process) Blocks. The encapsulation operator defined by Hoare and He and which\u00a0\u2026", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Mobile CSP\n", "abstract": " We describe an extension of imperative CSP with primitives to declare new event names and to exchange them by message passing between processes. We give examples in Mobile CSP to motivate the language design, and describe its semantic domain, based on the standard failures-divergences model for CSP, but also recording a dynamic event alphabet. The traces component is identical to the separation logic semantics of Hoare & O\u2019Hearn. Our novel contribution is a semantics for mobile channels in CSP, described in Unifying Theories of Programming, that supports: compositionality with other language paradigms; channel faults, nondeterminism, deadlock, and livelock; multi-way synchronisation; and many-to-many channels. We compare and contrast our semantics with other approaches, including the -calculus, and consider implementation issues. As well as modelling reconfigurable\u00a0\u2026", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Unified Runtime Verification for CSP-Extended version\n", "abstract": " A runtime verification technique has been developed for CSP via translation of CSP models to Kripke structures. With this technique, we can check that a system under test satisfies properties of traces and refusals of its CSP model. This complements analysis facilities available for CSP and for all languages with a CSP-based semantics: Safety-Critical Java, Simulink, SysML, and so on. Soundness of the verification depends on the soundness of the translation and on the traceability of the Kripke structure analysis back to the CSP models and to the property specifications. A rigorous soundness argument is available. Here, we present a formalisation of that argument by unifying the semantics of the languages involved: normalised graphs used in CSP model checking, action systems, and Kripke structures. Our contributions are the unified semantic framework and the formal argument itself.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "A refinement based strategy for local deadlock analysis of networks of csp processes\u2014extended version\n", "abstract": " Based on a characterisation of process networks in the CSP process algebra, we formalise a set of behavioural restrictions used for local deadlock analysis. Also, we formalise two patterns, originally proposed by Roscoe, which avoid deadlocks in cyclic networks by performing only local analyses on components of the network; our formalisation systematises the behavioural and structural constraints imposed by the patterns. A distinguishing feature of our approach is the use of refinement expressions for capturing notions of pattern conformance, which can be mechanically checked by CSP tools like FDR. Moreover, three examples are introduced to demonstrate the effectiveness of our strategy, including a performance comparison between FDR default deadlock assertion and the verification of local behavioural constraints induced by our approach, also using FDR.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Considering software preservation\n", "abstract": " Software is a class of electronic object which is by its very nature digital, and the preservation of software is often a vital prerequisite to the preservation of other electronic objects. However, software has many characteristics that make preserving it substantially more challenging than for many other types of digital object. Software is inherently complex, normally composed of a very large number of highly interdependent components and often forbiddingly opaque for people other than those who were directly involved in its development. Software is also highly sensitive to its operating environment, with the typical software artefact depending on a large number of other items including compilers, runtime environments, operating systems, documentation and even the hardware platform with its built-in software stack. Preserving a piece of software thus involves preserving much of its context as well.Handling these challenges is a major barrier to the preservation of software, so much so that the preservation of software is often seen as a secondary activity, less critical than the preservation of the data it manipulates. This is despite the fact that in many cases, such data becomes unusable without the software to handle it; and recreating software from partial information can be a near-impossible task.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Observations for Assertion-based Scenarios in the context of Model Validation\n", "abstract": " Certain approaches to Model-Based Testing focus on test case generation from assertions and invariants, eg, written in the Object Constraint Language. In such a setting, assertions and invariants must be validated. Validation can be carried out via executing scenarios wherein system operations are applied to detect unsatisfied invariants or failed assertions. This paper aims to improve our understanding of how to write useful validation scenarios for assertions in OCL. To do so, we report on our experiences during the creation and execution of 237 scenarios for validating assertions for the Mondex Smart Card application. We also describe key factors that must be considered in transforming scenarios into test cases.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "A Verified Implementation of a Control System\n", "abstract": " In this paper, a case study consisting of a plant, and associated control laws, is presented. An abstract specification of a control system governing operation of the plant is given in Hoare\u2019s Communicating Sequential Processes (CSP). The control system is known to respect the safety properties required of the plant. Via a series of calculated, verified refinements, an implementation is developed on a Field Programmable Gate Array using Handel-C. Verification is performed using the model-checker for CSP, FDR. The result is a verified system on a chip.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "A refinement based approach to calculating a fault-tolerant railway signal device\n", "abstract": " In this extended abstract, we present a technique whereby a new, fail-safe and fault-tolerant architecture for an existing device is calculated, and verified, from an existing abstract specification. The inspiration for the architecture draws from the Byzantine Generals problem. The model is presented in Hoare\u2019s CSP, safety properties are proved using the model checker FDR, and development is guided by the laws of Circus. The case study is Montigel\u2019s Dwarf Signal.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Formal Methods and Software Engineering: 5th International Conference on Formal Engineering Methods, ICFEM 2003, Singapore, November 5-7, 2003, Proceedings\n", "abstract": " This volume contains the proceedings of the 2003 International Conference on Formal Engineering Methods (ICFEM 2003). The conference was the? fth in a series that began in 1997. ICFEM 2003 was held in Singapore during 5\u20137 November 2003. ICFEM 2003 aimed to bring together researchers and practitioners from-dustry, academia, and government to advance the state of the art in formal engineering methods and to encourage a wider uptake of formal methods in industry. The Program Committee received 91 submissions from more than 20 co-tries in various regions. After each paper was reviewed by at least three referees in each relevant? eld, 34 high-quality papers were accepted based on originality, technical content, presentation and relevance to formal methods and software engineering. We wish to sincerely thank all authors who submitted their work for consideration. We would also like to thank the Program Committee members and other reviewers for their great e? orts in the reviewing and selecting process. Weareindebtedtothethreekeynotespeakers, Prof. IanHayesoftheUniv-sity of Queensland, Prof. Mathai Joseph of the Tata Research, Development and DesignCentre, andDr. ColinO\u2019HalloranofQinetiQ, foracceptingourinvitation to address the conference.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "ML for the Working Programme\n", "abstract": " In his ackowledgements Takefuji admits to being inspired by the work of Hopfield and Tank on using neural network architectures to solve problems in optimisation. The book sets out many extensions to the approach where mathematical models of constraint satisfaction problems are implemented and tested in neural nets. The variety of topics that are addressed and the variety of methods used to convey the ideas are distinctive characteristics. The first ten chapters deal with many hard optimisation problems such as N-queen problems and k-colorability problems. The remaining chapters deal with hardware implementations and mathematical derivations. Some Turbo PASCAL code is provided and each chapter has its own list of references. Most of the chapters have student exercises attached. The exercises are clearly an attempt to make this a text book, but I feel that students generally benefit most when model\u00a0\u2026", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Formalisms\n", "abstract": " At a previous workshop in this series at Orlando, there was a session on Theory; at this workshop there was a session on Formalisms. The difference is not just one of terminology: in the intervening three years many things have changed. Perhaps the key difference is that we now have much more experience in applying the results of the theoretical research in this area. We are now seeing formalisms being used on large projects, not just as part of a research activity, but also as part of the production of real products such as a silicon implementation of the IEEE floating point number system (INMOS), or the development of a large transaction processing system (IBM). Various formalisms---such as VDM, Z, CSP, Larch, and LOTOS---are reaching maturity and are emerging as today's standard tools for specification and design. These notations are formal in the sense that they are firmly based on logic and mathematics.", "num_citations": "1\n", "authors": ["1598"]}
{"title": "Formal methods and software engineering\n", "abstract": " This volume contains the proceedings of the 2003 International Conference on Formal Engineering Methods (ICFEM 2003). The conference was the fifth in a series that began in 1997. ICFEM 2003 was held in Singapore during 5\u20137 November 2003.", "num_citations": "1\n", "authors": ["1598"]}