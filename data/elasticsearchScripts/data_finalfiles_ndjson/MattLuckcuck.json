{"title": "Safety-critical Java level 2: motivations, example applications and issues\n", "abstract": " Safety Critical Java defines three compliance levels: Level 0, Level 1 and Level 2. Applications that can be scheduled using cyclic-executive techniques can be implemented at Level 0. Applications that can use simple analysable fixed-priority scheduling can be implemented at Level 1. However, Level 2 also targets fixed-priority scheduling, so this cannot be used to decide whether to use Level 1 or Level 2. The SCJ specification is clear on what constitutes a Level 2 application in terms of its use of the defined API, but not the occasions on which it should be used. Hence, it is not clear what application requirements dictate a Level 2 solution. This paper broadly classifies the features that exist only at Level 2 into three groups: support for nested mission sequencers, support for managed threads, including the use of the Object. wait, Object. notify, HighResolutionTime. waitForObject and Services. delay methods, and\u00a0\u2026", "num_citations": "9\n", "authors": ["1673"]}
{"title": "Safety\u2010Critical Java: level 2 in practice\n", "abstract": " Safety\u2010Critical Java (SCJ) is a profile of the Real\u2010Time Specification for Java that brings to the safety\u2010critical industry the possibility of using Java. SCJ defines three compliance levels: Level 0, Level 1 and Level 2. The SCJ specification is clear on what constitutes a Level 2 application in terms of its use of the defined API but not the occasions on which it should be used. This paper broadly classifies the features that are only available at Level 2 into three groups: nested mission sequencers, managed threads and global scheduling across multiple processors. We explore the first two groups to elicit programming requirements that they support. We identify several areas where the SCJ specification needs modifications to support these requirements fully; these include the following: support for terminating managed threads, the ability to set a deadline on the transition between missions and augmentation of the\u00a0\u2026", "num_citations": "3\n", "authors": ["1673"]}
{"title": "Safety-Critical Java Level 2: applications, modelling, and verification\n", "abstract": " Safety-Critical Java (SCJ) introduces a new programming paradigm for applications that must be certified. To aid certification, SCJ is organised into three compliance levels, which increase in complexity from Level 0 to Level 2. The SCJ language specification (JSR 302) is an Open Group Standard, but it does not include verification techniques. Previous work has addressed verification for Level 0 and Level 1 programs. This thesis supports the much more complex SCJ Level 2 programs, which allow for the programming of highly concurrent multi-processor applications with Java threads, and wait and notify mechanisms.   The SCJ language specification is clear on what constitutes a Level 2 program but not why it should be used. The utility of Levels 0 and 1 are clear from their features. The scheduling behaviour required by a program is a primary indicator of whether or not Level 0 should be used. However, both Levels 1 and 2 use concurrency and fixed-priority scheduling, so this cannot be used as an indicator to choose between them. This thesis presents the first examination of utility of the unique features of Level 2 and presents use cases that justify the availability of these features.  This thesis presents a technique for modelling SCJ Level 2 programs using the state-rich process algebra Circus. The model abstracts away from resources (for example, memory) and scheduling. An SCJ Level 2 program is represented by a combination of a generic model of the SCJ API (the framework model) and an application-specific model (the application model) of that program. The framework model is reused for each modelled program, whereas the\u00a0\u2026", "num_citations": "3\n", "authors": ["1673"]}
{"title": "A formal model of the safety-critical java level 2 paradigm\n", "abstract": " Safety-Critical Java (SCJ) introduces a new programming paradigm for applications that must be certified. The SCJ specification\u00a0(JSR 302) is an Open Group Standard, but it does not include verification techniques. Previous work has addressed verification for SCJ Level\u00a01 programs. We support the much more complex SCJ Level\u00a02 programs, which allows the programming of highly concurrent multi-processor applications with Java threads, and wait and notify mechanisms. We present a formal model of SCJ Level\u00a02 that captures the state and behaviour of both SCJ programs and the SCJ API. This is the first formal semantics of the SCJ Level\u00a02 paradigm and is an essential ingredient in the development of refinement-based reasoning techniques for SCJ Level\u00a02 programs. We show how our models can be used to prove properties of the SCJ API and applications.", "num_citations": "3\n", "authors": ["1673"]}
{"title": "Formal Verification of a Map Merging Protocol in the Multi-Agent Programming Contest\n", "abstract": " Communication is a critical part of enabling multi-agent systems to cooperate. This means that applying formal methods to protocols governing communication within multi-agent systems provides useful confidence in its reliability. In this paper, we describe the formal verification of a complex communication protocol that coordinates agents merging maps of their environment. The protocol was used by the LFC team in the 2019 edition of the Multi-Agent Programming Contest (MAPC). Our specification of the protocol is written in Communicating Sequential Processes (CSP), which is well-suited approach to specifying agent communication protocols due to its focus on concurrent communicating systems. We validate the specification's behaviour using five scenarios where the correct behaviour is known, and verify that eventually all the maps have merged.", "num_citations": "2\n", "authors": ["1673"]}
{"title": "Using formal methods for autonomous systems: Five recipes for formal verification\n", "abstract": " Formal Methods are mathematically-based techniques for software design and engineering, which enable the unambiguous description of and reasoning about a system\u2019s behaviour. Autonomous systems use software to make decisions without human control, are often embedded in a robotic system, are often safety-critical, and are increasingly being introduced into everyday settings. Autonomous systems need robust development and verification methods, but formal methods practitioners are often asked: Why use Formal Methods for Autonomous Systems? To answer this question, this position paper describes five recipes for formally verifying aspects of an autonomous system, collected from the literature. The recipes are examples of how Formal Methods can be an effective tool for the development and verification of autonomous systems. During design, they enable unambiguous description of requirements; in\u00a0\u2026", "num_citations": "1\n", "authors": ["1673"]}
{"title": "System Verification, Processes and Testing\n", "abstract": " A challenge related to autonomous systems concern their verification process and testing. This discussion is not detached from regulatory, societal, and ethical requirements. Indeed, being able to verify issues of governance and ethics is of high importance; yet, a key concern is which governance body and whose ethics are being adopted. The verification process should not be entirely removed from these concerns, and ensuring that the right properties are being verified will require interaction with domain experts in those areas. The regulatory, societal, and ethical requirements should be included at the beginning of the design process and should be fed through to the verification phase. However, the verification process may identify ethical concerns (especially if they have not been identified during the requirements and design process) and engineering practice should ensure that these concerns are included into the system\u2019s design.A main concern is how to obtain the right requirements against which to verify the system. While the validation of requirements is a concern with the verification of any system, it may be a particular challenge with autonomous systems. Firstly, this is because of the complexity of autonomous systems; secondly, this is because of a lack of consensus on regulation and ethical guidelines for autonomous systems.", "num_citations": "1\n", "authors": ["1673"]}