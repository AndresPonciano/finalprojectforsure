{"title": "Software performance self-adaptation through efficient model predictive control\n", "abstract": " A key challenge in software systems that are exposed to runtime variabilities, such as workload fluctuations and service degradation, is to continuously meet performance requirements. In this paper we present an approach that allows performance self-adaptation using a system model based on queuing networks (QNs), a well-assessed formalism for software performance engineering. Software engineers can select the adaptation knobs of a QN (routing probabilities, service rates, and concurrency level) and we automatically derive a Model Predictive Control (MPC) formulation suitable to continuously configure the selected knobs and track the desired performance requirements. Previous MPC approaches have two main limitations: i) high computational cost of the optimization, due to nonlinearity of the models; ii) focus on long-run performance metrics only, due to the lack of tractable representations of the QN's\u00a0\u2026", "num_citations": "27\n", "authors": ["712"]}
{"title": "Symbolic performance adaptation\n", "abstract": " Quality-of-Service attributes such as performance and reliability heavily depend on the run-time conditions under which software is executed (e.g., workload fluctuation and resources availability). Therefore, it is important to design systems able to adapt their setting and behavior due to these run-time variabilities. In this paper we propose a novel approach based on queuing networks as the quantitative model to represent system configurations. To find a model that fits with continuous changes in run-time conditions we rely on an innovative combination of symbolic analysis and satisfiability modulo theory (SMT). Through symbolic analysis we represent all possible system configurations as a set of non-linear real constraints. By formulating an SMT problem we are able to devise feasible system configurations at a small computational cost. We study the effectiveness and scalability of our approach on a three-tier web\u00a0\u2026", "num_citations": "18\n", "authors": ["712"]}
{"title": "Smile-simple middleware independent layer for distributed mobile applications\n", "abstract": " In this paper we introduce SMILE (simple middleware independent layer), a framework whose main purpose is to facilitate the development of distributed applications. In the SMILE abstraction an application is composed by a set of processes that exchange information. The interfaces of these processes are described using WSDL or by an equivalent UML definition. Using the open source AndroMDA tool and starting from the UML interface specification we are able to generate the skeleton of SMILE applications and most part of their business logic. An application developed using SMILE can run on different middleware platforms just changing its binding, i.e. the code that adapts SMILE to a given middleware. We have implemented bindings to CORBA, JAVA- RMI, JADE, JXTA and to an our own communication mechanism based on SIP suitable for mobile devices. At the end we hint at the usage of SMILE in service\u00a0\u2026", "num_citations": "17\n", "authors": ["712"]}
{"title": "Parallel and distributed bounded model checking of multi-threaded programs\n", "abstract": " We introduce a structure-aware parallel technique for context-bounded analysis of concurrent programs. The key intuition consists in decomposing the set of concurrent traces into symbolic subsets that are separately explored by multiple instances of the same decision procedure running in parallel. The decision procedures work on different partitions of the search space without cooperating, whence distribution follows effortlessly. Our experiments on a selection of complex multi-threaded programs show significant analysis speedups and scalability, and greater performance gains than with general-purpose parallel solvers.", "num_citations": "16\n", "authors": ["712"]}