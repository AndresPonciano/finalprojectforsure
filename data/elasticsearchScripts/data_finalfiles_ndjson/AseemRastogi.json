{"title": "Wysteria: A programming language for generic, mixed-mode multiparty computations\n", "abstract": " In a Secure Multiparty Computation (SMC), mutually distrusting parties use cryptographic techniques to cooperatively compute over their private data, in the process each party learns only explicitly revealed outputs. In this paper, we present Wysteria, a high-level programming language for writing SMCs. As with past languages, like Fairplay, Wysteria compiles secure computations to circuits that are executed by an underlying engine. Unlike past work, Wysteria provides support for mixed-mode programs, which combine local, private computations with synchronous SMCs. Wysteria complements a standard feature set with built-in support for secret shares and with wire bundles, a new abstraction that supports generic n-party computations. We have formalized Wysteria, its refinement type system, and its operational semantics. We show that Wysteria programs have an easy-to-understand single-threaded\u00a0\u2026", "num_citations": "136\n", "authors": ["1771"]}
{"title": "Verified low-level programming embedded in F\n", "abstract": " Embedded Low-Level Programming in F Page 1 Verified low-level programming embedded in F \u2217 Jonathan Protzenko Microsoft Research Nikhil Swamy Microsoft Research Project Everest INRIA Paris MSR Redmond, Cambridge, Bangalore CMU Protzenko / Swamy \u2014 MSR Embedded Low-Level Programming in F\u2217 May. 22nd, 2018 1 / 81 Page 2 Part 1: Motivation Page 3 Some motivation: the TLS protocol TLS stands for transport layer security and now powers more than half of the internet traffic. Handshake Record Layer Crypto PKI TCP Outside world miTLS TLS is a cryptographic protocol: \u2022 \u201cprotocol\u201d: handshake, negotiation, key derivation \u2022 \u201ccryptographic\u201d: well, a lot of math that needs to be fast Protzenko / Swamy \u2014 MSR Embedded Low-Level Programming in F\u2217 May. 22nd, 2018 3 / 81 Page 4 Need for speed latency is correlated with the performance of asymmetric cryptography throughput is correlated with \u2026", "num_citations": "99\n", "authors": ["1771"]}
{"title": "The ins and outs of gradual type inference\n", "abstract": " Gradual typing lets programmers evolve their dynamically typed programs by gradually adding explicit type annotations, which confer benefits like improved performance and fewer run-time failures. However, we argue that such evolution often requires a giant leap, and that type inference can offer a crucial missing step. If omitted type annotations are interpreted as unknown types, rather than the dynamic type, then static types can often be inferred, thereby removing unnecessary assumptions of the dynamic type. The remaining assumptions of the dynamic type may then be removed by either reasoning outside the static type system, or restructuring the code. We present a type inference algorithm that can improve the performance of existing gradually typed programs without introducing any new run-time failures. To account for dynamic typing, types that flow in to an unknown type are treated in a fundamentally\u00a0\u2026", "num_citations": "79\n", "authors": ["1771"]}
{"title": "Dijkstra monads for free\n", "abstract": " Dijkstra monads enable a dependent type theory to be enhanced with support for specifying and verifying effectful code via weakest preconditions. Together with their closely related counterparts, Hoare monads, they provide the basis on which verification tools like F*, Hoare Type Theory (HTT), and Ynot are built. We show that Dijkstra monads can be derived\" for free\" by applying a continuation-passing style (CPS) translation to the standard monadic definitions of the underlying computational effects. Automatically deriving Dijkstra monads in this way provides a correct-by-construction and efficient way of reasoning about user-defined effects in dependent type theories. We demonstrate these ideas in EMF*, a new dependently typed calculus, validating it via both formal proof and a prototype implementation within F*. Besides equipping F* with a more uniform and extensible effect system, EMF* enables a novel\u00a0\u2026", "num_citations": "49\n", "authors": ["1771"]}
{"title": "Knowledge inference for optimizing secure multi-party computation\n", "abstract": " In secure multi-party computation, mutually distrusting parties cooperatively compute functions of their private data; in the process, they only learn certain results as per the protocol (eg, the final output). The realization of these protocols uses cryptographic techniques to avoid leaking information between the parties. A protocol for a secure computation can sometimes be optimized without changing its security guarantee: when the parties can use their private data and the revealed output to infer the values of other data, then this other data need not be concealed from them via cryptography.", "num_citations": "26\n", "authors": ["1771"]}
{"title": "Recalling a Witness\n", "abstract": " We provide a way to ease the verification of programs whose state evolves monotonically. The main idea is that a property witnessed in a prior state can be soundly recalled in the current state, provided (1) state evolves according to a given preorder, and (2) the property is preserved by this preorder. In many scenarios, such monotonic reasoning yields concise modular proofs, saving the need for explicit program invariants. We distill our approach into the monotonic-state monad, a general yet compact interface for Hoare-style reasoning about monotonic state in a dependently typed language. We prove the soundness of the monotonic-state monad and use it as a unified foundation for reasoning about monotonic state in the F* verification system. Based on this foundation, we build libraries for various mutable data structures like monotonic references and apply these libraries at scale to the verification of several distributed applications.", "num_citations": "17\n", "authors": ["1771"]}
{"title": "WYS*: A Verified Language Extension for Secure Multi-party Computations\n", "abstract": " Secure multi-party computation (MPC) enables a set of mutually distrusting parties to cooperatively compute, using a cryptographic protocol, a function over their private data. This paper presents WYS*, a new domain-specific language (DSL) implementation for writing MPCs. WYS* is a Verified, Domain-Specific Integrated Language Extension (VDSILE), a new kind of embedded DSL hosted in F*, a full-featured, verification-oriented programming language. WYS* source programs are essentially F* programs written against an MPC library, meaning that the programmers can use F*\u2019s logic to verify the correctness and security properties of their programs. To reason about the distributed semantics of these programs, we formalize a deep embedding of WYS*, also in F*. We mechanize the necessary metatheory to prove that the properties verified for the WYS* source programs carry over to the distributed, multi-party semantics. Finally, we use F*\u2019s extraction mechanism to extract an interpreter that we have proved matches this semantics, yielding a verified implementation. Indeed, WYS* is the first DSL to enable formal verification of source MPC programs, and also the first MPC DSL to provide a verified implementation. With WYS* we have implemented several MPC protocols, including private set intersection, joint median, and an MPC-based card dealing application, and have verified their security and correctness.", "num_citations": "9\n", "authors": ["1771"]}
{"title": "Verified Low-Level Programming Embedded in F\n", "abstract": " We present Low\u2217, a language for efficient low-level programming and verification, and its application to high-assurance cryptographic libraries. Low\u2217 is a shallow embedding of a small, sequential, well-behaved subset of C in F\u2217, a dependently-typed variant of ML aimed at program verification. Departing from ML, Low\u2217 has a structured memory model \u00e0 la CompCert; it does not involve garbage collection or implicit heap allocations; and it provides instead the control required for writing low-level security-critical code. By virtue of typing, any Low\u2217 program is memory safe. On top of this, the programmer can make full use of the verification power of F\u2217 to write high-level specifications and verify the functional correctness of Low\u2217 code using a combination of SMT automation and sophisticated manual proofs. At extraction time, specifications and proofs are erased, and the remaining code enjoys a predictable translation to C. We prove that this translation preserves semantics and side-channel resistance.We have implemented and verified cryptographic algorithms, constructions, and tools in Low\u2217, for a total of about 20,000 lines of code. Our code delivers performance competitive with existing (unverified) C cryptographic libraries, suggesting our approach may be applicable to larger-scale, verified, low-level software.", "num_citations": "9\n", "authors": ["1771"]}
{"title": "Semantic Purity and Effects Reunited in F\u22c6\n", "abstract": " We present (new) F\u22c6, a dependently typed language for writing general-purpose programs with effects, specifying them within its functional core, and verifying them semi-automatically, by a combination of type inference, SMT solving, and manual proofs. A central difficulty is to ensure the consistency of a core language of proofs within a larger language in which programs may exhibit effects such as state, exceptions, non-termination, IO, concurrency, etc. Prior attempts at solving this problem generally resort to a range of ad hoc methods. Instead, the main novelty of F\u22c6 is to safely embrace and extend the familiar style of type-and-effect systems with fully dependent types.F\u22c6 is founded on a \u03bb-calculus with a range of primitive effects and a dependent type system parameterized by a user-defined lattice of Dijkstra monads. For each monad, the user provides a predicatetransformer that captures its effective semantics. At the bottom of the lattice is a distinguished Pure monad, such that computations typeable as Pure are normalizing\u2014our termination argument is based on well-founded relations and is fully semantic. We illustrate our design on a series of challenging programming examples. We outline its metatheory on a core calculus, for which we prove soundness and termination of the Pure fragment. We also discuss selected aspects of its fresh typechecker. The F\u22c6 system is open source; it fully supports our new design; it generates F# and OCaml code; and it bootstraps to several platforms.", "num_citations": "5\n", "authors": ["1771"]}
{"title": "Knowledge inference for optimizing and enforcing secure computations\n", "abstract": " We present several techniques that aim to compute the belief or knowledge a party might have about the values of hidden variables involved in the computation. These techniques can be used for enforcing knowledge-based security policies and for optimizing secure multiparty computations.", "num_citations": "3\n", "authors": ["1771"]}
{"title": "An Instrumenting Compiler for Enforcing Confidentiality in Low-Level Code\n", "abstract": " We present an instrumenting compiler for enforcing data confidentiality in low-level applications (eg those written in C) in the presence of an active adversary. In our approach, the programmer marks secret data by writing lightweight annotations on top-level definitions in the source code. The compiler then uses a static flow analysis coupled with efficient runtime instrumentation, a custom memory layout, and custom control-flow integrity checks to prevent data leaks even in the presence of low-level attacks. We have implemented our scheme as part of the LLVM compiler. We evaluate it on the SPEC micro-benchmarks for performance, and on larger, real-world applications (including OpenLDAP, which is around 300KLoC) for programmer overhead required to restructure the application when protecting the sensitive data such as passwords. We find that performance overheads introduced by our instrumentation are moderate (average 12% on SPEC), and the programmer effort to port OpenLDAP is only about 160 LoC.", "num_citations": "2\n", "authors": ["1771"]}
{"title": "Types and Access Controls for Cross-Domain Security in Flash\n", "abstract": " The ubiquitous Flash platform enables programmers to build sophisticated web application \u201cmash-ups\u201d that combine Flash executables loaded from multiple trust domains with complex, asymmetric trust relationships. Flash provides APIs and run-time checks to help programmers declare and enforce trust relationships between different domains, but there is currently no formal security model for Flash.               This paper presents the first formal security model for the Flash platform. Our formal model instantly reveals that the run-time checks performed by the Flash runtime are not sufficient to enforce data integrity \u2013 we present simple example programs that are vulnerable to attacks. We then develop a static type system for Flash programs that lets programmers specify fine-grained trust relationships, and we show that, combined with the run-time checks already performed by the Flash runtime, well-typed\u00a0\u2026", "num_citations": "1\n", "authors": ["1771"]}