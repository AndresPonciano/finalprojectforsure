{"title": "Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints\n", "abstract": " A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text-1515* 17 may be understood to denote computations on the abstract universe {(+),(-),(\u00b1)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution-1515* 17\u2192-(+)*(+)\u2192(-)*(+)\u2192(-), proves that-1515* 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (eg-1515+ 17\u2192\u00a0\u2026", "num_citations": "8365\n", "authors": ["1578"]}
{"title": "Systematic design of program analysis frameworks\n", "abstract": " Semantic analysis of programs is essential in optimizing compilers and program verification systems. It encompasses data flow analysis, data type determination, generation of approximate invariant assertions, etc.", "num_citations": "2020\n", "authors": ["1578"]}
{"title": "Abstract interpretation frameworks\n", "abstract": " We introduce abstract interpretation frameworks which are variations on the archetypal framework using Galois connections between concrete and abstract semantics, widenings and narrowings and are obtained by relaxation of the original hypotheses. We consider various ways of establishing the correctness of an abstract interpretation depending on how the relation between the concrete and abstract semantics is denned. We insist upon those correspondences allowing for the inducing of the approximate abstract semantics from the concrete one. Furthermore we study various notions of widening and narrowing as a means of obtaining convergence in the iterations used in abstract interpretation.", "num_citations": "972\n", "authors": ["1578"]}
{"title": "Abstract interpretation and application to logic programs\n", "abstract": " Abstract interpretation is a theory of semantics approximation that is used for the construction of semantic-based program analysis algorithms (sometimes called \u201cdata flow analysis\u201d), the comparison of formal semantics (e.g., construction of a denotational semantics from an operational one), design of proof methods, etc.Automatic program analysers are used for determining statistically conservative approximations of dynamic properties of programs. Such properties of the run-time behavior of programs are useful for debugging (e.g., type inference), code optimization (e.g., compile-time garbage collection, useless occur-check elimination), program transformation (e.g., partial evaluation, parallelization), and even program correctness proofs (e.g., termination proof).After a few simple introductory examples, we recall the classical framework for abstract interpretation of programs. Starting from a ground operational\u00a0\u2026", "num_citations": "887\n", "authors": ["1578"]}
{"title": "STATIC DETERMINATION OF DYNAMIC PROPERTIES OF PROGRAMS.\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "727\n", "authors": ["1578"]}
{"title": "Comparing the Galois connection and widening/narrowing approaches to abstract interpretation\n", "abstract": " The use of infinite abstract domains with widening and narrowing for accelerating the convergence of abstract interpretations is shown to be more powerful than the Galois connection approach restricted to finite lattices (or lattices satisfying the chain condition).", "num_citations": "601\n", "authors": ["1578"]}
{"title": "Abstract interpretation\n", "abstract": " A semantics S of a programming language L associates a semantic value S p in the semantic domain to each program p of L. The semantic domain can be transition systems (for small-step operational semantics), pomsets, traces, relations (for big-step operational semantics), higher-order functions (for denotational semantics), and so on. is usually defined compositionally by induction on the structure of run-time objects (computations, data, etc.). S is defined compositionally by induction on the syntactical structure of programs using, for example, fixpoint definitions to handle iteration, recursion, and the like.An empirical approach to abstract interpretation consists in a priori choosing a problem-specific abstract semantics domain\u266f and an abstract semantics S\u266f L\u266f that is designed intuitively for a specific language L. Then safety, correctness, or soundness is established by proving that a soundness relation satisfies", "num_citations": "352\n", "authors": ["1578"]}
{"title": "Semantic foundations of program analysis\n", "abstract": " Semantic foundations of program analysis \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Search by expertise, name or affiliation Semantic foundations of program analysis Patrick Cousot Computer Science Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter (peer-reviewed) \u203a peer-review Overview Original language English (US) Title of host publication Program flow analysis Subtitle of host publication Theory and applications Editors S. Muchnick, N. Jones Publisher Prentice Hall Pages 303-342 State Published - 1981 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P. (1981). Semantic foundations of program analysis. In S. Muchnick, & N. Jones (Eds.), Program flow analysis: Theory and applications (pp. 303-342). [Chapter 10] Prentice Hall. Semantic \u2026", "num_citations": "327\n", "authors": ["1578"]}
{"title": "Constructive versions of Tarski\u2019s fixed point theorems\n", "abstract": " Let F be a monotone operator on the complete lattice L into itself. Tarski\u2019s lattice theoretical fixed point theorem states that the set of fixed points of F is a nonempty complete lattice for the ordering of L. We give a constructive proof of this theorem showing that the set of fixed points of F is the image of L by a lower and an upper preclosure operator. These preclosure operators are the composition of lower and upper closure operators which are defined by means of limits of stationary transfinite iteration sequences for F. In the same way we give a constructive characterization of the set of common fixed points of a family of commuting operators. Finally we examine some consequences of additional semi-continuity hypotheses.", "num_citations": "295\n", "authors": ["1578"]}
{"title": "Inductive definitions, semantics and abstract interpretations\n", "abstract": " We introduce and illustrate a specification method combining rule-based inductive definitions, well-founded induction principles, fixed-point theory and abstract interpretation for general use in computer science. Finite as well as infinite objects can be specified, at various levels of details related by abstraction. General proof principles are applicable to prove properties of the specified objects.", "num_citations": "273\n", "authors": ["1578"]}
{"title": "Types as abstract interpretations\n", "abstract": " Starting from a denotational semantics of the eager untyped lambda-calculus with explicit runtime errors, the standard collecting semantics is defined as specifying the strongest program properties. By a first abstraction, a new sound type collecting semantics is derived in compositional fix-point form. Then by successive (semi-dual) Galois connection based abstractions, type systems and/or type inference algorithms are designed as abstract semantics or abstract interpreters approximating the type collecting semantics. This leads to a hierarchy of type systems, which is part of the lattice of abstract interpretations of the untyped lambda-calculus. This hierarchy includes two new \u00e1 la Church/Curry polytype systems. Abstractions of this polytype semantics lead to classical Milner/Mycroft and Damas/Milner polymorphic type schemes, Church/Curry monotypes and Hindley principal typing algorithm. This shows that types\u00a0\u2026", "num_citations": "255\n", "authors": ["1578"]}
{"title": "Proving program invariance and termination by parametric abstraction, lagrangian relaxation and semidefinite programming\n", "abstract": " In order to verify semialgebraic programs, we automatize the Floyd/Naur/Hoare proof method. The main task is to automatically infer valid invariants and rank functions.               First we express the program semantics in polynomial form. Then the unknown rank function and invariants are abstracted in parametric form. The implication in the Floyd/Naur/Hoare verification conditions is handled by abstraction into numerical constraints by Lagrangian relaxation. The remaining universal quantification is handled by semidefinite programming relaxation. Finally the parameters are computed using semidefinite programming solvers.               This new approach exploits the recent progress in the numerical resolution of linear or bilinear matrix inequalities by semidefinite programming using efficient polynomial primal/dual interior point methods generalizing those well-known in linear programming to convex\u00a0\u2026", "num_citations": "250\n", "authors": ["1578"]}
{"title": "Static determination of dynamic properties of recursive procedures\n", "abstract": " Static determination of dynamic properties of recursive procedures \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Search by expertise, name or affiliation Static determination of dynamic properties of recursive procedures Patrick Cousot, Radhia Cousot Computer Science Research output: Chapter in Book/Report/Conference proceeding \u203a Conference contribution Overview Original language English (US) Title of host publication IFIP Conference on Formal Description of Programming Concepts, St. Andrews, NB, Canada Editors E. Neuhold Publisher North-Holland Publishing Company Pages 237-277 State Published - 1977 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P., & Cousot, R. (1977). Static determination of dynamic properties of recursive procedures. In E. Neuhold (Ed.), \u2026", "num_citations": "238\n", "authors": ["1578"]}
{"title": "M\u00e9thodes it\u00e9ratives de construction et d'approximation de points fixes d'op\u00e9rateurs monotones sur un treillis, analyse s\u00e9mantique des programmes\n", "abstract": " Th\u00e9or\u00e8mes de points fixes dans les treillis complets, \u00e9tude du comportement d'un syst\u00e8me dynamique discret, analyse s\u00e9mantique exacte des programmes et applications. M\u00e9thodes constructives d'approximation de points fixes d'op\u00e9rateurs monotone sur un treillis complet. Analyse s\u00e9mantique approch\u00e9e des programmes et applications. Analyse s\u00e9mantique des proc\u00e9dures recursives.", "num_citations": "231\n", "authors": ["1578"]}
{"title": "Constructive design of a hierarchy of semantics of a transition system by abstract interpretation\n", "abstract": " We construct a hierarchy of semantics by successive abstract interpretations. Starting from the maximal trace semantics of a transition system, we derive the big-step semantics, termination and nontermination semantics, Plotkin's natural, Smyth's demoniac and Hoare's angelic relational semantics and equivalent nondeterministic denotational semantics (with alternative powerdomains to the Egli\u2013Milner and Smyth constructions), D. Scott's deterministic denotational semantics, the generalized and Dijkstra's conservative/liberal predicate transformer semantics, the generalized/total and Hoare's partial correctness axiomatic semantics and the corresponding proof methods. All the semantics are presented in a uniform fixpoint form and the correspondences between these semantics are established through composable Galois connections, each semantics being formally calculated by abstract interpretation of a more\u00a0\u2026", "num_citations": "228\n", "authors": ["1578"]}
{"title": "Abstract interpretation based formal methods and future challenges\n", "abstract": " In order to contribute to the solution of the software reliability problem, tools have been designed to analyze statically the run-time behavior of programs. Because the correctness problem is undecidable, some form of approximation is needed. The purpose of abstract interpretation is to formalize this idea of approximation. We illustrate informally the application of abstraction to the semantics of programming languages as well as to static program analysis. The main point is that in order to reason or compute about a complex system, some information must be lost, that is the observation of executions must be either partial or at a high level of abstraction.                 A few challenges for static program analysis by abstract interpretation are finally briefly discussed.                 The electronic version of this paper includes a comparison with other formal methods: typing, model-checking and deductive methods.", "num_citations": "220\n", "authors": ["1578"]}
{"title": "Modular static program analysis\n", "abstract": " The purpose of this paper is to present four basic methods for compositional separate modular static analysis of programs by abstract interpretation: - simplification-based separate analysis; - worst-case separate analysis; - separate analysis with (user-provided) interfaces; - symbolic relational separate analysis; as well as a fifth category which is essentially obtained by composition of the above separate local analyses together with global analysis methods.", "num_citations": "213\n", "authors": ["1578"]}
{"title": "Methods and logics for proving programs\n", "abstract": " Publisher SummaryThis chapter presents a number of ideas that originated an evolution of programming from arts and crafts to a science. The chapter describes computer arithmetic in two stages. In the first stage, axioms are given for arithmetic operations on natural numbers, which are valid independently of their computer representation, and choices of supplementary axioms are proposed for characterizing various possible implementations. In the second part, an axiomatic definition of program execution is introduced. An axiomatic approach is indispensable for achieving program reliability. The usefulness of program proving is advocated in view of the cost of programming errors and program testing. The chapter discusses the definition of formal language. The axioms and rules of inference can be understood as the ultimate definitive specification of the meaning of the language.", "num_citations": "209\n", "authors": ["1578"]}
{"title": "Systematic design of program transformation frameworks by abstract interpretation\n", "abstract": " We introduce a general uniform language-independent framework for designing online and offline source-to-source program transformations by abstract interpretation of program semantics. Iterative source-to-source program transformations are designed constructively by composition of source-to-semantics, semantics-to-transformed semantics and semantics-to-source abstractions applied to fixpoint trace semantics. The correctness of the transformations is expressed through observational and performance abstractions. The framework is illustrated on three examples: constant propagation, program specialization by online and offline partial evaluation and static program monitoring.", "num_citations": "197\n", "authors": ["1578"]}
{"title": "The calculational design of a generic abstract interpreter\n", "abstract": " We present in extenso the calculation-based development of a generic compositional reachability static analyzer for a simple imperative programming language by abstract interpretation of its formal rule-based/structured small-step operational semantics.", "num_citations": "191\n", "authors": ["1578"]}
{"title": "Higher-order abstract interpretation (and application to comportment analysis generalizing strictness, termination, projection and PER analysis of functional languages)\n", "abstract": " The original formulation of abstract interpretation represents program properties by sets. A property is understood as the set of semantic values satisfying it. Strongest program properties are defined by the collecting semantics which extends the standard semantics to powersets of semantic values. The approximation relation corresponding to the logical implication of program properties is subset inclusion. This was expressed using set and lattice theory in the context of transition systems. Some applications of abstract interpretation, such as strictness analysis for lazy functional languages, require infinite behaviours of higher-order functions to be taken into account. We solve the problem by returning to the sources of abstract interpretation, which consists in considering collecting semantics. By using Galois connections, properties of the standard semantics naturally transfer to the collecting and then to the abstract\u00a0\u2026", "num_citations": "190\n", "authors": ["1578"]}
{"title": "A parametric segmentation functor for fully automatic and scalable array content analysis\n", "abstract": " We introduce FunArray, a parametric segmentation abstract domain functor for the fully automatic and scalable analysis of array content properties. The functor enables a natural, painless and efficient lifting of existing abstract domains for scalar variables to the analysis of uniform compound data-structures such as arrays and collections. The analysis automatically and semantically divides arrays into consecutive non-overlapping possibly empty segments. Segments are delimited by sets of bound expressions and abstracted uniformly. All symbolic expressions appearing in a bound set are equal in the concrete. The FunArray can be naturally combined via reduced product with any existing analysis for scalar variables. The analysis is presented as a general framework parameterized by the choices of bound expressions, segment abstractions and the reduction operator. Once the functor has been instantiated with\u00a0\u2026", "num_citations": "175\n", "authors": ["1578"]}
{"title": "Temporal abstract interpretation\n", "abstract": " We study the abstract interpretation of temporal calculi and logics in a general syntax, semantics and abstraction independent setting. This is applied to the@@@@-calculus, a generalization of the \u03bc-calculus with new reversal and abstraction modalities as well as a new time-symmetric trace-based semantics. The more classical set-based semantics is shown to be an abstract interpretation of the trace-based semantics which leads to the understanding of model-checking and its application to data-flow analysis as incomplete temporal abstract interpretations. Soundness and incompleteness of the abstractions are discussed. The sources of incompleteness, even for finite systems, are pointed out, which leads to the identification of relatively complete sublogics, \u00e0 la CTL.", "num_citations": "171\n", "authors": ["1578"]}
{"title": "Formal language, grammar and set-constraint-based program analysis by abstract interpretation\n", "abstract": " We construct program analyses by abstract interpretation of a collecting semantics where abstract properties are coded using tuples of formal languages. A further approximation is to approximate such formal languages by different kinds of formal systems such as grammars or systems of set-constraints. The idea of using regular tree grammars for program analysis, is due to Jones and Muchnick[22, 23, 24] following Reynolds [29]. It was further developed by Aiken, Mishra, Murphy, Reddy and Sorensen[2, 27, 30], implemented by Aiken and Murphy[1] and reformulated by Heintze and Jaffar[16, 17, 19, 20] M set-constraint-based program analysis. We show that in such formal-language-based program analyses, the abstract semantics specifying the strongest abstract program property is defined M the least fixpoint of an abstract property transformer. This abstract semantics can be also presented as a system of\u00a0\u2026", "num_citations": "169\n", "authors": ["1578"]}
{"title": "Automatic synthesis of optimal invariant assertions: Mathematical foundations\n", "abstract": " The problem of discovering invariant assertions of programs is explored in light of the fixpoint approach in the static analysis of programs, Cousot [1977a], Cousot[1977b]. In section 2 we establish the lattice theoric foundations upon which the synthesis of invariant assertions is based. We study the resolution of a fixpoint system of equations by Jacobi's successive approximations method. Under continuity hypothesis we show that any chaotic iterative method converges to the optimal solution. In section 3 we study the deductive semantics of programs. We show that a system of logical forward equations can be associated with a program using the predicate transformer rules which define the semantics of elementary instructions. The resolution of this system of semantic equations by chaotic iterations leads to the optimal invariants which exactly define the semantics of this program. Therefore these optimal invariants\u00a0\u2026", "num_citations": "168\n", "authors": ["1578"]}
{"title": "An abstract interpretation-based framework for software watermarking\n", "abstract": " Software watermarking consists in the intentional embedding of indelible stegosignatures or watermarks into the subject software and extraction of the stegosignatures embedded in the stegoprograms for purposes such as intellectual property protection. We introduce the novel concept of abstract software watermarking. The basic idea is that the watermark is hidden in the program code in such a way that it can only be extracted by an abstract interpretation of the (maybe non-standard) concrete semantics of this code. This static analysis-based approach allows the watermark to be recovered even if only a small part of the program code is present and does not even need that code to be executed. We illustrate the technique by a simple abstract watermarking protocol for methods of Java\u2122 classes. The concept applies equally well to any other kind of software (including hardware originally specified by software).", "num_citations": "162\n", "authors": ["1578"]}
{"title": "Refining model checking by abstract interpretation\n", "abstract": " Formal methods combining abstract interpretation and model-checking have been considered for automated analysis of software.In abstract model-checking, the semantics of an infinite transition system is abstracted to get a finite approximation on which temporal-logic/\u00b5-calculus model-checking can be directly applied. The paper proposes two improvements of abstract model-checking which can be applied to infinite abstract transition systems:", "num_citations": "148\n", "authors": ["1578"]}
{"title": "Static determination of dynamic properties of generalized type unions\n", "abstract": " The classical programming languages such as PASCAL or ALGOL 68 do not provide full data type security. Run-time errors are not precluded on basic operations. Type safety necessitates a refinement of the data type notion which allows subtypes. The compiler must also be able to ensure that basic operations are applicable. This verification consists in determining a local subtype of globally declared variables or constants. This may be achieved by improved compiler capabilities to analyze the program properties or by language constructs which permit the expression of these properties. Both approaches are discussed and illustrated by the problems of access to records via pointers, access to variants of record structures, determination of disjoint collections of linked records, and determination of integer subrange. Both approaches are complementary and a balance must be found between what must be specified\u00a0\u2026", "num_citations": "97\n", "authors": ["1578"]}
{"title": "Constructive design of a hierarchy of semantics of a transition system by abstract interpretation\n", "abstract": " We construct a hierarchy of semantics by successive abstract interpretations. Starting from a maximal trace semantics of a transition system, we derive a big-step semantics, termination and nontermination semantics, natural, demoniac and angelic relational semantics and equivalent nondeterministic denotational semantics, D. Scott's deterministic denotational semantics, generalized/conservative/liberal predicate transformer semantics, generalized/total/partial correctness axiomatic semantics and corresponding proof methods. All semantics are presented in uniform fixpoint form and the correspondence between these semantics are established through composable Galois connection.", "num_citations": "96\n", "authors": ["1578"]}
{"title": "Basic concepts of abstract interpretation\n", "abstract": " A brief introduction to the theory of Abstract Interpretation, examplified by constructing a hierarchy of partial traces, reflexive transitive closure, reachable states and intervals abstract semantics of transition systems.", "num_citations": "95\n", "authors": ["1578"]}
{"title": "An abstract interpretation framework for termination\n", "abstract": " Proof, verification and analysis methods for termination all rely on two induction principles: (1) a variant function or induction on data ensuring progress towards the end and (2) some form of induction on the program structure. The abstract interpretation design principle is first illustrated for the design of new forward and backward proof, verification and analysis methods for safety. The safety collecting semantics defining the strongest safety property of programs is first expressed in a constructive fixpoint form. Safety proof and checking/verification methods then immediately follow by fixpoint induction. Static analysis of abstract safety properties such as invariance are constructively designed by fixpoint abstraction (or approximation) to (automatically) infer safety properties. So far, no such clear design principle did exist for termination so that the existing approaches are scattered and largely not comparable with each\u00a0\u2026", "num_citations": "86\n", "authors": ["1578"]}
{"title": "Probabilistic abstract interpretation\n", "abstract": " Abstract interpretation has been widely used for verifying properties of computer systems. Here, we present a way to extend this framework to the case of probabilistic systems.             The probabilistic abstraction framework that we propose allows us to systematically lift any classical analysis or verification method to the probabilistic setting by separating in the program semantics the probabilistic behavior from the (non-)deterministic behavior. This separation provides new insights for designing novel probabilistic static analyses and verification methods.             We define the concrete probabilistic semantics and propose different ways to abstract them. We provide examples illustrating the expressiveness and effectiveness of our approach.", "num_citations": "81\n", "authors": ["1578"]}
{"title": "Verification by abstract interpretation\n", "abstract": " Abstract interpretation theory formalizes the idea of abstraction of mathematical structures, in particular those involved in the specification of properties and proof methods of computer systems. Verification by abstract interpretation is illustrated on the particular cases of predicate abstraction, which is revisited to handle infinitary abstractions, and on the new parametric predicate abstraction.", "num_citations": "76\n", "authors": ["1578"]}
{"title": "S\u00e9mantiques des langages imp\u00e9ratifs d'ordre sup\u00e9rieur et interpr\u00e9tation abstraite\n", "abstract": " L'interpretation abstraite ou analyse semantique d'un langage de programmation est une methode formelle permettant d'obtenir, de maniere statique (i. E. A la compilation) et automatique, une description approchee du comportement dynamique (i. E. A l'execution) des programmes. Cette methode a ete appliquee jusqu'ici a des langages relativement simples (langages imperatifs, fonctionnels, logiques ou paralleles du premier ordre). Or les langages de programmation modernes comme le langage modula-3 ou meme des langages plus anciens comme pascal comportent des mecanismes de programmation puissants (passage des parametres formels par reference, passage en parametre des procedures locales, branchements a des etiquettes non locales, exceptions) qui augmentent de maniere considerable leur puissance d'expression et leur complexite semantique. Cette these aborde le probleme de l'interpretation abstraite des langages imperatifs d'ordre superieur. Dans une premiere partie, nous montrons que des interpretations abstraites trop naives de tels langages sont a la fois extremement couteuses et imprecises. Pour remedier a ces problemes, nous introduisons une nouvelle semantique des langages imperatifs d'ordre superieur dont l'interpretation abstraite est precise et peu couteuse et nous etablissons la correction de cette semantique pour une nouvelle classe non decidable de programmes comprenant en particulier la classe decidable des programmes pascal. Puis, dans la seconde partie, nous abordons la technique du debugging abstrait permettant d'effectuer une mise au point formelle des programmes et nous\u00a0\u2026", "num_citations": "76\n", "authors": ["1578"]}
{"title": "Compositional and inductive semantic definitions in fixpoint, equational, constraint, closure-condition, rule-based and game-theoretic form\n", "abstract": " We present a language and semantics-independent, compositional and inductive method for specifying formal semantics or semantic properties of programs in equivalent fixpoint, equational, constraint, closure-condition, rule-based and game-theoretic form. The definitional method is obtained by extending set-theoretic definitions in the context of partial orders. It is parameterized by the language syntax, by the semantic domains and by the semantic transformers corresponding to atomic and compound program components. The definitional method is shown to be preserved by abstract interpretation in either fixpoint, equational, constraint, closure-condition, rule-based or game-theoretic form. The features common to all possible instantiations are factored out thus allowing for results of general scope such as well-definedness, semantic equivalence, soundness and relative completeness of abstract\u00a0\u2026", "num_citations": "69\n", "authors": ["1578"]}
{"title": "Partial completeness of abstract fixpoint checking\n", "abstract": " Abstract interpretation is used in program static analysis and model checking to cope with infinite state spaces and/or with computer resource limitations. One common problem is to check abstract fixpoints for specifications. The abstraction is partially complete when the checking algorithm is exact in that, if the algorithm ever terminates, its answer is always affirmative for correct specifications. We characterize partially complete abstractions for various abstract fixpoint checking algorithms, including new ones, and show that the computation of complete abstract domains is essentially equivalent to invariance proofs that is to concrete fixpoint checking.", "num_citations": "68\n", "authors": ["1578"]}
{"title": "Interpr\u00e9tation abstraite\n", "abstract": " L\u2019interpr\u00e9tation abstraite est une th\u00e9orie de l\u2019approximation discr\u00e8te de s\u00e9mantiques de syst\u00e8mes informatiques principalement utilis\u00e9e pour l\u2019analyse et la v\u00e9rification statique de logiciels.ABSTRACT. Abstract interpretation is a theory of discrete approximation of the semantics of computer systems mainly applied to the static analysis and verification of software.", "num_citations": "59\n", "authors": ["1578"]}
{"title": "Semantic analysis of communicating sequential processes\n", "abstract": " We present semantic analysis techniques for concurrent programs which are designed as networks of nondeterministic sequential processes, communicating with each other explicitly, by the sole means o {synchronous, unbuffered message passing. The techniques are introduced using a version of Hoare [78]'s programming language CSP", "num_citations": "59\n", "authors": ["1578"]}
{"title": "ASYCHRONOUS ITERATIVE METHODS FOR SOLVING A FIXED POINT SYSTEM OF MONOTONE EQUATIONS IN A COMPLETE LATTICE.\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "58\n", "authors": ["1578"]}
{"title": "A gentle introduction to formal verification of computer systems by abstract interpretation\n", "abstract": " We introduce and illustrate basic notions of abstract interpretation theory and its applications by relying on the readers general scientific culture and basic knowledge of computer programming.", "num_citations": "55\n", "authors": ["1578"]}
{"title": "Precondition inference from intermittent assertions and application to contracts on collections\n", "abstract": " Programmers often insert assertions in their code to be optionally checked at runtime, at least during the debugging phase. In the context of design by contracts, these assertions would better be given as a precondition of the method/procedure which can detect that a caller has violated the procedure\u2019s contract in a way which definitely leads to an assertion violation (e.g., for separate static analysis). We define precisely and formally the contract inference problem from intermittent assertions inserted in the code by the programmer. Our definition excludes no good run even when a non-deterministic choice (e.g., an interactive input) could lead to a bad one (so this is not the weakest precondition, nor its strengthening by abduction, since a terminating successful execution is not guaranteed). We then introduce new abstract interpretation-based methods to automatically infer both the static contract precondition of\u00a0\u2026", "num_citations": "52\n", "authors": ["1578"]}
{"title": "Abstract interpretation: past, present and future\n", "abstract": " Abstract interpretation is a theory of abstraction and constructive approximation of the mathematical structures used in the formal description of complex or infinite systems and the inference or verification of their combinatorial or undecidable properties. Developed in the late seventies, it has been since then used, implicitly or explicitly, to many aspects of computer science (such as static analysis and verification, contract inference, type inference, termination inference, model-checking, abstraction/refinement, program transformation (including watermarking, obfuscation, etc), combination of decision procedures, security, malware detection, database queries, etc) and more recently, to system biology and SAT/SMT solvers. Production-quality verification tools based on abstract interpretation are available and used in the advanced software, hardware, transportation, communication, and medical industries.", "num_citations": "49\n", "authors": ["1578"]}
{"title": "Small formulas for large programs: On-line constraint simplification in scalable static analysis\n", "abstract": " Static analysis techniques that represent program states as formulas typically generate a large number of redundant formulas that are incrementally constructed from previous formulas. In addition to querying satisfiability and validity, analyses perform other operations on formulas, such as quantifier elimination, substitution, and instantiation, most of which are highly sensitive to formula size. Thus, the scalability of many static analysis techniques requires controlling the size of the generated formulas throughout the analysis. In this paper, we present a practical algorithm for reducing SMT formulas to a simplified form containing no redundant subparts. We present experimental evidence that on-line simplification of formulas dramatically improves scalability.", "num_citations": "48\n", "authors": ["1578"]}
{"title": "Invariance proof methods and analysis techniques for parallel programs\n", "abstract": " Invariance proof methods and analysis techniques for parallel programs \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Invariance proof methods and analysis techniques for parallel programs Patrick Cousot, Radhia Cousot Computer Science Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter (peer-reviewed) Overview Original language English (US) Title of host publication Automatic program construction techniques Editors A. Biermann, G. Guiho, Y. Kodratoff Publisher Macmillan Pages 243-271 State Published - 1984 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P., & Cousot, R. (1984). Invariance proof methods and analysis techniques for parallel programs. In A. Biermann, G. Guiho, & Y. Kodratoff (Eds.), Automatic program construction techniques (pp\u2026", "num_citations": "48\n", "authors": ["1578"]}
{"title": "Fixpoint-guided abstraction refinements\n", "abstract": " In this paper, we present an abstract fixpoint checking algorithm with automatic refinement by backward completion in Moore closed abstract domains. We study the properties of our algorithm and prove it to be more precise than the counterexample guided abstract refinement algorithm (CEGAR). Contrary to several works in the literature, our algorithm does not require the abstract domains to be partitions of the state space. We also show that our automatic refinement technique is compatible with so-called acceleration techniques. Furthermore, the use of Boolean closed domains does not improve the precision of our algorithm. The algorithm is illustrated by proving properties of programs with nested loops.", "num_citations": "46\n", "authors": ["1578"]}
{"title": "Program analysis: the abstract interpretation perspective\n", "abstract": " Program semantic analysis consists of designing and writing program analyzers. A program analyzer is a program which takes as input data a (possibly annotated) program (written in some language) and (fully automatically) produces as output answers to questions about runtime properties which are valid for all (or sometimes for some) possible executions of that program. Because of undecidability or complexity, these answers are necessarily partial, but should be irrefutable. Program analysis is both a theoretical activity (close to formal specification methods, semantics, etc.) and a practical activity (close to compiler design and development). In a sense this situation is quite creative: looking at a real and vast application problem is a fruitful guide to the process of formalization of the semantics of programming languages, proof methods, etc. This is also a difficult position akin to the old debate between pure and applied mathematics. Often practitioners are not worried about theories while theorists rarely take time to find applications of their theoretical work which is loosely coupled with practical problems.", "num_citations": "46\n", "authors": ["1578"]}
{"title": "The reduced product of abstract domains and the combination of decision procedures\n", "abstract": " The algebraic/model theoretic design of static analyzers uses abstract domains based on representations of properties and pre-calculated property transformers. It is very efficient. The logical/proof theoretic approach uses SMT solvers and computation on-the-fly of property transformers. It is very expressive. We propose a combination of the two approaches to reach the sweet spot best adapted to a specific application domain in the precision/cost spectrum. The proposed combination uses an iterated reduction to combine abstractions. The key observation is that the Nelson-Oppen procedure which decides satisfiability in a combination of logical theories by exchanging equalities and disequalities computes a reduced product (after the state is enhanced with some new \u201cobservations\u201d corresponding to alien terms). By abandoning restrictions ensuring completeness (such as disjointness, convexity, stably\u00a0\u2026", "num_citations": "44\n", "authors": ["1578"]}
{"title": "Analyses s\u00e9mantiques de congruence\n", "abstract": " L'analyse semantique des programmes consiste a determiner automatiquement a la compilation des proprietes qu'ils verifient lors de toute execution. Cette these est plus particulierement consacree aux proprietes de congruence des variables (ou des abstractions) numeriques. Precisement, a partir d'un cadre algebrique commun, on definit tout d'abord l'analyse de congruence arithmetique sur les nombres entiers, qui generalise a la fois la parite et la propagation des constantes, qu'on generalise elle-meme a l'inference de systemes d'equations lineaires de congruence. On generalise ensuite ces deux analyses aux nombres rationnels. Entre autres, ces analyses peuvent s' averer utiles dans le cadre de la vectorisation automatique pour les premieres, et pour les secondes afin d'optimiser la representation des reels et limiter les erreurs d'arrondi dans les calculs. On termine par la presentation rapide d'extensions des precedentes analyses, d'analyses de congruence multiplicative et de techniques d'iterations decroissantes permettant d'ameliorer les resultats des analyses en general", "num_citations": "42\n", "authors": ["1578"]}
{"title": "On abstraction in software verification\n", "abstract": " We show that the precision of static abstract software checking algorithms can be enhanced by taking explicitly into account the abstractions that are involved in the design of the program model/abstract semantics. This is illustrated on reachability analysis and abstract testing.", "num_citations": "37\n", "authors": ["1578"]}
{"title": "Ogre and Pythia: an invariance proof method for weak consistency models\n", "abstract": " We design an invariance proof method for concurrent programs parameterised by a weak consistency model. The calculational design of the invariance proof method is by abstract interpretation of a truly parallel analytic semantics. This generalises the methods by Lamport and Owicki-Gries for sequential consistency. We use cat as an example of language to write consistency specifications of both concurrent programs and machine architectures.", "num_citations": "36\n", "authors": ["1578"]}
{"title": "A scalable segmented decision tree abstract domain\n", "abstract": " The key to precision and scalability in all formal methods for static program analysis and verification is the handling of disjunctions arising in relational analyses, the flow-sensitive traversal of conditionals and loops, the context-sensitive inter-procedural calls, the interleaving of concurrent threads, etc. Explicit case enumeration immediately yields to combinatorial explosion. The art of scalable static analysis is therefore to abstract disjunctions to minimize cost while preserving weak forms of disjunctions for expressivity.             Building upon packed binary decision trees to handle disjunction in tests, loops and procedure/function calls and array segmentation to handle disjunctions in array content analysis, we introduce segmented decision trees to allow for more expressivity while mastering costs via widenings.", "num_citations": "36\n", "authors": ["1578"]}
{"title": "Proving the absence of run-time errors in safety-critical avionics code\n", "abstract": " We explain the design of the interpretation-based static analyzer ASTR\u00c9E and its use to prove the absence of run-time errors in safety-critical codes.", "num_citations": "36\n", "authors": ["1578"]}
{"title": "Induction principles for proving invariance properties of programs\n", "abstract": " Induction principles for proving invariance properties of programs \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Induction principles for proving invariance properties of programs Patrick Cousot, Radhia Cousot Computer Science Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter (peer-reviewed) Overview Original language English (US) Title of host publication Tools & notions for program construction Editors D. Neel Publisher Cambridge University Press Pages 43-119 State Published - 1982 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P., & Cousot, R. (1982). Induction principles for proving invariance properties of programs. In D. Neel (Ed.), Tools & notions for program construction (pp. 43-119). Cambridge University Press. Induction principles for \u2026", "num_citations": "36\n", "authors": ["1578"]}
{"title": "Formal verification by abstract interpretation\n", "abstract": " We provide a rapid overview of the theoretical foundations and main applications of abstract interpretation and show that it currently provides scaling solutions to achieving assurance in mission- and safety-critical systems through verification by fully automatic, semantically sound and precise static program analysis.", "num_citations": "34\n", "authors": ["1578"]}
{"title": "A constructive characterization of the lattices of all retractions, preclosure, quasi-closure and closure operators on a complete lattice\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "34\n", "authors": ["1578"]}
{"title": "Automatic Verification by abstract interpretation\n", "abstract": " We discuss the use of abstract interpretation in the context of automatic program verification requiring precise abstractions. We compare entirely manual versus user-guided abstractions ranging from program-specific abstractions including predicate abstraction to the systematic design of abstract domains and iteration strategies.", "num_citations": "32\n", "authors": ["1578"]}
{"title": "Theories, solvers and static analysis by abstract interpretation\n", "abstract": " The algebraic/model theoretic design of static analyzers uses abstract domains based on representations of properties and pre-calculated property transformers. It is very efficient. The logical/proof theoretic approach uses SMT solvers/theorem provers and computation of property transformers on-the-fly. It is very expressive. We propose to unify both approaches, so that they can be combined to reach the sweet spot best adapted to a specific application domain in the precision/cost spectrum. We first give a new formalization of the proof theoretic approach in the abstract interpretation framework, introducing a semantics based on multiple interpretations to deal with the soundness of such approaches. Then we describe how to combine them with any other abstract interpretation-based analysis using an iterated reduction to combine abstractions. The key observation is that the Nelson-Oppen procedure, which decides\u00a0\u2026", "num_citations": "30\n", "authors": ["1578"]}
{"title": "The verification grand challenge and abstract interpretation\n", "abstract": " Abstract Interpretation is a theory of approximation of mathematical structures, in particular those involved in the semantic models of computer systems [4,10,11]. Abstract interpretation can be applied to the systematic construction of methods and effective algorithms to approximate undecidable or very complex problems in computer science. The scope of application is rather large e.g. from type inference [5], model-checking [13], program transformation [14], watermarking [15] to context-free grammar parser generation [16].", "num_citations": "29\n", "authors": ["1578"]}
{"title": "Compositional separate modular static analysis of programs by abstract interpretation\n", "abstract": " The purpose of this paper is to present four ba sic methods for compositional separate modular static analy sis of programs by abstract interpretation:. Simplification-based separate analysis;. Worst-case separate analysis;. Separate analysis with (user-provided) interfaces;. Symbolic relational separate analysis; as well as a fifth category which is essentially obtained by composition of the above separate local analyses and global analysis methods.", "num_citations": "29\n", "authors": ["1578"]}
{"title": "Integrating physical systems in the static analysis of embedded control software\n", "abstract": " Abstract interpretation is a theory of effective abstraction and/or approximation of discrete mathematical structures as found in the semantics of programming languages, modelling program executions, hence program properties, at various levels of abstraction [3,7,8,10,12].", "num_citations": "28\n", "authors": ["1578"]}
{"title": "Galois connection based abstract interpretations for strictness analysis\n", "abstract": " The abstract interpretation framework based upon the approximation of a fixpoint collecting semantics using Galois connections and widening/narrowing operators on complete lattices [CC77a, CC79b] has been considered difficult to apply to Mycroft's strictness analysis [Myc80, Myc81] for which denotational semantics was though to be more adequate (because non-termination has to be taken into account), see e.g. [AH87], page 25.             Considering a non-deterministic first-order language, we show, contrary to expectation, and using the classical Galois connection-based framework, that Mycroft strictness analysis algorithm is the abstract interpretation of a relational semantics (a big-steps operational semantics including non-termination which can be defined in G\u221eSOS either in rule-based or fixpoint style by induction on the syntax of programs [CC92])             An improved version of Johnsson's algorithm\u00a0\u2026", "num_citations": "28\n", "authors": ["1578"]}
{"title": "Parsing as abstract interpretation of grammar semantics\n", "abstract": " Earley's parsing algorithm is shown to be an abstract interpretation of a refinement of the derivation semantics of context-free grammars.", "num_citations": "27\n", "authors": ["1578"]}
{"title": "Abstract interpretation: Achievements and perspectives\n", "abstract": " Computerized modern societies are highly frag ile to software bugs. Traditional testing methods hardly scale up for large safety critical systems as found in avionics, automotive, healthcare, e-commerce and security industry. As a viable alternative, static analysis consists in determin ing and verifying statically dynamic properties of programs. This is completely automatic (since programs are not actu ally executed) and covers all possible cases (as opposed to testing). This approach has had significant success stories and its industrialization recently started. Since the program total verification problem is undecidable, the key idea is that of approximation, as formalized by the theory of abstract interpretation. The scope of application of abstract inter pretation ranges from the theoretical design of hierarchies of the semantics of programming languages to the practical design of generic program static analyzers.", "num_citations": "27\n", "authors": ["1578"]}
{"title": "Syntax and semantics of the weak consistency model specification language cat\n", "abstract": " We provide the syntax and semantics of the cat language, a domain specific language to describe consistency properties of parallel/distributed programs. The language is implemented in the herd7 too (http://diy.inria.fr/doc/herd.html)l.", "num_citations": "25\n", "authors": ["1578"]}
{"title": "Verification of embedded software: Problems and perspectives\n", "abstract": " Computer aided formal methods have been very successful for the verification or at least enhanced debugging of hardware. The cost of correction of a hardware bug is huge enough to justify high investments in alternatives to testing such as correctness verification. This is not the case for software for which bugs are a quite common situation which can be easily handled through online updates. However in the area of embedded software, errors are hardly tolerable. Such embedded software is often safety-critical, so that a software failure might create a safety hazard in the equipment and put human life in danger. Thus embedded software verification is a research area of growing importance. Present day software verification technology can certainly be useful but is yet too limited to cope with the formidable challenge of complete software verification. We highlight some of the problems to be solved and\u00a0\u2026", "num_citations": "25\n", "authors": ["1578"]}
{"title": "Abstract interpretation based program testing\n", "abstract": " Every one can daily experiment that programs are bugged. Software bugs can have severe if not catas trophic consequences in computer-based safety critical ap plications. This impels the development of formal methods, whether manual, computer-assisted or automatic, for verify ing that a program satisfies a specification. Among the auto matic formal methods, program static analysis can be used to check for the absence of run-time errors. In this case the specification is provided by the semantics of the program ming language in which the program is written. Abstract in terpretation provides a formal theory for approximating this semantics, which leads to completely automated tools where run-time bugs can be statically and safely classified as un reachable, certain, impossible or potential. We discuss the extension of these techniques to abstract testing where speci fications are provided by the programmers. Abstract testing is compared to program debugging and model-checking.", "num_citations": "23\n", "authors": ["1578"]}
{"title": "Abstracting induction by extrapolation and interpolation\n", "abstract": " We introduce a unified view of induction performed by automatic verification tools to prove a given program specification This unification is done in the abstract interpretation framework using extrapolation (widening/dual-widening) and interpolation (narrowing, dual-narrowing, which are equivalent up to the exchange of the parameters). Dual-narrowing generalizes Craig interpolation in First Order Logic pre-ordered by implication to arbitrary abstract domains. An increasing iterative static analysis using extrapolation of successive iterates by widening followed by a decreasing iterative static analysis using interpolation of successive iterates by narrowing (both bounded by the specification) can be further improved by a increasing iterative static analysis using interpolation of iterates with the specification by dual-narrowing until reaching a fixpoint and checking whether it is inductive for the specification.", "num_citations": "22\n", "authors": ["1578"]}
{"title": "An abstract interpretation framework for refactoring with application to extract methods with contracts\n", "abstract": " Method extraction is a common refactoring feature provided by most modern IDEs. It replaces a user-selected piece of code with a call to an automatically generated method. We address the problem of automatically inferring contracts (precondition, postcondition) for the extracted method. We require the inferred contract:(a) to be valid for the extracted method (validity);(b) to guard the language and programmer assertions in the body of the extracted method by an opportune precondition (safety);(c) to preserve the proof of correctness of the original code when analyzing the new method separately (completeness); and (d) to be the most general possible (generality). These requirements rule out trivial solutions (eg, inlining, projection, etc). We propose two theoretical solutions to the problem. The first one is simple and optimal. It is valid, safe, complete and general but unfortunately not effectively computable (except\u00a0\u2026", "num_citations": "19\n", "authors": ["1578"]}
{"title": "Device and process for the signature, the marking and the authentication of computer programs\n", "abstract": " The product/program and the process according to the invention make it possible to insert into an item of software in source code, in particular Java, watermarks which comply with the semantics of the program and are very difficult to detect. They make it possible to: compute a secret semantic signature of a software or hardware computer program from an infinity of possible secret semantic signatures;\u2014mark a software or hardware computer program by inserting a visible or invisible watermark making it possible to retrieve an authenticator of the original program; retrieve the mark and extract this authenticator from the secret semantic signature of the watermarked software or hardware computer program. The secret semantic signature of the software or hardware computer program to be protected is characteristic of the semantics of said program. The inserted visible or invisible watermark of a software or hardware\u00a0\u2026", "num_citations": "19\n", "authors": ["1578"]}
{"title": "Bi-inductive structural semantics\n", "abstract": " We propose a simple order-theoretic generalization, possibly non-monotone, of set-theoretic inductive definitions. This generalization covers inductive, co-inductive and bi-inductive definitions and is preserved by abstraction. This allows structural operational semantics to describe simultaneously the finite terminating and infinite diverging behaviors of programs. This is illustrated on grammars and the structural bifinitary small big-step trace relational operational semantics of the call-by-value \u03bb-calculus (for which co-induction is shown to be inadequate).", "num_citations": "18\n", "authors": ["1578"]}
{"title": "Logical abstract domains and interpretations\n", "abstract": " We give semantic foundations to abstract domains consisting in first order logic formul\u00e6 in a theory, as used in verification tools or methods using SMT-solvers or theorem provers.We exhibit conditions for a sound usage of such methods with respect to multi-interpreted semantics and extend their usage to automatic invariant generation by abstract interpretation.", "num_citations": "17\n", "authors": ["1578"]}
{"title": "Grammar analysis and parsing by abstract interpretation\n", "abstract": " We study abstract interpretations of a fixpoint protoderivation semantics defining the maximal derivations of a transitional semantics of context-free grammars akin to pushdown automata. The result is a hierarchy of bottom-up or top-down semantics refining the classical equational and derivational language semantics and including Knuth grammar problem, classical grammar flow analysis algorithms, and parsing algorithms.", "num_citations": "17\n", "authors": ["1578"]}
{"title": "A language independent proof of the soundness and completeness of generalized Hoare logic\n", "abstract": " Generalized Hoare logic (GHL) is a formal logical system for proving invariance properties of programs. It was first introduced by Lamport to reason about simple concurrent programs with shared variables. It was generalized by Lamport and Schneider who noticed that the inference rules for each language construct (enabling invariance properties of statements to be derived from invariance properties of their components) can be viewed as special cases of simple logical meta-rules. We give a rigorous definition of GHL, based upon an abstract formal-ization of the syntax and semantics of programs so as to provide an interpretation for formulas of GHL which is independent of the specific instructions of the programming language used. We prove that the proof system of GHL is sound and relatively complete under hypotheses, which we formulate independently of any programming language; these are simple\u00a0\u2026", "num_citations": "17\n", "authors": ["1578"]}
{"title": "A binary decision tree abstract domain functor\n", "abstract": " We present an abstract domain functor whose elements are binary decision trees. It is parameterized by decision nodes which are a set of boolean tests appearing in the programs and by a numerical or symbolic abstract domain whose elements are the leaves. We first define the branch condition path abstraction which forms the decision nodes of the binary decision trees. It also provides a new prospective on partitioning the trace semantics of programs as well as separating properties in the leaves. We then discuss our binary decision tree abstract domain functor by giving algorithms for inclusion test, meet and join, transfer functions and extrapolation operators. We think the binary decision tree abstract domain functor may provide a flexible way of adjusting the cost/precision ratio in path-dependent static analysis.", "num_citations": "16\n", "authors": ["1578"]}
{"title": "A Galois connection calculus for abstract interpretation\n", "abstract": " We introduce a Galois connection calculus for language independent specification of abstract interpretations used in programming language semantics, formal verification, and static analysis. This Galois connection calculus and its type system are typed by abstract interpretation.", "num_citations": "16\n", "authors": ["1578"]}
{"title": "Grammar semantics, analysis and parsing by abstract interpretation\n", "abstract": " We study abstract interpretations of a fixpoint protoderivation semantics defining the maximal derivations of a transitional semantics of context-free grammars akin to pushdown automata. The result is a hierarchy of bottom-up or top-down semantics refining the classical equational and derivational language semantics and including Knuth grammar problems, classical grammar flow analysis algorithms and parsing algorithms.", "num_citations": "15\n", "authors": ["1578"]}
{"title": "G om trie du Parall lisme\n", "abstract": " Les mod les introduits pour tenter de combler ce d faut, attribuable au fait qu'une des s mantiques est du vrai parall lisme, l'autre tant une simulation par entrelacements, taient bas s sur une forme ou une autre de CW-complexes (ou de n-cat gories, on y reviendra). De tels objets sont des collages de formes l mentaires le long de leurs bords. L'explication qui suit est inspir e de ma th se.Consid rons d'abord les syst mes de transition. Ils permettent de mod liser le parall lisme avec une s mantique par entrelacement. Ce sont dj des objets g om triques, mais peu reconnus en tant que tels. Leur repr sentation sous forme de graphe2, permet d'y reconna tre les branchements et les con uences, les cycles, les tats initiaux et naux, ainsi que les tats inatteignables. Toutes ces notions g om triques sont d'importance; en particulier les branchements pour les quivalences s mantiques (branchingtime), et les points morts et tats inatteignables pour l'analyse statique (par exemple le modelchecking).", "num_citations": "15\n", "authors": ["1578"]}
{"title": "Relational abstract interpretation of higher order functional programs\n", "abstract": " Most applications of the abstract interpretation framework [2] have been for analyzing functional programs use functions on abstract values to approximate functions, thus assuming that functions may be called at all arguments. When the abstract domain is finite, this approach can easily be generalized to higher order functional languages as shown for example by [1]. In practice this leads to combinatorial explosion problems as observed, for example, in strictness analysis of higher order functional languages.", "num_citations": "15\n", "authors": ["1578"]}
{"title": "A la Floyd\u2019induction principles for proving inevitability properties of programs\n", "abstract": " Abstracting from Floyd's [6] invariant assertions and well-ordered set method for proving total correctness of sequential programs, we present induction principles for proving inevitability properties of transition systems. These induction principles are shown to be sound, semantically complete and equivalent. This formalizes Floyd's method independently of any particular programming and assertion language and generalizes it to non-deterministic transition systems (in particular partitioned ones) hence to parallel programs. Considering various classes of bounded nondeterminacy we characterize the corresponding well-founded relations which are necessary and sufficient for completeness. When the behavior of the transition system is specified by a non-closed set of execution traces (eg fair parallelism) Floyd's computational induction method cannot be applied without using auxiliary variables. One approach consists in using Floyd's method for an auxiliary transition relation on states and history variables that exactly generates the original set of traces. Another approach consists in a generalization of the use of loop cutpoints in Floyd's method, in that the choice of the cutpoints (where some termination function has to be decreased) may depend upon computation histories cumulated into auxiliary variables.", "num_citations": "15\n", "authors": ["1578"]}
{"title": "Program analysis is harder than verification: A computability perspective\n", "abstract": " We study from a computability perspective static program analysis, namely detecting sound program assertions, and verification, namely sound checking of program assertions. We first design a general computability model for domains of program assertions and corresponding program analysers and verifiers. Next, we formalize and prove an instantiation of Rice\u2019s theorem for static program analysis and verification. Then, within this general model, we provide and show a precise statement of the popular belief that program analysis is a harder problem than program verification: we prove that for finite domains of program assertions, program analysis and verification are equivalent problems, while for infinite domains, program analysis is strictly harder than verification.", "num_citations": "14\n", "authors": ["1578"]}
{"title": "Abstract interpretation of algebraic polynomial systems\n", "abstract": " We define a hierarchy of compositional formal semantics of algebraic polynomial systems over F-algebras by abstract interpretation. This generalizes classical formal language theoretical results and contextfree grammar flow-analysis algorithms in the same uniform framework of universal algebra and abstract interpretation.", "num_citations": "14\n", "authors": ["1578"]}
{"title": "A\u00b2I: abstract\u00b2 interpretation\n", "abstract": " The fundamental idea of Abstract2 Interpretation (A2I), also called meta-abstract interpretation, is to apply abstract interpretation to abstract interpretation-based static program analyses. A2I is generally meant to use abstract interpretation to analyse properties of program analysers. A2I can be either offline or online. Offline A2I is performed either before the program analysis, such as variable packing used by the Astr\u00e9e program analyser, or after the program analysis, such as in alarm diagnosis. Online A2I is performed during the program analysis, such as Venet\u2019s cofibred domains or Halbwachs et al.\u2019s and Singh et al.\u2019s variable partitioning techniques for fast polyhedra/numerical abstract domains. We formalize offline and online meta-abstract interpretation and illustrate this notion with the design of widenings and the decomposition of relational abstract domains to speed-up program analyses. This shows how\u00a0\u2026", "num_citations": "13\n", "authors": ["1578"]}
{"title": "\u201cA la Burstall\u201d intermittent assertions induction principles for proving inevitability properties of programs\n", "abstract": " We formalize Burstall's (1974) intermittent assertions method (initially conceived for proving total correctness of sequential programs) and generalize it to handle inevitability proofs for nondeterministic transition systems, hence (in particular) parallel programs.Programs are modeled by transition systems, program executions by sets of complete traces and program properties by inevitability properties of transition systems (generalizing total correctness of programs). It follows that the study is independent of any particular programming language.The basic proof principle that we derive from Burstall's and Manna and Waldinger's (1978) description of the intermittent assetions method is shown to be sound. It is also semantically complete under a condition on execution traces and inevitable properties. This condition is satisfied when considering inevitability properties such as total correctness or properties involving\u00a0\u2026", "num_citations": "13\n", "authors": ["1578"]}
{"title": "Sometime= always+ recursion\u2261 always on the equivalence of the intermittent and invariant assertions methods for proving inevitability properties of programs\n", "abstract": " We propose and compare two induction principles called \u201calways\u201d and \u201csometime\u201d for proving inevitability properties of programs. They are respective formalizations and generalizations of Floyd invariant assertions and Burstall intermittent assertions methods for proving total correctness of sequential programs whose methodological advantages or disadvantages have been discussed in a number of previous papers. Both principles are formalized in the abstract setting of arbitrary nondeterministic transition systems and illustrated by appropriate examples. The \u201csometime\u201d method is interpreted as a recursive application of the \u201calways\u201d method. Hence \u201calways\u201d can be considered as a special case of \u201csometime\u201d. These proof methods are strongly equivalent in the sense that a proof by one induction principle can be rewritten into a proof by the other one. The first two theorems of the paper show that an\u00a0\u2026", "num_citations": "13\n", "authors": ["1578"]}
{"title": "Static verification of dynamic type properties of variables\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "12\n", "authors": ["1578"]}
{"title": "Object detection based on co-occurrence gmulbp features\n", "abstract": " Image co-occurrence has shown great powers on object classification because it captures the characteristic of individual features and spatial relationship between them simultaneously. For example, Co-occurrence Histogram of Oriented Gradients (CoHOG) has achieved great success on human detection task. However, the gradient orientation in CoHOG is sensitive to noise. In addition, CoHOG does not take gradient magnitude into account which is a key component to reinforce the feature detection. In this paper, we propose a new LBP feature detector based image co-occurrence. Building on uniform Local Binary Patterns, the new feature detector detects Co-occurrence Orientation through Gradient Magnitude calculation. It is known as CoGMuLBP. An extension version of the GoGMuLBP is also presented. The experimental results on the UIUC car data set show that the proposed features outperform state-of-the\u00a0\u2026", "num_citations": "11\n", "authors": ["1578"]}
{"title": "Abstract interpretation based static analysis parameterized by semantics\n", "abstract": " We review how the dependence upon semantics has been taken into account in abstract interpretation based program analysis and next propose to design general purpose abstract interpreters taking semantics as a parameter, either that of the program to be analyzed or that of a programming language.", "num_citations": "11\n", "authors": ["1578"]}
{"title": "D\u00e9monstration automatique en logique classique: complexit\u00e9 et m\u00e9thodes\n", "abstract": " Nous nous interessons a decouvrir de nouvelles methodes, plus efficaces, que celles connues a l'heure actuelle, de recherche de preuves dans les logiques classiques, principalement au premier ordre. Le fondement de notre approche est une etude en termes de classes de complexite de la recherche de preuves a ressources bornees. L'existence d'une preuve in abstracto est indecidable, mais nous nous interessons aux preuves evidentes a l'aune humaine. Dans ce but, nous approchons la notion d'evidence par diverses mesures de difficulte de theoremes, et analysons la complexite de la recherche de preuves simples pour ces mesures. Ces resultats nous guident ensuite dans la recherche de nouvelles methodes de preuves. Nous presentons une methode pour la logique classique du premier ordre, fondee sur une structure de bdd (binary decision diagram) et l'application d'un principe de controle de l'information (au sens de shannon) dans les algorithmes branchants. Nous generalisons ensuite la methode a l'integration de la relation d'egalite (dans le style de gallier et al.) et au traitement de l'ordre superieur (dans le style de dougherty et johann)", "num_citations": "11\n", "authors": ["1578"]}
{"title": "Abstract interpretation: Theory and practice\n", "abstract": " Our objective in this talk is to give an intuitive account of abstract interpretation theory [1][2][3][4][5] and to present and discuss its main applications [6]. Abstract interpretation theory formalizes the conservative approximation of the semantics of hardware or software computer systems. The semantics provides a formal model describing all possible behaviors of a computer system in interaction with any possible environment. By approximation we mean the observation of the semantics at some level of abstraction, ignoring irrelevant details. Conservative means that the approximation can never lead to an erroneous conclusion.               Abstract interpretation theory provides thinking tools since the idea of abstraction by conservative approximation is central to reasoning (in particular on computer systems) and mechanical tools since the idea of an effectively computable approximation leads to a systematic and\u00a0\u2026", "num_citations": "10\n", "authors": ["1578"]}
{"title": "The role of abstract interpretation in formal methods\n", "abstract": " In computer science and software engineering, formal methods are mathematically-based techniques for the specification, development and verification of software and hardware systems. They therefore establish the satisfaction of a specification by a system semantics. Abstract interpretation is a theory of sound approximation of mathematical structures, in particular those involved in the description of the behavior of computer systems. It allows the systematic derivation of sound methods and algorithms for approximating undecidable or highly complex problems in various areas of computer science (semantics, verification and proof, model- checking, static analysis, program transformation and optimization, typing, software steganography, etc.). Its main current application is on the safety and security of complex hardware and software computer systems.", "num_citations": "9\n", "authors": ["1578"]}
{"title": "Syntax and analytic semantics of LISA\n", "abstract": " We provide the syntax and semantics of the LISA (for \"Litmus Instruction Set Architecture\") language. The parallel assembly language LISA is implemented in the herd7 tool (http://virginia.cs.ucl.ac.uk/herd/) for simulating weak consistency models.", "num_citations": "8\n", "authors": ["1578"]}
{"title": "Contract precondition inference from intermittent assertions on collections\n", "abstract": " In the context of design by contracts, programmers often insert assertions in their code to be optionally checked at runtime, at least during the debugging phase. These assertions would better be given as a precondition of the method-/procedure (eg for separate static analysis). We define precisely and formally the contract inference problem from intermittent assertions inserted in the code by the programmer. Our definition excludes no good run even when a non-deterministic choice (eg an interactive input) could lead to a bad one. We then introduce new abstract interpretation-based methods to automatically infer both the static contract precondition of a method/procedure and the code to check it at runtime on scalar and collection variables.", "num_citations": "8\n", "authors": ["1578"]}
{"title": "Abstract interpretation of resolution-based semantics\n", "abstract": " We extend the abstract interpretation point of view on context-free grammars by Cousot and Cousot to resolution-based logic programs and proof systems. Starting from a transition-based small-step operational semantics of Prolog programs (akin to the Warren Machine), we consider maximal finite derivations for the transition system from most general goals. This semantics is abstracted by instantiation to terms and furthermore to ground terms, following the so-called c- and s-semantics approach. Orthogonally, these sets of derivations can be abstracted to SLD-trees, call patterns and models, as well as interpreters providing effective implementations (such as Prolog). These semantics can be presented in bottom\u2013up fixpoint form. This abstract interpretation-based construction leads to classical bottom\u2013up semantics (such as the s-semantics of computed answers, the c-semantics of correct answers of Keith Clark\u00a0\u2026", "num_citations": "8\n", "authors": ["1578"]}
{"title": "Introduction to abstract interpretation\n", "abstract": " Abstract interpretation is a theory of semantics approximation which is used for the construction of semantics-based program analysis algorithms (sometimes called \u201cdata flow analysis\u201d), the comparison of formal semantics (eg, construction of a denotational semantics from an operational one), the design of proof methods, etc.Automatic program analysers are used for determining statically conservative approximations of dynamic properties of programs. Such properties of the run-time behavior of programs are useful for debugging (eg, type inference), code optimization (eg, compile-time garbage collection, useless occurcheck elimination), program transformation (eg, partial evaluation, parallelization), and even program correctness proofs (eg, termination proof).", "num_citations": "6\n", "authors": ["1578"]}
{"title": "Parallel combination of abstract interpretation and model-based automatic analysis of software\n", "abstract": " Formal methods combining abstract interpretation and modelchecking have been considered for automated analysis of software.", "num_citations": "6\n", "authors": ["1578"]}
{"title": "Abstract semantic dependency\n", "abstract": " Dependency is a prevalent notion in computer science. There have been numerous informal or formal attempts to define viable syntactic and semantic concepts of dependency in programming languages with subtle variations and limitations. We develop a new value dependency analysis defined by abstract interpretation of a trace semantics. A sound approximate dependency algorithm is formally derived by calculational design. Further abstractions provide information flow, slicing, non-interference, dye, and taint analyses.", "num_citations": "5\n", "authors": ["1578"]}
{"title": "Avionic Software Verification by Abstract Interpretation.\n", "abstract": " A flight control surface actuation system in avionics is safety critical and complex since it is placed between the pilot\u2019s controls (sidesticks, rudder pedals) and the control surfaces of the aircraft, whose movement it controls and monitors. For reliability and dependability, several redundant software and computers are used but each one must be proved to be correct. With the exponential increase of the power of computers, the flight control software has become much more powerful hence complex. Since the cost of tests increasing more rapidly that the size of programs, formal methods become an attractive complement for program verification. The difficulties with formal methods are that they need a formal specification, a formal semantics of the programming language and, because of undecidability, have serious limits in the automatic verification that the program semantics satisfies the specification. A theorem prover needs human assistance while model-checking requires finite models which, but for hardware, are generally incomplete. Static analysis offers an interesting completely automatic alternative in that the specification can be chosen to be implicit. For example the absence of runtime error will not require the user to define a complex specification. Moreover static analysis considers infinite models of computations that can be directly computed from the program text so that the end-user does not need to provide a (finite) model of the program computations and environment. Finally, the reachable states during any program computation are computed approximately through an overapproximation that omits no possible case. So the delicate\u00a0\u2026", "num_citations": "5\n", "authors": ["1578"]}
{"title": "A Case Study in Abstract Interpretation Based Program Transformation: Blocking Command Elimination.\n", "abstract": " We illustrate the design of correct semantics-based program transformations by abstract interpretation on blocking code elimination.", "num_citations": "5\n", "authors": ["1578"]}
{"title": "Design of semantics by abstract interpretation\n", "abstract": " \u2022 Such analyzers can be used to statically and fully automatically de termine run-time properties of programs;\u2022 Such run-time information can be used in complement to classical pro gram provers, model-checkers,\u2026 for program verification (abstract debugging,\u2026) and transformation (compiler optimization, partial evaluation, parallelization,\u2026);", "num_citations": "5\n", "authors": ["1578"]}
{"title": "The abstract interpretation perspective\n", "abstract": " Semantic analysis (of programs, systems, etc.) should become a mature discipline to be included in educational curricula in computer science; This requires the discipline to evolve from an illassorted collection of methods and algorithms to a large scope formal reasoning and design methodology; In particular, program analysis methods should be explained in language, program encoding, semantics, property, property encoding, and approximation independent way, to be of very broad scope and wide usefulness;", "num_citations": "5\n", "authors": ["1578"]}
{"title": "Constructing program invariance proof methods\n", "abstract": " Constructing program invariance proof methods \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Search by expertise, name or affiliation Constructing program invariance proof methods Patrick Cousot, Radhia Cousot Computer Science Research output: Chapter in Book/Report/Conference proceeding \u203a Conference contribution Overview Original language English (US) Title of host publication International Workshop on Program Construction, Chateau de Bonas, France, Castera-Verduzan, France, September 8-12, 1980 Pages 8-12 Volume 13 State Published - 1980 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P., & Cousot, R. (1980). Constructing program invariance proof methods. In International Workshop on Program Construction, Chateau de Bonas, France, Castera-Verduzan\u2026", "num_citations": "5\n", "authors": ["1578"]}
{"title": "Responsibility analysis by abstract interpretation\n", "abstract": " Given a behavior of interest in the program, statically determining the corresponding responsible entity is a task of critical importance, especially in program security. Classical static analysis techniques (e.g. dependency analysis, taint analysis, slicing, etc.) assist programmers in narrowing down the scope of responsibility, but none of them can explicitly identify the responsible entity. Meanwhile, the causality analysis is generally not pertinent for analyzing programs, and the structural equations model (SEM) of actual causality misses some information inherent in programs, making its analysis on programs imprecise. In this paper, a novel definition of responsibility based on the abstraction of event trace semantics is proposed, which can be applied in program security and other scientific fields. Briefly speaking, an entity  is responsible for behavior , if and only if  is free to choose its input value, and such\u00a0\u2026", "num_citations": "4\n", "authors": ["1578"]}
{"title": "Bi-inductive structural semantics\n", "abstract": " We propose a simple order-theoretic generalization of set-theoretic inductive definitions. This generalization covers inductive, co-inductive and bi-inductive definitions and is preserved by abstraction. This allows the structural operational semantics to describe simultaneously the finite/terminating and infinite/diverging behaviors of programs. This is illustrated on the structural bifinitary small/big-step trace/relational/operational semantics of the call-by-value \u03bb-calculus.", "num_citations": "4\n", "authors": ["1578"]}
{"title": "Design of syntactic program transformations by abstract interpretation of semantic transformations\n", "abstract": " Design of Syntactic Program Transformations by Abstract Interpretation of Semantic Transformations Page 1 Design of Syntactic Program Transformations by Abstract Interpretation of Semantic Transformations Patrick COUSOT \u00c9cole Normale Sup\u00e9rieure 45 rue d\u2019Ulm, 75230 Paris cedex 05, France Patrick.Cousot@ens.fr www.di.ens.fr/ cousot ICLP\u201901, AO , KY PO Nov 26 \u2013 Dec 1, 2001 \u25a0 \u25c0 \u25b6 \u00a3 Page 2 Content 1. A short introduction to abstract interpretation (in the con text of program static analysis) . . . . . . . . . . . . . . . . . . . . . . . 2. A new application of abstract interpretation: program trans formation .......................................... 3.Conclusion ......................................... This work was supported in part by the RTD project IST-1999-20527 Daedalus of the european IST FP5 programme. ICLP\u201901, AO , KY PO , Nov 26 \u2013 Dec 1, 2001 \u25c0\u00a1\u00a1\u00a1 \u2014 1 \u2014 [] \u25a0 \u2014 \u00a3\u00a3\u00a3\u25b6 \u00a9 P. Cousot Page 3 A Short Introduction to Abstract Interpretation ICLP\u201901, \u2026", "num_citations": "4\n", "authors": ["1578"]}
{"title": "Calculational design of semantics and static analyzers by abstract interpretation\n", "abstract": " The five 45mn lectures are conceived as an elementary introduction to abstract interpretation [9, 11]. Taking a pragmatic point of view, we formally design and implement a static analyzer for a simple imperative programming language by abstract interpretation of an operational semantics.", "num_citations": "4\n", "authors": ["1578"]}
{"title": "On Fixpoint/Iteration/Variant Induction Principles for Proving Total Correctness of Programs with Denotational Semantics.\n", "abstract": " We study partial and total correctness proof methods based on generalized fixpoint/iteration/variant induction principles applied to the denotational semantics of firstorder functional and iterative programs.", "num_citations": "3\n", "authors": ["1578"]}
{"title": "Directions for research in approximate system analysis\n", "abstract": " Program analysis is mainly concerned with the design of program analyzers to automatically determine semantic properties of programs written in some programming language. Such analyzers take programs as input and output some useful information about their runtime behavior. This information is useful for optimizing compilers [15], partial evaluators [11], abstract debuggers [1], models-checkers [2], formal verifiers [13], etc. The difficulty of the task comes from the fact that programs are infinite states so that all interesting questions about program executions are undecidable. Hence the automatically produced information, although sound, must be incomplete.With the appearance of new computing paradigms, the scope of program analysis has been constantly broadening these last two decades. The term \u201cprogram static analysis\u201d is therefore too restricted since the analysis problem appears as soon as one\u00a0\u2026", "num_citations": "3\n", "authors": ["1578"]}
{"title": "Typage par interpr\u00e9tation abstraite\n", "abstract": " L'interpr\u00e9tation abstraite et l'inf\u00e9rence de types sont deux m\u00e9thodes formelles permettant d'obtenir de mani\u00e8re statique (i. E. \u00e0 la compilation) et automatique une description approch\u00e9e du comportement dynamique (i. E. De l'ex\u00e9cution) d'un programme. Ces deux m\u00e9thodes sont g\u00e9n\u00e9ralement pr\u00e9sent\u00e9es comme concurrentes voir m\u00eame incompatibles. Dans cet ouvrage, notre objectif a \u00e9t\u00e9 tout d'abord de d\u00e9velopper une approche g\u00e9n\u00e9rique permettant de d\u00e9finir un syst\u00e8me de types en utilisant les techniques d'interpr\u00e9tation abstraite. Le r\u00e9sultat auquel nous sommes parvenus met ainsi fin \u00e0 la pol\u00e9mique entre les tenants des techniques d'interpr\u00e9tation abstraite et ceux de l'inf\u00e9rence de types et ouvrent de nouveaux horizons pour aux techniques d'inf\u00e9rences. Il est d\u00e9sormais possible de combiner les techniques propres aux syst\u00e8mes d'inf\u00e9rences de types et les techniques d'interpr\u00e9tation abstraite afin d'am\u00e9liorer les syst\u00e8mes de types existant, de d\u00e9velopper de nouveaux syst\u00e8mes de types. En r\u00e9sum\u00e9, notre objectif a \u00e9t\u00e9 tout d'abord de d\u00e9velopper dans cet ouvrage une approche g\u00e9n\u00e9rique permettant de d\u00e9finir un syst\u00e8me de types en utilisant les techniques de l'interpr\u00e9tation abstraite, tout en exhibant les similitudes des syst\u00e8mes obtenus avec les syst\u00e8mes de types d\u00e9finis de mani\u00e8re classique. Ce formalisme une fois d\u00e9fini, nous illustrons comment utiliser les techniques sp\u00e9cifiques de l'interpr\u00e9tation abstraite afin d'am\u00e9liorer de fa\u00e7on significative les syst\u00e8mes de types classiques. Enfin, dans une derni\u00e8re partie, nous d\u00e9finissons de nouveaux syst\u00e8mes moins intuitifs permettant des typages bien plus pr\u00e9cis que ceux disponibles dans la\u00a0\u2026", "num_citations": "3\n", "authors": ["1578"]}
{"title": "Calculational design of a regular model checker by abstract interpretation\n", "abstract": " Security monitors have been used to check for safety program properties at runtime, that is for any given execution trace. Such security monitors check a safety temporal property specified by a finite automaton or, equivalently, a regular expression. Checking this safety temporal specification for all possible execution traces, that is the program semantics, is a static analysis problem, more precisely a model checking problem, since model checking specializes in temporal properties. We show that the model checker can be formally designed by calculus, by abstract interpretation of a formal trace semantics of the programming language. The result is a structural sound and complete model checker, which proceeds by induction on the program syntax (as opposed to the more classical approach using computation steps formalized by a transition system). By Rice theorem, further hypotheses or abstractions are needed to\u00a0\u2026", "num_citations": "2\n", "authors": ["1578"]}
{"title": "Syntactic and semantic soundness of structural dataflow analysis\n", "abstract": " We show that the classical approach to the soundness of dataflow analysis is with respect to a syntactic path abstraction that may be problematic with respect to a semantics trace-based specification. The fix is a rigorous abstract interpretation based approach to formally construct dataflow analysis algorithms by calculational design.", "num_citations": "2\n", "authors": ["1578"]}
{"title": "Concurrency with Weak Memory Models (Dagstuhl Seminar 16471)\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 16471\" Concurrency with Weak Memory Models: Semantics, Languages, Compilation, Verification, Static Analysis, and Synthesis\". The aim of the seminar was to bring together people from various horizons, including theoreticians and verification practitioners as well as hardware vendors, in order to set up a long-term research program to design formal methods and develop tools ensuring the correctness of concurrent programs on modern multi-processor architectures.", "num_citations": "2\n", "authors": ["1578"]}
{"title": "Syntax and semantics of the cat language\n", "abstract": " The contents of this document are provided in connection with the HSA Foundation specifications. This specification is protected by copyright laws and contains material proprietary to the HSA Foundation. It or any components may not be reproduced, republished, distributed, transmitted, displayed, broadcast or otherwise exploited in any manner without the express prior written permission of HSA Foundation. You may use this specification for implementing the functionality therein, without altering or removing any trademark, copyright or other notice from the specification, but the receipt or possession of this specification does not convey any rights to reproduce, disclose, or distribute its contents, or to manufacture, use, or sell anything that it may describe, in whole or in part.HSA Foundation grants express permission to any current Founder, Promoter, Supporter Contributor, Academic or Associate member of HSA Foundation to copy and redistribute UNMODIFIED versions of this specification in any fashion, provided that NO CHARGE is made for the specification and the latest available update of the specification for any version of the API is used whenever possible. Such distributed specification may be re-formatted AS LONG AS the contents of the specification are not changed in any way. The specification may be incorporated into a product that is sold as long as such product includes significant independent work developed by the seller. A link to the current version of this specification on the HSA Foundation web-site should be included whenever possible with specification distributions.", "num_citations": "2\n", "authors": ["1578"]}
{"title": "Verification by abstract interpretation, soundness and abstract induction\n", "abstract": " Automatic program verification tools have to cope with programming language and machine semantics, undecidability, and mathematical induction, and so are all complex and imperfect. The ins and outs of automatic program verification will be discussed in light of the theory and practice of abstract interpretation [18, 19, 22].", "num_citations": "2\n", "authors": ["1578"]}
{"title": "La v\u00e9rification des programmes par interpr\u00e9tation abstraite\n", "abstract": " fact (12) 479001600 479001600 fact (13) 1932053504215430144 fact (14) 1278945280868538368 fact (15) 2004310016143173632 fact (16) 2004189184143294464 fact (17)288522240288522240 fact (18)898433024898433024 fact (19) 109641728 109641728 fact (20)2102132736 45350912 fact (21)1195114496 952369152 fact (22)522715136522715136 fact (23) 862453760 862453760 fact (24)775946240775946240 fact (25) 207618048071303168 fact (26)1853882368 293601280 fact (27) 1484783616662700032 fact (28)1375731712 771751936 fact (29)1241513984 905969664 fact (30) 1409286144738197504 fact (31) 738197504 738197504 fact (32)2147483648 0 fact (33)2147483648 0 fact (34) 0 0", "num_citations": "2\n", "authors": ["1578"]}
{"title": "Forward relational infinitary static analysis\n", "abstract": " \u2013It is the most abstract/less precise analysis which is more precise than the component analyzes (since it is the smallest Moore family containing all abstract properties of the various components)\u2013The study of the lub of closure operators yields effective methods to approximate this ideal\u2013page\u2013 Course 16.399:\u201cAbstract interpretation\u201d, Tuesday May 10th, 2005\u20145\u2014 \u013e P. Cousot, 2005", "num_citations": "2\n", "authors": ["1578"]}
{"title": "Proceedings of the 8th International Symposium on Static Analysis\n", "abstract": " Proceedings of the 8th International Symposium on Static Analysis | Guide Proceedings ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsSAS '01 ABSTRACT No abstract available. Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this Publication Information Contributors Published in Guide Proceedings cover image SAS '01: Proceedings of the 8th International Symposium on Static Analysis July 2001 436 pages ISBN:3540423141 Editor: Patrick Cousot Copyright \u00a9 2001 Publisher Springer-Verlag Berlin, Heidelberg \u2026", "num_citations": "2\n", "authors": ["1578"]}
{"title": "Algorithmique et programmation en Pascal (cours)(in French)\n", "abstract": " Algorithmique et programmation en Pascal (cours) (in French) \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Algorithmique et programmation en Pascal (cours) (in French) Patrick Cousot Computer Science Research output: Book/Report \u203a Book Overview Original language English (US) Publisher Ellipses Number of pages 288 State Published - 1992 Publication series Name Cours de l'Ecole Polytechnique Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P. (1992). Algorithmique et programmation en Pascal (cours) (in French). (Cours de l'Ecole Polytechnique). Ellipses. Algorithmique et programmation en Pascal (cours) (in French). / Cousot, Patrick. Ellipses, 1992. 288 p. (Cours de l'Ecole Polytechnique). Research output: Book/Report \u203a Book Cousot, P 1992, Algorithmique et \u2026", "num_citations": "2\n", "authors": ["1578"]}
{"title": "The astr\u00e9e static analysis tool\n", "abstract": " Software verification consists in proving that executions of the software in any admissible execution environment all satisfy a formal specification. In the case of the Astr\u00e9e static analyser (www. astree. ens. fr), the specification is implicit: no execution can lead to a \u201cruntime error\u201d(RTE)(such as bufer overrun, dangling pointer, division by zero, float overflow, modular integer arithmetic overflow,...). The Astr\u00e9e static analyser is designed by abstract interpretation of the semantics of a subset of the C programming language (without dynamic memory allocation, recursive function calls, no system and library calls as found in most embedded software). Abstract interpretation is a theory of abstraction, that is to say of safe approximation allowing for automatic formal proofs by considering an over-approximation of the set of all possible executions of the program. Contrary to bug-finding methods (eg by test, bounded model\u00a0\u2026", "num_citations": "1\n", "authors": ["1578"]}
{"title": "The Scientific Work of Reinhard Wilhelm\n", "abstract": " \u00ab The Scientific Work of Reinhard Wilhelm \u00bb Page 1 \u00ab The Scientific Work of Reinhard Wilhelm \u00bb Patrick Cousot \u00c9cole normale sup\u00e9rieure 45 rue d\u2019Ulm, 75230 Paris cedex 05, France o .@ts c u r n i e o r t . s Ck f Pa www.di.ens.fr/~cousot Laudatio f\u00fcr Reinhard Wilhelm \u2014 Saarbr\u00fccken \u2014 June 11th, 2006 \u2014 1 \u2014 Just in case you don\u2019t know him, or arrived late :-) Laudatio f\u00fcr R. Wilhelm, June 11th, 2006 \u2014 2 \u2014 \u013e P. Cousot Page 2 Just in case you don\u2019t know him, or arrived late :-) Laudatio f\u00fcr R. Wilhelm, June 11th, 2006 \u2014 2 \u2014 \u013e P. Cousot Page 3 A talent for organization \u2014 3 \u2014 Scientific Director of the International Conference and Research Center for Computer Science in Schlo\u00df Dagstuhl \u2013 Unique and known by every researcher in computer science in the world \u2013 This achievement only would be the best service for the progress of research in computer science Laudatio f\u00fcr R. Wilhelm, June 11th, 2006 \u2014 4 \u2014 \u013e P. \u2026", "num_citations": "1\n", "authors": ["1578"]}
{"title": "Progress on abstract interpretation based formal methods and future challenges\n", "abstract": " In order to contribute to the software reliability problem, tools have been designed in order to analyze statically the run-time behavior of programs. Because the correctness problem is undecidable, some form of approximation is needed. The whole purpose of abstract interpretation is to formalize this idea of approximation. We illustrate in formally the application of abstraction to the semantics of programming languages as well as to program static analysis. The main point is that in order to reason or compute about a complex system, some information must be lost, that is the observation of executions must be either partial or at a high level of abstraction.In the second part of the paper, we compare program static analysis with deductive methods, model-checking and type inference. Their foun dational ideas are shortly reviewed, and the shortcomings of these four tools are discussed, including when they are combined\u00a0\u2026", "num_citations": "1\n", "authors": ["1578"]}
{"title": "Analyses totales de programmes par Interpr\u00e9tation Abstraite Application au langage C++\n", "abstract": " Cette th\u00e8se porte sur la construction d'analyses traitant l'ensemble des propri\u00e9t\u00e9s d'un programme afin d'avoir une preuve de correction totale de logiciels. Une telle analyse est appel\u00e9e analyse totale par opposition aux analyses partielles telles les analyses de n\u00e9cessit\u00e9, de temps de liaisons, de typage, de propagation des constantes, qui ne s' int\u00e9ressent qu'\u00e0 un seul aspect du programme, aussi complexe soit-il. Les applications principales sont le debugging abstrait et l'optimisation de la compilation. Le debugging abstrait permet de tester un programme sur un jeu de donn\u00e9es, mais \u00e9galement sur des propri\u00e9t\u00e9s, qui ne sont que des ensembles de jeux de donn\u00e9es. Une telle analyse pourrait intervenir d\u00e8s l'\u00e9dition du code soit de mani\u00e8re semi-automatique avec interaction avec le programmeur pour des preuves de correction, soit de mani\u00e8re automatique avec plus de perte de pr\u00e9cision pour l'optimisation du code. Plusieurs applications sont pr\u00e9sent\u00e9es. Une premi\u00e8re application sur s\u00e9mantique d\u00e9notationnelle correspond \u00e0 l'analyse d'un mini langage de type ML avec une s\u00e9mantique paresseuse sur un support fini ou infini. Les propri\u00e9t\u00e9s les plus complexes \u00e0 capturer sont les propri\u00e9t\u00e9s de terminaison totale(pour tous les arguments) qui ne sont vraies qu'\u00e0 la limite en g\u00e9n\u00e9ral pour des fonctions r\u00e9cursives. Le proc\u00e9d\u00e9 de capture s' effectue \u00e0 l'aide d'it\u00e9rations ordinales croissantes(calcul\u00e9es dynamiquement) au lieu d'it\u00e9rations d\u00e9croissantes sur les arguments pour un ordre statique. Les applications sur s\u00e9mantiques op\u00e9rationnelles concernent essentiellement l'analyse totale de programmes imp\u00e9ratifs dans un environnement objet. La\u00a0\u2026", "num_citations": "1\n", "authors": ["1578"]}
{"title": "Analyse s\u00e9mantique relationnelle des indices de tableaux par congruences et trap\u00e9zo\u00efdes rationnels\n", "abstract": " L'analyse s\u00e9mantique des variables num\u00e9riques d'un programme consiste \u00e0 d\u00e9terminer statiquement et automatiquement des propri\u00e9t\u00e9s v\u00e9rifi\u00e9es par celles-ci \u00e0 l'ex\u00e9cution. Diff\u00e9rentes classes de propri\u00e9t\u00e9s (relations d'\u00e9galit\u00e9, d'in\u00e9galit\u00e9, de congruence) ont \u00e9t\u00e9 \u00e9tudi\u00e9es. Cette th\u00e8se propose la g\u00e9n\u00e9ralisation d'une partie des mod\u00e8les pr\u00e9c\u00e9dents. Plus particuli\u00e8rement, en utilisant le cadre formel fourni par l'interpr\u00e9tation abstraite, nous proposons, d'une part, un ensemble de propri\u00e9t\u00e9s g\u00e9n\u00e9ralisant les intervalles et les classes de congruences enti\u00e8res et, d'autre part, une g\u00e9n\u00e9ralisation des trap\u00e9zo\u00efdes et des syst\u00e8mes d'\u00e9quation lin\u00e9aires de congruence enti\u00e8res relationnelles. La d\u00e9finition d'une abstraction rationnelle de ces diff\u00e9rentes propri\u00e9t\u00e9s permet d'obtenir des approximations, dont la complexit\u00e9 reste polynomiale en le nombre de variables consid\u00e9r\u00e9es, des op\u00e9rateurs sur les propri\u00e9t\u00e9s enti\u00e8res.", "num_citations": "1\n", "authors": ["1578"]}
{"title": "Principe des methodes de preuve de proprietes d'invariance et de fatalite des programmes paralleles (in French)\n", "abstract": " Principe des methodes de preuve de proprietes d'invariance et de fatalite des programmes paralleles (in French) \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Search by expertise, name or affiliation Principe des methodes de preuve de proprietes d'invariance et de fatalite des programmes paralleles (in French) Patrick Cousot, Radhia Cousot Computer Science Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter (peer-reviewed) \u203a peer-review Overview Original language English (US) Title of host publication Parallelisme, communication et synchronisation Editors J.-P. Verjus, G. Roucairol Publisher Editions du CNRS Pages 129-149 State Published - 1985 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P., & Cousot, R. (1985). Principe des methodes de \u2026", "num_citations": "1\n", "authors": ["1578"]}
{"title": "An Introduction to a Mathematical Theory of Global Program Analysis\n", "abstract": " PerForming compile-time optimi zaLion of nrograns tAlo & Ullnan I lZ1, Srarrquat-t et a1. Iuo], tr-rcke & schwai'tz [69], Hecfrtl-751, Schaefer [73T, ldu1f et af. IZS] I involves an cnalyszs of the progz, ctrn (the determination and co1-lectlr: nr: f inf r: rmatlor'which is distribitted throughout the nrogran I LJ] lman t75l) I followed by a transformation of the pylogram Ithe application of those progran transfornabion rules which according Lo the previo-ts analysis can oe shown to leao to an equivaient but impr-oved translorned progran).", "num_citations": "1\n", "authors": ["1578"]}
{"title": "Thesis: These de docteur-ingenieur:: Definition interpretative et implantation de langages de programmation (in French)\n", "abstract": " Thesis: These de docteur-ingenieur: Definition interpretative et implantation de langages de programmation (in French) \u2014 NYU Scholars Skip to main navigation Skip to search Skip to main content NYU Scholars Logo Help & FAQ Home Profiles Research Units Research Output Thesis: These de docteur-ingenieur: Definition interpretative et implantation de langages de programmation (in French) Patrick Cousot Computer Science Research output: Book/Report \u203a Other report Overview Original language English (US) Place of Publication Grenoble, France Publisher Universite scientifique et medicale de Grenoble State Published - Dec 14 1974 Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Cousot, P. (1974). Thesis: These de docteur-ingenieur: Definition interpretative et implantation de langages de programmation (in French). Universite scientifique et medicale de Grenoble. Thesis: These de docteur-\u2026", "num_citations": "1\n", "authors": ["1578"]}
{"title": "UN ANALYSEUR SYNTAXIQUE POUR GRAMMAIRES HORS CONTEXTE ASCENDANT SELECTIF ET GENERAL\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "1\n", "authors": ["1578"]}