{"title": "Temporal logic for scenario-based specifications\n", "abstract": " We provide semantics for the powerful scenario-based language of live sequence charts (LSCs). We show how the semantics of live sequence charts can be captured using temporal logic. This is done by studying various subsets of the LSC language and providing an explicit translation into temporal logic. We show how a kernel subset of the LSC language (which omits variables, for example) can be embedded within the temporal logic CTL*. For this kernel subset the embedding is a strict inclusion. We show that existential charts can be expressed using the branching temporal logic CTL while universal charts are in the intersection of linear temporal logic and branching temporal logic LTL \u2229 CTL. Since our translations are efficient, the work described here may be used in the development of tools for analyzing and executing scenario-based requirements and for verifying systems against such requirements.", "num_citations": "132\n", "authors": ["1812"]}
{"title": "Embedded tutorial: Formal equivalence checking between system-level models and RTL\n", "abstract": " A rigorous system-level model (SLM) for a hardware design project is extremely important, often critical. Such a functional model not only defines the architect's ideas but also builds a precise foundation for both hardware designers and verification engineers. The key uses of SLMs are: architecture validation; performance modeling and architectural trade-off; platforms for software development and verification; and functional reference model. In this tutorial, we discuss how to formally verify sequential equivalence between SLMs and RTL, for both timed and untimed models. First, we provide a formal definition of the sequential equivalence. Then we discuss various formal verification technology that enables such practice in real designs.", "num_citations": "32\n", "authors": ["1812"]}
{"title": "Executable protocol specification in ESL\n", "abstract": " Hardware specifications in English are frequently ambiguous and often self-contradictory.We propose a new logic ESL which facilitates formal specification of hardware protocols.Our logic is closely related to LTL but can express all regular safety properties. We have developed a protocol synthesis methodology which generates Mealy machines from ESL specifications. The Mealy machines can be automatically translated into executable code either in Verilog or SMV. Our methodology exploits the observation that protocols are naturally composed of many semantically distinct components. This structure is reflected in the syntax of ESL specifications.We use a modified LTL tableau construction to build a Mealy machine for each component. The Mealy machines are connected together in a Verilog or SMV framework. In many cases this makes it possible to circumvent the state explosion problem during code\u00a0\u2026", "num_citations": "26\n", "authors": ["1812"]}
{"title": "Efficient variable ordering using aBDD based sampling\n", "abstract": " Variable ordering for BDDs has been extensively investigated. Recently, sampling based ordering techniques have been proposed to overcome problems with structure based static ordering methods and sifting based dynamic reordering techniques. However, existing sampling techniques can lead to an unacceptably large deviation in the size of the final BDD. In this paper, we propose a new sampling technique based on abstract BDDs (aBDDs) that does not suffer from this problem. This new technique, easy to implement and automate, consistently creates high quality variable orderings for both combinational as well as sequential functions. Experimental results show that for many applications our approach is significantly superior to existing techniques.", "num_citations": "21\n", "authors": ["1812"]}
{"title": "OBDD variable ordering using sampling based schemes\n", "abstract": " A system and method for determining variable orders for decision diagrams. The variable orders are determined by sampling subspaces of a Boolean space representing a function or circuit. The subspaces are formed in a variety of ways, including through the use of abstraction, decomposition, partial assignments, and circuit subspaces.", "num_citations": "20\n", "authors": ["1812"]}
{"title": "Automatic abstraction in model checking\n", "abstract": " As technology advances and demand for higher performance increases hardware designs are becoming more and more sophisticated. A typical chip design may contain over ten million switching devices. Since the systems become more and more complex, detecting design errors for systems of such scale becomes extremely difficult. Formal verification methodologies can potentially catch subtle design errors. However, many state-of-the-art formal verification tools suffer from the state explosion problem.", "num_citations": "19\n", "authors": ["1812"]}
{"title": "Design verification using formal techniques\n", "abstract": " Formal techniques are applied to industrial design problems such as verification of a circuit design. Initial decisions may include defining properties to verify the design. An abstraction of the design may be generated and model checking applied to the abstraction. Results obtained using these techniques may be extended by performance analysis and/or verification of sequential operations.", "num_citations": "17\n", "authors": ["1812"]}
{"title": "Synchronization of large sequential circuits by partial reset\n", "abstract": " In this paper, we present a technique to synchronize large synchronous sequential circuits, which uses partial reset to break feedback loops in the circuits such that they become synchronizable. The method also provides a synchronizing sequence. Experimental results for ISCAS'89 benchmark circuits are presented, including the largest circuits, which were not synchronized previously.", "num_citations": "16\n", "authors": ["1812"]}
{"title": "A semi-formal verification methodology\n", "abstract": " Formal verification techniques attract great attention from industry because of their ability to discover subtle design errors where simulation fails. However, due to the state explosion problem, formal techniques usually cannot handle large designs. This paper introduces a semi-formal verification methodology in which formal techniques and simulation are tightly coupled. In this methodology, we apply formal techniques to verify a few \"difficult\" block level designs. The verified properties and valid traces are carried over in the random simulation based system level validation. These properties and legal traces not only can discover new design errors but also help to define the \"thoroughness\" of the system level validation. The block level formal verification usually requires human abstraction and environment modeling. Due to human mistakes, it is possible that system level validation violates a property while the formal\u00a0\u2026", "num_citations": "15\n", "authors": ["1812"]}
{"title": "Analysis of composition complexity and how to obtain smaller canonical graphs\n", "abstract": " We discuss an open problem in construction of Reduced Ordered Binary Decision Diagrams (ROBDDs) using composition, and prove that the worst case complexity of the construction is truly cubic. With this insight we show that the process of composition naturally leads to the construction of (even exponentially) compact partitioned-OBDDs (POBDDs)[12]. Our algorithm which incorporates dynamic partitioning, leads to the most general (and compact) form of POBDDs-graphs with multiple root variables. To show that our algorithm is robust and practical, we have analyzed some well known problems in Boolean function representation, verification and finite state machine analysis where our approach generates graphs which are even orders of magnitude smaller.", "num_citations": "10\n", "authors": ["1812"]}
{"title": "Systems and methods for generating predicates and assertions\n", "abstract": " Systems and methods for deriving a predicate by constructing a logic formula from information recorded during test execution, optimizing the logic formula and computing the logical implication of the optimized logic formula. Systems and methods for deriving an assertion from a logical implication by substituting each predicate in the logical implication with corresponding design elements from a hardware design description, inserting the design elements into a target template, inserting a context-sensitive input of the target template based on design elements in the hardware design description and creating an instance name for an instantiation of the target template. Systems and methods for generating a set of clauses that are implied by a disjunctive normal formula of a set of cubes.", "num_citations": "8\n", "authors": ["1812"]}
{"title": "Design verification for a switching network logic using formal techniques\n", "abstract": " Formal techniques are applied to industrial design problems such as verification of a circuit design. Initial decisions may include defining properties to verify the design. An abstraction of the design may be generated and model checking applied to the abstraction. Results obtained using these techniques may be extended by performance analysis and/or verification of sequential operations.", "num_citations": "8\n", "authors": ["1812"]}
{"title": "Systems, methods, and media for assertion-based verification of devices\n", "abstract": " Systems and methods for functionally verifying the performance of a system on a chip (SOC) are provided herein. According to some embodiments, the methods may include at least the steps of analyzing a verification log, via a functional verification system, to determine signatures by correlating a pattern of at least one of triggered and untriggered assertions in one or more blocks of a plurality of blocks to behaviors of at least one of the SOC and the one or more blocks of the plurality of blocks. Exemplary methods also include categorizing signatures according to the behaviors, and storing similar signatures based upon the categorization in a database.", "num_citations": "7\n", "authors": ["1812"]}
{"title": "Verifying a gigabit ethernet switch using SMV\n", "abstract": " We use model checking techniques to verify a switching block in a new Gigabit Ethernet switch-BCM5690. Due to its dynamic nature, this block has been traditionally difficult to verify. Formal techniques are far more efficient than simulation for this particular design. Among 26 design errors discovered, 22 are found using formal methods. We then improve our model checking capability to analyze switch latency. We also use induction to avoid state explosion in the model checker.", "num_citations": "7\n", "authors": ["1812"]}
{"title": "Method for measuring assertion density in a system of verifying integrated circuit design\n", "abstract": " An assertion-based verification tool for circuit designs includes an effective measurement of assertion density for any given generated set of assertions. A register-transfer level (RTL) description of an integrated circuit (IC) is used to compute a set of predicates. Then, determination is made as to the number of predicates that are satisfiable on the given set of assertions received respective of the RTL description. Thereafter, simulation traces for the RTL are received and the number of predicates satisfiable on the simulation traces is computed. A figure of merit of assertion density is determined from the ratio of the respective numbers of predicates. The set of assertions may be modified as required to satisfy a predetermined threshold value of assertion density, to assure that a circuit is rigorously tested by the verification tool.", "num_citations": "4\n", "authors": ["1812"]}
{"title": "Automatic generation of properties to assist hardware emulation\n", "abstract": " Analysis of a first verification test suite automatically generates properties that may be directly used in a subsequent verification test suite. For example, an IP module may be verified by executing a software simulation test suite. The resulting data is accessed and analyzed to detect a set of properties of the software simulation test suite. A set of emulator-synthesizable properties are selected from the set of detected properties. The emulator-synthesizable properties are suitable for incorporation in a hardware emulation test suite used to test the SoC.", "num_citations": "3\n", "authors": ["1812"]}
{"title": "Utilizing Assertion Synthesis to Achieve an Automated Assertion-Based Verification Methodology for Complex Graphics Chip Designs\n", "abstract": " This paper reports a new functional verification methodology using assertion synthesis to automatically generate assertions and functional coverage goals. This new methodology complements and enhances our existing verification flows based on constrained random simulation, formal verification as well as emulation. Our experimental results supporting the new methodology are provided.", "num_citations": "3\n", "authors": ["1812"]}
{"title": "Cache-based free address pool\n", "abstract": " A method and apparatus for managing memory according to several embodiments of the invention. According to embodiments, the invention includes providing a memory including a plurality of memory locations configured to store data, providing a memory address pool having a plurality of available memory addresses and providing a cell free address pool (CFAP), including a memory address pointer, wherein the memory address pointer indicates a next available memory address in the memory address pool.", "num_citations": "2\n", "authors": ["1812"]}
{"title": "Linking Multiple Verification Flows Using Automatically Generated Assertions\n", "abstract": " More features and more bandwidth capability enabled in our new generation switch chips create a daunting task for functional verification. Our verification methodology includes a top level test environment and many block level tests for key blocks. Both rely on random stimulus to achieve significant coverage. They are typically independent effort from different groups. This paper reports a new methodology using whitebox assertions and functional cover properties automatically generated by a vendor tool (Bugscope) to link multiple verification flows. Using an Assertion Synthesis technology, Bugscope can automatically generate high quality assertions and cover properties. The main contribution of this paper is that we realize that Bugscope assertions and cover properties generated at block level testing can be used to guide further verification including chip and formal verification. Though the block level verification\u00a0\u2026", "num_citations": "1\n", "authors": ["1812"]}
{"title": "A Survey of Abstract BDDs\n", "abstract": " We survey and unify recent work about abstraction within BDD packages. Abstract BDDs (aBDDs) are obtained from ordinary BDDs by merging BDD nodes whose abstract values coincide. We discuss four types of abstract BDDs (called S-type, 0-type, 1-type and\u2228-type aBDDs) which have found applications in many CAD-related areas such as equivalence checking, variable ordering and model checking. Experimental results demonstrate the usefulness of our method.", "num_citations": "1\n", "authors": ["1812"]}
{"title": "Improving BDD variable ordering using abstract BDDs and sampling\n", "abstract": " Variable ordering for BDDs has been extensively investigated. Recently, sampling based ordering techniques have been proposed to overcome problems with structure based static ordering methods and sifting based dynamic reordering techniques. However, existing sampling techniques can lead to an unacceptably large deviation in the size of the final BDD. In this paper, we propose a sampling technique based on abstract BDDs (aBDDs) that does not suffer from this problem. This new technique has been implemented and consistently creates high quality variable orderings for both combinational as well as sequential functions. Experimental results show that for many applications our approach is significantly superior to existing techniques.", "num_citations": "1\n", "authors": ["1812"]}