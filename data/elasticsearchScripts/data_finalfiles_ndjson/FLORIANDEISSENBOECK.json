{"title": "Concise and consistent naming\n", "abstract": " Approximately 70% of the source code of a software system consists of identifiers. Hence, the names chosen as identifiers are of paramount importance for the readability of computer programs and therewith their comprehensibility. However, virtually every programming language allows programmers to use almost arbitrary sequences of characters as identifiers which far too often results in more or less meaningless or even misleading naming. Coding style guides somehow address this problem but are usually limited to general and hard to enforce rules like \u201cidentifiers should be self-describing\u201d. This paper renders adequate identifier naming far more precisely. A formal model, based on bijective mappings between concepts and names, provides a solid foundation for the definition of precise rules for concise and consistent naming. The enforcement of these rules is supported by a tool that incrementally\u00a0\u2026", "num_citations": "376\n", "authors": ["75"]}
{"title": "Demystifying maintainability\n", "abstract": " Due to its economic impact\" maintainability\" is broadly accepted as an important quality attribute of software systems. But in contrast to attributes such as performance and correctness, there is no common understanding of what maintainability actually is, how it can be achieved, measured, or assessed. In fact, every software organization of significant size seems to have its own definition of maintainability. We address this problem by defining an unique two-dimensional quality model that associates maintenance activities with system properties including the capabilities of the organization. The separation of activities and properties facilitates the identification of sound quality criteria and allows to reason about their interdependencies. The resulting quality controlling process enforces these criteria through tool-supported measurements as well as manual inspections. We report on our experiences with the incremental\u00a0\u2026", "num_citations": "83\n", "authors": ["75"]}
{"title": "From reality to programs and (not quite) back again\n", "abstract": " Making explicit the mappings between real-world concepts and program elements that implement them is an essential step in understanding, using or evaluating the public interface of programs, libraries and other collections of classes that model core domain concepts. Unfortunately, due to the big abstraction gap between the modeled domain and today's programming languages, the mapping is most of the times ambiguous as concepts and relations from the real world are distorted and diffused in the code. In this paper we present a comprehensive formal framework for describing the many-to-many mappings between domain concepts and the program elements, real-world relations and program relations and the real-world concept names and program identifiers. This framework allows us to describe and discuss typical classes of diffusion of the domain knowledge in code. Based on our formal framework we\u00a0\u2026", "num_citations": "58\n", "authors": ["75"]}
{"title": "Tool support for continuous quality assessment\n", "abstract": " Maintenance costs make up the bulk of the total life cycle costs of a software system. Besides organizational issues such as knowledge management and turnover, the long-term maintenance costs are largely predetermined by various quality attributes of the software system itself such as redundancy and adequate documentation. Unfortunately, many quality defects can hardly be corrected retrospectively after they have penetrated the system. A much more promising approach than correction is to avoid decay and to preserve a constant high level of quality through a continuous real-time quality controlling process. To reduce the costs for the required frequent quality assessments, adequate tool support is indispensable. This paper proposes to integrate measurement tools into a flexible and extensible yet high performance quality assessment tool. We present the design and implementation of this tool and report on\u00a0\u2026", "num_citations": "40\n", "authors": ["75"]}
{"title": "How programs represent reality (and how they don't)\n", "abstract": " Programming is modeling the reality. Most of the times, the mapping between source code and the real world concepts are captured implicitly in the names of identifiers. Making these mappings explicit enables us to regard programs from a conceptual perspective and thereby to detect semantic defects such as (logical) redundancies in the implementation of concepts and improper naming of program entities. We present real world examples of these problems found in the Java standard library and establish a formal framework that allows their concise classification. Based on this framework, we present our method for recovering the mappings between the code and the real world concepts expressed as ontologies. These explicit mappings enable semi-automatic identification of the discussed defect classes", "num_citations": "35\n", "authors": ["75"]}
{"title": "A unified meta-model for concept-based reverse engineering\n", "abstract": " While programming is modeling the reality, reverse engineering is concerned with recovering it from the code. Parts of this reality can be formalized as concepts and relations among them. As previous research suggests, the identification of these concepts is a key issue in automating program analysis. Their central role requires advance reverse engineering tasks to consider them first-class citizens. In this paper we unify the classical, structure-based reverse engineering meta-models with a meta-model describing concepts and their relations. Our unified meta-model establishes an explicit mapping between concepts and their implementations in a program. Instances of the meta-model are built in a semi-automatic manner by analyzing the program\u2019s identifiers. Using this model allows us to raise the abstraction level by viewing the program from the perspective of concepts it implements. This enables a higher degree of automation in the reverse engineering endeavor.", "num_citations": "33\n", "authors": ["75"]}
{"title": "A holistic approach to software quality at work\n", "abstract": " Software quality is a crucial issue in a society that vitally depends on software systems. Software quality definitions, standards, and metrics have contributed to the improvement of our understanding of this issue. However, there is a miss-match between the formalization of software quality issues and the practical demands of software quality. Software quality is not what we measure but what we experience when developing, operating, and using software systems over a long period of time. We argue, that it is dangerous to try to capture software quality merely by a set of numbers in terms of software metrics believing that these give an authentic picture. Though these numbers are helpful achieving truly high quality requires in addition a deep understanding of the field as well as valid knowledge on how to attain and assure software quality in development. If the top management of software dependent companies does not have an understanding of what software quality is about, all metrics of the world will not save them from their project failures.", "num_citations": "31\n", "authors": ["75"]}
{"title": "Programs are knowledge bases\n", "abstract": " Gaining an overview of the concepts represented in large programs is very demanding as multiple dimensions of knowledge appear at different abstraction levels throughout the source code. To reduce the overall comprehension effort it is therefore desirable to make the knowledge once gained explicit and shareable. We tackle this problem by establishing a mapping between source code and conceptualizations shared as ontologies. To achieve this we regard programs themselves as knowledge bases built on the programs' identifiers and their relations implied by the programming language. Making these mappings explicit allows sharing knowledge about the concepts represented in programs. We exemplify our approach on Java programming language and the WordNet ontology and we report on our experience with analyzing an open source system", "num_citations": "27\n", "authors": ["75"]}
{"title": "Continuous quality control of long-lived software systems\n", "abstract": " To be economically successful, software systems must be continuously adapted to ever changing requirements. The maintainability of software systems is therefore of paramount importance. However, most organizations do not apply dedicated processes, tools and techniques to assure maintainability. Partly, this is caused by the lack of a precise definition of the term maintainability. This dissertation proposes a novel approach for modeling maintainability that explicitly associates system propertie...\u00bb", "num_citations": "25\n", "authors": ["75"]}
{"title": "How to effectively define and measure maintainability\n", "abstract": " Maintainability and flexibility at the software level are of predominant importance to drive innovation at the business process level. However, existing definitions of maintainability, such as the Halstead Volume, McCabe's Cyclomatic Complexity or the SEI maintainability index provide a very poor understanding of what maintainability is how it can be assessed and ultimately controlled. This paper explains a new and more effective way to construct software product quality models. The key design principle is the strict separation of activities and properties of the system. This separation facilitates the identification of sound quality criteria and allows to reason about their interdependencies and their effects. The application of this quality modelling approach in large scale commercial software organiseations helped to effectively reveal important quality shortcomings and raised the awareness for the importance of long-term quality aspects among developers as well as managers.", "num_citations": "23\n", "authors": ["75"]}
{"title": "Continuous software quality control in practice\n", "abstract": " Many companies struggle with unexpectedly high maintenance costs for their software development which are often caused by insufficient code quality. Although companies often use static analyses tools, they do not derive consequences from the metric results and, hence, the code quality does not actually improve. We provide an experience report of the quality consulting company CQSE, and show how code quality can be improved in practice: we revise our former expectations on quality control from [1] and propose an enhanced continuous quality control process which requires the combination of metrics, manual action, and a close cooperation between quality engineers, developers, and managers. We show the applicability of our approach with a case study on 41 systems of Munich RE and demonstrate its impact.", "num_citations": "20\n", "authors": ["75"]}
{"title": "How much is a clone\n", "abstract": " Real-world software systems contain substantial amounts of cloned code. While the negative impact of cloning on software maintenance has been shown in principle, we currently cannot quantify it in terms of increased maintenance costs. However, as long as its economic impact cannot be quantified, control of cloning is probable to be neglected in practice. This paper presents an analytical cost model to estimate the maintenance effort increase caused by code cloning. The cost model can be used to assess the economic impact of cloning in a system and to evaluate investments in clone management tool support. To show its applicability, we report on a case study that instantiates the cost model for 11 industrial software systems.", "num_citations": "19\n", "authors": ["75"]}
{"title": "Feature profiling for evolving systems\n", "abstract": " Traditionally, most work in program comprehension focuses on understanding the inner workings of software systems. However, for many software maintenance tasks, not only a sound understanding of a system's implementation but also comprehensive and accurate information about the way users actually use a system's features is of crucial importance. Such information e.g. helps to determine the impact that a specific change has on the users of a system. In practice, however, this information is often not available. We propose an approach called feature profiling as a means to efficiently gather usage information to support maintenance tasks that affect the user interface of a software system. Furthermore, we present tool support for feature profiling and report on a case study in the insurance domain. In this study, we profiled the features of an application that is used by 150 users in 10 countries over a period of five\u00a0\u2026", "num_citations": "14\n", "authors": ["75"]}
{"title": "Towards a repository of common programming technologies knowledge\n", "abstract": " Towards a Repository of Common Programming Technologies Knowledge Page 1 Towards a Repository of Common Programming Technologies Knowledge Daniel Ratiu, Martin Feilkas, Florian Deissenb\u00f6ck, Jan J\u00fcrjens, Radu Marinescu STSM 10 June 2008 http://www4.in.tum.de/~ratiu/knowledge_repository.html Page 2 Situation Today \u27a2 Reverse engineering is a knowledge intensive activity \u27a2 To analyze programs, engineers need and use of a lot of knowledge about \u27a2 Application domain \u27a2 Software technologies \u27a2 ... and how are they combined at the code level Today's automatic tool support does not use this knowledge but ... There are currently no knowledge bases in a machine processable form, big enough and at the abstraction level of the source code because ... Page 3 Situation Today (2) \u27a2 Ontologies are the de-facto technology for knowledge sharing \u27a2 A lot of research efforts in the semantic web \u27a2 , a '\u2026", "num_citations": "13\n", "authors": ["75"]}
{"title": "Kontinuierliche qualit\u00e4ts\u00fcberwachung mit conqat\n", "abstract": " Obwohl der entscheidende Einfluss der Software-Qualit\u00e4t auf die Produktivit\u00e4t der Wartung und Weiterentwicklung von Software-Systemen allgemein akzeptiert ist, werden Qualit\u00e4tsaspekte, speziell bei der Entwicklung unter hohem Zeitund Kostendruck, oft vernachl\u00e4ssigt. Zur Durchf\u00fchrung kosteneffizienter, kontinuierlicher Qualit\u00e4tssicherungsma\u00dfnahmen bedarf es daher der Unterst\u00fctzung durch Werkzeuge zur automatisierten \u00dcberwachung vielf\u00e4ltiger Qualit\u00e4tskriterien. Dieses Papier pr\u00e4sentiert das Qualit\u00e4ts\u00fcberwachung-Framework CONQAT und berichtet \u00fcber die Erfahrungen, die im Laufe des bisher einj\u00e4hrigen Einsatzes gemacht wurden.", "num_citations": "9\n", "authors": ["75"]}
{"title": "The economic impact of software process variations\n", "abstract": " The economic benefit of a certain development process or particular activity is usually unknown and indeed hard to predict. However, the cost-effectiveness of process improvements is of paramount importance and the question how profitable certain activities are needs to be answered. Within a large-scale commercial organization, we were challanged with the task to quantify the economic benefit of isolated test and development environments. To answer this question we defined a generic process model based on absorbing Markov chains that allows to analyze the economic benefit of software process variations. This model exposes conflicts between process steps and reiterations of development activities and thereby provides a highly flexible tool for the investigation of the effects of changes to a development process on its overall performance. This model was used to predict the impact of isolated testing\u00a0\u2026", "num_citations": "8\n", "authors": ["75"]}
{"title": "How do Java methods grow?\n", "abstract": " Overly long methods hamper the maintainability of software - they are hard to understand and to change, but also difficult to test, reuse, and profile. While technically there are many opportunities to refactor long methods, little is known about their origin and their evolution. It is unclear how much effort should be spent to refactor them and when this effort is spent best. To obtain a maintenance strategy, we need a better understanding of how software systems and their methods evolve. This paper presents an empirical case study on method growth in Java with nine open source and one industry system. We show that most methods do not increase their length significantly; in fact, about half of them remain unchanged after the initial commit. Instead, software systems grow by adding new methods rather than by modifying existing methods.", "num_citations": "7\n", "authors": ["75"]}
{"title": "Probabilistic analysis of process economics\n", "abstract": " The economic benefit of a certain development process or particular activity is usually unknown and indeed hard to predict. However, the cost\u2010effectiveness of process improvements is of paramount importance and the question how profitable certain activities are needs to be answered. Within a large\u2010scale commercial organization, we were challenged with the task to quantify the economic benefit of isolated test and development environments. To answer this question, we defined a generic process model based on absorbing Markov chains that allows the analyzation of the economic benefit of software process variations. This model exposes conflicts between process steps and reiterations of development activities and thereby provides a highly flexible tool for the investigation of the effects of changes to a development process on its overall performance. This model was used to predict the impact of isolated\u00a0\u2026", "num_citations": "7\n", "authors": ["75"]}
{"title": "Concise and consistent naming: ten years later\n", "abstract": " Summary form only given. Approximately 70% of the source code of a software system consists of identifiers. Hence, the names chosen as identifiers are of paramount importance for the readability of computer programs and therewith their comprehensibility. However, virtually every programming language allows programmers to use almost arbitrary sequences of characters as identifiers which far too often results in more or less meaningless or even misleading naming. Coding style guides address this problem but are usually limited to general and hard to enforce rules like \"identifiers should be self-describing\". At IWPC 2005 we proposed a formal model, based on bijective mappings between concepts and names, provides a solid foundation for the definition of precise rules for concise and consistent naming. The enforcement of these rules was supported by a tool that incrementally builds and maintains a\u00a0\u2026", "num_citations": "4\n", "authors": ["75"]}
{"title": "Delta analysis\n", "abstract": " We use various kinds of static analyses to identify problems that decrease the quality of our system. In many cases, however, the number of reported problems is huge\u2014preventing us from solving these problems due to a lack of resources or motivation. We suggest a technique called \u201cdelta analysis\u201d together with a simple behavioral rule that allows to deal with large numbers of problems and gradually improves the quality of our system.", "num_citations": "2\n", "authors": ["75"]}
{"title": "Kontinuierliches Qualit\u00e4ts-Controlling langlebiger Softwaresysteme\n", "abstract": " um wirtschaftlich erfolgreich zu sein, miussen softwaresysteme an sich stetig iandernde anforderungen angepasst werden. daher ist die wartbarkeit von softwaresystemen von zentraler bedeutung. dennoch werden dedizierte prozesse, methoden und werkzeuge zur sicherung der wartbarkeit nur von wenigen unternehmen eingesetzt. dies ist teilweise dadurch bedingt, dass derzeit keine priazise definition des begriffs wartbarkeit existiert. diese dissertation schliagt einen neuen ansatz zur modellierung von wartbarkeit vor, der systemeigenschaften explizit mit wartungsaktivitiaten in verbindung setzt und damit eine strukturierte dekomposition des begriffs wartbarkeit ermioglicht. mit hilfe von werkzeugen kionnen wartbarkeitsmodelle, die mit diesem ansatz definiert sind, fiur das kontinuierliche Qualitiats-Controlling eingesetzt werden um einen schleichenden verfall der Qualitiat zu vermeiden. die eignung des ansatzes wird im rahmen von Fallstudien im industriellen umfeld demonstriert.", "num_citations": "1\n", "authors": ["75"]}
{"title": "Projekt PQL-Qualit\u00e4tsmodel\n", "abstract": " Dieses Dokument beschreibt das Qualit\u00e4tsmodell Software-Wartbarkeit, das im Rahmen des Projekts\u00bb Produktivit\u00e4ts-und Qualit\u00e4tsaspekte langlebiger Software (PQL)\u00abvom Lehrstuhls Software and Systems Engineering (Prof. Dr. Dr. hc Manfred Broy) und der Siemens Business Services GmbH & Co. OHG erarbeitet wurde.Ziel des Qualit\u00e4tsmodells PQL-QM ist es, die Vielzahl der Faktoren, die f\u00fcr die langfristige Produktivit\u00e4t und Qualit\u00e4t in der Software-Wartung entscheidend sind aufzuschl\u00fcsseln und ihren Einfluss auf die unterschiedlichen Wartungsaktivit\u00e4ten darzustellen. Erreicht wird dies durch eine konsequente Trennung zwischen den Wartungsaktivit\u00e4ten, der Projektsituation und Qualit\u00e4tsmerkmalen. Durch diese Trennung k\u00f6nnen die Kostentreiber identifiziert und ihr Einfluss erkl\u00e4rt werden.", "num_citations": "1\n", "authors": ["75"]}