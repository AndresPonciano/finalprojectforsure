{"title": "Building reliable component-based software systems\n", "abstract": " Here's a complete guide to building reliable component-based software systems. Written by world-renowned experts in the component-based software engineering field, this unique resource helps you manage complex software through the development, evaluation and integration of software components. You quickly develop a keen awareness of the benefits and risks to be considered when developing reliable systems using components. A strong software engineering perspective helps you gain a better understanding of software component design, to build systems with stronger requirements, and avoid typical errors throughout the process, leading to improved quality and time to market.", "num_citations": "900\n", "authors": ["639"]}
{"title": "Component\u2010based software engineering\u2014new challenges in software development\n", "abstract": " The primary role of component\u2010based software engineering is to address the development of systems as an assembly of parts (components), the development of parts as reusable entities, and the maintenance and upgrading of systems by customising and replacing such parts. This requires established methodologies and tool support covering the entire component and system lifecycle including technological, organisational, marketing, legal, and other aspects. The traditional disciplines from software engineering need new methodologies to support component\u2010based development. IVICA CRNKOVIC assesses the challenges of this emerging technology and discusses its implications for the software development process. Copyright \u00a9 2002 John Wiley & Sons, Ltd.", "num_citations": "420\n", "authors": ["639"]}
{"title": "Component-based development process and component lifecycle\n", "abstract": " In recent years component-based development has become an established approach. Component-based Software Engineering (CBSE) that deals with the entire lifecycle of component-based products has been focused on technologies related to design and implementation of software components and systems built from software components. The experience has shown that pure technologies alone are not enough. A CBSE approach requires certain changes in development and life cycle processes. However, very few CBSE works, either research or practical, have addressed these topics. This paper describes principle differences of component-based and non-component based processes. Also we give an overview of a case study from a company that applies component-based approach.", "num_citations": "352\n", "authors": ["639"]}
{"title": "Implementing and integrating product data management and software configuration management\n", "abstract": " Gain an in-depth understanding of software testing management and process issues that are critical for delivering high-quality software on time and within budget. Written by leading experts in the field, this book offers those involved in building and maintaining complex, mission-critical software systems a flexible, risk-based process to improve their software testing capabilities. Whether your organization currently has a well-defined testing process or almost no process, Systematic Software Testing provides unique insights into better ways to test your software. This book describes how to use a preventive method of testing, which parallels the software development lifecycle, and explains how to create and subsequently use test plans, test design, and test metrics. Detailed instructions are presented to help you decide what to test, how to prioritize tests, and when testing is complete. Learn how to conduct risk analysis and measure test effectiveness to maximize the efficiency of your testing efforts. Because organizational structure, the right people, and management are keys to better software testing, Systematic Software Testing explains these issues with the insight of the authors' more than 25 years of experience.", "num_citations": "270\n", "authors": ["639"]}
{"title": "Component-based software engineering for embedded systems\n", "abstract": " Although attractive, CBD has not been widely adopted in domains of embedded systems. The main reason is inability of these technologies to cope with the important concerns of embedded systems, such as resource constraints, real-time or dependability requirements. However an increasing understanding of principles of CBD makes it possible to utilize these principles in implementation of different component-based models more appropriate for embedded systems. The aim of this tutorial is to point to the opportunity of applying this approach for development and maintenance of embedded systems. The tutorial gives insights into basic principles of CBD, the main concerns and characteristics of embedded systems and possible directions of adaptation of component-based approach for these systems. Different types of embedded systems and approaches for applying CBD are presented and illustrated by\u00a0\u2026", "num_citations": "171\n", "authors": ["639"]}
{"title": "Specification, implementation, and deployment of components\n", "abstract": " Clarifying common terminology and exploring component-based relationships.", "num_citations": "167\n", "authors": ["639"]}
{"title": "Challenges of component-based development\n", "abstract": " It is generally understood that building software systems with components has many advantages but the difficulties of this approach should not be ignored. System evolution, maintenance, migration and compatibilities are some of the challenges met with when developing a component-based software system. Since most systems evolve over time, components must be maintained or replaced. The evolution of requirements affects not only specific system functions and particular components but also component-based architecture on all levels. Increased complexity is a consequence of different components and systems having different life cycles. In component-based systems it is easier to replace part of system with a commercial component. This process is however not straightforward and different factors such as requirements management, marketing issues, etc., must be taken into consideration. In this paper we\u00a0\u2026", "num_citations": "135\n", "authors": ["639"]}
{"title": "Component-based approach for embedded systems\n", "abstract": " \u2013Less programming efforts to build systems\u2013System verification and validation more difficult and more important", "num_citations": "122\n", "authors": ["639"]}
{"title": "A case study: demands on component-based development\n", "abstract": " Building software systems with reusable components brings many advantages. The development becomes more efficient, the realibility of the products is enhanced, and the maintenance requirement is significantly reduced. Designing, developing and maintaining components for reuse is, however, a very complex process which places high requirements not only for the component functionality and flexibility, but also for the development organization. In this paper we discuss the different levels of component reuse, and certain aspects of component development, such as component generality and efficiency, compatibility problems, the demands on development environment, maintenance, etc. The evolution of requirements for products generates new requirements for components, if components are not enough general and mature. This dynamism determines the component life cycle where the component first\u00a0\u2026", "num_citations": "104\n", "authors": ["639"]}
{"title": "Concerning predictability in dependable component-based systems: Classification of quality attributes\n", "abstract": " One of the main objectives of developing component-based software systems is to enable efficient building of systems through the integration of components. All component models define some form of component interface standard that facilitates the programmatic integration of components, but they do not facilitate or provide theories for the prediction of the quality attributes of the component compositions. This decreases significantly the value of the component-based approach to building dependable systems. If it is not possible to predict the value of a particular attribute of a system prior to integration and deployment to the target environment the system must be subjected to other procedures, often costly, to determine this value empirically. For this reason one of the challenges of the component-based approach is to obtain means for the \u201ccomposition\u201d of quality attributes. This challenge poses a very\u00a0\u2026", "num_citations": "92\n", "authors": ["639"]}
{"title": "Model-driven engineering for mission-critical iot systems\n", "abstract": " Mission-critical Internet of Things (MC-IoT) systems involve heterogeneous things from both the digital and physical worlds. They run applications whose failure might cause significant and possibly dramatic consequences, such as interruption of public services, significant business losses, and deterioration of enterprise operations. These applications require not only high availability, reliability, safety, and security but also regulatory compliance, scalability, and serviceability. At the same time, they're exposed to various facets of uncertainty, spanning from software and hardware variability to mission planning and execution in possibly unforeseeable environments. Model-driven engineering can potentially meet these challenges and better enable the adoption of MC-IoT systems.", "num_citations": "85\n", "authors": ["639"]}
{"title": "Component-based vs. model-based development: a comparison in the context of vehicular embedded systems\n", "abstract": " Component based and model based development (CBD vs. MBD), in their various interpretations, are in focus in many efforts in order to better handle the efficient development of increasingly complex embedded systems. We elaborate on what CBD and MBD represent, on their differences and similarities. Although CBD represents a bottom-up approach whereas MBD is more top-down in nature, it turns out that the concepts have much in common and can benefit from cross-fertilization. In particular, MBD requires improved handling of 'model' components, and CBD requires improved component models to assure component composition and reuse. We discuss their mutual opportunities and other relationships.", "num_citations": "69\n", "authors": ["639"]}
{"title": "New challenges for configuration management\n", "abstract": " More and more systems are developed using components. There is a move from monolithic to open and flexible systems. In such systems, components are upgraded and introduced at run-time, which affects the configuration of the complete system. Keeping up-to-date information about which components are installed is a problem. Updating a component also affects the compatibility of the system. It is therefore important to keep track of changes introduced in the system. In the product life cycle, CM is traditionally focused on the development phase, in particular on managing source code. Now when changes are introduced in systems at run-time and systems are component-based, a new discipline, component configuration management is required. This paper analyses component management and highlights the problems related to component configuration. Requirements on component configuration\u00a0\u2026", "num_citations": "65\n", "authors": ["639"]}
{"title": "COTS selection best practices in literature and in industry\n", "abstract": " This paper presents an extensive literature survey of the software COTS component selection methods published to date, followed by a meta-model consolidating the activities and practices of these methods. Together with data collected from practitioners and researchers in the embedded systems domain, we provide concrete recommendations which will enable organizations to identify suitable practices when designing a customized selection processes.", "num_citations": "63\n", "authors": ["639"]}
{"title": "Configuration management for component-based systems\n", "abstract": " One of the basic problems when developing component-based systems is that it is difficult to keep track of components and their interrelationships. This problem emerges already in the requirement phase, in which we want to identify and select the most appropriate components. Later, during the assembly and deployment process, or when upgrading components, the problem of components identification and dependency management becomes even more important. One way to maintain control over upgrades is to use component identification and dependency analysis. These are well known techniques for managing system configurations during development, but are rarely applied in managing run-time dependencies. Knowledge of the possible impacts of an update is important, since it can be used to limit the scope of testing and be a basis for evaluating the potential damage of the update. In this paper we analyse different types of dependencies and discuss how to identify and specify them, in analogy with Makefiles. The dependencies can be showed in a form of a dependency graph. The dependency graphs can also be used to facilitate maintenance by identifying differences between configurations, eg, making it possible to recognise any deviations from a functioning reference configuration.", "num_citations": "51\n", "authors": ["639"]}
{"title": "Software systems integration and architectural analysis-a case study\n", "abstract": " Software systems no longer evolve as separate entities but are also integrated with each other. The purpose of integrating software systems can be to increase user-value or to decrease maintenance costs. Different approaches, one of which is software architectural analysis, can be used in the process of integration planning and design. This paper presents a case study in which three software systems were to be integrated. We show how architectural reasoning was used to design and compare integration alternatives. In particular, four different levels of the integration were discussed (interoperation, a so-called enterprise application integration, an integration based on a common data model, and a full integration). We also show how cost, time to delivery and maintainability of the integrated solution were estimated. On the basis of the case study, we analyze the advantages and limits of the architectural approach\u00a0\u2026", "num_citations": "49\n", "authors": ["639"]}
{"title": "Software systems in-house integration: Architecture, process practices, and strategy selection\n", "abstract": " As organizations merge or collaborate closely, an important question is how their existing software assets should be handled. If these previously separate organizations are in the same business domain \u2013 they might even have been competitors \u2013 it is likely that they have developed similar software systems. To rationalize, these existing software assets should be integrated, in the sense that similar features should be implemented only once. The integration can be achieved in different ways. Success of it involves properly managing challenges such as making as well founded decisions as early as possible, maintaining commitment within the organization, managing the complexities of distributed teams, and synchronizing the integration efforts with concurrent evolution of the existing systems.This paper presents a multiple case study involving nine cases of such in-house integration processes. Based both on\u00a0\u2026", "num_citations": "38\n", "authors": ["639"]}
{"title": "Real world influences on software architecture-interviews with industrial system experts\n", "abstract": " Industrial systems are examples of complex and often long-lived systems in which software is playing an increasingly important role. Their architectures play a crucial role in maintaining the properties of such systems during their entire life cycle. In this paper, we present the results of a case study based on a series of interviews and a workshop with key personnel from research and development groups of successful international companies in their Swedish locations. The main goal of the investigation was to find the significant factors which influence system and software architectures and to find similarities and differences between the architecture-determining decisions and the architectures of these systems. The role of the architect was an important subject of the investigation. Our findings result in recommendations relating to the design and evolution of system architectures and suggestions regarding areas in\u00a0\u2026", "num_citations": "37\n", "authors": ["639"]}
{"title": "Component-based software engineering: building systems from components at 9th IEEE conference and workshops on engineering of computer-based systems\n", "abstract": " This paper gives a short overview of the Workshop on Component-based Software Engineering - Building Systems from Components held at 9th IEEE Conference and Workshops on Engineering of Computer-Based Systems in Lund, Sweden, April, 2002. The aim of the workshop was to bring together researches and practitioners from system engineering, software architecture and from component-based software engineering communities in order to exchange experiences and research results from these domains.", "num_citations": "37\n", "authors": ["639"]}
{"title": "Extracting client-side web application code\n", "abstract": " The web application domain is one of the fastest growing and most wide-spread application domains today. By utilizing fast, modern web browsers and advanced scripting techniques, web developers are developing highly interactive applications that can, in terms of user-experience and responsiveness, compete with standard desktop applications. A web application is composed of two equally important parts: the server-side and the client-side. The client-side acts as a user-interface to the application, and can be viewed as a collection of behaviors. Similar behaviors are often used in a large number of applications, and facilitating their reuse offers considerable benefits. However, due to client-side specifics, such as multi-language implementation and extreme dynamicity, identifying and extracting code responsible for a certain behavior is difficult. In this paper we present a semi-automatic method for extracting\u00a0\u2026", "num_citations": "36\n", "authors": ["639"]}
{"title": "Component-based software engineering-new paradigm of software development\n", "abstract": " Component-based software development is a new trend in software development. The main idea is to reuse already completed components instead of developing everything from the very beginning each time. Use of component-based development brings many advantages: faster development, lower costs of the development, better usability, etc. Component-based development is however still not mature process and there still exist many problems. For example, when you buy a component you do not know exactly its behavior, you do not have control over its maintenance, and so on. To be able to successfully develop component-based products, the organizations must introduce new development methods.This seminar gives a short introduction to component-based development, and component-based software engineering methods, both form technological and marketing point of view. An overview of existing component models will be presented. Finally some successful examples of componentbased development are shown: OPC-a standard set of interfaces, properties, and methods for use in processcontrol and manufacturing-automation applications, and ABB Industrial IT, a new generation of automation systems.", "num_citations": "36\n", "authors": ["639"]}
{"title": "Safety for mobile robotic systems: A systematic mapping study from a software engineering perspective\n", "abstract": " Robotic research is making huge progress. However, existing solutions are facing a number of challenges preventing them from being used in our everyday tasks: (i) robots operate in unknown environments, (ii) robots collaborate with each other and even with humans, and (iii) robots shall never injure people or create damages. Researchers are targeting those challenges from various perspectives, producing a fragmented research landscape.We aim at providing a comprehensive and replicable picture of the state of the art from a software engineering perspective on existing solutions aiming at managing safety for mobile robotic systems. We apply the systematic mapping methodology on an initial set of 1274 potentially relevant research papers, we selected 58 primary studies and analyzed them according to a systematically-defined classification framework.This work contributes with (i) a classification framework\u00a0\u2026", "num_citations": "34\n", "authors": ["639"]}
{"title": "Identifying code of individual features in client-side web applications\n", "abstract": " Web applications are one of today's fastest growing software systems. Structurally, they are composed of two parts: the server side, used for data access and business logic, and the client side, used as a user interface. In recent years, with developers building complex interfaces, the client side is playing an increasingly important role. Unfortunately, the techniques and tools used to support development are not as advanced as in other disciplines. From the user's perspective, the client side offers a number of features that are relatively easy to distinguish. However, the same cannot be said for their implementation details. This makes the understanding, maintenance, and reuse of code difficult. The goal of the work presented in this paper is to improve reusability, maintainability, and performance of client-side web applications by identifying the code that implements a particular feature. We have evaluated the approach\u00a0\u2026", "num_citations": "33\n", "authors": ["639"]}
{"title": "Customers' role in teaching distributed software development\n", "abstract": " This paper describes different aspects of teaching distributed software development, regarding the types of project customers: industry and academia. These approaches enable students to be more engaged in real-world situations, by having customers from the industry, local or distributed customers in universities, distributed customers in software engineering contests or being involved in an ongoing project, thus simulating the company merging. The methods we describe are used in a distributed project-oriented course, which is jointly carried out by two universities from Sweden and Croatia. The paper presents our experiences of such projects being done during the course, the differences in each approach, issues observed and ways to solve them, in order to create a more engaging education for better-prepared engineers of tomorrow.", "num_citations": "32\n", "authors": ["639"]}
{"title": "Architectural decisions for HW/SW partitioning based on multiple extra-functional properties\n", "abstract": " Growing advances in hardware technologies are enabling significant improvements in application performance by the deployment of components to dedicated executable units. This is particularly valid for Cyber Physical Systems in which the applications are partitioned in HW and SW execution units. The growing complexity of such systems, and increasing requirements, both project- and product-related, makes the partitioning decision process complex. Although different approaches to this decision process have been proposed during recent decades, they lack the ability to provide relevant decisions based on a larger number of requirements and project/business constraints. A sound approach to this problem is taking into account all relevant requirements and constraints and their relations to the properties of the components deployed either as HW or SW units. A typical approach for managing a large number of\u00a0\u2026", "num_citations": "29\n", "authors": ["639"]}
{"title": "Meeting industry-academia research collaboration challenges with agile methodologies\n", "abstract": " Continuous and long-term collaboration between industry and academia is crucial to develop front-line research in context-dependent areas like software development where both practitioners and researchers are searched for data collection, analysis and results. Despite many mutual benefits, this collaboration is often challenging, not only due to different goals, but also because of different pace in providing the results. The software development industry has during the last decade aligned around and organized their development adopting agile methodologies. For the researchers, the agile methodologies are a topic for a research, rather than a means of performing the research itself. We can state a question, whether the agile methodologies can be a good common ground for enabling successful research collaboration between industry and academia? This paper reports on a longitudinal industry - academia\u00a0\u2026", "num_citations": "27\n", "authors": ["639"]}
{"title": "Existing approaches to software integration\u2013and a challenge for the future\n", "abstract": " This paper analyzes three fields of practice and research from a software integration perspective: component-based software, standard interfaces and open systems, and Enterprise Application Integration (EAI). The circumstances under which each is applicable are presented, as well as the expected benefits and drawbacks seen from the integrator\u2019s perspective. The paper concludes with describing an integration context encountered in practice that challenges the established approaches, and outlines future research from there.", "num_citations": "27\n", "authors": ["639"]}
{"title": "Ten tips to succeed in global software engineering education\n", "abstract": " The most effective setting for training in Global Software Engineering is to provide a distributed environment for students. In such an environment, students will meet challenges in recognizing problems first-hand. Teaching in a distributed environment is, however, very demanding, challenging and unpredictable compared to teaching in a local environment. Based on nine years of experience, in this paper we present the most important issues that should be taken into consideration to increase the probability of success in teaching a Global Software Engineering course.", "num_citations": "25\n", "authors": ["639"]}
{"title": "Technology transfer: why some succeed and some don't\n", "abstract": " In this paper we present several technology transfer cases both successes and failures. These cases describe transfers from research department within a large corporation to a product company, university to a large product company and university to a small product company. Based on the analysis of these cases we outline several strategies that can be used, in isolation or combined, in order to increase the probability for success.", "num_citations": "25\n", "authors": ["639"]}
{"title": "System development with real-time components\n", "abstract": " Component-based Software Engineering is a promising approach to improve quality, to achieve shorter time to market and to manage the increasing complexity of software. Still there are a number of unsolved problems that hinder wide use of it. This is especially true for real-time systems, not only because of more rigorous requirements and demanding constraints, but also because of lack of knowledge how to implement the component-based techniques on real-time development. In this paper we present a method for development of real-time systems using the component-based approach. The development process is analyzed with respect to both temporal and functional constraints of real-time components. Furthermore, we propose what information is needed from the component providers to successfully reuse binary real-time components. Finally, we discuss a possibility of managing compositions of components. 1 Introduction Component-based Software Engineering (CBSE)[15] is benecial to obtain faster...", "num_citations": "25\n", "authors": ["639"]}
{"title": "Component-based software engineering\n", "abstract": " \u2022 The size & complexity of software increases rapidly\u2022 Single products become part of product families\u2022 Software is upgraded after deployment\u2022 Applications must be built from components that were never intended to work together.\u2022 The time-to-market must decrease significantly\u2022 The cost of products must be reduced", "num_citations": "23\n", "authors": ["639"]}
{"title": "CDB Process\n", "abstract": " When designing and developing software systems, there are several challenges that have to be addressed such as complexity, change management and system integrity. Trends in development processes, programming languages and software design are constantly changing. New programming paradigms have succeeded each other while the software systems have grown larger and more difficult to maintain. Component-oriented thinking provides the opportunity to re-use pre-fabricated parts to assemble software systems from tested building blocks, facilitating a rapid and consistent software development process. A component-oriented approach, however, affects both the life cycle and the development process of a software system. Therefore, a new way of viewing the life cycle as well as the development process for component-based software systems is presented in this thesis.A key issue when using a component-oriented approach is to consider both behavioral and static aspects of a software system. Furthermore, we need to be able to analyze the architecture of the enterprise as well as the software system architecture to deliver business value with information systems. System interdependencies will be placed in the foreground when integrating technical and organizational aspects of the information system. We therefore need a modeling technique suitable for focusing on semantic aspects rather than implementation-dependent issues. A suitable modeling technique is the Enterprise Modeling approach.", "num_citations": "23\n", "authors": ["639"]}
{"title": "Collaboration patterns in distributed software development projects\n", "abstract": " The need for educating future software engineers in the field of global software engineering is recognized by many educational institutions. In this paper we outline the characteristics of an existing global software development course run over a period of nine years, and present a flexible project framework for conducting student projects in a distributed environment. Based on data collected from fourteen distributed student projects, a set of collaboration patterns is identified and their causes and implications described. Collaboration patterns are a result of the analysis of collaboration links within distributed student teams, and can assist teachers in better understanding of the dynamics found in distributed projects.", "num_citations": "22\n", "authors": ["639"]}
{"title": "Processing requirements by software configuration management\n", "abstract": " Short development life cycles, the importance of time-to-market and fast changes in technology influence the requirements engineering process. Requirements are exposed to changes during the entire development life cycle, and decisions related to requirements and system design are moving toward developers. For this reason it is important to keep requirement changes under control during the entire development process. This control can be achieved by utilizing Configuration Management (CM) functions and in particular Change Management. This paper describes a model for managing requirements using CM functions. A requirements specification is defined as an hierarchic structure, in which elements of the structure are isolated requirements designated Requirements Specification Items. Having items under version control it is possible to get a better overview of the requirements change process. In the\u00a0\u2026", "num_citations": "22\n", "authors": ["639"]}
{"title": "Software product integration: A case study-based synthesis of reference models\n", "abstract": " In software intensive systems the integration becomes complex since both software and hardware components are integrated and run in the execution environment for the first time. Support for this stage is thus essential. Practices for Product Integration are described in different reference models. We have investigated these and compared them with activities performed in seven product development projects.Our conclusion is that descriptions of best practices in product integration are available in different reference models, but need to be merged into one set of practices. Through case studies we see that the described practices are insufficiently used in industry, and that organizations would benefit from adhering to them. Our investigations indicate that a set of practices are necessary to be successful in software product integration: define and check criteria for integration, review interface descriptions and ensure\u00a0\u2026", "num_citations": "21\n", "authors": ["639"]}
{"title": "Classification and survey of component models\n", "abstract": " As component-based software engineering is growing and its usage expanding, more and more component models are developed. In this report we present a survey of software component models in which models are described and classified respecting the classification framework for component models proposed by CrnkoviA   et. al. [1]. This framework specifies several groups of important principles and characteristics of component models: lifecycle, constructs, specification and management of extra-functional properties, and application domain. This report analyzes a considerable amount of component models, including widely used industrial models, as well as research models.", "num_citations": "21\n", "authors": ["639"]}
{"title": "Information Management for Multi-Technology Products\n", "abstract": " Software (SW) is an increasingly important part of many types of products. Companies designing and producing mechanical and hardware products have problems integrating the mechanics and hardware design process with the software design process. The different requirements for the information used and the use of separate information systems makes information management a difficult task. Therefore, many companies are facing a strong need to integrate both the processes and the information systems. This paper describes the processes and discusses their information need. An integration is proposed, from a process, information and tool perspective.", "num_citations": "21\n", "authors": ["639"]}
{"title": "Component configuration management\n", "abstract": " Component-based programming is nowadays widely recognized approach in software development. Still there are many open problems related to both technical and non-technical aspects of the components. In this paper, we point out the problem of component identification. Since the components are usually binary units deployed in the system at run-time, we do not have the same insight to their characteristics as for software units that we manage at development time. This problem could be solved if the components had built in this information together with the binary code, which can be achieved by defining a standardized identification interface. As such interfaces do not exist in standard component models today, this concept is possible to use only with components built in-house. For external components, extensive tests can, to some extent, compensate the lack of information. To perform an efficient and yet a successful testing we must limit the number of test cases. Which parts of our system can be affected by introduction of a component, or by its updating? We can answer this if we can keep track of changes introduced in the system and their impact on the system. These problems are similar to the problems at development-time solved by Software Configuration Management (SCM) disciplines. In this paper we point out these problems and make proposals for their utilization at run-time using SCM principles.", "num_citations": "21\n", "authors": ["639"]}
{"title": "An extended model for multi-criteria software component allocation on a heterogeneous embedded platform\n", "abstract": " A recent development of heterogeneous platforms (ie those containing different types of computational units such as multicore CPUs, GPUs, and FPGAs) has enabled significant improvements in performance for real-time data processing. This potential, however, is still not fully utilized due to the lack of methods for optimal configuration of software; the allocation of different software components to different computational unit types is crucial for getting the maximal utilization of the platform, but for more complex systems it is difficult to find ad-hoc a good enough or the best configuration. With respect to system and user defined constraints, in this paper we are applying analytical hierarchical process and a genetic algorithm to find feasible, locally optimal solution for allocating software components to computational units.", "num_citations": "20\n", "authors": ["639"]}
{"title": "On the teaching of distributed software development\n", "abstract": " As the software industry moves towards software development projects involving several sites around the world, universities should incorporate this trend into their software engineering curricula. We describe the experiences from the development of a university course in distributed software development. Some of the problems of distributed development make it inherently difficult to transfer this domain to the university environment. Also, the concept of \"distribution \" has penetrated not only the contents of the course but many other levels as well.", "num_citations": "20\n", "authors": ["639"]}
{"title": "Experience with Change-oriented SCM tools\n", "abstract": " In the recent years two approaches in Software Configuration Management (SCM) tools have been emphasized: a Change-oriented model and a Version-model approach. This paper gives an overview of two Change-oriented SCM tools developed at ABB Industrial Systems and describes the experience with their usage. The first tool is strictly change-oriented and it requires formal consistency of the entire software system. The second one is more pragmatic and less formal. It uses both Version and Change approach. The experience shows that a tool that supports a Change Management is very important in large software systems, especially in the verification and maintenance phase. Change Management is not only used as a part of a SCM tool, but in the entire development/maintenance process; in planning, producing release documentation, etc. However, a usage of a strictly change-oriented tool has\u00a0\u2026", "num_citations": "20\n", "authors": ["639"]}
{"title": "Continuous experimentation on cyber-physical systems: challenges and opportunities\n", "abstract": " Establishing and mastering continuous experimentation as an instrument in the portfolio of software product managers is of growing importance resulting in continuous renewal of products for continuous user satisfaction. Product managers for purely software-based products like web-based applications found in online web-shops or smartphone apps can monitor usage profiles of their products in the context of their customers' usage (ie the\" field\"). However, in the area of interconnected embedded systems, cyber-physical systems, or with Internet-of-Things (IoT), such continuous experimentation is under-explored and in many cases understandably not considered due to safety considerations. In this position paper, we are outlining challenges and opportunities of continuous experimentation for cyber-physical systems.", "num_citations": "19\n", "authors": ["639"]}
{"title": "Partitioning decision process for embedded hardware and software deployment\n", "abstract": " Many types of embedded systems applications are implemented as a combination of software and hardware. For such systems the mapping of the application units into hardware and software, i.e. the partitioning process, is a key phase of the design. Although there exist techniques for partitioning, the entire process, in particular in relation to different application requirements and project constraints, is not properly supported. This leads to several unplanned iterations, redesigns and interruptions due to uncontrolled dependencies between hardware and software parts. In order to overcome these problems, we provide a design process that enables the partitioning based on a multiple criteria decision analysis in a late design phase. We illustrate the proposed approach and provide a proof-of concept on an industrial case study to validate the approach applicability.", "num_citations": "18\n", "authors": ["639"]}
{"title": "15 years of CBSE symposium: impact on the research community\n", "abstract": " In 2012, the International Symposium on Component-based Software Engineering (CBSE) is being organized for the 15th time. This is a great opportunity to take a step back and reflect on the impact of the symposium over these 15 years. Several interesting questions immediately come to mind: What were the main topics of interest in the community? What is the maturity of the field? What is the research CBSE Symposia impact? Who are the mots involved researches and researchers centers? In order to answer these questions we have performed a systematic review of 318 papers published under CBSE. In this paper we provide answers about the impact of the event, list and categorize the most frequent topics, and give some statistical data about the event during this period.", "num_citations": "18\n", "authors": ["639"]}
{"title": "Quality attribute support in a component technology for vehicular software\n", "abstract": " The electronics in vehicles represents a class of systems where quality attributes, such as safety, reliability, and resource usage, leaven all through development. Vehicular manufacturers are interested in developing their software using a component based approach, supported by a component technology, but commercial component technologies are too resource demanding, complex and unpredictable. In this paper we provide a vehicular domain specific classification of the importance of different quality attributes for software, and a discussion of how they could be facilitated by a component technology. The results can be used as guidance and evaluation for research aiming at developing component technologies suitable for vehicular systems.", "num_citations": "18\n", "authors": ["639"]}
{"title": "Client-side web application slicing\n", "abstract": " Highly interactive web applications that offer user experience and responsiveness of standard desktop applications are becoming prevalent in the web application domain. However, with these benefits come certain drawbacks. For example, the event-based architectural style, and poor support for code organization, often lead to a situation where code responsible for a certain behavior is intermixed with irrelevant code. This makes development, debugging and reuse difficult. One way of locating code implementing a certain behavior is program slicing, a method that, given a subset of a program's behavior, reduces the program to a minimal form that still produces that behavior. In this paper we present a semi-automatic client-side web application slicing method, describe the web page dependency graph, and show how it can be used to extract only the code implementing a certain behavior.", "num_citations": "17\n", "authors": ["639"]}
{"title": "Software configuration management\n", "abstract": " Software Configuration Management (SCM) concerns the control of the evolution of complex software systems.CM is one of the most successful Software Engineering research fields with respect to acceptance in the industry.Almost any development organization that releases software applications and/or supplies complete software intensivesystems, can only survive with the right attention to Configuration Management. The importance of SCM is alsoaddressed by software process improvement models, such as CMM, CMMI and SPICE, in which SCM processes playa major role in achieving an initial level of maturity.During the last three decades, SCM has emerged towards a mature Software Engineering discipline. During theseyears, several topics in SCM have been researched and their results are currently common in the available SCM tools.Software development is changing, which implies that aspects of SCM\u00a0\u2026", "num_citations": "16\n", "authors": ["639"]}
{"title": "Is software engineering training enough for software engineers?\n", "abstract": " Most software engineering courses focus exclusively on the software development process, often referring to problems related to the complexity of software products and processes. In practice, however, many problems of a complex nature arise in which system engineering and other engineering disciplines are important in the development of systems. In such cases software engineers may have difficulty in coping with the entire problem, in the same way that engineers in other fields may have difficulty in understanding the software part. This suggests that the software engineering education of today is inadequate in certain respects. This paper presents a case study of a software engineering course and discusses the difficulty for computer science students to understand and to develop a system which also requires skills in engineering of a non-software nature.", "num_citations": "16\n", "authors": ["639"]}
{"title": "Student motivation in distributed software development projects\n", "abstract": " In this paper we discuss challenges faced in conducting distributed student projects within a scope of a distributed software development university course. Student motivation and demotivation factors, along with perceived cultural differences, are identified and analyzed on the basis of data collected from a number of student projects.", "num_citations": "15\n", "authors": ["639"]}
{"title": "Avoiding scylla and charybdis in distributed software development course\n", "abstract": " Teaching Distributed Software Development (DSD) is a challenging task. A convincing simulation of distributed environment in a local environment is practically impossible. Teaching DSD in distributed environment is more realistic since the students directly experience all its specifics. However, teaching in distributed environment, in which several geographically separated teams participate, is very demanding. Different types of obstacles occur, from administrative and organizational to technical ones. This paper describes some of the challenges, lessons learned, but also success stories of the DSD course performed now eight year in a row.", "num_citations": "15\n", "authors": ["639"]}
{"title": "A model for reuse and optimization of embedded software components\n", "abstract": " In software engineering for embedded systems generic reusable software components must often be discarded in favor of using resource optimized solutions. In this paper we outline a model that enables the utilization of component-based principles even for embedded systems with high optimization demands. The model supports the creation of component variants optimized for different scenarios, through the introduction of an entrance preparation step and an ending verification step into the component design process. These activities are proposed to be supported by tools working on metadata associated with components, where the metadata is possible to automatically retrieve from many development tools. This paper outlines the theoretical model that is the basis for our current realization work.", "num_citations": "14\n", "authors": ["639"]}
{"title": "Process patterns for software systems in-house integration and merge-experiences from industry\n", "abstract": " When an organization faces new types of collaboration, for example after a company merger, there is a need to integrate the existing software. Two main process challenges are how to arrive at a realistic vision of a future integrated system, and how to actually carry out the integration process. We have performed a multiple case study, consisting of 9 cases. This paper presents the observations made in the form of recurring patterns that can be used as recommendations for other organizations facing the same challenge. Also discussed are the similarities and differences between already known software process best practices and the integration patterns found.", "num_citations": "14\n", "authors": ["639"]}
{"title": "Modelling for hardware and software partitioning based on multiple properties\n", "abstract": " In many embedded systems types the separation process for deploying the applications as software and hardware executable units, called partitioning is crucial. This is due to the fact that partitioning decisions impact the overall life cycle of the systems. In industry it is common practice to take partitioning decisions in an early stage of the design, based on hardware and software designers expertise. We propose a new methodology as a combination of model based and component-based approaches which enables a late partitioning decisions based on high level system requirements and project constrains. The final partitioning is decided based on a multi-property analysis approach. Here, we focus on the formalization of the overall process and in particular on the definition of a comprehensive system metamodel. This is meant to support modelling approaches suitable for enabling both the partitioning and reuse\u00a0\u2026", "num_citations": "13\n", "authors": ["639"]}
{"title": "Using prediction enabled technologies for embedded product line architectures\n", "abstract": " Predicting the behavior of a product before it is built has been a long time struggle, especially for software based systems. For building software systems there are few methods that comply with the engineering methods established from physics where properties of construction can be determined before the actual assembly of a product. By taking the predictable assembly from certifiable components (PACC) approach our intention is define methods to predict certain properties. We conclude that product line architectures that build on top of a component technology can be build in a much more controlled way if the component technology is prediction enabled. The aim of this position paper is to investigate how embedded product line architectures can utilize a prediction enabled component technology to build products with known properties. We present a framework where we can reason about extra-functional properties in a uniformed way. We illustrate our approach by an example including several different extra-functional properties.", "num_citations": "13\n", "authors": ["639"]}
{"title": "Component models for reasoning\n", "abstract": " The world of component-based systems is as appealing as it is challenging. Components, as first-class citizens of component-based systems, serve as the main units of encapsulated functionality and also units of composition, with the intention to improve development efficiency and software quality through reusability, extensibility and analyzability of software. These benefits are obtained especially when the components are understood by means of a formally well-defined component model, amenable to effective reasoning on functional and extra-functional properties at unit- as well as system-level. In this article we present the basic concepts of component-based design, emphasizing the characteristics of different types of component compositions, which dictate particular trade-offs between the degree of assurance and design flexibility. We show that rich and semantically well-defined component models with\u00a0\u2026", "num_citations": "12\n", "authors": ["639"]}
{"title": "Software component evaluation: A theoretical study on component selection and certification\n", "abstract": " Software components need to be evaluated at several points during their life cycle, by different actors and for different purposes. Besides the quality assurance performed by component developers, there are two main activities which include evaluation of components: component selection (ie evaluation performed by the system developer in order to select the best fit component to use in a system) and an envisioned component certification (ie evaluation made by an independent actor in order to increase the trust in the component). This paper examines the fundamental similarities and differences between these two types of component evaluations and elaborates how these fit in the overall process views of component-based development for both COTS-based development and software product line development.", "num_citations": "12\n", "authors": ["639"]}
{"title": "On the expected synergies between component-based software engineering and best practices in product integration\n", "abstract": " The expectations for a well working integration process are described in the Capability Maturity Model Integration (CMMI). Often during the integration process, weaknesses of the entire development process become visible. This is usually too late and too costly. Particular development processes and use of particular technologies may help to improve the performance of the integration process by providing proper input to it. For example, by the use of a component-based approach, the development process changes. Some of these changes may help in performing according to the process expectations. In This work, examples of problems that have been observed in the integration process are described. Through a case study we describe a number of practical problems in current development projects. Based on this case study, we analyze how a component-based approach could help and lead to a more effective\u00a0\u2026", "num_citations": "12\n", "authors": ["639"]}
{"title": "Classification of quality attributes for predictability in component-based systems\n", "abstract": " One of the main objectives of developing component-based software systems is to enable integration of components which are perceived as black boxes. While the construction part of the integration using component interfaces is a standard part of all component models, the prediction of the quality attributes of the component compositions is not fully developed. This decreases significantly the value of the component-based approach to building dependable systems. This paper classifies different types of relations between the quality attributes of components and those of their compositions. The types of relations are classified according to the possibility of predicting the attributes of compositions from the attributes of the components and according to the impacts of other factors such as system environment or software architecture. Such a classification can indicate the efforts which would be required to predict the system attributes that are essential for system dependability and in this way, the feasibility of the component-based approach in developing dependable systems.", "num_citations": "12\n", "authors": ["639"]}
{"title": "Complex systems development requirements-PDM and SCM integration\n", "abstract": " Software is being increasingly incorporated into increasingly extensive industrial and other applications. There is a demand for total control of entire applications including their software components. As a consequence, the development procedure, production operations and maintenance, previously separate processes, are being integrated in comprehensive process systems. In the integration of these processes, many difficulties are encountered because of the different natures of the processes and the different approaches made to the problem. In the integration process, many activities overlap and much data is duplicated, thus making a complex process even more complex. software configuration management (SCM) and product data management (PDM) which are used to solve similar problems in different ways are examples of overlapping processes. Attempts to integrate SCM and PDM systems to obtain a\u00a0\u2026", "num_citations": "12\n", "authors": ["639"]}
{"title": "Reuse, validation and verification of system development processes\n", "abstract": " Large companies often use standardized template development processes. Project-specific adaptation of templates must address aspects such as: project resources (time/staff), standards, regulations, etc. Adapting templates is a particularly manual process requiring skill and for large companies represents a large proportion of the total development cost. Integrating locally gained experience and updating the template process is tedious work and resources for such updates are rarely available. Fortunately, formal representation of processes and process components enables reuse, analysis and comparison of processes and parts of processes. We use a case-based reasoning (CBR) approach which permits identification and reuse of processes or parts of processes. The formal notation allows the user to sketch new processes or adapt template processes. These sketches/adaptations are used in a matching\u00a0\u2026", "num_citations": "12\n", "authors": ["639"]}
{"title": "Towards a methodology for hardware and software design separation in embedded systems\n", "abstract": " Development of embedded systems in automation industry often includes development of both software and hardware, which requires both software and hardware expertise. In the current practice these expertise are not often completely combined in synergic ways. Traditionally, design gets separated into hardware design and software design at very early stage which negatively impacts the overall application development process due to design flow interruption and redesign. In order to overcome to the aforementioned problems, this paper presents a new design methodology that provides platform independent design first, and pushes hardware-and software-dependent design to a later stage. This enables \u201csoftware-independent\u201d hardware and \u201chardware-independent\u201d software development after the separation stage, which collectively improve the overall development process.", "num_citations": "11\n", "authors": ["639"]}
{"title": "Key elements of the product integration process\n", "abstract": " The integration phase represents a highly critical part of the product development process as components are combined and should work together. Errors and problems in product integration result in delays and rework as the results are needed for later phases. Standards and other reference models that include guidelines for product integration are available, but are not always used.Our proposal is that is that the current descriptions in standards and reference models are insufficient and need to be consolidated to help development organizations improve the product integration process. The presented research includes a number of case studies and analyses that have resulted in a superset of practices, ie a combination of the activities included in the different reference models. Through the case studies performed in seven different product development organizations, a connection between problems that are observed and the failure to follow the recommendations is identified.", "num_citations": "11\n", "authors": ["639"]}
{"title": "Verifying the correctness of component-based applications that support business processes\n", "abstract": " Developing applications that properly support the enterprise is a difficult task. Failing to perform this task results in applications that are not accepted by the end-users and that frustrate daily conduct of business. In this paper we introduce a formal yet practical method that helps to design componentbased applications that properly support the enterprise. The method can be used to verify whether the behavior of an application conforms to the behavior of the enterprise, where the behavior of the enterprise is specified in the form of business processes. The method helps to avoid applications being designed that support the enterprise in an incorrect manner.", "num_citations": "11\n", "authors": ["639"]}
{"title": "Development experiences of a component-based system\n", "abstract": " Building software systems with reusable components brings many advantages. If the reuse concept is utilized on several levels of a system development, the development becomes more efficient, the reliability of the products is enhanced, and the maintenance requirement is significantly reduced. The levels of reuse are spread out from the reuse of source code and common libraries, through the reuse of large business components, up to the reuse of the standard products in the configuration of large systems. Designing, developing and maintaining components for reuse is, however, a very complex process which places high requirements not only for the component functionality and flexibility, but also for the development organization. In this paper, we discuss the different levels of component reuse, and certain aspects of component development. As an illustration of reuse issues, we present a successful\u00a0\u2026", "num_citations": "11\n", "authors": ["639"]}
{"title": "Change Measurements in an SCM process\n", "abstract": " An SCM database contains data which can be used as input for Software Metrics. Both data for Size-Oriented Metrics, and information for Process-Oriented Metrics are available from SCM systems. This paper describes measurements taken from an SCM database used at ABB Industrial Systems. The SCM tool is change-oriented and collects information about changes in Change Request (CR) documents. As CRs are under version control, the measurements taken on them give information not only about the amount and type of changes but also about the change process behavior. The measurements, generated from CRs by a tool, are used during the development process and in the final analysis of the project. The paper presents some of the measurements showing typical cases of lifecycle models.", "num_citations": "11\n", "authors": ["639"]}
{"title": "A review on software architectures for heterogeneous platforms\n", "abstract": " The increasing demands for computing performance have been a reality regardless of the requirements for smaller and more energy efficient devices. Throughout the years, the strategy adopted by industry was to increase the robustness of a single processor by increasing its clock frequency and mounting more transistors so more calculations could be executed. However, it is known that the physical limits of such processors are being reached, and one way to fulfill such increasing computing demands has been to adopt a strategy based on heterogeneous computing, i.e., using a heterogeneous platform containing more than one type of processor. This way, different types of tasks can be executed by processors that are specialized in them. Heterogeneous computing, however, poses a number of challenges to software engineering, especially in the architecture and deployment phases. In this paper, we conduct an\u00a0\u2026", "num_citations": "10\n", "authors": ["639"]}
{"title": "Towards guidelines for a development process for component-based embedded systems\n", "abstract": " Software is more and more built from pre-existing components. This is true also for the embedded software domain, and there is a need to consider how development processes need to be changed to best utilize the component-based paradigm, and how processes and technologies must be designed to support each other. To facilitate this change towards component-based embedded software, this paper presents a set of process guidelines, named the Progress Process Guidelines (PPG), which is based on the structure of CMMI. This paper presents the structure of the PPG, and presents and analyzes the PPG parts which most closely relate to system verification, which is typically an important and difficult activity for embedded software.", "num_citations": "10\n", "authors": ["639"]}
{"title": "6th ICSE workshop on component-based software engineering: Automated reasoning and prediction\n", "abstract": " This report gives an overview of the 6th ICSE Workshop on Component-Based Software Engineering held at 25th International Conference on Software Engineering. The workshop brought together researchers and practitioners from three communities: component technology, software architecture, and software certification. The primary goal of the workshop was to continue clarifying the concepts, identifying the main challenges and findings of predictable assembly of certifiable software components. This report gives a comprehensive summary of the position papers, of the workshop, its findings, and its results.", "num_citations": "10\n", "authors": ["639"]}
{"title": "Combining models for business decisions and software development\n", "abstract": " Today there is a number of established software development lifecycle models (SDLM) supporting software development. Correct implementation of these models helps develop software products the right way, but this does not ensure that the right products are developed. Successful product development companies often use business decision models (BDM) to facilitate the selection of products and projects for investment, but these models do not necessarily facilitate actual development of the software. One of the current challenges in the software community is to combine BDM and SDLM, including mapping of business decision gates and major lifecycle milestones. This is needed to achieve synergies between the two model types and to support the development the right products the right way, as well as to gain control over company investments. This paper analyzes two RDM, proposes mappings to an\u00a0\u2026", "num_citations": "10\n", "authors": ["639"]}
{"title": "Managing complex systems-challenges for PDM and SCM\n", "abstract": " Within the industry there is a need of controlling the whole product development process including both hardware and software components. The integration of development processes meets many problems partially because of the different nature of the processes and partially because of the different approaches. A typical example of overlapping processes is Software Configuration Management (SCM) and Product Data Management (PDM). Both SCM and PDM try to solve similar problems but in different ways. To get a more efficient development process, the companies try to integrate PDM and SCM systems, which has not yet been very successful.This paper gives a brief overview of common characteristics of SCM and PDM and gives an analysis of a possible integration. An example of an early attempt of integration is depicted. Finally the paper presents an initiative by the Swedish industry to provide better understanding of SCM and PDM integration problems and to give directions for the possible integrations.", "num_citations": "10\n", "authors": ["639"]}
{"title": "An extensible framework for software configuration optimization on heterogeneous computing systems: Time and energy case study\n", "abstract": " Context: Application of component based software engineering methods to heterogeneous computing (HC) enables different software configurations to realize the same function with different non\u2013functional properties (NFP). Finding the best software configuration with respect to multiple NFPs is a non\u2013trivial task.Objective: We propose a Software Component Allocation Framework (SCAF) with the goal to acquire a (sub\u2013) optimal software configuration with respect to multiple NFPs, thus providing performance prediction of a software configuration in its early design phase. We focus on the software configuration optimization for the average energy consumption and average execution time.Method: We validated SCAF through its instantiation on a real\u2013world demonstrator and a simulation. Firstly, we verified the correctness of our model through comparing the performance prediction of six software configurations to\u00a0\u2026", "num_citations": "9\n", "authors": ["639"]}
{"title": "Green HPC: MPI vs. OpenMP on a shared memory system\n", "abstract": " A power consumption of a high performance computer (HPC) system has been an issue lately. Many programming techniques are still relying on performance gain, but only few of them are concerning energy footprint of the increased computing power. MPI and OpenMP are considered as a core scientific HPC programming libraries for distributed-memory and shared-memory computer systems respectively. Each of them brings performance when used on a parallel system, but there are dissimilarities in their performance per watt ratio. The key is to find the best appliance for each of them on a shared-memory computer system.", "num_citations": "9\n", "authors": ["639"]}
{"title": "Towards efficient software component evaluation: an examination of component selection and certification\n", "abstract": " When software systems incorporate existing software components, there is a need to evaluate these components. Component evaluation is of two kinds according to literature: component certification is performed by an independent actor to provide a trustworthy assessment of the component\u00bfs properties in general, and component selection is performed by a system development organization. While this principle is in general understood, in practice the certification process is neither established nor well defined. This paper outlines the relationship between the evaluations performed during certification and selection. We start from the current state of practice and research and (a) propose a component-based life cycle for COTS-based development and software product line development, (b) identify a number of differences in process characteristics between the two types of evaluation, and (c) classify concrete quality\u00a0\u2026", "num_citations": "9\n", "authors": ["639"]}
{"title": "Architectural reuse in software systems in-house integration and merge\u2013experiences from industry\n", "abstract": " When organizations cooperate closely, for example after a company merger, there is typically a need to integrate their in-house developed software into one coherent system, preferably by reusing from all of the existing systems. The parts that can be reused may be arbitrarily small or large, ranging from code snippets to large self-containing components. Not only implementations can be reused however; sometimes it may be more appropriate to only reuse experiences in the form of architectural solutions and requirements. In order to investigate the circumstances under which different types of reuse are appropriate, we have performed a multiple case study, consisting of nine cases. Our conclusions are, summarized: reuse of components from one system requires reuse of architectural solutions from the same system; merge of architectural solutions cannot occur unless the solutions already are similar, or\u00a0\u2026", "num_citations": "9\n", "authors": ["639"]}
{"title": "Integration of software systems-process challenges\n", "abstract": " The assumptions, requirements, and goals of integrating existing software systems are different compared to other software activities such as maintenance and development, implying that the integration processes should be different. But where there are similarities, proven processes should be used. We analyze the process used by a recently merged company, with the goal of deciding on an integration approach for three systems. We point out observations that illustrate key elements of such a process, as well as challenges for the future.", "num_citations": "9\n", "authors": ["639"]}
{"title": "Software components and COTS in software system development\n", "abstract": " The component-based software engineering, CBSE, approach emphasize on acquisition and integration of components to accomplish complex and large-scale software solutions. Benefits from using a CBSE approach include, system quality improvement, shorter time-to-market, and improved management of complexity of software. However, the focus of development move to issues like selection, integration, evaluation and evolution of components in the system. Underestimating the technical risks associated with selection, evaluation, and integration of software components can result in long schedule delays and high development/maintenance cost.This report introduces basic concepts of CBSE and Commercial-off-the-shelf, COTS, components. Driving factors for the use of COTS components are presented together with potential benefits and key issues to consider in order to successfully adapt to a CBSE approach. The intent is also to point out possible risks that are typically not present when developing traditional, non-CBSE, software systems. Specifically the basic CBSE issues of system reliability, development process, and real-time system development are presented.", "num_citations": "9\n", "authors": ["639"]}
{"title": "Implementation of a software engineering course for computer science students\n", "abstract": " Experience from industry shows that graduates in computer science generally lack many of the skills required in software development projects. This presents a challenge to academic institutions. We describe our experiences in implementing a course in software engineering at a Swedish university. A set of challenges is presented and it is described how these were met using a combination of lectures and project work. The results of the projects, the lessons we have learned, and the feedback from the students are discussed.", "num_citations": "9\n", "authors": ["639"]}
{"title": "State of the practice: Component-based software engineering course\n", "abstract": " Component-based development has many potential advantages such as shorter time to market and lower prices. These advantages are especially attractive for customers, who often do not recognize the risks of lower reliability, possible problems with maintenance, etc. Many software companies are forced to use imported components in their products, but are not able to keep the development process under control. Component-based development is still a process with lot of problems, not well defined either from theoretical or practical points of view. The lack of knowledge is probably the biggest problem and the need for component-based software engineering (CBSE) is urgent. This was the motivation to a company and a university to organize a Ph. D. course on CBSE. Both Ph. D. students and practitioners from the industry participated in the course. The aim of the course was to increase the knowledge and understanding of CBSE, and to analyze the needs for software components in different engineering areas. The course consisted of lectures, seminars and student reports on chosen CBSE topics. This paper describes the course, gives an overview of the reports, and discusses the course result.", "num_citations": "9\n", "authors": ["639"]}
{"title": "Architecture optimization: speed or accuracy? both!\n", "abstract": " Embedded systems are becoming more and more complex, thus demanding innovative means to tame their challenging development. Among others, early architecture optimization represents a crucial activity in the development of embedded systems to maximise the usage of their limited resources and to respect their real-time requirements. Typically, architecture optimization seeks good architecture candidates based on model-based analysis. Leveraging abstractions and estimates, this analysis usually produces approximations useful for comparing architecture candidates. Nonetheless, approximations do not provide enough accuracy in estimating crucial extra-functional properties. In this article, we provide an architecture optimization framework that profits from both the speed of model-based predictions and the accuracy of execution-based measurements. Model-based optimization rapidly finds a\u00a0\u2026", "num_citations": "8\n", "authors": ["639"]}
{"title": "Inclusion of ethical aspects in multi-criteria decision analysis\n", "abstract": " Decision process is often based on multi-faceted and mutually opposing criteria. In order to provide rigorous techniques for problem structuring and criteria aggregation used for classification and ranking of alternatives, Multiple Criteria Decision Analysis (MCDA) has been used as a method to achieve architectural decisions. Even though it has already been argued in literature that MCDA essentially depends on value systems of decision-makers, it is a question how the decision result reflects a particular criterion, requirement or a particular decision. This is especially true if a criterion is not precisely specified. In this paper we analyse the ethical aspects of MCDA. In our analysis we argue that it is in the long run necessary to make value basis of decision-making and ethical considerations explicit and subject for scrutiny. As a support to encourage introduction of transparent value-based deliberation we propose an\u00a0\u2026", "num_citations": "8\n", "authors": ["639"]}
{"title": "Using UML for domain-specific component models\n", "abstract": " Over the recent years there is a tendency for using domain-specific languages which enable expressing design solutions in the idiom and level of abstraction appropriate for a specific problem domain. While this approach enables an efficient and accurate design, it suffers from problems of standardization, portability and transformation between the models. This paper addresses a challenge of tailoring UML, a widely used modelling language, for domain specific modelling. We discuss a possible solution for achieving interoperability between UML and the domain-specific language SaveComp Component Model (SaveCCM) intended for real-time embedded systems, by means of implementing a transformation between UML and SaveCCM models. The challenge of the transformation is to keep all necessary information including the domain specific semantics. The paper presents the strategy for the transformation, its implementation and an analysis. We also address the second challenge, a usability of the domain-specific language (ie SaveCCM) in comparison with usability of extended UML and by an experiment analyse its usability in comparison with SaveCCM.", "num_citations": "8\n", "authors": ["639"]}
{"title": "Case study: Componentization of an industrial control system\n", "abstract": " When different business units of an international company are responsible for the development of different parts of a large system, a component-based software architecture may be a good alternative to more traditional, monolithic architectures. The new common control system, developed by ABB to replace several existing control systems, must incorporate support for a large number of I/O systems, communication interfaces, and communication protocols. An activity has therefore been started to redesign the system's architecture, so that I/O and communication components can be implemented by different development centers around the world. This paper reports on experiences from this. effort, describing the system, its current software architecture, the new component-based architecture, and the lessons learned so far.", "num_citations": "8\n", "authors": ["639"]}
{"title": "The Different Aspects of Component Based Software Engineering\n", "abstract": " More and more systems are developed from components instead of from scratch. Reusing components has many advantages: The development time dramatically decreases, the usability of the products increases, the production costs usually decrease, and so on. However, there is a big difference between a \u201cclassic\u201d and component-based development, and there are many pitfalls which may lead to an unsuccessful result. A lot of difficult issues and aspects of Component Based Software Engineering (CBSE) have to be investigated to develop good component-based products. Still there is no established development process which will guarantee a proper treatment of components. This paper elaborates on some of those different aspects of CBSE and gives advise to developers working with component technologies. In particular the component identification problem is discussed, relation between the object-oriented and the component development, and the different phases in the component-based development process. Certain proposals for improvements of the process are given.", "num_citations": "8\n", "authors": ["639"]}
{"title": "A change process model in an SCM tool\n", "abstract": " The paper is a survey of a change process model developed and used at ABB Industrial Products. The change process is based on a software configuration management (SCM) tool and the capability maturity model (CMM). CMM emphasizes the importance of controlling the changes made in a development project. The SCM tool, developed at ABB Industrial Products, is a change oriented tool, by means of which changes are managed through change requests. A change request is a document which describes changes processed in a software. During the development process, change requests collect information about the changes implemented in configuration items and they pass through different states. Since change requests are under version control, the data obtained from them give information about both the number and types of changes and the change process behavior. Experience has shown which an\u00a0\u2026", "num_citations": "8\n", "authors": ["639"]}
{"title": "Predictability and evolution in resilient systems\n", "abstract": " This paper gives a short overview of the talk related to the challenges in software development of resilient systems. The challenges come of the resilience characteristic as such; it a system emerging lifecycle property, neither directly measurable nor computable. While software is an essential part of a system, its analysis not enough for determining the system resilience. The talk will discuss about system resilience reasoning, its limitations, and possible approaches in the software design that include resilience analysis.", "num_citations": "7\n", "authors": ["639"]}
{"title": "Performing a project in a distributed software development course: lessons learned\n", "abstract": " Distributed software development approaches have to face with several issues like cultural differences, collaboration and communication mechanisms, which can undermine the overall development success if not handled in a proper manner. In order to provide a real environment for students placed in different countries to learn and apply the best practices in distributed software development, a course has been developed jointly by two european universities. The course aims at providing the students an insight in the complexity of distributed development and giving the possibility to work in distributed teams for actual implementations, in order to minimize the gap between theory and practice. This paper describes the course design, challenges, results and success factors, from a students perspective.", "num_citations": "7\n", "authors": ["639"]}
{"title": "A prototype tool for software component services in embedded real-time systems\n", "abstract": " The use of software component models has become popular during the last decade, in particular in the development of software for desktop applications and distributed information systems. However, such models have not been widely used in the domain of embedded real-time systems. There is a considerable amount of research on component models for embedded real-time systems, or even narrower application domains, which focuses on source code components and statically configured systems. This paper explores an alternative approach by laying the groundwork for a component model based on binary components and targeting the broader domain of embedded real-time systems. The work is inspired by component models for the desktop and information systems domains in the sense that a basic component model is extended with a set of services for the targeted application domain. A prototype\u00a0\u2026", "num_citations": "7\n", "authors": ["639"]}
{"title": "Professional ethics in software engineering curricula\n", "abstract": " Engineering has a direct and vital impact on the quality of life of people. The services provided by engineers are required to take into consideration the safety, health and welfare of the public. Engineering Ethics is of relevance to the majority of people within the field of computing which has its own particular ethical concerns. Computer Ethics (with Software Engineering Ethics as its subfield) has thus been developed as a specific branch of Applied Ethics. It is important to recognize that prudent ethical judgment is an essential requirement of computer professionals. The aim of this paper is to shed light upon the significance of teaching ethical issues in Software Engineering curricula. It argues that education in Ethics should be incorporated in computing curricula. Experience from the course \u201cProfessional Ethics in Science and Engineering\u201d given at M\u00e4lardalen University in Sweden is presented as an illustration.", "num_citations": "7\n", "authors": ["639"]}
{"title": "Case study: software product integration practices\n", "abstract": " Organizations often encounter problems in the Product Integration process. The difficulties include finding errors at integration related to mismatch between the different components and problems in other parts of the system than the one that was changed. The question is if these problems can be decreased if the awareness of the integration process is increased in other activities. To get better understanding of this problem we have analyzed the integration process in two product development organizations. One of the organizations has two different groups with slightly different integration routines while the other is basing the development on well defined components. The obstacles found in product integration are highlighted and related to best practices as described in the interim standard EIA-731.1. Our conclusion from this study is that the current descriptions for best practices in product integration are\u00a0\u2026", "num_citations": "7\n", "authors": ["639"]}
{"title": "Computing Curricula: Teaching Theory of Science to Computer Science Students\n", "abstract": " An ideal Science for the existing Theory of Science (Popper, Carnap, Kuhn, Chalmers) is Physics. Not many modern Sciences conform to that ideal, however. Philosophy of Science (Theory of Science) as it is today is not of much help when trying to understand eg Computer Science. There is an urgent need to broaden the Theory of Science perspective in order to match the present situation within the area, as well as to help its further development. Computer Science has its basis in Logic and Mathematics, and in many cases its theoretical and experimental research methods follow patterns of classical scientific fields of Logic/Mathematics and Natural Sciences. On the other hand, computer modeling and simulation which is specific for the discipline and it is rapidly growing in importance, applied to computers, as well as to other scientific and artistic fields, hardly corresponds to traditional definition of scientific method. Situation gets even more complicated in the field of Intelligent Systems (Artificial Intelligence, AI). AI is generally associated with Computer Science, but it has many important links with other fields such as Mathematics, Psychology, Cognition, Biology, Behavioral and Brain Sciences, Linguistics and Philosophy, among others. This paper addresses the need for paradigm shift within Theory of Science. It shows that it is essential for students of Computer Science to not only acquire the concepts from Theory of Science within its conventional domain, but also widen the perspective and see the field in its context of other scientific traditions.", "num_citations": "7\n", "authors": ["639"]}
{"title": "Software deployment on heterogeneous platforms: A systematic mapping study\n", "abstract": " Context: Multiple types of processing units (e.g., CPUs, GPUs and FPGAs) can be used jointly to achieve better performance in computational systems. However, these units are built with fundamentally different characteristics and demand attention especially towards software deployment. Objective: The goal of this work is to summarize the state-of-the-art of software deployment on heterogeneous platforms. We provide an overview of the research area by searching for and categorizing relevant studies, as well as discussing gaps and trends of the field. We are interested in the main concerns (RQ1) and the approaches used (RQ2) when deploying software on heterogeneous platforms. Method: In order to achieve our goal, we performed a systematic mapping study, which refers to a method for reviewing literature with basis on predefined search strategies and a multi-step selection process. Results: We selected and\u00a0\u2026", "num_citations": "6\n", "authors": ["639"]}
{"title": "Multi-criteria software component allocation on a heterogeneous platform\n", "abstract": " A recent development of heterogeneous platforms (i.e. those containing different types of computing units such as multicore CPUs, GPUs, and FPGAs) has enabled significant improvements in performance processing large amount of data in realtime. This possibility however is still not fully utilized due to a lack of methods for optimal configuration of software; the allocation of different software components to different computing unit types is crucial for getting the maximal utilization of the platform, but for more complex systems it is difficult to find ad-hoc a good enough or the best configuration. In this paper we present an approach to find a feasible and locally optimal solution for allocating software components to processing units in a heterogeneous platform.", "num_citations": "6\n", "authors": ["639"]}
{"title": "Ten tips to succeed in global software engineering education: What do the students say?\n", "abstract": " When a project had followed advices from the best practices, we can raise a question whether the success (or failure) of the project came from following (or not following) the best practices, or whether there were additional reasons that led to the positive (or negative) outcome. In this paper we analyze a case of a student project performed as a part of our Distributed Software Development course. The project followed the advices from the \u201cTen Tips to Succeed in Global Software Engineering Education\u201d publication. This paper analyzes the project work with respect to the advices. Focusing on the perspective of a student participating in the project, the paper tries to answer whether following the advices is sufficient for a positive project outcome.", "num_citations": "6\n", "authors": ["639"]}
{"title": "Will They Report It? Ethical Attitude of Graduate Software Engineers in Reporting Bad News\n", "abstract": " Hiding critical information has resulted in disastrous failures of some major software projects. This paper investigates, using a subset of Keil's test, how graduates (70% of them with work experience) from different cultural backgrounds who are enrolled in a postgraduate course on global software development would handle negative information that is critical in a project. The subjects were mainly from Europe and Asia. The results showed that the subjects are highly likely to report critical information to their immediate supervisors (t(36)=-11, p<;0.0005), but are undecided on whether they would take the matter further up the organisational hierarchy if the supervisor ignored their report. There was no significant difference between participants of different regions, or between those with and without work experience. The consequences of negative information not reaching the level where remedial actions can be taken\u00a0\u2026", "num_citations": "6\n", "authors": ["639"]}
{"title": "phpModeler-A Web model extractor\n", "abstract": " This paper presents phpModeler, a tool for reverse engineering of legacy php web applications that generates static UML diagrams showing resources which the current web page is using, its functions and dependencies it has on other web pages. Once the models describing individual web pages have been generated, phpModeler can analyze them and generate dependency models that for each entity in every page model show all entities dependent on it. phpModeler can also be used to highlight the difference between page models - a feature that, when combined with a SVN repository shows the way how the current web page has evolved over time. phpModeler is a plugin for the Eclipse IDE.", "num_citations": "6\n", "authors": ["639"]}
{"title": "Why do some mature organizations not use mature CM tools\n", "abstract": " This paper presents a case-study of a Configuration Management (CM) tool evaluation. The evaluation was performed in a company with a long tradition of using CM tools. Although several generations of CM tools have been developed internally, different reasons led to a decision not to use CM tools internally developed but to buy a tool available on the market. A detailed evaluation was performed on the basis of the company\u2019s experience. The investigation procedure, the criteria for the evaluation, and the results are presented in the paper. The results of the evaluation, taken to the final selection of a tool, have shown the superiority of one tool, but another tool, considerably inferior to the first has been chosen. Why? This paper analyses the background of the decision and points out the factors, not always of a technical nature, which significantly influence d the decision, and which are sometimes forgotten\u00a0\u2026", "num_citations": "6\n", "authors": ["639"]}
{"title": "Improving bandwidth efficiency with self-adaptation for data marshalling on the example of a self-driving miniature car\n", "abstract": " Publish/subscribe communication is a common architectural design pattern in component-based software systems used in many of today's cyber-physical systems to exchange information between distributed software components. These systems typically deal with an increased number of data transfers, with a risk of lacking resources. Our recent domain analysis for a lane-following algorithm of a self-driving miniature car unveiled that the actual\" information increment\" between two subsequently sent packets is often small. Such scenario enables possibilities for a more efficient data exchange by avoiding redundant and/or unnecessary information transfer. In this paper, we propose and evaluate our concept for\" self-adaptive data marshalling\" that transparently adapts data types in messages to be exchanged by analyzing the actual information increment. The approach could reduce the bandwidth usage by more\u00a0\u2026", "num_citations": "5\n", "authors": ["639"]}
{"title": "Towards specifying pragmatic software reuse\n", "abstract": " Software reuse has numerous benefits, including reduced development time, defect density, and increased developer productivity. Numerous approaches to software reuse have been developed and we can divide them into two categories: preplanned approaches, where software artifacts are developed to be reused; and pragmatic approaches, that facilitate the reuse of software artifacts not necessarily designed for reuse. In this paper, we specify the general approach to pragmatic software reuse, which consists of three steps: i) feature location, which identifies the source code of an individual feature; ii) code analysis and modification, which fixes conflicts that can happen when achieving reuse; and iii) feature integration, which achieves reuse by integrating code into the target system. We also discuss how certain steps in the process are used in current state-of-the-art pragmatic reuse approaches. In addition\u00a0\u2026", "num_citations": "5\n", "authors": ["639"]}
{"title": "Enhancing model-based architecture optimization with monitored system runs\n", "abstract": " Typically, architecture optimization searches for good architecture candidates based on analyzing a model of the system. Model-based analysis inherently relies on abstractions and estimates, and as such produces approximations which are used to compare architecture candidates. However, approximations are often not sufficient due to the difficulty of accurately estimating certain extra-functional properties. In this paper, we present an architecture optimization approach where the speed of model-based optimization is combined with the accuracy of monitored system runs. Model-based optimization is used to quickly find a good architecture candidate, while optimization based on monitored system runs further refines this candidate. Using measurements assures a higher accuracy of the metrics used for optimization compared to using performance predictions. We demonstrate the feasibility of the approach by\u00a0\u2026", "num_citations": "5\n", "authors": ["639"]}
{"title": "Towards automatic client-side feature reuse\n", "abstract": " Client-side applications often contain similar features and facilitating reuse could offer considerable benefits in terms of faster development. Unfortunately, due to the specifics of prevailing technologies, the techniques and tools used to support reuse are not as advanced as in other software engineering disciplines and the main method of reuse is still copy-pasting code. Copy-paste reuse can introduce a number of different types of errors that are time-consuming to detect and fix. In this paper we present an automatic method for feature reuse in client-side web applications. We identify problems that occur when introducing code from one application into another, present a set of algorithms that detect and fix those problems and perform the actual code merging. We have evaluated the approach on four case study applications, and the results show that the method is capable of performing feature reuse.", "num_citations": "5\n", "authors": ["639"]}
{"title": "Oh dear, we bought our competitor: Integrating similar software systems\n", "abstract": " A look at 10 case studies addresses the technological, personnel, and organizational challenges. The 10 cases involved seven organizations in different business sectors. Our data collection methods included our participation in projects, several rounds of interviews with project leaders and software architects, and several rounds of questionnaires with software architects and project managers, as well as project and product documentation. 2 Companies we studied included ABB, Bombardier, Ericsson, Saab, and Westinghouse. However, we can't disclose detailed information or relate case descriptions to specific companies or systems. Our observations regarding cultural influences might be skewed because all the organizations involved Sweden and other European or North American countries.", "num_citations": "5\n", "authors": ["639"]}
{"title": "Transaction level control for application execution on the SegBus Platform\n", "abstract": " We define here a simple, low level control procedure definition, to support application implementation on a particular multiprocessor platform, namely the \"SegBus\" segmented bus. The approach considers communication as data package transactions from one device to another. It takes into consideration the platform characteristics and requires details of application partitioning and mapping on platform resources. The dependency between operations are extracted from a SDF-like representation, and the actual control code is produced as \"application-dependent\" VHDL code, grouped in so-called snippets, application and platform instance dependent. The obtained code is inserted in a specific section of a (segment or central level) arbiter. We illustrate the application of our approach on a small implementation example.", "num_citations": "5\n", "authors": ["639"]}
{"title": "Product Data Management and Software Configuration Management Integration\n", "abstract": " Today, many products are built from both hardware and software components, this especially being true for technologically high-end and complex products such as cars, aircrafts, or mobile phones. Development of such products requires an integrated support that encompasses different domains such as electronics, mechanics, and software. Previously separated, the development of hardware and software components is becoming a common undivided process, which also requires integration of tools providing this support. One of the today\u2019s key factors for an integrated product information management is the possibility of integrated and uniform use of Product Data Management (PDM) and Software Configuration Management (SCM). These tools have similar purpose: providing an overall support for building and managing information infrastructure and collaboration between stakeholders. Yet, the integration of these tools and supporting processes has proven to be difficult and challenging for many companies.The main objective of this thesis is to study the feasibility of achieving an integrated, consistent and efficient support to the complex products life cycles by PDM and SCM, either as separated or integrated tools. This objective has been achieved by several research activities:(i) analysis of the main characteristics of PDM and SCM, ie their key functionalities and relations between them,(ii) numerous industrial case studies of PDM and SCM usage and their interoperability, and (iii) a discussion of the hypothesis that the three factors, namely, technologies and architectures, processes, and stakeholders\u2019 cultural differences, are of a vital\u00a0\u2026", "num_citations": "5\n", "authors": ["639"]}
{"title": "Software systems in-house integration strategies: merge or retire-experiences from industry\n", "abstract": " When an organization faces different types of collaboration, for example after a company merger, there is a need to consolidate the existing in-house developed software. A main challenge is to select a suitable strategy, such as merging the systems, evolve one of the existing systems to be able to retire others, or start a new development effort in order to retire the existing systems. This should arguably be done at a high abstraction level, ie architectural level. In order to investigate how a strategy should be chosen, we have performed a multiple case study, consisting of nine integration projects. Two major concerns have been found that can be used to exclude some strategies: 1) architectural compatibility, and 2) what we have labeled \u2018retireability\u2019, ie all considerations influencing whether or not the existing systems can be allowed to be retired.", "num_citations": "5\n", "authors": ["639"]}
{"title": "Interviews on Software Integration\n", "abstract": " Integration or replacement of existing software systems is inevitable after company mergers and other types of collaborations between organizations. Our present research aims at describing how organizations have accomplished new generations of their existing systems by integrating, merging, or reusing parts of existing systems, be it code, design ideas, or requirements. As an important part of this research, a number of interviews with people from industrial integration projects have been carried out, as well as participation in one case. The present report describes the methodology used to set up these interviews and contains the full notes made during the interviews. No analysis of the results is made.", "num_citations": "5\n", "authors": ["639"]}
{"title": "Quality improvements by integrating development processes\n", "abstract": " Software is an increasing and important part of many products and systems. Software, hardware, and system level components have been developed and produced following separate processes. However, in order to improve the quality of the final complex product, requirements and prospects for an automatic integrated process support are called for. Product data management (PDM) has focused on hardware products, while software configuration management (SCM) has aimed to support software development. Several attempts to integrate tools from these domains exist, but they all show small visible success. The reason for this is that integration goes far beyond tool issues only. According to our experiences, three main factors play a crucial role for a successful integration: tools and technologies, processes, and people. This paper analyses the main characteristics of PDM and SCM, describes the three\u00a0\u2026", "num_citations": "5\n", "authors": ["639"]}
{"title": "Three Aspects of Successful Software Development Projects\" When are projects canceled, and why?\".\n", "abstract": " Successful project execution, successful technical solutions or a promising business case, are they equally important selection criteria in a product development process? We have used experiences gained from a large multinational industrial company that is currently deploying a software product line strategy to try to answer that question. The product line's core assets include, among other things, a new software platform that is introduced to the company's software development organizations by means of a portfolio of targeted pilot projects. A business decision-making process is used to select and prioritize projects within the portfolio. We find from an analysis of a large number of projects and will indicate that the three criteria are not equally important.", "num_citations": "5\n", "authors": ["639"]}
{"title": "Software process measurements using software configuration management\n", "abstract": " Software Configuration Management (SCM) is the controlled way to manage the development and modification of software. For an efficient SCM process different SCM tools can be used to collect information about items being changed in the development or maintenance process. Advanced SCM tools include also Change Management which collects information related to the change process in a project. There is a huge amount of information stored in SCM repository and this information can be used as input to Software Metrics for Size-and Process-Oriented Metrics.This paper describes how SCM data can be utilised for Process-Oriented Software Metrics. To identify the changes performed in a software system, SCM uses Change Requests (CR). By placing CRs under version control, it is possible to measure the nature of change process: The measurements taken on CRs give information not only about the number and type of changes but also about the development process behaviour. These measurements can be used during the development process and in the final analysis of the project. Main advantages of using data stored by SCM is the accuracy of the data, and that it is not necessary to put extra efforts to register the data (they are updated automatically when certain actions related to the SCM process are performed). As an implementation example, the paper presents a change-oriented SCM tool used at ABB Automation Product AB, and measurements showing certain cases of different lifecycle models.", "num_citations": "5\n", "authors": ["639"]}
{"title": "Systematic evaluation of three data marshalling approaches for distributed software systems\n", "abstract": " Cyber-physical systems like robots and self-driving vehicles comprise complex software systems. Their software is typically realized as distributed agents that are responsible for dedicated tasks like sensor data handling, sensor data fusion, or action planning. The modular design allows a flexible deployment as well as algorithm encapsulation to exchange software modules where needed. The distributed software exchanges data using a data marshalling layer to serialize and deserialize data structures between a sending and receiving entity. In this article, we are systematically evaluating Google Protobuf, LCM, and our self-adaptive delta marshalling approach by using a generic description language, of which instances are composed at runtime. Our results show that Google Protobuf performs well for small messages composed mainly by integral field types; the self-adaptive data marshalling approach is efficient\u00a0\u2026", "num_citations": "4\n", "authors": ["639"]}
{"title": "Technology in real-life teaching of distributed software development\n", "abstract": " Distributed Software Development course is a project-based course, currently run together on three universities: in Croatia,Italy and Sweden. The specificity of this course is usage of technology and distance work in order to teach students exactlythat \u2013 distributed software development. Students experience what they are learning about through course participation.The goal is to offer students real-life experience of building such a distributed project, by working in distributed teams,having teaching staff and customers in remote universities, or participating in software competitions. Different educationalactivities build on the social constructivism method of learning, supported by various tools and technologies used. Courseevaluation, which is being conducted since the beginning, for 11 years, shows constant and high students\u2019 satisfaction.Students\u2019 comments acknowledge the innovative concept and an opportunity to work in a real-life, distributed environment, with the help of technology.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Project Monitoring and Control in Model-Driven and Component-Based Development of Embedded Systems\n", "abstract": " This position paper describes how the combination of the Model-Driven Development (MDD) and Component-Based Software Engineering (CBSE) paradigms can support project monitoring and control, and project risk reduction. The core principle for this is articulated and named CARMA, and our research agenda and preliminary results are described. Through interviews, industry input, process simulation, tool implementation and pilot projects, and describing an extension of CMMI, we are exploring the CARMA principle in order to provide guidelines for MDD/CBSE projects.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Models transformation between UML and a domain specific language\n", "abstract": " As complexity of software systems is increasing, using a proper modelling language for designing and analysing a system is becoming more and more important. Over the recent years there is a tendency for using domain-specific languages which enable expressing design solutions in the idiom and the level of abstraction of the specific problem domain. Since a design process passes through different levels of abstractions and different properties of systems are being modelled, different modelling languages are used. While this approach enables an efficient and accurate design, it suffers from a problem of transformation between the models. This paper addresses a challenge of transformation between UML, a modelling language widely used, to a domain-specific language SaveComp component model (SaveCCM) intended for real-time embedded systems. In this paper we discuss a possible solution for achieving interoperability between SaveCCM and UML. The challenge of a transformation is to keep all necessary information including the semantics of the models. The paper presents the strategy for the transformation, its implementation and an analysis of the results.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Holistic approach in education-filling the gap between different disciplines\n", "abstract": " In the research, education and in everyday practice, a need for and general understanding and a holistic approach is becoming more and more important. Still in concrete cases such approaches meet many challenges, mostly in form of misunderstanding between involved partners experts from different disciplines. Education in general does not provide training for such approach. This paper describes a case - a course which goal was to transfer knowledge from one area to another: A software engineering and management of software development projects was taught to students of management and economy. In addition to this the course provided new teaching methods that students were not used to. Finally the course has been taught as a distance course, using Internet-based technology. All this elements made the course very challenging. The paper gives an overview of the case, identifies the challenges and\u00a0\u2026", "num_citations": "4\n", "authors": ["639"]}
{"title": "A Quantitative Survey on Software In-house Integration\n", "abstract": " As organizations merge or collaborate closely, an important question is how their existing software assets should be handled. If these previously separate organizations are in the same business domain\u2013they might even have been competitors\u2013it is likely that they have developed similar software systems. To rationalize, these existing software assets should be integrated, in the sense that similar features should be implemented only once.We have previously made qualitative observations on this topic. This report describes the followup study, which was performed in the form of a questionnaire aimed at validating and quantifying the previous observations. This report describes the research design, present the questionnaire together with all responses, and make some statistical analyses. This will form a basis for further publications with deeper analyses.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Component-Based Software Engineering: 7th International Symposium, CBSE 2004, Edinburgh, UK, May 24-25, 2004, Proceedings\n", "abstract": " Component-based software engineering (CBSE) is concerned with the devel-ment of software-intensive systems from reusable parts (components), the dev-opmentofsuchreusableparts, andthemaintenanceandimprovementofsystems by means of component replacement and customization. Although it holds c-siderable promise, there are still many challenges facing both researchers and practitioners in establishing CBSE as an e? cient and proven engineering dis-pline. Six CBSE workshops have been held consecutively at the most recent six International Conferences on Software Engineering (ICSE). The premise of the last three CBSE workshops was that the long-term success of component-based development depends on the viability of an established science and technology foundation for achieving predictable quality in component-based systems. TheintentoftheCBSE2004symposiumwastobuildonthispremise, andto provide a forum for more in-depth and substantive treatment of topics perta-ing to predictability, to help establish cross-discipline insights, and to improve cooperation and mutual understanding. The goal of the CBSE 2004 symposium was to discuss and present more complete and mature works, and consequently collect the technical papers in published proceedings. The response to the Call for Papers was beyond expectations: 82 papers were submitted. Of those 25 (12 long and 13 short) were accepted for publication. In all 25 cases, the papers were reviewed by three to four independent reviewers. The symposium brought together researchers and practitioners from a variety of disciplines related to CBSE.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Introduction for using UML\n", "abstract": " The purpose with this document is to provide a brief introduction to the Unified Modeling Language (UML) for usage in the jointly held course in distributed development in V\u00e4ster\u00e5s and Zagreb. The focus is on using UML in general, not in combination with a particular tool, problem domain or programming technique.", "num_citations": "4\n", "authors": ["639"]}
{"title": "A Component-Based Software Architecture for Industrial Control\n", "abstract": " When different business units of an international company are responsible for the development of different parts of a large system, a component-based software architecture may be a good alternative to more traditional, monolithic architectures. The new common control system, developed by ABB to replace several existing control systems, must incorporate support for a large number of I/O systems, communication interfaces, and communication protocols. An activity has therefore been started to redesign the system\u2019s architecture, so that I/O and communication components can be implemented by different development centers around the world. This paper reports on experiences from this effort, describing the system, its current software architecture, the new component-based architecture, and the lessons learned so far.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Managing Complex Systems\u2013Challenges for PDM and SCM\n", "abstract": " Software is being increasingly incorporated in increasingly extensive industrial and other applications. There is a demand for total control of entire applications including their software components. A consequence of this is that the development procedure, production operations and maintenance, previously separate processes, are being integrated in comprehensive process systems. In the integration of these processes, many difficulties are encountered because of different natures of the processes and the different approaches made to the problem. In the integration process, many activities overlap and much data is duplicated, this making a complex process even more complex. Software Configuration Management (SCM) and Product Data Management (PDM) which are used to solve similar problems in different ways are examples of overlapping processes. Attempts to integrate SCM and PDM systems to obtain a more efficient development process have not proved particularly successful.This paper analyses the main characteristics of SCM and PDM, development processes that are PDM-or SCM-centered, their common characteristics and their differences. The problems encountered when using both systems are analyzed. An analysis of possible integration of these systems is presented and the potential benefits of and problems involved in such integration are discussed.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Component Configuration Management for Frameworks\n", "abstract": " Object-oriented Design frameworks are increasingly recognized as better components than objects. In this paper, we briefly explain the framework concept, show a COM implementation, and discuss the accompanying configuration management issues.", "num_citations": "4\n", "authors": ["639"]}
{"title": "Introduction to Component-Based Software Engineering\n", "abstract": " Introduction to Component- Based Software Engineering Page 1 1 Introduction to ComponentBased Software Engineering Gentilmente cedido por Ivica Crnkovic M\u00e4lardalen University Department of Computer Science, Sweden 2 \u25aa The size & complexity of software increases rapidly \u25aa Single products become part of product families \u25aa Software is updated after deployment \u25aa Demands of decreasing time to market \u25aa Costs of software development increasing Problems of software development 3 Observations of the practice of software engineering \u25aa About 80% of software development deals with changing (adaptation, improvement) of existing software \u25aa Time to market is an important completive advantage: \u25aa Importance of incorporation of new innovations quickly \u25aa System should be built to facilitate changes \u25aa Easy removal and addition of functionality \u25aa Systems should be built to facilitate reuse \u25aa Easy integration of existing \u2026", "num_citations": "3\n", "authors": ["639"]}
{"title": "Towards automatic synthesis of hardware-specific code in component-based embedded systems\n", "abstract": " Most component models currently in use do not try to provide extensive support for dealing with hardware devices like sensors and actuator. Lack of such support means that software components and subsystems often include device- and platform-specific code, limiting our ability to reuse them and forcing us to deal with specifics of underlying hardware in high-level software models. In this paper we propose a solution that would enable automatic generation of device-specific code. We remove device- and platform-specific code outside of software components and specifying it as reusable units. Based on a system model we then generate glue-code that binds this reusable units of code to each other and to the software components, resulting in a system-specific solution.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Managing complexity and predictability in embedded systems: Applying component-based development\n", "abstract": " Summary form only given. Due to the booming growth of Information and Communication Technology (ICT), a vast amount of data is produced at a considerably high rate and it drives the traditional methods of storing data to its limits and most of the time it simply overwhelms the current storage systems. Because of that, throughout the history of the development of ICT, the effort to find an efficient and feasible data storage system that has a substantial capacity to cater the current data storage needs has been relentless.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Distributed Software Development course: Students' and teachers' perspectives\n", "abstract": " Students and teachers do not necessarily have the same understanding of a course - of the purpose, the objective, and in particular of the course elements - the way the course is performed, the examination procedure, and similar. In distributed-development courses, in which students and teachers are dispersed over different locations, this difference can be larger than in \u201cordinary\u201d courses, but also less visible, due to limited communication. In this paper we discuss these different perspectives, their rationales, possible consequences on the course performance and on the result, as well as lessons learned from students' feedback.", "num_citations": "3\n", "authors": ["639"]}
{"title": "DICES technical report Classification and survey of component models\n", "abstract": " As component-based software engineering is growing and its usage expanding, more and more component models are developed. In this report we present a survey of software component models in which models are described and classified respecting the classification framework for component models proposed by Crnkovi\u0107 et. al.[1]. This framework specifies several groups of important principles and characteristics of component models: lifecycle, constructs, specification and management of extra-functional properties, and application domain. This report analyzes a considerable amount of component models, including widely used industrial models, as well as research models.", "num_citations": "3\n", "authors": ["639"]}
{"title": "GENESIS: a framework for global engineering of embedded systems\n", "abstract": " GENESIS is an European initiative involving institutions and persons from older and new EU members, and West Balkan countries. It aims at developing a global network of research and education in embedded systems. The related research will be coordinated in such a way to address hot topics at European and global levels and will concentrate on the fusion of embedded systems and distributed services over the Internet. One of the main objectives of GENESIS is to develop a distributed virtual laboratory to be used in embedded systems research and education and this is described in detail. This paper presents the rationale behind this initiative and the main actions that are proposed to fulfill the educational, and scientific objectives of GENESIS.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Increasing Interdisciplinarity by Distance Learning: Examples Connecting Economics with Software Engineering, and Computing with Philosophy\n", "abstract": " This paper presents two distance courses aimed at promoting interdisciplinarity. The first one was an internet-based distance undergraduate course in software engineering and management of software development projects for students of management and economy. The goal of the course was to bridge the gap between disciplines of economy (management) and software engineering, transfer knowledge and provide necessary technical background for future managers who very likely in their careers will take part in software intense projects. Both the interdisciplinarity and the advanced e-learning tech-nology of this course made it challenging. The second was a specialized level Swedish National Course in Philosophy of Computing and Informatics for students of computing, philosophy and design, which was a combination of a campus-based and a distance course involving several Swedish univer-sities, with a group of distinguished teachers from both Sweden and abroad. The critical challenge of this course was the establishing of a new inter-discipline and overarching the gaps between traditions of disciplinary thinking.As education systems today in general do not offer training for interdisciplinarity and multi-disciplinarity, distance education can play an important role in providing additional degrees of free-dom and facilitating communication between disciplines. This paper presents two case studies based on experiences with distance courses intended to promote cross-disciplinarity. The first one was a dis-tance undergraduate course in software engineering and management for students of management and economy. The second was a\u00a0\u2026", "num_citations": "3\n", "authors": ["639"]}
{"title": "Software In-house integration-Quantified experiences from industry\n", "abstract": " When an organization faces new types of collaboration, for example after a company merger, there is a need to consolidate the existing in-house developed software. There are many high-level strategic decisions to be made, which should be based on as good foundation as possible, while these decisions must be made rapidly. Also, one must employ feasible processes and practices in order to get the two previously separate organizations to work towards a common goal. In order to study this topic, we previously performed an explorative and qualitative multiple case study, where we identified a number of suggested practices as well as other concerns to take into account. This paper presents a follow-up study, which aims at validating and quantifying these previous findings. This study includes a questionnaire distributed to in-house integration projects, aiming at validation of earlier findings. We compare the data\u00a0\u2026", "num_citations": "3\n", "authors": ["639"]}
{"title": "Architectural concerns when selecting an in-house integration strategy-experiences from industry\n", "abstract": " Consider the scenario where two or more software systems have been developed in-house, for different purposes. Over time, the systems have been evolved to contain more functionality, until a point where there is some overlap in functionality and purpose. The same situation occurs, only more drastically, as a result of company acquisitions and mergers. A new system combining the functionality of the existing systems would improve the situation both from an economical and maintenance point of view, and from the point of view of users, marketing and customers.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Concretizing the vision of a future integrated system-experiences from industry\n", "abstract": " When an organization faces new types of collaboration, for example after a company merger, there is a need to integrate the existing software. Important challenges are how to create a realistic vision of a future integrated system, how to make the vision concrete enough to be able to work towards the vision, and of course to carry out the actual integration process. This paper focuses on how to concretize the vision. We have carried out a multiple case study, consisting of 9 cases. This paper presents the observations made in the form of recurring patterns that can be used as recommendations for other organizations facing the same challenge.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Influences between software architecture and its environment in industrial systems-A case study\n", "abstract": " Software Architecture has received much attention in Software Engineering Research Community in the last decade. In this report, we have collected data from a number of real systems, which are successful and complex industrial systems. We tried to identify factors that have significant influence on their Software System Architecture lifecycle. The main goal of the investigation is to identify some key common factors that make architectures of these systems, successful or fail. The investigation was performed through a series of interviews with a number of key persons of research and development groups of successful international companies located in Sweden. The interviews were conducted in the late fall of 2003. This document contains the description of the case study setup and the material collected during interviews, without any analysis being done yet.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Experiences with component-based software development in industrial control\n", "abstract": " When different business units of an international company are responsible for the development of different parts of a large system, a component-based software architecture may be a good alternative to more traditional, monolithic architectures. The new common control system, developed by ABB to replace all its existing control systems, must incorporate support for a large number of I/O systems, communication interfaces, and communication protocols. An activity has therefore been started to redesign the system\u2019s architecture, so that I/O and communication components can be implemented by different development centers around the world. This paper reports on experiences from this effort, describing the system, its current software architecture, the new component-based architecture, and the lessons learned so far.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Managing standard components in large software systems\n", "abstract": " This position paper consists of two parts. The first part gives an overview of a research project started by ABB and M\u00e4lardalen University. The project is concentrated on use of standards technologies and standard components in real-time industry-process systems. The main goal of the project is to increase the knowledge about software development based on standard components from both theoretical and practical points of view. The project can be an interesting case of practices of adopting CBSE, a case of an approach in managing component-based engineering.The second part of the paper points to some important aspects in use of components at the development, run-time, and maintenance phases. It is a problem of identification and configuration of components in software systems. Configuration Management (CM) disciplines, such as Version Management, Configuration and Build Management, Change Management, etc., are well established for the conventional development. In a component-based development some new requirements on identification and version management arise, and some new methods, similar to those from conventional CM, and possible extensions of the existing methods, should be objects of further research. We propose an extension of CBSE-handbook with a new sub-chapter which is related to component identification and configuration and which could be a part of the Technology for supporting CBSE chapter.", "num_citations": "3\n", "authors": ["639"]}
{"title": "Adaptive Message Restructuring Using Model-Driven Engineering\n", "abstract": " Message exchange between distributed software components in cyber-physical systems is a frequent and resource-demanding activity. Existing data description languages simply map user-specified messages literally to the system implementation creating the data stream that is exchanged between the software components; however, our research shows that the exchanged information is often redundant and would allow for runtime optimization. In this paper, we propose a model-based approach for adaptive message restructuring. Taking both design-time properties and runtime properties into account, we propose to dynamically restructure user-specified messages to achieve better resource usage (e.g., reduced latency). Our model-based workflow also includes formal verification of adaptive message restructuring in the presence of complex data flow. This is demonstrated by an automotive example.", "num_citations": "2\n", "authors": ["639"]}
{"title": "Towards a common software-to-hardware allocation framework for the heterogeneous high performance computing\n", "abstract": " In the domain of high performance computing, software deployment on heterogeneous distributed processing units has been in practice for many years. However, new hardware technologies, increased complexity of software and significant increase of requirements demand new methods that can manage these concerns in an efficient way. In this paper we propose a new optimization framework that in a systematic way addresses a general allocation model, the software and deployment architectures, and, based on the user preferences, provides a software deployment solution regardless of number of quality attributes used. Additionally, we present the input models to the allocation process capable of describing a number of software and hardware configurations, and a two-step allocation algorithm capable of harnessing these models.", "num_citations": "2\n", "authors": ["639"]}
{"title": "Embedded Systems Software Architecture\n", "abstract": " Embedded Systems are the dominate type of computer systems today; they span a range from small systems that include a simple platform integrated with sensors and actuators, to large distributed systems consisting of hundreds, or possibly thousand, intensely interactive nodes. In recent years Software has become the most important part of Embedded Systems\u2013it implements the complex system functionality, is a currier of the system integration, and it is enabler of important extra-functional system properties. In many aspects, software for Embedded Systems has reached functional complexity of general-purpose software but faces severe constraints. This special issue includes six research papers that address some of the mentioned challenges.", "num_citations": "2\n", "authors": ["639"]}
{"title": "Automatic synthesis of hardware-specific code in component-based embedded systems\n", "abstract": " In recent years, there has been a clear trend in research and practice to bring benefits of component based development into the embedded systems domain. However, one often neglected aspect in component models is support for integration of hardware devices like sensors and actuators. In most component models, communication with such devices is either left out completely or considered as an integral part of the software component code. In the latter case, the software components are highly device-specific, and can hardly be reused on different platform configurations. This paper introduces an approach for automatic synthesis of device-specific code in component models for embedded systems. We divide a system in reusable elements: device-specific code, platformspecific code and device-dependant software component code. Based on a software and hardware model of the system, we then automatically generate glue-code that creates connections between these reusable elements. The result of our synthesis is a system-specific deployable code. The approach is illustrated by a demonstrator and an implementation example using the ProCom component model.", "num_citations": "2\n", "authors": ["639"]}
{"title": "Are ultra-large systems systems of systems?\n", "abstract": " Ultra Large Systems are characterized by its complexity, size, diversity of concerns and missions. As complexity of systems grows and the demands on interoperability between them grow, the concerns of how to build, maintain and manage them becomes more important. It is however a question how this complexity can be managed, or how the complexity can be simplified. A second question is related to a question whether an ultra-large system is the same as ultra-large integration of systems, ie systems of systems? In this short position paper we exploit a hypothesis that ultra-large systems are either loosely integrated systems and in that case they should be treated as systems of systems, or tight-coupled systems and in that case they should have an layered architecture. As illustration, the paper shows some examples from Scandinavian industry that manage systems which are approaching the size of ultra-large\u00a0\u2026", "num_citations": "2\n", "authors": ["639"]}
{"title": "A comparative study of software component models for embedded real time systems\n", "abstract": " It is no doubt that at the moment time is so important for every one in every kind of field. So it is the requirement of time to produce suck kind of products which consumes les time. But now it is right to say that there are such products available in market which really changes our lives. At the moment every manufacturing company trying to use such kind of CPUs that really helps to develop the embedded systems. Even if we observe our daily life we find such kind of thing s which we really ignored uses embedded systems. At the moment there are different components are used to develop the embedded systems. The most important component at the moment is Koala component which is developed by the Philips. Philips used Koala in developing the consumer electronic products. Koala has its own characteristics due to which Philips used it. There are also real time embedded systems which use such kind of\u00a0\u2026", "num_citations": "2\n", "authors": ["639"]}
{"title": "Distributed Development Project using WWW\n", "abstract": " : This paper describes a support for a software development distributed geographically and used on different platforms. By using simple cgi-scripts it is possible to access the development project structure and to exchange the software components from different sites. In particular a solution for a distributed software configuration management is presented: A development structure is placed on a WWW server and under control of a configuration management. Software components are via Netscape checked-out, locked for double updating and then checked back in the project repository. The software components and their states are shown by simple graphical objects in HTML pages that are dynamically created on the WWW server site. 1. INTRODUCTION The enormous expansion of the Internet and usage of the World Wide Web (WWW) has removed barriers between different platforms and geographical distances. However, in the same time the new requirements on software applications have been posed: applicat...", "num_citations": "2\n", "authors": ["639"]}
{"title": "Technical Report: Energy Management in Embedded Systems Taxonomy\n", "abstract": " Energy is an important constraint in embedded systems, and there exists a huge expertise in this domain how to manage and optimize energy consumption in the computer systems. The aim of this paper is to present the energy concerns addressed in the research literature and build up a knowledge that can be utilized in other domains. Based on a systematic review, the paper presents taxonomy of energy consumption and management in embedded systems.", "num_citations": "2\n", "authors": ["639"]}
{"title": "Component Repository Browser\n", "abstract": " The main goal of this thesis is to investigate efficient searching mechanisms for searching and retrieving software components across different remote repositories and implement a supporting prototype called \u201cComponent Repository Browser\u201d using the plug-in based Eclipse technology for PROGRESS-IDE. The prototype enables users to search the ProCom components and to import the desired components from a remote repository server over different protocols such as HTTP, HTTPS, and/or SVN. Several component searching mechanisms and suggestions were studied and examined such as keyword, facet-based search, folksonomy classification, and signature matching, from which we selected keyword search along with facet-based searching technique to help component searchers to efficiently find the desired components from a remote repository.", "num_citations": "1\n", "authors": ["639"]}
{"title": "A Metamodel independent approach for Conflict Detection tosupport distributed development in MDE\n", "abstract": " Models are the basic elements in Model Driven Engineering (MDE). The main principle in MDE is focusing on models; considering the concept of \u201cEverything is a model\u201d. This has been partially solved for programming languages: several languages, tools and platforms have been developed for this purpose and some of them are introduced in this report.Model development has introduced many new research fields. Our research is focused on model version management. Models can be developed in a distributed environment, thus once they merge together, conflicts and inconsistencies should be detected in a convenient way in order to be reconciled. The emphasis here is on generating conflict Metamodel of models automatically. This conflict metalmodel is used to generate conflict patterns. Conflict patterns represent cases in which conflicts occur with two concurrent versions of the same model. When model developers update model repositories, this conflict detection will be so useful and practical as it shows existing conflicts to the users, so the time for manual recognition of conflicts will be reduced. Also with some reconciliation strategies, conflicts could be resolved automatically.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Binary change set composition\n", "abstract": " Binary component-based software updates that are lightweight, efficient, safe and generic still remain a challenge. Most existing deployment systems that achieve this goal have to control the complete software environment of the user which is a barrier to adoption for both software consumers and producers. Binary change set composition is a technique to deliver incremental, binary updates for component-based software systems in an efficient and non-intrusive way. This way application updates can be delivered more frequently, with minimal additional overhead for users and without sacrificing the benefits of component-based software development.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Evaluation of Software Components in Embedded Real-Time Systems\n", "abstract": " Today, computers have become more popular in every field of life especially in industries, robots, automobiles and health care systems of hospitals. This large growth of computers in our daily life is causing so many problems related to softwares. To overcome these problems in softwares, the software engineers are adopting new approaches which is called Component-based software engineering (CBSE). CBSE is widely using in the development of component-based software systems. The main advantage to use the component based software engineering is that, we can increase the efficiency and reduce the time to complete the software\u2019s projects. The development of components is growing technique which is used to build the real-time systems. The trend to use the embedded realtime systems in household products has been increased for last 10 years. In embedded real-time systems the hardwares and softwares are joined in this way that they perform better function. In development of embedded real-time systems the different software component model techniques are used. In this Master thesis we evaluate the software components and their models in embedded real-time systems.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Quality of Software Architectures: Second International Conference on Quality of Software Architectures, QoSA 2006, V\u00e4steras, Schweden, June 27-29, 2006, Revised Papers\n", "abstract": " Although the quality of a system\u2019s software architecture is one of the critical factors in its overall quality, the architecture is simply a means to an end, the end being the implemented system. Thus the ultimate measure of the quality of the software architecture lies in the implemented system, in how well it satis? es the system and project requirements and constraints and whether it can be maintained and evolved successfully. In order to treat design as a science rather thananart, weneedtobeabletoaddressthequalityofthesoftwarearchitecture directly, not simply as it is re? ected in the implemented system. Therefore, QoSA is concerned with software architecture quality directly by addressing the problems of:\u2013Designing software architectures of good quality\u2013De? ning, measuring, evaluating architecture quality\u2013Managing architecture quality, tying it upstream to requirements and do-stream to implementation, and preserving architecture quality throughout the lifetime of the system Cross-cutting these problems is the question of the nature of software archit-ture. Software architecture organizes a system, partitioning it into elements and de? ning relationships among the elements. For this we often use multiple views, each with a di? erent organizing principle.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Merging In-House Developed Software Systems\u2013A Method for Exploring Alternatives\n", "abstract": " An increasing form of software evolution is software merge\u2013when two or more software systems are being merged. The reason may be to achieve new integrated functions, but also remove duplication of services, code, data, etc. This situation might occur as systems are evolved in-house, or after a company acquisition or merger. One potential solution is to merge the systems by taking components from the two (or more) existing systems and assemble them into an existing system. The paper presents a method for exploring merge alternatives at the architectural level, and evaluates the implications in terms of system features and quality, and the effort needed for the implementation. The method builds on previous observations from several case studies. The method includes well-defined core model with a layer of heuristics in terms of a loosely defined process on top. As an illustration of the method usage a case study is discussed using the method.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Components and services session report\n", "abstract": " This paper shortly summarises the working session \"Components and Services\" held at WICSA 2005 (Working International Conference on Software Architecture). Both components and services are strongly related to software architecture and have now an increased focus in research and practitioners\u2019 communities. Both component-based and serviceoriented development, use the same technologies and same or similar principles in architecting of software systems. Still there have not been many interactions between the \"components\" and \"services\" communities. For this reason the events like this working session are very important to bring the communities together, to increase the mutual understanding, to exchange experience and to share solutions.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Possible implications of design decisions based on predictions\n", "abstract": " Software systems and applications are increasingly constructed as assemblies of preexisting components. This makes software development cheaper and faster, and results in more favorable preconditions for achieving higher quality. This approach, however, introduces several problems, most of them originating from the fact that preexisting software components behave as black boxes. One problem is that it is difficult to analyze the properties of systems in which they are incorporated. To simplify the evaluation of system properties, different techniques have been developed to predict the behavior of systems on the basis of the properties of the constituent components. Because many cannot be formally specified, these techniques make use of statistical terms such as probability or mean value to express system properties. This paper discusses ethical aspects of the interpretation of such predictions. This problem is\u00a0\u2026", "num_citations": "1\n", "authors": ["639"]}
{"title": "Master Education Management System.\u201d\n", "abstract": " In this thesis, we discuss basic principles of web development; this includes database and web-based server design which today is used most often for development of distributed applications.The basic objective of our thesis was to develop a distributed management system to manage and administrate the master\u2019s program collaborated several European universities. The essence of requirements was to develop a flexible distributed system which can be used at several distributed venues for enrolment and administration of students and courses at these venues. Based on this requirement, we decided to choose web-based architecture and technology to build the application. The reasons which compelled us towards web application include several factors such as: web application can be used anywhere via internet browser and there is no need any additional installation at user-end and minimal user training\u00a0\u2026", "num_citations": "1\n", "authors": ["639"]}
{"title": "Enhancing Distributed Simulation Systems by Utilizing Component-based Technologies\n", "abstract": " Simulations in today\u2019s industry are becoming increasingly complex and are requiring more and more computing power to gain higher efficiency. One way of solving this is by adding computing power to the machine performing the simulation. However, this approach is not only costly but also in some cases requires time-consuming re-programming of the simulation environment to fully utilize the increased performance. A solution to this is to divide the problem into different subtasks and distribute them on several machines running possibly different simulators. Although this at first glance seems to be an appealing solution, these types of systems tend to introduce new obstacles. In order to minimize costs, these distributed simulation environments often need to include many already existing systems. The simulators are also in many cases closed environments, which are difficult to communicate with due to their varying data format, communication protocol and data exchange models. For such heterogeneous systems it is a challenge to obtain a seamless integration, in particular if there are requirements for system expansion either by integrating new simulators or introducing new simulations. This paper describes these challenges and a middleware concept that meets them. Further it gives an example the middleware component \u201cthe DOTS Middleware Model (DMM)\u201d that has been developed and that meets the requirements and challenges discussed.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Composing Systems From Components\n", "abstract": " Component-based Software Engineering (CBSE) is concerned with the development of systems from reusable parts (components), the development of components, and system maintenance and improvement by means of component replacement or customization. Building systems from components and building components for different systems requires established methodologies and processes not only in relation to development/maintenance phases, but also to the entire component and system lifecycle including organizational, marketing, legal, and other aspects. In addition to objectives such as component specification, composition, and component technology development that are specific to CBSE, there are a number of software engineering disciplines and processes that require methodologies be specialized for application in component-based development. Many of these methodologies are not yet established in practice, some have not yet been developed. The progress of software development in the near future will depend very much on the successful establishment of CBSE; this is recognized by both industry and academia. The growing interest in CBSE is also reflected in the number of workshops and conferences with CBSE tracks [2-5].", "num_citations": "1\n", "authors": ["639"]}
{"title": "Experience of using a simple SCM tool in a complex development environment\n", "abstract": " Using a base tool like RCS is not sufficient for large software systems, but such a tool is very good for building more complex tools on top of it.             The experience has shown that it is very important to have an SCM tool that is a general enough and flexible enough for adjusting to development processes.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Paper I\n", "abstract": " Software systems no longer evolve as separate entities but are also integrated with each other. The purpose of integrating software systems can be to increase user-value or to decrease maintenance costs. Different approaches, one of which is software architectural analysis, can be used in the process of integration planning and design.This paper presents a case study in which three software systems were to be integrated. We show how architectural reasoning was used to design and compare integration alternatives. In particular, four different levels of the integration were discussed (interoperation, a so-called Enterprise Application Integration, an integration based on a common data model, and a full integration). We also show how cost, time to delivery and maintainability of the integrated solution were estimated.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Component-Based Development-a New Approach in Software Development\n", "abstract": " Component-based development is a new paradigm in software development. The basic principles of this new trend is to re-use components that are developed independently of the final product. New products are developed by inclusions of the already completed components, and in this way the development time and costs can be dramatically decreased. Component-based software engineering has many advantages, but also many disadvantages. For example, it is more difficult to predict the behavior of external components built in the products. The maintenance and service require a new approach to achieve the quality and reliability of the products.There are many consequences of component-based development. Huge, in-hose built monolith applications are being replaced by, component-based, flexible applications based on standard solutions. Similar (or the same) problems are being solved by using standardized components. Big software companies do not need as many software developers as before, they focus on the development on their\" core-business\", while the rest is bough, or outsourced. This implies emerge of many smaller specialized small companies. What are the trends in component-based software engineering, what are the consequences and what are the chances for smaller countries like Croatia to participate in this process? These are the topics of the report.", "num_citations": "1\n", "authors": ["639"]}
{"title": "Component-based Software Engineering: Building Systems form Software Components\n", "abstract": " Component-based Software Engineering (CBSE) is concerned with the development of systems from software components, the development of components, and system maintenance and improvement by means of component replacement or customization [1]. Building systems from components and building components for different systems requires established methodologies and processes not only in relation to development/maintenance phases, but also to the entire component and system lifecycle including organizational, marketing, legal, and other aspects. In addition to objectives such as component specification, composition, and component technology development that are specific to CBSE, there are a number of software engineering disciplines and processes that require methodologies be specialized for application in component-based development. Many of these methodologies are not yet established in practice, some have not yet been developed. Experiences from other areas, such as system engineering can be successfully applied on componentbased development, as there are many similarities in the basic concepts (for example, relations between systems and components). Also, with its focus on components and their specifications, CBSE can give better understanding of building systems in general, and in particular of computer-based systems whose significant part is software.The progress of software and system development in the near future will depend very much on the successful establishment of CBSE; this is recognized by both industry and academia. The growing interest in CBSE is reflected in the number of\u00a0\u2026", "num_citations": "1\n", "authors": ["639"]}
{"title": "Teaching Theory of Science to Computer Science Students\n", "abstract": " An ideal Science for the existing Theory of Science (Popper, Carnap, Kuhn, Chalmers) is Physics. Not many modern Sciences conform to that ideal, however. Philosophy of Science (Theory of Science) as it is today is not of much help when trying to understand eg Computer Science. There is an urgent need to broaden the Theory of Science perspective in order to match the present situation within the area, as well as to help its further development.Computer Science has its basis in Logic and Mathematics, and in many cases its theoretical and experimental research methods follow patterns of classical scientific fields of Logic/Mathematics and Natural Sciences. On the other hand, computer modeling and simulation which is specific for the discipline and it is rapidly growing in importance, applied to computers, as well as to other scientific and artistic fields, hardly corresponds to traditional definition of scientific method. Situation gets even more complicated in the field of Intelligent Systems (Artificial Intelligence, AI. This paper addresses the need for paradigm shift within Theory of Science. It shows that it is essential for students of Computer Science to not only acquire the concepts from Theory of Science within its conventional domain, but also widen the perspective and see the field in its context of other scientific traditions.", "num_citations": "1\n", "authors": ["639"]}