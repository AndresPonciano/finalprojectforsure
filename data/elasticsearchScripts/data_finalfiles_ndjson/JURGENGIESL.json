{"title": "Termination of term rewriting using dependency pairs\n", "abstract": " We present techniques to prove termination and innermost termination of term rewriting systems automatically. In contrast to previous approaches, we do not compare left- and right-hand sides of rewrite rules, but introduce the notion of dependency pairs to compare left-hand sides with special subterms of the right-hand sides. This results in a technique which allows to apply existing methods for automated termination proofs to term rewriting systems where they failed up to now. In particular, there are numerous term rewriting systems where a direct termination proof with simplification orderings is not possible, but in combination with our technique, well-known simplification orderings (such as the recursive path ordering, polynomial orderings, or the Knuth\u2013Bendix ordering) can now be used to prove termination automatically. Unlike previous methods, our technique for proving innermost termination automatically can\u00a0\u2026", "num_citations": "734\n", "authors": ["290"]}
{"title": "Modular termination proofs for rewriting using dependency pairs\n", "abstract": " Recently, Arts and Giesl developed the dependency pair approach which allows automated termination and innermost termination proofs for many term rewriting systems (TRSs) for which such proofs were not possible before. The motivation for this approach was that virtually all previous techniques for automated termination proofs of TRSs were based on simplification orderings. In practice, however, many rewrite systems are not simply terminating, i.e. their termination cannot be verified by any simplification ordering. In this paper we introduce a refinement of the dependency pair framework which further extends the class of TRSs for which termination or innermost termination can be shown automatically. By means of this refinement, one can now prove termination in a modular way. Thus, this refinement is inevitable in order to verify the termination of large rewrite systems occurring in practice. To be more precise\u00a0\u2026", "num_citations": "102\n", "authors": ["290"]}
{"title": "Transformation techniques for context-sensitive rewrite systems\n", "abstract": " Context-sensitive rewriting is a computational restriction of term rewriting used to model non-strict (lazy) evaluation in functional programming. The goal of this paper is the study and development of techniques to analyze the termination behavior of context-sensitive rewrite systems. For that purpose, several methods have been proposed in the literature which transform context-sensitive rewrite systems into ordinary rewrite systems such that termination of the transformed ordinary system implies termination of the original context-sensitive system. In this way, the huge variety of existing techniques for termination analysis of ordinary rewriting can be used for context-sensitive rewriting, too. We analyze the existing transformation techniques for proving termination of context-sensitive rewriting and we suggest two new transformations. Our first method is simple, sound, and more powerful than the previously proposed\u00a0\u2026", "num_citations": "91\n", "authors": ["290"]}
{"title": "Generating polynomial orderings for termination proofs\n", "abstract": " Most systems for the automation of termination proofs using polynomial orderings are only semi-automatic, i.e. the \u201cright\u201d polynomial ordering has to be given by the user. We show that a variation of Lank-ford's partial derivative technique leads to an easier and slightly more powerful method than most other semi-automatic approaches. Based on this technique we develop a method for the automated synthesis of a suited polynomial ordering.", "num_citations": "88\n", "authors": ["290"]}
{"title": "Termination of nested and mutually recursive algorithms\n", "abstract": " This paper deals with automated termination analysis for functional programs. Previously developed methods for automated termination proofs of functional programs often fail for algorithms with nested recursion and they cannot handle algorithms with mutual recursion.               We show that termination proofs for nested and mutually recursive algorithms can be performed without having to prove the correctness of the algorithms simultaneously. Using this result, nested and mutually recursive algorithms do no longer constitute a special problem and the existing methods for automated termination analysis can be extended to nested and mutual recursion in a straightforward way. We give some examples of algorithms whose termination can now be proved automatically (including well-known challenge problems such as McCarthy\u2019s f_91 function).", "num_citations": "86\n", "authors": ["290"]}
{"title": "Automatically proving termination where simplification orderings fail\n", "abstract": " To prove termination of term rewriting systems (TRSs), several methods have been developed to synthesize suitable well-founded orderings automatically. However, virtually all orderings that are amenable to automation are so-called simplification orderings. Unfortunately, there exist numerous interesting and relevant TRSs that cannot be oriented by orderings of this restricted class and therefore their termination cannot be proved automatically with the existing techniques.             In this paper we present a new approach which allows to apply the standard techniques for automated termination proofs to those TRSs where these techniques failed up to now. For that purpose we have developed a procedure which, given a TRS, generates a set of inequalities (constraints) automatically. If there exists a well-founded ordering satisfying these constraints, then the TRS is terminating. It turns out that for many TRSs\u00a0\u2026", "num_citations": "84\n", "authors": ["290"]}
{"title": "Verification of Erlang processes by dependency pairs\n", "abstract": " Erlang is a functional programming language developed by Ericsson Telecom, which is particularly well suited for implementing concurrent processes. In this paper we show how methods from the area of term rewriting are presently used at Ericsson. To verify properties of processes, such a property is transformed into a termination problem of a conditional term rewriting system (CTRS). Subsequently, this termination proof can be performed automatically using dependency pairs.               The paper illustrates how the dependency pair technique can be applied for termination proofs of conditional TRSs. Secondly, we present three refinements of this technique, viz. narrowing, rewriting, and instantiating dependency pairs. These refinements are not only of use in the industrial applications sketched in this paper, but they are generally applicable to arbitrary (C)TRSs. Thus, in this way dependency pairs can be\u00a0\u2026", "num_citations": "79\n", "authors": ["290"]}
{"title": "Proving innermost normalisation automatically\n", "abstract": " We present a technique to prove innermost normalisation of term rewriting systems (TRSs) automatically. In contrast to previous methods, our technique is able to prove innermost normalisation of TRSs that are not terminating.             Our technique can also be used for termination proofs of all TRSs where innermost normalisation implies termination, such as non-overlapping TRSs or locally confluent overlay systems. In this way, termination of many (also non-simply terminating) TRSs can be verified automatically.", "num_citations": "73\n", "authors": ["290"]}
{"title": "Termination analysis for functional programs using term orderings\n", "abstract": " To prove the termination of a functional program there has to be a well-founded ordering such that the arguments in each recursive call are smaller than the corresponding inputs. In this paper we present a procedure for automated termination proofs of functional programs. In contrast to previously presented methods a suited well-founded ordering does not have to be fixed in advance by the user, but can be synthesized automatically.             For that purpose we use approaches developed in the area of term rewriting systems for the automated generation of suited well-founded term orderings. But unfortunately term orderings cannot be directly used for termination proofs of functional programs which call other algorithms in the arguments of their recursive calls. The reason is that while for the termination of term rewriting systems orderings between terms are needed, for functional programs we need orderings\u00a0\u2026", "num_citations": "71\n", "authors": ["290"]}
{"title": "Automated Detection of Non-termination and NullPointerExceptions for Java Bytecode\n", "abstract": " Recently, we developed an approach for automated termination proofs of Java Bytecode (JBC), which is based on constructing and analyzing termination graphs. These graphs represent all possible program executions in a finite way. In this paper, we show that this approach can also be used to detect non-termination or NullPointerExceptions. Our approach automatically generates witnesses, i.e., calling the program with these witness arguments indeed leads to non-termination resp. to a NullPointerException. Thus, we never obtain \u201cfalse positives\u201d. We implemented our results in the termination prover AProVE and provide experimental evidence for the power of our approach.", "num_citations": "63\n", "authors": ["290"]}
{"title": "The size-change principle and dependency pairs for termination of term rewriting\n", "abstract": " In [24], a new size-change principle was proposed to verify termination of functional programs automatically. We extend this principle in order to prove termination and innermost termination of arbitrary term rewrite systems (TRSs). Moreover, we compare this approach with existing techniques for termination analysis of TRSs (such as recursive path orders or dependency pairs). It turns out that the size-change principle on its own fails for many examples that can be handled by standard techniques for rewriting, but there are also TRSs where it succeeds whereas existing rewriting techniques fail. Moreover, we also compare the complexity of the respective methods. To this end, we develop the first complexity analysis for the dependency pair approach. While the size-change principle is PSPACE-complete, we prove that the dependency pair approach (in combination with classical path orders) is only\u00a0\u2026", "num_citations": "59\n", "authors": ["290"]}
{"title": "A collection of examples for termination of term rewriting using dependency pairs\n", "abstract": " This report contains a collection of examples to demonstrate the use and the power of the dependency pair technique developed by Arts and Giesl. This technique allows automated termination and innermost termination proofs for many term rewrite systems for which such proofs were not possible before.", "num_citations": "56\n", "authors": ["290"]}
{"title": "Analyzing innermost runtime complexity of term rewriting by dependency pairs\n", "abstract": " We present a modular framework to analyze the innermost runtime complexity of term rewrite systems automatically. Our method is based on the dependency pair framework for termination analysis. In contrast to previous work, we developed a direct adaptation of successful termination techniques from the  dependency pair framework in order to use them for complexity analysis. By extensive experimental results, we demonstrate the power of our method compared to existing techniques.", "num_citations": "54\n", "authors": ["290"]}
{"title": "Dependency pairs for equational rewriting\n", "abstract": " The dependency pair technique of Arts and Giesl [1,2,3] for termination proofs of term rewrite systems (TRSs) is extended to rewriting modulo equations. Up to now, such an extension was only known in the special case of AC-rewriting [15,17]. In contrast to that, the proposed technique works for arbitrary non-collapsing equations (satisfying a certain linearity condition). With the proposed approach, it is now possible to perform automated termination proofs for many systems where this was not possible before. In other words, the power of dependency pairs can now also be used for rewriting modulo equations.", "num_citations": "53\n", "authors": ["290"]}
{"title": "Polynomial interpretations as a basis for termination analysis of logic programs\n", "abstract": " This paper introduces a new technique for termination analysis of definite logic programs based on polynomial interpretations. The principle of this technique is to map each function and predicate symbol to a polynomial over some domain of natural numbers, like it has been done in proving termination of term rewriting systems. Such polynomial interpretations can be seen as a direct generalisation of the traditional techniques in termination analysis of LPs, where (semi-) linear norms and level mappings are used. Our extension generalises these to arbitrary polynomials. We extend a number of standard concepts and results on termination analysis to the context of polynomial interpretations. We propose a constraint based approach for automatically generating polynomial interpretations that satisfy termination conditions.", "num_citations": "50\n", "authors": ["290"]}
{"title": "Size-change termination for term rewriting\n", "abstract": " In [13], a new size-change principle was proposed to verify termination of functional programs automatically. We extend this principle in order to prove termination and innermost termination of arbitrary term rewrite systems (TRSs). Moreover, we compare this approach with existing techniques for termination analysis of TRSs (such as recursive path orderings or dependency pairs). It turns out that the size-change principle on its own fails for many examples that can be handled by standard techniques for rewriting, but there are also TRSs where it succeeds whereas existing rewriting techniques fail. In order to benefit from their respective advantages, we show how to combine the size-change principle with classical orderings and with dependency pairs. In this way, we obtain a new approach for automated termination proofs of TRSs which is more powerful than previous approaches.", "num_citations": "48\n", "authors": ["290"]}
{"title": "Automated Termination Proofs for Java Programs with Cyclic Data\n", "abstract": " In earlier work, we developed a technique to prove termination of Java programs automatically: first, Java programs are automatically transformed to term rewrite systems (TRSs) and then, existing methods and tools are used to prove termination of the resulting TRSs. In this paper, we extend our technique in order to prove termination of algorithms on cyclic data such as cyclic lists or graphs automatically. We implemented our technique in the tool AProVE and performed extensive experiments to evaluate its practical applicability.", "num_citations": "47\n", "authors": ["290"]}
{"title": "Transforming context-sensitive rewrite systems\n", "abstract": " We present two new transformation techniques for proving termination of context-sensitive rewriting. Ourfirst method is simple, sound, and more powerful than previously suggested transformations. However, it is not complete, i.e., there are terminating context-sensitive rewrite systems that are transformed into non-terminating term rewrite systems. The second method that we present in this paper is both sound and complete. This latter result can be interpreted as stating that from a termination perspective there is no reason to study context-sensitive rewriting.", "num_citations": "47\n", "authors": ["290"]}
{"title": "Modularity of termination using dependency pairs\n", "abstract": " The framework of dependency pairs allows automated termination and innermost termination proofs for many TRSs where such proofs were not possible before. In this paper we present a refinement of this framework in order to prove termination in a modular way. Our modularity results significantly increase the class of term rewriting systems where termination resp. innermost termination can be proved automatically. Moreover, the modular approach to dependency pairs yields new modularity criteria which extend previous results in this area. In particular, existing results for modularity of innermost termination can easily be obtained as direct consequences of our new criteria.", "num_citations": "35\n", "authors": ["290"]}
{"title": "Proving non-looping non-termination automatically\n", "abstract": " We introduce a technique to prove non-termination of term rewrite systems automatically. Our technique improves over previous approaches substantially, as it can also detect non-looping non-termination.", "num_citations": "33\n", "authors": ["290"]}
{"title": "Decidable classes of inductive theorems\n", "abstract": " Kapur and Subramaniam [8] defined syntactical classes of equations where inductive validity is decidable. Thus, their validity can be checked without any user interaction and hence, this allows an integration of (a restricted form of) induction in fully automated reasoning tools such as model checkers. However, the results of [8] were only restricted to equations. This paper extends the classes of conjectures considered in [8] to a larger class of arbitrary quantifier-free formulas (e.g., conjectures also containing negation, conjunction, disjunction, etc.).", "num_citations": "33\n", "authors": ["290"]}
{"title": "The termination and complexity competition\n", "abstract": " The termination and complexity competition (termCOMP) focuses on automated termination and complexity analysis for various kinds of programming paradigms, including categories for term rewriting, integer transition systems, imperative programming, logic programming, and functional programming. In all categories, the competition also welcomes the participation of tools providing certifiable output. The goal of the competition is to demonstrate the power and advances of the stateof-the-art tools in each of these areas.", "num_citations": "28\n", "authors": ["290"]}
{"title": "Innermost termination of context-sensitive rewriting\n", "abstract": " Context-sensitive rewriting is a restriction of term rewriting used to model evaluation strategies in functional programming and in programming languages like OBJ. For example, under certain conditions termination of an OBJ program is equivalent to innermost termination of the corresponding context-sensitive rewrite system [18]. To prove termination of context-sensitive rewriting, several methods have been proposed in the literature which transform context-sensitive rewrite systems into ordinary rewrite systems such that termination of the transformed ordinary system implies termination of the original context-sensitive system. Most of these transformations are not very satisfactory when it comes to proving innermost termination. We investigate the relationship between termination and innermost termination of context-sensitive rewriting and we examine the applicability of the different transformations for\u00a0\u2026", "num_citations": "28\n", "authors": ["290"]}
{"title": "AProVE: Termination and Memory Safety of C Programs\n", "abstract": " AProVE is a system for automatic termination and complexity proofs of C, Java, Haskell, Prolog, and term rewrite systems. The particular strength of AProVE when analyzing C is its capability to reason about pointer arithmetic combined with direct memory accesses (as, e.g., in standard implementations of string algorithms). As a prerequisite for termination, AProVE also proves memory safety of C programs.", "num_citations": "27\n", "authors": ["290"]}
{"title": "Termination competition (termCOMP 2015)\n", "abstract": " The termination competition focuses on automated termination analysis for all kinds of programming paradigms, including categories for term rewriting, imperative programming, logic programming, and functional programming. Moreover, the competition also features categories for automated complexity analysis. In all categories, the competition also welcomes the participation of tools providing certified proofs. The goal of the termination competition is to demonstrate the power of the leading tools in each of these areas.", "num_citations": "26\n", "authors": ["290"]}
{"title": "A dependency pair framework for innermost complexity analysis of term rewrite systems\n", "abstract": " We present a modular framework to analyze the innermost runtime complexity of term rewrite systems automatically. Our method is based on the dependency pair framework for termination analysis. In contrast to previous work, we developed a direct adaptation of successful termination techniques from the dependency pair framework in order to use them for complexity analysis. By extensive experimental results, we demonstrate the power of our method compared to existing techniques.", "num_citations": "26\n", "authors": ["290"]}
{"title": "Termination analysis for functional programs\n", "abstract": " Proving termination is a central problem in software development and formal methods for termination analysis are essential for program verification. However, since the halting problem is undecidable and totality of functions is not even semi-decidable, there is no procedure to prove or disprove the termination of all algorithms.", "num_citations": "26\n", "authors": ["290"]}
{"title": "Deciding inductive validity of equations\n", "abstract": " Kapur and Subramaniam [12] defined syntactical classes of equations where inductive validity can be decided automatically. However, these classes are quite restrictive, since defined function symbols with recursive definitions may only appear on one side of the equations. In this paper, we expand the decidable class of equations significantly by allowing both sides of equations to be expressed using defined function symbols. The definitions of these function symbols must satisfy certain restrictions which can be checked mechanically. These results are crucial to increase the applicability of decision procedures for induction.", "num_citations": "25\n", "authors": ["290"]}
{"title": "Termination analysis for partial functions\n", "abstract": " This paper deals with automated termination analysis for partial functional programs, i.e. for functional programs which do not terminate for each input. We present a method to determine their domains (resp. non-trivial subsets of their domains) automatically. More precisely, for each functional program a termination predicate algorithm is synthesized, which only returns true for inputs where the program is terminating. To ease subsequent reasoning about the generated termination predicates we also present a procedure for their simplification.", "num_citations": "25\n", "authors": ["290"]}
{"title": "Liveness in rewriting\n", "abstract": " In this paper, we show how the problem of verifying liveness properties is related to termination of term rewrite systems (TRSs). We formalize liveness in the framework of rewriting and present a sound and complete transformation to transform particular liveness problems into TRSs. Then the transformed TRS terminates if and only if the original liveness property holds. This shows that liveness and termination are essentially equivalent. To apply our approach in practice, we introduce a simpler sound transformation which only satisfies the \u2018only if\u2019-part. By refining existing techniques for proving termination of TRSs we show how liveness properties can be verified automatically. As examples, we prove a liveness property of a waiting line protocol for a network of processes and a liveness property of a protocol on a ring of processes.", "num_citations": "24\n", "authors": ["290"]}
{"title": "Aiming low is harder: Induction for lower bounds in probabilistic program verification\n", "abstract": " We present a new inductive rule for verifying lower bounds on expected values of random variables after execution of probabilistic loops as well as on their expected runtimes. Our rule is simple in the sense that loop body semantics need to be applied only finitely often in order to verify that the candidates are indeed lower bounds. In particular, it is not necessary to find the limit of a sequence as in many previous rules.", "num_citations": "22\n", "authors": ["290"]}
{"title": "Pushing the frontiers of combining rewrite systems farther outwards\n", "abstract": " It is well known that simple termination is modular for certain kinds of combinations of term rewriting systems (TRSs). This result is of practical relevance because most techniques for (automated) termination proofs use simplification orderings, so they show in fact simple termination. On the other hand, in practice many systems are non-simply terminating. In order to cope with such systems, Arts and Giesl developed the dependency pair approach. By using (quasi-) simplification orderings in combination with dependency pairs, it is possible to prove termination of non-simply terminating systems automatically. It is natural to ask whether modularity of simple termination can be extended to the class of those systems which can be handled by this technique. In this paper we show that this is indeed the case. In this way, the class of TRSs for which termination can be proved in a modular way is extended significantly.", "num_citations": "22\n", "authors": ["290"]}
{"title": "Termination of Isabelle functions via termination of rewriting\n", "abstract": " We show how to automate termination proofs for recursive functions in (a first-order subset of) Isabelle/HOL by encoding them as term rewrite systems and invoking an external termination prover. Our link to the external prover includes full proof reconstruction, where all necessary properties are derived inside Isabelle/HOL without oracles. Apart from the certification of the imported proof, the main challenge is the formal reduction of the proof obligation produced by Isabelle/HOL to the termination of the corresponding term rewrite system. We automate this reduction via suitable tactics which we added to the IsaFoR library.", "num_citations": "20\n", "authors": ["290"]}
{"title": "Approximating the domains of functional and imperative programs\n", "abstract": " This paper deals with automated termination analysis of partial functional programs, that is, of functional programs which do not terminate for some input. We present a method to determine their domains (respectively non-trivial subsets of their domains) automatically. More precisely, for each functional program a termination predicate algorithm is synthesized that only returns true for inputs where the program is terminating. To ease subsequent reasoning about the generated termination predicates we also present a procedure for their simplification. Finally, we show that our method can also be used for automated termination analysis of imperative programs.", "num_citations": "20\n", "authors": ["290"]}
{"title": "Termination of constructor systems\n", "abstract": " We present a method to prove termination of constructor systems automatically. Our approach takes advantage of the special form of these rewrite systems because for constructor systems instead of left- and right-hand sides of rules it is sufficient to compare so-called dependency pairs [Art96]. Unfortunately, standard techniques for the generation of well-founded orderings cannot be directly used for the automation of the dependency pair approach. To solve this problem we have developed a transformation technique which enables the application of known synthesis methods for well-founded orderings to prove that dependency pairs are decreasing. In this way termination of many (also non-simply terminating) constructor systems can be proved fully automatically.", "num_citations": "20\n", "authors": ["290"]}
{"title": "Complexity Analysis for Java with AProVE\n", "abstract": " While AProVE is one of the most powerful tools for termination analysis of Java since many years, we now extend our approach in order to analyze the complexity of Java programs as well. Based on a symbolic execution of the program, we develop a novel transformation of (possibly heap-manipulating) Java programs to integer transition systems (ITSs). This allows us to use existing complexity analyzers for ITSs to infer runtime bounds for Java programs. We demonstrate the power of our implementation on an established standard benchmark set.", "num_citations": "18\n", "authors": ["290"]}
{"title": "SAT-based termination analysis using monotonicity constraints over the integers\n", "abstract": " We describe an algorithm for proving termination of programs abstracted to systems of monotonicity constraints in the integer domain. Monotonicity constraints are a nontrivial extension of the well-known size-change termination method. While deciding termination for systems of monotonicity constraints is PSPACE complete, we focus on a well-defined and significant subset, which we call MCNP (for \u201cmonotonicity constraints in NP\u201d), designed to be amenable to a SAT-based solution. Our technique is based on the search for a special type of ranking function defined in terms of bounded differences between multisets of integer values. We describe the application of our approach as the back end for the termination analysis of Java Bytecode. At the front end, systems of monotonicity constraints are obtained by abstracting information, using two different termination analyzers: AProVE and COSTA. Preliminary results\u00a0\u2026", "num_citations": "17\n", "authors": ["290"]}
{"title": "Induction proofs with partial functions\n", "abstract": " In this paper we present a method for automated induction proofs about partial functions. We show that most well-known techniques developed for (explicit) induction theorem proving are unsound when dealing with partial functions. But surprisingly, by slightly restricting the application of these techniques, it is possible to develop a calculus for automated induction proofs with partial functions. In particular, under certain conditions one may even generate induction schemes from the recursions of nonterminating algorithms. The need for such induction schemes and the power of our calculus have been demonstrated on a large collection of nontrivial theorems (including Knuth and Bendix's critical pair lemma). In this way, existing induction theorem provers can be directly extended to partial functions without major changes of their logical framework.", "num_citations": "17\n", "authors": ["290"]}
{"title": "Context-moving transformations for function verification\n", "abstract": " Several induction theorem provers have been developed which support mechanized verification of functional programs. Unfortunately, a major problem is that they often fail in verifying tail recursive functions (which correspond to imperative programs). However, in practice imperative programs are used almost exclusively.               We present an automatic transformation to tackle this problem. It transforms functions which are hard to verify into functions whose correctness can be shown by the existing provers. In contrast to classical program transformations, the aim of our technique is not to increase efficiency, but to increase verifiability. Therefore, this paper introduces a novel application area for program transformations and it shows that such techniques can in fact solve some of the most urgent current challenge problems in automated verification and induction theorem proving.", "num_citations": "17\n", "authors": ["290"]}
{"title": "Termination analysis by inductive evaluation\n", "abstract": " We present a new approach for automatic termination analysis of functional programs. Several methods have been presented which try to find a well-founded ordering such that the arguments in the recursive calls are smaller than the corresponding inputs. However, previously developed approaches for automated termination analysis often disregard the conditions under which the recursive calls are evaluated. Hence, the existing methods fail for an important class of algorithms where the necessary information for proving termination is \u2018hidden\u2019 in the conditions. In this paper we develop the inductive evaluation method which analyzes the auxiliary functions occurring in the conditions of the recursive calls. We also discuss an extension of our method to partial functions in order to determine their domains automatically. The proposed technique proved successful for termination analysis of numerous\u00a0\u2026", "num_citations": "17\n", "authors": ["290"]}
{"title": "Automated termination proofs with measure functions\n", "abstract": " This paper deals with the automation of termination proofs for recursively defined algorithms (i.e. algorithms in a pure functional language). Previously developed methods for their termination proofs either had a low degree of automation or they were restricted to one single fixed measure function to compare data objects. To overcome these drawbacks we introduce a calculus for automated termination proofs which is able to handle arbitrary measure functions based on polynomial norms.", "num_citations": "17\n", "authors": ["290"]}
{"title": "Proving termination of programs with bitvector arithmetic by symbolic execution\n", "abstract": " In earlier work, we developed an approach for automated termination analysis of C programs with explicit pointer arithmetic, which is based on symbolic execution. However, similar to many other termination techniques, this approach assumed the program variables to range over mathematical integers instead of bitvectors. This eases mathematical reasoning but is unsound in general. In this paper, we extend our approach in order to handle fixed-width bitvector integers. Thus, we present the first technique for termination analysis of C programs that covers both byte-accurate pointer arithmetic and bit-precise modeling of integers. We implemented our approach in the automated termination prover AProVE and evaluate its power by extensive experiments.", "num_citations": "16\n", "authors": ["290"]}
{"title": "Applying rewriting techniques to the verification of Erlang processes\n", "abstract": " Erlang is a functional programming language developed by Ericsson Telecom which is particularly well suited for implementing con- current processes. In this paper we show how methods from the area of term rewriting are presently used at Ericsson. To verify properties of processes, such a property is transformed into a termination problem of a conditional term rewriting system (CTRS). Subsequently, this termi- nation proof can be performed automatically using dependency pairs. The paper illustrates how the dependency pair technique can be applied for termination proofs of conditional TRSs. Secondly, we present two refinements of this technique, viz. narrowing and rewriting dependency pairs. These refinements are not only of use in the industrial application sketched in this paper, but they are generally applicable to arbitrary (C)TRSs. Thus, in this way dependency pairs can be used to prove ter\u00a0\u2026", "num_citations": "15\n", "authors": ["290"]}
{"title": "Exotic semiring constraints\n", "abstract": " Exotic semiring constraints arise in a variety of applications and in particular in the context of automated termination analysis. We propose two techniques to solve such constraints:(a) to model them using Boolean functions and integer linear arithmetic and solve them using an SMT solver (QF LIA, in certain cases also QF IDL); and (b) to seek finite domain solutions by applying unary bit-blasting and solve them using a SAT solver. In this note, we show the structure of such systems of constraints, and report on the performance of SMT solvers and SAT encodings when solving them. In particular, we observe that good results are obtained by unary bit-blasting, improving on previous proposals to apply binary bit-blasting. Moreover, our results indicate that, for our benchmarks, unary bit-blasting leads to better results than the ones directly obtained by an SMT solver.", "num_citations": "14\n", "authors": ["290"]}
{"title": "Lower bounds for runtime complexity of term rewriting\n", "abstract": " We present the first approach to deduce lower bounds for (worst-case) runtime complexity of term rewrite systems (TRSs) automatically. Inferring lower runtime bounds is useful to detect bugs and to complement existing methods that compute upper complexity bounds. Our approach is based on two techniques: the induction technique generates suitable families of rewrite sequences and uses induction proofs to find a relation between the length of a rewrite sequence and the size of the first term in the sequence. The loop detection technique searches for \u201cdecreasing loops\u201d. Decreasing loops generalize the notion of loops for TRSs, and allow us to detect families of rewrite sequences with linear, exponential, or infinite length. We implemented our approach in the tool AProVE and evaluated it by extensive experiments.", "num_citations": "13\n", "authors": ["290"]}
{"title": "POLO| A System for Termination Proofs using Polynomial Orderings\n", "abstract": " POLO is a system for both semi-automatic and fully automated termination proofs of term rewriting systems using polynomial orderings. In this paper we describe the system's user interface and illustrate its performance with some examples.", "num_citations": "13\n", "authors": ["290"]}
{"title": "Termination of triangular integer loops is decidable\n", "abstract": " We consider the problem whether termination of affine integer loops is decidable. Since Tiwari conjectured decidability in 2004 [15], only special cases have been solved [3, 4, 14]. We complement this work by proving decidability for the case that the update matrix is triangular.", "num_citations": "12\n", "authors": ["290"]}
{"title": "Proving non-termination via loop acceleration\n", "abstract": " We present the first approach to prove non-termination of integer programs that is based on loop acceleration. If our technique cannot show non-termination of a loop, it tries to accelerate it instead in order to find paths to other non-terminating loops automatically. The prerequisites for our novel loop acceleration technique generalize a simple yet effective non-termination criterion. Thus, we can use the same program transformations to facilitate both non-termination proving and loop acceleration. In particular, we present a novel invariant inference technique that is tailored to our approach. An extensive evaluation of our fully automated tool LoAT shows that it is competitive with the state of the art.", "num_citations": "10\n", "authors": ["290"]}
{"title": "Analyzing Runtime Complexity via Innermost Runtime Complexity.\n", "abstract": " There exist powerful techniques to infer upper bounds on the innermost runtime complexity of term rewrite systems (TRSs), ie, on the lengths of rewrite sequences that follow an innermost evaluation strategy. However, the techniques to analyze the (full) runtime complexity of TRSs are substantially weaker. In this paper, we present a sufficient criterion to ensure that the runtime complexity of a TRS coincides with its innermost runtime complexity. This criterion can easily be checked automatically and it allows us to use all techniques and tools for innermost runtime complexity in order to analyze (full) runtime complexity. By extensive experiments with an implementation of our results in the tool AProVE, we show that this improves the state of the art of automated complexity analysis significantly.", "num_citations": "10\n", "authors": ["290"]}
{"title": "Inferring lower bounds for runtime complexity\n", "abstract": " We present the first approach to deduce lower bounds for innermost runtime complexity of term rewrite systems (TRSs) automatically. Inferring lower runtime bounds is useful to detect bugs and to complement existing techniques that compute upper complexity bounds. The key idea of our approach is to generate suitable families of rewrite sequences of a TRS and to find a relation between the length of such a rewrite sequence and the size of the first term in the sequence. We implemented our approach in the tool AProVE and evaluated it by extensive experiments.", "num_citations": "10\n", "authors": ["290"]}
{"title": "Induction and decision procedures\n", "abstract": " Mechanization of inductive reasoning is an exciting research area in artificial intelligence and automated reasoning with many challenges. An overview of our work on mechanizing inductive reasoning based on the cover set method for generating induction schemes from terminating recursive function definitions and using decision procedures is presented. This paper particularly focuses on the recent work on integrating induction into decision procedures without compromising their automation.", "num_citations": "10\n", "authors": ["290"]}
{"title": "Polynomial loops: Beyond termination\n", "abstract": " Polynomial Loops: Beyond Termination Page 1 Polynomial Loops: Beyond Termination 23rd Conference on Logic for Programming, Artificial Intelligence and Reasoning Marcel Hark Florian Frohn J\u00fcrgen Giesl LPAR-23 \u2013 Polynomial Loops: Beyond Termination \u2013 Hark, Frohn, Giesl \u2013 January 13 \u2013 Slide 1 Page 2 Motivation Setting the stage \u2022 Termination on a given input and Runtime Complexity are among the most important program properties. \u2192 Witnesses for non-termination indicate implementation bugs. \u2192 Runtime bounds indicate efficiency of a program. \u2022 Drawback: Termination on a given input of general programs (Halting Problem) is undecidable [Turing 1937]. \u2192 No technique which can (dis-)prove Halting Problem for all programs. \u2022 Hope: Find sub-classes of programs where Halting Problem is decidable and runtime bounds can be computed. \u2192 For Halting Problem: Linear loops [Li \u201917, Kincaid et al. \u201919] (\u2026", "num_citations": "9\n", "authors": ["290"]}
{"title": "Termination and complexity analysis for programs with bitvector arithmetic by symbolic execution\n", "abstract": " In earlier work, we developed an approach for automated termination analysis of C programs with explicit pointer arithmetic, which is based on symbolic execution. However, similar to many other termination techniques, this approach assumed the program variables to range over mathematical integers instead of bitvectors. This eases mathematical reasoning but is unsound in general. In this paper, we extend our approach in order to handle fixed-width bitvector integers. Thus, we present the first technique for termination analysis of C programs that covers both byte-accurate pointer arithmetic and bit-precise modeling of integers. Moreover, we show that our approach can also be used to analyze the runtime complexity of bitvector programs. We implemented our contributions in the automated termination prover AProVE and evaluate its power by extensive experiments.", "num_citations": "9\n", "authors": ["290"]}
{"title": "Automated reasoning\n", "abstract": " Automated Reasoning - NASA/ADS Now on home page ads icon ads Enable full ADS view NASA/ADS Automated Reasoning Giesl, J\u00fcrgen ; H\u00e4hnle, Reiner Abstract Publication: Lecture Notes in Computer Science Pub Date: 2010 DOI: 10.1007/978-3-642-14203-1 Bibcode: 2010LNCS......G Keywords: Computer Science; Artificial Intelligence (incl. Robotics); Mathematical Logic and Formal Languages; Logics and Meanings of Programs; Logic Design; Discrete Mathematics in Computer Science; Mathematics of Computing full text sources Publisher | \u00a9 The SAO/NASA Astrophysics Data System adshelp[at]cfa.harvard.edu The ADS is operated by the Smithsonian Astrophysical Observatory under NASA Cooperative Agreement NNX16AC86A NASA logo Smithsonian logo Resources About ADS ADS Help What's New Careers@ADS Social @adsabs ADS Blog Project Switch to full ADS Is ADS down? (or is it just me...) \u2026", "num_citations": "9\n", "authors": ["290"]}
{"title": "Equational termination by semantic labelling\n", "abstract": " Semantic labelling is a powerful tool for proving termination of term rewrite systems. The usefulness of the extension to equational term rewriting described in Zantema [24] is however rather limited. In this paper we introduce a stronger version of equational semantical labelling, parameterized by three choices: (1) the order on the underlying algebra (partial order vs. quasi-order), (2) the relation between the algebra and the rewrite system (model vs. quasi-model), and (3) the labelling of the function symbols appearing in the equations (forbidden vs. allowed). We present soundness and completeness results for the various instantiations and analyze the relationships between them. Applications of our equational semantic labelling technique include a short proof of the main result of Ferreira et al. [7]\u2014the correctness of a version of dummy elimination for AC-rewriting which completely removes the AC-axioms\u00a0\u2026", "num_citations": "9\n", "authors": ["290"]}
{"title": "AProVE: Proving and Disproving Termination of Memory-Manipulating C Programs\n", "abstract": " AProVE is a system for automatic termination and complexity analysis of C, Java, Haskell, Prolog, and several forms of rewrite systems. The new contributions in this version of AProVE are its capabilities to prove non-termination of C programs and to handle recursive C programs, even if these programs use pointer arithmetic combined with direct memory accesses. Moreover, in addition to mathematical integers, AProVE can now also handle fixed-width bitvector integers.", "num_citations": "8\n", "authors": ["290"]}
{"title": "Deaccumulation techniques for improving provability\n", "abstract": " Several induction theorem provers were developed to verify functional programs mechanically. Unfortunately, automatic verification often fails for functions with accumulating arguments. Using concepts from the theory of tree transducers and extending on earlier work, the paper develops automatic transformations from accumulative functional programs into non-accumulative ones, which are much better suited for mechanized verification. The overall goal is to reduce the need for generalizing induction hypotheses in (semi-)automatic provers. Via the correspondence between imperative programs and tail-recursive functions, the presented approach can also help to reduce the need for inventing loop invariants in the verification of imperative programs.", "num_citations": "7\n", "authors": ["290"]}
{"title": "Term Rewriting and Applications\n", "abstract": " This volume contains the proceedings of the 16th International Conference on Rewriting Techniques and Applications (RTA 2005), which was held on April 19\u201321, 2005, at the Nara-Ken New Public Hall in the center of the Nara National Park in Nara, Japan.RTA is the major forum for the presentation of research on all aspects of rewriting. Previous RTA conferences were held in Dijon (1985), Bordeaux (1987), Chapel Hill (1989), Como (1991), Montreal (1993), Kaiserslautern (1995), Rutgers (1996), Sitges (1997), Tsukuba (1998), Trento (1999), Norwich (2000), Utrecht (2001), Copenhagen (2002), Valencia (2003), and Aachen (2004). This year, there were 79 submissions from 20 countries, of which 31 papers were accepted for publication (29 regular papers and 2 system descriptions). The submissions came from France (10 accepted papers of the 23.1 submitted papers), USA (5.6 of 11.7), Japan (4 of 9), Spain\u00a0\u2026", "num_citations": "7\n", "authors": ["290"]}
{"title": "Eliminating dummy elimination\n", "abstract": " This paper is concerned with methods that automatically prove termination of term rewrite systems. The aim of dummy elimination, a method to prove termination introduced by Ferreira and Zantema, is to transform a given rewrite system into a rewrite system whose termination is easier to prove. We show that dummy elimination is subsumed by the more recent dependency pair method of Arts and Giesl. More precisely, if dummy elimination succeeds in transforming a rewrite system into a so-called simply terminating rewrite system then termination of the given rewrite system can be directly proved by the dependency pair technique. Even stronger, using dummy elimination as a preprocessing step to the dependency pair technique does not have any advantages either. We show that to a large extent these results also hold for the argument filtering transformation of Kusakari et al.", "num_citations": "7\n", "authors": ["290"]}
{"title": "Computing expected runtimes for constant probability programs\n", "abstract": " We introduce the class of constant probability (CP) programs and show that classical results from probability theory directly yield a simple decision procedure for (positive) almost sure termination of programs in this class. Moreover, asymptotically tight bounds on their expected runtime can always be computed easily. Based on this, we present an algorithm to infer the exact expected runtime of any CP program.", "num_citations": "6\n", "authors": ["290"]}
{"title": "Deaccumulation\u2013Improving Provability\n", "abstract": " Several induction theorem provers were developed to verify functional programs mechanically. Unfortunately, automated verification usually fails for functions with accumulating arguments. In particular, this holds for tail-recursive functions that correspond to imperative programs, but also for programs with nested recursion.             Based on results from the theory of tree transducers, we develop an automatic transformation technique. It transforms accumulative functional programs into non-accumulative ones, which are much better suited for automated verification by induction theorem provers. Hence, in contrast to classical program transformations aiming at improving the efficiency, the goal of our deaccumulation technique is to improve the provability.", "num_citations": "6\n", "authors": ["290"]}
{"title": "Inferring expected runtimes of probabilistic integer programs using expected sizes\n", "abstract": " We present a novel modular approach to infer upper bounds on the expected runtimes of probabilistic integer programs automatically. To this end, it computes bounds on the runtimes of program parts and on the sizes of their variables in an alternating way. To evaluate its power,\u00a0we implemented our approach in a new version of our open-source tool KoAT.", "num_citations": "5\n", "authors": ["290"]}
{"title": "Simulating liveness by reduction strategies\n", "abstract": " We define a general framework to handle liveness and related properties by reduction strategies in abstract reduction and term rewriting. Classically, reduction strategies in rewriting are used to simulate the evaluation process in programming languages. The aim of our work is to use reduction strategies to also study liveness questions which are of high importance in practice (e.g., in protocol verification for distributed processes). In particular, we show how the problem of verifying liveness is related to termination of term rewrite systems (TRSs). Using our results, techniques for proving termination of TRSs can be used to verify liveness properties.", "num_citations": "5\n", "authors": ["290"]}
{"title": "The critical pair lemma: A case study for induction proofs with partial functions\n", "abstract": " In [9] we presented a calculus for automated induction proofs about partial functions. In contrast to previous work, our approach also allows us to derive induction schemes from the recursions of partial (and in particular, non-terminating) algorithms. In this way, existing induction theorem provers can be directly extended to partial functions without changing their logical framework.", "num_citations": "5\n", "authors": ["290"]}
{"title": "On Gr\u00f6bner bases in SMT-compliant decision procedures\n", "abstract": " Modern satisfiability solvers are able to determine satisfiability of a given propositional logic formula very efficiently. Satisfiability modulo theories (SMT) is an approach to use solvers to determine the satisfiability of formulae from the first order logic over some theories. This thesis aims at the development of methods for deciding consistency of sets of polynomial constraints over the real numbers, which have a decent performance when embedded into an SMT solver. Gr\u00f6bner bases and the Weak Nullstellensatz allow deciding consistency over the complex numbers. Since Gr\u00f6bner basis are frequently used and are subject to a lot of active research, the existing algorithms are highly optimised. In this thesis a well-known algorithm is implemented and extended to make the method SMT-compliant.To decide the unsatisfiability over the real numbers, an application of the Real Nullstellensatz is implemented, in which existing methods for semidefinite programming are combined with Gr\u00f6bner bases to find sums of squares, which are potential witnesses for unsatisfiability. The experimental results show some promising applications, which could be further improved by the implementation of the ideas from the thesis\u2019 comprehensive overview over both theoretical and technical enhancements.", "num_citations": "4\n", "authors": ["290"]}
{"title": "Invariant Generation for Linear Probabilistic Programs\n", "abstract": " Verification is a branch of computer science in which we try to formally prove that a given \u201csystem\u201d behaves correctly. In this context a system may be a software program, a hardware circuit or any other thing that exposes some behaviour. The definition of what is the correct behaviour is given by the system designer.In contrast to testing, verification is a tedious and expensive task. Therefore it is rarely applied in the areas where failures do not harm a user\u2019s safety. For example if a computer game crashes due to a programming error, this has no severe consequences-the player has just to wait for the next patch. Things are different for safety critical systems like control software of rockets, airplanes, trains or the circuit design of massively produced computer chips etc. An error in the design or implementation of such systems may lead to loss of life or the financial breakdown of a manufacturer. Here testing does not suffice because each test only shows that the system works in one particular case but does not show that it will work in all cases. This justifies the application of verification techniques.", "num_citations": "4\n", "authors": ["290"]}
{"title": "Termination of Polynomial Loops\n", "abstract": " We consider the termination problem for triangular weakly non-linear loops (twn-loops) over some ring S S like Z Z, Q Q, or R R. Essentially, the guard of such a loop is an arbitrary Boolean formula over (possibly non-linear) polynomial inequations, and the body is a single assignment where each x_i xi is a variable, c_i \u2208 S ci\u2208 S, and each p_i pi is a (possibly non-linear) polynomial over S S and the variables x_ i+ 1, ..., x_ d xi+ 1,\u2026, xd. We present a reduction from the question of termination to the existential fragment of the first-order theory of S S and R R. For loops over R R, our reduction entails decidability of termination. For loops over Z Z and Q Q, it proves semi-decidability of non-termination. Furthermore, we present a transformation to convert certain non-twn-loops into twn-form. Then the original loop terminates iff the transformed loop terminates over a specific subset of R R, which can also be checked via\u00a0\u2026", "num_citations": "3\n", "authors": ["290"]}
{"title": "On the decidability of termination for polynomial loops\n", "abstract": " We consider the termination problem for triangular weakly non-linear loops (twn-loops) over some ring  like , , or . Essentially, the guard of such a loop is an arbitrary Boolean formula over (possibly non-linear) polynomial inequations, and the body is a single assignment  where each  is a variable, , and each  is a (possibly non-linear) polynomial over  and the variables . We present a reduction from the question of termination to the existential fragment of the first-order theory of  and . For loops over , our reduction entails decidability of termination. For loops over  and , it proves semi-decidability of non-termination. Furthermore, we present a transformation to convert certain non-twn-loops into twn-form. Then the original loop terminates iff the transformed loop terminates over a specific subset of , which can also be checked via our reduction. This transformation also allows us to prove tight complexity bounds for the termination problem for two important classes of loops which can always be transformed into twn-loops.", "num_citations": "3\n", "authors": ["290"]}
{"title": "ELFE\u2013An interactive theorem prover for undergraduate students\n", "abstract": " ELFE is an interactive theorem prover with an easy to use language and user interface. Many present interactive theorem provers assume knowledge of automated theorem proving, ELFE tries to abstract away the technicalities. This allows the system to be used in teaching basic proof methods in discrete Mathematics.The user inputs a mathematical text written in fair English. The text is then converted to a special data-structure of first-order formulas. The internal representation of the text implies certain proof obligations which are checked by automated theorem provers. The background provers try to either proof the obligations or find countermodels if a obligation is wrong. The result of this verification process is then returned to the user.", "num_citations": "3\n", "authors": ["290"]}
{"title": "AProVE\n", "abstract": " AProVE Page 1 LuFG Informatik II AProVE A System for Proving Termination J. Giesl, R. Thiemann, P. Schneider-Kamp, S. Falke http://www-i2.informatik.rwth-aachen.de/AProVE Lehr- und Forschungsgebiet Informatik II Aachen AProVE \u2013 p.1 Page 2 LuFG Informatik II OUTLINE AProVE \u2013 p.2 Page 3 LuFG Informatik II APROVE OVERVIEW AProVE \u2013 p.3 Page 4 LuFG Informatik II DIRECT TERMINATION PROOFS Idea: show \u2192R is subset of a well-founded ordering \u227b AProVE \u2013 p.4 Page 5 LuFG Informatik II DIRECT TERMINATION PROOFS Idea: show \u2192R is subset of a well-founded ordering \u227b Termination Criterion: l \u227b r \u2200 l \u2192 r \u2208 R where \u227b is a well-founded, stable, monotonic ordering. AProVE \u2013 p.4 Page 6 LuFG Informatik II DIRECT TERMINATION PROOFS Idea: show \u2192R is subset of a well-founded ordering \u227b Termination Criterion: l \u227b r \u2200 l \u2192 r \u2208 R where \u227b is a well-founded, stable, monotonic ordering. : pred(s,\u2026", "num_citations": "3\n", "authors": ["290"]}
{"title": "Current trends in automated deduction\n", "abstract": " Automated deduction is one of the key areas in artificial intelligence. In this short article we give an overview on some of the main current research topics in automated deduction.", "num_citations": "2\n", "authors": ["290"]}
{"title": "Term Rewriting and Applications: 16th International Conference, RTA 2005, Nara, Japan, April 19-21, 2005, Proceedings\n", "abstract": " This volume contains the proceedings of the 16th International Conference on Rewriting Techniques and Applications (RTA2005), whichwasheldonApril19\u201321, 2005, at the Nara-Ken New Public Hall in the center of the Nara National Park in Nara, Japan. RTA is the major forum for the presentation of research on all aspects of rewriting. PreviousRTAconferenceswereheldinDijon (1985), Bordeaux (1987), Chapel Hill (1989), Como (1991), Montreal (1993), Kaiserslautern (1995), Rutgers (1996), Sitges (1997), Tsukuba (1998), Trento (1999), Norwich (2000), Utrecht (2001), Copenhagen (2002), Valencia (2003), and Aachen (2004). This year, there were 79 submissions from 20 countries, of which 31 papers were accepted for publication (29 regular papers and 2 system descriptions). The submissions came from France (10 accepted papers of the 23.1 submitted papers), USA (5.6 of 11.7), Japan (4 of 9), Spain (2.7 of 6.5), UK (2.7 of 4.7), The Netherlands (1.7 of 3.8), Germany (1.3 of 2.3), Austria (1 of 1), Poland (1 of 1), Israel (0.5 of 0.8), Denmark (0.5 of 0.5), China (0 of 4), Korea (0 of 4), Taiwan (0 of 1.3), Australia (0 of 1), Brazil (0 of 1), Russia (0 of 1), Switzerland (0 of 1), Sweden (0 of 1), and Italy (0 of 0.3). Each submission was assigned to at least three Program Committee m-bers, who carefully reviewed the papers, with the help of 111 external referees.", "num_citations": "2\n", "authors": ["290"]}
{"title": "Partial functions in induction theorem proving\n", "abstract": " We present an approach for automated induction proofs with partial functions. Most well-known techniques developed for (explicit) induction theorem proving are unsound when dealing with partial functions. But surprisingly, by slightly restricting the application of these techniques, it is possible to develop a calculus for automated induction proofs with partial functions. In particular, under certain conditions one may even generate induction schemes from the recursions of non-terminating algorithms. The need for such induction schemes and the power of our approach have been demonstrated on a large collection of non-trivial theorems (including Knuth and Bendix'critical pair lemma). In this way, existing induction theorem provers can be directly extended to partial functions without changing their logic...", "num_citations": "2\n", "authors": ["290"]}
{"title": "Proving partial correctness of partial functions\n", "abstract": " We present a method for automated induction proofs about partial functions. This method cannot only be used to verify the partial correctness of functional programs, but it also solves some other challenge problems where reasoning about partial functions is necessary. For a further analysis of partial functions we also developed a method to determine (non-trivial subsets of) their domains automatically.", "num_citations": "2\n", "authors": ["290"]}
{"title": "The semantics of rational contractions\n", "abstract": " This paper is concerned with the revision of beliefs in the face of new and possibly contradicting information. In the Logic of Theory Change developed by Alchourron, G\u00e4rdenfors and Makinson this nonmonotonic process consists of a contraction and an expansion of a set of formulas. To achieve minimal change they formulated widely accepted postulates that rational contractions have to fulfill.", "num_citations": "2\n", "authors": ["290"]}
{"title": "Funktionale Programmierung\n", "abstract": " Generell unterscheiden wir grunds\u00e4tzlich zwischen imperativen und deklarativen Programmiersprachen (wobei sich deklarative Sprachen weiter in funktionale und logische Sprachen unterteilen). In imperativen Sprachen setzen sich die Programme aus einer Folge von nacheinander ausgef\u00fchrten Anweisungen zusammen, die die Werte der Variablen im Speicher ver\u00e4ndern. Die meisten der heute verwendeten Programmiersprachen beruhen auf diesem Prinzip, das auch einen direkten Zusammenhang zu der klassischen Rechnerarchitektur besitzt, die auf John von Neumann zur\u00fcckgeht. In der deklarativen Programmierung bestehen die Programme hingegen aus einer Spezifikation dessen, was berechnet werden soll. Die Festlegung, wie die Berechnung genau verlaufen soll, wird dem Interpreter bzw. dem Compiler \u00fcberlassen. Deklarative Programmiersprachen sind daher problemorientiert statt maschinenorientiert. Einerseits sind die verschiedenen Programmiersprachen alle \u201cgleichm\u00e4chtig\u201d, dh, jedes Programm l\u00e4sst sich prinzipiell in jeder der \u00fcblicherweise verwendeten Sprachen schreiben. Andererseits sind die Sprachen aber unterschiedlich gut f\u00fcr verschiedene Anwendungsbereiche geeignet. So werden imperative Sprachen wie C beispielsweise f\u00fcr schnelle maschinennahe Programmierung eingesetzt, da dort der Programmierer direkt die Verwaltung des Speichers \u00fcbernehmen kann (und muss). In anderen Programmiersprachen wird diese Aufgabe automatisch (vom Compiler) durchgef\u00fchrt. Dies erlaubt eine schnellere Programmentwicklung, die weniger fehleranf\u00e4llig ist. Andererseits sind die dabei entstehenden Programme", "num_citations": "2\n", "authors": ["290"]}
{"title": "Java program analysis by symbolic execution\n", "abstract": " Program analysis has a long history in computer science. Even when only considering the important aspect of termination analysis, in the past decades an overwhelming number of different techniques has been developed. While the programming languages considered by these approaches initially were more of theoretical importance than of practical use, recently also automated analyses for imperative programming languages like C or Java have been developed. Here, a major challenge is to deal with language constructs and concepts which do not exist in simpler languages. For example, in Java one often uses dynamic dispatch, complex object hierarchies, or side-effects with far-reaching consequences involving the global heap.In this thesis, we present a preprocessing step for Java Bytecode programs in which all such complicated language constructs are handled. This way, subsequent analyses do not need to be concerned with these, and making use of existing techniques is easy. In particular, we show how Symbolic Execution Graphs can be constructed which contain an over-approximation of all possible program runs. This way, and by taking care of having a precise approximation, the information contained in the constructed graphs can, for example, be used to reason about the termination behavior of the original program. Additionally to the construction of such graphs, in this thesis we present a new analysis technique which helps end users identify parts of the analyzed code which are irrelevant for the desired outcome. This way, programming errors causing code to be not executed can be identified and, consequently, fixed by the\u00a0\u2026", "num_citations": "1\n", "authors": ["290"]}
{"title": "Grundlagen der Funktionalen Programmierung\n", "abstract": " Generell unterscheiden wir grunds\u00e4tzlich zwischen imperativen und deklarativen Programmiersprachen (wobei sich deklarative Sprachen weiter in funktionale und logische Sprachen unterteilen). In imperativen Sprachen setzen sich die Programme aus einer Folge von nacheinander ausgef\u00fchrten Anweisungen zusammen, die die Werte der Variablen im Speicher ver\u00e4ndern. Die meisten der heute verwendeten Programmiersprachen beruhen auf diesem Prinzip, das auch einen direkten Zusammenhang zu der klassischen Rechnerarchitektur besitzt, die auf John von Neumann zur\u00fcckgeht. In der deklarativen Programmierung bestehen die Programme hingegen aus einer Spezifikation dessen, was berechnet werden soll. Die Festlegung, wie die Berechnung genau verlaufen soll, wird dem Interpreter bzw. dem Compiler \u00fcberlassen. Deklarative Programmiersprachen sind daher problemorientiert statt maschinenorientiert. Einerseits sind die verschiedenen Programmiersprachen alle \u201cgleichm\u00e4chtig\u201d, dh, jedes Programm l\u00e4sst sich prinzipiell in jeder der \u00fcblicherweise verwendeten Sprachen schreiben. Andererseits sind die Sprachen aber unterschiedlich gut f\u00fcr verschiedene Anwendungsbereiche geeignet. So werden imperative Sprachen wie C beispielsweise f\u00fcr schnelle maschinennahe Programmierung eingesetzt, da dort der Programmierer direkt die Verwaltung des Speichers \u00fcbernehmen kann (und muss). In anderen Programmiersprachen wird diese Aufgabe automatisch (vom Compiler) durchgef\u00fchrt. Dies erlaubt eine schnellere Programmentwicklung, die weniger fehleranf\u00e4llig ist. Andererseits sind die dabei entstehenden Programme", "num_citations": "1\n", "authors": ["290"]}
{"title": "Genetic Algorithms for Finding Polynomial Orderings\n", "abstract": " Polynomial orderings are a well-known method to prove termination of term rewriting systems. However, for an automation of this method, the crucial point is to find suitable coefficients by machine. We present a novel approach for solving this problem by applying genetic algorithms.", "num_citations": "1\n", "authors": ["290"]}