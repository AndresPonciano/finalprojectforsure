{"title": "Factors influencing code review processes in industry\n", "abstract": " Code review is known to be an efficient quality assurance technique. Many software companies today use it, usually with a process similar to the patch review process in open source software development. However, there is still a large fraction of companies performing almost no code reviews at all. And the companies that do code reviews have a lot of variation in the details of their processes. For researchers trying to improve the use of code reviews in industry, it is important to know the reasons for these process variations. We have performed a grounded theory study to clarify process variations and their rationales. The study is based on interviews with software development professionals from 19 companies. These interviews provided insights into the reasons and influencing factors behind the adoption or non-adoption of code reviews as a whole as well as for different process variations. We have condensed\u00a0\u2026", "num_citations": "51\n", "authors": ["969"]}
{"title": "A faceted classification scheme for change-based industrial code review processes\n", "abstract": " Code review in the industry today is different to code review twenty years ago. The process has become more lightweight, reviews are performed frequently and change-based and the use of specialized tools is increasing. An accurate view of the current state of the industrial practice is an indispensable foundation for improving it. Most recent descriptions of review practices come from a limited population of large hightech companies. Therefore, we used interviews with software engineering professionals from a broad sample of 19 companies to gain insight into their code review practices. We augmented our findings with data for 11 companies found through a semisystematic literature review. There are many commonalities in the code review processes of these companies, but also a lot of variation in the details. A simple process taxonomy cannot describe these variations adequately. Therefore, we present a\u00a0\u2026", "num_citations": "41\n", "authors": ["969"]}
{"title": "The choice of code review process: A survey on the state of the practice\n", "abstract": " Code review has been known to be an effective quality assurance technique for decades. In the last years, industrial code review practices were observed to converge towards \u201cchange-based/modern code review\u201d, but with a lot of variation in the details of the processes. Recent research also proposed hypotheses on factors that influence the choice of process. However, all current research in this area is based on small and largely non-random samples of cases. Therefore, we set out to assess the current state of the practice and to test some of these hypotheses with a survey among commercial software development teams. We received responses from 240 teams. They support many of the stated hypotheses, e.g., that change-based code review is the dominating style of code review in the industry, and that teams doing change-based code review have a lower risk that review use fades away. However\u00a0\u2026", "num_citations": "19\n", "authors": ["969"]}
{"title": "Comparing pre\u2010commit reviews and post\u2010commit reviews using process simulation\n", "abstract": " Code review in practice is often performed change\u2010based, ie, using the code changes belonging to a task to determine which code to review. Previous studies found that 2 variations of this process are used in industry: pre\u2010commit review and post\u2010commit review. The choice between these has implications not only for practitioners deciding on a code review process to use but also for the development of review tools and for experimentation with review processes. In some situations, a specific variant is clearly preferable due to the nature of the development process or team. In other situations, there are conflicting opinions. So we asked: Are there practically relevant performance differences between pre and post\u2010commit reviews? How are these differences influenced by contextual factors? To assess these questions, we designed a parametric discrete event simulation model of certain agile development processes\u00a0\u2026", "num_citations": "19\n", "authors": ["969"]}
{"title": "On the need for a new generation of code review tools\n", "abstract": " Tool support for change-based code review is gaining widespread acceptance in the industry. This indicates that the current generation of tools is well-aligned to current code review practices. Nevertheless, we believe that further improvements in code review tooling can lead to increased review efficiency and effectiveness. In this paper, we combine results from a qualitative study and results from the literature to substantiate this claim. We derive promising improvement areas and provide an overview of existing research in these areas. A common attribute of these improvements is that they trade flexibility for reviewer support. As flexibility is one of the main characteristics of the current generation of code review tools in Hedberg\u2019s classification of review tool generations, we regard these coming tools as part of a new generation of code review tools.", "num_citations": "17\n", "authors": ["969"]}
{"title": "An industrial case study on shrinking code review changesets through remark prediction\n", "abstract": " Change-based code review is used widely in industrial software development. Thus, research on tools that help the reviewer to achieve better review performance can have a high impact. We analyze one possibility to provide cognitive support for the reviewer: Determining the importance of change parts for review, specifically determining which parts of the code change can be left out from the review without harm. To determine the importance of change parts, we extract data from software repositories and build prediction models for review remarks based on this data. The approach is discussed in detail. To gather the input data, we propose a novel algorithm to trace review remarks to their triggers. We apply our approach in a medium-sized software company. In this company, we can avoid the review of 25% of the change parts and of 23% of the changed Java source code lines, while missing only about 1% of the review remarks. Still, we also observe severe limitations of the tried approach: Much of the savings are due to simple syntactic rules, noise in the data hampers the search for better prediction models, and some developers in the case company oppose the taken approach. Besides the main results on the mining and prediction of triggers for review remarks, we contribute experiences with a novel, multi-objective and interactive rule mining approach. The anonymized dataset from the company is made available, as are the implementations for the devised algorithms.", "num_citations": "4\n", "authors": ["969"]}
{"title": "Leveraging pre-commit hooks for context-sensitive checklists: a case study\n", "abstract": " The need to increase the efficiency of software development creates a demand for unobtrusive in-process means of software quality assurance that align well with agile processes. Many version control system clients provide facilities for running scripts or other executables before a change is committed to the repository. These \u201dpre-commit hooks\u201d can be client-side or server-side, both having distinct advantages. Client-side pre-commit hooks are well suited to implement context-sensitive checklists and automatic quality checks, but their potential has not been fully realized in practice and corresponding research is missing. To narrow this gap, we did an industrial case study on this use of client-side pre-commit hooks. The case study used the tool \u201dTortoiseChecklist\u201d and was focused on increasing continuous integration build stability. The results were positive, with a notable increase in stability and no significant disadvantages noticed.", "num_citations": "3\n", "authors": ["969"]}
{"title": "A multi-objective anytime rule mining system to ease iterative feedback from domain experts\n", "abstract": " Data extracted from software repositories is used intensively in Software Engineering research, for example, to predict defects in source code. In our research in this area, with data from open source projects as well as an industrial partner, we noticed several shortcomings of conventional data mining approaches for classification problems: (1) Domain experts' acceptance is of critical importance, and domain experts can provide valuable input, but it is hard to use this feedback. (2) The evaluation of the model is not a simple matter of calculating AUC or accuracy. Instead, there are multiple objectives of varying importance, but their importance cannot be easily quantified. Furthermore, the performance of the model cannot be evaluated on a per-instance level in our case, because it shares aspects with the set cover problem. To overcome these problems, we take a holistic approach and develop a rule mining system that simplifies iterative feedback from domain experts and can easily incorporate the domain-specific evaluation needs. A central part of the system is a novel multi-objective anytime rule mining algorithm. The algorithm is based on the GRASP-PR meta-heuristic but extends it with ideas from several other approaches. We successfully applied the system in the industrial context. In the current article, we focus on the description of the algorithm and the concepts of the system. We provide an implementation of the system for reuse.", "num_citations": "2\n", "authors": ["969"]}
{"title": "Cognitive-support code review tools: improved efficiency of change-based code review by guiding and assisting reviewers\n", "abstract": " Code reviews, i.e., systematic manual checks of program source code by other developers, have been an integral part of the quality assurance canon in software engineering since their formalization by Michael Fagan in the 1970s. Computer-aided tools supporting the review process have been known for decades and are now widely used in software development practice. Despite this long history and widespread use, current tools hardly go beyond simple automation of routine tasks. The core objective of this thesis is to systematically develop options for improved tool support for code reviews and to evaluate them in the interplay of research and practice.  The starting point of the considerations is a comprehensive analysis of the state of research and practice. Interview and survey data collected in this thesis show that review processes in practice are now largely change-based, i.e., based on checking the changes resulting from the iterative-incremental evolution of software. This is true not only for open source projects and large technology companies, as shown in previous research, but across the industry. Despite the common change-based core process, there are various differences in the details of the review processes. The thesis shows possible factors influencing these differences. Important factors seem to be the process variants supported and promoted by the used review tool. In contrast, the used tool has little influence on the fundamental decision to use regular code reviews. Instead, the interviews and survey data suggest that the decision to use code reviews depends more on cultural factors.  Overall, the analysis of the state of\u00a0\u2026", "num_citations": "1\n", "authors": ["969"]}
{"title": "Integrating GUI Mockups and User Stories.\n", "abstract": " An important goal in requirements engineering is to enable good requirements communication among all project participants. Especially in projects with a variety of stakeholders, it is important to repeatedly collect and discuss their different views and requirements throughout the whole project. However, most of the stakeholders have other main tasks and only little time to spend on requirements analysis and documentation. Therefore, it is important to enable quick and efficient ways to gain viable requirements artifacts. Especially in iterative or agile approaches, stakeholders are in demand to actively contribute to requirements analysis and documentation. Two frequent types of artifacts used in such situations are user stories and GUI mockups. GUI mockups have proven to be particularly supportive for discussions about requirements details. Stakeholders with little experience in requirements engineering find GUI mockups tangible and with their help can express their requirements more easily [1]. In order to eventually convert the acquired information into story cards, additional effort and a switch of context are necessary. Often, one needs to switch back and forth between different views, which slows down the whole activity. Alternatively, verbal comments are written down as notes, which puts them at the risk of being implemented directly and never documented in a requirements artifact [1].", "num_citations": "1\n", "authors": ["969"]}