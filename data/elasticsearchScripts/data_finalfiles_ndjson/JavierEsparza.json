{"title": "An improvement of McMillan's unfolding algorithm\n", "abstract": " McMillan has recently proposed a new technique to avoid the state explosion problem in the verification of systems modelled with finite-state Petri nets. The technique requires to construct a finite initial part of the unfolding of the net. McMillan's algorithm for this task may yield initial parts that are larger than necessary (exponentially larger in the worst case). We present a refinement of the algorithm which overcomes this problem.", "num_citations": "691\n", "authors": ["1874"]}
{"title": "Decidability issues for Petri nets\n", "abstract": " This is a survey of some decidability results for Petri nets, covering the last three decades. The presentation is structured around decidability of specific properties, various behavioural equivalences and finally the model checking problem for temporal logics.", "num_citations": "539\n", "authors": ["1874"]}
{"title": "Efficient algorithms for model checking pushdown systems\n", "abstract": " We study model checking problems for pushdown systems and linear time logics. We show that the global model checking problem (computing the set of configurations, reachable or not, that violate the formula) can be solved in  time and  space, where  and  are the size of the pushdown system and the size of a B\u00fcchi automaton for the negation of the formula. The global model checking problem for reachable configurations can be solved in  time and  space. In the case of pushdown systems with constant number of control states (relevant for our application), the complexity becomes  time and  space and  time and  space, respectively. We show applications of these results in the area of program analysis and present some experimental results.", "num_citations": "453\n", "authors": ["1874"]}
{"title": "Decidability and complexity of Petri net problems\u2014an introduction\n", "abstract": " A collection of 10 \u201crules of thumb\u201d is presented that helps to determine the decidability and complexity of a large number of Petri net problems.", "num_citations": "434\n", "authors": ["1874"]}
{"title": "Model checking using net unfoldings\n", "abstract": " McMillan (1992) described a technique for deadlock detection based on net unfoldings. We extend its applicability to the properties of a temporal logic with a possibility operator. The new algorithm is shown to be polynomial in the size of the net for 1-safe conflict-free Petri nets, while the algorithms of the literature require exponential time.", "num_citations": "331\n", "authors": ["1874"]}
{"title": "Unfoldings: a partial-order approach to model checking\n", "abstract": " Model checking is a prominent technique used in the hardware and software industries for automatic verification. While it is very successful in finding subtle bugs in distributed systems, it faces the state explosion problem-the number of reachable states grows exponentially in the number of concurrent components. In this book the authors introduce unfoldings, an approach to model checking which alleviates the state explosion problem by means of concurrency theory. They offer a gentle introduction to the basics of the method, and in particular they detail an unfolding-based algorithm for model checking concurrent systems against properties specified as formulas of linear temporal logic (LTL). Self-contained chapters cover transition systems and their products; unfolding products; search procedures for basic verification problems, such as reachability and livelocks; and model checking LTL. The final chapter summarizes the results of the book, and points the reader to tools and case studies. The book will be of value to researchers and graduate students engaged in automatic verification and concurrency theory.", "num_citations": "276\n", "authors": ["1874"]}
{"title": "Complexity results for 1-safe nets\n", "abstract": " We study the complexity of several standard problems for 1-safe Petri nets and some of its subclasses. We prove that reachability, liveness, and deadlock are all PSPACE-complete for 1-safe nets. We also prove that deadlock is NP-complete for free-choice nets and for 1-safe free-choice nets. Finally, we prove that for arbitrary Petri nets, deadlock is equivalent to reachability and liveness.", "num_citations": "255\n", "authors": ["1874"]}
{"title": "Petri nets, commutative context-free grammars, and basic parallel processes\n", "abstract": " The paper provides a structural characterisation of the reachable markings of Petri nets in which every transition has exactly one input place. As a corollary, the reachability problem for this class is proved to be NP-complete. Further consequences are: the uniform word problem for commutative context-free grammars is NP-complete; weak-bisimilarity is semidecidable for Basic Parallel Processes.", "num_citations": "216\n", "authors": ["1874"]}
{"title": "Model checking LTL with regular valuations for pushdown systems\n", "abstract": " Recent works have proposed pushdown systems as a tool for analyzing programs with (recursive) procedures, and the model-checking problem for LTL has received special attention. However, all these works impose a strong restriction on the possible valuations of atomic propositions: whether a configuration of the pushdown system satisfies an atomic proposition or not can only depend on the current control state of the pushdown automaton and on its topmost stack symbol. In this paper we consider LTL with regular valuations: the set of configurations satisfying an atomic proposition can be an arbitrary regular language. The model-checking problem is solved via two different techniques, with an eye on efficiency. The resulting algorithms are polynomial in certain measures of the problem which are usually small, but can be exponential in the size of the problem instance. However, we show that this exponential\u00a0\u2026", "num_citations": "214\n", "authors": ["1874"]}
{"title": "Decidability of model checking for infinite-state concurrent systems\n", "abstract": " We study the decidability of the model checking problem for linear and branching time logics, and two models of concurrent computation, namely Petri nets and Basic Parallel Processes.", "num_citations": "213\n", "authors": ["1874"]}
{"title": "A BDD-based model checker for recursive programs\n", "abstract": " We present a model-checker for boolean programs with (possibly recursive) procedures and the temporal logic LTL. The checker is guaranteed to terminate even for (usually faulty) programs in which the depth of the recursion is not bounded. The algorithm uses automata to finitely represent possibly infinite sets of stack contents and BDDs to compactly represent finite sets of values of boolean variables. We illustrate the checker on some examples and compare it with the Bebop tool of Ball and Rajamani.", "num_citations": "198\n", "authors": ["1874"]}
{"title": "Model checking probabilistic pushdown automata\n", "abstract": " We consider the model checking problem for probabilistic pushdown automata (pPDA) and properties expressible in various probabilistic logics. We start with properties that can be formulated as instances of a generalized random walk problem. We prove that both qualitative and quantitative model checking for this class of properties and pPDA is decidable. Then we show that model checking for the qualitative fragment of the logic PCTL and pPDA is also decidable. Moreover, we develop an error-tolerant model checking algorithm for PCTL and the subclass of stateless pPDA. Finally, we consider the class of omega-regular properties and show that both qualitative and quantitative model checking for pPDA is decidable.", "num_citations": "181\n", "authors": ["1874"]}
{"title": "A note on on-the-fly verification algorithms\n", "abstract": " The automata-theoretic approach to LTL verification relies on an algorithm for finding accepting cycles in a B\u00fcchi automaton. Explicit-state model checkers typically construct the automaton \u201con the fly\u201d and explore its states using depth-first search. We survey algorithms proposed for this purpose and identify two good algorithms, a new algorithm based on nested DFS, and another based on strongly connected components. We compare these algorithms both theoretically and experimentally and determine cases where both algorithms can be useful.", "num_citations": "164\n", "authors": ["1874"]}
{"title": "On the decidability of model checking for several \u03bc-calculi and Petri nets\n", "abstract": " The decidability of the model checking problem for several \u03bc-calculi and Petri nets is analysed. The linear time \u03bc-calculus without atomic sentences is decidable; if simple atomic sentences are added, it becomes undecidable. A very simple subset of the modal \u03bc-calculus is undecidable.", "num_citations": "141\n", "authors": ["1874"]}
{"title": "Circuits, handles, bridges and nets\n", "abstract": " This paper introduces two new structural objects for the study of nets: handles and bridges. They are shown to provide sufficient, although not necessary, conditions of good behaviour for general ordinary nets, as well as a new characterisation of structural liveness and structural boundedness for the subclass of Free Choice nets. This characterisation is used to approach a modular synthesis theory of Free Choice nets through the synchronisation of State Machines. The task is fully performed for the restricted subclass of Strict Free Choice nets introduced here.", "num_citations": "126\n", "authors": ["1874"]}
{"title": "Verification of safety properties using integer programming: Beyond the state equation\n", "abstract": " The state equation is a verification technique that has been applied\u2014not always under this name\u2014to numerous systems modelled as Petri nets or communicating automata. Given a safety property P, the state equation is used to derive a necessary condition for P to hold which can be mechanically checked. The necessary conditions derived from the state equation are known to be of little use for systems communicating by means of shared variables, in the sense that many of these systems satisfy the property but not the conditions. In this paper, we use traps, a well-known notion of net theory, to obtain stronger conditions that can still be efficiently checked. We show that the new conditions significantly extend the range of verifiable systems.", "num_citations": "119\n", "authors": ["1874"]}
{"title": "An automata-theoretic approach to interprocedural data-flow analysis\n", "abstract": " We show that recent progress in extending the automatatheoretic approach to model-checking beyond the class of finite-state processes finds a natural application in the area of interprocedural data- flow analysis.", "num_citations": "116\n", "authors": ["1874"]}
{"title": "A polynomial-time algorithm to decide liveness of bounded free choice nets\n", "abstract": " Lautenbach (1987) described an interesting method for the linear algebraic calculation of deadlocks and traps. The method is here proved anew and its power clarified. This allows us to propose a polynomial time algorithm to decide liveness for bounded free choice nets, thus proving an enlarged version of a conjecture raised by Jones (1977)", "num_citations": "113\n", "authors": ["1874"]}
{"title": "An unfolding algorithm for synchronous products of transition systems\n", "abstract": " The unfolding method, initially introduced for systems modelled by Petri nets, is applied to synchronous products of transition systems, a model introduced by Arnold [2]. An unfolding procedure is provided which exploits the product structure of the model. Its performance is evaluated on a set of benchmarks.", "num_citations": "104\n", "authors": ["1874"]}
{"title": "On the analysis and synthesis of free choice systems\n", "abstract": " This invited paper present in a semi-formal illustrative way several new results concerning the analysis and synthesis of free choice systems. It is a complementary work of the survey by E. Best [Best 87]. In the analysis part, we characterize liveness and boundedness in linear algebraic terms. As a consequence of the new characterizations, both properties are shown to be decidable (as a whole) in polynomial time. We also provide two different kits of sound and complete reduction rules (the one reverse-dual of the other).             We address then the problem of synthezising live and bounded free choice systems within the two basic design methodologies: top-down and modular (synthesis by composition of modules). Two complete kits of top-down synthesis rules are provided. They are essentially the reduction kits obtained before, but this time considered in the reverse direction. The completeness of the kits\u00a0\u2026", "num_citations": "97\n", "authors": ["1874"]}
{"title": "More Infinite Results.\n", "abstract": " Since the early nineties there has been a spurt of activity in concurrency theory centered on the analysis of in\ufb01nite-state systems. The following two problems have been intensely investigated:(1) given two in\ufb01nite-state systems, are they equal with respect to a certain equivalence notion?, and (2) given an in\ufb01nite-state system and a property expressed in a certain temporal logic, does the system satisfy the property? In his paper \u201cIn\ufb01nite Results\u201d[1], Moller surveys some of the key results on the decidability and complexity of problem (1). This paper is a survey on the results about problem The original paper, published in EATCS Bulletin 62, covered results until 1996. In this version we also consider later developments.", "num_citations": "93\n", "authors": ["1874"]}
{"title": "General refinement and recursion operators for the Petri box calculus\n", "abstract": " New generalised definitions are given for the refinement and recursion operators in the calculus of Petri Boxes. It is shown that not only recursion, but also other operators such as sequence, choice and iteration can be viewed as based on refinement. Various structural properties of these operators can be deduced from a general property of (simultaneous) refinement. A partial order based denotational approach for recursion is presented, which yields a unique fixpoint even in unguarded cases. The construction is based on a judicious naming discipline for places and transitions and yields a closed form for the fixpoint.", "num_citations": "89\n", "authors": ["1874"]}
{"title": "Reduction and synthesis of live and bounded free choice Petri nets\n", "abstract": " This paper provides reduction rules that make it possible to reduce all and only live and bounded Free Choice Petri nets to a circuit containing one place and one transition. The reduction algorithm is shown to require polynomial time in the size of the system. The reduction rules can be transformed into synthesis rules, which can be used for the stepwise construction of large systems.", "num_citations": "85\n", "authors": ["1874"]}
{"title": "Reachability analysis of multithreaded software with asynchronous communication\n", "abstract": " We introduce asynchronous dynamic pushdown networks (ADPN), a new model for multithreaded programs in which pushdown systems communicate via shared memory. ADPN generalizes both CPS (concurrent pushdown systems)\u00a0[7] and DPN (dynamic pushdown networks)\u00a0[5]. We show that ADPN exhibit several advantages as a program model. Since the reachability problem for ADPN is undecidable even in the case without dynamic creation of processes, we address the bounded reachability problem\u00a0[7], which considers only those computation sequences where the (index of the) thread accessing the shared memory is changed at most a fixed given number of times. We provide efficient algorithms for both forward and backward reachability analysis. The algorithms are based on automata techniques for symbolic representation of sets of configurations.", "num_citations": "84\n", "authors": ["1874"]}
{"title": "Limit-deterministic B\u00fcchi automata for linear temporal logic\n", "abstract": " Limit-deterministic B\u00fcchi automata can replace deterministic Rabin automata in probabilistic model checking algorithms, and can be significantly smaller. We present a direct construction from an LTL formula  to a limit-deterministic B\u00fcchi automaton. The automaton is the combination of a non-deterministic component, guessing the set of eventually true -subformulas of , and a deterministic component verifying this guess and using this information to decide on acceptance. Contrary to the indirect approach of constructing a non-deterministic automaton for  and then applying a semi-determinisation algorithm, our translation is compositional and has a clear logical structure. Moreover, due to its special structure, the resulting automaton can be used not only for qualitative, but also for quantitative verification of MDPs, using the same model checking algorithm as for deterministic automata. This allows\u00a0\u2026", "num_citations": "76\n", "authors": ["1874"]}
{"title": "Abstraction refinement with Craig interpolation and symbolic pushdown systems\n", "abstract": " Counterexample-guided abstraction refinement (CEGAR) has proven to be a powerful method for software model-checking. In this paper, we investigate this concept in the context of sequential (possibly recursive) programs whose statements are given as BDDs. We examine how Craig interpolants can be computed efficiently in this case and propose a new, special type of interpolants. Moreover, we show how to treat multiple counterexamples in one refinement cycle. We have implemented this approach within the model-checker Moped and report on experiments.", "num_citations": "76\n", "authors": ["1874"]}
{"title": "Implementing LTL model checking with net unfoldings\n", "abstract": " We report on an implementation of the unfolding approach to model-checking LTL-X recently presented by the authors. Contrary to that work, we consider an state-based version of LTL-X, which is more used in practice. We improve on the checking algorithm; the new version allows to reuse code much more efficiently. We present results on a set of case studies.", "num_citations": "74\n", "authors": ["1874"]}
{"title": "From LTL to deterministic automata\n", "abstract": " We present a new algorithm to construct a (generalized) deterministic Rabin automaton for an LTL formula . The automaton is the product of a co-B\u00fcchi automaton for  and an array of Rabin automata, one for each -subformula of . The Rabin automaton for  is in charge of recognizing whether  holds. This information is passed to the co-B\u00fcchi automaton that decides on acceptance. As opposed to standard procedures based on Safra\u2019s determinization, the states of all our automata have a clear logical structure, which allows for various optimizations. Experimental results show improvement in the sizes of the resulting automata compared to existing methods.", "num_citations": "73\n", "authors": ["1874"]}
{"title": "Quantitative analysis of probabilistic pushdown automata: Expectations and variances\n", "abstract": " Probabilistic pushdown automata (pPDA) have been identified as a natural model for probabilistic programs with recursive procedure calls. Previous works considered the decidability and complexity of the model-checking problem for pPDA and various probabilistic temporal logics. In this paper we concentrate on computing the expected values and variances of various random variables defined over runs of a given probabilistic pushdown automaton. In particular, we show how to compute the expected accumulated reward and the expected gain for certain classes of reward functions. Using these results, we show how to analyze various quantitative properties of pPDA that are not expressible in conventional probabilistic temporal logics.", "num_citations": "72\n", "authors": ["1874"]}
{"title": "Unfolding based algorithms for the reachability problem\n", "abstract": " We study four solutions to the reachability problem for 1-safe Petri nets, all of them based on the unfolding technique. We define the problem as follows: given a set of places of the net, determine if some reachable marking puts a token in all of them. Three of the solutions to the problem are taken from the literature [McM92, Mel98, Hel99], while the fourth one is first introduced here. The new solution shows that the problem can be solved in time O (n^ k), where  is the size of the prefix of the unfolding containing all reachable states, and  is the number of places which should hold a token. We compare all four solutions on a set of examples, and extract a recommendation on which algorithms should be used and which ones not.", "num_citations": "70\n", "authors": ["1874"]}
{"title": "Computing the least fixed point of positive polynomial systems\n", "abstract": " We consider equation systems of the form , , , where  are polynomials with positive real coefficients. In vector form we denote such an equation system by  and call  a system of positive polynomials (SPP). Equation systems of this kind appear naturally in the analysis of stochastic models like stochastic context-free grammars (with numerous applications to natural language processing and computational biology), probabilistic programs with procedures, web-surfing models with back buttons, and branching processes. The least nonnegative solution  of an SPP equation  is of central interest for these models. Etessami and Yannakakis [J. ACM, 56 (2009), pp. 1\u201366] have suggested a particular version of Newton's method to approximate . We extend a result of Etessami and Yannakakis and show that Newton's method starting at  always converges to . We obtain lower bounds on the convergence speed of the method. For so-called\u00a0\u2026", "num_citations": "69\n", "authors": ["1874"]}
{"title": "Parikh\u02bcs theorem: A simple and direct automaton construction\n", "abstract": " Parikh\u02bcs theorem states that the Parikh image of a context-free language is semilinear or, equivalently, that every context-free language has the same Parikh image as some regular language. We present a very simple construction that, given a context-free grammar, produces a finite automaton recognizing such a regular language.", "num_citations": "67\n", "authors": ["1874"]}
{"title": "Pattern-based verification for multithreaded programs\n", "abstract": " Pattern-based verification checks the correctness of program executions that follow a given pattern, a regular expression over the alphabet of program transitions of the form w1* \u2026 wn*. For multithreaded programs, the alphabet of the pattern is given by the reads and writes to the shared storage. We study the complexity of pattern-based verification for multithreaded programs with shared counters and finite variables. While unrestricted verification is undecidable for abstracted multithreaded programs with recursive procedures and PSPACE-complete for abstracted multithreaded while-programs (even without counters), we show that pattern-based verification is NP-complete for both classes, even in the presence of counters. We then conduct a multiparameter analysis to study the complexity of the problem on its three natural parameters (number of threads+counters+variables, maximal size of a thread, size of the\u00a0\u2026", "num_citations": "66\n", "authors": ["1874"]}
{"title": "jMoped: A Java bytecode checker based on Moped\n", "abstract": " We present a tool for finding errors in Java programs that translates Java bytecodes into symbolic pushdown systems, which are then checked by the Moped tool [1].", "num_citations": "63\n", "authors": ["1874"]}
{"title": "Parameterized Verification of Crowds of Anonymous Processes.\n", "abstract": " We survey some results on the automatic verification of parameterized programs without identities. These are systems composed of arbitrarily many components, all of them running exactly the same finite-state program. We discuss the complexity of deciding that no component reaches an unsafe state. A former version of this paper was published in the Proceedings of STACS 2014 [8].", "num_citations": "62\n", "authors": ["1874"]}
{"title": "Newtonian program analysis\n", "abstract": " This article presents a novel generic technique for solving dataflow equations in interprocedural dataflow analysis. The technique is obtained by generalizing Newton's method for computing a zero of a differentiable function to \u03c9-continuous semirings. Complete semilattices, the common program analysis framework, are a special class of \u03c9-continuous semirings. We show that our generalized method always converges to the solution, and requires at most as many iterations as current methods based on Kleene's fixed-point theorem. We also show that, contrary to Kleene's method, Newton's method always terminates for arbitrary idempotent and commutative semirings. More precisely, in the latter setting the number of iterations required to solve a system of n equations is at most n.", "num_citations": "62\n", "authors": ["1874"]}
{"title": "Top-down synthesis of live and bounded free choice nets\n", "abstract": " The paper provides a set of rules for the stepwise synthesis of all and only live and bounded Free Choice nets. The starting point are nets composed by a circuit containing one place and one transition.", "num_citations": "62\n", "authors": ["1874"]}
{"title": "On the model checking problem for branching time logics and basic parallel processes\n", "abstract": " We investigate the model checking problem for branching time logics and Basic Parallel Processes. We show that the problem is undecidable for the logic \u2200L(O, F, U) (equivalent to CTL *) in the usual interleaving semantics, but decidable in a standard partial order interpretation.", "num_citations": "61\n", "authors": ["1874"]}
{"title": "Proving termination of probabilistic programs using patterns\n", "abstract": " Proving programs terminating is a fundamental computer science challenge. Recent research has produced powerful tools that can check a wide range of programs for termination. The analog for probabilistic programs, namely termination with probability one (\u201calmost-sure termination\u201d), is an equally important property for randomized algorithms and probabilistic protocols. We suggest a novel algorithm for proving almost-sure termination of probabilistic programs. Our algorithm exploits the power of state-of-the-art model checkers and termination provers for nonprobabilistic programs: it calls such tools within a refinement loop and thereby iteratively constructs a \u201cterminating pattern\u201d, which is a set of terminating runs with probability\u00a0one. We report on various case studies illustrating the effectiveness of our algorithm. As a further application, our algorithm can improve lower bounds on reachability probabilities.", "num_citations": "59\n", "authors": ["1874"]}
{"title": "Deciding Finiteness of Petri Nets up to Bisim ulation\n", "abstract": " We study the following problems for strong and weak bisimulation equivalence: given a labelled Petri net and a finite transition system, are they equivalent?; given a labelled Petri net, is it equivalent to some (unspecified) finite transition system? We show that both problems are decidable for strong bisimulation and undecidable for weak bisimulation.", "num_citations": "58\n", "authors": ["1874"]}
{"title": "Synthesis of distributed algorithms using asynchronous automata\n", "abstract": " We apply the theory of asynchronous automata to the synthesis problem of closed distributed systems. We use safe asynchronous automata as implementation model, and characterise the languages they accept. We analyze the complexity of the synthesis problem in our framework. Theorems by Zielonka and Morin are then used to develop and implement a synthesis algorithm. Finally, we apply the developed algorithms to the classic problem of mutual exclusion.", "num_citations": "57\n", "authors": ["1874"]}
{"title": "The model-checking kit\n", "abstract": " The Model-Checking Kit [8] is a collection of programs which allow to model finite state systems using a variety of modelling languages, and verify them using a variety of checkers, including deadlock-checkers, reachability-checkers, and model-checkers for the temporal logics CTL and LTL [7].", "num_citations": "54\n", "authors": ["1874"]}
{"title": "Deterministic automata for the (F, G)-fragment of LTL\n", "abstract": " When dealing with linear temporal logic properties in the setting of e.g. games or probabilistic systems, one often needs to express them as deterministic omega-automata. In order to translate LTL to deterministic omega-automata, the traditional approach first translates the formula to a non-deterministic B\u00fcchi automaton. Then a determinization procedure such as of Safra is performed yielding a deterministic \u03c9-automaton. We present a direct translation of the (F,G)-fragment of LTL into deterministic \u03c9-automata with no determinization procedure involved. Since our approach is tailored to LTL, we often avoid the typically unnecessarily large blowup caused by general determinization algorithms. We investigate the complexity of this translation and provide experimental results and compare them to the traditional method.", "num_citations": "52\n", "authors": ["1874"]}
{"title": "Symbolic context-bounded analysis of multithreaded Java programs\n", "abstract": " The reachability problem is undecidable for programs with both recursive procedures and multiple threads with shared memory. Approaches to this problem have been the focus of much recent research. One of these is to use context-bounded reachability, i.e. to consider only those runs in which the active thread changes at most k\u00a0times, where k is fixed. However, to the best of our knowledge, context-bounded reachability has not been implemented in any tool so far, primarily because its worst-case runtime is prohibitively high, i.e. O(n                                    k                 ), where n is the size of the shared memory. Moreover, existing algorithms for context-bounded reachability do not admit a meaningful symbolic implementation (e.g., using BDDs) to reduce the run-time in practice. In this paper, we propose an improvement that overcomes this problem. We have implemented our approach in the tool jMoped and\u00a0\u2026", "num_citations": "52\n", "authors": ["1874"]}
{"title": "A polynomial algorithm to compute the concurrency relation of free-choice signal transition graphs\n", "abstract": " The concurrency relation of a Petri net contains the pairs of transitions that can be concurrently enabled. We present a polynomial algorithm to compute the concurrency relation of free-choice Signal Transition Graphs, a class of Petri nets with applications to the verification and synthesis of speed-independent circuits.", "num_citations": "52\n", "authors": ["1874"]}
{"title": "A new unfolding approach to LTL model checking\n", "abstract": " A new unfolding approach to LTL model checking is presented, in which the model checking problem can be solved by direct inspection of a certain finite prefix. The techniques presented so far required to run an elaborate algorithm on the prefix.", "num_citations": "51\n", "authors": ["1874"]}
{"title": "Reachability in live and safe free-choice Petri nets is NP-complete\n", "abstract": " The complexity of the reachability problem for live and safe free-choice Petri nets has been open for several years. Several partial results seemed to indicate that the problem is polynomial. We show that this is unlikely: the problem is NP-complete.", "num_citations": "50\n", "authors": ["1874"]}
{"title": "Synthesis rules for Petri nets, and how they lead to new results\n", "abstract": " Three kits of rules for top-down synthesis of Petri nets are introduced. The properties and expressive power of the kits are compared. They are then used to characterise the class of structurally live Free Choice nets by means of the rank of the incidence matrix.", "num_citations": "49\n", "authors": ["1874"]}
{"title": "On fixed point equations over commutative semirings\n", "abstract": " Fixed point equations x = f(x) over \u03c9-continuous semirings can be seen as the mathematical foundation of interprocedural program analysis. The sequence 0, f(0),f                                    2                 (0),... converges to the least fixed point \u03bc                 f. The convergence can be accelerated if the underlying semiring is commutative. We show that accelerations in the literature, namely Newton\u2019s method for the arithmetic semiring [4] and an acceleration for commutative Kleene algebras due to Hopkins and Kozen [5], are instances of a general algorithm for arbitrary commutative \u03c9-continuous semirings. In a second contribution, we improve the  bound of [5] and show that their acceleration reaches \u03bc                 f after n iterations, where n is the number of equations. Finally, we apply the Hopkins-Kozen acceleration to itself and study the resulting hierarchy of increasingly fast accelerations.", "num_citations": "45\n", "authors": ["1874"]}
{"title": "Operational semantics for the Petri box calculus\n", "abstract": " The Petri Box Calculus (PBC), based on Milner's CCS, has been developed to provide a compositional semantics of high level programming constructs in terms of a class of Petri nets with interfaces, called Petri Boxes. In this paper we present a structural operational semantics for Box expressions which provide the syntax for the PBC. We show that the use of equations in addition to action rules leads to a uniform theory consisting essentially of a single action rule, a set of context rules, and a set of equations. To capture what is basically the standard Petri net transition rule, we introduce an overbarring and underbarring technique which is related to that used in the event systems due to Boudol and Castellani. We define step sequence rules and show their consistency and completeness with respect to the counterparts from net theory. The results hold also for expressions involving unguarded recursion.", "num_citations": "42\n", "authors": ["1874"]}
{"title": "Analysis and prediction of the long-run behavior of probabilistic sequential programs with recursion\n", "abstract": " We introduce a family of long-run average properties of Markov chains that are useful for purposes of performance and reliability analysis, and show that these properties can effectively be checked for a subclass of infinite-state Markov chains generated by probabilistic programs with recursive procedures. We also show how to predict these properties by analyzing finite prefixes of runs, and present an efficient prediction algorithm for the mentioned subclass of Markov chains.", "num_citations": "39\n", "authors": ["1874"]}
{"title": "Analyzing probabilistic pushdown automata\n", "abstract": " The paper gives a summary of the existing results about algorithmic analysis of probabilistic pushdown automata and their subclasses.", "num_citations": "37\n", "authors": ["1874"]}
{"title": "Model checking LTL using constraint programming\n", "abstract": " The model-checking problem for 1-safe Petri nets and linear-time temporal logic (LTL) consists of deciding, given a 1-safe Petri net and a formula of LTL, whether the Petri net satisfies the property encoded by the formula. This paper introduces a semidecision test for this problem. By a semidecision test we understand a procedure which may answer \u2018yes\u2019, in which case the Petri net satisfies the property, or \u2018don't know\u2019. The test is based on a variant of the so called automata-theoretic approach to model-checking and on the notion of T-invariant. We analyse the computational complexity of the test, implement it using 21p-a constraint programming tool, and apply it to two case studies.             This paper is a (very) abbreviated version of [6].", "num_citations": "37\n", "authors": ["1874"]}
{"title": "Learning workflow petri nets\n", "abstract": " Workflow mining is the task of automatically producing a workflow model from a set of event logs recording sequences of workflow events; each sequence corresponds to a use case or workflow instance. Formal approaches to workflow mining assume that the event log is complete (contains enough information to infer the workflow) which is often not the case. We present a learning approach that relaxes this assumption: if the event log is incomplete, our learning algorithm automatically derives queries about the executability of some event sequences. If a teacher answers these queries, the algorithm is guaranteed to terminate with a correct model. We provide matching upper and lower bounds on the number of queries required by the algorithm, and report on the application of an implementation to some examples.", "num_citations": "35\n", "authors": ["1874"]}
{"title": "Newton\u2019s Method for \u03c9-Continuous Semirings\n", "abstract": " Fixed point equations  over \u03c9-continuous semirings are a natural mathematical foundation of interprocedural program analysis. Generic algorithms for solving these equations are based on Kleene\u2019s theorem, which states that the sequence  converges to the least fixed point. However, this approach is often inefficient. We report on recent work in which we extend Newton\u2019s method, the well-known technique from numerical mathematics, to arbitrary \u03c9-continuous semirings, and analyze its convergence speed in the real semiring.", "num_citations": "35\n", "authors": ["1874"]}
{"title": "Petri nets and regular processes\n", "abstract": " We consider the following problems: (a) Given a labelled Petri net and a finite automaton, are they equivalent?; (b) Given a labelled Petri net, is it equivalent to some (unspecified) finite automaton? These questions are studied within the framework of trace and bisimulation equivalences, in both their strong and weak versions. (In the weak version a special \u03c4 action\u2014likened to an \u03b5-move in automata theory\u2014is considered to be nonobservable.) We demonstrate that (a) is decidable for strong and weak trace equivalence and for strong bisimulation equivalence, but undecidable for weak bisimulation equivalence. On the other hand, we show that (b) is decidable for strong bisimulation equivalence, and undecidable for strong and weak trace equivalence, as well as for weak bisimulation equivalence.", "num_citations": "35\n", "authors": ["1874"]}
{"title": "Traps characterize home states in free choice systems\n", "abstract": " Free choice nets are a subclass of Petri nets allowing to model concurrency and nondeterministic choice, but with the restriction that choices cannot be influenced externally. Home states are ground markings which can be reached from any other reachable marking of a system. A trap is a structurally defined part of a net with the property that once it is marked (that is, carries at least one token), it will remain remarked in any successor marking.The main result of this paper characterizes the home states of a live and bounded free choice system by the property that all traps are marked. This characterization leads to a polynomial-time algorithm for deciding the home state property. Other consequences include the proof that executing all parts of a net at least once necessarily leads to a home state; this has been a long standing conjecture.", "num_citations": "35\n", "authors": ["1874"]}
{"title": "Verifying single and multi-mutator garbage collectors with owicki-gries in isabelle/hol\n", "abstract": " Using a formalization of the Owicki-Gries method in the theorem prover Isabelle/HOL, we obtain mechanized correctness proofs for two incremental garbage collection algorithms, the second one parametric in the number of mutators. The Owicki-Gries method allows to reason directly on the program code; it also splits the proof into many small goals, most of which are very simple, and can thus be proved automatically. Thanks to Isabelle\u2019s facilities in dealing with syntax, the formalization can be done in a natural way.", "num_citations": "32\n", "authors": ["1874"]}
{"title": "From LTL and limit-deterministic B\u00fcchi automata to deterministic parity automata\n", "abstract": " Controller synthesis for general linear temporal logic (LTL) objectives is a challenging task. The standard approach involves translating the LTL objective into a deterministic parity automaton (DPA) by means of the Safra-Piterman construction. One of the challenges is the size of the DPA, which often grows very fast in practice, and can reach double exponential size in the length of the LTL formula. In this paper we describe a single exponential translation from limit-deterministic B\u00fcchi automata (LDBA) to DPA, and show that it can be concatenated with a recent efficient translation from LTL to LDBA to yield a double exponential, \u201cSafraless\u201d LTL-to-DPA construction. We also report on an implementation, a comparison with the SPOT library, and performance on several sets of formulas, including instances from the 2016 SyntComp competition.", "num_citations": "31\n", "authors": ["1874"]}
{"title": "Grammars as processes\n", "abstract": " In 1999 I met Grzegorz Rozenberg in Amsterdam, while I was attending the ETAPS conference and he was taking part in a meeting. The next day I was giving a talk with the title \u201cGrammars as Processes\u201d, and Grzegorz, who had seen it announced in the program, asked me about it. We had little time, and so I could barely sketch the contents. I think Grzegorz would have liked the talk, because it pointed out an interesting connection between two ofhis oldest loves, formal languages and concurrency theory, and showed how a model of computation derived from this connection has a natural application in the area of program analysis. He would have also liked to see how an abstract result obtained by B\u00fcchi in 1964 on regular canonical systems was the basis to new algorithms for the analysis of software. This paper is a written version oft he talk, and it also surveys the new results obtained since 1999. Sections\u00a0\u2026", "num_citations": "31\n", "authors": ["1874"]}
{"title": "Reduction rules for colored workflow nets\n", "abstract": " We study Colored Workflow nets [8], a model based on Workflow nets [14] enriched with data. Based on earlier work by Esparza and Desel on the negotiation model of concurrency [3, 4], we present reduction rules for our model. Contrary to previous work, our rules preserve not only soundness, but also the data flow semantics. For free choice nets, the rules reduce all sound nets (and only them) to a net with one single transition and the same data flow semantics. We give an explicit algorithm that requires only a polynomial number of rule applications.", "num_citations": "29\n", "authors": ["1874"]}
{"title": "Rewriting models of boolean programs\n", "abstract": " We show that rewrite systems can be used to give semantics to imperative programs with boolean variables, a class of programs used in software model-checking as over- or underapproximations of real programs. We study the classes of rewrite systems induced by programs with different features like procedures, concurrency, or dynamic thread creation, and survey a number of results on their word problem and their symbolic reachability problem.", "num_citations": "29\n", "authors": ["1874"]}
{"title": "Verifying red-black trees\n", "abstract": " We show how to verify the correctness of insertion of elements into red-black trees\u2014a form of balanced search trees\u2014using analysis techniques developed for graph rewriting. We first model red-black trees and operations on them using hypergraph rewriting. Then we use the tool Augur, which computes approximated unfoldings, in order to show that insertion preserves the property that there are no two consecutive red nodes in a tree, a requirement for red-black trees. Furthermore, we prove that the tree remains balanced by exploiting a type system that can be obtained as an instance of a general framework.", "num_citations": "29\n", "authors": ["1874"]}
{"title": "Efficient algorithms for alternating pushdown systems with an application to the computation of certificate chains\n", "abstract": " Motivated by recent applications of pushdown systems to computer security problems, we present an efficient algorithm for the reachability problem of alternating pushdown systems. Although the algorithm is exponential, a careful analysis reveals that the exponent is usually small in typical applications. We show that the algorithm can be used to compute winning regions in pushdown games. In a second contribution, we observe that the algorithm runs in polynomial time for a certain subproblem, and show that the computation of certificate chains with threshold certificates in the SPKI/SDSI authorization framework can be reduced to this subproblem. We present a detailed complexity analysis of the algorithm and its application, and report on experimental results obtained with a prototype implementation.", "num_citations": "28\n", "authors": ["1874"]}
{"title": "Model checking of persistent Petri nets\n", "abstract": " In this paper we develop a model checking algorithm which is fast in the size of the system. The class of system models we consider are safe persistent Petri nets; the logic is S 4, i.e. prepositional logic with a \u2018some time\u2019 operator. Our algorithm does not require to construct any transition system: We reduce the model checking problem to the problem of computing certain Parikh vectors, and we show that for the class of safe marked graphs these vectors can be computed \u2014 from the structure of the Petri net \u2014 in polynomial time in the size of the system.", "num_citations": "28\n", "authors": ["1874"]}
{"title": "Net reductions for LTL model-checking\n", "abstract": " We present a set of reduction rules for LTL model-checking of 1-safe Petri nets. Our reduction techniques are of two kinds: (1) Linear programming techniques which are based on well-known Petri net techniques like invariants and implicit places, and (2) local net reductions. We show that the conditions for the application of some local net reductions can be weakened if one is interested in LTL model-checking using the approach of [EH00,EH01]. Finally, we present a number of experimental results and show that the model-checking time of a net system can be significantly decreased if it has been preprocessed with our reduction techniques.", "num_citations": "25\n", "authors": ["1874"]}
{"title": "A uniform framework for problems on context-free grammars\n", "abstract": " In [2], Bouajjani and others presented an automata-based approach to a number of elementary problems on context-free grammars. This approach is of pedagogical interest since it provides a uniform solution to decision procedures usually solved by independent algorithms in textbooks, eg [7]. This paper improves upon [2] in a number of ways. We present a new algorithm which not only has a better space complexity but is also (in our opinion) easier to read and understand. Moreover, a closer inspection reveals that the new algorithm is competitive to well-known solutions for most (but not all) standard problems.", "num_citations": "25\n", "authors": ["1874"]}
{"title": "On negotiation as concurrency primitive\n", "abstract": " We introduce negotiations, a model of concurrency close to Petri nets, with multiparty negotiation as primitive. We study the problems of soundness of negotiations and of, given a negotiation with possibly many steps, computing a summary, i.e., an equivalent one-step negotiation. We provide a complete set of reduction rules for sound, acyclic, weakly deterministic negotiations and show that, for deterministic negotiations, the rules compute the summary in polynomial time.", "num_citations": "24\n", "authors": ["1874"]}
{"title": "Compositional synthesis of live and bounded free choice Petri nets\n", "abstract": " The paper defines two notions of composition of concurrent modules modelled by means of Petri nets: synchronisations and fusions. We study these two notions for the class of Free Choice nets, and characterise the compositions (within this class) that preserve liveness (absence of partial or global deadlocks) and boundedness (absence of overflows in finite stores). The characterisation shows which structures must be avoided in order to preserve the properties.", "num_citations": "24\n", "authors": ["1874"]}
{"title": "Minimal deadlocks in free choice nets\n", "abstract": " Deadlocks and traps 4] are very useful structures for the analysis of Petri nets, in particular the so-called minimal ones. In| 1| K. Barkaoui and B. Lemaire give a nice characterisation of minimal deadlocks in terms of graph theoretical properties, using the notion of alternating circuit. The purpose of this note is to show that this characterisation reduces to a simpler one for the particular case of free choice nets; then this simplified characterisation is used to obtain two results: the first is an algorithm that constructs minimal deadlocks in (strongly connected) free choice nets; the second is the existence of a close relationship between minimal and strongly connected deadlocks in the same subclass. This last result has an important consequence: minimal deadlocks in free choice nets enjoy some properties if and only if the strongly connected deadlocks enjoy them (one of these properties, as will be shown at the end of the\u00a0\u2026", "num_citations": "24\n", "authors": ["1874"]}
{"title": "Rabinizer: Small Deterministic Automata for LTL(F,G)\n", "abstract": " We present Rabinizer, a tool for translating formulae of the fragment of linear temporal logic with the operators F (eventually) and G (globally) into deterministic Rabin automata. Contrary to tools like ltl2dstar, which translate the formula into a B\u00fcchi automaton and apply Safra\u2019s determinization procedure, Rabinizer uses a direct construction based on the logical structure of the formulae. We describe a number of optimizations of the basic procedure, crucial for the good performance of Rabinizer, and present an experimental comparison.", "num_citations": "23\n", "authors": ["1874"]}
{"title": "Computing least fixed points of probabilistic systems of polynomials\n", "abstract": " We study systems of equations of the form X1 = f1(X1, ..., Xn), ..., Xn = fn(X1, ..., Xn), where each fi is a polynomial with nonnegative coefficients that add up to 1. The least nonnegative solution, say mu, of such equation systems is central to problems from various areas, like physics, biology, computational linguistics and probabilistic program verification. We give a simple and strongly polynomial algorithm to decide whether mu=(1, ..., 1) holds. Furthermore, we present an algorithm that computes reliable sequences of lower and upper bounds on mu, converging linearly to mu. Our algorithm has these features despite using inexact arithmetic for efficiency. We report on experiments that show the performance of our algorithms.", "num_citations": "21\n", "authors": ["1874"]}
{"title": "Verifying probabilistic procedural programs\n", "abstract": " Monolithic finite-state probabilistic programs have been abstractly modeled by finite Markov chains, and the algorithmic verification problems for them have been investigated very extensively. In this paper we survey recent work conducted by the authors together with colleagues on he algorithmic verification of probabilistic procedural programs ([BKS,EKM04,EY04]). Probabilistic procedural programs can more naturally be modeled by recursive Markov chains ([EY04)], or equivalently, probabilistic pushdown automata ([EKM04)]. A very rich theory emerges for these models. While our recent work solves a number of verification problems for these models, many intriguing questions remain open.", "num_citations": "21\n", "authors": ["1874"]}
{"title": "Proof-checking protocols using bisimulations\n", "abstract": " We report on our experience in using the Isabelle/HOL theorem prover to mechanize proofs of observation equivalence for systems with infinitely many states, and for parameterized systems. We follow the direct approach: An infinite relation containing the pair of systems to be shown equivalent is defined, and then proved to be a weak bisimulation. The weak bisimilarity proof is split into many cases, corresponding to the derivatives of the pairs in the relation. Isabelle/HOL automatically proves simple cases, and guarantees that no case is forgotten. The strengths and weaknesses of the approach are discussed.", "num_citations": "21\n", "authors": ["1874"]}
{"title": "One theorem to rule them all: A unified translation of LTL into \u03c9-automata\n", "abstract": " We present a unified translation of LTL formulas into deterministic Rabin automata, limit-deterministic B\u00fcchi automata, and nondeterministic B\u00fcchi automata. The translations yield automata of asymptotically optimal size (double or single exponential, respectively). All three translations are derived from one single Master Theorem of purely logical nature. The Master Theorem decomposes the language of a formula into a positive boolean combination of languages that can be translated into \u03c9-automata by elementary means. In particular, Safra's, ranking, and breakpoint constructions used in other translations are not needed.", "num_citations": "20\n", "authors": ["1874"]}
{"title": "Large flocks of small birds: on the minimal size of population protocols\n", "abstract": " Population protocols are a well established model of distributed computation by mobile finite-state agents with very limited storage. A classical result establishes that population protocols compute exactly predicates definable in Presburger arithmetic. We initiate the study of the minimal amount of memory required to compute a given predicate as a function of its size. We present results on the predicates  for , and more generally on the predicates corresponding to systems of linear inequalities. We show that they can be computed by protocols with  states (or, more generally, logarithmic in the coefficients of the predicate), and that, surprisingly, some families of predicates can be computed by protocols with  states. We give essentially matching lower bounds for the class of 1-aware protocols.", "num_citations": "20\n", "authors": ["1874"]}
{"title": "On negotiation as concurrency primitive II: Deterministic cyclic negotiations\n", "abstract": " We continue our study of negotiations, a concurrency model with multi-party negotiation as primitive. In a previous paper [7] we have provided a correct and complete set of reduction rules for sound, acyclic, and (weakly) deterministic negotiations. In this paper we extend this result to all deterministic negotiations, including cyclic ones. We also show that this set of rules allows one to decide soundness and to summarize negotiations in polynomial time.", "num_citations": "20\n", "authors": ["1874"]}
{"title": "Approximative methods for monotone systems of min-max-polynomial equations\n", "abstract": " A monotone system of min-max-polynomial equations (min-max-MSPE) over the variables X                   1,...,X                                        n                    has for every i exactly one equation of the form X                                        i                   \u2009=\u2009f                                        i                   (X                   1,...,X                                        n                   ) where each f                                        i                   (X                   1,...,X                                        n                   ) is an expression built up from polynomials with non-negative coefficients, minimum- and maximum-operators. The question of computing least solutions of min-max-MSPEs arises naturally in the analysis of recursive stochastic games [5,6,14]. Min-max-MSPEs generalize MSPEs for which convergence speed results of Newton\u2019s method are established in [11,3]. We present the first methods for approximatively computing least solutions of min-max-MSPEs which converge at least linearly\u00a0\u2026", "num_citations": "20\n", "authors": ["1874"]}
{"title": "Existence of home states in Petri nets is decidable\n", "abstract": " We show that the problem whether a given Petri net has a home state (a marking reachable from every reachable marking) is decidable, and at least as hard as the reachability problem.", "num_citations": "18\n", "authors": ["1874"]}
{"title": "A brief history of Strahler numbers\n", "abstract": " The Strahler number or Horton-Strahler number of a tree, originally introduced in geophysics, has a surprisingly rich theory. We sketch some milestones in its history, and its connection to arithmetic expressions, graph traversing, decision problems for context-free languages, Parikh\u2019s theorem, and Newton\u2019s procedure for approximating zeros of differentiable functions.", "num_citations": "18\n", "authors": ["1874"]}
{"title": "Automatic error correction of Java programs\n", "abstract": " We present a technique for automatically detecting and correcting software bugs. The programmer is required to define a catalog of hotspots, syntactic constructs she considered to be error prone (e.g. i < N), together with suitable alternatives (e.g. i < (N + 1) and i < (N - 1)). Given a faulty program, search techniques are then applied to find a combination of alternatives yielding a correct program. The technique is implemented on top of the Java Pathfinder Framework.", "num_citations": "18\n", "authors": ["1874"]}
{"title": "Towards efficient verification of population protocols\n", "abstract": " Population protocols are a well established model of computation by anonymous, identical finite-state agents. A protocol is well-specified if from every initial configuration, all fair executions of the protocol reach a common consensus. The central verification question for population protocols is the well-specification problem: deciding if a given protocol is well-specified. Esparza et al. have recently shown that this problem is decidable, but with very high complexity: it is at least as hard as the Petri net reachability problem, which is TOWER-hard, and for which only algorithms of non-primitive recursive complexity are currently known. In this paper we introduce the class of well-specified strongly-silent protocols and we prove that it is suitable for automatic verification. More precisely, we show that has the same computational power as general well-specified protocols, and captures standard protocols from the literature\u00a0\u2026", "num_citations": "17\n", "authors": ["1874"]}
{"title": "A Logical Viewpoint on Process-Algebraic Quotients\n", "abstract": " Let \u223c be a process equivalence. A formula \u03c6 is preserved by \u223c-quotients iff for every process s of a transition system T we have that if s satisfies \u03c6, then also [s] satisfies \u03c6, where [s] is the equivalence class of s in the quotient of T under \u223c. We classify all formulae of Hennessy\u2013Milner logic which are preserved by \u223c-quotients of image-finite processes. Our result is generic in the sense that it works for a large class of process equivalences which admit a modal characterization in Hennessy\u2013Milner logic satisfying certain closure properties. Practical applicability of the result is demonstrated on equivalences of the linear/branching time spectrum.", "num_citations": "17\n", "authors": ["1874"]}
{"title": "An effective tableau system for the linear time \u03bc-calculus\n", "abstract": " We present a tableau system for the model checking problem of the linear time \u03bc-calculus. It improves the system of Stirling and Walker by simplifying the success condition for a tableau. In our system success for a leaf is determined by the path leading to it, whereas Stirling and Walker's method requires the examination of a potentially infinite number of paths extending over the whole tableau.", "num_citations": "17\n", "authors": ["1874"]}
{"title": "Shortest paths in reachability graphs\n", "abstract": " We prove the following property for safe conflict-free Petri nets and live and safe extended free-choice Petri nets:             Given two markings M                  1               , M                  2                of the reachability graph, if some path leads from M 1 to M 2, then some path of polynomial length in the number of transitions of the net leads from M 1 to M 2.", "num_citations": "17\n", "authors": ["1874"]}
{"title": "A partial order approach to model checking\n", "abstract": " Model checking is a prominent technique used in the hardware and software industries for automatic verification. While it is very successful in finding subtle bugs in distributed systems, it faces the state explosion problem-the number of reachable states grows exponentially in the number of concurrent components.In this book the authors introduce unfoldings, an approach to model checking which alleviates the state explosion problem by means of concurrency theory. They offer a gentle introduction to the basics of the method, and in particular they detail an unfolding-based algorithm for model checking concurrent systems against properties specified as formulas of linear temporal logic (LTL). Self-contained chapters cover transition systems and their products; unfolding products; search procedures for basic verification problems, such as reachability and livelocks; and model checking LTL. The final chapter\u00a0\u2026", "num_citations": "17\n", "authors": ["1874"]}
{"title": "Veri\ufb01cation of Graph Transformation Systems with Context-Free Speci\ufb01cations\u22c6\n", "abstract": " We introduce an analysis method for graph transformation systems which checks that certain forbidden graphs are not reachable from the start graph. These forbidden graphs are speci\ufb01ed by a contextfree graph grammar. The technique is based on the approximation of graph transformation systems by Petri nets and on semilinear sets of markings. Especially we exploit Parikh\u2019s theorem which says that the Parikh image of a context-free grammar is semilinear. An important application is deadlock analysis for interaction nets and we speci\ufb01cally show how to apply the technique to an in\ufb01nite-state dining philosopher\u2019s system.", "num_citations": "16\n", "authors": ["1874"]}
{"title": "A solution to the covering problem for 1-bounded conflict-free Petri nets using linear programming\n", "abstract": " Given a marking \u03bc of a Petri net, the covering problem consist of determining if there exists a reachable marking \u03bc'\u2a7e. We show that the covering problem for 1-bounded conflict-free Petri nets ispolynomially reducible to a Linear Programming problem. This proves that the covering problem is in PTIME for this class of Petri nets, which generalises a result of Yen.", "num_citations": "16\n", "authors": ["1874"]}
{"title": "Polynomial analysis algorithms for free choice probabilistic workflow nets\n", "abstract": " We introduce Probabilistic Workflow Nets (PWNs), a model extending confusion-free workflow Petri nets with probabilities. We give PWNs a semantics in terms of Markov Decision Processes (MDPs) and introduce a reward model. We show that the expected reward of a complete execution of a PWN is independent of the scheduler used to resolve the nondeterminism of the MDP, which allows one to choose a suitable scheduler for its computation. However, this feature does not lead to a polynomial algorithm, and in fact we prove that deciding whether the expected reward exceeds a given threshold is PSPACE-hard.To alleviate this high computational cost, we extend previous work on property-preserving reductions of non-probabilistic workflow nets. We introduce reduction rules for PWNs, and prove that they preserve the expected reward. The rules allow us to simplify the workflow before constructing its MDP. We\u00a0\u2026", "num_citations": "15\n", "authors": ["1874"]}
{"title": "Space-efficient scheduling of stochastically generated tasks\n", "abstract": " We study the problem of scheduling tasks for execution by a processor when the tasks can stochastically generate new tasks. Tasks can be of different types, and each type has a fixed, known probability of generating other tasks. We present results on the random variable S \u03c3 modeling the maximal space needed by the processor to store the currently active tasks when acting under the scheduler \u03c3. We obtain tail bounds for the distribution of S \u03c3 for both offline and online schedulers, and investigate the expected value E [S \u03c3].", "num_citations": "14\n", "authors": ["1874"]}
{"title": "Parameterized analysis of immediate observation petri nets\n", "abstract": " We introduce immediate observation Petri nets, a class of interest in the study of population protocols (a model of distributed computation), and enzymatic chemical networks. In these areas, relevant analysis questions translate into parameterized Petri net problems: whether an infinite set of Petri nets with the same underlying net, but different initial markings, satisfy a given property. We study the parameterized reachability, coverability, and liveness problems for immediate observation Petri nets. We show that all three problems are in  for infinite sets of initial markings defined by counting constraints, a class sufficiently rich for the intended application. This is remarkable, since the problems are already -hard when the set of markings is a singleton, i.e., in the non-parameterized case. We use these results to prove that the correctness problem for immediate observation population protocols is\u00a0\u2026", "num_citations": "13\n", "authors": ["1874"]}
{"title": "Peregrine: A Tool for the Analysis of Population Protocols\n", "abstract": " We introduce Peregrine, the first tool for the analysis and parameterized verification of population protocols. Population protocols are a model of computation very much studied by the distributed computing community, in which mobile anonymous agents interact stochastically to achieve a common task. Peregrine allows users to design protocols, to simulate them both manually and automatically, to gather statistics of properties such as convergence speed, and to verify correctness automatically. This paper describes the features of Peregrine and their implementation.", "num_citations": "13\n", "authors": ["1874"]}
{"title": "The PEP Verification System\n", "abstract": " This paper gives a short overview of the veri cation system PEP (a Programming Environment based on Petri nets). It focuses on some recent developments.", "num_citations": "13\n", "authors": ["1874"]}
{"title": "Solving fixed-point equations by derivation tree analysis\n", "abstract": " Systems of equations over \u03c9-continuous semirings can be mapped to context-free grammars in a natural way. We show how an analysis of the derivation trees of the grammar yields new algorithms for approximating and even computing exactly the least solution of the system.", "num_citations": "12\n", "authors": ["1874"]}
{"title": "FPsolve: A Generic Solver for Fixpoint Equations over Semirings\n", "abstract": " We introduce FPsolve, an implementation of generic algorithms for solving fixpoint equations over semirings. We first illustrate the interest of generic solvers by means of a scenario. We then succinctly describe some of the algorithms implemented in the tool, and provide some implementation details.", "num_citations": "11\n", "authors": ["1874"]}
{"title": "Simple representative instantiations for multicast protocols\n", "abstract": " We present a formal model for multicast network protocols working on arbitrary tree structures. We give sufficient conditions under which correctness of the protocol for all structures reduces to correctness for the structures with at most one layer of internal nodes. If additional conditions hold, we can reduce further to correctness for one single structure. All these results can be applied to (an abstract version of) the Pragmatic General Multicast protocol.", "num_citations": "11\n", "authors": ["1874"]}
{"title": "Verification using PEP\n", "abstract": " PEP is a tool for the design, analysis and the verification of parallel programs. Two approaches are presented in this paper being the underlying technique of the verification component of PEP.", "num_citations": "11\n", "authors": ["1874"]}
{"title": "Succinct population protocols for Presburger arithmetic\n", "abstract": " Angluin et al. proved that population protocols compute exactly the predicates definable in Presburger arithmetic (PA), the first-order theory of addition. As part of this result, they presented a procedure that translates any formula  of quantifier-free PA with remainder predicates (which has the same expressive power as full PA) into a population protocol with  states that computes . More precisely, the number of states of the protocol is exponential in both the bit length of the largest coefficient in the formula, and the number of nodes of its syntax tree. In this paper, we prove that every formula  of quantifier-free PA with remainder predicates is computable by a leaderless population protocol with  states. Our proof is based on several new constructions, which may be of independent interest. Given a formula  of quantifier-free PA with remainder predicates, a first construction produces a succinct protocol (with  leaders) that computes ; this completes the work initiated in [STACS'18], where we constructed such protocols for a fragment of PA. For large enough inputs, we can get rid of these leaders. If the input is not large enough, then it is small, and we design another construction producing a succinct protocol with one leader that computes . Our last construction gets rid of this leader for small inputs.", "num_citations": "10\n", "authors": ["1874"]}
{"title": "Negotiations and Petri nets\n", "abstract": " Negotiations have recently been introduced as a model of concurrency with multi-party negotiation atoms as primitive. This paper studies the relation between negotiations and Petri nets. In particular, we show that each negotiation can be translated into a 1-safe labelled Petri net with equivalent behaviour. In the general case, this Petri net is exponentially larger than the negotiation. For deterministic negotiations, however, the corresponding Petri has linear size compared to the negotiation, and it enjoys the free-choice property. We show that for this class the negotiation is sound if and only if the corresponding Petri net is sound. Finally, we have a look at the converse direction: given a Petri net, can we find a corresponding negotiation?", "num_citations": "10\n", "authors": ["1874"]}
{"title": "Enhancing the Availability of Networked Database Services by Replication and Consistency Maintenance\n", "abstract": " We describe a middleware platform for maintaining the consistency of replicated data called COPla (Common Object Platform). The purpose of replication is to enhance the availability of data and services in distributed database networks. That is orthogonal to recovery strategies of backed-up snapshots, logs and other measures to alleviate database downtimes. A range of different consistency modes ensures the correctness of replicated data.", "num_citations": "10\n", "authors": ["1874"]}
{"title": "A polynomial-time algorithm for checking consistency of free-choice signal transition graphs\n", "abstract": " Signal Transition Graphs (STGs) are one of the most popular models for the specification of asynchronous circuits. A STG can be implemented if it admits a so-called consistent and complete binary encoding. Deciding this is EXPSPACE-hard for arbitrary STGs, and so a lot of attention has been devoted to the subclass of free-choice STGs, which offers a good compromise between expressive power and analizability. In the last years, polynomial time synthesis techniques have been developed for free-choice STGs, but they assume that the STG has a consistent binary encoding. This paper presents the first polynomial algorithm for checking consistency.", "num_citations": "10\n", "authors": ["1874"]}
{"title": "Automatic analysis of expected termination time for population protocols\n", "abstract": " Population protocols are a formal model of sensor networks consisting of identical mobile devices. Two devices can interact and thereby change their states. Computations are infinite sequences of interactions in which the interacting devices are chosen uniformly at random. In well designed population protocols, for every initial configuration of devices, and for every computation starting at this configuration, all devices eventually agree on a consensus value. We address the problem of automatically computing a parametric bound on the expected time the protocol needs to reach this consensus. We present the first algorithm that, when successful, outputs a function f(n) such that the expected time to consensus is bound by O(f(n)), where n is the number of devices executing the protocol. We experimentally show that our algorithm terminates and provides good bounds for many of the protocols found in the literature.", "num_citations": "9\n", "authors": ["1874"]}
{"title": "Derivation tree analysis for accelerated fixed-point computation\n", "abstract": " We show that for several classes of idempotent semirings the least fixed-point of a polynomial system of equations is equal to the least fixed-point of a linear system obtained by \u201clinearizing\u201d the polynomials of in a certain way. Our proofs rely on derivation tree analysis, a proof principle that combines methods from algebra, calculus, and formal language theory, and was first used in [5] to show that Newton\u2019s method over commutative and idempotent semirings converges in a linear number of steps. Our results lead to efficient generic algorithms for computing the least fixed-point. We use these algorithms to derive several consequences, including an O (N 3) algorithm for computing the throughput of a context-free grammar (obtained by speeding up the O (N 4) algorithm of [2]), and a generalization of Courcelle\u2019s result stating that the downward-closed image of a context-free language is regular [3].", "num_citations": "9\n", "authors": ["1874"]}
{"title": "A false history of true concurrency: From Petri to tools\n", "abstract": " I briefly review the history of the unfolding approach to model checking.", "num_citations": "9\n", "authors": ["1874"]}
{"title": "Verification of systems with an infinite state space\n", "abstract": " During the last two decades, an important effort has been devoted to the development of verification techniques and their application. Significant achievements have been obtained, and efficient tools have been developed for automatic verification of finite-state systems (i.e., systems with finitely many configurations), based essentially on reachability analysis algorithms. All major constructors of hardware and software controllers have already created verification groups that use these techniques. This is particularly true after the recent occurrence of costly errors like the Pentium bug and the Ariane crash.", "num_citations": "9\n", "authors": ["1874"]}
{"title": "Parameter synthesis in Markov models.\n", "abstract": " Markov models comprise states with probabilistic transitions. The analysis of these models is ubiquitous and studied in, among others, reliability engineering, artificial intelligence, systems biology, and formal methods. Naturally, their analysis crucially depends on the transition probabilities. Often, these probabilities are approximations based on data or reflect configurable parts of a modelled system. To represent the uncertainty about the probabilities, we study parametric Markov models, in which the probabilities are symbolic expressions rather than concrete values. More precisely, we consider parametric Markov decision processes (pMDPs) and parametric Markov chains (pMCs) as special case. Substitution of the parameters yields classical, parameter-free Markov decision processes (MDPs) and Markov chains (MCs). A pMDP thus induces uncountably many MDPs. Each MDP may satisfy reachability and reward properties, such as the maximal probability that the system reaches an \u2018offline\u2019state is less than 0.01%, or the maximal expected energy consumption is less than 20 kWh. Lifting these properties to pMDPs yields fundamental problems asking: Is there an induced MDP satisfying the property?(feasibility), its dual Do all induced MDPs satisfy the property?(validity), and advanced problems such as What is a concise representation for all induced MCs satisfying the property? We study these problems on a conceptual level, and design and implement both improved and novel algorithms. On the conceptual side, a thorough discussion of the feasibility problem yields new results, such as:(1) that answering various variants of the feasibility\u00a0\u2026", "num_citations": "8\n", "authors": ["1874"]}
{"title": "Black ninjas in the dark: Formal analysis of population protocols\n", "abstract": " In this interactive paper, which you should preferably read connected to the Internet, the Black Ninjas introduce you to population protocols, a fundamental model of distributed computation, and to recent work by the authors and their colleagues on their automatic verification.", "num_citations": "8\n", "authors": ["1874"]}
{"title": "Minimizing test suites with unfoldings of multithreaded programs\n", "abstract": " This article focuses on computing minimal test suites for multithreaded programs. Based on previous work on test case generation for multithreaded programs using unfoldings, this article shows how this unfolding can be used to generate minimal test suites covering all local states of the program. Generating such minimal test suites is shown to be NP-complete in the size of the unfolding. We propose an SMT encoding for this problem and two methods based on heuristics which only approximate the solution, but scale better in practice. Finally, we apply our methods to compute the minimal test suites for several benchmarks.", "num_citations": "8\n", "authors": ["1874"]}
{"title": "Reactive and proactive diagnosis of distributed systems using net unfoldings\n", "abstract": " We present a diagnosis algorithm for distributed systems modeled as products of transition systems, a model very close to Petri nets. Following the seminal work of Benveniste, Fabre, Haar, and Jard, our algorithm palliates the state-explosion problem by means of the unfolding technique. Given an observation (partial information about a firing sequence), the algorithm constructs a prefix of the unfolding, a compact representation of the executions of the system compatible with the observation. Since the computations of this prefix is algorithmically involved, we define an over approximation that trades precision for speed. We report on an implementation that constructs the prefix when the sequence of observations is known (reactive), but also present an online approach, where the diagnosis proactively looks into the future and compare these two approaches. Moreover, we present SAT solving methods for analyzing\u00a0\u2026", "num_citations": "8\n", "authors": ["1874"]}
{"title": "Probabilistic abstractions with arbitrary domains\n", "abstract": " Recent work by Hermanns et al. and Kattenbelt et al. has extended counterexample-guided abstraction refinement (CEGAR) to probabilistic programs. These approaches are limited to predicate abstraction. We present a novel technique, based on the abstract reachability tree recently introduced by Gulavani et al., that can use arbitrary abstract domains and widening operators (in the sense of Abstract Interpretation). We show how suitable widening operators can deduce loop invariants difficult to find for predicate abstraction, and propose refinement techniques.", "num_citations": "8\n", "authors": ["1874"]}
{"title": "A negative result on depth-first net unfoldings\n", "abstract": " Esparza et al present a counterexample showing that depth-first search in net unfoldings is not correct. Exparza et al discuss unfoldings of transition systems, introduce introduce net unfoldings as a generalization of the transition-system case, comment on the the notion of correct search algorithms and present the counter example showing that depth-first-search algorithms are not correct. Finally, Esparza et al discuss the result.", "num_citations": "8\n", "authors": ["1874"]}
{"title": "Soundness in negotiations\n", "abstract": " Negotiations are a formalism for describing multiparty distributed cooperation. Alternatively, they can be seen as a model of concurrency with synchronized choice as communication primitive. Well-designed negotiations must be sound, meaning that, whatever its current state, the negotiation can still be completed. In earlier work, Esparza and Desel have shown that deciding soundness of a negotiation is Pspace-complete, and in Ptime if the negotiation is deterministic. They have also extended their polynomial soundness algorithm to an intermediate class of acyclic, non-deterministic negotiations. However, they did not analyze the runtime of the extended algorithm, and also left open the complexity of the soundness problem for the intermediate class. In the first part of this paper we revisit the soundness problem for deterministic negotiations, and show that it is Nlogspace-complete, improving on the earlier algorithm, which requires linear space. In the second part we answer the question left open by Esparza and Desel. We prove that the soundness problem can be solved in polynomial time for acyclic, weakly non- deterministic negotiations, a more general class than the one considered by them. In the third and final part, we show that the techniques developed in the first two parts of the paper can be applied to analysis problems other than soundness, including the problem of detecting race conditions, and several classical static analysis problems. More specifically, we show that, while these problems are intractable for arbitrary acyclic deterministic negotiations, they become tractable in the sound case. So soundness is not only a desirable\u00a0\u2026", "num_citations": "7\n", "authors": ["1874"]}
{"title": "SDSIrep: A reputation system based on SDSI\n", "abstract": " We introduce SDSIrep, a reputation system based on the SPKI/SDSI authorization system. It is well-known that a system of SPKI/SDSI certificates corresponds to the formal model of a pushdown system (PDS). Our system, SDSIrep, allows principals to express trust and recommendations in the form of so-called certificates with weights. By interpreting weights as probabilities, we obtain a random-walk model of the reputation of a principal. Thus, SDSIrep represents an application of the theory of probabilistic PDSs to the field of computer security. We present an algorithm to compute the reputation of each principal. An extension of SDSIrep also provides for so-called intersection certificates, by which, loosely speaking, a principal gains reputation if recommended by all members of a given group of principals. On a formal-methods level, this extension makes SDSIrep correspond to probabilistic alternating PDSs\u00a0\u2026", "num_citations": "7\n", "authors": ["1874"]}
{"title": "Locality-based abstractions\n", "abstract": " We present locality-based abstractions, in which a set of states of a distributed system is abstracted to the collection of views that some observers have of the states. Special cases of locality-abstractions have been used in different contexts (planning, analysis of concurrent programs, concurrency theory). In this paper we give a general definition in the context of abstract interpretation, show that arbitrary locality-based abstractions are hard to compute in general, and provide two solutions to this problem. The solutions are evaluated in several case studies.", "num_citations": "7\n", "authors": ["1874"]}
{"title": "An automata-theoretic approach to software verification\n", "abstract": " \u2013Parameterisation. Many distributed systems should be correct whatever the value of some parameter. The problem is to validate the system for all possible values.(Strictly speaking, we deal here with an infinite family of systems, but the family can usually be seen as one single infinite-state system.)", "num_citations": "7\n", "authors": ["1874"]}
{"title": "Shortest paths in reachability graphs\n", "abstract": " We prove the following property for safe marked graphs, safe conflict-free Petri nets, and live and safe extended free-choice Petri nets: Given two markings M1, M2 of the reachability graph, if some path leads from M1 to M2, then some path of polynomial length in the number of transitions of the net leads from M1 to M2.", "num_citations": "7\n", "authors": ["1874"]}
{"title": "Zeros of the Hankel function of real order out of the principal Riemann sheet\n", "abstract": " Zeros of the Hankel function of real order follow, as the order varies continuously, trajectories across different Riemann sheets of the complex plane. A discussion of the main features of these trajectories is presented.", "num_citations": "7\n", "authors": ["1874"]}
{"title": "Complexity of verification and synthesis of threshold automata\n", "abstract": " Threshold automata are a formalism for modeling and analyzing fault-tolerant distributed algorithms, recently introduced by Konnov, Veith, and Widder, describing protocols executed by a fixed but arbitrary number of processes. We conduct the first systematic study of the complexity of verification and synthesis problems for threshold automata. We prove that the coverability, reachability, safety, and liveness problems are NP-complete, and that the bounded synthesis problem is  complete. A key to our results is a novel characterization of the reachability relation of a threshold automaton as an existential Presburger formula. The characterization also leads to novel verification and synthesis algorithms. We report on an implementation, and provide experimental results.", "num_citations": "6\n", "authors": ["1874"]}
{"title": "Checking qualitative liveness properties of replicated systems with stochastic scheduling\n", "abstract": " We present a sound and complete method for the verification of qualitative liveness properties of replicated systems under stochastic scheduling. These are systems consisting of a finite-state program, executed by an unknown number of indistinguishable agents, where the next agent to make a move is determined by the result of a random experiment. We show that if a property of such a system holds, then there is always a witness in the shape of a Presburger stage graph: a finite graph whose nodes are Presburger-definable sets of configurations. Due to the high complexity of the verification problem (non-elementary), we introduce an incomplete procedure for the construction of Presburger stage graphs, and implement it on top of an SMT solver. The procedure makes extensive use of the theory of well-quasi-orders, and of the structural theory of Petri nets and vector addition systems. We apply our results to a set\u00a0\u2026", "num_citations": "6\n", "authors": ["1874"]}
{"title": "Static analysis of deterministic negotiations\n", "abstract": " Negotiation diagrams are a model of concurrent computation akin to workflow Petri nets. Deterministic negotiation diagrams, equivalent to the much studied and used free-choice workflow Petri nets, are surprisingly amenable to verification. Soundness (a property close to deadlock-freedom) can be decided in PTIME. Further, other fundamental questions like computing summaries or the expected cost, can also be solved in PTIME for sound deterministic negotiation diagrams, while they are PSPACE-complete in the general case.", "num_citations": "6\n", "authors": ["1874"]}
{"title": "Negotiation as concurrency primitive\n", "abstract": " This paper introduces negotiations, a model of concurrency close to Petri nets, with multi-party negotiations as concurrency primitive. We study two fundamental analysis problems. The soundness problem consists in deciding if it is always possible for a negotiation to terminate successfully, whatever the current state is. Given a sound negotiation, the summarization problem aims at computing an equivalent one-step negotiation with the same input/output behavior. The soundness and summarization problems can be solved by means of simple algorithms acting on the state space of the negotiation, which however face the well-known state explosion problem. We study alternative algorithms that avoid the construction of the state space. In particular, we define reduction rules that simplify a negotiation while preserving the sound/non-sound character of the negotiation and its summary. In a first result we show\u00a0\u2026", "num_citations": "6\n", "authors": ["1874"]}
{"title": "Automata, Languages, and Programming: 41st International Colloquium, ICALP 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part II\n", "abstract": " This two-volume set of LNCS 8572 and LNCS 8573 constitutes the refereed proceedings of the 41st International Colloquium on Automata, Languages and Programming, ICALP 2014, held in Copenhagen, Denmark, in July 2014. The total of 136 revised full papers presented together with 4 invited talks were carefully reviewed and selected from 484 submissions. The papers are organized in three tracks focussing on Algorithms, Complexity, and Games, Logic, Semantics, Automata, and Theory of Programming, Foundations of Networked Computation.", "num_citations": "6\n", "authors": ["1874"]}
{"title": "A strongly polynomial algorithm for criticality of branching processes and consistency of stochastic context-free grammars\n", "abstract": " We provide a strongly polynomial algorithm for determining whether a given multi-type branching process is subcritical, critical, or supercritical. The same algorithm also decides consistency of stochastic context-free grammars.", "num_citations": "6\n", "authors": ["1874"]}
{"title": "On the memory consumption of probabilistic pushdown automata\n", "abstract": " We investigate the problem of evaluating memory consumption for systems modelled by probabilistic pushdown automata (pPDA). The space needed by a runof a pPDA is the maximal height reached by the stack during the run. Theproblem is motivated by the investigation of depth-first computations that playan important role for space-efficient schedulings of multithreaded programs. We study the computation of both the distribution of the memory consumption and its expectation. For the distribution, we show that a naive method incurs anexponential blow-up, and that it can be avoided using linear equation systems. We also suggest a possibly even faster approximation method. Given~ , these methods allow to compute bounds on the memoryconsumption that are exceeded with a probability of at most~ . For the expected memory consumption, we show that whether it is infinite can be decided in polynomial time for stateless pPDA (pBPA) and in polynomial space for pPDA. We also provide an iterative method for approximating theexpectation. We show how to compute error bounds of our approximation methodand analyze its convergence speed. We prove that our method convergeslinearly, ie, the number of accurate bits of the approximation is a linear function of the number of iterations.", "num_citations": "6\n", "authors": ["1874"]}
{"title": "Zeros of the Whittaker function associated to Coulomb waves\n", "abstract": " The zeros in the complex z plane of the Whittaker function W c/z,\u03bc (z), closely related to spherical waves in the quantum-mechanical Coulomb problem, are investigated for varying real values of the parameters c and \u03bc", "num_citations": "6\n", "authors": ["1874"]}
{"title": "Expressive power of broadcast consensus protocols\n", "abstract": " Population protocols are a formal model of computation by identical, anonymous mobile agents interacting in pairs. Their computational power is rather limited: Angluin et al. have shown that they can only compute the predicates over  expressible in Presburger arithmetic. For this reason, several extensions of the model have been proposed, including the addition of devices called cover-time services, absence detectors, and clocks. All these extensions increase the expressive power to the class of predicates over  lying in the complexity class NL when the input is given in unary. However, these devices are difficult to implement, since they require that an agent atomically receives messages from all other agents in a population of unknown size; moreover, the agent must know that they have all been received. Inspired by the work of the verification community on Emerson and Namjoshi's broadcast protocols, we show that NL-power is also achieved by extending population protocols with reliable broadcasts, a simpler, standard communication primitive.", "num_citations": "5\n", "authors": ["1874"]}
{"title": "An SMT-based approach to fair termination analysis\n", "abstract": " Algorithms for the coverability problem have been successfully applied to safety checking for concurrent programs. In a former paper (An SMT-based Approach to Coverability Analysis, CAV14) we have revisited a constraint approach to coverability based on classical Petri net analysis techniques and implemented it on top of state-of-the-art SMT solvers. In this paper we extend the approach to fair termination; many other liveness properties can be reduced to fair termination using the automata-theoretic approach to verification. We use T-invariants to identify potential infinite computations of the system, and design a novel technique to discard false positives, that is, potential computations that are not actually executable. We validate our technique on a large number of case studies.", "num_citations": "5\n", "authors": ["1874"]}
{"title": "Some applications of petri nets to the analysis of parameterised systems\n", "abstract": " Some applications of Petri Nets to the Analysis of Parameterised Systems Page 1 Some applications of Petri Nets to the Analysis of Parameterised Systems Javier Esparza Institute for Formal Methods in Computer Science University of Stuttgart (with thanks to Jean-Francois Raskin) Page 2 Automatic verification Initiated in the midlle 80s Very successful in hardware Application to software systems is probably today\u2019s main research challenge Explicit construction of the state space \u2192 finiteness constraint 1 Page 3 Sources of infinity in infinite-state systems Data manipulation: unbounded counters, integer variables, lists . . . Control structures: procedures , process creation . . . Asynchronous communication: unbounded FIFO queues Parameters: number of processes, of input gates, of principals, of sessions, of nonces . . . Real-time: discrete or dense domains 2 Page 4 Parameterised protocols Defined for n processes. \u2026", "num_citations": "5\n", "authors": ["1874"]}
{"title": "Lower Bounds on the State Complexity of Population Protocols\n", "abstract": " Population protocols are a model of computation in which an arbitrary number of indistinguishable finite-state agents interact in pairs. The goal of the agents is to decide by stable consensus whether their initial global configuration satisfies a given property, specified as a predicate on the set of all initial configurations. The state complexity of a predicate is the number of states of a smallest protocol that computes it. Previous work by Blondin et al. has shown that the counting predicates  have state complexity  for leaderless protocols and  for protocols with leaders. We obtain the first non-trivial lower bounds: the state complexity of  is  for leaderless protocols, and the inverse of a non-elementary function for protocols with leaders.", "num_citations": "4\n", "authors": ["1874"]}
{"title": "Negotiation programs\n", "abstract": " We introduce a global specification language for distributed negotiations, a recently introduced concurrent computation model with atomic negotiations combining synchronization of participants and choice as primitive. A token game on distributed negotiations determines reachable markings which enable possible next atomic negotiations. In a deterministic distributed negotiation, each participant can always be engaged in at most one next atomic negotiation. In a sound distributed negotiation, every atomic negotiation is enabled at some reachable marking, and from every reachable marking the final marking of the distributed negotiation can be reached. We prove that our specification language has the same expressive power as sound and deterministic negotiations, i.e., every program can be implemented by an equivalent sound and deterministic negotiation and every sound and deterministic\u00a0\u2026", "num_citations": "4\n", "authors": ["1874"]}
{"title": "Distributed markov chains\n", "abstract": " The formal verification of large probabilistic models is challenging. Exploiting the concurrency that is often present is one way to address this problem. Here we study a class of communicating probabilistic agents in which the synchronizations determine the probability distribution for the next moves of the participating agents. The key property of this class is that the synchronizations are deterministic, in the sense that any two simultaneously enabled synchronizations involve disjoint sets of agents. As a result, such a network of agents can be viewed as a succinct and distributed presentation of a large global Markov chain. A rich class of Markov chains can be represented this way.             We use partial-order notions to define an interleaved semantics that can be used to efficiently verify properties of the global Markov chain represented by the network. To demonstrate this, we develop a statistical model\u00a0\u2026", "num_citations": "4\n", "authors": ["1874"]}
{"title": "On the complexity of consistency and complete state coding for signal transition graphs\n", "abstract": " Signal Transition Graphs (STGs) are a popular formalism for the specification of asynchronous circuits. A necessary condition for the implementability of an STG is the existence of a consistent and complete state encoding. For an important subclass of STGs, the marked graph STGs, we show that checking consistency is polynomial, but checking the existence of a complete state coding is co-NP-complete. In fact, co-NP-completeness already holds for acyclic and 1-bounded marked graph STGs and for live and 1-bounded marked graph STGs. We add some relevant results for free-choice, bounded, and general STGs.", "num_citations": "4\n", "authors": ["1874"]}
{"title": "A logical viewpoint on process-algebraic quotients\n", "abstract": " We study the following problem: Given a transition system    and its quotient   under an equivalence\u223c, which are the sets   of Hennessy-Milner formulae such that: if   and    satisfies \u03d5, then   satisfies \u03d5; if   and   satisfies \u03d5, then   satisfies \u03d5.", "num_citations": "4\n", "authors": ["1874"]}
{"title": "A unified translation of linear temporal logic to \u03c9-automata\n", "abstract": " We present a unified translation of linear temporal logic (LTL) formulas into deterministic Rabin automata (DRA), limit-deterministic B\u00fcchi automata (LDBA), and nondeterministic B\u00fcchi automata (NBA). The translations yield automata of asymptotically optimal size (double or single exponential, respectively). All three translations are derived from one single Master Theorem of purely logical nature. The Master Theorem decomposes the language of a formula into a positive Boolean combination of languages that can be translated into \u03c9-automata by elementary means. In particular, Safra\u2019s, ranking, and breakpoint constructions used in other translations are not needed. We further give evidence that this theoretical clean and compositional approach does not lead to large automata per se and in fact in the case of DRAs yields significantly smaller automata compared to the previously known approach using\u00a0\u2026", "num_citations": "3\n", "authors": ["1874"]}
{"title": "An efficient normalisation procedure for linear temporal logic and very weak alternating automata\n", "abstract": " In the mid 80s, Lichtenstein, Pnueli, and Zuck proved a classical theorem stating that every formula of Past LTL (the extension of LTL with past operators) is equivalent to a formula of the form^ nu= 1 GF\u03c6 v FG\u03c8i, where \u03c6 and \u03c8 contain only past operators. Some years later, Chang, Manna, and Pnueli built on this result to derive a similar normal form for LTL. Both normalisation procedures have a non-elementary worst-case blow-up, and follow an involved path from formulas to counter-free automata to star-free regular expressions and back to formulas. We improve on both points. We present a direct and purely syntactic normalisation procedure for LTL yielding a normal form, comparable to the one by Chang, Manna, and Pnueli, that has only a single exponential blow-up. As an application, we derive a simple algorithm to translate LTL into deterministic Rabin automata. The algorithm normalises the formula\u00a0\u2026", "num_citations": "3\n", "authors": ["1874"]}
{"title": "Quantitative implementation strategies for safety controllers\n", "abstract": " We consider the symbolic controller synthesis approach to enforce safety specifications on perturbed, nonlinear control systems. In general, in each state of the system several control values might be applicable to enforce the safety requirement and in the implementation one has the burden of picking a particular control value out of possibly many. We present a class of implementation strategies to obtain a controller with certain performance guarantees. This class includes two existing implementation strategies from the literature, based on discounted payoff and mean-payoff games. We unify both approaches by using games characterized by a single discount factor determining the implementation. We evaluate different implementations from our class experimentally on two case studies. We show that the choice of the discount factor has a significant influence on the average long-term costs, and the best performance guarantee for the symbolic model does not result in the best implementation. Comparing the optimal choice of the discount factor here with the previously proposed values, the costs differ by a factor of up to 50. Our approach therefore yields a method to choose systematically a good implementation for safety controllers with quantitative objectives.", "num_citations": "3\n", "authors": ["1874"]}
{"title": "Computation of summaries using net unfoldings\n", "abstract": " We study the following summarization problem: given a parallel composition A=A1||...||An of labelled transition systems communicating with the environment through a distinguished component Ai, efficiently compute a summary Si such that E||A and E||Si are trace-equivalent for every environment E. While Si can be computed using elementary automata theory, the resulting algorithm suffers from the state-explosion problem. We present a new, simple but subtle algorithm based on net unfoldings, a partial-order semantics, give some experimental results using an implementation on top of MOLE, and show that our algorithm can handle divergences and compute weighted summaries with minor modifications.", "num_citations": "3\n", "authors": ["1874"]}
{"title": "FTOS-Verify: Analysis and Verification of Non-Functional Properties for Fault-Tolerant Systems\n", "abstract": " The focus of the tool FTOS is to alleviate designers' burden by offering code generation for non-functional aspects including fault-tolerance mechanisms. One crucial aspect in this context is to ensure that user-selected mechanisms for the system model are sufficient to resist faults as specified in the underlying fault hypothesis. In this paper, formal approaches in verification are proposed to assist the claim. We first raise the precision of FTOS into pure mathematical constructs, and formulate the deterministic assumption, which is necessary as an extension of Giotto-like systems (e.g., FTOS) to equip with fault-tolerance abilities. We show that local properties of a system with the deterministic assumption will be preserved in a modified synchronous system used as the verification model. This enables the use of techniques known from hardware verification. As for implementation, we develop a prototype tool called FTOS-Verify, deploy it as an Eclipse add-on for FTOS, and conduct several case studies.", "num_citations": "3\n", "authors": ["1874"]}
{"title": "Monotonic set-extended prefix rewriting and verification of recursive ping-pong protocols\n", "abstract": " Ping-pong protocols with recursive definitions of agents, but without any active intruder, are a Turing powerful model. We show that under the environment sensitive semantics (i.e. by adding an active intruder capable of storing all exchanged messages including full analysis and synthesis of messages) some verification problems become decidable. In particular we give an algorithm to decide control state reachability, a problem related to security properties like secrecy and authenticity. The proof is via a reduction to a new prefix rewriting model called Monotonic Set-extended Prefix rewriting (MSP). We demonstrate further applicability of the introduced model by encoding a fragment of the ccp (concurrent constraint programming) language into MSP.", "num_citations": "3\n", "authors": ["1874"]}
{"title": "Application and Theory of Petri Nets 2002: 23rd International Conference, ICATPN 2002, Adelaide, Australia, June 24-30, 2002. Proceedings\n", "abstract": " This volume contains the proceedings of the 23rd International Conference on Application and Theory of Petri Nets. The aim of the Petri net conferences is to createaforumfordiscussingprogressinthe applicationandtheoryofPetrinets. Typically, the conferences have 100-150participants\u2013one third of these coming from industry while the rest are from universities and research institutions. The conferences always take place in the last week of June. The conference and a number of other activities are co-ordinated by a ste-ing committee with the following members: G. Balbo (Italy), J. Billington (A-tralia), G. De Michelis (Italy), S. Haddad (France), K. Jensen (Denmark), S.-magai (Japan), T. Murata (USA), CA Petri (Germany; honorary member), W. Reisig (Germany), G. Rozenberg (The Netherlands; chairman), and M. Silva (Spain). Other activities before and during the 2002 conference included tool dem-strations, extensive introductory tutorials, two advanced tutorials on \u201cWork? ow Management: Models, Methods, and Systems\u201d and \u201cModel Checking\u201d, and two workshops on \u201cSoftware Engineering and Formal Methods\u201d and \u201cFormal Me-ods Applied to Defence Systems\u201d. The tutorial notes and workshop proceedings are not published in this volume, but copies are available from the organ-ers. The proceedings can be found at http://www. jrpit. flinders. edu. au/CRPIT. html. The 2002 conference was organized by the Computer Systems Engineering Centre, School of Electrical and Information Engineering at the University of South Australia, Adelaide, Australia with assistance from the Department of Computer Science, Adelaide University, Adelaide, Australia\u00a0\u2026", "num_citations": "3\n", "authors": ["1874"]}
{"title": "Computing Parameterized Invariants of Parameterized Petri Nets\n", "abstract": " A fundamental advantage of Petri net models is the possibility to automatically compute useful system invariants from the syntax of the net. Classical techniques used for this are place invariants, P-components, siphons or traps. Recently, Bozga et al. have presented a novel technique for the parameterized verification of safety properties of systems with a ring or array architecture. They show that the statement \u201cfor every instance of the parameterized Petri net, all markings satisfying the linear invariants associated to all the P-components, siphons and traps of the instance are safe\u201d can be encoded in WS1S and checked using tools like MONA. However, while the technique certifies that this infinite set of linear invariants extracted from P-components, siphons or traps are strong enough to prove safety, it does not return an explanation of this fact understandable by humans. We present a CEGAR loop that constructs a\u00a0\u2026", "num_citations": "2\n", "authors": ["1874"]}
{"title": "The complexity of verifying population protocols\n", "abstract": " Population protocols (Angluin et al. in PODC, 2004) are a model of distributed computation in which indistinguishable, finite-state agents interact in pairs to decide if their initial configuration, ie, the initial number of agents in each state, satisfies a given property. In a seminal paper Angluin et al. classified population protocols according to their communication mechanism, and conducted an exhaustive study of the expressive power of each class, that is, of the properties they can decide (Angluin et al. in Distrib Comput 20 (4): 279\u2013304, 2007). In this paper we study the correctness problem for population protocols, ie, whether a given protocol decides a given property. A previous paper (Esparza et al. in Acta Inform 54 (2): 191\u2013215, 2017) has shown that the problem is decidable for the main population protocol model, but at least as hard as the reachability problem for Petri nets, which has recently been proved to have non\u00a0\u2026", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Online Monitoring -Regular Properties in Unknown Markov Chains\n", "abstract": " We study runtime monitoring of -regular properties. We consider a simple setting in which a run of an unknown finite-state Markov chain  is monitored against a fixed but arbitrary -regular specification . The purpose of monitoring is to keep aborting runs that are \"unlikely\" to satisfy the specification until  executes a correct run. We design controllers for the reset action that (assuming that  has positive probability) satisfy the following property w.p.1: the number of resets is finite, and the run executed by  after the last reset satisfies .", "num_citations": "2\n", "authors": ["1874"]}
{"title": "A Classification of Weak Asynchronous Models of Distributed Computing\n", "abstract": " We conduct a systematic study of asynchronous models of distributed computing consisting of identical finite-state devices that cooperate in a network to decide if the network satisfies a given graph-theoretical property. Models discussed in the literature differ in the detection capabilities of the agents residing at the nodes of the network (detecting the set of states of their neighbors, or counting the number of neighbors in each state), the notion of acceptance (acceptance by halting in a particular configuration, or by stable consensus), the notion of step (synchronous move, interleaving, or arbitrary timing), and the fairness assumptions (non-starving, or stochastic-like). We study the expressive power of the combinations of these features, and show that the initially twenty possible combinations fit into seven equivalence classes. The classification is the consequence of several equi-expressivity results with a clear interpretation. In particular, we show that acceptance by halting configuration only has non-trivial expressive power if it is combined with counting, and that synchronous and interleaving models have the same power as those in which an arbitrary set of nodes can move at the same time. We also identify simple graph properties that distinguish the expressive power of the seven classes.", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Flatness and complexity of immediate observation Petri nets\n", "abstract": " In a previous paper we introduced immediate observation (IO) Petri nets, a class of interest in the study of population protocols and enzymatic chemical networks. In the first part of this paper we show that IO nets are globally flat, and so their safety properties can be checked by efficient symbolic model checking tools using acceleration techniques, like FAST. In the second part we study Branching IO nets (BIO nets), whose transitions can create tokens. BIO nets extend both IO nets and communication-free nets, also called BPP nets, a widely studied class. We show that, while BIO nets are no longer globally flat, and their sets of reachable markings may be non-semilinear, they are still locally flat. As a consequence, the coverability and reachability problem for BIO nets, and even a certain set-parameterized version of them, are in PSPACE. This makes BIO nets the first natural net class with non-semilinear reachability relation for which the reachability problem is provably simpler than for general Petri nets.", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Computing the expected execution time of probabilistic workflow nets\n", "abstract": " Free-Choice Workflow Petri nets, also known as Workflow Graphs, are a popular model in Business Process Modeling. In this paper we introduce Timed Probabilistic Workflow Nets (TPWNs), and give them a Markov Decision Process (MDP) semantics. Since the time needed to execute two parallel tasks is the maximum of the times, and not their sum, the expected time cannot be directly computed using the theory of MDPs with rewards. In our first contribution, we overcome this obstacle with the help of \"earliest-first\" schedulers, and give a single exponential-time algorithm for computing the expected time. In our second contribution, we show that computing the expected time is #P-hard, and so polynomial algorithms are very unlikely to exist. Further, #P-hardness holds even for workflows with a very simple structure in which all transitions times are 1 or 0, and all probabilities are 1 or 0.5. Our third and final contribution is an experimental investigation of the runtime of our algorithm on a set of industrial benchmarks. Despite the negative theoretical results, the results are very encouraging. In particular, the expected time of every workflow in a popular benchmark suite with 642 workflow nets can be computed in milliseconds.", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Advances in Parameterized Verification of Population Protocols\n", "abstract": " Population protocols (Angluin et al. PODC, 2004) are a formal model of sensor networks consisting of identical mobile devices. Two devices can interact and thereby change their states. Computations are infinite sequences of interactions satisfying a strong fairness constraint.               A population protocol is well specified if for every initial configuration C of devices, and every computation starting at C, all devices eventually agree on a consensus value depending only on C. If a protocol is well specified, then it is said to compute the predicate that assigns to each initial configuration its consensus value.               While the computational power of well-specified protocols has been extensively studied, much less is known about how to verify their correctness: Given a population protocol, is it well specified? Given a population protocol and a predicate, does the protocol compute the predicate? Given a well\u00a0\u2026", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Finite and algorithmic model theory\n", "abstract": " Intended for researchers and graduate students in theoretical computer science and mathematical logic, this volume contains accessible surveys by leading researchers from areas of current work in logical aspects of computer science, where both finite and infinite model-theoretic methods play an important role. Notably, the articles in this collection emphasize points of contact and connections between finite and infinite model theory in computer science that may suggest new directions for interaction. Among the topics discussed are: algorithmic model theory, descriptive complexity theory, finite model theory, finite variable logic, model checking, model theory for restricted classes of finite structures, and spatial databases. The chapters all include extensive bibliographies facilitating deeper exploration of the literature and further research.", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Solving Monotone Polynomial Equations\n", "abstract": " We survey some recent results on iterative methods for approximating the least solution of a system of monotone fixed-point polynomial equations.", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Modeling and Verification for Timing Satisfaction of Fault-Tolerant Systems with Finiteness\n", "abstract": " The increasing use of model-based tools enables further use of formal verification techniques in the context of distributed real-time systems. To avoid state explosion, it is necessary to construct verification models that focus on the aspects under consideration.In this paper, we discuss how we construct a verification model for timing analysis in distributed real-time systems.We (1) give observations concerning restrictions of timed automata to model these systems,(2) formulate mathematical representations on how to perform model-to-model transformation to derive verification models from system models, and (3) propose some theoretical criteria how to reduce the model size. The latter is in particular important, as for the verification of complex systems, an efficient model reflecting the properties of the system under consideration is equally important to the verification algorithm itself.Finally, we present an extension of\u00a0\u2026", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Model Checking\n", "abstract": " Model Checking Page 1 Model Checking Javier Esparza and Stephan Merz Lab. for Foundations of Computer Science, University of Edinburgh Institut fur Informatik, Universitat Munchen Page 2 Program 9:00\u201310:00 Basics A bit of history A case study: the Needham-Schroeder protocol Linear and branching time temporal logics 10:00\u201310:30 Model-checking LTL I The automata-theoretic approach 10:30\u201311:00 Coffee Break 11:00\u201311:30 Model-checking LTL II On-the-fly model checking Partial-order techniques 11:30\u201312:30 Model-checking CTL Basic algorithms Binary Decision Diagrams 12:30\u201314:00 Lunch 14:00\u201315:30 Abstraction Basics Predicate Abstraction 15:30\u201316:00 Coffee Break 16:00\u201317:30 Infinite state spaces Sources of infinity Symbolic search Accelerations and widenings 2 Page 3 Basics A bit of history A case study: the Needham-Schroeder protocol Linear and branching time temporal logics 3 Page 4 \u2026", "num_citations": "2\n", "authors": ["1874"]}
{"title": "DIAGNOSIS OF HUMAN EPENDYMOMAS: COMPUTER-ASSISTED DECISION-MAKING WITH THE BAYESIAN TOOL\" MEDES\"\n", "abstract": " Diagnostic decision-making in pathology involves gathering observational evidence and using it to reason and to decide which out of a number of possible diagnoses is most likely. In many areas of Pathology, a rich body of objective morphological numerical information exists. However, pathologists cannot make optimal use of this information, because, like all humans, they are not good at handling large amounts of numerical data. MEDES (Medical Decision Shell), a tool developed by the authors, has been used to develop a decision-making model for histological and clinical diagnosis of human ependymomas. 268 human ependymomas collected in our laboratory of neuropathology were studied. 176 ependymomas were used as training test: 79 typical ependymomas, WHO-Grade II), 34 subependymomas, 22 myxopapillary ependymomas, and 41 anaplastic ependymomas. The frequencies of location, age and\u00a0\u2026", "num_citations": "2\n", "authors": ["1874"]}
{"title": "On the mechanized verification of infinite systems\n", "abstract": " Observation equivalence is a well-known technique for proving that a concurrent system satisfies its specification. We report on our experience in the mechanization of observation equivalence proofs with the help of a general-purpose theorem prover. Several case-studies are considered, including a sliding window and a cache-coherence protocol. In all cases the system has an infinite number of states, and sometimes also an arbitrarily large number of components. We show how compositionality and bisimulation-up-to techniques can be applied to reduce the size of the proofs.", "num_citations": "2\n", "authors": ["1874"]}
{"title": "Finding Cut-Offs in Leaderless Rendez-Vous Protocols is Easy.\n", "abstract": " In rendez-vous protocols an arbitrarily large number of indistinguishable finite-state agents interact in pairs. The cut-off problem asks if there exists a number B such that all initial configurations of the protocol with at least B agents in a given initial state can reach a final configuration with all agents in a given final state. In a recent paper [17], Horn and Sangnier prove that the cut-off problem is equivalent to the Petri net reachability problem for protocols with a leader, and in EXPSPACE for leaderless protocols. Further, for the special class of symmetric protocols they reduce these bounds to PSPACE and NP, respectively. The problem of lowering these upper bounds or finding matching lower bounds is left open. We show that the cut-off problem is P-complete for leaderless protocols, NP-complete for symmetric protocols with a leader, and in NC for leaderless symmetric protocols, thereby solving all the problems left open in [17].", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Peregrine 2.0: Explaining Correctness of Population Protocols Through Stage Graphs\n", "abstract": " We present a new version of Peregrine, the tool for the analysis and parameterized verification of population protocols introduced in [Blondin et al., CAV\u20192018]. Population protocols are a model of computation, intensely studied by the distributed computing community, in which mobile anonymous agents interact stochastically to perform a task. Peregrine 2.0 features a novel verification engine based on the construction of stage graphs. Stage graphs are proof certificates, introduced in [Blondin et al., CAV\u20192020], that are typically succinct and can be independently checked. Moreover, unlike the techniques of Peregrine 1.0, the stage graph methodology can verify protocols whose executions never terminate, a class including recent fast majority protocols. Peregrine 2.0 also features a novel proof visualization component that allows the user to interactively explore the stage graph generated for a given protocol.", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Computing the concurrency threshold of sound free-choice workflow nets\n", "abstract": " Workflow graphs extend classical flow charts with concurrent fork and join nodes. They constitute the core of business processing languages such as BPMN or UML Activity Diagrams. The activities of a workflow graph are executed by humans or machines, generically called resources. If concurrent activities cannot be executed in parallel by lack of resources, the time needed to execute the workflow increases. We study the problem of computing the minimal number of resources necessary to fully exploit the concurrency of a given workflow, and execute it as fast as possible (i.e., as fast as with unlimited resources).                 We model this problem using free-choice Petri nets, which are known to be equivalent to workflow graphs. We analyze the computational complexity of two versions of the problem: computing the resource and concurrency thresholds. We use the results to design an algorithm to\u00a0\u2026", "num_citations": "1\n", "authors": ["1874"]}
{"title": "A brief history of Strahler numbers\u2014with a preface\n", "abstract": " The Strahler number or Horton-Strahler number of a tree, originally introduced in geophysics, has a surprisingly rich theory. We sketch some milestones in its history, and its connection to arithmetic expressions, graph traversing, decision problems for context-free languages, Parikh\u2019s theorem, and Newton\u2019s procedure for approximating zeros of differentiable functions.", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Negotiation games\n", "abstract": " Negotiations, a model of concurrency with multi party negotiation as primitive, have been recently introduced in [5, 6]. We initiate the study of games for this model. We study coalition problems: can a given coalition of agents force that a negotiation terminates (resp. block the negotiation so that it goes on forever)?; can the coalition force a given outcome of the negotiation? We show that for arbitrary negotiations the problems are EXPTIME-complete. Then we show that for sound and deterministic or even weakly deterministic negotiations the problems can be solved in PTIME. Notice that the input of the problems is a negotiation, which can be exponentially more compact than its state space.", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Message-Passing Algorithms for the Verification of Distributed Protocols\n", "abstract": " Message-passing algorithms (MPAs) are an algorithmic paradigm for the following generic problem: given a system consisting of several interacting components, compute a new version of each component representing its behaviour inside the system. MPAs avoid computing the full state space by propagating messages along the edges of the system interaction graph. We present an MPA for verifying local properties of distributed protocols with a tree communication structure. We report on an implementation, and validate it by means of two case studies, including an analysis of the PGM protocol.", "num_citations": "1\n", "authors": ["1874"]}
{"title": "On least fixed points of systems of positive polynomials\n", "abstract": " SPrPs are important in different areas of the theory of stochastic processes and computational models. A fundamental result of the theory of branching processes, with numerous applications in physics and biology (see eg [6, 1]), states that extinction probabilities of species are equal to the least solution of a SPrP. The same result has been recently shown for the probability of termination of certain probabilistic recursive programs ([5, 4]). The consistency of stochastic context-free grammars, a problem of interest in statistical natural language processing, also reduces to checking whether the least solution of a SPrP equals 1 (see eg [8]). We fix an SPrP with function f and denote its least solution by \u00b5f. The following two problems are motivated by the applications above:(1) decide whether \u00b5f= 1, and (2) given \u03f5> 0 compute lb, ub such that lb\u2264 \u00b5f\u2264 ub and ub\u2212 lb\u2264 \u03f5.Etessami and Yannakakis show in [5] that Problem (1\u00a0\u2026", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Model Checking LTL\n", "abstract": " In this chapter we present the main result of this work, a search procedure for model checking products of transition systems against specifications written in Linear Temporal Logic (LTL). 1 The chapter is divided in several sections. In Sects. 8.1 and 8.2 we recall the syntax and semantics of LTL, show how to interpret LTL on products, and define the model checking problem. In Sect. 8.3 we introduce the concept of B\u00fcchi tester for an LTL property. Loosely speaking, a tester of a product is a new component added to the product in order to observe and register the occurrences of (some) global transitions. A tester may \u201crecognize\u201d a history of the product based on the occurrences it has observed. The tester for an LTL property is designed to recognize the histories that violate the property. We show that every LTL property has a B\u00fcchi tester.Section 8.4 presents a first approach to the model checking problem, in which the\u00a0\u2026", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Building a software model checker\n", "abstract": " In this paper we introduce jMoped, a tool for the analysis of Java programs based on model-checking techniques. We then proceed to introduce and explain the theory underlying the tool, and how it shaped some design choices.", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Deterministic Context-Free Model Checking\n", "abstract": " Regular Model-Checking (RMC) is a technique for the formal verification of infinite state systems based on the theory of regular languages. In the paper \u201cBeyond Regular Model Checking\u201d Fisman and Pnueli have shown that RMC can be extended to languages accepted by cascade products of single-state deterministic pushdown automata and finite automata. In this paper we further extend RMC to arbitrary deterministic context-free languages. For this purpose, and inspired by recent results of Caucal, we introduce height-deterministic pushdown automata and show that they satisfy adequate closure properties.", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Automatic verification with unfolding\n", "abstract": " CiNii \u8ad6\u6587 - Automatic verification with unfolding CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3 ] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9\u306e\u518d\u958b \u306b\u3064\u3044\u3066 Automatic verification with unfolding ESPARZA J. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 ESPARZA J. \u53ce\u9332\u520a\u884c\u7269 Tutorial Lecture, Int.Conf.on Application of Concurrency to System Design, Aizu-Wakamatsu Tutorial Lecture, Int.Conf.on Application of Concurrency to System Design, Aizu-Wakamatsu, 1998 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u96e2\u6563\u4e8b\u8c61\u30b7\u30b9\u30c6\u30e0\u7406\u8ad6 : \u6765\u3057\u65b9\u3068\u73fe\u5728 (\u96e2\u6563\u4e8b\u8c61\u30b7\u30b9\u30c6\u30e0 \u7406\u8ad6\u306e\u65b0\u305f\u306a\u5c55\u958b\u7279\u96c6\u53f7) \u5150\u7389 \u614e\u4e09 , \u6f6e \u4fca\u5149 \u30b7\u30b9\u30c6\u30e0\uff0f\u5236\u5fa1\uff0f\u60c5\u5831 42(8), 415-420, 1998 \u53c2\u8003\u6587\u732e43\u4ef6 \u88ab\u5f15\u7528\u6587\u732e4\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10004327476 \u8cc7\u6599\u7a2e\u5225 \u2026", "num_citations": "1\n", "authors": ["1874"]}
{"title": "The asynchronous committee meeting problem\n", "abstract": " The committee meeting problem consists in finding the earliest meeting time acceptable to every member of a committee. We consider an asynchronous version of the problem that does not presuppose the existence of a global clock, where meeting times are maximal antichains in a poset of \u2018local times\u2019, and propose an efficient algorithm to solve it. A generalization, the private meeting problem, where the earliest time for a meeting without some committee members is sought, turns out to be NP-complete. However, it can be solved in polynomial time if the poset is N-free, that is, representing a precedence of the arcs (and not the nodes) of an acyclic directed graph. This special case is relevant, because it allows to improve the key algorithm of the model checking technique developed in [4] for Petri nets.", "num_citations": "1\n", "authors": ["1874"]}
{"title": "Traps, Free Choice and Home States\n", "abstract": " The free choice Petri net shown in Figure 1 has a live and bounded (even safe) marking which is not a home state; from any other reachable marking, it is impossible to reach the initial marking again. The net also has an unmarked trap (s               o, s               2, s               3, s                                s               , s               6), that is, a set of places with the property that every output transition of the set is also an input transition of the set.", "num_citations": "1\n", "authors": ["1874"]}