{"title": "Mining software history to improve software maintenance quality: A case study\n", "abstract": " Errors in software updates can cause regressions failures in stable parts of the system. The Binary Change Tracer collects data on software projects and helps predict regressions in software projects.", "num_citations": "29\n", "authors": ["726"]}
{"title": "Using statistical models to predict software regressions\n", "abstract": " Incorrect changes made to the stable parts of a software system can cause failures - software regressions. Early detection of faulty code changes can be beneficial for the quality of a software system when these errors can be fixed before the system is released. In this paper, a statistical model for predicting software regressions is proposed. The model predicts risk of regression for a code change by using software metrics: type and size of the change, number of affected components, dependency metrics, developerpsilas experience and code metrics of the affected components. Prediction results could be used to prioritize testing of changes: the higher is the risk of regression for the change, the more thorough testing it should receive.", "num_citations": "14\n", "authors": ["726"]}
{"title": "Automated analysis of multithreaded programs for performance modeling\n", "abstract": " The behavior of multithreaded programs is often difficult to understand and predict. Synchronization operations and limited computational resources combine to produce complex non-linear dependencies between a program's configuration parameters and its performance. Performance models are used to understand these dependencies. Such models are complex, and constructing them requires a solid understanding of the program's behavior. As a result, building models of complex applications manually is extremely time-consuming and error-prone. In this paper we demonstrate that such models can be built automatically.", "num_citations": "8\n", "authors": ["726"]}
{"title": "What is my program doing? Program dynamics in programmer\u2019s terms\n", "abstract": " Programmers need to understand their systems. They need to understand how their systems work and why they fail; why they perform well or poorly, and when the systems are behaving abnormally. Much of this involves understanding the dynamic behavior of complex software systems. These systems can involve multiple processes and threads, thousands of classes, and millions of lines of code. These systems are designed to run continuously, often running for months at a time. We consider the problem of using dynamic analysis and visualization to help programmers achieve the necessary understanding. To be effective this needs to be done on running applications with minimal overhead and in the high-level terms programmers use to think about their system. After going over past efforts in this area we look at our current work and then present a number of challenges for the future.", "num_citations": "7\n", "authors": ["726"]}
{"title": "Using computer simulation to predict the performance of multithreaded programs\n", "abstract": " Predicting the performance of a computer program facilitates its efficient design, deployment, and problem detection. However, predicting performance of multithreaded programs is complicated by complex locking behavior and concurrent usage of computational resources. Existing performance models either require running the program in many different configurations or impose restrictions on the types of programs that can be modeled. This paper presents our approach towards building performance models that do not require vast amounts of training data. Our models are built using a combination of queuing networks and probabilistic call graphs. All necessary information is collected using static and dynamic analyses of a single run of the program. In our experiments these models were able to accurately predict performance of different types of multithreaded programs and detected those configurations that\u00a0\u2026", "num_citations": "6\n", "authors": ["726"]}
{"title": "Tool demonstration: The visualizations of code bubbles\n", "abstract": " Code Bubbles is an integrated development environment that concentrates on the user experience. The environment is very visual and includes a number of different visualizations, both static and dynamic. We will demonstrate the environment and the various visualizations on a realistic scenario based on our current work.", "num_citations": "5\n", "authors": ["726"]}
{"title": "Automatic categorization and visualization of lock behavior\n", "abstract": " We consider the problem of understanding locking behavior in large Java programs using a combination of data collection, data analysis, and visualization. Our technique starts by collecting partial information about all locks used in the program. It then analyzes this information to determine sets of locks with common behaviors and to determine, for each set of locks, how that lock is used, e.g. if it is used as a mutex, semaphore, read-write lock, etc. The result of the analysis is then presented to the user who can select specific locks for full analysis during a subsequent run. Visualizing locking information is particularly difficult since the time scale of a lock can be ten or more orders of magnitude different from the time scale of the overall run and locks can be used millions of times. We provide different visualizations and visualization techniques for this purpose. First, we analyze either the partial or full traces and identify\u00a0\u2026", "num_citations": "4\n", "authors": ["726"]}
{"title": "Automatic performance prediction of multithreaded programs: a simulation approach\n", "abstract": " The performance of multithreaded programs is often difficult to understand and predict. Multiple threads engage in synchronization operations and use hardware simultaneously. This results in a complex non-linear dependency between the configuration of a program and its performance. To better understand this dependency a performance prediction model is used. Such a model predicts the performance of a system for different configurations. Configurations reflect variations in the workload, different program options such as the number of threads, and characteristics of the hardware. Performance models are complex and require a solid understanding of the program\u2019s behavior. As a result, building models of large applications manually is extremely time-consuming and error-prone. In this paper we present an approach for building performance models of multithreaded programs automatically. We employ\u00a0\u2026", "num_citations": "3\n", "authors": ["726"]}