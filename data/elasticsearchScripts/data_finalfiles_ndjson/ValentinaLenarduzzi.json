{"title": "Microservices Anti Patterns: A Taxonomy\n", "abstract": " Several companies are rearchitecting their monolithic information systems with microservices. However, many companies migrate to microservices without experience, mainly learning how to migrate from books or from practitioners\u2019 blogs. Because of the novelty of the topic, practitioners and consultancies are learning by doing how to migrate, thus facing several issues but also several benefits. In this chapter, we introduce a catalog and a taxonomy of the most common microservices anti-patterns in order to identify common problems. Our anti-pattern catalog is based on the experience summarized by different practitioners we interviewed in the last 3 years. We identified a taxonomy of 20 anti-patterns, including organizational (team oriented and technology/tool oriented) anti-patterns and technical (internal and communication) anti-patterns. The results can be useful to practitioners to avoid experiencing the same\u00a0\u2026", "num_citations": "44\n", "authors": ["988"]}
{"title": "A continuous software quality monitoring approach for small and medium enterprises\n", "abstract": " Context: SMEs cannot always afford the effort required for software quality assurance, and therefore there is the need of easy and affordable practices to prevent issues in the software they develop.Object: In this paper we propose an approach to allow SMEs to access SQA practices, using an SQA approach based on a continuous issue and error monitoring and a recommendation system that will suggest quality practices, recommending a set of quality actions based on the issues that previously created errors, so as to help SMEs to maintain quality above a minimum threshold. Method: First, we aim to identify a set of SQA practices applicable in SMEs, based on the main constraints of SMEs and a set of tools and practices to fulfill a complete DevOps pipeline. Second, we aim to define a recommendation system to provide software quality feedback to micro-teams, suggesting which action (s) they should take to\u00a0\u2026", "num_citations": "27\n", "authors": ["988"]}
{"title": "Serverless Testing: Tool Vendors\u2019 and Experts\u2019 Point of View\n", "abstract": " Testing serverless applications plays an important role in software quality assurance. The current status of testing and debugging in serverless-based applications depicted by the experts helped us highlight issues and challenges that need to be deeply investigated.", "num_citations": "11\n", "authors": ["988"]}
{"title": "Towards a Holistic Definition of Requirements Debt\n", "abstract": " When not appropriately managed, technical debt is considered to have negative effects to the long term success of software projects. However, how the debt metaphor applies to requirements engineering in general, and to requirements engineering activities in particular, is not well understood. Grounded in the existing literature, we present a holistic definition of requirements debt which includes debt incurred during the identification, formalization, and implementation of requirements. We outline future assessment to validate and further refine our proposed definition. This conceptualization is a first step towards a requirements debt monitoring framework to support stakeholders decisions, such as when to incur and eventually pay back requirements debt, and at what costs.", "num_citations": "10\n", "authors": ["988"]}
{"title": "Why Do Developers Adopt Open Source Software? Past, Present and Future\n", "abstract": " Free/Libre Open Source Software has evolved dramatically in the last twenty years and many open source products are now considered similar, or even better than proprietary counterparts. Given the evolution of software \u2013 both concerning its development and its usage \u2013 it is likely that the motivations for adopting an open source rather than a proprietary product have changed over time. The goal of this work is to identify the current motivations for adopting open source software, and compare them with the motivations that held in the past. We conducted a set of interviews among software practitioners, asking them to rank motivations for the adoption of open source software, and we compared these new results with the motivations elicited in previous surveys published in 2010 and 2013. The results show that motivations have actually changed over time.", "num_citations": "10\n", "authors": ["988"]}
{"title": "On the negative impact of team independence in microservices software development\n", "abstract": " Microservices allow teams to work in isolation, and reduce the need of communication among the teams. While this aspect could be considered a short-term benefit due to the reduction of the communication effort, the reduced amount of communication could create issues in the general synchronization of the whole project. In this work we start to depict the potential negative impact of the reduced need of communication in the development of microservices-based systems. We propose the design of an empirical study to understand if this reduction is beneficial, and when and how communication between teams should be enforced.", "num_citations": "10\n", "authors": ["988"]}
{"title": "Could social factors influence the effort software estimation?\n", "abstract": " Effort estimation is often influenced by several factors, including social. This study aims at understanding the interactions between social factors and effort during effort estimation. I want to analyze the dynamics that occur when a developer estimates the effort for a specific task and the influence of the work team and the work conditions. I conducted a semi-structured interview among three different projects with different developers working in Agile and Scrum processes, asking them which factors and social aspects they take in to account when they estimate the effort during the development processes. Results show an important influence of social factors during the effort estimation phase, and call for future works for a large scale Survey for a more accurate identification.", "num_citations": "9\n", "authors": ["988"]}
{"title": "Can Functional Size Measures Improve Effort Estimation in SCRUM\n", "abstract": " In SCRUM projects, effort estimations are carried out at the beginning of each sprint, usually based on story points. The usage of functional size measures, specifically selected for the type of application and development conditions, is expected to allow for more accurate effort estimates. The goal of the work presented here is to verify this hypothesis, based on experimental data. The association of story measures to actual effort and the accuracy of the resulting effort model was evaluated. The study shows that developers\u2019 estimation is more accurate than those based on functional measurement. In conclusion, our study shows that, easy to collect functional measures do not help developers in improving the accuracy of the effort estimation in Moonlight SCRUM.", "num_citations": "7\n", "authors": ["988"]}
{"title": "Software Quality for AI: Where Are We Now?\n", "abstract": " Artificial Intelligence is getting more and more popular, being adopted in a large number of applications and technology we use on a daily basis. However, a large number of Artificial Intelligence applications are produced by developers without proper training on software quality practices or processes, and in general, lack in-depth knowledge regarding software engineering processes. The main reason is due to the fact that the machine-learning engineer profession has been born very recently, and currently there is a very limited number of training or guidelines on issues (such as code quality or testing) for machine learning and applications using machine learning code. In this work, we aim at highlighting the main software quality issues of Artificial Intelligence systems, with a central focus on machine learning code, based on the experience of our four research groups. Moreover, we aim at defining a\u00a0\u2026", "num_citations": "6\n", "authors": ["988"]}
{"title": "How the Cathedral Embraced the Bazaar, and the Bazaar Became a Cathedral\n", "abstract": " Over the past 20 years, open source has become a widely adopted approach to develop software. Code repositories provide software to power cars, phones, and other things that are considered proprietary. In parallel, proprietary development has evolved from rigid, centralized waterfall approaches to agile, iterative development. In this paper, we share our experiences regarding this co-evolution of open and closed source from the viewpoints of tools, practices, and organizing the development work, concluding that today\u2019s bazaars and cathedrals have much more common characteristics than those that separate them.", "num_citations": "4\n", "authors": ["988"]}
{"title": "Does Code Quality Affect Pull Request Acceptance? An empirical study\n", "abstract": " Background. Pull requests are a common practice for contributing and reviewing contributions, and are employed both in open-source and industrial contexts. One of the main goals of code reviews is to find defects in the code, allowing project maintainers to easily integrate external contributions into a project and discuss the code contributions. Objective. The goal of this paper is to understand whether code quality is actually considered when pull requests are accepted. Specifically, we aim at understanding whether code quality issues such as code smells, antipatterns, and coding style violations in the pull request code affect the chance of its acceptance when reviewed by a maintainer of the project. Method. We conducted a case study among 28 Java open-source projects, analyzing the presence of 4.7 M code quality issues in 36 K pull requests. We analyzed further correlations by applying Logistic Regression and seven machine learning techniques (Decision Tree, Random Forest, Extremely Randomized Trees, AdaBoost, Gradient Boosting, XGBoost). Results. Unexpectedly, code quality turned out not to affect the acceptance of a pull request at all. As suggested by other works, other factors such as the reputation of the maintainer and the importance of the feature delivered might be more important than code quality in terms of pull request acceptance. Conclusions. Researchers already investigated the influence of the developers' reputation and the pull request acceptance. This is the first work investigating if quality of the code in pull requests affects the acceptance of the pull request or not. We recommend that researchers further investigate\u00a0\u2026", "num_citations": "3\n", "authors": ["988"]}
{"title": "Software Components Selection in Microservices-based Systems\n", "abstract": " Software is commonly developed integrating custom-developed code with existing components. Companies commonly develop only a small percentage of the whole system under development.", "num_citations": "3\n", "authors": ["988"]}
{"title": "Towards a marketing strategy for open source software\n", "abstract": " Open Source Software (OSS) communities do not often invest in marketing strategies to promote their products in a competitive way. The web pages of OSS products are the main communication channel with potential users and they should act as a product's shopping window. However, even the home pages of well-known OSS products show technicalities and details that are not relevant the vast majority of users. So, final users and even developers, who are interested in evaluating and potentially adopting an OSS product, are often negatively impressed by the web portal of the product and turn to proprietary software solutions or fail to adopt OSS that may be useful in their activities.", "num_citations": "3\n", "authors": ["988"]}
{"title": "The Lean Strategies: A tale of user-driven innovation processes\n", "abstract": " Since 1978 several Lean Strategies have been defined and nowadays companies are increasing the adoption of them. However, there are still several practitioners that face some issues in understanding which practice is most suitable for their context and how to apply the practice in the correct way.", "num_citations": "2\n", "authors": ["988"]}
{"title": "Fault Prediction based on Software Metrics and SonarQube Rules. Machine or Deep Learning?\n", "abstract": " Background. Developers spend more time fixing bugs and refactoring the code to increase the maintainability than developing new features. Researchers investigated the code quality impact on fault-proneness focusing on code smells and code metrics. Objective. We aim at advancing fault-inducing commit prediction based on SonarQube considering the contribution provided by each rule and metric. Method. We designed and conducted a case study among 33 Java projects analyzed with SonarQube and SZZ to identify fault-inducing and fault-fixing commits. Moreover, we investigated fault-proneness of each SonarQube rule and metric using Machine and Deep Learning models. Results. We analyzed 77,932 commits that contain 40,890 faults and infected by more than 174 SonarQube rules violated 1,9M times, on which there was calculated 24 software metrics available by the tool. Compared to machine learning models, deep learning provide a more accurate fault detection accuracy and allowed us to accurately identify the fault-prediction power of each SonarQube rule. As a result, fourteen of the 174 violated rules has an importance higher than 1\\% and account for 30\\% of the total fault-proneness importance, while the fault proneness of the remaining 165 rules is negligible. Conclusion. Future works might consider the adoption of timeseries analysis and anomaly detection techniques to better and more accurately detect the rules that impact fault-proneness.", "num_citations": "1\n", "authors": ["988"]}
{"title": "Towards an Approach to Identify Obsolete Features based on Importance and Technical Debt\n", "abstract": " Many of today\u2019s software systems are maintained over years or even decades. To ensure that software remains useful, new features have to be added or old features have to be adapted to respond to new or changed requirements. As time goes on, some of the features become obsolete, i.e., are not needed anymore. Typically, these features are not removed because of various reasons, e.g., because removing them might be considered too costly, the costs of keeping unused features is considered low, or because of the \"sunk cost fallacy\", i.e., that a feature is considered worth to keep because of the previously invested resources (time, money or effort) to build it. The consequences of keeping unused source code can impact maintainability, technical debt, performance, and extensibility of the system. This can lead to lower development productivity and to a reduced innovation ability, consequently reducing\u00a0\u2026", "num_citations": "1\n", "authors": ["988"]}
{"title": "On the Perceived Harmfulness of Requirement Smells: An Empirical Study\n", "abstract": " Technical debt is considered to have negative effects to the long term success of software projects. However, how the debt metaphor applies to requirements engineering is yet not significantly explored. Previously, we proposed a framework to identify Requirements Debt (ReD) in three stages of the software development lifecycle. One of these stages is the formalization of stakeholder needs into natural language requirement specifications. In this work, we propose a live study aiming at surveying requirements engineering experts to gain further insights on the issues taking place at this stage and how they fit in our definition of ReD.", "num_citations": "1\n", "authors": ["988"]}
{"title": "Are Code smells the root cause of faults? A continuous experimentation approach\n", "abstract": " Code Smells are quite a good instrument to evaluate code's quality, even if they provide a general analysis: no one can assure that determined code smells are really responsible for faults. More and more software companies pay attention to produce qualitative software, in order to reduce the number of bugs. But how can they know, which code-refactoring really can decrease the faults' number? In this work, we aim to find out which code smells are really the cause of bugs and, through a continuous monitoring system, continuously propose companies code refactoring, with the aim of reduce drastically the number of bugs.", "num_citations": "1\n", "authors": ["988"]}