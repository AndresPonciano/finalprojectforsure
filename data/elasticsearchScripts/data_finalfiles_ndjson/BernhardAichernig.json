{"title": "Test case generation by OCL mutation and constraint solving\n", "abstract": " Fault-based testing is a technique where testers anticipate errors in a system under test in order to assess or generate test cases. The idea is to have enough test cases capable of detecting these anticipated errors. This paper presents a method of fault-based test case generation for pre- and postcondition specifications. Here, errors are anticipated on the specification level by mutating the pre- and postconditions. We present the underlying theory by giving test cases a formal semantics and translate this general testing theory to a constraint satisfaction problem. A prototype test case generator serves to demonstrate the automatization of the method. The current tool works with OCL specifications, but the theory and method are general and apply to many state-based specification languages.", "num_citations": "102\n", "authors": ["2024"]}
{"title": "Killing strategies for model\u2010based mutation testing\n", "abstract": " This article presents the techniques and results of a novel model\u2010based test case generation approach that automatically derives test cases from UML state machines. The main contribution of this article is the fully automated fault\u2010based test case generation technique together with two empirical case studies derived from industrial use cases. Also, an in\u2010depth evaluation of different fault\u2010based test case generation strategies on each of the case studies is given and a comparison with plain random testing is conducted. The test case generation methodology supports a wide range of UML constructs and is grounded on the formal semantics of Back's action systems and the well\u2010known input\u2013output conformance relation. Mutation operators are employed on the level of the specification to insert faults and generate test cases that will reveal the faults inserted. The effectiveness of this approach is shown and it is\u00a0\u2026", "num_citations": "80\n", "authors": ["2024"]}
{"title": "Momut:: UML model-based mutation testing for UML\n", "abstract": " Model-based mutation testing (MBMT) is a promising testing methodology that relies on a model of the system under test (SUT) to create test cases. Hence, MBMT is a so-called black-box testing approach. It also is fault based, as it creates test cases that are guaranteed to reveal certain faults: after inserting a fault into the model of the SUT, it looks for a test case revealing this fault. This turns MBMT into one of the most powerful and versatile test case generation approaches available as its tests are able to demonstrate the absence of certain faults, can achieve both, control-flow and data-flow coverage of model elements, and also may include information about the behaviour in the failure case. The latter becomes handy whenever the test execution framework is bound in the number of observations it can make and - as a consequence - has to restrict them. However, this versatility comes at a price: MBMT is\u00a0\u2026", "num_citations": "70\n", "authors": ["2024"]}
{"title": "Survey on test data generation tools\n", "abstract": " Automating the process of software testing is a very popular research topic and of real interest to industry. Test automation can take part on different levels, e.g., test execution, test case generation, test data generation. This survey gives an overview of state-of-the art test data generation tools, either academic or commercial. The survey focuses on white- and gray-box techniques. The list of existing tools was filtered with respect to their public availability, their maturity, and activity. The remaining seven tools, i.e., AgitarOne, CodePro AnalytiX, AutoTest, C++test, Jtest, RANDOOP, and PEX, are briefly introduced and their evaluation results are summarized. For the evaluation we defined 31 benchmark tests, which check the tools capabilities to generate test data that satisfies a given specification: 24 primitive type benchmarks and 7 non-primitive type and more complex with respect to the specification\u00a0\u2026", "num_citations": "53\n", "authors": ["2024"]}
{"title": "A proof obligation generator for VDM-SL\n", "abstract": " In this paper an extension of the IFAD VDM-SL Toolbox with a proof obligation generator is described. Static type checking in VDM is undecidable in general and therefore the type checker must be incomplete. Hence, for the \u201cdifficult\u201d parts introducing undecidability, it is up to the user to verify the consistency of a specification. Instead of providing error messages and warnings, the approach of generating proof obligations for the consistency of VDM-SL specifications is taken. The overall goal of this work is to automate the generation of proof obligations for VDM-SL. Proof obligation generation has already been carried out for a number of related notations, but VDM-SL contains a number of challenging constructs (e.g. patterns, non-disjoint union types, and operations) for which new research is presented in this paper.", "num_citations": "51\n", "authors": ["2024"]}
{"title": "Mutation testing in the refinement calculus\n", "abstract": " This article discusses mutation testing strategies in the context of refinement. Here, a novel generalisation of mutation testing techniques is presented to be applied to contracts ranging from formal specifications to programs. It is demonstrated that refinement and its dual abstraction are the key notions leading to a precise and yet simple theory of mutation testing. The refinement calculus of Back and von Wright is used to express concepts like contracts, useful mutations, test cases and test coverage.", "num_citations": "49\n", "authors": ["2024"]}
{"title": "Model-based mutation testing of an industrial measurement device\n", "abstract": " MoMuT::UML is a model-based mutation testing tool for UML models. It maps UML state machines to a formal semantics and performs a conformance check between an original and a set of mutated models to automatically generate test cases. The resulting test suite is able to detect whether a system under test implements one of the faulty models instead of the correct, original model. In this work, we illustrate the whole model-based mutation testing process by means of an industrial case study. We test the control logic of a device that counts the particles in exhaust gases. First, we model the system under test in UML. Then, MoMuT::UML is used to automatically generate three test suites from the UML test model: one mutation-based test suite, one set of random test cases, and a third test suite combining random and mutation-based test case generation. The test cases are executed on the system\u00a0\u2026", "num_citations": "45\n", "authors": ["2024"]}
{"title": "From faults via test purposes to test cases: On the fault-based testing of concurrent systems\n", "abstract": " Fault-based testing is a technique where testers anticipate errors in a system under test in order to assess or generate test cases. The idea is to have enough test cases capable of detecting these anticipated errors. This paper presents a theory and technique for generating fault-based test cases for concurrent systems. The novel idea is to generate test purposes from faults that have been injected into a model of the system under test. Such test purposes form a specification of a more detailed test case that can detect the injected fault. The theory is based on the notion of refinement. The technique is automated using the TGV test case generator and an equivalence checker of the CADP tools. A case study of testing web servers demonstrates the practicability of the approach.", "num_citations": "45\n", "authors": ["2024"]}
{"title": "Automated conformance verification of hybrid systems\n", "abstract": " Due to the combination of discrete events and continuous behavior the validation of hybrid systems is a challenging task. Nevertheless, as for other systems the correctness of such hybrid systems is a major concern. In this paper we present a new approach for verifying the input-output conformance of two hybrid systems. This approach can be used to generate mutation-based test cases. We specify a hybrid system within the framework of Qualitative Action Systems. Here, besides conventional discrete actions, the continuous dynamics of hybrid systems is described with so called qualitative actions. This paper then shows how labeled transition systems can be used to describe the trace semantics of Qualitative Action Systems. The labeled transition systems are used to verify the conformance between two Qualitative Action Systems. Finally, we present first experimental results on a water tank system.", "num_citations": "44\n", "authors": ["2024"]}
{"title": "Connectors as designs: Modeling, refinement and test case generation\n", "abstract": " Over the past years, the need for high-confidence coordination mechanisms has intensified as new technologies have appeared for the development of service-oriented applications, making formalization of coordination mechanisms critical. Unifying Theories of Programming (UTP) provide a formal semantic foundation not only for programming languages but also for various expressive specification languages. A key concept in UTP is design: the familiar pre/post-condition pair that describes a contract. In this paper we use UTP to formalize Reo connectors, whereby connectors are interpreted as designs in UTP. This model can be used as a semantic foundation for proving properties of connectors, such as equivalence and refinement relations between connectors. Furthermore, it can be used as a reference document for developing tool support for Reo, such as test case generators. A fault-based method to\u00a0\u2026", "num_citations": "42\n", "authors": ["2024"]}
{"title": "Mutation testing in UTP\n", "abstract": " This paper presents a theory of testing that integrates into Hoare and He\u2019s Unifying Theory of Programming (UTP). We give test cases a denotational semantics by viewing them as specification predicates. This reformulation of test cases allows for relating test cases via refinement to specifications and programs. Having such a refinement order that integrates test cases, we develop a testing theory for fault-based testing.               Fault-based testing uses test data designed to demonstrate the absence of a set of pre-specified faults. A well-known fault-based technique is mutation testing. In mutation testing, first, faults are injected into a program by altering (mutating) its source code. Then, test cases that can detect these errors are designed. The assumption is that other faults will be caught, too. In this paper, we apply the mutation technique to both, specifications and programs.               Using our theory of testing\u00a0\u2026", "num_citations": "42\n", "authors": ["2024"]}
{"title": "Model-based mutation testing of hybrid systems\n", "abstract": " This paper presents a novel model-based testing approach developed in the MOGENTES project. The aim is to test embedded systems controlling a continuous environment, i.e., hybrid systems. We present our two key abstractions against which we systematically test for conformance. (1) Classical action systems are used to model the discrete controller behavior. (2) Qualitative differential equations are used to model the evolutions of the environment. The latter is based on a technique from the domain of Artificial Intelligence called qualitative reasoning. Mutation testing on these models is used to generate effective test cases. A test case generator has been developed that searches for all test cases that would kill a mutant. The mutant models represent our fault models. The generated test cases are then executed on the implementation in order to systematically exclude the possibility that a mutant has\u00a0\u2026", "num_citations": "39\n", "authors": ["2024"]}
{"title": "Validating voice communication requirements using lightweight formal methods\n", "abstract": " To show that lightweight approaches can facilitate the technological transfer of formal development methods, the authors report on their experience using VDM++ to specify a safety-critical air traffic control voice communication system. Their approach raised both the quality of the informal system specification and the efficiency of the system test suites they used.", "num_citations": "39\n", "authors": ["2024"]}
{"title": "UML in action: a two-layered interpretation for testing\n", "abstract": " This paper presents a novel model-based test case generation approach that automatically derives test cases from UML state machines. UML is given a two-layered formal semantics by (1) mapping UML class diagrams and state charts to Back's Action Systems, (2) by interpreting these action systems as labeled transition systems. The first semantics provides a formal framework to capture the object-oriented machinery: classes, objects, inheritance, transitions, time-outs, signals, nested and parallel regions. The second mapping represents the tester's view on the interface in terms of input and output actions. Tretman's input-output conformance relation (ioco) forms the basis of our fault models. Mutation analysis on the models is used to generate test cases. A car alarm system serves as a running example", "num_citations": "38\n", "authors": ["2024"]}
{"title": "Model-based mutation testing via symbolic refinement checking\n", "abstract": " In model-based mutation testing, a test model is mutated for test case generation. The resulting test cases are able to detect whether the faults in the mutated models have been implemented in the system under test. For this purpose, a conformance check between the original and the mutated model is required. The generated counterexamples serve as basis for the test cases. Unfortunately, conformance checking is a hard problem and requires sophisticated verification techniques. Previous attempts using an explicit conformance checker suffered state space explosion. In this paper, we present several optimisations of a symbolic conformance checker using constraint solving techniques. The tool efficiently checks the refinement between non-deterministic test models. Compared to previous implementations, we could reduce our runtimes by 97%. In a new industrial case study, our optimisations can reduce the\u00a0\u2026", "num_citations": "37\n", "authors": ["2024"]}
{"title": "Incremental refinement checking for test case generation\n", "abstract": " We combine model-based testing and mutation testing to automatically generate a test suite that achieves a high mutation adequacy score. The original model representing the system under test is mutated. To generate test cases that detect whether a modelled fault has been implemented, we perform a refinement check between the original and the mutated models. Action systems serve as formal models. They are well-suited to model reactive systems and allow non-determinism. We extend our previous work by two techniques to improve efficiency: (1) a strategy to efficiently handle a large number of mutants and (2) incremental solving. A case study illustrates the potential of our improvements. The runtime for checking appr.\u00a0200 mutants could be reduced from 20s to 3s. We implemented our algorithms in two versions: one uses a constraint solver, the other one an SMT solver. Both show similar performance.", "num_citations": "37\n", "authors": ["2024"]}
{"title": "Test-case calculation through abstraction\n", "abstract": " This paper discusses the calculation of test-cases for interactive systems. A novel approach is presented that treats the problem of test-case synthesis as an abstraction problem. The refinement calculus is used to formulate abstraction rules for calculating correct test-case scenarios from a formal contract. This abstraction calculus results in a synthesis method that, does not need to compute a finite state machine. This is in contrast to previous work on testing from state-based specifications. A well known example from the testing literature serves to demonstrate this unusual application of the refinement calculus in order to synthesize tests rather than implementations.", "num_citations": "36\n", "authors": ["2024"]}
{"title": "Contract-based testing\n", "abstract": " A tester relies on some sort of contract between the users and the implementers of a system. The contract defines the obligations of each part that are partially checked by selecting and executing test-cases. In fact, these test-cases are contracts, too, although in a rather operational form. In this article we define the general relationship between these two forms of contract and present a method how various test-selection strategies can be defined formally. More precisely, we demonstrate how test-cases can be calculated from contracts using a refinement calculus.", "num_citations": "35\n", "authors": ["2024"]}
{"title": "Efficient mutation killers in action\n", "abstract": " This paper presents the techniques and results of a novel model-based test case generation approach that automatically derives test cases from UML state machines. Mutation testing is applied on the modeling level to generate test cases. We present the test case generation approach, discuss the tool chain, and present the properties of the generated test cases. The main contribution of this paper is an empirical study of a car alarm system where different strategies for killing mutants are compared. We present detailed figures on the effectiveness of the test case generation technique. Although UML serves as an input language, all techniques are grounded on solid foundations: we give UML state transition diagrams a formal semantics by mapping them to Back's action systems.", "num_citations": "34\n", "authors": ["2024"]}
{"title": "Mapping UML to labeled transition systems for test-case generation\n", "abstract": " The Unified Modeling Language (UML) is a well known and widely used standard for building software models. While it is familiar to many software engineers, it lacks standardized formal semantics. In this paper, we extend on the formalism of object-oriented action systems (OOAS) and describe a mapping of a selected UML-subset to OOAS by choosing one of the several possible semantics of UML. This mapping, together with the introduction of a trace semantics for OOAS, paves the way for applying tools for and theory of labeled transition systems to UML-models. As a running example, we use a car alarm system in the context of model-based test-case generation and show how the UML mapping is done.", "num_citations": "34\n", "authors": ["2024"]}
{"title": "Conformance testing of distributed concurrent systems with executable designs\n", "abstract": " This paper presents a unified approach to test case generation and conformance test execution in a distributed setting. A model in the object-oriented, concurrent modeling language Creol is used both for generating test inputs and as a test oracle. For test case generation, we extend Dynamic Symbolic Execution (also called Concolic Execution) to work with multi-threaded models and use this to generate test inputs that maximize model coverage. For test case execution, we establish a conformance relation based on trace inclusion by recording traces of events in the system under test and replaying them in the model. User input is handled by generating a test driver that supplies the needed stimuli to the model. An industrial case study of the Credo project serves to demonstrate the approach.", "num_citations": "32\n", "authors": ["2024"]}
{"title": "On the Semantics of Componentware: A Coalgebraic Perspective\n", "abstract": " In this chapter we present a coalgebraic semantics for components. Our semantics forms the basis for a family of operators for combining components. These operators together with their algebraic laws establish a calculus for software components. We present two applications of our semantics: a coalgebraic interpretation of UML diagrams and the design of a component repository.", "num_citations": "31\n", "authors": ["2024"]}
{"title": "Automated black-box testing with abstract VDM oracles\n", "abstract": " In this paper the possibilities to automate black-box testing through formal requirement specifications are explored. More precisely, the formal method VDM (Vienna Development Method) serves to demonstrate that abstract requirement models can be used as test oracles for concrete software. The automation of the resulting testing frame-work is based on modern CASE-tools that support a light-weight approach to formal methods. The specification language used is VDMSL, but the results are easily transferred into similar model oriented methods such as B, Z or RAISE.", "num_citations": "31\n", "authors": ["2024"]}
{"title": "Systematic black-box testing of computer-based systems through formal abstraction techniques\n", "abstract": " In the past of computer science, sometimes, a gap between the testing and the formal methods community could be observed. Testers did not believe in the applicability of formal verification techniques to real world problems, and formal methods\u2019 advocates could not accept testing-techniques as an adequate verification method for producing correct software. However, today the gap is closing and this thesis contributes to building the bridge by offering new results on testing based on formal development techniques.Others have worked on testing based on formal specifications before, but only a few considered the related development techniques such as program synthesis. Most of the previous work focused on generating test-cases by partitioning the formal specification into equivalence classes of input-output behavior. This related work on testing is reviewed.", "num_citations": "30\n", "authors": ["2024"]}
{"title": "Test case generation by contract mutation in Spec#\n", "abstract": " Mutation testing is a well known fault-based testing technique that is normally used to assess the quality of a test suite. In this paper we use the mutation operation to derive test cases that demonstrate the absence of certain faults in an implementation: In difference to conventional mutation testing, which mutates program code, we mutate program contracts and generate test-input data that is able to distinguish the mutated contract from the original one. We show how existing development tools can be used as a foundation for the presented methodology: In particular we rely on the counter-example generation capabilities of the Spec#/Boogie/Z3 system.", "num_citations": "23\n", "authors": ["2024"]}
{"title": "Dependable internet of things for networked cars\n", "abstract": " The Internet of Things (IoT) extends the Internet to include also wireless embedded computers that are often equipped with sensors and actuators to monitor and control their physical environment. The IoT is increasingly used for safety-critical applications such as smart factories or networked cars, where a failure of the IoT may lead to catastrophic consequences. The IoT is therefore in urgent need of dependability, where reliability, availability, and security properties can be guaranteed even in harsh environments (eg, radio interference) and under deliberate attacks (eg, exploiting side channels). In this paper we give an overview of recent research activities in the LEAD project \u201cDependable Internet of Things in Adverse Environments\u201d towards a dependable IoT, specifically dependable wireless communication and localization using Ultra-Wide-Band technology, secure execution of real-time software, protocol testing and verification, and dependable networked control. We also present the TruckLab testbed, where our research results can be integrated and validated in a platooning use case. In this testbed, model trucks are automatically controlled to follow a lead truck. Copyright\u00a9 Research Institute for Intelligent Computer Systems, 2017. All rights reserved.", "num_citations": "22\n", "authors": ["2024"]}
{"title": "Property-based testing with FsCheck by deriving properties from business rule models\n", "abstract": " Previous work has demonstrated that property-based testing can successfully be applied to web services. For example, it has been shown that JSON schemas can be used to automatically derive test-case generators for web forms. This paper presents a test-case generation approach for web services that takes business rule models as input for property-based testing. We parse these models to automatically derive generators for sequences of web service requests together with their required form data. Most of the work in this field applies property-based testing in the context of functional programming. Here, we define our properties in an object-oriented style in C# and its tool FsCheck. We apply our method to the business rule models of an industrial web service application in the automotive domain.", "num_citations": "20\n", "authors": ["2024"]}
{"title": "Efficient refinement checking for model-based mutation testing\n", "abstract": " In model-based mutation testing, a test model is mutated for test case generation. The resulting test cases are able to detect whether the faults in the mutated models have been implemented in the system under test. For this purpose, a conformance check between the original and the mutated model is required. We have developed an approach for conformance checking of action systems, which are well-suited to specify reactive and non-deterministic systems. We rely on constraint solving techniques. Both, the conformance relation and the transition relation are encoded as constraint satisfaction problems. Earlier results showed the potential of our constraint-based approach to outperform explicit conformance checking techniques, which often face state space explosion. In this work, we go one step further and show optimisations that really boost our performance. In our experiments, we could reduce our runtimes by\u00a0\u2026", "num_citations": "20\n", "authors": ["2024"]}
{"title": "-Based Learning of Markov Decision Processes\n", "abstract": " Automata learning techniques automatically generate system models from test observations. These techniques usually fall into two categories: passive and active. Passive learning uses a predetermined data set, e.g., system logs. In contrast, active learning actively queries the system under learning, which is considered more efficient. An influential active learning technique is Angluin\u2019s  algorithm for regular languages which inspired several generalisations from DFAs to other automata-based modelling formalisms. In this work, we study -based learning of deterministic Markov decision processes, first assuming an ideal setting with perfect information. Then, we relax this assumption and present a novel learning algorithm that collects information by sampling system traces via testing. Experiments with the implementation of our sampling-based algorithm suggest that it achieves better accuracy than state-of-the\u00a0\u2026", "num_citations": "19\n", "authors": ["2024"]}
{"title": "Formal specification techniques as a catalyst in validation\n", "abstract": " The American Heritage Dictionary defines a catalyst as a substance, usually present in small amounts relative to the reactants, that modifies and especially increases the rate of a chemical reaction without being consumed in the process. This article reports on the experience gained in an industrial project that formal specification techniques form such a catalyst in the validation of complex systems. These formal development methods improve the validation process significantly by generating precise questions about the system's intended functionality very early and by uncovering ambiguities and faults in textual requirement documents. This project has been a cooperation between the IST and the company Frequentis. The Vienna Development Method (VDM) has been used for validating the functional requirements and the existing acceptance tests of a network node for voice communication in air traffic control. In\u00a0\u2026", "num_citations": "18\n", "authors": ["2024"]}
{"title": "Unifying input output conformance\n", "abstract": " Model-based conformance testing aims to assess the correctness of an implementation with respect to a specification. This raises the question of a proper conformance relation that should be established between implementations and specifications. One commonly used conformance relation is the so-called input output conformance (ioco), which is defined over labeled transition systems. In this paper we investigate a denotational semantics of the input output conformance relation over reactive processes. We formalize the underlying assumptions of the ioco relation in terms of formal healthiness conditions and by adopted choice operators. Finally, we show that our denotational version of ioco can be generalized in the same way as the original relation. Our work aims to provide a unification of input output conformance by lifting the definition from labeled transition systems to reactive processes.", "num_citations": "17\n", "authors": ["2024"]}
{"title": "Formal specification of a voice communication system used in air traffic control an industrial application of light-weight formal methods using vdm\n", "abstract": " A joint project of the Austrian company Frequentis1 and the Technical University Graz demonstrates the applicability of executable formal models2. The formal method VDM++ has been applied to specify a safety critical voice communication system (VCS) for air-traffic control. Besides the expected improvement of the informal speciffication documents, 64 defects have been found, the efficiency of the system test-cases to cover the functionality of the VCS has been analyzed. In order to get a test-coverage measure, the formal specification has been animated with existing system test-cases using IFAD\u2019s VDMTools.", "num_citations": "17\n", "authors": ["2024"]}
{"title": "Learning from faults: Mutation testing in active automata learning\n", "abstract": " System verification is often hindered by the absence of formal models. Peled et al. proposed black-box checking as a solution to this problem. This technique applies active automata learning to infer models of systems with unknown internal structure.               This kind of learning relies on conformance testing to determine whether a learned model actually represents the considered system. Since conformance testing may require the execution of a large number of tests, it is considered the main bottleneck in automata learning.               In this paper, we describe a randomised conformance testing approach which we extend with fault-based test selection. To show its effectiveness we apply the approach in learning experiments and compare its performance to a well-established testing technique, the partial W-method. This evaluation demonstrates that our approach significantly reduces the cost of learning \u2013 in\u00a0\u2026", "num_citations": "16\n", "authors": ["2024"]}
{"title": "Debugging with timed automata mutations\n", "abstract": " Model-based Debugging is an application of Model-based Diagnosis techniques to debugging computer systems. Its basic principle is to compare a model, i.e., a description of the correct behaviour of a system, to the observed behaviour of the system. In this paper we show how this technique can be applied in the context of model-based mutation testing (MBMT) with timed automata. In MBMT we automatically generate a set of test sequences out of a test model. In contrast to general model-based testing, the test cases of MBMT cover a pre-defined set of faults that have been injected into the model (model mutation). Our automatic debugging process is purely black-box. If a test run fails, our tool reports a diagnosis as a set of model mutations. These mutations provide possible explanations why the test case has failed. For reproducing the failure, we also generate a set of minimal test cases leading to the\u00a0\u2026", "num_citations": "16\n", "authors": ["2024"]}
{"title": "Dynamic symbolic execution for testing distributed objects\n", "abstract": " This paper extends dynamic symbolic execution to distributed and concurrent systems. Dynamic symbolic execution can be used in software testing to systematically identify equivalence classes of input values and has been shown to scale well to large systems. Although mainly applied to sequential programs, this scalability makes it interesting to consider the technique in the distributed and concurrent setting as well. In order to extend the technique to concurrent systems, it is necessary to obtain sufficient control over the scheduling of concurrent activities to avoid race conditions. Creol, a modeling language for distributed concurrent objects, solves this problem by abstracting from a particular scheduling policy but explicitly defining scheduling points. This provides sufficient control to apply the technique of dynamic symbolic execution for model based testing of interleaved processes. The technique has\u00a0\u2026", "num_citations": "16\n", "authors": ["2024"]}
{"title": "Automatic Test Case Generation for OCL: a Mutation Approach\n", "abstract": " Fault-based testing is a technique where testers anticipate errors in a system under test in order to assess or generate test cases. The idea is to have enough test cases capable of detecting these anticipated errors. This work presents a method of fault-based test case generation for pre-and postcondition specifications. Here, errors are anticipated on the specification level by mutating the pre-and postconditions. We present the underlying theory by giving test cases a formal semantics and translate this general testing theory to a constraint satisfaction problem. A prototype test case generator serves to demonstrate the automatization of the method. It works on OCL specifications.", "num_citations": "16\n", "authors": ["2024"]}
{"title": "A coalgebraic semantic framework for component-based development in UML\n", "abstract": " This paper introduces a generic semantic framework for component-based development, expressed in the unified modelling language UML. The principles of a coalgebraic semantics for class, object and statechart diagrams as well as for use cases, are developed. It is also discussed how to formalize the refinement steps in the development process based upon a suitable notion of behavior refinement. In this way, a formal basis for component-based development in UML is studied, which allows the construction of more complex and specific systems from independent components.", "num_citations": "16\n", "authors": ["2024"]}
{"title": "Statistical model checking meets property-based testing\n", "abstract": " In recent years, statistical model checking (SMC) has become increasingly popular, because it scales well to larger stochastic models and is relatively simple to implement. SMC solves the model checking problem by simulating the model for finitely many executions and uses hypothesis testing to infer if the samples provide statistical evidence for or against a property. Being based on simulation and statistics, SMC avoids the state-space explosion problem well-known from other model checking algorithms. In this paper we show how SMC can be easily integrated into a property-based testing framework, like FsCheck for C#. As a result we obtain a very flexible testing and simulation environment, where a programmer can define models and properties in a familiar programming language. The advantages: no external modelling language is needed and both stochastic models and implementations can be checked. In\u00a0\u2026", "num_citations": "15\n", "authors": ["2024"]}
{"title": "Qualitative action systems\n", "abstract": " An extension to action systems is presented facilitating the modeling of continuous behavior in the discrete domain. The original action system formalism has been developed by Back et al. in order to describe parallel and distributed computations of discrete systems, i.e. systems with discrete state space and discrete control. In order to cope with hybrid systems, i.e. systems with continuous evolution and discrete control, two extensions have been proposed: hybrid action systems and continuous action systems. Both use differential equations (relations) to describe continuous evolution. Our version of action systems takes an alternative approach by adding a level of abstraction: continuous behavior is modeled by Qualitative Differential Equations that are the preferred choice when it comes to specifying abstract and possibly non-deterministic requirements of continuous behavior. Because their solutions are\u00a0\u2026", "num_citations": "15\n", "authors": ["2024"]}
{"title": "Combining algebraic and model-based test case generation\n", "abstract": " The classical work on test case generation and formal methods focuses either on algebraic or model-based specifications. In this paper we propose an approach to derive test cases in the RAISE method whose specification language RSL combines the model-based and algebraic style. Our approach integrates the testing techniques of algebraic specifications and model-based specifications. In this testing strategy, first, every function definition is partitioned by Disjunctive Normal Form (DNF) rewriting and then test arguments are generated. Next, sequences of function calls are formed. Finally, the test cases are built by replacing the variables, on both sides of the axioms, with the sequences of functions calls. These kinds of test cases not only provide the data for testing, but also serve as test oracles. Based on this combined approach, a test case generation tool has been developed.", "num_citations": "14\n", "authors": ["2024"]}
{"title": "Time to Learn\u2013Learning Timed Automata from Tests\n", "abstract": " Model learning has gained increasing interest in recent years. It derives behavioural models from test data of black-box systems. The main advantage offered by such techniques is that they enable model-based analysis without access to the internals of a system. Applications range from fully automated testing over model checking to system understanding. Current work focuses on learning variations of finite state machines. However, most techniques consider discrete time. In this paper, we present a novel method for learning timed automata, finite state machines extended with real-valued clocks. The learning method generates a model consistent with a set of timed traces collected via testing. This generation is based on genetic programming, a search-based technique for automatic program creation. We evaluate our approach on  timed systems, comprised of four systems from the literature (two\u00a0\u2026", "num_citations": "13\n", "authors": ["2024"]}
{"title": "Formal test-driven development with verified test cases\n", "abstract": " In this paper we propose the combination of several techniques into an agile formal development process: model-based testing, formal models, refinement of models, model checking, and test-driven development. The motivation is a smooth integration of formal techniques into an existing development cycle. Formal models are used to generate abstract test cases. These abstract tests are verified against requirement properties by means of model checking. The motivation for verifying the tests and not the model is two-fold: (1) in a typical safety-certification process the test cases are essential, not the models, (2) many common modelling tools do not provide a model checker. We refine the models, check refinement, and generate additional test cases capturing the newly added details. The final refinement step from a model to code is done with classical test-driven development. Hence, a developer implements one\u00a0\u2026", "num_citations": "13\n", "authors": ["2024"]}
{"title": "Towards symbolic model-based mutation testing: Pitfalls in expressing semantics as constraints\n", "abstract": " Model-based mutation testing uses altered models to generate test cases that are able to detect whether a certain fault has been implemented in the system under test. For this purpose, we need to check for conformance between the original and the mutated model. We have developed an approach for conformance checking of action systems using constraints. Action systems are well-suited to specify reactive systems and may involve non-determinism. Expressing their semantics as constraints for the purpose of conformance checking is not totally straight forward. This paper presents some pitfalls that hinder the way to a sound encoding of semantics into constraint satisfaction problems and gives solutions for each problem.", "num_citations": "13\n", "authors": ["2024"]}
{"title": "The formal foundations in RSL for UML statechart diagrams\n", "abstract": " In this paper, we present a formalization for UML statechart diagrams in the RAISE specification language RSL. By such a formalization, we propose a general framework for integration of graphical UML statechart diagrams and formal RSL specifications, which forms the continuation of the previous work on formalization of UML class diagrams in RSL. This allows the definition of UML semantic interpretations that are precise and unambiguous, and also enhancing the readability, conciseness and abstraction of the resulting RSL specification. In a case study, we illustrate how the framework can be used to create formal specification for UML models and analyze the properties of the models.", "num_citations": "13\n", "authors": ["2024"]}
{"title": "Efficient active automata learning via mutation testing\n", "abstract": " System verification is often hindered by the absence of formal models. Peled et al. proposed black-box checking as a solution to this problem. This technique applies active automata learning to infer models of systems with unknown internal structure. This kind of learning relies on conformance testing to determine whether a learned model actually represents the considered system. Since conformance testing may require the execution of a large number of tests, it is considered the main bottleneck in automata learning. In this paper, we describe a randomised conformance testing approach which we extend with fault-based test selection. To show its effectiveness we apply the approach in learning experiments and compare its performance to a well-established testing technique, the partial W-method. This evaluation demonstrates that our approach significantly reduces the cost of learning. In multiple\u00a0\u2026", "num_citations": "12\n", "authors": ["2024"]}
{"title": "Property-based testing of web services by deriving properties from business-rule models\n", "abstract": " Property-based testing is well suited for web-service applications, which was already shown in various case studies. For example, it has been demonstrated that JSON schemas can be used to automatically derive test case generators for web forms. In this work, we present a test case generation approach for a rule engine-driven web-service application. Business-rule models serve us as input for property-based testing. We parse these models to automatically derive generators for sequences of web-service requests together with their required form data. Property-based testing is mostly applied in the context of functional programming. Here, we define our properties in an object-oriented style in C# and its tool FsCheck. We apply our method to the business-rule models of an industrial web-service application in the automotive domain.", "num_citations": "12\n", "authors": ["2024"]}
{"title": "Model-based mutation testing of reactive systems\n", "abstract": " In this paper we give an overview of our work on combining model-based testing and mutation testing. Model-based testing is a black-box testing technique that avoids the labour of manually writing hundreds of test cases, but instead advocates the capturing of the expected behaviour in a model of the system-under-test. The test cases are automatically generated from this model. The technique is receiving growing interest in the embedded-systems domain, where models are the rule rather than the exception.             Mutation testing is a technique for assessing and improving a test suite. A number of faulty versions of a program-under-test are produced by injecting bugs into its source code. These faulty programs are called mutants. A tester analyses if his test suite can \u201dkill\u201d all mutants. We say that a test kills a mutant if it is able to distinguish it from the original. The tester improves his test suite until all faulty\u00a0\u2026", "num_citations": "12\n", "authors": ["2024"]}
{"title": "Component-based coalgebraic specification and verification in RSL\n", "abstract": " Component-based software development has become a popular paradigm in software engineering. From the theoretical point of view, components can be seen as coalgebras. We present a coalgebraic technique for component-based system specification and verification which is based on RSL, the wide spectrum specification language of the RAISE method. A bisimulation relationship between components is defined for reuse of components and used in the behavior verification of specification development. Final coalgebras are used to construct the minimal implementations of given specifications.", "num_citations": "12\n", "authors": ["2024"]}
{"title": "How fast is MQTT?\n", "abstract": " MQTT is one of the major messaging protocols in the Internet of things (IoT). In this work, we investigate the expected performance of MQTT implementations in various settings. We present a model-based performance testing approach that allows a fast simulation of specific usage scenarios in order to perform a quantitative analysis of the latency. Out of automatically generated log-data, we learn the distributions of latencies and apply statistical model checking to analyse the functional and timing behaviour. The result is a novel testing and verification technique for analysing the performance of IoT protocols. Two well-known open source MQTT implementations are evaluated and compared.", "num_citations": "11\n", "authors": ["2024"]}
{"title": "Symbolic input-output conformance checking for model-based mutation testing\n", "abstract": " This paper presents an approach to use symbolic input output conformance checking for mutation-based test case generation. In this approach, a possibly non-deterministic action system model is used as basis for generating a number of mutants. Subsequently after the generation of mutants, the original model and the mutants are simultaneously symbolically executed and tested for conformance. Distinguishing test cases are generated, if non-conformance is detected during this process. Several optimisations of the conformance check are presented and their effectiveness is underpinned by listing experimental results.", "num_citations": "11\n", "authors": ["2024"]}
{"title": "A proof obligation generator for the IFAD VDM-SL Toolbox\n", "abstract": " During the last years, the interest in formal methods for software development has been growing rapidly. One of the reasons for this is the availability of tools to support the developer in using these formal methods. This thesis describes an extension of the IFAD VDMSL Toolbox, a CASE tool supporting the Vienna Development Method VDM. Amongst other features the Toolbox supports parsing and type checking of specifications written in VDM-SL, the specification language of VDM. Static type checking in VDM-SL is undecidable in general and therefore the type checker must be necessarily incomplete. In traditional programming languages the additional consistency checks are performed at run time. This approach is not feasible, because specifications are not executable in general. Hence, it is up to the user to verify the consistency of a specification for the \u201cdifficult\u201d parts introducing undecidability. In the existing type checker the user is supported by error messages and warnings generated during type checking. Instead of providing error messages, in this thesis the approach of generating proof obligations for consistency is described. A proof obligation is an unproven theorem stating that a certain property must hold in order for the specification to be consistent. If a proof obligation can be proved, then the part referred to in the specification is consistent. The goal of the thesis project was the specification of a proof obligation generator in VDM-SL as an extension to the existing static semantics of VDM-SL. The proof obligations are designed to be imported into a theorem prover for the Toolbox which is currently under development. iii", "num_citations": "10\n", "authors": ["2024"]}
{"title": "From Passive to Active: Learning Timed Automata Efficiently\n", "abstract": " Model-based testing is a promising technique for quality assurance. In practice, however, a model is not always present. Hence, model learning techniques attain increasing interest. Still, many learning approaches can only learn relatively simple types of models and advanced properties like time are ignored in many cases. In this paper we present an active model learning technique for timed automata. For this, we build upon an existing passive learning technique for real-timed systems. Our goal is to efficiently learn a timed system while simultaneously minimizing the set of training data. For evaluation we compared our active to the passive learning technique based on 43 timed systems with up\u00a0to 20 locations and multiple clock variables. The results of  experiments show that we require only 100 timed traces to adequately learn a timed system. The new approach is up\u00a0to 755 times faster.", "num_citations": "9\n", "authors": ["2024"]}
{"title": "Checking response-time properties of web-service applications under stochastic user profiles\n", "abstract": " Performance evaluation of critical software is important but also computationally expensive. It usually involves sophisticated load-testing tools and demands a large amount of computing resources. Analysing different user populations requires even more effort, becoming infeasible in most realistic cases. Therefore, we propose a model-based approach. We apply model-based test-case generation to generate log-data and learn the associated distributions of response times. These distributions are added to the behavioural models on which we perform statistical model checking (SMC) in order to assess the probabilities of the required response times. Then, we apply classical hypothesis testing to evaluate if an implementation of the behavioural model conforms to these timing requirements. This is the first model-based approach for performance evaluation combining automated test-case generation, cost\u00a0\u2026", "num_citations": "9\n", "authors": ["2024"]}
{"title": "Property-based testing with external test-case generators\n", "abstract": " Previous work has demonstrated that property-based testing (PBT) is a flexible random testing technique that facilitates the generation of complex form data. For example, it has been shown that PBT can be applied to web-service applications that require various inputs for web-forms. We want to exploit this data generation feature of PBT and combine it with an external test-case generator that can generate test cases via model-based mutation testing. PBT already supports the generation of test cases from stateful models, but it is limited, because it normally only considers the current state during exploration of the model. We want to give the tester more control on how to produce meaningful operation sequences for test cases. By integrating an external test-case generator into a PBT tool, we produce a smaller set of test cases that meet certain coverage criteria. This also reduces the test execution time. We\u00a0\u2026", "num_citations": "9\n", "authors": ["2024"]}
{"title": "Bounded determinization of timed automata with silent transitions\n", "abstract": " Deterministic timed automata are strictly less expressive than their non-deterministic counterparts, which are again less expressive than those with silent transitions. As a consequence, timed automata are in general non-determinizable. This is unfortunate since deterministic automata play a major role in model-based testing, observability and implementability. However, by bounding the length of the traces in the automaton, effective determinization becomes possible. We propose a novel procedure for bounded determinization of timed automata. The procedure unfolds the automata to bounded trees, removes all silent transitions and determinizes via disjunction of guards. The proposed algorithms are optimized to the bounded setting and thus are more efficient and can handle a larger class of timed automata than the general algorithms. The approach is implemented in a prototype tool and evaluated on\u00a0\u2026", "num_citations": "9\n", "authors": ["2024"]}
{"title": "Towards generation of adaptive test cases from partial models of determinized timed automata\n", "abstract": " The well-defined timed semantics of timed automata as specification models provide huge advantages for the verification and validation of real-time systems. Thus, timed automata have already been applied in many different areas, including model-based testing. Unfortunately, there is one drawback in using timed automata for test-case generation: if they contain non-determinism or silent transitions, the problem of language inclusion between timed automata becomes undecidable. In recent work, we developed and implemented a technique to determinize timed automata up to a certain depth k. The resulting timed automata are unfolded to directed acyclic graphs (DAGs) up to depth k. The unfolding caused an exponential state-space explosion. Consequently, our model-based test-case generation algorithm for deterministic timed automata, which uses language inclusion, did not scale anymore. Within this paper\u00a0\u2026", "num_citations": "9\n", "authors": ["2024"]}
{"title": "Automatic test case generation for RAISE\n", "abstract": " In this report we propose an approach to derive test cases from RSL specifications. Our approach integrates the testing techniques for algebraic and model-based specifications. In this approach, Disjunctive Normal Form (DNF) partition analysis is first applied to function definitions to generate test data for the individual functions, then sequences of function calls are formed, and test cases are derived from replacing the variables on both sides of axioms by the sequences of function calls. The test cases not only provide the input data for testing, but also serve as test oracles. A test case generation tool has been developed based on this approach.", "num_citations": "9\n", "authors": ["2024"]}
{"title": "Database development of a work-flow planning and tracking system using VDM-SL\n", "abstract": " This paper presents the techniques and experiences of an industrial project, applying the formal method VDM in order to develop a work-flow planning and tracking system. A method for creating formal models of relational databases has been developed| specifically, formal representations of SQL datatypes, a model of the structure of a database including primary and foreign keys and the formulation of queries in the model. With this approach, familiar informal design methods from the database world can be used without giving up the expressive power of formal methods. The transition from the informal to the formal world can be automated, keeping the relevant parts of the formal model synchronized with minimal effort. The formal method used is VDM, but the results are easily transferred into similar model oriented methods.", "num_citations": "9\n", "authors": ["2024"]}
{"title": "Probabilistic black-box reachability checking (extended version)\n", "abstract": " Model checking has a long-standing tradition in software verification. Given a system design it checks whether desired properties are satisfied. Unlike testing, it cannot be applied in a black-box setting. To overcome this limitation Peled et al.\u00a0 introduced black-box checking, a combination of testing, model inference and model checking. The technique requires systems to be fully deterministic. For stochastic systems, statistical techniques are available. However, they cannot be applied to systems with non-deterministic choices. We present a black-box checking technique for stochastic systems that allows both, non-deterministic and probabilistic behaviour. It involves model inference, testing and probabilistic model-checking. Here, we consider reachability checking, i.e., we infer near-optimal input-selection strategies for bounded reachability.", "num_citations": "8\n", "authors": ["2024"]}
{"title": "Learning and statistical model checking of system response times\n", "abstract": " Since computers have become increasingly more powerful, users are less willing to accept slow responses of systems. Hence, performance testing is important for interactive systems. However, it is still challenging to test if a system provides acceptable performance or can satisfy certain response-time limits, especially for different usage scenarios. On the one hand, there are performance-testing techniques that require numerous costly tests of the system. On the other hand, model-based performance analysis methods have a doubtful model quality. Hence, we propose a combined method to mitigate these issues. We learn response-time distributions from test data in order to augment existing behavioral models with timing aspects. Then, we perform statistical model checking with the resulting model for a performance prediction. Finally, we test the accuracy of our prediction with hypotheses testing of the real\u00a0\u2026", "num_citations": "8\n", "authors": ["2024"]}
{"title": "Probabilistic black-box reachability checking\n", "abstract": " Model checking has a long-standing tradition in software verification. Given a system design it checks whether desired properties are satisfied. Unlike testing, it cannot be applied in a black-box setting. To overcome this limitation Peled et al.\u00a0 introduced black-box checking, a combination of testing, model inference and model checking. The technique requires systems to be fully deterministic. For stochastic systems, statistical techniques are available. However, they cannot be applied to systems with non-deterministic choices. We present a black-box checking technique for stochastic systems that allows both, non-deterministic and probabilistic behaviour. It involves model inference, testing and probabilistic model-checking. Here, we consider reachability checking, i.e., we infer near-optimal input-selection strategies for bounded reachability.", "num_citations": "8\n", "authors": ["2024"]}
{"title": "Automated requirements testing with abstract oracles\n", "abstract": " During the last few years the interest in formal software development has been growing rapidly. One of the main reasons for this is the availability of tools to assist the developer in using these formal methods. The author, too, has contributed to the growing computer aid by an extension of a commercial tool 1]. However, formal methods are not often applied in industrial projects, despite the maturity of the theories and tools. Several reasons can be identi ed for the absence of formality in the software development process: Too many di erent notations have been invented, a lack of integration into informal approaches, and the strong emphasize on formal proofs.Consequently, instead of promoting formal correctness proofs, we regard the automation of functional testing as the next step in a smooth integration of formal methods to raise the level of reliability, after formal speci cation techniques have been introduced. The Vienna Development Method (VDM) 4] serves to demonstrate how a well-established formal method supports the automation of testing. VDM is supported by CASE-tools and even allows an integration into informal methods like UML or Structured Analysis, and so does our testing approach. Previous work has shown how test-cases may be derived out of formal speci cations 2]. However, little attention had been given to the fact that formal models of software requirements are inherently abstract in the sense that detailed design decisions are not included. Consequently, the test-cases, derived (generated) from such an abstract model, are abstract, too, and thus inappropriate for a direct automatic test of a target sys-", "num_citations": "8\n", "authors": ["2024"]}
{"title": "Dynamic symbolic execution of distributed concurrent objects\n", "abstract": " This paper extends dynamic symbolic execution to distributed and concurrent systems. Dynamic symbolic execution is used to systematically identify equivalence classes of input values and has been shown to scale well to large systems. Although mainly applied to sequential programs, this scalability makes it interesting to consider the technique in the distributed and concurrent setting as well. In order to extend the technique to concurrent systems, it is necessary to obtain sufficient control over the scheduling of concurrent activities to avoid race conditions. Creol, a modeling language for distributed concurrent objects, solves this problem by abstracting from a particular scheduling policy but explicitly defining scheduling points. This provides sufficient control to apply the technique of dynamic symbolic of interleaved processes. The technique has been formalized in rewriting logic and executes in Maude.", "num_citations": "7\n", "authors": ["2024"]}
{"title": "Towards integrating statistical model checking into property-based testing\n", "abstract": " In recent years statistical model checking (SMC) became increasingly popular, mainly because it does not suffer from one of the major problems that limits traditional model checking, the so called state-space-explosion problem. SMC solves this problem by simulating a stochastic model for finitely many executions. There exist a number of SMC tools, but they require the user to learn a specific modelling language and a particular (temporal) logic to express properties. In this paper we propose a more flexible application of SMC, where both the model and the properties can be defined in a programming language. The technique builds upon the well-known property-based testing approach. We use the programming language C# and its associated tool FsCheck to demonstrate our approach. A stochastic counter serves as illustrating example.", "num_citations": "6\n", "authors": ["2024"]}
{"title": "Formal Methods at the Crossroads. From Panacea to Foundational Support: 10th Anniversary Colloquium of UNU/IIST, the International Institute for Software Technology of The\u00a0\u2026\n", "abstract": " This volume is devoted to the 10th Anniversary Colloquium of UNU/IIST, the International Institute for Software Technology of the United Nations University, as well as to the memory of Armando Haeberer, who passed away while he was working on the preparation of this book in February 2003. The volume starts with a special paper by Tom Maibaum recollecting Armando Haeberer's life and work. The second part presents work done by members of UNU/IIST as well as a paper on the history of the institute. The subsequent topical sections present key contributions by leading researchers and thus assess the state of the art in software engineering and its engineering and scientific principles, from models to software, real-time systems, and verification. All in all, the book is a unique survey of the power and potential of formal methods in software engineering.", "num_citations": "6\n", "authors": ["2024"]}
{"title": "Learning abstracted non-deterministic finite state machines\n", "abstract": " Active automata learning gains increasing interest since it gives an insight into the behavior of a black-box system. A crucial drawback of the frequently used learning algorithms based on Angluin\u2019s  is that they become impractical if systems with a large input/output alphabet are learned. Previous work suggested to circumvent this problem by abstracting the input alphabet and the observed outputs. However, abstraction could introduce non-deterministic behavior. Already existing active automata learning algorithms for observable non-deterministic systems learn larger models if outputs are only observable after certain input/output sequences. In this paper, we introduce an abstraction scheme that merges akin states. Hence, we learn a more generic behavioral model of a black-box system. Furthermore, we evaluate our algorithm in a practical case study. In this case study, we learn the behavior of five\u00a0\u2026", "num_citations": "5\n", "authors": ["2024"]}
{"title": "The credo methodology\n", "abstract": " This paper is an extended version of the Credo Methodology [16]. Credo offers tools and techniques to model and analyze highly reconfigurable distributed systems. In a previous version we presented an integrated methodology to use the Credo tool suite. Following a compositional, component\u2013based approach to model and analyze distributed systems, we presented a separation of the system into components and the network. A high\u2013level, abstract representation of the dataflow level on the network was given in terms of behavioral interface automata and a detailed model of the components in terms of Creol models. Here we extend the methodology with a detailed model of the network connecting these components. The Vereofy tool set is used to model and analyze the dataflow of the network in detail. The behavioral automata connect the detailed model of the network and the detailed model of the\u00a0\u2026", "num_citations": "5\n", "authors": ["2024"]}
{"title": "A coalgebraic calculus for component based systems\n", "abstract": " In this paper we describe the coalgebraic models for state-based software components and componentbased systems. The behaviour patterns of components are specified by strong monads. A family of operators for combining components based on the category of coalgebras are defined and a set of algebraic laws are also presented to specify the properties being satisfied by these operators.", "num_citations": "5\n", "authors": ["2024"]}
{"title": "Requirements validation of a voice communication system used in air traffic control. An industrial application of light-weight formal methods\n", "abstract": " During the last few years light-weight approaches to formal development methods have been proposed in order to facilitate the technological transfer of formal methods. \"Light-weight\" means that a precise and unambiguous formal specification language is used in order to raise the quality of a system's description, without focusing on proofs (C.B. Jones, 1996). The article presents the results and experiences gained in an industrial project where VDM++, an object oriented extension of the Vienna Development Method, has been applied in such a light-weight manner. In the joint project of the Austrian company Frequentis and the Technical University Graz (J. Horl, 1999), a safety critical voice communication system (VCS) for air-traffic control has been specified and validated. It serves as the sole communication system between the pilots, the air-traffic control personnel at the tower, the ground personnel on the\u00a0\u2026", "num_citations": "5\n", "authors": ["2024"]}
{"title": "Learning-Based Fuzzing of IoT Message Brokers\n", "abstract": " The number of devices in the Internet of Things (IoT) immensely grew in recent years. A frequent challenge in the assurance of the dependability of IoT systems is that components of the system appear as a black box. This paper presents a semi-automatic testing methodology for black-box systems that combines automata learning and fuzz testing. Our testing technique uses stateful fuzzing based on a model that is automatically inferred by automata learning. Applying this technique, we can simultaneously test multiple implementations for unexpected behavior and possible security vulnerabilities.We show the effectiveness of our learning-based fuzzing technique in a case study on the MQTT protocol. MQTT is a widely used publish/subscribe protocol in the IoT. Our case study reveals several inconsistencies between five different MQTT brokers. The found inconsistencies expose possible security vulnerabilities and\u00a0\u2026", "num_citations": "4\n", "authors": ["2024"]}
{"title": "Learning-based testing of an industrial measurement device\n", "abstract": " Active automata learning algorithms have gained increasing importance in the field of model-based system verification. For some classes of systems - especially deterministic systems, like Mealy machines, a variety of learning algorithm implementations is readily available. In this paper, we apply this technique to a measurement device from the automotive industry in order to systematically test its behaviour. However, our system under learning shows sparse non-deterministic behaviour, preventing the direct application of the available learning tools.               We propose an implementation of the active automata learning framework which masks this non-determinism. We repeat a previous model-based testing experiment with faulty devices and show that we can detect all injected faults. Most importantly, our technique was also able to find unknown bugs.", "num_citations": "4\n", "authors": ["2024"]}
{"title": "Learning Timed Automata via Genetic Programming\n", "abstract": " Model learning has gained increasing interest in recent years. It derives behavioural models from test data of black-box systems. The main advantage offered by such techniques is that they enable model-based analysis without access to the internals of a system. Applications range from fully automated testing over model checking to system understanding. Current work focuses on learning variations of finite state machines. However, most techniques consider discrete time. In this paper, we present a method for learning timed automata, finite state machines extended with real-valued clocks. The learning method generates a model consistent with a set of timed traces collected by testing. This generation is based on genetic programming, a search-based technique for automatic program creation. We evaluate our approach on 44 timed systems, comprising four systems from the literature and 40 randomly generated examples.", "num_citations": "4\n", "authors": ["2024"]}
{"title": "Conformance checking of real-time models\n", "abstract": " We compare conformance checking based on symbolic execution to conformance checking via bounded model checking. The application context is fault-based test case generation, focusing on real-time faults. The existing bounded model checking approach is performed on timed automata. It supports time-relevant mutation operators and a preprocessing functionality for removing silent transitions and non-determinism. The new symbolic execution approach is performed on timed action systems, which are a novel variant of Back\u2019s action systems augmented by clock variables and real-time semantics. It supports the same set of mutation operators, silent transitions, non-determinism and data variables. We show how to encode timed automata as timed action systems and perform experiments on three variants of a car alarm system, to investigate the influence of silent transitions, non-determinism and data\u00a0\u2026", "num_citations": "4\n", "authors": ["2024"]}
{"title": "Integrating model-based testing and analysis tools via test case exchange\n", "abstract": " Europe's industry in embedded system design is currently aiming for a better integration of tools that support their development, validation and verification processes. The idea is to combine model-driven development with model-based testing and model-based analysis. The interoperability of tools shall be achieved with the help of meta-models that facilitate the mapping between different modelling notations. However, the syntactic and semantic integration of tools is a complex and costly task. A common problem is that different tools support different subsets of a language. Furthermore, semantic differences are a major obstacle to sound integration efforts. In this paper we advocate an alternative, more pragmatic approach. We propose the exchange of test cases generated from the models instead of exchanging the models themselves. The advantage is that test cases have a much simpler syntax and semantics\u00a0\u2026", "num_citations": "4\n", "authors": ["2024"]}
{"title": "When model-based testing fails\n", "abstract": " Armando Haeberer made a substantial contribution in translating results from the philosophy of science to software testing. He showed that the limits of the standard methodology of confirming theories, where observations are derived from the theory and hypothesis, are also present in software testing. He criticized the classical test case generation approach from algebraic specifications, but also supplied an alternative based on Glymour's bootstrap approach. However, the debate that one would expect after his contribution never really happened. This is especially astonishing since most of the model-based testing approaches follow the method he criticized. This paper aims to open the debate by looking on his findings from a fresh point of view. We use the concept of refinement to clarify the fundamental issues involved in testing and discuss the practical consequences.", "num_citations": "4\n", "authors": ["2024"]}
{"title": "Coalg KPF: Towards a Coalgebraic Calcu-lus for Component-Based Systems\n", "abstract": " Coalgebras of Kripke Polynomial Functors have been widely used in modelling various kinds of systems. In this paper, we give a category CoalgKPF which consists of coalgebras of KPFs. Then we present a set of constructions like sequential and parallel composition in a subcategory of CoalgKPF for a restricted family of KPFs by exploiting the canonical operations in category theory. A family of algebraic laws for the properties being satisfied by these operations is provided.", "num_citations": "4\n", "authors": ["2024"]}
{"title": "AALpy: an active automata learning library\n", "abstract": " AALpy is an extensible open-source Python library providing efficient implementations of active automata learning algorithms for deterministic, non-deterministic, and stochastic systems. We put a special focus on the conformance testing aspect in active automata learning, as well as on an intuitive and seamlessly integrated interface for learning automata characterizing real-world reactive systems. In this manuscript, we present AALpy\u2019s core functionalities, illustrate its usage via examples, and evaluate its learning performance.", "num_citations": "3\n", "authors": ["2024"]}
{"title": "-based learning of Markov decision processes (extended version)\n", "abstract": " Automata learning techniques automatically generate system models from test observations. These techniques usually fall into two categories: passive and active. Passive learning uses a predetermined data set, e.g., system logs. In contrast, active learning actively queries the system under learning, which is considered more efficient. An influential active learning technique is Angluin's L* algorithm for regular languages which inspired several generalisations from DFAs to other automata-based modelling formalisms. In this work, we study L*-based learning of deterministic Markov decision processes, first assuming an ideal setting with perfect information. Then, we relax this assumption and present a novel learning algorithm that collects information by sampling system traces via testing. Experiments with the implementation of our sampling-based algorithm suggest that it achieves better accuracy than state-of-the-art passive learning techniques with the same amount of test data. Unlike existing learning algorithms with predefined states, our algorithm learns the complete model structure including the states.", "num_citations": "3\n", "authors": ["2024"]}
{"title": "Refinement and test case generation in UTP\n", "abstract": " This paper presents a theory of testing that integrates into Hoare and He's Unifying Theory of Programming (UTP). We give test cases a denotational semantics by viewing them as specification predicates. This reformulation of test cases allows for relating test cases via refinement to specifications and programs. Having such a refinement order that integrates test cases, we develop a testing theory for fault-based testing.Fault-based testing uses test data designed to demonstrate the absence of a set of pre-specified faults. A well-known fault-based technique is mutation testing. In mutation testing, first, faults are injected into a program by altering (mutating) its source code. Then, test cases that can detect these errors are designed. The assumption is that other faults will be caught, too. In this paper, we apply the mutation technique to both, specifications and programs.Using our theory of testing, two new test case\u00a0\u2026", "num_citations": "3\n", "authors": ["2024"]}
{"title": "On the value of fault injection on the modeling level\n", "abstract": " In this paper we advocate the integration of fault injection into a formal methods tool set. We start by giving some motivations from our past industrial experiences with VDM. Then, we report about our recent work on specification-based test case generation via model mutation. In this testing approach the idea is not to cover a specification structurally, eg all expressions/statements, but to cover a predefined set of possible faults, like semantic misunderstandings. A prototype tool has been developed that generates such test cases that could be easily adapted to VDM specifications. Finally, the validation role of fault injection is discussed.", "num_citations": "3\n", "authors": ["2024"]}
{"title": "Testing for design faults\n", "abstract": " Existing theories of testing focus on verification. Their strategy is to cover a specification or a program text to a certain degree in order to raise the confidence in the correctness of a system under test. We take a different approach in the sense that we present a theory of fault-based testing. Fault-based testing uses test data designed to demonstrate the absence of a set of pre-specified faults. Here, the focus is on falsification. The presented theory of testing is integrated into Hoare & He\u2019s theory of programming. As a result, two new test case generation techniques for detecting anticipated faults are presented: one is based on the semantic level of design specifications, the other on the algebraic properties of a programming language.", "num_citations": "3\n", "authors": ["2024"]}
{"title": "Benchmarking Combinations of Learning and Testing Algorithms for Active Automata Learning\n", "abstract": " Active automata learning comprises techniques for learning automata models of black-box systems by testing such systems. While this form of learning enables model-based analysis and verification, it may also require a substantial amount of interactions with considered systems to learn adequate models, which capture the systems\u2019 behaviour. The test cases executed during learning can be divided into two categories: (1) test cases to gain knowledge about a system and (2) test cases to falsify a learned hypothesis automaton. The former are selected by learning algorithms, whereas the latter are selected by conformance-testing algorithms. There exist various options for both types of algorithms and there are dependencies between them. In this paper, we investigate the performance of combinations of four different learning algorithms and seven different testing algorithms. For this purpose, we perform learning\u00a0\u2026", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Statistical model checking of response times for different system deployments\n", "abstract": " Performance testing is becoming increasingly important for interactive systems. Evaluating their performance with respect to user expectations is complex, especially for different system deployments. Various load-testing approaches and performance-simulation methods aim at such analyses. However, these techniques have certain disadvantages, like a high testing effort for load testing, and a questionable model accuracy for simulation methods. Hence, we propose a combination of both techniques. We apply statistical model checking with a learned timed model and evaluate the results on the real system with hypothesis testing. Moreover, we check the established hypotheses of a reference system on various system deployments (configurations), like different hardware or network settings, and analyse the influence on the performance. Our method is realised with a property-based testing tool that is\u00a0\u2026", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Does this fault lead to failure? Combining refinement and input\u2013output conformance checking in fault-oriented test-case generation\n", "abstract": " In this paper we describe an advanced test-case generation technique that is implemented in our model-based test-case generator MoMuT::UML. The tool injects faults into a UML model and analyses if the faults propagate to the interface. If a fault does propagate to an observable failure, an explaining sequence of events is generated and converted into a test-case scenario. The faults are detected using a highly optimised refinement checker, their propagation is analysed with an input\u2013output conformance (ioco) checker. We show that this combination is faster than pure input\u2013output conformance checking. It has been used in a recent industrial application of testing automotive measurement devices. The refinement and ioco checker are implemented in Prolog using the SMT solver Z3.", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Bounded determinization of timed automata with silent transitions\n", "abstract": " Bounded Determinization of Timed Automata with Silent Transitions \u2014 Graz University of Technology Skip to main navigation Skip to search Skip to main content Graz University of Technology Logo English Deutsch Home Persons Research Units Research Outputs Projects Activities Prizes Press / Media Search by expertise, name or affiliation Bounded Determinization of Timed Automata with Silent Transitions Amnon Rosenmann, Florian Lukas Lorber, Dejan Nickovic, Bernhard Aichernig Institute of Software Technology (7160) Research output: Book/Report \u203a Other report Overview Original language English Publisher . Publication status Published - 2015 Fields of Expertise Information, Communication & Computing Access to Document paper_main.pdfFinal published version, 440 KB Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Rosenmann, A., Lorber, FL, Nickovic, D., & Aichernig, B. (2015). \u2026", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Formal Methods for Components and Objects: 9th International Symposium, FMCO 2010, Graz, Austria, November 29-December 1, 2010\n", "abstract": " The focus in development methodologies of large and complex software systems has switched in the last two decades from functional issues to structural issues; this holds for both the object-oriented and the more recent component-based software engineering paradigms. Formal methods have been applied successfully to the verification of medium-sized programs in protocol and hardware design for quite a long time. However, their application to the development of large systems requires more emphasis on specification, modeling and validation techniques supporting the concepts of reusability and modifiability, and their implementation in new extensions of existing programming languages like Java. This state-of-the-art survey presents the outcome of the 9th Symposium on Formal Methods for Components and Objects, held in Graz, Austria, in November/December 2010. The volume contains 20 revised contributions submitted after the symposium by speakers from each of the following European IST projects: the FP7-IST project AVANTSSAR on automated validation of trust and security of service-oriented architectures; the FP7-IST project DEPLOY on industrial deployment of advanced system engineering methods for high productivity and dependability; the ESF-COST Action IC0701 on formal verification of object-oriented software; the FP7-IST project HATS on highly adaptable and trustworthy software using formal models; the FP7-SST project INESS on an integrated European railway signalling system; the FP7-IST project MADES on a model-driven approach to improve the current practice in the development of embedded systems; the\u00a0\u2026", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Resource modeling for timed Creol models\n", "abstract": " This paper describes the semantics of a timed, resource-constrained extension of the Creol modeling language. Creol is an object-oriented modeling language with a design that is suited for modeling distributed systems. However, the computation model of Creol assumes infinite memory and infinite parallelism within an object. This paper describes a way to extend Creol with a notion of resource constraints and a way to quantitatively assess the effects of introducing resource constraints on a given model. We discuss possible semantics of message delivery under resource constraints, their implementation and their impact on the model. The method is illustrated with a case study modeling a biomedical sensor network.", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Input output conformance testing in the unifying theories of programming\n", "abstract": " Model-based conformance testing aims to assess the correctness of an implementation with respect to a specification. This raises the question of a proper conformance relation that should be established between implementations and specifications. One commonly used conformance relation is the so-called input output conformance (ioco), which is defined over labeled transition systems. In this paper we investigate a denotational semantics of the input output conformance relation over reactive processes. We formalize the underlying assumptions of the ioco relation in terms of formal healthiness conditions and by adopted choice operators. Finally, we show that our denotational version of ioco can be generalized in the same way as the original relation. Our work aims to provide a unification of input output conformance by lifting the definition from labeled transition systems to reactive processes.", "num_citations": "2\n", "authors": ["2024"]}
{"title": "A systematic introduction to mutation testing in unifying theories of programming\n", "abstract": " This chapter presents a theory of testing that integrates into Hoare and He\u2019s Unifying Theories of Programming\u00a0(UTP). We give test cases a denotational semantics by viewing them as specification predicates. This reformulation of test cases allows for relating test cases via refinement to specifications and programs. Having such a refinement order that integrates test cases, we develop a testing theory for fault-based testing.             As discussed in Chapter\u00a01, fault-based testing uses test data designed to demonstrate the absence of a set of pre-specified faults. A well-known fault-based technique is mutation testing. In mutation testing, first, faults are injected into a program by altering\u00a0(mutating) its source code. Then, test cases that can detect these errors are designed. The assumption is that other faults will be caught, too. In this chapter, we apply the mutation technique to both specifications and programs.", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Qualification of open source software for e-govemment\n", "abstract": " 2. BackgroundIn 2000, the computer network of the institute of the author at the TU Graz, Austria, was hacked. The intruder caused severe damage by deleting several essential files on various servers. Although no sensitive data could be accessed, it took several days until the network services were back to normal operation. As an immediate consequence a new security policy was enforced. The use of ftp and telnet was prohibited, since these programs send passwords unencrypted via the Internet. Instead the Secure Shell SSH was to be used. Everybody considered this as a reasonable measure. However, it was completely inadequate. A closer analysis of the attack revealed that the intruder got access by exploiting a fault in OpenSSH, an open source implementation of the SSH protocol. The program that was supposed to secure the network actually caused the trouble! Not the insecure protocol of ftp or telnet\u00a0\u2026", "num_citations": "2\n", "authors": ["2024"]}
{"title": "UML \u72b6\u6001\u673a\u89c6\u56fe\u7684 RSL \u5f62\u5f0f\u63cf\u8ff0\n", "abstract": " \u4f7f\u7528RAISE\u89c4\u8303\u8bed\u8a00RSL\u7ed9\u51fa\u4e86UML\u72b6\u6001\u673a\u89c6\u56fe\u7684\u5f62\u5f0f\u63cf\u8ff0.\u901a\u8fc7\u8fd9\u4e00\u5f62\u5f0f\u5316\u63d0\u51fa\u4e86\u4e00\u79cd\u5bf9\u56fe\u5f62\u5316\u7684UML\u72b6\u6001\u673a\u89c6\u56fe\u6a21\u578b\u7684\u5f62\u5f0f\u5316\u548cRSL\u89c4\u8303\u8fdb\u884c\u96c6\u6210\u7684\u6846\u67b6,\u8fd9\u4e00\u5de5\u4f5c\u662f\u5bf9UML\u7c7b\u56fe\u5728RSL\u4e2d\u5f62\u5f0f\u5316\u7684\u7ee7\u7eed,\u4f7f\u5f97\u4eba\u4eec\u53ef\u4ee5\u5bf9UML\u7684\u975e\u5f62\u5f0f\u5316\u6a21\u578b\u7ed9\u51fa\u4e00\u79cd\u7cbe\u786e,\u65e0\u4e8c\u4e49\u6027\u7684\u8bed\u4e49\u89e3\u91ca,\u540c\u65f6\u4e5f\u63d0\u9ad8\u4e86RSL\u89c4\u8303\u7684\u62bd\u8c61\u5c42\u6b21,\u589e\u5f3a\u4e86\u5176\u53ef\u8bfb\u6027,\u7b80\u660e\u6027.\u6700\u540e\u901a\u8fc7\u4e00\u4e2a\u5e94\u7528\u5b9e\u4f8b,\u8bf4\u660e\u8fd9\u4e00\u6846\u67b6\u5982\u4f55\u7528\u4e8e\u4eceUML\u6a21\u578b\u521b\u5efa\u5bf9\u5e94\u7684\u5f62\u5f0f\u5316\u89c4\u8303,\u5e76\u5bf9\u6a21\u578b\u7684\u6027\u8d28\u8fdb\u884c\u4e86\u5206\u6790.", "num_citations": "2\n", "authors": ["2024"]}
{"title": "The Commuting V-Diagram\n", "abstract": " This article discusses the relations between the step-wise development through refinement and the design of test-cases. It turns out that a commuting diagram inspired by the V-process model is able to clarify the issues involved. This V-diagram defines the dependencies of specifications, implementations and test-cases in the category of contracts. The objects in this category are contracts defined in the formalism of the refinement calculus. The maps are the refinement steps between these objects. Our framework is able to define the correctness notion of test-cases, testing strategies as refinement rules, and which test-cases should be added under refinement.", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Open source software: challenges and prospects for developing countries\n", "abstract": " Open Source Software: challenges and prospects for developing countries \u2014 Graz University of Technology Skip to main navigation Skip to search Skip to main content Graz University of Technology Logo English Deutsch Home Persons Research Units Research Outputs Projects Activities Prizes Press / Media Open Source Software: challenges and prospects for developing countries Bernhard Aichernig Institute of Software Technology (7160) Research output: Contribution to journal \u203a Article \u203a Research Overview Original language English Pages (from-to) 8-10 Journal Technology policy briefs Volume 2 Issue number 2 Publication status Published - 2003 Treatment code (N\u00e4here Zuordnung) Popular Scientific Access to Document http://www.intech.unu.edu/publications/technology_policy/tpbs_2002_2004.php Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Aichernig, B. (2003). Open Source Software\u2026", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Modeling and validating hybrid systems using VDM and Mathematica\n", "abstract": " Hybrid systems are characterized by the hybrid evolution of their state: A part of the state changes discretely, the other part changes continuously over time. Typically, modern control applications belong to this class of systems, where a digital controller interacts with a physical environment. In this article we illustrate how a combination of the formal method VDM and the computer algebra system Mathematica can be used to model and simulate both aspects: the control logic and the physics involved. A new Mathematica package emulating VDM-SL has been developed that allows the in-tegration of differential equation systems into for-mal specifications. The SAFER example from (11) serves to demonstrate the new simulation capabili-ties Mathematica adds: After the thruster selection process, the astronaut\u2019s actual position and velocity is calculated by numerically solving Euler's and", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Softwareentwicklung\u2014eine Ingenieursdisziplin!(?)\n", "abstract": " Reference: BK Aichernig and P. Lucas. Softwareentwicklung--eine Ingenieursdisziplin!(?). Telematik, Zeitschrift des Telematik-Ingenieur-Verbandes (TIV), 4 (2): 2-8, 1998. ISSN 1028-5068.", "num_citations": "2\n", "authors": ["2024"]}
{"title": "Step-wise development of provably correct actor systems\n", "abstract": " Concurrent and distributed software is widespread, but is inherently complex. The Actor model avoids the common pitfall of shared mutable state and interprocess communication is done via asynchronous message passing. Actors are used in Erlang, the Akka framework, and many others. In this paper we discuss the formal development of actor systems via refinement. We start with an abstract specification and introduce details until the final model can be translated into an actor program. In each refinement, we show that the abstract properties are still preserved. Agha\u2019s classical factorial algorithm serves as a demonstrating example. To the best of our knowledge we are the first who formally prove that his actor system computes factorials. We use Event-B as a modelling language together with interactive theorem proving and SMT solving for verification.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "A Formal Modeling Approach for Portable Low-Level OS Functionality\n", "abstract": " The increasing dependability requirements and hardware diversity of the Internet of Things (IoT) pose a challenge to developers. New approaches for software development that guarantee correct implementations will become indispensable. Specially for Real Time Operating Systems (RTOSs), automatic porting for all current and future devices will also be required. As part of our framework for embedded RTOS portability, based on formal methods and code generation, we present our approach to formally model low-level operating-system functionality using Event-B . We show the part of our RTOS model where the switch into the kernel and back to a task happens, and prove that the model is correct according to the specification. Hardware details are only introduced in late refinements, which allows us to reuse most of the RTOS model and proofs for several target platforms. As a proof of concept, we refine the\u00a0\u2026", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Predicting and testing latencies with deep learning: An iot case study\n", "abstract": " The Internet of things (IoT) is spreading into the everyday life of millions of people. However, the quality of the underlying communication technologies is still questionable. In this work, we are analysing the performance of an implementation of MQTT, which is a major communication protocol of the IoT. We perform model-based test-case generation to generate log data for training a neural network. This neural network is applied to predict latencies depending on different features, like the number of active clients. The predictions are integrated into our initial functional model, and we exploit the resulting timed model for statistical model checking. This allows us to answer questions about the expected performance for various usage scenarios. The benefit of our approach is that it enables a convenient extension of a functional model with timing aspects using deep learning. A comparison to our previous work\u00a0\u2026", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Programming behavioral test models for SMT solving in Scala\n", "abstract": " We present a novel approach for modeling cyber-physical systems for analysis and test purposes. Instead of creating a new expressive specification language with sophisticated semantics and complex compilers, we rely on a lightweight version of Back's Action Systems, for which we provide a simple bounded model checker using the SMT solver Z3. In order to model industrial-sized embedded systems, we extend our simple specification language by using the powerful capa-bilities of the modern programming language Scala for creating Domain Specific Languages (DSL). This enables us to use the features of an expressive, object-oriented and functional generalpurpose language without the need to increase the complexity of the model checker. We demonstrate how to model a railway interlocking system with a configurable track layout and sketch the application to model-based testing.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Software engineering and formal methods\n", "abstract": " The 13th edition of the International Conference on Software Engineering and Formal Methods (SEFM) was held in York, UK, during September 7\u201311, 2015. The conference brought together researchers and practitioners from academia, industry, and government to advance the state of the art in formal methods, to facilitate their uptake in the software industry, and to encourage their integration within practical software engineering methods and tools.Authors were invited to submit full research papers describing original research results, case studies, and tools; and short new ideas/work-in-progress papers describing new approaches, techniques, and/or tools not fully validated yet. The topics of interest included the following aspects of software engineering and formal methods:", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Model-Based Mutation Testing: Theory and Application\n", "abstract": " Model-Based Mutation Testing: Theory and Application \u2014 Graz University of Technology Skip to main navigation Skip to search Skip to main content Graz University of Technology Logo English Deutsch Home Persons Research Units Research Outputs Projects Activities Prizes Press / Media Search by expertise, name or affiliation Model-Based Mutation Testing: Theory and Application Bernhard Aichernig Institute of Software Technology (7160) Research output: Thesis \u203a Habilitation Overview Original language English Publication status Published - 2012 Fields of Expertise Information, Communication & Computing Treatment code (N\u00e4here Zuordnung) Application Theoretical Cite this APA Standard Harvard Vancouver Author BIBTEX RIS Aichernig, B. (2012). Model-Based Mutation Testing: Theory and Application. Model-Based Mutation Testing: Theory and Application. / Aichernig, Bernhard. 2012. Research output: \u2026", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Exploiting distribution and atomic transactions for partial order reduction\n", "abstract": " We present a method for systematic examination and reduction of the state space of distributed systems. The approach exploits properties of distributed systems to partition processes into atomic transitions and uses observations about partial orders among the distributed components to perform dynamic partial order reduction for state space reduction. This report concentrates on preserving reachability checks and deadlock detection for a fixed input of the system. We present a search algorithm with a succinct representation of the search stack that requires only the current state in memory. We furthermore define characteristics to determine independent blocks of processes and propose and evaluate heuristics to guide the search to further state space reduction. In combination with dynamic symbolic execution (also known as concolic execution), the approach also allows the generalization of a concrete run and gives rise to examination of the full input state space of a distributed system.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Towards an Improved Computing Curriculum for San Pablo Catholic University in Peru\n", "abstract": " This report shows the analysis of the current curriculum at San Pablo Catholic University in order to identify possibles areas that could be improved. This analysis is based on the CC2001 curricula recommendations, and on the study of the characteristics of undergraduate CS curricula in two leading universities. As a result of this analysis we present 15 concrete recommendations in order to improve the current curriculum.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "When specification-based testing fails\n", "abstract": " Armando Haeberer made a substantial contribution in translating results from the philosophy of science to software testing. He showed that the limits of the standard methodology of confirming theories, where observations are derived from the theory and hypothesis, are also present in software testing. He strongly criticized Gaudel\u2019s classical approach on test case generation, but also supplied an alternative based on Glymour\u2019s bootstrap approach. However, the debate that one would expect after his contribution never really happened. This is especially astonishing since most of the specification-based testing approaches follow the method he criticized. This paper aims to open the debate by looking on his findings from a fresh point of view. We use the concept of refinement to clarify the fundamental issues involved in testing and discuss the practical consequences.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "J. UCS Special Issue in Honor of Professor Peter Lucas\n", "abstract": " The present special issue of J. UCS is a collection of papers presented at the colloquium Formal Aspects of Software Engineering which took place on the 18th and 19th of May 2001 in Graz, Austria. The colloquium was held to mark the retirement of Professor Peter Lucas from his chair in Software Technology at the Graz University of Technology.The subject of the colloquium is the central area of research of Peter and his institute. In scientific talks, several of Peter's colleagues and friends have presented their view on the past, present and future of formal development methods in software engineering. The topics cover a broad range of the field, such as re-engineering using algebraic methods, testing based on abstraction techniques, modeling in category theory, development tools, parallel computing, and education.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Requirements Validation of a Voice Communication System Used in Air Traffic Control.\n", "abstract": " During the last few years light-weight approaches to formal development methods have been proposed in order to facilitate the technological transfer of these techniques. This article presents the results and experiences gained in an industrial project, in which VDM++ has been applied to specify a safety critical voice communication system for air-traffic control. It is shown that an executable VDM++ model can be used to raise both, the level of quality of the informal system specification, as well as the efficiency of existing system test-suites. Furthermore, a selected change request serves to demonstrate how maintenance is supported by a formal model. For all the tasks in the project, precise time-effort figures are presented.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Property orientation in the model oriented vienna development method (vdm)\n", "abstract": " Formal development methods can be divided into property oriented and model oriented approaches. The Vienna Development Method (VDM) is model oriented in the sense that systems are modelled by means of prede ned mathematical objects like sets, sequences and nite mappings. However, property oriented speci cation techniques claim to have several advantages, such as to result in more abstract system descriptions. In this paper an integration of a property oriented specication style into VDM is presented. It is demonstrated that property oriented descriptions come for free, without the need for changing the ISO standardised VDM-speci cation language (VDM-SL). Only minor changes for syntactic sugar are proposed. Combining the two paradigms results in several new applications in the area of re nement. Examples serve to demonstrate the general applicability of the techniques.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Executable specifications in software reliability engineering\n", "abstract": " \\When formal methods are in full swing, formal design proofs might be available to achieve mathematical proof of correctness for programs. Also, faultmonitoring assertions could be employed through executable speci cations, and test-cases could be automatically generated to achieve e cient software veri cation.\" In the following, so called light-weight applications of formal methods to Software Reliability Engineering (SRE) 10] are examined.'Light-weight'means that not correctness proofs are in the center of interest, but the modeling process and the execution of functional speci cations. The Vienna Development Method (VDM) 7, 3] will serve to demonstrate that today's formal methods are mature enough to serve SRE as a complementary tool.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "A telephone exchange specification in VDM-SL\n", "abstract": " The following example has been taken out of 1] and has been translated from the B-notation into VDM-SL 2, 3]. It demonstrates how an event-based system may be modeled using the speci cation language of the Vienna Development Method. In the following, operations specify the events which can be initiated either by the system or by a subscriber (user). An implicit style using pre-and post-conditions has been chosen, in order to model the system's state transitions. The model of the telephone exchange is centred around a set of subscribers who may be engaged in telephone conversations through a network controlled by an exchange.", "num_citations": "1\n", "authors": ["2024"]}
{"title": "Teaching programming to the uninitiated using Mathematica\n", "abstract": " In October 1997 an experiment was started to use Mathematica 4] in order to teach programming to rst year students of Technical Mathematics. In the rst semester the programming course focused on functional programming. The contents were determined by a parallel computer science course, where the programming language SML 3] was used as the basic notation. In this paper the experiences of using Mathematica to teach programming are outlined. Especially, a survey is given how the basic concepts and features of a standard functional programming language like SML are provided by Mathematica.", "num_citations": "1\n", "authors": ["2024"]}