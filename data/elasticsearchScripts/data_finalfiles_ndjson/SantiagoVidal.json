{"title": "Producing just enough documentation: The next sad version problem\n", "abstract": " Software architecture knowledge is an important asset in today\u2019s projects, as it serves to share the main design decisions among the project stakeholders. Architectural knowledge is commonly captured by the Software Architecture Document (SAD), an artifact that is useful but can also be costly to produce and maintain. In practice, the SAD often fails to fulfill its mission of addressing the stakeholders\u2019 information needs, due to factors such as: detailed or high-level contents that do not consider all stakeholders, outdated documentation, or documentation generated late in the lifecycle, among others. To alleviate this problem, we propose a documentation strategy that seeks to balance the stakeholders\u2019 interests in the SAD against the efforts of producing it. Our strategy is cast as an optimization problem called \u201dthe next SAD version problem\u201d (NSVP) and several search-based techniques for it are discussed. A\u00a0\u2026", "num_citations": "7\n", "authors": ["818"]}
{"title": "Algoritmos de resoluci\u00f3n para el cubo de Rubik\n", "abstract": " El objetivo de este trabajo fue dise\u00f1ar e implementar un algoritmo que resuelva el problema de armar el cubo de Rubik (o cubo m\u00e1gico), dada cualquiera de las m\u00e1s de 43 trillones de posibles configuraciones de \u00e9ste. Para esto se realiz\u00f3 un trabajo de investigaci\u00f3n mediante el cual se procedi\u00f3 a delinear los pasos para un algoritmo basado en la t\u00e9cnica de Backtracking. Se analizaron distintas heur\u00edsticas para reducir el espacio de b\u00fasqueda y as\u00ed obtener un algoritmo m\u00e1s eficiente.No estando totalmente satisfechos con esta primera soluci\u00f3n, se implement\u00f3 un segundo programa del mismo tipo, aunque mucho m\u00e1s complejo y sofisticado que logr\u00f3 reducir a la mitad la cantidad de movimientos en los cuales se arma el cubo. Se describe en este trabajo las dos soluciones propuestas y una comparaci\u00f3n entre ambas. Para darle una funcionalidad real al programa se le provee al usuario la posibilidad de cargar cualquier cubo mediante una interfaz gr\u00e1fica amigable. Cabe destacar que esta carga va acompa\u00f1ada de un conjunto complejo de comprobaciones que cerciora configuraciones v\u00e1lidas. Este trabajo fue realizado como proyecto final para una materia que introduce en el an\u00e1lisis y el dise\u00f1o de algoritmos. La misma es dictada en segundo a\u00f1o de una carrera de Inform\u00e1tica. El lenguaje utilizado para la implementaci\u00f3n fue C++ y el entorno de desarrollo Borland Builder C++.", "num_citations": "5\n", "authors": ["818"]}