{"title": "Automated behavioral testing of refactoring engines\n", "abstract": " Refactoring is a transformation that preserves the external behavior of a program and improves its internal quality. Usually, compilation errors and behavioral changes are avoided by preconditions determined for each refactoring transformation. However, to formally define these preconditions and transfer them to program checks is a rather complex task. In practice, refactoring engine developers commonly implement refactorings in an ad hoc manner since no guidelines are available for evaluating the correctness of refactoring implementations. As a result, even mainstream refactoring engines contain critical bugs. We present a technique to test Java refactoring engines. It automates test input generation by using a Java program generator that exhaustively generates programs for a given scope of Java declarations. The refactoring under test is applied to each generated program. The technique uses SafeRefactor\u00a0\u2026", "num_citations": "150\n", "authors": ["801"]}
{"title": "Making program refactoring safer\n", "abstract": " Developers rely on compilation, test suites, and tools to preserve observable behavior during refactoring. However, most refactoring tools don't implement all the preconditions that guarantee refactoring correctness because formally identifying them is cost-prohibitive. Therefore, these tools could perform nonbehavior-preserving transformations. The authors present a tool for improving safety during refactoring that automatically generates a test suite suited for detecting behavioral changes. They used this tool to evaluate seven real case study refactorings (from 3 to 100 KLOC).", "num_citations": "139\n", "authors": ["801"]}
{"title": "A procedure to detect problems of processes in software development projects using Bayesian networks\n", "abstract": " There are several software process models and methodologies such as waterfall, spiral and agile. Even so, the rate of successful software development projects is low. Since software is the major output of software processes, increasing software process management quality should increase the project\u2019s chances of success. Organizations have invested to adapt software processes to their environments and the characteristics of projects to improve the productivity and quality of the products. In this paper, we present a procedure to detect problems of processes in software development projects using Bayesian networks. The procedure was successfully applied to Scrum-based software development projects. The research results should encourage the usage of Bayesian networks to manage software processes and increase the rate of successful software development projects.", "num_citations": "85\n", "authors": ["801"]}
{"title": "Comparing approaches to analyze refactoring activity on software repositories\n", "abstract": " Some approaches have been used to investigate evidence on how developers refactor their code, whether refactorings activities may decrease the number of bugs, or improve developers\u2019 productivity. However, there are some contradicting evidence in previous studies. For instance, some investigations found evidence that if the number of refactoring changes increases in the preceding time period the number of defects decreases, different from other studies. They have used different approaches to evaluate refactoring activities. Some of them identify committed behavior-preserving transformations in software repositories by using manual analysis, commit messages, or dynamic analysis. Others focus on identifying which refactorings are applied between two programs by using manual inspection or static analysis. In this work, we compare three different approaches based on manual analysis, commit message\u00a0\u2026", "num_citations": "47\n", "authors": ["801"]}
{"title": "Learning quick fixes from code repositories\n", "abstract": " Code analyzers such as Error Prone and FindBugs detect code patterns symptomatic of bugs, performance issues, or bad style. These tools express patterns as quick fixes that detect and rewrite unwanted code. However, it is difficult to come up with new quick fixes and decide which ones are useful and frequently appear in real code. We propose to rely on the collective wisdom of programmers and learn quick fixes from revision histories in software repositories. We present REVISAR, a tool for discovering common Java edit patterns in code repositories. Given code repositories and their revision histories, REVISAR (i) identifies code edits from revisions and (ii) clusters edits into sets that can be described using an edit pattern. The designers of code analyzers can then inspect the patterns and add the corresponding quick fixes to their tools. We ran REVISAR on nine popular GitHub projects, and it discovered 89 useful edit patterns that appeared in 3 or more projects. Moreover, 64% of the discovered patterns did not appear in existing tools. We then conducted a survey with 164 programmers from 124 projects and found that programmers significantly preferred eight out of the nine of the discovered patterns. Finally, we submitted 16 pull requests applying our patterns to 9 projects and, at the time of the writing, programmers accepted 6 (60%) of them. The results of this work aid toolsmiths in discovering quick fixes and making informed decisions about which quick fixes to prioritize based on patterns programmers actually apply in practice.", "num_citations": "36\n", "authors": ["801"]}
{"title": "Analyzing refactorings on software repositories\n", "abstract": " Currently analysis of refactoring in software repositories is either manual or only syntactic, which is time-consuming, error-prone, and non-scalable. Such analysis is useful to understand the dynamics of refactoring throughout development, especially in multi-developer environments, such as open source projects. In this work, we propose a fully automatic technique to analyze refactoring frequency, granularity and scope in software repositories. It is based on SAFEREFACTOR, a tool that analyzes transformations by generating tests to detect behavioral changes - it has found a number of bugs in refactoring implementations within some IDEs, such as Eclipse and Netbeans. We use our technique to analyze five open source Java projects (JHotDraw, ArgoUML, SweetHome 3D, HSQLDB and jEdit). From more than 40,723 software versions, 39 years of software development, 80 developers and 1.5 TLOC, we have\u00a0\u2026", "num_citations": "30\n", "authors": ["801"]}
{"title": "ASAP-V: A privacy-preserving authentication and sybil detection protocol for VANETs\n", "abstract": " Node authentication, non-repudiation and anonymous communication are key roles to provide security in Vehicular Ad Hoc Networks (VANETs). On the other hand, the trade-off between authentication/non-repudiation and anonymous communication may lead to a harmful type of network attack called sybil attack. In such an attack, a malicious node behaves as if it is a large number of nodes. In this paper, we propose an anonymous authentication and sybil attack detection protocol for VANETs called ASAP-V. Experimental results suggest that ASAP-V\u00a0is more robust against sybil attacks, with lower average detection time than the state-of-art works, also without false-positive and false-negative detections.", "num_citations": "25\n", "authors": ["801"]}
{"title": "Making software product line evolution safer\n", "abstract": " Developers evolve software product lines (SPLs) manually or using typical program refactoring tools. However, when evolving a product line to introduce new features or to improve its design, it is important to make sure that the behavior of existing products is not affected. Typical program refactorings cannot guarantee that because the SPL context goes beyond code and other kinds of core assets, and involves additional artifacts such as feature models and configuration knowledge. Besides that, in a SPL we typically have to deal with a set of possibly alternative assets that do not constitute a well-formed program. As a result, manual changes and existing program refactoring tools may introduce behavioral changes or invalidate existing product configurations. To avoid that, we propose approaches and implement tools for making product line evolution safer; these tools check whether SPL transformations are\u00a0\u2026", "num_citations": "16\n", "authors": ["801"]}
{"title": "Saferefactor-tool for checking refactoring safety\n", "abstract": " Despite several evidences that refactorings are not sound and safe, refactoring tools are widely used and trusted upon. Several evidences have been published that these tools may perform erroneous transformations that do not preserve behavior. In order to detect some of these errors, developers may rely on compilation and tests to attest that behavior is preserved. Compilation errors, for instance, are simple to identify. However, changes in behavior very often go undetected. In this paper, we present SAFEREFACTOR\u2013an Eclipse plugin to identify behavioral changes in transformations. We evaluate it against 9 transformations (5 of them do not preserve behavior and are not detected by the best program refactoring tools). Our tool has been successful in detecting all behavioral changes and not producing false alarms.", "num_citations": "14\n", "authors": ["801"]}
{"title": "Generating unit tests for checking refactoring safety\n", "abstract": " Program refactorings in IDEs are commonly implemented in an ad hoc way, since checking correctness with respect to a formal semantics is prohibitive. These tools may perform erroneous transformations, not preserving behavior. In order to detect these errors, developers rely on compilation and tests to attest that behavior is preserved. Compilation errors, for instance, are simple to identify by tools. However, changes in behavior very often go undetected. We propose a technique for generating a test suite that is specific to pinpoint incorrect refactorings. In each refactoring, we identify program parts that are common to the program before and after refactoring, and automatically generate a comprehensive set of unit tests for the initial program aided by a test generator. As such, the create test suite is run on the program before and after automatic refactoring, which does not require also to refactor the test suite itself in our technique, as may occur sometimes in traditional refactoring scenarios. Our technique is evaluated against a benchmark of 16 refactoring cases which present errors when performed by mainstream refactoring tools. This evaluation has been successful in detecting more than 93% of those errors.", "num_citations": "13\n", "authors": ["801"]}
{"title": "Live feedback on behavioral changes\n", "abstract": " The costs to find and fix bugs grows over time, to the point where fixing a bug after release may cost as much as 100 times more than before release. To help programmers find bugs as soon as they are introduced, we sketch a plugin for an integrated development environment that provides live feedback about behavioral changes to Java programs by continuously generating tests, running the tests on the current and previous versions of the program, and comparing the results. Such a tool would allow programmers to better understand how their changes affect the behavior of their programs. As a proof of concept, we developed a prototype that found a bug that remained undetected by pair programmers working on JHotDraw in a previous study. Had the programmers performed this change with our plugin, they would have been notified about the bug as soon as they introduced it.", "num_citations": "9\n", "authors": ["801"]}
{"title": "An admission control mechanism for dynamic QoS-enabled opportunistic routing protocols\n", "abstract": " Opportunistic routing has gained much attention as a new and promising approach to relay packets in wireless mesh networks. The collaboration of intermediate nodes to deliver packets without a predetermined route, using the broadcast nature of wireless channel, increases the transmission reliability and network throughput. Nevertheless, such characteristics make the process of admission control even more challenging than in a traditional unipath routing protocol. In this paper, we propose an admission control mechanism for quality of service (QoS)-enabled opportunistic routing protocols. This mechanism performs admission control and resource reservation in multiple neighbors according to their importance for the relaying process. We also consider the influence of using thresholds for QoS parameters in order to improve the service provided to adaptive applications. Simulation results allow us to reach two\u00a0\u2026", "num_citations": "8\n", "authors": ["801"]}
{"title": "JMLOK: Uma Ferramenta para Verificar Conformidade em Programas Java/JML\n", "abstract": " It is non-trivial to verify whether a Java code is in conformance with its JML specification. Usually, developers perform this task by manual reasoning, which is error-prone and time-consuming, or by including assertions in the compiled Java code. However, these assertions may not be sufficiently exercised, then problems arise when the system is in production. We implemented JMLOK to identify non-conformances between Java code and its JML specification by randomly generating unit tests. We evaluate JMLOK in toy examples and real case studies, finding 13 non-conformances. Even in toy examples presented in the literature, we found non-conformances between programs and specifications.", "num_citations": "6\n", "authors": ["801"]}
{"title": "Making aspect-oriented refactoring safer\n", "abstract": " Developers may refactor part of the object-oriented (OO) code into aspects in order to improve modularity. However, since most refactoring tools have a limited or no support for aspect-oriented (AO) constructs, developers have to apply manual steps. Even the aspect-aware refactorings contain bugs. Developers need a better support for making AO refactorings safer. In this paper, we propose a tool for evaluating whether AspectJ transformations preserve behavior. We evaluate it in 8 non-behavior-preserving transformations applied by Eclipse. Our tool detected all of them. Additionally, we compared the OO version and its refactored AO version of two real case studies. Our tool found a nonbehavior-preserving transformation. We also analyzed 23 design patterns implemented in Java and AspectJ. Our tool identified that the AO and OO versions of the State pattern are not equivalent. Finally we evaluated two JML compilers that generate AO code. Our tool identified a bug in one of them.", "num_citations": "5\n", "authors": ["801"]}
{"title": "A Toolset for Checking SPL Refinements.\n", "abstract": " Developers evolve software product lines (SPLs) manually or using typical program refactoring tools. However, when evolving an SPL to introduce new features or to improve its design, it is important to make sure that the behavior of existing products is not affected. Typical program refactorings cannot guarantee that because the SPL context goes beyond code and other kinds of core assets, and involves additional artifacts such as feature models and configuration knowledge. Besides that, we typically have to deal with a set of alternative assets that do not constitute a well-formed program in an SPL. As a result, manual changes and existing program refactoring tools may introduce behavioral changes or invalidate existing product configurations. To reduce such risks, we propose approaches and implement four tools for making product line evolution safer. These tools check if SPL transformations preserve the\u00a0\u2026", "num_citations": "4\n", "authors": ["801"]}