{"title": "TGV: theory, principles and algorithms\n", "abstract": " This paper presents the TGV tool, which allows for the automatic synthesis of conformance test cases from a formal specification of a (non-deterministic) reactive system. TGV was developed by Irisa Rennes and Verimag Grenoble, with the support of the Vasy team of Inria Rh\u00f4nes-Alpes. The paper describes the main elements of the underlying testing theory, which is based on a model of transitions system which distinguishes inputs, outputs and internal actions, and is based on the concept of conformance relation. The principles of the test synthesis process, as well as the main algorithms, are explained. We then describe the main characteristics of the TGV tool and refer to some industrial experiments that have been conducted to validate the approach. As a conclusion, we describe some ongoing work on test synthesis.", "num_citations": "535\n", "authors": ["1053"]}
{"title": "Using on-the-fly verification techniques for the generation of test suites\n", "abstract": " In this paper we attempt to demonstrate that on-the-fly techniques, developed in the context of verification, can help in deriving test suites. Test purposes are used in practice to select test cases according to some properties of the specification. We define a consistency pre-order linking test purposes and specifications. We give a set of rules to check this consistency and to derive a complete test case with preamble, postamble, verdicts and timers. The algorithm, which implements the construction rules, is based on a depth first traversal of a synchronous product between the test purpose and the specification. We shortly relate our experience on an industrial protocol with TGV, a first prototype of the algorithm implemented as a component of the C ADP toolbox.", "num_citations": "281\n", "authors": ["1053"]}
{"title": "An experiment in automatic generation of test suites for protocols with verification technology\n", "abstract": " In this paper we describe an experiment in automatic generation of test suites for protocol testing. We report the results gained with generation of test suites based on advanced verification techniques applied to a real industrial protocol. In this experiment, several tools have been used: the commercial tool GEODE (VERILOG) was used for the generation of finite state graph models from SDL specifications, the tool Aldebaran of the CADP toolbox for the minimization of transition systems, and a prototype named TGV (for Test Generation using Verification techniques) for the generation of test suites which has been developed in the CADP toolbox. TGV is based on verification techniques such as synchronous product and on-the-fly verification. These tools have been applied to an industrial protocol, the DREX protocol. The comparison of produced test suites with hand written test suites proves the relevance of the used\u00a0\u2026", "num_citations": "210\n", "authors": ["1053"]}
{"title": "STG: A symbolic test generation tool\n", "abstract": " We report on a tool we have developed that implements conformance testing techniques to automatically derive symbolic tests cases from formal operational specifications. We demonstrate the application of the techniques and tools on a simple example and present case studies for the CEPS (Common Electronic Purse Specification) and for the file system of the 3GPP (Third Generation Partnership Project) card.", "num_citations": "160\n", "authors": ["1053"]}
{"title": "An approach to symbolic test generation\n", "abstract": " Test generation is a program-synthesis problem: starting from the formal specification of a system under test, and from a test purpose describing a set of behaviours to be tested, compute a reactive program that observes an implementation of the system to detect non- conformant behaviour, while trying to control it towards satisfying the test purpose. In this paper we describe an approach for generating sym- bolic test cases, in the form of input-output automata with variables and parameters.", "num_citations": "158\n", "authors": ["1053"]}
{"title": "Supervision patterns in discrete event systems diagnosis\n", "abstract": " In this paper, we are interested in the diagnosis of discrete event systems modeled by finite transition systems. We propose a model of supervision patterns general enough to capture past occurrences of particular trajectories of the system. Modeling the diagnosis objective by a supervision pattern allows us to generalize the properties to be diagnosed and to render them independent of the description of the system. We first formally define the diagnosis problem in this context. We then derive techniques for the construction of a diagnoser and for the verification of the diagnosability based on standard operations on transition systems. We show that these techniques are general enough to express and solve in a unified way a broad class of diagnosis problems found in the literature, e.g. diagnosing permanent faults, multiple faults, fault sequences and some problems of intermittent faults", "num_citations": "155\n", "authors": ["1053"]}
{"title": "Test generation derived from model-checking\n", "abstract": " Model-checking and testing are different activities, at least conceptually. While model-checking consists in comparing two specifications at different abstraction levels, testing consists in trying to find errors or gain some confidence in the correctness of an implementation with respect to a specification by the execution of test cases. Nevertheless, there are also similarities in models and algorithms. We argue for this by giving a new on-the-fly test generation algorithm which is an adaptation of a classical graph algorithm which also serves as a basis of some model-checking algorithms. This algorithm is the Tarjan\u2019s algorithm which computes the strongly connected components of a digraph.", "num_citations": "154\n", "authors": ["1053"]}
{"title": "Bounded-memory Algorithms for Verification On-the-fly\n", "abstract": " Program verification is a branch of computer science whose business is\" to prove programs correctness\". It has been studied in theoretical computer science departments for a long time but it is rarely and laboriously applied to real world problems. As a matter of fact, we must pay much more attention to practical problems like the amount of space and time needed to perform verification. Let us recall that proofs of correctness are proofs of the relative consistency between two formal specifications: those of the program, and of the properties that the program is supposed to satisfy. Such a formal proof tries to increase the confidence that a computer system will make it right when executing the program under consideration.A considerable need for such methods appeared these last ten years in different domains, such as design of asynchronous circuits, communication protocols and distributed software in general. A lot of\u00a0\u2026", "num_citations": "114\n", "authors": ["1053"]}
{"title": "Symbolic test selection based on approximate analysis\n", "abstract": " This paper addresses the problem of generating symbolic test cases for testing the conformance of a black-box implementation with respect to a specification, in the context of reactive systems. The challenge we consider is the selection of test cases according to a test purpose, which is here a set of scenarios of interest that one wants to observe during test execution. Because of the interactions that occur between the test case and the implementation, test execution can be seen as a game involving two players, in which the test case attempts to satisfy the test purpose.               Efficient solutions to this problem have been proposed in the context of finite-state models, based on the use of fixpoint computations. We extend them in the context of infinite-state symbolic models, by showing how approximate fixpoint computations can be used in a conservative way. The second contribution we provide is the\u00a0\u2026", "num_citations": "103\n", "authors": ["1053"]}
{"title": "On-line model-checking for finite linear temporal logic specifications\n", "abstract": " If we restrict our attention to finite state programs (variables and communication channels if any range over finite domains), then the whole program can be represented as a (generally large) finite graph. Each transition of this state graph is valued with the atomic action which has just changed the state. Consequently, a finite state program can be viewed as a finite model over which temporal formulas can be evaluated. Checking that a given finite model satisfies a given temporal formula is what one calls\" model-checking\". We consider the linear time version of temporal logic (LTL) and atomic propositions as actions [16]. Our terminology is no essential restriction and simplifies the transition to the automata framework we use thereafter. Models for linear logic are totally ordered computations. We restrict our attention to finite computations. Extension to the infinite case will be discussed. Classical model-checking as\u00a0\u2026", "num_citations": "102\n", "authors": ["1053"]}
{"title": "On-the-fly verification of finite transition systems\n", "abstract": " The analysis of programs by the exhaustive inspection of reachable states in a finite-state graph is a well-understood procedure. It is straightforwardly applicable to many description languages and is actually implemented in several industrial tools. But one of the main limitations of today's verification tools is the size of the memory needed to exhaustively build the state graphs of the programs. For numerous properties, it is not necessary to explicitly build this graph; an exhaustive depth-first traversal is often sufficient. This leads to an on-line algorithms for computing B\u00fcchi acceptance (in the deterministic case) and behavioral equivalences: they are presented in detail. In order to avoid retraversing states, it is, however, important to store some of the already visited states in memory. To keep the memory size bounded (and avoid a performance falling down), visited states are randomly replaced. In most cases\u00a0\u2026", "num_citations": "97\n", "authors": ["1053"]}
{"title": "Automated test generation from SDL specifications\n", "abstract": " Automated test generation from formal specifications presents a lot of promises, either in cost control or test suite correctness. Some interesting tools begin to emerge, either prototypes or industrial strength tools. We present the result of the integration in ObjectGEODE of an industrial test generation tool1. This tool is based on two complementary test generation prototypes, TVEDA and TGV. TVEDA comes from the research laboratory France-Telecom-CNET, it provides for test purposes and test case generation, based on state space exploration combined with heuristics. TGV has been designed in the research laboratories Irisa and Verimag, it provides test case generation based on efficient, on-the-fly state space exploration techniques.", "num_citations": "83\n", "authors": ["1053"]}
{"title": "Integrating formal verification and conformance testing for reactive systems\n", "abstract": " In this paper, we describe a methodology integrating verification and conformance testing. A specification of a system - an extended input-output automaton, which may be infinite-state - and a set of safety properties (\"nothing bad ever happens\") and possibility properties (\"something good may happen\") are assumed. The properties are first tentatively verified on the specification using automatic techniques based on approximated state-space exploration, which are sound, but, as a price to pay for automation, are not complete for the given class of properties. Because of this incompleteness and of state-space explosion, the verification may not succeed in proving or disproving the properties. However, even if verification did not succeed, the testing phase can proceed and provide useful information about the implementation. Test cases are automatically and symbolically generated from the specification and the\u00a0\u2026", "num_citations": "78\n", "authors": ["1053"]}
{"title": "Remote testing can be as powerful as local testing\n", "abstract": " Designing test cases for remote asynchronous testing is error-prone. This is due to the difficulty to foresee all the disorders on the observations collected by the tester as well as the possible collisions between stimuli and observations. Designing correct synchronous test cases is easier, but transforming,them into correct asynchronous ones is a difficult task. Moreover, it is difficult to compare remote testing and local testing as in general sets of conformant implementations are not comparable.                 In this paper, we prove that by the use of logical stamps, remote testing can gain the same power as local testing: the conformant implementations in an asynchronous environment are exactly the same ones as in a synchronous environment. We give an operational method to derive the correct test cases for remote testing with this testing power. Furthermore, we show that test cases designed for a synchronous\u00a0\u2026", "num_citations": "77\n", "authors": ["1053"]}
{"title": "Predictability of sequence patterns in discrete event systems\n", "abstract": " The problem of predicting the occurrences of a pattern in a partially-observed discrete-event system is studied. The system is modeled by a labeled transition system. The pattern is a set of event sequences modeled by a finite-state automaton. The occurrences of the pattern are predictable if it is possible to infer about any occurrence of the pattern before the pattern is completely executed by the system. A novel off-line algorithm to verify the property of predictability is presented. The verification is polynomial in the number of states of the system. An on-line algorithm to track the execution of the pattern during the operation of the system is also presented. This algorithm is based on the use of a diagnoser automaton.", "num_citations": "73\n", "authors": ["1053"]}
{"title": "Using UML for automatic test generation\n", "abstract": " This paper presents an architecture for model-based testing using a profile of the Unified Modeling Language (UML). Class, object, and state diagrams are used to define essential models: descriptions that characterise the entire range of possible behaviours, in terms of the actions and events of the model. Object and state diagrams are used to introduce test directives.Models written in this profile may be compiled into a tool language: the Intermediate Format (IF). Descriptions written in IF can be animated, verified, and used to generate tests. As well as illustrating the testing tool adopted, the paper defines the profile for UML, explains testing directives, the basis of the compilation into IF and of the test generation process, and reports upon the problems encountered.", "num_citations": "66\n", "authors": ["1053"]}
{"title": "A general approach to trace-checking in distributed computing systems\n", "abstract": " The problem of checking the correctness of distributed computations arises when debugging distributed algorithms, and more generally when testing protocols or distributed applications. For that purpose, one describes the expected behavior (or suspected errors) by a global property: for example, a predicate on process variables, or the set of admissible orderings on observable events. The problem is to check whether this property is satisfied or not during the execution. A relevant model for this study is the partial order of message causality and the associated state graph, called \"lattice of consistent cuts\". In this paper, we propose a general approach to trace checking, based on partial order theory.< >", "num_citations": "63\n", "authors": ["1053"]}
{"title": "Testing for unboundedness of fifo channels\n", "abstract": " Undecidability of the unboundedness problem for specification models allowing fifo channels was proved a few years ago by Brand and Zafiropulo. The paper investigates a testing approach of that problem. Dealing with the general framework of systems communicating through fifo channels, we find a sufficient condition for unboundedness based on a relation between the nodes of the reachability tree. The construction of the resulting reduced tree can then be applied as well to communicating finite-state machines as to fifo nets. Moreover, the test extends existing decidability results. As a matter of fact, it becomes a decision procedure for a class of systems strictly including linear and monogeneous systems, which are the two essential classes in which decidability is already known. In order to conclude our study on a practical view, we show that a few modifications of the relation make the test available for Estelle\u00a0\u2026", "num_citations": "59\n", "authors": ["1053"]}
{"title": "Test cases generation for nondeterministic real-time systems\n", "abstract": " We study the generation of test cases for nondeterministic real-time systems. We define a class of Determinizable Timed Automata (DTA), in order to specify the system under test. The principle of our test method consists of two steps. In Step 1, we express the problem in a non-real-time form, by transforming a DTA into an equivalent finite state automaton. The latter uses two additional types of events, Set and Exp. In Step 2, we adapt a non-real-time test generation method.", "num_citations": "57\n", "authors": ["1053"]}
{"title": "Symbolic model-based test selection\n", "abstract": " This paper addresses the problem of model-based off-line selection of test cases for testing the conformance of a black-box implementation with respect to a specification, in the context of reactive systems. Efficient solutions to this problem have been proposed for LTS finite-state models, based on the ioco conformance testing theory. In this paper, the approach is extended for infinite-state specifications, modelled as automata extended with variables. When considering the selection of test cases according to test purposes (abstract scenarii focused by test cases), the selection of test cases relies on approximate co-reachability analyses using abstract interpretation and syntactical transformations guided by this analysis, while test execution uses constraint solving.", "num_citations": "48\n", "authors": ["1053"]}
{"title": "Automated test and oracle generation for smart-card applications\n", "abstract": " We present work we are engaged in to develop symbolic test generation techniques and apply those techniques to testing of smart card applications. Beginning with (1) a system specification and (2) a test purpose expressed as symbolic labelled-transition-systems, we automatically derive tests to check conformance of an implementation to the behaviors of the specification selected by the test purpose. We present an example taken from a case-study we are developing based on the application of these techniques to the CEPS e-purse specifications.", "num_citations": "45\n", "authors": ["1053"]}
{"title": "Verification of communication protocols using abstract interpretation of FIFO queues\n", "abstract": " We address the verification of communication protocols or distributed systems that can be modeled by Communicating Finite State Machines (CFSMs), i.e. a set of sequential machines communicating via unbounded FIFO channels. Unlike recent related works based on acceleration techniques, we propose to apply the Abstract Interpretation approach to such systems, which consists in using approximated representations of sets of configurations. We show that the use of regular languages together with an extrapolation operator provides a simple and elegant method for the analysis of CFSMs, which is moreover often as accurate as acceleration techniques, and in some cases more expressive. Last, when the system has several queues, our method can be implemented either as an attribute-independent analysis or as a more precise (but also more costly) attribute-dependent analysis.", "num_citations": "40\n", "authors": ["1053"]}
{"title": "A game approach to determinize timed automata\n", "abstract": " Timed automata are frequently used to model real-time systems. Their determinization is a key issue for several validation problems. However, not all timed automata can be determinized, and determinizability itself is undecidable. In this paper, we propose a game-based algorithm which, given a timed automaton with \u03b5-transitions and invariants, tries to produce a language-equivalent deterministic timed automaton, otherwise a deterministic over-approximation. Our method subsumes two recent contributions: it is at once more general than the determinization procedure of [4] and more precise than the approximation algorithm of [11].", "num_citations": "38\n", "authors": ["1053"]}
{"title": "Automatic verification and conformance testing for validating safety properties of reactive systems\n", "abstract": " This paper presents a combination of verification and conformance testing techniques for the formal validation of reactive systems. A formal specification of a system, which may be infinite-state, and a set of safety properties are assumed. Each property is verified on the specification using automatic techniques based on abstract interpretation, which are sound, but, as a price to pay for automation, are not necessarily complete. Next, for each property, a test case is automatically generated from the specification and the property, and is executed on a black-box implementation of the system to detect violations of the property by the implementation and non-conformances between implementation and specification. If the verification step did not conclude, the test execution may also detect violations of the property by the specification.", "num_citations": "38\n", "authors": ["1053"]}
{"title": "Towards automatic distribution of testers for distributed conformance testing\n", "abstract": " This paper presents first steps towards automatic generation of distributed tests. We first define a characterization of the tests for which the property of unbias is preserved by the existence of an asynchronous environment. Then, starting from a centralized test case, we propose a method to derive automatically its corresponding distributed test case in an asynchronous environment. We prove that the generated distributed test case is not biased, it tests the same behaviors of an implementation and has the same testing power as the centralized test case.", "num_citations": "38\n", "authors": ["1053"]}
{"title": "Off-line test selection with test purposes for non-deterministic timed automata\n", "abstract": " This paper proposes novel off-line test generation techniques for non-deterministic timed automata with inputs and outputs (TAIOs) in the formal framework of the tioco, conformance theory. In this context, a first problem is the determinization of TAIOs, which is necessary to foresee next enabled actions, but is in general impossible. This problem is solved here thanks to an approximate determinization using a game approach, which preserves tioco, and guarantees the soundness of generated test cases. A second problem is test selection for which a precise description of timed behaviors to be tested is carried out by expressive test purposes modeled by a generalization of TAIOs. Finally, using a symbolic co-reachability analysis guided by the test purpose, test cases are generated in the form of TAIOs equipped with verdicts.", "num_citations": "35\n", "authors": ["1053"]}
{"title": "Stg: a tool for generating symbolic test programs and oracles from operational specifications\n", "abstract": " We report on a tool we have developed that automates the derivation of tests from specifications. The tool implements conformance testing techniques to derive symbolic tests that incorporate their own oracles from formal operational specifications. It was applied for testing a simple version of the CEPS (Common Electronic Purse Specification).", "num_citations": "30\n", "authors": ["1053"]}
{"title": "From safety verification to safety testing\n", "abstract": " A methodology that combines verification and conformance testing for validating safety requirements of reactive systems is presented. The requirements are first automatically verified on the system\u2019s specification. Then, test cases are automatically derived from the specification and the requirements, and executed on a black-box implementation of the system. The test cases attempt to push the implementation into violating a requirement. We show that an implementation conforms to its specification if and only if it passes all the test cases generated in this way.", "num_citations": "28\n", "authors": ["1053"]}
{"title": "Off-line Test Selection with Test Purposes for Non-Deterministic Timed Automata\n", "abstract": " This article proposes novel off-line test generation techniques from non-deterministic timed automata with inputs and outputs (TAIOs) in the formal framework of the tioco conformance theory. In this context, a fi?rst problem is the determinization of TAIOs, which is necessary to foresee next enabled actions after an observable trace, but is in general impossible because not all timed automata are determinizable. This problem is solved thanks to an approximate determinization using a game approach. The algorithm performs an io-abstraction which preserves the tioco conformance relation and thus guarantees the soundness of generated test cases. A second problem is the selection of test cases from a TAIO speci?fication. The selection here relies on a precise description of timed behaviors to be tested which is carried out by expressive test purposes modeled by a generalization of TAIOs. Finally, an algorithm is described which generates test cases in the form of TAIOs equipped with verdicts, using a symbolic co-reachability analysis guided by the test purpose. Properties of test cases are then analyzed with respect to the precision of the approximate determinization: when determinization is exact, which is the case on known determinizable classes, in addition to soundness, properties characterizing the adequacy of test cases verdicts are also guaranteed.", "num_citations": "27\n", "authors": ["1053"]}
{"title": "A game approach to determinize timed automata\n", "abstract": " Timed automata are frequently used to model real-time systems. Their determinization is a key issue for several validation problems. However, not all timed automata can be determinized, and determinizability itself is undecidable. In this paper, we propose a game-based algorithm which, given a timed automaton, tries to produce a language-equivalent deterministic timed automaton, otherwise a deterministic over-approximation. Our method generalizes two recent contributions: the determinization procedure of \u00a0Baier et al. (Proceedings of the 36th international colloquium on automata, languages and programming (ICALP\u201909), 2009) and the approximation algorithm of\u00a0Krichen and Tripakis (Form Methods Syst Des 34(3):238\u2013304, 2009). Moreover, we extend it to apply to timed automata with invariants and -transitions, and also consider other useful approximations: under-approximation, and combination\u00a0\u2026", "num_citations": "25\n", "authors": ["1053"]}
{"title": "Assessment of automatic generation methods of conformance test suites in an industrial context\n", "abstract": " In this paper we describe three experiments in the automatic generation of conformance abstract test suites for protocol testing. The methods and tools have been applied to a same industrial protocol, the DREX protocol. This protocol has been specified in SDL language. Abstract conformance test suites have been generated in TTCN language. The study proved that the technology transfer to obtain a commercial tool is now possible.", "num_citations": "25\n", "authors": ["1053"]}
{"title": "Symbolic determinisation of extended automata\n", "abstract": " We define a symbolic determinisation procedure for a class of infinite-state systems, which consists of automata extended with symbolic variables that may be infinite-state. The subclass of extended automata for which the procedure terminates is characterised as bounded lookahead extended automata. It corresponds to automata for which, in any location, the observation of a bounded-length trace is enough to infer the first transition actually taken. We discuss applications of the algorithm to the verification, testing, and diagnosis of infinite-state systems.", "num_citations": "24\n", "authors": ["1053"]}
{"title": "Abstracting time and data for conformance testing of real-time systems\n", "abstract": " Current approaches to model-based conformance testing of real-time systems are mostly based either on finite state machines/transition systems or on timed automata. However, most real-time systems manipulate data while being subject to time constraints. The usual solution consists in enumerating data values (in finite domains) while treating time symbolically, thus leading to the classical state explosion problem. This paper proposes a new model of real-time systems as an extension of both symbolic transition systems and timed automata, in order to handle both data and time requirements symbolically. We then adapt the tioco conformance testing theory to deal with this model and describe a test case generation process based on a combination of symbolic execution and constraint solving for the data part and symbolic analysis for timed aspects.", "num_citations": "23\n", "authors": ["1053"]}
{"title": "Monitoring confidentiality by diagnosis techniques\n", "abstract": " We are interested in constructing monitors for the detection of confidential information flow in the context of partially observable discrete event systems. We focus on the case where the secret information is given as a regular language. We first characterize the set of observations allowing an attacker to infer the secret information. Further, based on the diagnosis of discrete event systems, we provide necessary and sufficient conditions under which detection and prediction of secret information flow can be ensured, and construct a monitor allowing an administrator to detect it.", "num_citations": "23\n", "authors": ["1053"]}
{"title": "Verification of test suites\n", "abstract": " We present a formal approach to check the correctness and to propose corrections of hand-written test suites with respect to a formal specification of the protocol implementations to test. It is shown that this requires in general a complex algorithmic comparable to model-checking. The principles of a prototype tool, called VTS, and based on the synthesis algorithms of TGV, are presented. We then prove the usefulness of the technique by checking a significant part of the ATM Forum test suite for the SSCOP protocol.", "num_citations": "17\n", "authors": ["1053"]}
{"title": "3D layout of reachability graphs of communicating processes\n", "abstract": " This paper presents a study about the 3D layout of some particular graphs. These graphs are finite reachability graphs of communicating processes. Some interesting semantical information which is present in the graph, such as concurrency, non-determinism, and membership of actions to processes are explicitly used in the layout. We start with the study of deterministic processes and give a conical representation which satisfies our requirements. Then we extrapolate our layout for non-deterministic processes.", "num_citations": "17\n", "authors": ["1053"]}
{"title": "Optimal enforcement of (timed) properties with uncontrollable events\n", "abstract": " This paper deals with runtime enforcement of untimed and timed properties with uncontrollable events. Runtime enforcement consists in defining and using mechanisms that modify the executions of a running system to ensure their correctness with respect to a desired property. We introduce a framework that takes as input any regular (timed) property described by a deterministic automaton over an alphabet of events, with some of these events being uncontrollable. An uncontrollable event cannot be delayed nor intercepted by an enforcement mechanism. Enforcement mechanisms should satisfy important properties, namely soundness, compliance and optimality \u2013 meaning that enforcement mechanisms should output as soon as possible correct executions that are as close as possible to the input execution. We define the conditions for a property to be enforceable with uncontrollable events. Moreover, we\u00a0\u2026", "num_citations": "15\n", "authors": ["1053"]}
{"title": "Model-based test selection for infinite-state reactive systems\n", "abstract": " This paper addresses the problem of off-line selection of test cases for testing the conformance of a black-box implementation with respect to a specification, in the context of reactive systems. Efficient solutions to this problem have been proposed in the context of finite-state models, based on the ioco conformance testing theory. An extension of these is proposed in the context of infinite-state specifications, modelled as automata extended with variables. One considers the selection of test cases according to test purposes describing abstract scenarios that one wants to test. The selection of program test cases then consists in syntactical transformations of the specification model, using approximate analyses.", "num_citations": "14\n", "authors": ["1053"]}
{"title": "Testing for unboundedness of FIFO channels\n", "abstract": " Unsolvability of the unboundedness problem for specification models allowing Fifo channels was proved a few years ago by Brand and Zafiropulo. The paper investigates a testing approach of that problem. Instead of reducing the model in order to give decidability results, we work with the largest possible framework and find a sufficient condition for unboundedness based on a relation between the nodes of the reachability tree. The construction of the resulting reduced tree can then be applied as well to communicating finite state machines as to Fifo-Nets. Moreover, the test extends existing decidability results. A few modifications of the relation make it available for Estelle specifications.", "num_citations": "14\n", "authors": ["1053"]}
{"title": "Contribution \u00e0 la validation des protocoles: test d'infinitude et v\u00e9rification \u00e0 la vol\u00e9e\n", "abstract": " Le but de cette these est de fournir de nouvelles idees aux concepteurs d'outils de validation. Traitant du probleme indecidable de la finitude des graphes d'accessibilite de modeles de specification autorisant des files fifo, nous donnons une condition suffisante fondee sur une relation entre etats accessibles. Cette relation fournit un test pouvant s' appliquer a toutes les specifications du modele et meme aux programmes estelle. En depit de cette approche, nous ameliorons les resultats theoriques connus. Une des limitations principales des outils de validation est l'exposition du graphe d'etats. Mais certaines proprietes peuvent etre verifiees au cours d'un parcours du graphe d'accessibilite. Nous experimentons donc un parcours en profondeur avec remplacement aleatoire qui peut augmenter de facon significative la taille des graphes analysables. Nous discutons ensuite de l'utilisation du parcours avec remplacement pour la verification a la volee. Nous donnons en particulier un algorithme original et efficace permettant la verification d'une specification par un automate de buchi. Finalement, nous donnons quelques idees pour la construction d'un outil de validation incorporant le parcours avec remplacement", "num_citations": "14\n", "authors": ["1053"]}
{"title": "Automatic test generation from interprocedural specifications\n", "abstract": " This paper adresses the generation of test cases for testing the conformance of a reactive black-box implementation with respect to its specification. We aim at extending the principles and algorithms of model-based testing for recursive interprocedural specifications that can be modeled by Push-Down Systems (PDS). Such specifications may be more compact than non-recursive ones and are more expressive.             The generated test cases are selected according to a test purpose, a (set of) scenario of interest that one wants to observe during test execution. The test generation method we propose in this paper is based on program transformations and a coreachability analysis, which allows to decide whether and how the test purpose can still be satisfied. However, despite the possibility to perform an exact analysis, the inability of test cases to inspect their own stack prevents it from using fully the\u00a0\u2026", "num_citations": "13\n", "authors": ["1053"]}
{"title": "The V3F project\n", "abstract": " This paper describes the main results of the V3F project (which stands for \u201cValidation and verification of software handling floating-point numbers\u201d) 1. The goal of this project was to provide tools to support the verification and validation process of programs with floatingpoint numbers. We did investigate two directions: structural testing of a program with floating-point numbers and verification of the conformity of a program handling floating-point numbers, with its specification. Practically, a constraint solver over the floats was developed for the generation of test sets in structural testing framework. Different techniques have been developed to evaluate the distance between the semantics of a program over the real numbers and its semantics over the floating-point numbers.", "num_citations": "13\n", "authors": ["1053"]}
{"title": "Ensuring the conformance of reactive discrete-event systems using supervisory control\n", "abstract": " We study the problem of controlling an implementation of a system by means of an automatically computed supervisor, in order to ensure a conformance relation between the implementation and its formal specification. The supervisor can be seen as a \"patch\" that automatically fixes errors, which otherwise should have been discovered by testing and fixed by hand.", "num_citations": "13\n", "authors": ["1053"]}
{"title": "More testable properties\n", "abstract": " In this paper, we explore the set of testable properties within the Safety-Progress classification where testability means to establish by testing that a relation, between the tested system and the property under scrutiny, holds. We characterize testable properties wrt. several relations of interest. For each relation, we give a sufficient condition for a property to be testable. Then, we study and delineate, for each Safety-Progress class, the subset of testable properties and their corresponding test oracle producing verdicts for the possible test executions. Finally, we address automatic test generation for the proposed framework.", "num_citations": "12\n", "authors": ["1053"]}
{"title": "Automatic testing of access control for security properties\n", "abstract": " In this work, we investigate the combination of controller synthesis and test generation techniques for the testing of open, partially observable systems with respect to security policies. We consider two kinds of properties: integrity properties and confidentiality properties. We assume that the behavior of the system is modeled by a labeled transition system and assume the existence of a black-box implementation. We first outline a method allowing to automatically compute an ideal access control ensuring these two kinds of properties. Then, we show how to derive testers that test the conformance of the implementation with respect to its specification, the correctness of the real access control that has been composed with the implementation in order to ensure a security property, and the security property itself.", "num_citations": "11\n", "authors": ["1053"]}
{"title": "More testable properties\n", "abstract": " Testing remains a widely used validation technique for software systems. However, recent needs in software development (e.g., in terms of security concerns) may require to extend this technique to address a larger set of properties. In this article, we explore the set of testable properties within the Safety-Progress classification where testability means to establish by testing that a relation, between the tested system and the property under scrutiny, holds. We characterize testable properties w.r.t. several relations of interest. For each relation, we give a sufficient condition for a property to be testable. Then, we study and delineate a fine-grain characterization of testable properties: for each Safety-Progress class, we identify the subset of testable properties and their corresponding test oracle. Furthermore, we address automatic test generation for the proposed framework by providing a general synthesis\u00a0\u2026", "num_citations": "10\n", "authors": ["1053"]}
{"title": "Model-checking of infinite Kripke structures defined by simple graph grammars\n", "abstract": " We present an algorithm for checking whether an infinite transition system, defined by a graph grammar of a restricted kind, is a model of a formula of the temporal logic CTL. We first present the syntax and the semantics of CTL, that are defined with respect to transition systems, labelled with atomic propositions. Then, we show how to adapt the formalism of graph grammars, for expressing such infinite transition systems. Our algorithm treats such a finite representation, and modify it, ensuring that the labelling for formulas remains coherent with the truth values of the different states of the infinite transition system.", "num_citations": "10\n", "authors": ["1053"]}
{"title": "Monitoring information flow by diagnosis techniques\n", "abstract": " In this paper, we are interested in constructing monitors for the detection of confidential information flow in the context of partially observable discrete event systems. We focus on the case where the secret information is given as a regular language. We first characterize the set of observations allowing an attacker to infer the secret behaviors. We consider the general case where the attacker and the administrator have different partial views of the system. Further, based on the diagnosis of discrete event systems, we provide necessary and sufficient conditions under which detection and prediction of secret information flow can be ensured and a construction of a monitor ensuring this task.", "num_citations": "9\n", "authors": ["1053"]}
{"title": "Verifying MPI Applications with SimGridMC\n", "abstract": " SimGridMC (also dubbed Mc SimGrid) is a stateful Model Checker for MPI applications. It is integrated to SimGrid, a framework mostly dedicated to predicting the performance of distributed applications. We describe the architecture of McSimGrid, and show how it copes with the state space explosion problem using Dynamic Partial Order Reduction and State Equality algorithms. As case studies we show how SimGrid can enforce safety and liveness properties for MPI applications, as well as global invariants over communication patterns.", "num_citations": "8\n", "authors": ["1053"]}
{"title": "Verification and symbolic test generation for safety properties\n", "abstract": " This paper presents a combination of verification and conformance testing techniques for the formal validation of reactive systems. A formal specification of a system - an input-output automaton with variables that may range over infinite domains - is assumed. Additionally, a set of safety properties for the specification are given under the form of observers described in the same formalism. Then, each property is verified on the specification using automatic techniques (e.g., abstract interpretation) that are sound but not necessarily complete for the class of safety properties considered here. Next, for each property, a test case is automatically generated from the specification and the property and is executed on a black-box implementation of the system. If the verification step was successful, that is, it has established that the specification satisfies the property, then the test execution may detect the violation of the property by the implementation and the violation of the standard ioco conformance relation[18] between implementation and specification. On the other hand, if the verification step did not conclude (i.e., it did not allow to prove or to disprove the property), then the test execution may additionally detect a violation of the property by the specification. The informations about the relative (in)consistencies between specification, implementation, and properties are reported to the user as test verdicts. The approach is illustrated on the BRP protocol [9].", "num_citations": "8\n", "authors": ["1053"]}
{"title": "Symbolic Methods in Testing (Dagstuhl Seminar 13021)\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 13021\" Symbolic Methods in Testing\". The aim of the seminar was to bring together leading researchers of this field; the seminary ended up with 38 participants from 10 countries: France, The Netherlands, The Unites States, Germany, Switzerland, United Kingdom, Brazil, Norway, Estonia and Italy. Through a series of presentations, discussions, and working group meetings, the seminar attempted to get a coherent picture of the field, which transcends the borders of applications and disciplines, of existing approaches and problems in formal testing. The seminar brought together, on the one hand, researchers from the different camps and various tools. The main outcome of the seminar is the exchange of information between different groups and the discussion of new trends (parallelization, cloud-computing).", "num_citations": "7\n", "authors": ["1053"]}
{"title": "Finitely representing infinite reachability graphs of CFSMs with graph grammars\n", "abstract": " We propose here an algorithm enabling to represent, in a finite way, some infinite reachability graphs of communicating finite-state machines, by using a graph grammar. The model-checking algorithm presented in Burkart and Quemener (1996) uses that finite representation for verifying properties of the infinite graph. In way to obtain that finite representation, we use a result of J\u00e9ron and Jard (1993): it can be detected that some sequences of transitions are infinitely repeated. We show here that the transitions issued from states linked by such sequences are also infinitely repeated if they are repeated twice. We deduce a method for detecting patterns that compose the infinite reachability graph on study.", "num_citations": "7\n", "authors": ["1053"]}
{"title": "Test generation from recursive tile systems\n", "abstract": " This paper explores the generation of conformance test cases for recursive tile systems (RTSs) in the framework of the classical ioco testing theory. The RTS model allows the description of reactive systems with recursion and is very similar to other models like pushdown automata, hyperedge replacement grammars or recursive state machines. Test generation for this kind of infinite state labelled transition systems is seldom explored in the literature. The first part presents an off\u2010line test generation algorithm for weighted RTSs, a determinizable sub\u2010class of RTSs, and the second one an on\u2010line test generation algorithm for the full RTS model. Both algorithms use test purposes to guide test selection through targeted behaviours. Additionally, essential properties relating verdicts produced by generated test cases with both the soundness, with respect to the specification, and the precision, with respect to a test\u00a0\u2026", "num_citations": "6\n", "authors": ["1053"]}
{"title": "G\u00e9n\u00e9ration de tests pour les syst\u00e8mes r\u00e9actifs et temporis\u00e9s\n", "abstract": " L\u2019objectif de ce cours est d\u2019introduire les principes du test de conformit\u00e9 bas\u00e9 sur des mod\u00e8les pour les syst\u00e8mes r\u00e9actifs, ainsi que les techniques de g\u00e9n\u00e9ration automatique de tests correspondantes. Dans un premier temps, nous pr\u00e9sentons une th\u00e9orie du test sur des mod\u00e8les simples de syst\u00e8mes de transitions ainsi que les algorithmes de g\u00e9n\u00e9ration de tests pour ces mod\u00e8les, bas\u00e9s sur une analyse de co-accessibilit\u00e9. Nous \u00e9voquons ensuite l\u2019extension de ces algorithmes \u00e0 des mod\u00e8les manipulant des donn\u00e9es qui reposent alors sur une analyse approch\u00e9e. Enfin, nous expliquons comment \u00e9tendre la th\u00e9orie du test et les algorithmes de g\u00e9n\u00e9ration au mod\u00e8le des automates temporis\u00e9s.", "num_citations": "4\n", "authors": ["1053"]}
{"title": "Construction de moniteurs pour la surveillance de propri\u00e9t\u00e9s de s\u00e9curit\u00e9\n", "abstract": " Nous nous int\u00e9ressons \u00e0 la construction de moniteurs permettant de d\u00e9tecter la fuite d'information confidentielle pour des syst\u00e8mes partiellement observables, mod\u00e9lis\u00e9s par des syst\u00e8mes de transition finis. Nous consid\u00e9rons le cas o\u00f9 le secret peut se mod\u00e9liser par des langages r\u00e9guliers. Nous commen\u00e7ons par d\u00e9finir la notion d'opacit\u00e9 pour formaliser la fuite d'information. Nous caract\u00e9risons l'ensemble des observations pour lesquelles un attaquant inf\u00e8re de l'information confidentielle. En adaptant les techniques de diagnostic sur des syst\u00e8mes \u00e0 \u00e9v\u00e9nement discrets, nous explicitons des conditions n\u00e9cessaires et suffisantes sur le syst\u00e8me pour permettre la d\u00e9tection et/ou la pr\u00e9diction de cette fuite d'information et construisons un moniteur permettant un administrateur d'assurer cette d\u00e9tection. Nous consid\u00e9rons le cas g\u00e9n\u00e9ral o\u00f9 l'attaquant et l'administrateur ont des vues partielles diff\u00e9rentes du syst\u00e8me.", "num_citations": "3\n", "authors": ["1053"]}
{"title": "Motifs de surveillance pour le diagnostic de syst\u00e8mes \u00e0 \u00e9v\u00e9nements discrets\n", "abstract": " Dans cet article, nous nous int\u00e9ressons au diagnostic dans les syst\u00e8mes de transitions finis. Nous proposons un mod\u00e8le de motifs de surveillance correspondant \u00e0 des propri\u00e9t\u00e9s d'atteignabilit\u00e9. Ceci permet de g\u00e9n\u00e9raliser les propri\u00e9t\u00e9s \u00e0 diagnostiquer tout en les d\u00e9couplant de la description du syst\u00e8me. Nous en d\u00e9duisons des techniques de v\u00e9rification de diagnosticabilit\u00e9 et de construction de diagnostiqueur fond\u00e9es sur des op\u00e9rations standards sur les syst\u00e8mes de transitions. Nous montrons que ces techniques sont suffisamment g\u00e9n\u00e9rales pour exprimer et r\u00e9soudre de mani\u00e8re unifi\u00e9e une classe importante de probl\u00e8mes de diagnostic consid\u00e9r\u00e9s dans la litt\u00e9rature comme le diagnostic de pannes permanentes, de pannes multiples, de s\u00e9quences de pannes, et certains probl\u00e8mes de diagnostic de pannes intermittentes.", "num_citations": "3\n", "authors": ["1053"]}
{"title": "Synth\u00e8se de contr\u00f4leurs pour une relation de conformit\u00e9\n", "abstract": " Nous nous int\u00e9ressons \u00e0 la combinaison du test de conformit\u00e9 et de la synth\u00e8se de contr\u00f4leurs ; sp\u00e9cifiquement, au probl\u00e8me de rendre une impl\u00e9mentation d'un syst\u00e8me conforme \u00e0 sa sp\u00e9cification, \u00e0 l'aide d'un contr\u00f4leur calcul\u00e9 automatiquement. Ce dernier peut \u00eatre vu comme un ``patch'' qui corrige automatiquement des erreurs, qui autrement auraient d\u00fb \u00eatre d\u00e9tect\u00e9es par le test et corrig\u00e9es \u00e0 la main. Nous traitons ici le cas o\u00f9 toutes les actions de la sp\u00e9cification et de l'impl\u00e9mentation sont observables depuis l'environnement, mais seul un sous-ensemble des actions est contr\u00f4lable", "num_citations": "3\n", "authors": ["1053"]}
{"title": "Validation of reactive systems\n", "abstract": " Archive ouverte HAL - Validation of Reactive Systems Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation inria-00422469, version 1 Chapitre d'ouvrage Validation of Reactive Systems Camille Constant 1 Thierry J\u00e9ron 1 Herv\u00e9 Marchand 1 Vlad Rusu 1 D\u00e9tails 1 VERTECS - Verification models and techniques applied to testing and control of reactive systems Inria Rennes \u2013 Bretagne Atlantique Type de document : Chapitre d'ouvrage Domaine : Informatique [cs] / G\u00e9nie logiciel [cs.SE] Liste compl\u00e8te des \u2026", "num_citations": "2\n", "authors": ["1053"]}
{"title": "Model-based test selection for infinite state reactive systems\n", "abstract": " We address the problem of offline selection of test cases for testing the conformance of a black-box implementation with respect to a specification of a reactive systems. Efficient solutions to this problem have been proposed in the context of finite-state models, based on the ioco contbmlance testing theory. We extend them in the context of infinite state specifications, modelled as automata extended with variables. We consider the selection of test cases according to test purposes describing abstract scenarios that one wants to test. The selection of program test cases then consists in syntactical transformations of the specification model, using approximate analysis.", "num_citations": "2\n", "authors": ["1053"]}
{"title": "Abstract Interpretation of FIFO channels\n", "abstract": " We address the analysis and the verification of communicating systems, which are systems built from sequential processes communicating via unbounded FIFO channels. We adopt the Abstract Interpretation approach to this problem, by defining approximate representations of sets of configuration of FIFO channels. In this paper we restrict our attention to the case where processes are finite-state processes and the alphabet of exchanged messages is finite. We first focus on systems with only one queue, for which we propose an abstract lattice based on regular languages, and we then generalize our proposal to systems with several queues. In particular, we define for these systems two abstract lattices, which are resp. non-relational and relational abstract lattices. We use those lattices for computing an over-approximation of the reachability set of a CFSM. Our experimental evaluation shows that, for some protocols, we obtain results that are as good as those obtained by exact methods founded on acceleration techniques.", "num_citations": "1\n", "authors": ["1053"]}
{"title": "Ensuring the conformance of reactive discrete-event systems by means of supervisory control\n", "abstract": " We study the problem of controlling a plant of a system by means of an automatically computed supervisor, in order to ensure a certain conformance relation between the plant and its formal specification. The supervisor can be seen as a device that automatically fixes errors that otherwise would have been discovered by testing and fixed by hand. The resulting controlled plant conforms to the specification and is maximal in terms of observable behaviour.", "num_citations": "1\n", "authors": ["1053"]}
{"title": "An educational case study in protocol verification and distributed observation\n", "abstract": " This paper describes a case study presented to students in computer science during a course on formal techniques for protocol validation. The course teaches some basic notions on specification, simulation, verification, testing and distributed observation. The case study is the classical alternating-bit protocol. The exercise first consists of some simple modeling and simulation of the specification and verification of some basic service properties. It is then followed with the problem of observation of distributed executions of the protocol. This kind of experiment was found to be useful for students, since they gain an understanding of the importance and necessity of formal methods for protocol validation.", "num_citations": "1\n", "authors": ["1053"]}