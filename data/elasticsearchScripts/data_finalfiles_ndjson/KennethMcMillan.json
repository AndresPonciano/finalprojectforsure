{"title": "Symbolic model checking\n", "abstract": " In the previous chapter, we equated a CTL formula with the set of states in which the formula is true. We showed how the CTL operators can thus be characterized as fixed points of certain continuous functionals in the lattice of subsets, and how these fixed points can be computed iteratively. This provides us with a model checking algorithm for CTL, but requires us to build a finite Kripke model for our system and hence leads us to the state explosion problem. In this chapter, we will explore a method of model checking that avoids the state explosion problem in some cases by representing the Kripke model implicitly with a Boolean formula. This allows the CTL model checking algorithm to be implemented using well developed automatic techniques for manipulating Boolean formulas. Since the Kripke model is symbolically represented, there is no need to actually construct it as an explicit data structure. Hence\u00a0\u2026", "num_citations": "5858\n", "authors": ["1781"]}
{"title": "Interpolation and SAT-based model checking\n", "abstract": " We consider a fully SAT-based method of unbounded symbolic model checking based on computing Craig interpolants. In benchmark studies using a set of large industrial circuit verification instances, this method is greatly more efficient than BDD-based symbolic model checking, and compares favorably to some recent SAT-based model checking methods on positive instances.", "num_citations": "1063\n", "authors": ["1781"]}
{"title": "Using unfoldings to avoid the state explosion problem in the verification of asynchronous circuits\n", "abstract": " A number of researchers have observed that the arbitrary interleaving of concurrent actions is a major contributor to the state explosion problem, and that substantial efficiencies could be obtained if the enumeration of all possible interleavings could be avoided. As a result, several have proposed verification algorithms based on partial orders [Va189, Valg0, GOd90, GW91, PL89, PL90, PL91, YTK91]. The method presented in this paper is based on unfolding a Petri net into an acyclic structure called an occurrence net. The notion of unfolding was introduced by Nielsen, Piotkin and Winskel as a means for giving a concurrent semantics to nets, but in this case tile goal is to avoid the state explosion problem. An algorithm is introduced for constructing the unfolding of a net, whidl terminates when the unfolded net represents all of the reachable states of the original net. The unfolding is adequate for testing teachability (to\u00a0\u2026", "num_citations": "589\n", "authors": ["1781"]}
{"title": "Lazy abstraction with interpolants\n", "abstract": " We describe a model checker for infinite-state sequential programs, based on Craig interpolation and the lazy abstraction paradigm. On device driver benchmarks, we observe a speedup of up to two orders of magnitude relative to a similar tool using predicate abstraction.", "num_citations": "530\n", "authors": ["1781"]}
{"title": "A technique of state space search based on unfolding\n", "abstract": " Unfoldings of Petri nets provide a method of searching the state space of concurrent systems without considering all possible interleavings of concurrent events. A procedure is given for constructing the unfolding of a Petri net, terminating the construction when it is sufficient to represent all reachable markings. This procedure is applied to hazard and deadlock detection in asynchronous circuits. Examples are given of scalable systems with exponential size state spaces, but polynomial size unfoldings, including a distributed mutual exclusion ring circuit.", "num_citations": "399\n", "authors": ["1781"]}
{"title": "The SMV system\n", "abstract": " In order to apply symbolic model checking to real problems, we need expressive languages that we can use to describe our model at a suitably high level (eg., a gate level schematic is probably not a high enough level). For our purposes, this means the language must provide operations on suitable high level types (such as symbolic enumerated types), and must allow us to conveniently describe non-deterministic choices, so that we can describe high level protocols without being concerned with implementation details. The language must have a precise mathematical semantics that defines the translation from a program in the langauge to a form suitable for symbolic model checking (ie., a Boolean formula representing the transition relation). For reasons that will be clarified in chapter 7, the semantics should be syntax-directed (defining the meaning of a language construct in terms of the meanings of its\u00a0\u2026", "num_citations": "365\n", "authors": ["1781"]}
{"title": "Automatic abstraction without counterexamples\n", "abstract": " A method of automatic abstraction is presented that uses proofs of unsatisfiability derived from SAT-based bounded model checking as a guide to choosing an abstraction for unbounded model checking. Unlike earlier methods, this approach is not based on analysis of abstract counterexamples. The performance of this approach on benchmarks derived from microprocessor verification indicates that SAT solvers are quite effective in eliminating logic that is not relevant to a given property. Moreover, benchmark results suggest that when bounded model checking successfully terminates, and the problem is unsatisfiable, the number of state variables in the proof of unsatisfiability tends to be small. In almost all cases tested, when bounded model checking succeeded, unbounded model checking of the resulting abstraction also succeeded.", "num_citations": "289\n", "authors": ["1781"]}
{"title": "An interpolating theorem prover\n", "abstract": " We present a method of deriving Craig interpolants from proofs in the quantifier-free theory of linear inequality and uninterpreted function symbols, and an interpolating theorem prover based on this method. The prover has been used for predicate refinement in the BLAST software model checker, and can also be used directly for model checking infinite-state systems, using interpolation-based image approximation.", "num_citations": "238\n", "authors": ["1781"]}
{"title": "Verification of an implementation of Tomasulo's algorithm by compositional model checking\n", "abstract": " An implementation of an out-of-order processing unit based on Tomasulo's algorithm is formally verified using compositional model checking techniques. This demonstrates that finite-state methods can be applied to such algorithms, without recourse to higher-order proof systems. The paper introduces a novel compositional system that supports cyclic environment reasoning and multiple environment abstractions per signal. A proof of Tomasulo's algorithm is outlined, based on refinement maps, and relying on the novel features of the compositional system. This proof is fully verified by the SMV verifier, using symmetry to reduce the number of assertions that must be verified.", "num_citations": "235\n", "authors": ["1781"]}
{"title": "Verification of infinite state systems by compositional model checking\n", "abstract": " A method of compositional verification is presented that uses the combination of temporal case splitting and data type reductions to reduce types of infinite or unbounded range to small finite types, and arrays of infinite or unbounded size to small fixed-size arrays. This supports the verification by model checking of systems with unbounded resources and uninterpreted functions. The method is illustrated by application to an implementation of Tomasulo\u2019s algorithm, for arbitrary or infinite word size, register file size, number of reservation stations and number of execution units.", "num_citations": "224\n", "authors": ["1781"]}