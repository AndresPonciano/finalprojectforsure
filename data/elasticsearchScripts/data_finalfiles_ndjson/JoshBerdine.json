{"title": "Structuring the verification of heap-manipulating programs\n", "abstract": " Most systems based on separation logic consider only restricted forms of implication or non-separating conjunction, as full support for these connectives requires a non-trivial notion of variable context, inherited from the logic of bunched implications (BI). We show that in an expressive type theory such as Coq, one can avoid the intricacies of BI, and support full separation logic very efficiently, using the native structuring primitives of the type theory.", "num_citations": "86\n", "authors": ["677"]}
{"title": "Linear and affine typing of continuation-passing style\n", "abstract": " In this dissertation we show that linear and affine type systems for continuation-passing style support correct and tight refinements of standard continuation semantics. In particular, a wide variety of control constructs admit typing disciplines which ensure linear or affine use of the control context in their continuation semantics. This refinement of standard continuation semantics using restricted types is an exploitation of the stylized use of continuations many control behaviors exhibit. Continuations are the raw material of control and can be used to explain a wide variety of control behaviors, including calling/returning (procedures), raising/handling (exceptions), jumping/labeling (goto and labels), process switching (coroutines), backtracking (amb and fail), and capturing/invoking first-class continuations (call/cc, or callcc and throw). However, in all but the last case, continuations are not themselves intrinsic to the control construct, instead they are \u201cbehind the scenes,\u201d implementing the control construct. In other words, except for first-class continuations, each control behavior is simply an idiom of continuation usage, and hence the continuations are used in a stylized fashion. Linear or affine use of control contexts; by which we mean, roughly, that control contexts cannot be duplicated or, in the linear case, discarded; captures this stylized usage in all the above-mentioned cases bar backtracking. We also investigate several cases where even storable labels (plus goto) admit restricted interpretations.", "num_citations": "13\n", "authors": ["677"]}
{"title": "Diagnosing abstraction failure for separation logic\u2013based analyses\n", "abstract": " Abstraction refinement is an effective verification technique for automatically proving safety properties of software. Application of this technique in shape analyses has proved impractical as core components of existing refinement techniques such as backward analysis, general conjunction, and identification of unreachable but doomed states are computationally infeasible in such domains.               We propose a new method to diagnose proof failures to be used in a refinement scheme for Separation Logic\u2013based shape analyses. To check feasibility of abstract error traces, we perform Bounded Model Checking over the traces using a novel encoding into SMT. A subsequent diagnosis finds discontinuities on infeasible traces, and identifies doomed states admitted by the abstraction. To construct doomed states, we give a model-finding algorithm for \u201csymbolic heap\u201d Separation Logic formulas, employing the\u00a0\u2026", "num_citations": "13\n", "authors": ["677"]}
{"title": "A Proposal for Weak-Memory Local Reasoning\n", "abstract": " Program logics are formal systems for specifying and reasoning about software programs. Most program logics make the strong assumption that all threads agree on the value of shared memory at all times. This assumption can be unsound though for programs with races, like many concurrent data structures. Verification of these difficult programs must take into account the weaker models of memory provided by the architectures on which they execute. In this paper, we describe progress toward a program logic for local reasoning about racy concurrent programs executing on a weak, x86-like memory model.", "num_citations": "13\n", "authors": ["677"]}
{"title": "Resourceful reachability as HORN-LA\n", "abstract": " The program verification tool SLAyer uses abstractions during analysis and relies on a solver for reachability to refine spurious counterexamples. In this context, we extract a reachability benchmark suite and evaluate methods for encoding reachability properties with heaps using Horn clauses over linear arithmetic. The benchmarks are particularly challenging and we describe and evaluate pre-processing transformations that are shown to have significant effect.", "num_citations": "10\n", "authors": ["677"]}
{"title": "Backward analysis via over-approximate abstraction and under-approximate subtraction\n", "abstract": " We propose a novel approach for computing weakest liberal safe preconditions of programs. The standard approaches, which call for either underapproximation of a greatest fixed point, or complementation of a least fixed point, are often difficult to apply successfully. Our approach relies on a different decomposition of the weakest precondition of loops. We exchange the greatest fixed point for the computation of a least fixed point above a recurrent set, instead of the bottom element. Convergence is achieved using over-approximation, while in order to maintain soundness we use an under-approximating logical subtraction operation. Unlike general complementation, subtraction more easily allows for increased precision in case its arguments are related. The approach is not restricted to a specific abstract domain and we use it to analyze programs using the abstract domains of intervals and of 3-valued\u00a0\u2026", "num_citations": "7\n", "authors": ["677"]}
{"title": "A forward analysis for recurrent sets\n", "abstract": " Non-termination of structured imperative programs is primarily due to infinite loops. An important class of non-terminating loop behaviors can be characterized using the notion of recurrent sets. A recurrent set is a set of states from which execution of the loop cannot or might not escape. Existing analyses that infer recurrent sets to our knowledge rely on one of: the combination of forward and backward analyses, quantifier elimination, or SMT-solvers. We propose a purely forward abstract interpretation\u2013based analysis that can be used together with a possibly complicated abstract domain where none of the above is readily available. The analysis searches for a recurrent set of every individual loop in a program by building a graph of abstract states and analyzing it in a novel way. The graph is searched for a witness of a recurrent set that takes the form of what we call a recurrent component which is somewhat\u00a0\u2026", "num_citations": "6\n", "authors": ["677"]}
{"title": "Computing all implied equalities via SMT-based partition refinement\n", "abstract": " Consequence finding is used in many applications of deduction. This paper develops and evaluates a suite of optimized SMT-based algorithms for computing equality consequences over arbitrary formulas and theories supported by SMT solvers. It is inspired by an application in the SLAyer analyzer, where our new algorithms are commonly 10\u2013100x faster than simpler algorithms. The main idea is to incrementally refine an initially coarse partition using models extracted from a solver. Our approach requires only O(N) solver calls for N terms, but in the worst case creates O(N                 2) fresh subformulas. Simpler algorithms, in contrast, require O(N                 2) solver calls. We also describe an asymptotically superior algorithm that requires O(N) solver calls and only O(NlogN) fresh subformulas. We evaluate algorithms which reduce the number of fresh formulas required either by using specialized data\u00a0\u2026", "num_citations": "5\n", "authors": ["677"]}
{"title": "Diagrammatic reasoning in separation logic\n", "abstract": " A new method of reasoning about simple imperative programs in separation logic is proposed. Rather than proving program specifications symbolically, the hope is to model more closely human diagrammatic reasoning, and to perform automated diagrammatic reasoning in separation logic.", "num_citations": "4\n", "authors": ["677"]}