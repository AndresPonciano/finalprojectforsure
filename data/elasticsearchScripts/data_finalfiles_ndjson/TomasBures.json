{"title": "Sofa 2.0: Balancing advanced features in a hierarchical component model\n", "abstract": " Component-based software engineering is a powerful paradigm for building large applications. However, our experience with building application of components is that the existing advanced component models (such as those offering component nesting, behavior specification and checking, dynamic reconfiguration to some extent, etc.) are subject to a lot of limitations and issues which prevent them from being accepted more widely (by industry in particular). We claim that these issues are specifically related to (a) the lack of support for dynamic reconfigurations of hierarchical architectures, (b) poor support for modeling and extendibility of the control part of a component, and (c) the lack of support for different communication styles applied in inter-component communication. In this paper, we show how these problems can be addressed and present an advanced component system SOFA 2.0 as a proof of the concept\u00a0\u2026", "num_citations": "365\n", "authors": ["584"]}
{"title": "DEECo: An ensemble-based component system\n", "abstract": " The recent increase in the ubiquity and connectivity of computing devices allows forming large-scale distributed systems that respond to and influence activities in their environment. Engineering of such systems is very complex because of their inherent dynamicity, open-endedness, and autonomicity. In this paper we propose a new class of component systems (Ensemble-Based Component Systems-EBCS) which bind autonomic components with cyclic execution via dynamic component ensembles controlling data exchange. EBCS combine the key ideas of agents, ensemble-oriented systems, and control systems into software engineering concepts based on autonomic components. In particular, we present an instantiation of EBCS-the DEECo component model. In addition to DEECo main concepts, we also describe its computation model and mapping to Java. Lastly, we outline the basic principles of the EBCS\u00a0\u2026", "num_citations": "137\n", "authors": ["584"]}
{"title": "Comparison of component frameworks for real-time embedded systems\n", "abstract": " The usage of components brings significant help in development of real-time embedded systems. There have been a number of component frameworks developed for this purpose and some of them have already become well-established in this area. However, although the component frameworks share basic concepts and the general approach, they substantially differ in the range of supported features and maturity. This makes relatively difficult to select the right component framework and thus poses a significant obstacle in adoption of the component-based development for real-time embedded systems. To provide an overview, we present a survey in this paper, which illustrates distinguishing features of selected modern component-based frameworks for real-time embedded systems. The survey identifies features which are important for building systems from components in this area and compares these\u00a0\u2026", "num_citations": "65\n", "authors": ["584"]}
{"title": "Self-adaptation in software-intensive cyber\u2013physical systems: From system goals to architecture configurations\n", "abstract": " Design of self-adaptive software-intensive cyber\u2013physical systems (siCPS) operating in dynamic environments is a significant challenge when a sufficient level of dependability is required. This stems partly from the fact that the concerns of self-adaptivity and dependability are to an extent contradictory. In this paper, we introduce IRM-SA (Invariant Refinement Method for Self-Adaptation)\u2014a design method and associated formally grounded model targeting siCPS\u2014that addresses self-adaptivity and supports dependability by providing traceability between system requirements, distinct situations in the environment, and predefined configurations of system architecture. Additionally, IRM-SA allows for architecture self-adaptation at runtime and integrates the mechanism of predictive monitoring that deals with operational uncertainty. As a proof of concept, it was implemented in DEECo, a component framework that is\u00a0\u2026", "num_citations": "56\n", "authors": ["584"]}
{"title": "The autonomic cloud: a vision of voluntary, peer-2-peer cloud computing\n", "abstract": " Autonomic computing - that is, the development of software and hardware systems featuring a certain degree of self-awareness and self-adaptability - is a field with many application areas and many technical difficulties. In this paper, we explore the idea of an autonomic cloud in the form of a platform-as-a-service computing infrastructure which, contrary to the usual practice, does not consist of a well-maintained set of reliable high-performance computers, but instead is formed by a loose collection of voluntarily provided heterogeneous nodes which are connected in a peer-to-peer manner. Such an infrastructure must deal with network resilience, data redundancy, and failover mechanisms for executing applications. We discuss possible solutions and methods which help developing such (and similar) systems. The described approaches are developed in the EU project ASCENS.", "num_citations": "48\n", "authors": ["584"]}
{"title": "Communication style driven connector configurations\n", "abstract": " Connectors are used in component-based systems as first-class entities to abstract component interactions. In this paper, we propose a way to compose connectors by using fine-grained elements, each of them representing a single, well-defined function. We identify an experimentally proven set of connector elements, which, composed together, model four basic component interconnection types (procedure call, messaging, streaming, blackboard), and allow for connector variants to reflect distribution, security, fault- tolerance, etc. We also discuss how to generate such a connector semi-automatically. The presented results are based on a proof-of-the-concept implementation.", "num_citations": "45\n", "authors": ["584"]}
{"title": "Microcomponent-based component controllers: A foundation for component aspects\n", "abstract": " In most component models, a software component consists of a functional part and a controller part. The controller part may be extensible; however, existing component models provide no means to capture the structure of the controller part, and therefore neither to specify the controller part extensions. In this paper, we introduce a minimalist component model to capture the structure of the controller part, coining the term microcomponent for the controller part elements. We further introduce the concept of a component aspect as a consistent set of controller part extensions. Within this framework, it is possible to seamlessly integrate controller part extensions, applying them to the components selected in the application's launch configuration. We have evaluated these concepts in a prototype implementation.", "num_citations": "44\n", "authors": ["584"]}
{"title": "Towards dependable emergent ensembles of components: the DEECo component model\n", "abstract": " In the domain of dynamically evolving distributed systems composed of autonomous and (self-) adaptive components, the task of systematically managing the design complexity of their communication and composition is a pressing issue. This stems from the dynamic nature of such systems, where components and their bindings may appear and disappear without anticipation. To address this challenge, we propose employing separation of concerns via a mechanism of dynamic implicit bindings with implicit communication. This way, we strive for dynamically formed, implicitly interacting groups - ensembles - of autonomous components. In this context, we introduce the DEECo component model, where such bindings, as well as the associated communication, are managed in an automated way, enabling transparent handling of the dynamic changes in the system.", "num_citations": "41\n", "authors": ["584"]}
{"title": "Capturing performance assumptions using stochastic performance logic\n", "abstract": " Compared to functional unit testing, automated performance testing is difficult, partially because correctness criteria are more difficult to express for performance than for functionality. Where existing approaches rely on absolute bounds on the execution time, we aim to express assertions on code performance in relative, hardware-independent terms. To this end, we introduce Stochastic Performance Logic (SPL), which allows making statements about relative method performance. Since SPL interpretation is based on statistical tests applied to performance measurements, it allows (for a special class of formulas) calculating the minimum probability at which a particular SPL formula holds. We prove basic properties of the logic and present an algorithm for SAT-solver-guided evaluation of SPL formulas, which allows optimizing the number of performance measurements that need to be made. Finally, we propose\u00a0\u2026", "num_citations": "40\n", "authors": ["584"]}
{"title": "Generating Connectors for Homogenous and Heterogenous deployment\n", "abstract": " Software connectors are typically used in component-based engineering to model and realize component interconnections. Connectors play an important role both at design time, when they allow for specifying the way components interact, and at runtime, when they actually implement the specified interactions in particular target environments. Connectors also help with deployment (both homogeneous and heterogeneous) by allowing for seamless distribution and overcoming incompatibilities between components and component systems by utilizing adaptors. An important aspect of employing connectors is the amount of work connected with their use. In this context, to make connectors truly an asset, it is necessary to allow for generating their runtime implementations based on design-time specification. This is however a problem (mainly because of the semantic gap between the connector specification and its implementation), which has not been sufficiently addressed so far, especially when trying to use connectors in the context of heterogeneous deployment. In this thesis, we propose a technique of automatic generation of a connector implementation based on a high-level connector specification. The thesis focuses on building connectors in the scope of homogeneous and heterogeneous deployment, which means that the generated...", "num_citations": "40\n", "authors": ["584"]}
{"title": "Self-adaptation based on big data analytics: a model problem and tool\n", "abstract": " In this paper, we focus on self-adaptation in large-scale software-intensive distributed systems. The main problem in making such systems self-adaptive is that their adaptation needs to consider the current situation in the whole system. However, developing a complete and accurate model of such systems at design time is very challenging. To address this, we present a novel approach where the system model consists only of the essential input and output parameters. Furthermore, Big Data analytics is used to guide self-adaptation based on a continuous stream of operational data. We provide a concrete model problem and a reference implementation of it that can be used as a case study for evaluating different self-adaptation techniques pertinent to complex large-scale distributed systems. We also provide an extensible tool for endorsing an arbitrary system with self-adaptation based on analysis of operational\u00a0\u2026", "num_citations": "39\n", "authors": ["584"]}
{"title": "An architecture framework for experimentations with self-adaptive cyber-physical systems\n", "abstract": " Recent advances in embedded devices capabilities and wireless networks paved the way for creating ubiquitous Cyber-Physical Systems (CPS) grafted with self-configuring and self-adaptive capabilities. As these systems need to strike a balance between dependability, open-endedness and adaptability, and operate in dynamic and opportunistic environments, their design and development is particularly challenging. We take an architecture-based approach to this problem and advocate the use of component-based abstractions and related machinery to engineer self-adaptive CPS. Our approach is structured around DEECo -- a component framework that introduces the concept of component ensembles to deal with the dynamicity of CPS at the middleware level. DEECo provides the architecture abstractions of autonomous components and component ensembles on top of which different adaptation techniques\u00a0\u2026", "num_citations": "36\n", "authors": ["584"]}
{"title": "Cocome in fractal\n", "abstract": " This chapter presents our solution to the CoCoME assignment that is based on the Fractal component model. The solution involves (i) modeling architecture in Fractal ADL, (ii) specification of component behavior via behavior protocols, (iii) checking compatibility of components, (iv) verification of correspondence between component code and behavior specification, and (v) run-time monitoring of non-functional properties. Among the issues we have faced was the need to modify the architecture - the component hierarchy was reorganized in order to improve clarity of the design and the hierarchical bus was split into two independent buses. These were modeled by primitive components, since Fractal does not support message bus as a first-class entity. Since the CoCoME assignment does not include a complete UML behavior specification (e.g. via activity diagrams and state charts), behavior protocols for all\u00a0\u2026", "num_citations": "36\n", "authors": ["584"]}
{"title": "Design of ensemble-based component systems by invariant refinement\n", "abstract": " The challenge of developing dynamically-evolving resilient distributed systems that are composed of autonomous components has been partially addressed by introducing the concept of component ensembles. Nevertheless, systematic design of complex ensemble-based systems is still a pressing issue. This stems from the fact that contemporary design methods do not scale in terms of the number and complexity of ensembles and components, and do not efficiently cope with the dynamism involved. To address this issue, we present a novel method-Invariant Refinement Method (IRM)-for designing ensemble-based component systems by building on goal-based requirements elaboration, while integrating component architecture design and software control system design.", "num_citations": "33\n", "authors": ["584"]}
{"title": "Software abstractions for component interaction in the internet of things\n", "abstract": " Component ensembles provide expressive abstractions that address challenges in engineering software architectures for Internet of Things and cyber-physical systems, particularly when combined with mobile ad hoc networks. A case study in collaborative parking demonstrates the open-endedness of component ensembles and their ability to self-adapt.", "num_citations": "31\n", "authors": ["584"]}
{"title": "Architectural homeostasis in self-adaptive software-intensive cyber-physical systems\n", "abstract": " Self-adaptive software-intensive cyber-physical systems (sasiCPS) encounter a high level of run-time uncertainty. State-of-the-art architecture-based self-adaptation approaches assume designing against a fixed set of situations that warrant self-adaptation; as a result, failures may appear when sasiCPS operate in environment conditions they are not specifically designed for. In response, we propose to increase the homeostasis of sasiCPS, i.e., the capacity to maintain an operational state despite run-time uncertainty, by introducing run-time changes to the architecture-based self-adaptation strategies according to environment stimuli. In addition to articulating the main idea of architectural homeostasis, we describe three mechanisms that reify the idea: (i) collaborative sensing, (ii) faulty component isolation from adaptation, and (iii) enhancing mode switching. Moreover, our experimental evaluation of the\u00a0\u2026", "num_citations": "29\n", "authors": ["584"]}
{"title": "Component reliability extensions for fractal component model\n", "abstract": " Fractal is a component model developed initially by France Telecom and INRIA and later as an open source project in the ObjectWeb consortium. The component model is defined by the Fractal Component Model specification [BCS]. The specification defines a hierarchical component model, where a component is specified in terms of its server and client (provided and required) interfaces and configurable attributes. The model supports advanced features such as component sharing, mandatory/optional interfaces, collection interfaces. The Fractal API is defined for three languages: Java, C, and CORBA IDL. The reference implementation of Fractal, Julia, is developed in Java and supports Java Fractal components.The Fractal specification allows to use an Architecture Description Language (ADL), however, it does not directly specify one. In the Fractal ADL project, an XML-based ADL for the Fractal component model is defined to specify the initial architecture of an application. The features of this ADL language include inheritance among component specifications, and also a mechanism to specify values of components' attributes.", "num_citations": "29\n", "authors": ["584"]}
{"title": "Runtime concepts of hierarchical software components\n", "abstract": " Components have become a widely accepted concept used in building large-scale applications. Although the concept of a component is not really new, it is generally not clear how to deal with the component abstraction at runtime. This manifests in the fact that nowadays component systems can be basically divided (a) to those being rich in advanced features (eg, hierarchical components, software connectors, versioning, dynamic architectures), but which have typically only poor or even no runtime support, and (b) to those with a solid runtime support, but which typically possess only a limited set of the advanced features. In our opinion, this is mainly due to the difficulties that arise when trying to give proper semantics to the features and reify them in development tools and an runtime platform. In this paper, we describe the implementation of the runtime environment for the SOFA 2.0 component model. In particular, we focus on the runtime support of the advanced features mentioned above. The described issues and corresponding solutions are not specific only to SOFA 2.0, but they are generic enough to be applicable to any other component system aiming at addressing those advanced features.", "num_citations": "28\n", "authors": ["584"]}
{"title": "Unit testing performance with stochastic performance logic\n", "abstract": " Unit testing is an attractive quality management tool in the software development process, however, practical obstacles make it difficult to use unit tests for performance testing. We present Stochastic Performance Logic, a formalism for expressing performance requirements, together with interpretations that facilitate performance evaluation in the unit test context. The formalism and the interpretations are implemented in a performance testing framework and evaluated in multiple experiments, demonstrating the ability to identify performance differences in realistic unit test scenarios.", "num_citations": "27\n", "authors": ["584"]}
{"title": "CoCoME in SOFA\n", "abstract": " This chapter presents our solution to the CoCoME assignment that is based on the SOFA 2.0 (SOFtware Appliances) hierarchical component model. The solution involves (i) modeling architecture in SOFA meta-model, (ii) speci fication of component behavior via extended behavior protocols, (iii) checking behavior compliance of components, (iv) verification of correspondence be tween selected component Java code and behavior specification, (v) deploy ment to SOFA run-time envi ronment (using connectors that support RMI and JMS), and (vi) modeling of performance and resource usage via layered queue ing networks. We faced sev eral issues during implementation of the CoCoME assignment in SOFA 2.0. Most notably, the architecture was modified in order to improve clarity of the design \u2013 in particular, the hierarchical bus was re placed by two separate buses and the Inventory component was\u00a0\u2026", "num_citations": "27\n", "authors": ["584"]}
{"title": "The autonomic cloud\n", "abstract": " The cloud case study within ASCENS explores the vision of an autonomic cloud, which is a cloud providing a platform-as-a-service computing infrastructure which, contrary to the usual practice, does not consist of a well-maintained set of reliable high-performance computers, but instead is formed by a loose collection of voluntarily provided heterogeneous nodes which are connected in a peer-to-peer manner. Such an infrastructure must deal with network resilience, data redundancy, and failover mechanisms for executing applications. As such, the autonomic cloud thus requires a certain degree of self-awareness, monitoring, and self-adaptation to reach its goals, which has been achieved with the integration of ASCENS methods and techniques.", "num_citations": "26\n", "authors": ["584"]}
{"title": "A connector model suitable for automatic generation of connectors\n", "abstract": " The notion of connector can be found in many of the contemporary component-based systems. A connector is an architectural element, which embodies communication among components in a system. In this paper we propose a flexible connector model that is easy to use in practice and expressive enough to capture the semantics of component interconnections. Our model follows the top-down approach to software design and allows to define different types of connections (procedure call, messaging, pipe, etc.) and their specialization (adding security, protocol checks, etc.)For this model we propose an abstract connector generator, a framework allowing to create complex component interconnections almost automatically. The paper presents basic ideas of connector generation and specifies the framework data structures and interfaces needed for generation in platform independent language (CORBA IDL [22]). The paper is concluded with discussion on our prototype implementation for SOFA/DCUP component system [30] and describes the cases used for testing of overall functionality of our concept.", "num_citations": "26\n", "authors": ["584"]}
{"title": "Comparison of component frameworks for real-time embedded systems\n", "abstract": " The use of components significantly helps in development of real-time embedded systems. There have been a number of component frameworks developed for this purpose, and some of them have already became well established in this area. Even though these frameworks share the general idea of component-based development, they significantly differ in the range of supported features and maturity. This makes it relatively difficult to select the right component framework and thus poses a significant obstacle in adoption of the component-based development approach for developing real-time embedded systems. To provide guidance in choosing a component framework, or at least relevant concepts when building a custom framework, we present a survey, which illustrates distinguishing features and provides comparison of selected modern component-based frameworks for real-time embedded systems\u00a0\u2026", "num_citations": "23\n", "authors": ["584"]}
{"title": "Component-based design of cyber-physical applications with safety-critical requirements\n", "abstract": " Cyber-physical systems typically involve large numbers of mobile autonomous devices that closely interact with each other and their environment. Standard design and development techniques often fail to effectively manage the complexity and dynamics of such systems. As a result, there is a strong need for new programing models and abstractions. Towards this, component-based design methods are a promising solution. However, existing such approaches either do not accurately model transitory interactions between components \u2013 which are typical of cyber-physical systems \u2013 or do not provide guarantees for real-time behavior which is essential in safety-critical applications. To overcome this problem, we present a component-based design technique based on DEECo (Dependable Emergent Ensembles of Components). The DEECo framework allows modeling large-scale dynamic systems by a set of\u00a0\u2026", "num_citations": "22\n", "authors": ["584"]}
{"title": "Generating connectors for heterogeneous deployment\n", "abstract": " A software connector is an abstraction capturing interactions among components. Apart from middleware independence, connectors provide additional services (eg, adaptation, synchronization, etc.). They play a major role in heterogeneous deployment (ie, building applications from components implemented in different component models) where they are invaluable for solving distribution and overcoming incompatibilities stemming from coexistence of different component models and middleware. However, to make the use of connectors in heterogeneous deployment possible, it is imperative to have means of generating them automatically. In this paper, we show how to create an extensible connector generator with features needed for heterogeneous deployment. The work is based on our experience with designing and implementing such an extensible connector generator for SOFA, Fractal and EJB component\u00a0\u2026", "num_citations": "21\n", "authors": ["584"]}
{"title": "High-level mission specification for multiple robots\n", "abstract": " Mobile robots are increasingly used in our everyday life to autonomously realize missions. A variety of languages has been proposed to support roboticists in the systematic development of robotic applications, ranging from logical languages with well-defined semantics to domain-specific languages with user-friendly syntax. The characteristics of both of them have distinct advantages, however, developing a language that combines those advantages remains an elusive task. We present PROMISE, a novel language that enables domain experts to specify missions on a high level of abstraction for teams of autonomous robots in a user-friendly way, while having well-defined semantics. Our ambition is to permit users to specify high-level goals instead of a series of specific actions the robots should perform. The language contains a set of atomic tasks that can be executed by robots and a set of operators that allow the\u00a0\u2026", "num_citations": "20\n", "authors": ["584"]}
{"title": "Gossiping components for cyber-physical systems\n", "abstract": " Developing software for dynamic cyber-physical systems (CPS) is a complex task. One has to deal with the dynamicity and unreliability of the physical environment where the software resides in, while, at the same time, provide sufficient levels of dependability and scalability. Although emerging software engineering abstractions, such as dynamic ad-hoc component ensembles, provide a convenient way to structure software for dynamic CPS, they need to be mapped to robust decentralized execution schemes in real-life settings. A particular challenge in this context is the robust distributed data dissemination in dynamic networks. Gossip-based communication stands as a promising solution to this challenge. We argue, that exploitation of application-specific information, software architecture in particular, has a large potential for improving the robustness and performance of gossip-based communication. This\u00a0\u2026", "num_citations": "20\n", "authors": ["584"]}
{"title": "Requirement specifications using natural languages\n", "abstract": " We discuss the part of the requirement specification process which is located between the textual requirements definition and the semi-formal diagrams of the requirements specifications.It concerns the acquisition and the refinement of requirements, the modeling in UML, and the consensus improvement between the analyst and the user. We point out open problems in this area that include natural language processing (eg automatic construction of UML diagrams from a parsed text of requirements), ontologies, constraints, solution scope and optional requirements, requirement inconsistency, querying for completness improvement and refinement of requirements, ambiguity, traceability of requirements, and validation feedbacks.", "num_citations": "20\n", "authors": ["584"]}
{"title": "Property networks allowing oracle-based mode-change propagation in hierarchical components\n", "abstract": " Strong pressure on deployment of embedded control systems on a low-cost hardware leads to the need of optimizing software architectures to minimize resource demands. Nevertheless, releasing the resources not needed in specific phases of system execution is only rarely supported by todays component frameworks, mainly since information about the system state is spread over several components, which makes the idea hard to implement.", "num_citations": "20\n", "authors": ["584"]}
{"title": "Runtime support for advanced component concepts\n", "abstract": " Component-based development has become a recognized technique for building large scale distributed applications. Although the maturity of this technique, there appears to be quite a significant gap between (a) component systems that are rich in advanced features (e.g., component nesting, software connectors, versioning, dynamic architectures), but which have typically only poor or even no runtime support, and (b) component systems with a solid runtime support, but which typically possess only a limited set of the advanced features. In our opinion, this is mainly due to the difficulties that arise when trying to give proper semantics to the features and reify them in development tools and an runtime platform. In this paper, we describe the implementation of the runtime environment for the SOFA 2.0 component model. In particular, we focus on the runtime support of the advanced features mentioned above. The\u00a0\u2026", "num_citations": "19\n", "authors": ["584"]}
{"title": "The role of ontologies in schema-based program synthesis\n", "abstract": " Program synthesis is the process of automatically deriving executable code from (non-executable) high-level specifications. It is more flexible and powerful than conventional code generation techniques that simply translate algorithmic specifications into lower-level code or only create code skeletons from structural specifications (such as UML class diagrams). Key to building a successful synthesis system is specializing to an appropriate application domain. The AUTOBAYES and AUTOFILTER systems, under development at NASA Ames, operate in the two domains of data analysis and state estimation, respectively. The central concept of both systems is the schema, a representation of reusable computational knowledge. This can take various forms, including high-level algorithm templates, code optimizations, datatype refinements, or architectural information. A schema also contains applicability conditions that are used to determine when it can be applied safely. These conditions can refer to the initial specification, to intermediate results, or to elements of the partially-instantiated code. Schema-based synthesis uses AI technology to recursively apply schemas to gradually refine a specification into executable code. This process proceeds in two main phases. A front-end gradually transforms the problem specification into a program represented in an abstract intermediate code. A backend then compiles this further down into a concrete target programming language of choice. A core engine applies schemas on the initial problem specification, then uses the output of those schemas as the input for other schemas, until the full implementation is\u00a0\u2026", "num_citations": "19\n", "authors": ["584"]}
{"title": "Adapting a system with noisy outputs with statistical guarantees\n", "abstract": " Many complex systems are intrinsically stochastic in their behavior which complicates their control and optimization. Current self-adaptation and self-optimization approaches are not tailored to systems that have (i) complex internal behavior that is unrealistic to model explicitly,(ii) noisy outputs,(iii) high cost of bad adaptation decisions, ie systems that are both hard and risky to adapt at runtime. In response, we propose to model the system to be adapted as black box and apply state-of-the-art optimization techniques combined with statistical guarantees. Our main contribution is a framework that combines runtime optimization with guarantees obtained from statistical testing and with a method for handling cost of bad adaptation decisions. We evaluate the feasibility of our approach by applying it on an existing traffic navigation self-adaptation exemplar.", "num_citations": "18\n", "authors": ["584"]}
{"title": "Architecture adaptation based on belief inaccuracy estimation\n", "abstract": " Cyber-physical systems (CPS) are systems of cooperating autonomous components which closely interact with and control the physical environment. Being distributed and typically based on periodic activities, CPS have to cope with the problem that data capturing a distributed state of the system and its environment are inherently inaccurate (they represent belief on the state). In particular, this poses a problem when dependability is being pursued. In this paper we address this issue by modeling belief at the architecture level. In particular, we enhance the architecture by models describing belief inaccuracy over time. We exploit these models to quantify at runtime the impact of belief staleness on its inaccuracy. We then use this quantification to drive architectural adaptation with the aim to increase dependability of the running CPS system.", "num_citations": "18\n", "authors": ["584"]}
{"title": "Performance awareness in component systems: Vision paper\n", "abstract": " Resource awareness is a key requirement for dynamic adaptation in resource-constrained systems. Achieving resource awareness with clean separation of concerns and reasonable overhead is still a challenge - especially where this awareness concerns runtime performance. Among the difficult issues are for example transparent performance monitoring or platform independent performance evaluation. To advance the current state of the art in resource awareness, we propose a performance awareness framework for the domain of component-based systems. The framework is based on the Stochastic Performance Logic (SPL), which enables explicit description and automatic evaluation of assumptions about performance using logic formulas. We demonstrate the potential of the framework on multiple use-cases and outline extensions that facilitate the runtime resource awareness.", "num_citations": "18\n", "authors": ["584"]}
{"title": "Logic-based modeling of information transfer in cyber\u2013physical multi-agent systems\n", "abstract": " In modeling multi-agent systems, the structure of their communication is typically one of the most important aspects, especially for systems that strive toward self-organization or collaborative adaptation. Traditionally, such structures have often been described using logic-based approaches as they provide a formal foundation for many verification methods. However, these formalisms are typically not well suited to reflect the stochastic nature of communication in the cyber\u2013physical setting. In particular, their level of abstraction is either too high to provide sufficient accuracy or too low to be practicable in more complex models. Therefore, we propose an extension of the logic-based modeling language SALMA, which we have introduced recently, that provides adequate high-level constructs for communication and data propagation, explicitly taking into account stochastic delays and errors. In combination with SALMA\u2019s\u00a0\u2026", "num_citations": "17\n", "authors": ["584"]}
{"title": "The invariant refinement method\n", "abstract": " The chapter describes IRM, a method that guides the design of smart-cyber physical systems that are built according to the autonomic service-component paradigm. IRM is a requirements-oriented design method that focuses on distributed collaboration. It relies on the invariant concept to model both high-level system goals and low-level software obligations. In IRM, high-level invariants are iteratively decomposed into more specific sub-invariants up to the level that they can be operationalized by autonomous components and component collaborations (ensembles). We present the main concepts behind the method, as well the main decomposition patterns that back up the design process, and illustrate them in the ASCENS e-mobility case study.", "num_citations": "17\n", "authors": ["584"]}
{"title": "Scalable element-based connectors\n", "abstract": " Connectors are used in component-based systems as first-class entities to abstract component interactions. In this paper, we propose a way to compose connectors by using fine-grained elements, each of them representing a single, well-defined function. We identify an experimentally proven set of connector elements, which, composed together, model four basic component interconnection types (procedure call, messaging, streaming, blackboard), and allow for connector variants to reflect distribution, security, fault-tolerance, etc. The presented results are based on a proof-of-the-concept implementation where connectors are semi-automatically generated.", "num_citations": "17\n", "authors": ["584"]}
{"title": "Tuning self-adaptation in cyber-physical systems through architectural homeostasis\n", "abstract": " Self-adaptive software-intensive cyber-physical systems (sasiCPS) encounter a high level of run-time uncertainty. State-of-the-art architecture-based self-adaptation approaches assume designing against a fixed set of situations that warrant self-adaptation. As a result, failures may appear when sasiCPS operate in environment conditions they are not specifically designed for. In response, we propose to increase the homeostasis of sasiCPS, i.e., the capacity to maintain an operational state despite run-time uncertainty, by introducing run-time changes to the architecture-based self-adaptation strategies according to environment stimuli. In addition to articulating the main idea of architectural homeostasis, we introduce four mechanisms that reify the idea: (i) collaborative sensing, (ii) faulty component isolation from adaptation, (iii) enhancing mode switching, and (iv) adjusting guards in mode switching. Moreover, our\u00a0\u2026", "num_citations": "16\n", "authors": ["584"]}
{"title": "Strengthening architectures of smart CPS by modeling them as runtime product-lines\n", "abstract": " Smart Cyber-Physical Systems (CPS) are complex distributed decentralized systems of cooperating mobile and stationary devices which closely interact with the physical environment. Although Component-Based Development (CBD) might seem as a viable solution to target the complexity of smart CPS, existing component models scarcely cope with the open-ended and very dynamic nature of smart CPS. This is especially true for design-time modeling using hierarchical explicit architectures, which traditionally provide an excellent means of coping with complexity by providing multiple levels of abstractions and explicitly specifying communication links between component instances. In this paper we propose a modeling method (materialized in the SOFA NG component model) which conveys the benefits of explicit architectures of hierarchical components to the design of smart CPS. Specifically, we base our\u00a0\u2026", "num_citations": "16\n", "authors": ["584"]}
{"title": "Using DSL for automatic generation of software connectors\n", "abstract": " Component-based engineering is a recognized paradigm, which models an application as a collection of reusable components. The key idea behind components is that they contain only the business logic and communicate with one another only via well-defined interfaces. The communication paths among components (so called bindings) are in modern component systems realized by software connectors, which allow explicit modeling of communication and also its implementation at runtime. An important aspect of using connectors is the possibility of their automatic generation, which saves a significant amount of development work. However, the generation itself is not a trivial task, since there is a big semantic gap between the abstract specification of a connector at design time and its implementation at runtime. In this paper, we present an approach to generating implementations of software connectors. The\u00a0\u2026", "num_citations": "16\n", "authors": ["584"]}
{"title": "DEECo: an ecosystem for cyber-physical systems\n", "abstract": " In this work we tackle the problem of designing and developing software-intensive cyber-physical systems (CPS), which are large distributed systems of collaborating elements that closely interact with the physical world, such as intelligent transportation systems and crowdsourcing applications. Due to their specific constraints, such as extreme dynamism and continuous evolution of the physical substratum, and requirements, such us open-endedness and adaptability, CPS introduce many new challenges for software engineering. In response, we present a tailored ecosystem of software engineering models, methods, and tools. This ecosystem is centered on the DEECo component model, which we have proposed specifically for architecting software-intensive CPS.", "num_citations": "15\n", "authors": ["584"]}
{"title": "Strengthening adaptation in cyber-physical systems via meta-adaptation strategies\n", "abstract": " The dynamic nature of complex Cyber-Physical Systems puts extra requirements on their functionalities: they not only need to be dependable, but also able to adapt to changing situations in their environment. When developing such systems, however, it is often impossible to explicitly design for all potential situations up front and provide corresponding strategies. Situations that come out of this \u201cenvelope of adaptability\u201d can lead to problems that end up by applying an emergency fail-safe strategy to avoid complete system failure. The existing approaches to self-adaptation cannot typically cope with such situations better\u2014while they are adaptive (and can apply learning) in choosing a strategy, they still rely on a pre-defined set of strategies not flexible enough to deal with those situations adequately. To alleviate this problem, we propose the concept of meta-adaptation strategies, which extends the limits of\u00a0\u2026", "num_citations": "14\n", "authors": ["584"]}
{"title": "Sofa 2 component framework and its ecosystem\n", "abstract": " Component-based software development represents a common practice to assemble various kinds of systems using well-defined building blocks called components.SOFA 2 is an advanced component framework providing a rich set of features including hierarchical architectures, multiple communication styles, behavior specification, transparent distribution, etc. The framework also introduces a well-defined development methodology supported by a rigorous component model and rich set of tools enabling application design, deployment, and execution. Furthermore, SOFA 2 is suitable for development of systems for multiple application domains. To allow this, SOFA 2 offers a concept of \u201cprofiles\u201d, which extend the core of the framework to be suitable for a particular domain. Currently, profiles for Java, Java ME and embedded C-based systems exist, utilizing a common development methodology and tooling.This\u00a0\u2026", "num_citations": "14\n", "authors": ["584"]}
{"title": "Verifying temporal properties of use-cases in natural language\n", "abstract": " This paper presents a semi-automated method that helps iteratively write use-cases in natural language and verify consistency of behavior encoded within them. In particular, this is beneficial when the use-cases are created simultaneously by multiple developers. The proposed method allows verifying the consistency of textual use-case specification by employing annotations in use-case steps that are transformed into temporal logic formulae and verified within a formal behavior model. A supporting tool for plain English use-case analysis is currently being enhanced by integrating the verification algorithm proposed in the paper.", "num_citations": "14\n", "authors": ["584"]}
{"title": "Using a product line for creating component systems\n", "abstract": " Component systems have become a wide-spread technology and found their place in several application domains. Each component system has its specifics and particularities that reflect its focus and the application domain it is intended for. Although important, the diversity of component systems leads to a number of problems including having different tools for each systems, unnecessary duplication of functionality and problems with integration when several domains are to be targeted. Based on categorization of component application domains, we propose a\" meta-component system\", which provides a software product line for creating custom component systems. We focus especially on the deployment and execution environment, which is where most diversities are found. We demonstrate the usage of the\" meta-component system\" and propose how it is to be realized by two core concepts of SOFA 2, namely\u00a0\u2026", "num_citations": "14\n", "authors": ["584"]}
{"title": "Using connectors for deployment of heterogeneous applications in the context of OMG D&C Specification\n", "abstract": " Component-based software engineering is a paradigm advancing a view of constructing software from reusable building blocks, components. A component is typically a black box with a well defined interface, performing a known function. The concept builds on the techniques well known from modular programming, which encourage the developers to split a large and complex system into smaller and better manageable functional blocks and attempt to minimize dependencies between those blocks.Several aspects of component-based programming have been embraced by the software development industry and as a result, there are now several component models, such as Enterprise Java Beans [12] by Sun Microsystems, CORBA Component Model [8] by OMG, and. Net [5] by Microsoft, which are extensively used for production of complex software systems. There are also a large number of other component\u00a0\u2026", "num_citations": "14\n", "authors": ["584"]}
{"title": "Intelligent ensembles-a declarative group description language and java framework\n", "abstract": " Smart cyber-physical systems (sCPS) is a growing research field focused on scenarios such as smart cities or smart mobility, where autonomous components are deployed in a physical environment, and are expected to cooperate with one another, as well as with humans. As these systems typically operate in a highly uncertain and dynamically changing environment, being able to cooperate and adapt in groups to cope with various (possibly unanticipated) situations becomes a crucial and challenging task. In this artifact, we respond to this challenge by presenting the Intelligent Ensembles framework, consisting of a high-level declarative language for describing dynamic cooperation groups, and a Java runtime library for automatically forming groups that best satisfy the given specification. The framework provides dynamic architecture adaptation (i.e., forming groups of components and exchanging data between\u00a0\u2026", "num_citations": "13\n", "authors": ["584"]}
{"title": "Towards intelligent ensembles\n", "abstract": " Recently, several ensemble-based component models have been created to address the dynamicity and complexity of designing cyber-physical systems. Experience in applying these models to actual case studies has shown that there are still scenarios in distributed organization that are hard to capture by utilizing only the concepts of these component models. In this paper, we present a summary of issues encountered, based on the analysis of selected case studies. We propose new concepts that build on those contained in ensemble-based models. In particular, we introduce the ideas of ensemble nesting, dynamic role cardinalities and ensemble fitness. These concepts and their support in the runtime framework aim at serving as a bridge between high-level ensemble formation rules and low-level decentralized implementation. These concepts are illustrated on one of the case studies, demonstrating a domain\u00a0\u2026", "num_citations": "13\n", "authors": ["584"]}
{"title": "Model problem and testbed for experiments with adaptation in smart cyber-physical systems\n", "abstract": " In this artifact, we partially address the problem of development of smart Cyber-Physical Systems (sCPS) by providing a concrete model problem and testbed for experimenting with, comparing, and developing new adaptation techniques and algorithms pertinent to sCPS. In particular, our model problem features autonomous robots cooperating opportunistically in a highly dynamic environment with multiple sources of uncertainty and runtime failures. Our testbed provides ROS-based Stage simulation of the model problem reified in a swarm of Turtlebot robots. The testbed ties this to timing-, bandwidth- and mobility-aware simulation of the robot communication (based on OMNeT++). To enable fast prototyping, the testbed abstracts robots as autonomous components (implemented in Java) and allows describing robot communication via dynamic collaboration groups (ensembles). It also points to specific places in the\u00a0\u2026", "num_citations": "12\n", "authors": ["584"]}
{"title": "Statistical approach to architecture modes in smart cyber physical systems\n", "abstract": " Smart Cyber-Physical Systems (sCPS) are complex distributed decentralized systems of cooperating components. They typically operate in uncertain environments and thus require means for managing variability at run-time. Architectural modes have traditionally been a proven means for the runtime variability. They are easy to understand, easy to realize in resource-constrained systems and (contrary to more sophisticated methods of learning) provide an explicit specification that can be inspected and validated at design time. However, in uncertain environments (which is the case of sCPS), they tend to lack expressivity to take into account the level of uncertainty and factor it in the mode-switching logic. In this paper we present a rich language to specify mode-switch guards. The semantics of the language is based on statistical tests, which, as we show, is a convenient way to reason about uncertainty in the state of\u00a0\u2026", "num_citations": "12\n", "authors": ["584"]}
{"title": "The E-mobility case study\n", "abstract": " Electro-mobility (e-mobility) is one of the promising technologies being considered by automotive OEMs as an alternative to internal combustion engines as a means of propulsion. The e-mobility case study provides a novel example of a relevant industry application within the ASCENS framework. An overview of the system design is given which describes how e-mobility is conceptualized and then transformed using the ensemble development life cycle (EDLC) approach into a distributed autonomic (i.e self-aware, self-adaptive) component-based software system. The system requirements engineering is based on the state-of-the-affairs (SOTA) approach and the invariant refinement method (IRM) which are both revisited and applied. Regarding the implementation and deployment of the system, a dependable emergent ensembles of components (DEECo) approach is utilized. The DEECo components and\u00a0\u2026", "num_citations": "12\n", "authors": ["584"]}
{"title": "Supporting real-time features in a hierarchical component system\n", "abstract": " The thesis focuses on an extension of the SOFA 2 component system allowing development of high-integrity real-time embedded systems using the component-based development approach. SOFA 2 employs a hierarchical component model and many advanced features which may be useful in this area of software development. The thesis offers discussion about necessary changes and features that needs to be incorporated into the SOFA 2 component system. The thesis also consists of design and prototype implementation of the extension in order to realise and prove the viability of the proposed concepts. This implementation allows development of high-integrity real-time embedded systems by its decomposition into components which offers strict separation of concerns and higher reuse. The prototype implementation aims to reuse as much as possible of the existing SOFA 2 tools and code. Use cases and comparison with related work is provided to demonstrate usability and features of the prototype implementation.", "num_citations": "12\n", "authors": ["584"]}
{"title": "Advanced Features of Hierarchical Component Models.\n", "abstract": " Using software components has become a widely used development technique for building large enterprise systems. However in practice, component applications are still primarily built using simple component models and advanced component models offering valuable features like component nesting, multiple communication styles, behavior validation, etc. are omitted (by industry in particular). Based on our experience, such an omitting is mainly caused due to usually unbalanced semantics of these advanced features. In this paper, we present a \u201cnextgeneration\u201d component model SOFA 2.0, which in particular aims at a proper support of such advanced features.", "num_citations": "12\n", "authors": ["584"]}
{"title": "A language and framework for dynamic component ensembles in smart systems\n", "abstract": " Smart system applications (SSAs)\u2014a heterogeneous landscape of applications of Internet of things, cyber-physical systems, and smart sensing systems\u2014are composed of autonomous yet inherently cooperating components. An important problem in this area is how to hoist the cooperation of software components forming dynamic groups\u2014ensembles\u2014at the architectural level of an SSA. This is hard since ensembles can overlap, be nested, and be dynamically formed and dismantled based on several criteria. A related problem is how to combine component and ensemble specification with a well-established language supported on multiple platforms. To target these problems, we propose a specification and implementation language Trait-based COmponent Ensemble Language (TCOEL) based on Scala internal DSL, to describe both the architecture and formation of dynamic ensembles of components and their\u00a0\u2026", "num_citations": "11\n", "authors": ["584"]}
{"title": "Towards performance-aware engineering of autonomic component ensembles\n", "abstract": " Ensembles of autonomic components are a novel software engineering paradigm for development of open-ended distributed highly dynamic software systems (e.g. smart cyber-physical systems). Recent research centered around the concept of ensemble-based systems resulted in design and development models that aim to systematize and simplify the engineering process of autonomic components and their ensembles. These methods highlight the importance of covering both the functional concepts and the non-functional properties, specifically performance-related aspects of the future systems. In this paper we propose an integration of the emerging techniques for performance assessment and awareness into different stages of the development process. Our goal is to aid both designers and developers of autonomic component ensembles with methods providing performance awareness throughout\u00a0\u2026", "num_citations": "11\n", "authors": ["584"]}
{"title": "DEECo computational model\u2013I\n", "abstract": " This report provides the formalization of DEECo concepts and operational semantic of DEECo systems. Further, it establishes the refinement relation and shows the centralized tuple space semantics (as featured by local and Apache River-based knowledge providers in jDEECo).", "num_citations": "11\n", "authors": ["584"]}
{"title": "Meta-adaptation strategies for adaptation in cyber-physical systems\n", "abstract": " Modern Cyber-Physical Systems (CPS) not only need to be dependable, but also resilient to and able to adapt to changing situations in their environment. When developing such CPS, however, it is often impossible to anticipate all potential situations upfront and provide corresponding tactics. Situations that lie out of this \u201cenvelope of adaptability\u201d can lead to problems that range from single component malfunctioning to complete system failure. The existing approaches to self-adaptation cannot typically cope with such situations as they still rely on a fixed set of tactics, which in case of complex systems does not guarantee achieving correct functionality. To alleviate this problem, we propose the concept of meta-adaptation strategies, which extends the limits of adaptability of a system by constructing new tactics at runtime to reflect the changes in the environment. The approach is demonstrated on an existing\u00a0\u2026", "num_citations": "10\n", "authors": ["584"]}
{"title": "Checking fractal component behavior using behavior protocols\n", "abstract": " Building applications from of-the-shelf pieces, like libraries and components, is a promising approach to the future of software development. As such pieces are a subject to reuse, they have to have their interfaces and semantics clearly defined. To combine components from various vendors, one need a way to reason about component compatibility. Our experience with distributed component-based application has shown that reasoning about component compatibility based only on comparing component types (interface/method signatures) is not sufficient. Therefore, a kind of component semantic/behavioral specification is necessary. Fractal [1] provides a hierarchical component model, where components may be nested (forming composite components) and only the lowest-level (primitive) components are implemented in a programming language. The architecture of a component application is described in the Fractal Architecture Description Language (ADL). For each component, its behavioral specification may be stated in the application ADL file. In this paper, we describe results of the work on the \u201cComponent Reliability Extensions for Fractal Component Model\u201d project [7] funded by France Telecom. The goal of the project is to extend the Fractal Component model and its Julia implementation with support for behavior protocols [8]. The paper is structured as follows: In Sect. 2, behavior protocols as a way of specifying component behavior are described, while Sect. 3 introduces various types of compatibility checks. Sect. 4 provides evaluation and concludes the paper.", "num_citations": "10\n", "authors": ["584"]}
{"title": "Cost-aware stage-based experimentation: challenges and emerging results\n", "abstract": " Experimentation at post-deployment phases (in production environments) can be a powerful tool for both learning how a deployed system operates and how it is being used. Though this knowledge is invaluable for optimization of the system, collecting it may require long time and experiments may even worsen the system with negative effects on users and business. This calls for methods for performing experimentation in production environments that balance the profit of experimentation with its cost. In this paper, we describe related challenges and our emerging results towards cost-aware stage-based experimentation. In particular, we aim for performing experiments that optimize towards their profit while making sure that the overall experimentation cost (e.g. total experimentation time) stays within given bounds. First, we illustrate the challenges and needs of such experimentation in two use cases from different\u00a0\u2026", "num_citations": "9\n", "authors": ["584"]}
{"title": "Towards verification of ensemble-based component systems\n", "abstract": " The relatively new domain of Ensemble-Based Component Systems (EBCS) brings a number of important verification challenges that stem mainly from the dynamism of EBCS. In this paper, we elaborate on our previous work on EBCS verification. In particular, we focus on verification of applications based on the DEECo component model \u2013 a representative of EBCS \u2013 and evaluate it on a real-life case study. Since our verification technique employs a specialized DEECo semantics to make the verification problem tractable, our goal is to investigate the practical relevance of the properties that can be addressed by the verification. Specifically, we compare the specialized semantics with the realistic general semantics of DEECo to identify verification properties that are preserved by the specialized semantics. We further investigate the tractability of verification of these properties on a real-life case study from the\u00a0\u2026", "num_citations": "9\n", "authors": ["584"]}
{"title": "From textual use-cases to component-based applications\n", "abstract": " A common practice to capture functional requirements of a software system is to utilize use-cases, which are textual descriptions of system usage scenarios written in a natural language. Since the substantial information about the system is captured by the use-cases, it comes as a natural idea to generate from these descriptions the implementation of the system (at least partially). However, the fact that the use-cases are in a natural language makes this task extremely difficult. In this paper, we describe a model-driven tool allowing code of a system to be generated from use-cases in plain English. The tool is based on the model-driven development paradigm, which makes it modular and extensible, so as to allow for use-cases in multiple language styles and generation for different component frameworks.", "num_citations": "9\n", "authors": ["584"]}
{"title": "Formal verification of annotated textual use-cases\n", "abstract": " Textual use-cases have been traditionally used in the initial stages of the software development process to describe software functionality from the user's perspective. Their advantage is that they can be easily understood by stakeholders and domain experts. However, since use-cases typically rely on natural language, they cannot be directly subject to a formal verification. In this article, we present a method (called Formal Verification of Annotated Use-Case Models, FOAM) for formal verification of use-cases. This method features simple user-definable annotations, which are inserted into a use-case to make its semantics more suitable for verification. Subsequently, a model-checking tool is employed to verify temporal invariants associated with the annotations. This way, FOAM allows harnessing the benefits of model checking while still keeping the use-cases understandable for non-experts.", "num_citations": "8\n", "authors": ["584"]}
{"title": "Bridging the component-based and service-oriented worlds\n", "abstract": " The component-based and service-oriented development have become commonly used techniques for building high quality, evolvable, large systems in a timely and affordable manner. In heterogeneous software systems, both approaches can coexist and complement each other. In this setting, interoperability is one the essential issues, since it enables composition of diverse components and services.In the paper, we analyze possibilities of interoperability between component systems and the service oriented platforms and based on that we propose a solution for their mutual collaboration. To demonstrate the concepts, we use SOFA 2 as the particular component platform and OSGi service platform as the particular service platform.", "num_citations": "8\n", "authors": ["584"]}
{"title": "Eliminating execution overhead of disabled optional features in connectors\n", "abstract": " Connectors are used to realize component interactions in component systems. Apart from their primary function, which is mediating the communication, their implementation can also support additional features that, while unrelated to the primary function, may benefit from their placement in connectors. Such features are often optional in the sense that they can be activated and deactivated at run-time. The problem is that even if they are disabled, their very presence in the connector incurs certain overhead. In this paper, we describe an approach to eliminate this overhead by reconfiguration of the connector implementation. Besides connectors, the approach is applicable to similar technologies such as reflective middleware and other architecture-based component systems and frameworks.", "num_citations": "8\n", "authors": ["584"]}
{"title": "Composing connectors of elements\n", "abstract": " Connectors are used in component-based systems as first-class entities to abstract component interactions. To explain their responsibilities, several taxonomies have been published to date. However, most of them mix different levels of abstraction and fail to provide any guidelines that address different component interconnections through \u201creal connectors\u201d(employed in assembling real-life applications).In this paper, we propose a way to compose connectors by using fine-grained elements, each of them representing only a single, well-defined functionality. We identify an experimentally proven set of connector elements, which, composed together, model four basic component interconnection types (procedure call, messaging, streaming, blackboard), and allow for connector variants as well (to reflect distribution, security, fault-tolerance, etc.). The presented results are based on a proof-of-the-concept implementation where connectors are automatically generated (assuming description of connector structure and middleware technologies are provided). Thanks to the element composition approach, such connectors can support more middleware technologies at the same time.", "num_citations": "8\n", "authors": ["584"]}
{"title": "Dynamic security specification through autonomic component ensembles\n", "abstract": " One of the key properties of autonomic component systems is their dynamicity and context-dependence of their behavior. In contrast to systems with a static architecture, their components interact and collaborate in an ad-hoc fashion depending on their internal state and location, the state of other components and their locations, timing and history of events/state of external (uncontrolled) environment. This high degree of dynamicity collides with traditional approaches to security, which typically rely on static hierarchies of roles and a static assignment of roles. To address this problem, we formulate security rules which are autonomically composable and context-dependent; in their evolution, they follow the dynamicity and context-dependence of the autonomic components. Based on our previous work with autonomic component ensembles, we show how ensembles can be exploited to define security rules\u00a0\u2026", "num_citations": "7\n", "authors": ["584"]}
{"title": "The Two-Hemisphere Modelling Approach to the Composition of Cyber-Physical Systems.\n", "abstract": " The Two-hemisphere model-driven (2HMD) approach assumes modelling and use of procedural and conceptual knowledge on an equal and related basis. This differentiates 2HMD approach from pure procedural, pure conceptual, and object oriented approaches. The approach may be applied in the context of modelling of a particular business domain as well as in the context of modelling the knowledge about the domain. Cyber-physical systems are heterogeneous systems, which require multi-disciplinary approach to their modelling. Modelling of cyber-physical systems by 2HMD approach gives an opportunity to transparently compose and analyse system components to be provided and components actually provided, and, thus, to identify and fill the gaps between desirable and actual system content.", "num_citations": "7\n", "authors": ["584"]}
{"title": "Automated resolution of connector architectures using constraint solving (ARCAS method)\n", "abstract": " In current software systems, connectors play an important role by encapsulating the communication and coordination logic. Since they share common patterns (elements) depending on characteristics of the connections, the elements can be predefined and reused. A method of connector implementation based on a composition of predefined elements naturally comprises two steps: resolution of the connector architecture, and creation of the actual connector code based on the architecture. However, manual resolution of a connector architecture is very difficult due to the number of factors to be considered. Thus, the challenge is to come up with an automated method, able to address all the important factors. In this paper, we present a method for automated resolution of connector architectures based on constraint solving techniques. We exploit a propositional logic with relational calculus for defining a\u00a0\u2026", "num_citations": "7\n", "authors": ["584"]}
{"title": "Adaptation in Cyber-Physical Systems: from System Goals to Architecture Configurations\n", "abstract": " Design of self-adaptive Cyber-Physical Systems (CPS) operating in not fully anticipated environments is a significant challenge, especially if the design is to provide for a sufficient level of dependability. This stems partly from the fact that the concerns of self-adaptivity and dependability are to certain extent contradictory. In this paper, we present an extension to IRM (Invariant Refinement Method)\u2013a design method and associated formally grounded model targeting CPS\u2013that addresses self-adaptivity while preserving the dependability aspects. Specifically, we extend IRM to provide traceability between system requirements, distinct situations in the environment, and predefined configurations of system architecture. Additionally, based on this traceability, we propose a method for adaptation at runtime that allows coping with unanticipated situations. As a proof of concept, we implemented the proposed method for the DEECo component model, based on dynamic ensembles of components.", "num_citations": "7\n", "authors": ["584"]}
{"title": "Software engineering for software-intensive cyber-physical systems\n", "abstract": " In software-intensive cyber-physical systems (siCPS) the interplay of software control with the physical environment has a prominent role. Nowadays, siCPS are expected to (i) effectively deal with the issues of distribution, scalability, and environment dynamicity, (ii) control their emergent behavior, and, at the same time, (iii) be versatile and tolerant in face of changes and threats. Although approaches that individually meet the above requirements of siCPS already exist, their synergy in a comprehensive software engineering framework is far from trivial. In this paper, we pinpoint the important characteristics of engineering siCPS in an attempt to show that they introduce distinct challenges to traditional software engineering. We argue that this can be addressed by a synergy and adaptation of existing models and abstractions, show our proposal towards such a synergy, and discuss its implications.", "num_citations": "7\n", "authors": ["584"]}
{"title": "Engineering autonomous systems\n", "abstract": " Future technology needs adaptive, autonomous, self-aware and intelligent behavior offering solutions that are intuitively integrated in our everyday surroundings. One such approach is presented illustrating the major engineering process of autonomous systems' construction. The dynamism and autonomous nature of the system elements is modeled by the novel communication/distribution principle that is knowledge-and predicate-based, allowing for late (at run-time) evaluation of communication and connection rules among the system elements. The approach is presented in terms of the major development life-cycle phases--requirements specification, modeling and deployment--and is illustrated on a concrete application example.", "num_citations": "7\n", "authors": ["584"]}
{"title": "Extensible Polyglot Programming Support in Existing Component Frameworks\n", "abstract": " Utilization of various agile development practices brings demand of short development cycle with stress on early deployment and rapid delivery. Such practices require techniques permitting rapid prototyping of systems, corresponding tests and simulations. One of the well-adopted rapid prototyping techniques is polyglot programming combining multiple, mainly scripting, languages during development of systems. This permits the use of a specialized language for dedicated system concerns and also allows for a continuous change and re-deployment of implementation. Despite the advantages, rapid prototyping with help of polyglot programming is still not well supported in the domain of component-based systems, which makes it difficult to quickly prototype and test these systems. To address the obstacle, the paper describes a general technique for transparent and extensible combining of multiple languages for\u00a0\u2026", "num_citations": "7\n", "authors": ["584"]}
{"title": "Supporting real-life applications in hierarchical component systems\n", "abstract": " Component-based development has become a widely accepted programming technique. However, the current situation in usage of component systems is that most of the widely used systems are flat ones while hierarchical systems (which are more advanced and elaborated) are rather ignored by industry. In our view, the situation is caused by a poor support of features necessary to built real-life applications in hierarchical component systems. In the paper, based on several real-life case-studies, we show a set of typical architecture patterns, which have to be supported by hierarchical component systems, and also we evaluate how these patterns are supported by current systems.", "num_citations": "7\n", "authors": ["584"]}
{"title": "Managing latency in edge\u2013cloud environment\n", "abstract": " Modern Cyber\u2013physical Systems (CPS) include applications like smart traffic, smart agriculture, smart power grid, etc. Commonly, these systems are distributed and composed of end-user applications and microservices that typically run in the cloud. The connection with the physical world, which is inherent to CPS, brings the need to operate and respond in real-time. As the cloud becomes part of the computation loop, the real-time requirements have to be also reflected by the cloud. In this paper, we present an approach that provides soft real-time guarantees on the response time of services running in cloud and edge\u2013cloud (i.e., cloud geographically close to the end-user), where these services are developed in high-level programming languages. In particular, we elaborate a method that allows us to predict the upper bound of the response time of a service when sharing the same computer with other services\u00a0\u2026", "num_citations": "6\n", "authors": ["584"]}
{"title": "Toward autonomically composable and context-dependent access control specification through ensembles\n", "abstract": " Dynamicity and context dependence are some of the key properties of autonomic component systems that include a large spectrum of today\u2019s modern smart systems. In these systems, components dynamically re-group themselves, interact and collaborate in an ad hoc fashion to collectively cope with situations in their environment. Though security and access control become the key concerns of these systems, the high degree of dynamicity and the potential open-endedness is incompatible with the traditional approaches to access control, which typically rely on static hierarchies of roles and a static assignment of roles. To address this problem, we formulate access control rules which allow for dynamic ad hoc collaboration at runtime and which follow the dynamicity and context dependence of the autonomic components. Based on our previous work with autonomic component ensembles, we show how the\u00a0\u2026", "num_citations": "6\n", "authors": ["584"]}
{"title": "Low-cost IoT, Big Data, and Cloud Platform for Developing Countries\n", "abstract": " Gartner forecasts that 6.4 billion connected things will be in use worldwide in 2016, up 30% from 2015, and will reach 20.8 billion by 2020. In 2016, 5.5 million new things will get connected every day. Furthermore, the current research and marker trends shows the convergence between IoT and Big Data. On the other hand, developing countries are still far from being able to benefit from IoT infrastructures. In this paper we explain how IoT can be made available for everybody and we present WAZIUP, a project aiming at building an open innovation platform able to accelerate innovation in developing countries and rural areas. The WAZIUP IoT platform will allow the development of IoT applications coupled with Big Data capabilities. The platform is tailored to the specific requirements and constraints of developing countries. We will give an overview of the WAZIUP IoT and Big Data platform and then detail its\u00a0\u2026", "num_citations": "6\n", "authors": ["584"]}
{"title": "IoT, big data, and cloud platform for rural African needs\n", "abstract": " IoT has not fully diffused in Africa to address various challenges faced by African people. To address the emergence and pervasiveness of IoT in Africa, we present an open IoT, and big data platform as an innovation platform to accelerate innovations in rural Africa. However, the technology is not dedicated to the rural cases; it is designed for any IoT application. The platform will allow to develop IoT applications coupled with Big Data capacities. Moreover, the platform can be tailored to the specific requirements and constraints of African users. In this paper, we give an overview of the proposed IoT and Big Data platform, detail its technical aspects, and finally introduce three use case deployments to prove the validity of platform architecture.", "num_citations": "6\n", "authors": ["584"]}
{"title": "Supporting performance awareness in autonomous ensembles\n", "abstract": " The ASCENS project works with systems of self-aware, self-adaptive and self-expressive ensembles. Performance awareness represents a concern that cuts across multiple aspects of such systems, from the techniques to acquire performance information by monitoring, to the methods of incorporating such information into the design making and decision making processes. This chapter provides an overview of five project contributions \u2013 performance monitoring based on the DiSL instrumentation framework, measurement evaluation using the SPL formalism, performance modeling with fluid semantics, adaptation with DEECo and design with IRM-SA \u2013 all in the context of the cloud case study.", "num_citations": "6\n", "authors": ["584"]}
{"title": "Position paper: towards a requirements-driven design of ensemble-based component systems\n", "abstract": " Although approaches that effectively address the distribution and dynamism of adaptive systems at a middleware level exist, the design of complex, ensemble-based systems still remains a significant challenge. This hinders the development of real-life applications based on the ensemble paradigm.", "num_citations": "6\n", "authors": ["584"]}
{"title": "Language for reconfiguring runtime infrastructure of component-based systems\n", "abstract": " A component system is not only composed of a model but also of an execution environment which is able to instantiate components described by the model. However, the execution environment reflecting a complex component model and its changes at runtime is a non-trivial and error-prone application. Hence it is beneficial to simplify and conceptualize the execution environment by having a simple way of describing component compositions and reconfigurations. In this paper we propose a minimalistic language which describes the composition of the component-based system\u2019s infrastructure in a procedural way and thus reduces the execution environment basically to a simple language interpreter.", "num_citations": "6\n", "authors": ["584"]}
{"title": "Addressing heterogeneity in OMG D&C-based deployment\n", "abstract": " The OMG Deployment and Configuration specification is an attempt at standardizing the deployment process of component-based applications in distributed environment. A software connector is an abstraction capturing interaction among components. Apart from middleware independence, connectors provide additional services (eg adaptation, monitoring, etc.) and benefits, especially in the area of integration of heterogeneous componentbased applications. This paper presents an approach for using connectors in the context of deployment process defined by the OMG Deployment and Configuration specification to overcome incompatibilities in different component models and allow for a true heterogeneous deployment.", "num_citations": "6\n", "authors": ["584"]}
{"title": "Modeling Data Flow Constraints for Design-Time Confidentiality Analyses\n", "abstract": " With the increase in connectedness and the growing volume of data, ensuring confidentiality becomes increasingly critical. Data-driven analyses try to cope with this complexity by automatically verifying confidentiality at design time. However, confidentiality constraints are manifold. Thus, analyses limit the software architect\u2019s possibilities of expression or require them to use the underlying verification formalism directly. We propose a domain-specific language to enable architects to formulate data flow constraints using the terminology and abstraction of the architectural domain. We present a mapping of data flow constraints and results which is compliant to the transformation of the architecture and evaluated based on real-world scenarios.", "num_citations": "5\n", "authors": ["584"]}
{"title": "Automated trainability evaluation for smart software functions\n", "abstract": " More and more software-intensive systems employ machine learning and runtime optimization to improve their functionality by providing advanced features (e. g. personal driving assistants or recommendation engines). Such systems incorporate a number of smart software functions (SSFs) which gradually learn and adapt to the users' preferences. A key property of SSFs is their ability to learn based on data resulting from the interaction with the user (implicit and explicit feedback)-which we call trainability. Newly developed and enhanced features in a SSF must be evaluated based on their effect on the trainability of the system. Despite recent approaches for continuous deployment of machine learning systems, trainability evaluation is not yet part of continuous integration and deployment (CID) pipelines. In this paper, we describe the different facets of trainability for the development of SSFs. We also present our\u00a0\u2026", "num_citations": "5\n", "authors": ["584"]}
{"title": "A framework for tunable anomaly detection\n", "abstract": " As software architecture practice relies more and more on runtime data to inform decisions in continuous experimentation and self-adaptation, it is increasingly important to consider the quality of the data used as input to the different decision-making and prediction algorithms. One issue in data-driven decisions is that real-life data coming from running systems can contain invalid or wrong values which can bias the result of data analysis. Data-driven decision-making should therefore comprise detection and handling of data anomalies as an integral part of the process. However, currently, anomaly detection is either absent in runtime decision-making approaches for continuous experimentation and self-adaptation or difficult to tailor to domain-specific needs. In this paper, we contribute by proposing a framework that simplifies the detection of data anomalies in timeseries-outputs of running systems. The framework is\u00a0\u2026", "num_citations": "5\n", "authors": ["584"]}
{"title": "Automated dynamic formation of component ensembles\n", "abstract": " Smart cyber-physical systems (sCPS) is a growing research field focused on scenarios where a set of autonomous software-hardware entities (components) is cooperating via network communication to achieve a type of swarm or cloud intelligence. Typically the components\u2019 cooperation is designed at a low level of abstraction and their behavior validated via simulations. As a remedy, a declarative language capable of specifying high-level component ensembles has been proposed in recent work. By capturing component functionality and the cooperation constraints, a specification serves both for generating platform-specific implementation and as a model@ run. time to support self-adaption via dynamic formation of ensembles. However, for a particular specification, multiple possible architectural configurations exist with various impact on the system. Given their typically large number, we select the best one via an SMT solver. In this paper, we show that scalability of such approach can be supported by exploiting the effect of locality in component cooperation and by hoisting specific domain knowledge to the level of architecture.", "num_citations": "5\n", "authors": ["584"]}
{"title": "Employing domain knowledge for optimizing component communication\n", "abstract": " The emerging area of (smart) Cyber Physical Systems (sCPS) triggers demand for new methods of design, development, and deployment of architecturally dynamic distributed systems. Current approaches (e.g. Component-Based Software Engineering and Agent-Based Development) become insufficient since they fail in addressing challenges specific to sCPS such as mobility, heterogeneous and unreliable deployment infrastructure, and architectural dynamicity. The strong dependence on the underlying communication infrastructure, often combining ad-hoc established links typical for wireless connectivity with more reliable connections of infrastructural networks, requires a novel method to optimize system deployment. In this paper we propose such a method based on the domain knowledge elicited from design level specification. As a proof of concept, we have provided an extension to the DEECo\u00a0\u2026", "num_citations": "5\n", "authors": ["584"]}
{"title": "Towards component-based design of safety-critical cyber-physical applications\n", "abstract": " Cyber-physical systems typically involve a large number of mobile autonomous devices that closely interact with each other and their environment. Standard design and development techniques from the embedded domain fail to accurately model the dynamics of such systems and, hence, there is an increasing need for new programming models and abstractions. Component-based design approaches are a promising solution to manage the complexity of large-scale dynamic systems. However, existing such approaches either do not accurately model transitory interactions between components -- which are typical of cyber-physical systems -- or do not provide guarantees for real-time behavior which is essential in many safety-critical applications. To overcome this problem, in this paper, we present a component-based design technique based on DEECo (Dependable Emergent Ensembles of Components). The\u00a0\u2026", "num_citations": "5\n", "authors": ["584"]}
{"title": "FOAM: A Lightweight Method for Verification of Use-Cases\n", "abstract": " The advantage of textual use-cases is that they can be easily understood by stakeholders and domain experts. However, since use-cases typically rely on a natural language, they cannot be directly subject to a formal verification. In this paper, we present the FOAM method which features simple user-definable annotations, inserted into a use-case to make its semantics more suitable for verification. Subsequently a model-checking tool verifies temporal invariants associated with the annotations. This way, FOAM allows for harnessing the benefits of model-checking while still keeping the use-cases understandable for non-experts.", "num_citations": "5\n", "authors": ["584"]}
{"title": "Formal verification of annotated use-cases\n", "abstract": " Textual use-cases have been traditionally used at the design stage of development process for describing software functionality from the user\u2019s view. Their advantage is that they can be easily understood by stakeholders and domain experts. However, since use-cases typically rely on a natural language, they cannot be directly subject to a formal verification. In this paper, we present Formal Verification of Annotated Use-Case Models (FOAM). This method features simple user-definable annotations, which are inserted into a use-case to make its semantics more suitable for verification. Subsequently a model-checking tool verifies temporal invariants associated with the annotations. This way, FOAM allows for harnessing the benefits of model-checking while still keeping the use-cases understandable for non-experts.", "num_citations": "5\n", "authors": ["584"]}
{"title": "Introducing support for embedded and real-time devices into existing hierarchical component system: Lessons learned\n", "abstract": " As embedded and real-time systems became an inherent part of many electronic appliances of everyday use, the demand for their development has grown enormously. Increasing complexity of these systems leads to demands of tools and techniques addressing their efficient and short time-to-market development. One of the possible ways to tackle the problem is a reuse of tools, methodologies and know how already established and successfully adopted in other application domains. Such transfer cannot be done inherently without appropriate modification and methodical adaptation based on an analysis of domain requirements. The paper analyzes necessary modifications and extensions of a general purpose component-based technology to enable development of embedded real-time systems. In addition, we present our own experience obtained while tailoring advanced component framework SOFA 2 to\u00a0\u2026", "num_citations": "5\n", "authors": ["584"]}
{"title": "Automated synthesis of connectors for heterogeneous deployment\n", "abstract": " Although component based engineering has alredy become a widely accepted parading, easy combining components from different component system in one application is still beyond possibility. In our long-term project we are trying to address this problem by extending OMG D&C based deployment. We rely on software connectors as special entities modeling and realizing component interactions. However, in order to benefit from connectors, we have to generate them automatically at deployment time with respect to high-level connection requirements. In this paper we show how to create such a connector generator for heterogeneous deployment.", "num_citations": "5\n", "authors": ["584"]}
{"title": "Capturing dynamicity and uncertainty in security and trust via situational patterns\n", "abstract": " Modern smart systems are highly dynamic and allow for dynamic and ad-hoc collaboration not only among devices, but also among humans and organizations. Such a collaboration can introduce uncertainty to a system, as behavior of humans cannot be directly controlled and the system has to deal with unforeseen changes. Security and trust play a crucial role in these systems, especially in domains like Industry 4.0 and similar. In this paper we aim at providing situational patterns for tackling uncertainty in trust \u2013 in particular in access control. To do so, we provide a classification of uncertainty of access control in Industry 4.0 systems and illustrate this on a series of representative examples. Based on this classification and examples, we derive situational patterns per type of uncertainty. These situational patterns will serve as adaptation strategies in cases when, due to uncertainty, an unanticipated situation is\u00a0\u2026", "num_citations": "4\n", "authors": ["584"]}
{"title": "IVIS: Highly customizable framework for visualization and processing of IoT data\n", "abstract": " This tool paper presents the IVIS platform for processing and visualizing IoT and CPS data. The platform provides a web-based interface that allows both definition of complex visualizations and data processing jobs as well as exploring the data. Compared to the existing open-source and commercial offerings, IVIS follows a different model and focuses on flexibility. Instead of providing a complex administrative UI for creating visualizations by dragging and dropping components onto a dashboard, IVIS provides a set of JavaScript-based visualization components that are glued together using simple JavaScript code. Similarly, the data processing jobs can be defined using code in scripting languages, such as Python, which allows exploiting the wealth of existing libraries for numerical processing. This not only makes the definition of visualizations and data processing jobs much more expressive, but it also turns out to\u00a0\u2026", "num_citations": "4\n", "authors": ["584"]}
{"title": "A tool for online experiment-driven adaptation\n", "abstract": " In this paper, we present Online Experiment-Driven Adaptation (OEDA), a tool for performing end-to-end optimization of a target system abstracted as a black-box by combining statistical and optimization methods and providing statistical guarantees along the optimization process. We present the requirements and architecture of OEDA and describe its built-in optimization process that chains together factorial design, Bayesian optimization, and t-test. OEDA allows the user to create reusable abstractions of systems-to-be-optimized and specify, run and observe the execution of end-to-end experiments. For instance, we support data exchange with common tools like Kafka, MQTT and HTTP. We show the benefits of OEDA in a web server application example. OEDA can be a useful vehicle for research in the area of automated experimentation, an emerging challenge where systems are capable of performing\u00a0\u2026", "num_citations": "4\n", "authors": ["584"]}
{"title": "Use cases in dataflow-based privacy and trust modeling and analysis in industry 4.0 systems\n", "abstract": " Fostering efficiency of distributed supply chains in the Industry 4.0 often bases on IoT-data analysis and by means of lean-and shopfloor-management. However, trust by preserving privacy is a precondition: Competing factories will not share data, if, eg, the analysis of the data will reveal business relevant information to competitors. Our approach is enforcing privacy policies in Industry 4.0 supply chains. These are highly dynamic and therefore not manageable by\u2019traditional\u2019rights-management approaches as we will stretch in a literature analysis.To enforce privacy, we analyze two industrial settings and derive general requirements:(1) Lean-and shopfloor-management and (2) factory access control, both common in Industry 4.0 supply chains. We further propose a reference architecture for Industry 4.0 supply chains. We introduce the combination of Palladio Component Model (PCM)[23] and Ensembles [4] in order to analyze and enforce privacy policies in highly dynamic environments.", "num_citations": "4\n", "authors": ["584"]}
{"title": "Self-Adaptation in Cyber-Physical Systems: from System Goals to Architecture Configurations\n", "abstract": " Self-Adaptation in Cyber-Physical Systems: from System Goals to Architecture Configurations | D3S D3S homepage For Students Research People Projects Software Publications Seminar Contact Self-Adaptation in Cyber-Physical Systems: from System Goals to Architecture Configurations Technical report Title: Self-Adaptation in Cyber-Physical Systems: from System Goals to Architecture Configurations Authors: I. Gerostathopoulos, T. Bure\u0161, P. Hn\u011btynka, J. Keznikl, M. Kit, F. Pl\u00e1\u0161il, N. Plouzeau Publication: Technical report no. D3S-TR-2015-02, Dep. of Distributed and Dependable Systems, Charles University in Prague Year: 2015 BibTeX: @techreport{gerostathopoulos_selfadaptation_report_2015, title = {{Self-Adaptation in Cyber-Physical Systems: from System Goals to Architecture Configurations}}, author = {Gerostathopoulos, I. and Bures, T. and Hnetynka, P. and Keznikl, J. and Kit, M. and Plasil, F. and \u2026", "num_citations": "4\n", "authors": ["584"]}
{"title": "Interoperable domain\u2010specific languages families for code generation\n", "abstract": " This paper has been motivated by experience gained with specification and code generation of control elements for a software component platform and general\u2010purpose programming language like Java and C. The problem to be addressed is two\u2010fold: first, several domain\u2010specific languages (DSL) are to be employed to express different element concerns (architecture, deployment context, code pattern) and second, porting to another general\u2010purpose language should avoid modification of the specification and related code generation process as much as possible. In both respects, the classical template\u2010based code generation technique proved to be inflexible, requiring the code generator to be blurred with ad hoc encoded DSL facets. The paper addresses the problem by introducing the concept of interoperable DSL family. Each member of the family is built around its core language, which can be further\u00a0\u2026", "num_citations": "4\n", "authors": ["584"]}
{"title": "Interoperable DSL Families for Code Generation\n", "abstract": " This paper has been motivated by experience gained with specification and code generation of control elements for a software component platform and general-purpose (GP) programming language like Java and C. The problem to be addressed is two-fold: first, several domain-specific languages (DSL) are to be employed to express different element concerns (architecture, deployment context, code pattern) and second, porting to another GP language should avoid modification of the specification and related code generation process as much as possible. In both respects, the classical template-based code generation technique proved to be inflexible, requiring the code generator to be blurred with ad-hoc encoded DSL facets. The paper addresses the problem by introducing the concept of interoperable DSL family. Each member of the family is built around its core language which can be further specialized by embedding into a target programming language. Interoperability of these DSLs is achieved at the level of ASTs with help of queries.As a proof of the concept, we have implemented the queries via the AST transformation rules of the Stratego/XT framework. In the evaluation, we provide a comparison with the original template-based implementation which clearly indicates the DSL family and AST transformation benefits. We also provide examples of application areas where and how the concept of interoperable DSL family can be employed.", "num_citations": "4\n", "authors": ["584"]}
{"title": "Fine-grained entities in component architectures\n", "abstract": " Component-based software engineering (CBSE) defines components as basic software building blocks with relatively strongly formalized behavior and interactions. The key benefits of structuring code into components include good analyzability of performance and behavioral correctness, simpler code generation and high documentation value. However, a sufficiently detailed formalization including all relevant parts of application behavior often requires finer granularity than of a software component\u2013a typical example is component own data exposed to other components, eg, opened files, client sessions. Moreover, we show these concepts should be captured at the architecture level in order to keep all the mentioned benefits of CBSE. In this respect, we propose a component model extension. Our main goal is to define a model allowing seamless integration in existing behavior specification formalisms and implementation in current component systems.", "num_citations": "4\n", "authors": ["584"]}
{"title": "Handling Heterogeneity in Connector Generation\n", "abstract": " A software connector is an abstraction capturing interactions among components. Apart from middleware independence, connectors provide additional services (eg adaptation, synchronization, etc.). They play a major role in heterogeneous deployment (ie building applications from components implemented in different component models) where they are invaluable for solving distribution and overcoming incompatibilities stemming from coexistence of different component models and middleware. However, to make the use of connectors in heterogeneous deployment possible, it is imperative to have means of generating them automatically. In this paper, we show how to create an extensible connector generator with features needed for heterogeneous deployment. The work is based on our experience with designing and implementing such an extensible connector generator for SOFA, Fractal and EJB component models.", "num_citations": "4\n", "authors": ["584"]}
{"title": "Using component ensembles for modeling autonomic component collaboration in smart farming\n", "abstract": " Smart systems have become key solutions for many application areas including autonomous farming. The trend we can see now in the smart systems is that they shift from single isolated autonomic and self-adaptive components to larger ecosystems of heavily cooperating components. This increases the reliability and often the cost-effectiveness of the system by replacing one big costly device with a number of smaller and cheaper ones. In this paper, we demonstrate the effect of synergistic collaboration among autonomic components in the domain of smart farming---in particular, the use-case we employ in the demonstration stems from the AFar-Cloud EU project. We exploit the concept of autonomic component ensembles to describe situation-dependent collaboration groups (so called ensembles). The paper shows how the autonomic component ensembles can easily capture complex collaboration rules and\u00a0\u2026", "num_citations": "3\n", "authors": ["584"]}
{"title": "Trait-based language for smart cyber-physical systems\n", "abstract": " The problem this paper aims to target is how to hoist the cooperation of software components, acting as autonomous agents and forming coalitions, at the architectural level in smart cyber-physical systems (sCPS). This is a hard problem as coalitions can be overlapping, nested, and dynamically formed and dismantled based on several criteria. To target this issue, we propose and implement an architecture description language (TCOF-ADL) based on Scala internal DSL, that describes architecture and formation of dynamic coalitions of components. To raise the level of expressivity, we introduce the concept of domain-specific extensions (traits) of the core TCOF-ADL to reflect different concerns\u2014such as movement in a 2D map, state-space modeling of physical processes, statistical reasoning about uncertainty. This allows configuring the ADL for the needs of a specific application case and facilitates reuse. To evaluate our approach, we show how it can be beneficially used in addressing the coordination of agents within the RoboCup Rescue Simulation League.", "num_citations": "3\n", "authors": ["584"]}
{"title": "Towards systematic live experimentation in software-intensive systems of systems\n", "abstract": " As the size, variation, and sophistication of software-intensive systems-of-systems grows, so does the uncertainty inherent to their design and development. To deal with this issue, we propose a framework for systematic experimentation based on declarative specification connected with system architecture. The focus is on how to specify experiments that allow systematic exploration of the space of alternative configurations at runtime. Since such experiments should be launched on live systems, extra care needs to be taken in preventing damages when experimenting with the systems. Therefore, we also focus on how to quantify the direct and the indirect cost associated with each experiment execution (which needs to be included in a cost-benefit analysis for system adaptation) and on how to gradually roll out an experiment via a number of different stages. We use the development of a route planner system as an\u00a0\u2026", "num_citations": "3\n", "authors": ["584"]}
{"title": "Smart coordination of autonomic component ensembles in the context of ad-hoc communication\n", "abstract": " Smart Cyber-Physical Systems (sCPS) are complex distributed decentralized systems that typically operate in an uncertain environment and thus have to be resilient to both network and individual node failures. At the same time, sCPS are commonly required to exhibit complex smart coordination while being limited in terms of resources such as network. However, optimizing network usage in a general sCPS coordination framework while maintaining the system function is complex. To better enable this, we allow incorporating key network parameters and constraints into the architecture, realized as an extension of the autonomic component ensembles paradigm. We show that when chosen well, these parameters make it possible to improve network resource usage without hampering the system utility too much. We demonstrate the parameter selection on a mobile gossip-based sCPS coordination\u00a0\u2026", "num_citations": "3\n", "authors": ["584"]}
{"title": "Formalization of Invariant Patterns for the Invariant Refinement Method\n", "abstract": " Refining high-level system invariants into lower-level software obligations has been successfully employed in the design of ensemble-based systems. In order to obtain guarantees of design correctness, it is necessary to formalize the invariants in a form amenable to mathematical analysis. This paper provides such a formalization and demonstrates it in the context of the Invariant Refinement Method. The formalization is used to formally define invariant patterns at different levels of abstraction and with respect to different (soft) real-time constraints, and to provide proofs of theorems related to refinement among these patterns.", "num_citations": "3\n", "authors": ["584"]}
{"title": "Mode change in real-time component systems-suitable form of run-time variability in resource constrained environments\n", "abstract": " The document describes and examines possibilities of run-time variability in real-time embedded component systems. Namely it formally describes support of operating modes. The report introduces a reconfiguration mechanism based on properties and relations between them. The mechanism is designed to facilitate a straight forward modeling of operating modes and reconfiguration rules and preserves re-usability of assembled components. The report also presents a realization of the mechanism suitable for the domain of embedded real-time systems.", "num_citations": "3\n", "authors": ["584"]}
{"title": "Constraint-based generation of connectors\n", "abstract": " In this paper we discuss the a typical use-case of connector usage in component-based systems. We show how the connectors are refined during application development and investigate a way how to automatically generate connectors with respect to style of interaction and component distribution.", "num_citations": "3\n", "authors": ["584"]}
{"title": "An ensemble-based approach for scalable qos in highly dynamic cps\n", "abstract": " Modern cyber-physical systems (CPS) often involve distributed devices/components that closely interact with each other and their environment. In this context, operation conditions may constantly change and it is not always possible to guarantee quality of service (QoS), particularly, if resourcesdegrade or stop being available. In addition, sometimes, one would like QoS to scale up/down with operation conditions, e.g., maximize efficiency, minimize energy consumption, etc. without compromising safety. However, traditional design and development techniques fail to capture the dynamics of modern CPS, since they rather focus on individual components/devices, and are unable to provide such QoS guarantees. To overcome this problem, we propose a design methodology based on the concept of ensemble, i.e., a dynamic grouping of components, which allows for scalable QoS guaranties. We illustrate the utility of\u00a0\u2026", "num_citations": "2\n", "authors": ["584"]}
{"title": "SPL: Unit testing performance\n", "abstract": " Unit testing is an attractive quality management tool in the software development process, however, practical obstacles make it difficult to use unit tests for performance testing. We present Stochastic Performance Logic, a formalism for expressing performance requirements, together with interpretations that facilitate performance evaluation in the unit test context. The formalism and the interpretations are evaluated in multiple experiments, to demonstrate (1) the ability to reflect typical developer concerns related to performance, and (2) the ability to identify performance differences in realistic measurements.", "num_citations": "2\n", "authors": ["584"]}
{"title": "Strengthening component architectures by modeling fine-grained entities\n", "abstract": " Component-based software engineering (CBSE) defines components as basic software building blocks with strongly formalized behavior and interactions. The key benefits of structuring code into components include good analyzability of performance and behavioral correctness, simpler code generation, and high documentation value. However, a sufficiently detailed formalization including all relevant parts of application behavior often requires finer granularity than of a software component - a typical example is component's data exposed to other components that can circulate through the application, e.g., opened files, client sessions. In order to propagate all the mentioned benefits of CBSE to this level of granularity, we propose a conservative component model extension which allows to capture those concepts on the architecture level. Our main goal is to define a model allowing seamless integration in existing\u00a0\u2026", "num_citations": "2\n", "authors": ["584"]}
{"title": "SOFA High Integrity: Our Approach to SAVOIR\n", "abstract": " This paper presents advanced concepts of the SOFA HI component model, namely its support for reuse and modelling variability, its support for separating communication concerns from software building blocks, and options for schedulability analysis. We use our experience from the COrDeT-Toulouse TRP project funded by ESA [1], as well as other research projects we have carried out. 1 The proposed architecture fits with the goals of SAVOIR, a recent ESA initiative to standardise space avionics.", "num_citations": "2\n", "authors": ["584"]}
{"title": "Addressing static execution overhead in connectors with disabled optional features\n", "abstract": " Connectors are used to realize inter-component interactions in component systems. Apart from their primary function, which is mediating the communication, connectors can also support additional features that, while orthogonal to the primary function, may benefit from the placement in connectors. The features that fit well in connectors are those implemented using interception or filtering. Such features are often optional in the sense that they can be activated and deactivated at runtime. A problem with optional features is that even if they are inactive, there is some overhead associated with their presence in an application. In this paper, we address the overhead of disabled optional features by a special reconfiguration process. The approach presented is applicable not only to architecture-based connectors, but also to other component architectures including componentized middleware (eg, reflective middleware, Jonathan, etc.).", "num_citations": "2\n", "authors": ["584"]}
{"title": "Real-life Behavior Specification of Software Components\n", "abstract": " Real-life Behavior Specification of Software Components | D3S D3S homepage For Students Research People Projects Software Publications Seminar Contact Real-life Behavior Specification of Software Components Proceedings paper Title: Real-life Behavior Specification of Software Components Authors: J. Adamek, T. Bure\u0161, P. Je\u017eek, J. Kofro\u0148, V. Mencl, P. Par\u00edzek, F. Pl\u00e1\u0161il Publication: The 11th EMEA Academic Forum, Dublin, Ireland Year: 2006 BibTeX: @inproceedings{adamek_reallife_2006, title = {{Real-life Behavior Specification of Software Components}}, author = {Adamek, J. and Bures, T. and Jezek, P. and Kofron, J. and Mencl, V. and Parizek, P. and Plasil, F.}, year = {2006}, booktitle = {{The 11th EMEA Academic Forum, Dublin, Ireland}}, } \u00a9 D3S Edit this page Department of Distributed and Dependable Systems Faculty of Mathematics and Physics Charles University Malostransk\u00e9 n\u00e1m\u011bst\u00ed 25 118 00 \u2026", "num_citations": "2\n", "authors": ["584"]}
{"title": "Self-Adaptation 2.0\n", "abstract": " This motion on the question whether \u201chandling unanticipated changes is the ultimate challenge for self-adaptation\u201d positions the research on self-adaptive systems in the broader context of the current research agenda (in the frame of Horizon Europe). It discusses the relation to AI and the need to align with and gain more prominence by building on the AI movement and bringing self-adaptation to the next level.", "num_citations": "1\n", "authors": ["584"]}
{"title": "Forming ensembles at runtime: a machine learning approach\n", "abstract": " Smart system applications (SSAs) built on top of cyber-physical and socio-technical systems are increasingly composed of components that can work both autonomously and by cooperating with each other. Cooperating robots, fleets of cars and fleets of drones, emergency coordination systems are examples of SSAs. One approach to enable cooperation of SSAs is to form dynamic cooperation groups\u2014ensembles\u2014between components at runtime. Ensembles can be formed based on predefined rules that determine which components should be part of an ensemble based on their current state and the state of the environment (e.g., \u201cgroup together 3 robots that are closer to the obstacle, their battery is sufficient and they would not be better used in another ensemble\u201d). This is a computationally hard problem since all components are potential members of all possible ensembles at runtime. In our experience working\u00a0\u2026", "num_citations": "1\n", "authors": ["584"]}
{"title": "A toolbox for realtime timeseries anomaly detection\n", "abstract": " Software architecture practice relies more and more on data-driven decision-making. Data-driven decisions are taken either by humans or by software agents via analyzing streams of timeseries data coming from different running systems. Since the quality of sensed data influences the analysis and subsequent decision-making, detecting data anomalies is an important and necessary part of any data analysis and data intelligence pipeline (such as those typically found in smart and self-adaptive systems). Although a number of data science libraries exist for timeseries anomaly detection, it is both time consuming and hard to plug realtime anomaly detection functionality in existing pipelines. The problem lies with the boilerplate code that needs to be provided for common tasks such as data ingestion, data transformation and preprocessing, invoking of model re-training when needed, and persisting of identified\u00a0\u2026", "num_citations": "1\n", "authors": ["584"]}
{"title": "Software Architectures for Context-Aware Smart Systems\n", "abstract": " This special issue on software architectures for context-aware smart systems aims to outline the importance of the architectural aspects in the development of context-aware solutions, and their role in ensuring and improving the overall quality of the software in different smart systems domains based on the enabling technologies, such as the Internet-of-Things (IoT).", "num_citations": "1\n", "authors": ["584"]}
{"title": "Intelligent Ensembles\u2013a Declarative Group Description Language and Java Framework (Artifact)\n", "abstract": " Smart cyber-physical systems (sCPS) is a growing research field focused on scenarios such as smart cities or smart mobility, where autonomous components are deployed in a physical environment, and are expected to cooperate with one another, as well as with humans. As these systems typically operate in a highly uncertain and dynamically changing environment, being able to cooperate and adapt in groups to cope with various (possibly unanticipated) situations becomes a crucial and challenging task. In this artifact, we respond to this challenge by presenting the Intelligent Ensembles framework, consisting of a high-level declarative language for describing dynamic cooperation groups, and a Java runtime library for automatically forming groups that best satisfy the given specification. The framework provides dynamic architecture adaptation (ie, forming groups of components and exchanging data between them) based on the state of components and situation in their environment. Further, the framework can be used as a first step of a group-wise adaptation (ie, identifying components that are to negotiate and coordinate in an adaptation). The framework is built on top of the Z3 SMT solver and the Eclipse Modelling Framework.", "num_citations": "1\n", "authors": ["584"]}
{"title": "Model problem (crowdnav) and framework (rtx) for self-adaptation based on big data analytics (artifact)\n", "abstract": " This artifact supports our research in self-adaptation in large-scale software-intensive distributed systems. The main problem in making such systems self-adaptive is that their adaptation needs to consider the current situation in the whole system. However, developing a complete and accurate model of such systems at design time is very challenging. We are instead investigating a novel approach where the system model consists only of the essential input and output parameters and Big Data analytics is used to guide self-adaptation based on a continuous stream of operational data. In this artifact, we provide a concrete model problem that can be used as a case study for evaluating different self-adaptation techniques pertinent to complex large-scale distributed systems. We also provide an extensible tool-based framework for endorsing an arbitrary system with self-adaptation based on analysis of operational data coming from the system. The model problem (CrowdNav) and the framework (RTX) have been packaged together in this artifact, but can also work independently.", "num_citations": "1\n", "authors": ["584"]}
{"title": "Security and Trust in Data Sharing Smart Cyber-Physical Systems\n", "abstract": " Security and trust plays an important role in Smart Cyber-Physical Systems (sCPS), which are formed as open and large collections of autonomous context-and self-aware adaptive components that dynamically group themselves and cooperate (all in a rather decentralized manner). Such a high level of dynamicity, open-endedness and context-dependence however makes existing approaches to security and trust in distributed systems not fully suitable (typically being too static and not able to cope with decentralization). In this paper we introduce the concepts of context-dependent security and trust defined at the architecture level of sCPS. Contrary to traditional approaches, our solution allows components to adapt their security clearance according to their context (ie their state and the surrounding environment), while preserving high level security policies. We further define the interplay of security and trust in sCPS\u00a0\u2026", "num_citations": "1\n", "authors": ["584"]}
{"title": "Computational Model for Gossiping Components in Cyber-Physical Systems\n", "abstract": " Developing software for dynamic cyber-physical systems (CPS) is a complex task A particular challenge in this context is the robust distributed data dissemination in dynamic networks. Gossip-based communication stands as a promising solution to this challenge. We argue, that exploitation of application-specific information, software architecture in particular, has a large potential for improving the robustness and performance of gossip-based communication. This report presents a computational model that represents a synergy between high-level architectural models and low-level communication models to effectively enable application-specific gossiping in component-based systems.", "num_citations": "1\n", "authors": ["584"]}
{"title": "CoDIT: Bridging the Gap between System-Level and Component-Level Development\n", "abstract": " Component-based development traditionally recognizes two parallel views (system-level view and component-level view), which correspond to two major concerns - development of a an application and development of a reusable component for the use in application development. By having different objectives, these views have relatively disparate notion of a component, which consequently means that they are difficult (yet necessary) to combine. In this paper, we propose a method (named CoDIT), which spans the gap between the two views by providing a synchronisation between system-level view (expressed in UML 2) and componentlevel view. For component-level view, the method supports component frameworks with method-call as the communication style. The variability in the composition mechanisms of the component frameworks is addressed by using principles of metacomponent systems. The\u00a0\u2026", "num_citations": "1\n", "authors": ["584"]}
{"title": "Deploying Heterogeneous Applications using OMG D&C and Software Connectors\n", "abstract": " Component-based software engineering is a paradigm advancing a view of constructing software from reusable building blocks, components. A component is typically a black box with a well defined interface, performing a known function. The concept builds on the techniques well known from modular programming, which encourage the developers to split a large and complex system into smaller and better manageable functional blocks and attempt to minimize dependencies between those blocks.Several aspects of component-based programming have been embraced by the software development industry and as a result, there are now several component models, such as Enterprise Java Beans [12] by Sun Microsystems, CORBA Component Model [8] by OMG, and. Net [5] by Microsoft, which are extensively used for production of complex software systems. There are also a large number of other component models, designed and used mainly by the academic community. While most of the academic component models lack the maturity of their industrial counterparts, they aim higher with respect to fulfilling the vision of the component-based software engineering paradigm. This is mainly reflected in support for advanced modeling features, such as component nesting, or connector support. While we are aware of a number of component models used in academia, we are most familiar with SOFA [11, 7] and Fractal [6]. Throughout the paper, we will use these models along with EJB as a test-bed for our experiments.", "num_citations": "1\n", "authors": ["584"]}
{"title": "Formal Verification of Annotated Use-Cases (FOAM Method)\n", "abstract": " Textual use-cases have been traditionally used at the design stage of development process for describing software functionality from the user\u2019s view. Their advantage is that they can be easily understood by stakeholders and domain experts. However, since use-cases typically rely on a natural language, they cannot be directly subject to a formal verification. In this paper, we present Formal Verification of Annotated Use-Case Models (FOAM). This method features simple userdefinable annotations, which are inserted into a use-case to make its semantics more suitable for verification. Subsequently a model-checking tool verifies temporal invariants associated with the annotations. This way, FOAM allows for harnessing the benefits of model-checking while still keeping the use-cases understandable for non-experts.", "num_citations": "1\n", "authors": ["584"]}