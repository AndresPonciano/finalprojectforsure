{"title": "A declarative debugger of incorrect answers for constraint functional-logic programs\n", "abstract": " Debugging is one of the essential parts of the software development cycle. However, the usual debugging techniques used in imperative languages such as the step by step execution often are not suitable for debugging declarative programming languages. We present here a graphical debugging environment for constraint lazy functional-logic programs based on declarative debugging. The debugger displays the computation tree associated with a computation which has produced an incorrect answer, and navigates it with the assistance of the user until the error, an incorrect program rule, is found out. The debugger supports programs including equality and disequality constraints.", "num_citations": "76\n", "authors": ["1835"]}
{"title": "Algorithmic debugging of Java programs\n", "abstract": " In this paper we propose applying the ideas of declarative debugging to the object-oriented language Java as an alternative to traditional trace debuggers used in imperative languages. The declarative debugger builds a suitable computation tree containing information about method invocations occurred during a wrong computation. The tree is then navigated, asking the user questions in order to compare the intended semantics of each method with its actual behavior until a wrong method is found out. The technique has been implemented in an available prototype. We comment the several new issues that arise when using this debugging technique, traditionally applied to declarative languages, to a completely different paradigm and propose several possible improvements and lines of future work.", "num_citations": "60\n", "authors": ["1835"]}
{"title": "Declarative debugging of rewriting logic specifications\n", "abstract": " Declarative debugging is a semi-automatic technique that starts from an incorrect computation and locates a program fragment responsible for the error by building a tree representing this computation and guiding the user through it to find the error. Membership equational logic (MEL) is an equational logic that in addition to equations allows one to state membership axioms characterizing the elements of a sort. Rewriting logic is a logic of change that extends MEL by adding rewrite rules, which correspond to transitions between states and can be nondeterministic. We propose here a calculus to infer reductions, sort inferences, normal forms, and least sorts with the equational subset of rewriting logic, and rewrites and sets of reachable terms through rules. We use an abbreviation of the proof trees computed with this calculus to build appropriate debugging trees for both wrong (an incorrect result obtained from an\u00a0\u2026", "num_citations": "49\n", "authors": ["1835"]}
{"title": "Theoretical foundations for the declarative debugging of lazy functional logic programs\n", "abstract": " The aim of this paper is to provide theoretical foundations for the declarative debugging of wrong answers in lazy functional logic programming. We rely on a logical framework which formalizes both the intended meaning and the execution model of programs in a simple language which combines the expressivity of pure Prolog and a significant subset of Haskell. As novelties w.r.t. to previous related approaches, we deal with functional values both as arguments and as results of higher order functions, we obtain a completely formal specification of the debugging method, and we extend known soundness and completeness results for the debugging of wrong answers in logic programming to a substantially more difficult context. A prototype implementation of a working debugger is planned as future work.", "num_citations": "42\n", "authors": ["1835"]}
{"title": ": a Declarative Debugging Tool for Functional-Logic Languages\n", "abstract": " We present a graphical tool for the declarative debugging of wrong answers in functional-logic languages. The tool, integrated in the system , can be used to navigate a computation tree corresponding to some erroneous computation. During the navigation the users can either follow a fixed strategy or move freely providing information about the validity of the nodes as they like. We show by means of examples how this flexibility can reduce both the number and the complexity of the questions that the user must consider w.r.t. the usual top-down navigation strategy. Moreover, the tool includes some extra features that can be used to automatically simplify the computation trees.", "num_citations": "40\n", "authors": ["1835"]}
{"title": "Predicting students' knowledge after playing a serious game based on learning analytics data: A case study\n", "abstract": " Serious games have proven to be a powerful tool in education to engage, motivate, and help students learn. However, the change in student knowledge after playing games is usually measured with traditional (paper) prequestionnaires\u2013postquestionnaires. We propose a combination of game learning analytics and data mining techniques to predict knowledge change based on in\u2010game student interactions. We have tested this approach in a case study for which we have conducted preexperiments\u2013postexperiments with 227 students playing a previously validated serious game on first aid techniques. We collected student interaction data while students played, using a game learning analytics infrastructure and the standard data format Experience API for Serious Games. After data collection, we developed and tested prediction models to determine whether knowledge, given as posttest results, can be accurately\u00a0\u2026", "num_citations": "38\n", "authors": ["1835"]}
{"title": "A declarative debugging system for lazy functional logic programs\n", "abstract": " We present a declarative debugger for lazy functional logic programs with polymorphic type discipline. Whenever a 0computed answer is considered wrong by the user (error symptom), the debugger locates a program fragment (function defining rule) responsible for the error. The notions of symptom and error have a declarative meaning w.r.t. to an intended program semantics. Debugging is performed by searching in a computation tree which is a logical representation of the computation. Following a known technique, our tool is based on a program transformation: transformed programs return computation trees along with the results expected by source programs. Our transformation is provably correct w.r.t. well-typing and program semantics. As additional improvements w.r.t. related approaches, we solve a previously open problem concerning the use of curried functions, and we provide a correct method for\u00a0\u2026", "num_citations": "37\n", "authors": ["1835"]}
{"title": "A theoretical framework for the declarative debugging of datalog programs\n", "abstract": " The logic programming language Datalog has been extensively researched as a query language for deductive databases. Although similar to Prolog, the Datalog operational mechanisms are more intricate, leading to computations quite hard to debug by traditional approaches. In this paper, we present a theoretical framework for debugging Datalog programs based on the ideas of declarative debugging. In our setting, a debugging session starts when the user detects an unexpected answer for some query, and ends with the debugger pointing to either an erroneous predicate or to a set of mutually recursive predicates as the cause of the unexpected answer. Instead of representing the computations by means of trees, as usual in declarative debugging, we propose graphs as a more convenient structure in the case of Datalog, proving formally the soundness and completeness of the debugging technique\u00a0\u2026", "num_citations": "36\n", "authors": ["1835"]}
{"title": "A functional-logic perspective of parsing\n", "abstract": " Parsing has been a traditional workbench for showing the virtues of declarative programming. Both logic and functional programming claim the ability of writing parsers in a natural and concise way. We address here the task from a functional-logic perspective. By modelling parsers as non-deterministic functions we achieve a very natural manner of building parsers, which combines the nicest properties of the functional and logic approaches. In particular, we are able to define parsers within our framework in a style very close to that of functional programming parsers, but using simpler concepts. Moreover, we have moved beyond usual declarative approaches to parsers, since the functional-logic parsers presented here can be considered as truly data values. As an example of this feature we define a function that detects ambiguous grammars.", "num_citations": "34\n", "authors": ["1835"]}
{"title": "Similarity-based reasoning in qualified logic programming\n", "abstract": " Similarity-based Logic Programming (briefly, SLP) has been proposed to enhance the LP paradigm with a kind of approximate reasoning which supports flexible information retrieval applications. This approach uses a fuzzy similarity relation \u211d between symbols in the program's signature, while keeping the syntax for program clauses as in classical LP. Another recent proposal is the QLP (D) scheme for Qualified Logic Programming, an extension of the LP paradigm which supports approximate reasoning and more. This approach uses annotated program clauses and a parametrically given domain D whose elements qualify logical assertions by measuring their closeness to various users' expectations. In this paper we propose a more expressive scheme SQLP (\u211d, D) which subsumes both SLP and QLP (D) as particular cases. We also show that SQLP (\u211d, D) programs can be transformed into semantically\u00a0\u2026", "num_citations": "26\n", "authors": ["1835"]}
{"title": "Applying constraint logic programming to SQL test case generation\n", "abstract": " We present a general framework for generating SQL query test cases using Constraint Logic Programming. Given a database schema and a SQL view defined in terms of other views and schema tables, our technique generates automatically a set of finite domain constraints whose solutions constitute the test database instances. The soundness and correctness of the technique w.r.t. the semantics of Extended Relational Algebra is proved. Our setting has been implemented in an available tool covering a wide range of SQL queries, including views, subqueries, aggregates and set operations.", "num_citations": "25\n", "authors": ["1835"]}
{"title": "A declarative debugger for Maude functional modules\n", "abstract": " A declarative debugger for Maude functional modules, which correspond to executable specifications in membership equational logic, is presented. Starting from an incorrect computation, declarative debugging builds a debugging tree as a logical representation of the computation, that then is traversed by asking questions to an external oracle until the error is found. We summarize the construction of appropriate debugging trees for oriented equational and membership inferences, where all the nodes whose correctness does not need any justification have been collapsed. The reflective features of Maude allow us to generate and navigate the debugging tree of a Maude computation using operations in Maude itself; even the user interface of the declarative debugger can be specified in this way. We present the debugger's main features, such as two different strategies to traverse the debugging tree, use of a\u00a0\u2026", "num_citations": "22\n", "authors": ["1835"]}
{"title": "EDD: A declarative debugger for sequential erlang programs\n", "abstract": " Declarative debuggers are semi-automatic debugging tools that abstract the execution details to focus on the program semantics. This paper presents a tool implementing this approach for the sequential subset of Erlang, a functional language with dynamic typing and strict evaluation. Given an erroneous computation, it first detects an erroneous function (either a \u201cnamed\u201d function or a lambda-abstraction), and then continues the process to identify the fragment of the function responsible for the error. Among its features it includes support for exceptions, predefined and built-in functions, higher-order functions, and trusting and undo commands.", "num_citations": "21\n", "authors": ["1835"]}
{"title": "Declarative debugging of wrong and missing answers for SQL views\n", "abstract": " This paper presents a debugging technique for diagnosing errors in SQL views. The debugger allows the user to specify the error type, indicating if there is either a missing answer (a tuple was expected but it is not in the result) or a wrong answer (the result contains an unexpected tuple). This information is employed for slicing the associated queries, keeping only those parts that might be the cause of the error. The validity of the results produced by sliced queries is easier to determine, thus facilitating the location of the error. Although based on the ideas of declarative debugging, the proposed technique does not use computation trees explicitly. Instead, the logical relations among the nodes of the trees are represented by logical clauses that also contain the information extracted from the specific questions provided by the user. The atoms in the body of the clauses correspond to questions that the user must\u00a0\u2026", "num_citations": "20\n", "authors": ["1835"]}
{"title": "Algorithmic debugging of SQL views\n", "abstract": " We present a general framework for debugging systems of correlated SQL views. The debugger locates an erroneous view by navigating a suitable computation tree. This tree contains the computed answer associated with every intermediate relation, asking the user whether this answer is expected or not. The correctness and completeness of the technique is proven formally, using a general definition of SQL operational semantics. The theoretical ideas have been implemented in an available tool which includes the possibility of employing trusted specifications for reducing the number of questions asked to the user.", "num_citations": "18\n", "authors": ["1835"]}
{"title": "Constraint solving for generating glass-box test cases\n", "abstract": " Glass-box testing tries to cover paths through the tested code, based on a given criterion such as def-use chain coverage. When generating glass-box test cases manually, the user is likely to overlook some def-use chains. Moreover it is difficult to find suitable test cases which cause certain def-use chains to be passed. We have developed a tool which automatically generates a system of test cases for a piece of Java byte code, which ensures that all def-use chains are covered. The tool consists of a symbolic Java virtual machine (SJVM) and a system of dedicated constraint solvers. The SJVM uses the constraint solvers in order to determine which branches the symbolic execution needs to consider. A backtracking mechanism is applied in case that several branches remain feasible. Thus we have applied implementation techniques known from functional logic and constraint programming to handle the considered applications problems.", "num_citations": "18\n", "authors": ["1835"]}
{"title": "Las bases de Big Data\n", "abstract": " Cada clic en Internet es un dato que bien aprovechado puede servir, por ejemplo, para adecuar las p\u00e1ginas a nuestras preferencias, pero tambi\u00e9n para ofrecer publicidad personalizada. Los tel\u00e9fonos m\u00f3viles emiten constantemente datos sobre nuestra ubicaci\u00f3n o el uso de aplicaciones. Al viajar en transporte p\u00fablico y validar un billete, contribuimos a una base de datos que sirve para decidir qu\u00e9 l\u00edneas de transporte se utilizan m\u00e1s ya qu\u00e9 horas. Al pagar con tarjeta, aportamos a nuestro banco informaci\u00f3n sobre nuestros h\u00e1bitos y tambi\u00e9n a la tienda sobre los productos que hemos comprado. Estos ejemplos muestran que cada vez vivimos en un mundo m\u00e1s repleto de datos, a menudo producidos por nosotros mismos sin darnos cuenta. Este inmenso trasiego de datos solo se convierte en informaci\u00f3n \u00fatil cuando se procesa y analiza, es entonces cuando se vislumbra su potencial. Aunque a simple vista\u00a0\u2026", "num_citations": "16\n", "authors": ["1835"]}
{"title": "User\u2019s manual for Toy\n", "abstract": " TOY is a compiler for lazy functional-logic language with disequality constraints and higher order facilities. This manual describes the language, the environment of the compiler and the operational semantics. It also shows some programming examples.", "num_citations": "15\n", "authors": ["1835"]}
{"title": "Declarative diagnosis of missing answers in constraint functional-logic programming\n", "abstract": " We present a declarative method for diagnosing missing computed answers in , a generic scheme for lazy Constraint Functional-Logic Programming which can be instantiated by any constraint domain  given as parameter. As far as we know, declarative diagnosis of missing answers in such an expressive framework has not been tackled before. Our approach combines and extends previous work done separately for constraint logic programming and lazy functional programming languages. Diagnosis can be started whenever a user finds that the set of computed answers for a given goal with finite search space misses some expected solution w.r.t. an intended interpretation of the program, that provides a declarative description of its expected behavior. Diagnosis proceeds by exploring a proof tree, that provides a declarative view of the answer-collection process performed by the computation\u00a0\u2026", "num_citations": "14\n", "authors": ["1835"]}
{"title": "A deductive database with datalog and sql query languages\n", "abstract": " This paper introduces Datalog Educational System (DES), a deductive database which supports both Datalog and SQL as query languages. Since its inception, this system is targeted to educational purposes rather to develop an efficient, competitive system with respect to other existing systems. As distinguishing features, it is free, open-source, multiplatform, interactive, portable, GUI-enabled, implemented following ISO-Prolog and supports extensions to pure Datalog in the form of stratified negation, strong constraints, types, metapredicates, and duplicates. Also, test case generation for SQL views and declarative debugging for Datalog programs and SQL views are supported. SQL statements, following ISO standard, are compiled to Datalog programs and solved by its inference engine. Nonetheless, ODBC connections are also supported, which enables access to external DBMSs and benefit from their\u00a0\u2026", "num_citations": "13\n", "authors": ["1835"]}
{"title": "A new proposal for debugging datalog programs\n", "abstract": " In this paper, we propose to apply declarative debugging to Datalog programs. Our approach relies on program semantics rather than on the computation mechanism. The debugging process starts when the user detects an unexpected answer. By asking questions about the intended semantics, the debugger looks for incorrect program relations. While usual declarative debuggers for other languages are based on computation trees, we show that graphs are more convenient structures for representing Datalog computations. The theoretical framework is complemented by the implementation of a debugger for the deductive database system DES, a publicly available open-source project.", "num_citations": "13\n", "authors": ["1835"]}
{"title": "A declarative debugger for sequential Erlang programs\n", "abstract": " Declarative debuggers are semi-automatic debugging tools that abstract the execution details to focus on the program semantics. Erroneous computations are represented by suitable trees, which are traversed by asking questions to the user until a bug is found. This paper applies declarative debugging to the sequential subset of the language Erlang. The debugger takes the intermediate representation generated by Erlang systems, known as Core Erlang, and an initial error detected by the user, and locates an erroneous program function responsible for the error. In order to represent the erroneous computation, a semantic calculus for sequential Core Erlang programs is proposed. The debugger uses an abbreviation of the proof trees of this calculus as debugging trees, which allows us to prove the soundness of the approach. The technique has been implemented in a debugger tool publicly available.", "num_citations": "11\n", "authors": ["1835"]}
{"title": "Integrating XPath with the functional-logic language toy\n", "abstract": " This paper presents a programming framework for incorporating XPath queries into the functional-logic language . The proposal exploits the language characteristics, including non-determinism, logic variables, and higher-order functions and patterns. Our setting covers a wide range of standard XPath axes and tests. In particular reverse axes are implemented thanks to the double nature of XPath queries, which are both higher-order functions and data terms in our setting. The combination of these two different worlds, the functional-logic paradigm and the XML query language XPath, is very enriching for both of them. From the point of view of functional-logic programming, the language is now able to deal with XML documents in a very simple way. From the point of view of XPath, our approach presents several nice properties as the generation of XML test-cases for XPath queries, which can be useful\u00a0\u2026", "num_citations": "11\n", "authors": ["1835"]}
{"title": "A Transformation-based implementation for CLP with qualification and proximity\n", "abstract": " Uncertainty in logic programming has been widely investigated in the last decades, leading to multiple extensions of the classical logic programming paradigm. However, few of these are designed as extensions of the well-established and powerful Constraint Logic Programming (CLP) scheme for CLP. In a previous work we have proposed the proximity-based qualified constraint logic programming (SQCLP) scheme as a quite expressive extension of CLP with support for qualification values and proximity relations as generalizations of uncertainty values and similarity relations, respectively. In this paper we provide a transformation technique for transforming SQCLP programs and goals into semantically equivalent CLP programs and goals, and a practical Prolog-based implementation of some particularly useful instances of the SQCLP scheme. We also illustrate, by showing some simple \u2013 and working \u2013 examples\u00a0\u2026", "num_citations": "9\n", "authors": ["1835"]}
{"title": "Declarative debugging of membership equational logic specifications\n", "abstract": " Algorithmic debugging has been applied to many declarative programming paradigms; in this paper, it is applied to the rewriting paradigm embodied in Maude. We introduce a declarative debugger for executable specifications in membership equational logic which correspond to Maude functional modules. Declarative debugging is based on the construction and navigation of a debugging tree which logically represents the computation steps. We describe the construction of appropriate debugging trees for oriented equational and membership inferences. These trees are obtained as the result of collapsing in proof trees all those nodes whose correctness does not need any justification. We use an extended example to illustrate the use of the declarative debugger and its main features, such as two different strategies to traverse the debugging tree, use of a correct module to reduce the number of questions\u00a0\u2026", "num_citations": "9\n", "authors": ["1835"]}
{"title": "Declarative debugging of concurrent Erlang programs\n", "abstract": " Despite the growing number of concurrent applications in nowadays systems, debugging concurrent programs remains an open issue due to its intrinsic complexity. In this work, we present a declarative debugger for the concurrent language Erlang. Following the ideas of algorithmic debugging, our tool asks questions to the user about the validity of transitions between those program points that involve message passing, and also about the expected results of the function calls occurred during the computation. The differences between the user answers, which represent the intended behavior of the program, and the actual program execution, allow the debugger to detect the function responsible for the error, and to point out the pieces of source code responsible for the bugs. The proposal is based on a concurrent calculus for Erlang programs, and we show a benchmark that assesses its scalability both in terms of\u00a0\u2026", "num_citations": "8\n", "authors": ["1835"]}
{"title": "A zoom-declarative debugger for sequential Erlang programs\n", "abstract": " We present a declarative debugger for sequential Erlang programs. The tool is started when a program produces some unexpected result, and proceeds asking questions to the user about the correctness of some subcomputations until an erroneous program function is found. Then, the user can refine the granularity by zooming in the function, checking the values bound to variables and the if/case/try-catch branches taken during the execution. We show by means of an extensive benchmark that the result is a usable, scalable tool that complements already existing debugging tools such as the Erlang tracer and Dialyzer. Since the technique is based on a formal calculus, we are able to prove the soundness and completeness of the approach.", "num_citations": "8\n", "authors": ["1835"]}
{"title": "Debugging of wrong and missing answers for datalog programs with constraint handling rules\n", "abstract": " This paper presents a proposal for debugging deductive database programs. Although inspired in the logic programming paradigm, these programs have the particularity of involving large sets of data. In this context, debugging tools employed usually in logic programs, such as traditional trace debuggers, become impractical. Our technique is based on the principles of algorithmic debugging but adapted to the particularities of the deductive database query language Datalog. The debugging process starts when the user detects an initial erroneous result. Then, the debugger asks questions about the validity/nonvalidity of some intermediate results until a bug is located. The debugger allows the user to report the existence of wrong or missing answers. This information is employed for simplifying the following questions using different forms of slicing. During the debugging process the information provided by the user\u00a0\u2026", "num_citations": "8\n", "authors": ["1835"]}
{"title": "Simplifying questions in maude declarative debugger by transforming proof trees\n", "abstract": " Declarative debugging is a debugging technique that abstracts the execution details that in general may be difficult to follow in declarative languages to focus on results. It relies on a data structure representing the wrong computation, the debugging tree, which is traversed by asking questions to the user about the correctness of the computation steps related to each node. Thus, the complexity of the questions is an important factor regarding the applicability of the technique. In this paper we present a transformation for debugging trees for Maude specifications that ensures that any subterm occurring in a question has been previously replaced by the most reduced form that it has taken during the computation, thus ensuring that questions become as simple as possible.", "num_citations": "8\n", "authors": ["1835"]}
{"title": "A declarative debugger for Maude specifications-User guide\n", "abstract": " We show in this guide how to use our declarative debugger for Maude specifications. Declarative debugging is a semi-automatic technique that starts from a computation considered incorrect by the user (error symptom) and locates a program fragment responsible for the error by asking questions to an external oracle, which is usually the user. In our case the debugging tree is obtained from a proof tree in a suitable semantic calculus; more concretely, we abbreviate the proof trees obtained from this calculus in order to ease and shorten the debugging process while preserving the correctness and completeness of the technique.We present the main features of our tool, what is assumed about the modules introduced by the user, the list of available commands, and the kinds of questions used during the debugging process. Then, we use several examples to illustrate how to use the debugger. We refer the interested reader to the webpage http://maude. sip. ucm. es/debugging, where these and other examples can be found together with more information about the theory underlying the debugger, its implementation and the Maude source files.", "num_citations": "8\n", "authors": ["1835"]}
{"title": "A declarative debugger for Maude\n", "abstract": " Declarative debugging has been applied to many declarative programming paradigms; in this paper, a declarative debugger for rewriting logic specifications, embodied in the Maude language, is presented. Starting from an incorrect computation (a reduction, a type inference, or a rewrite), the debugger builds a tree representing this computation and guides the user through it to find a wrong statement. We present the debugger\u2019s main features, such as support for functional and system modules, two possible constructions of the debugging tree, two different strategies to traverse it, use of a correct module to reduce the number of questions asked to the user, selection of trusted vs. suspicious statements, and trusting of statements \u201con the fly\u201d.", "num_citations": "8\n", "authors": ["1835"]}
{"title": "Declarative debugging of Maude modules\n", "abstract": " We introduce a declarative debugger for Maude modules: functional modules correspond to executable specifications in membership equational logic, while system modules correspond to rewrite theories. First we describe the construction of appropriate debugging trees for oriented equational and membership inferences and rewrite rules. These trees are obtained as the result of collapsing in proof trees all those nodes whose correction does not need any justification. We include several extended examples to illustrate the use of the declarative debugger and its main features, such as two possible constructions of the debugging tree, two different strategies to traverse it, use of a correct module to reduce the number of questions asked to the user, selection of trusted vs. suspicious statements by means of labels, and trusting of statements \u201con the fly.\u201d Since Maude supports the reflective features in its underlying logic, it includes a predefined META-LEVEL module providing access to metalevel concepts such as specifications or computations as usual data. This allows us to generate and navigate the debugging tree of a Maude computation using operations in Maude itself. Even the user interface of the declarative debugger for Maude can be specified in Maude itself. We describe in detail this metalevel implementation of our tool.", "num_citations": "8\n", "authors": ["1835"]}
{"title": "A declarative debugger for concurrent erlang programs (extended version)\n", "abstract": " We present here a calculus for Core Erlang programs. It provides a medium-sized normal form, that is, expressions are evaluated to an intermediate normal form, which might be either a value or a let expression containing an unevaluated receive. These medium-sized normal forms are then evaluated by consuming messages from an outbox.", "num_citations": "7\n", "authors": ["1835"]}
{"title": "Declarative diagnosis of wrong answers in constraint functional-logic programming\n", "abstract": " Debugging tools are a practical need for diagnosing the causes of erroneous computations. Declarative programming paradigms involving complex operational details, such as constraint solving and lazy evaluation, do not fit well to traditional debugging techniques relying on the inspection of low-level computation traces. As a solution to this problem, declarative diagnosis uses Computation Trees (shortly, CTs) in place of traces. CTs are built a posteriori to represent the structure of a computation whose top level outcome is regarded as an error symptom by the user. Each node in a CT represents the computation of some observable result, depending on the results of its children nodes. Declarative diagnosis explores a CT looking for a so-called buggy node which computes an incorrect result from children whose results are correct; such a node must point to an incorrect program fragment. The search for a\u00a0\u2026", "num_citations": "7\n", "authors": ["1835"]}
{"title": "Towards a Set Oriented Calculus for Logic Programming 1\n", "abstract": " This paper presents SOCLP (Set Oriented Calculus for Logic Programming), a proof calculus for pure Prolog programs with negation. The main difference of this calculus wrt other related approaches is that it deals with the answer set of a goal as a whole, instead of considering each single answer separately. We prove that SOCLP is well defined, in the sense that, at most, one answer set can be derived from a goal, and that the derived set is correct and complete wrt the logical meaning of the program. However, not all the answer sets admit a proof in SOCLP. For this reason, the paper also introduces another calculus, SOCLP\u2192, which allows to prove finite approximations of (possibly infinite) answer sets. SOCLP\u2192 is coupled, through the inference rule for dealing with negation, with a third calculus SOCLP\u2190, which proves whether a set is a superset of the answer set of a given goal. The paper also shows how the three calculi are related and their main properties.", "num_citations": "7\n", "authors": ["1835"]}
{"title": "Improving deterministic computations in lazy functional logic languages\n", "abstract": " The detection of deterministic computations at run-time can be used to introduce dynamic cuts pruning the search space and thus increasing the efficiency of functional logic systems. This idea was introduced in an early work of R. Loogen and S. Winkler. However the proposal of these authors cannot be used in current implementations because it did not consider non-deterministic functions and was not oriented to the demand driven strategy. Our work adapts and extends the technique, showing both how to deal with non-deterministic computations, and how definitional trees can be employed to locate the places where the cuts will be introduced. An implementation based on a Prolog-translation is proposed, making the technique easy to implement in current systems generating Prolog code. Some experiments showing the effectiveness of the cut are presented.", "num_citations": "7\n", "authors": ["1835"]}
{"title": "A core Erlang semantics for declarative debugging\n", "abstract": " One of the main advantages of declarative languages is their clearly established formal semantics, that allows programmers to reason about the properties of programs and to establish the correctness of tools. In particular, declarative debugging is a technique that analyses the proof trees of computations to locate bugs in programs. However, in the case of commercial declarative languages such as the functional language Erlang, sometimes the semantics is only informally defined, and this precludes these possibilities. Moreover, defining semantics for these languages is far from trivial because they include complex features needed in real applications, such as concurrency. In this paper we define a semantics for Core Erlang, the intermediate language underlying Erlang programs. We focus on the problem of concurrency and show how a medium-sized-step calculus, that avoids the details of small-step semantics\u00a0\u2026", "num_citations": "6\n", "authors": ["1835"]}
{"title": "New Common Proper-Motion Pairs from the PPMX Catalog\n", "abstract": " We use data mining techniques for finding 82 previously unreported common proper motion pairs from the PPM-Extended catalogue. Special-purpose software automating the different phases of the process has been developed. The software simplifies the detection of the new pairs by integrating a set of basic operations over catalogues. The operations can be combined by the user in scripts representing different filtering criteria. This procedure facilitates testing the software and employing the same scripts for different projects.", "num_citations": "5\n", "authors": ["1835"]}
{"title": "Qualified computations in functional logic programming\n", "abstract": " Qualification has been recently introduced as a generalization of uncertainty in the field of Logic Programming. In this paper we investigate a more expressive language for First-Order Functional Logic Programming with Constraints and Qualification. We present a Rewriting Logic which characterizes the intended semantics of programs, and a prototype implementation based on a semantically correct program transformation. Potential applications of the resulting language include flexible information retrieval. As a concrete illustration, we show how to write program rules to compute qualified answers for user queries concerning the books available in a given library.", "num_citations": "5\n", "authors": ["1835"]}
{"title": "Finding New Common Proper-Motion Binaries by Data Mining\n", "abstract": " This paper presents new common proper-motion binaries detected by applying well-known statistical criteria over large subsets of the astrometric catalogs available online. All the pairs have been confirmed by checking the photographic plates and are not included in the Washington Double Star Catalog. An initial measurement of separation and position angle has been obtained for each pair.", "num_citations": "5\n", "authors": ["1835"]}
{"title": "Declarative debugging for encapsulated search\n", "abstract": " Declarative debugging has been proposed as a suitable technique for developing debuggers in the context of declarative languages. However, to become really useful debuggers must be able to deal with those parts of the languages that have no clear declarative semantics but are widely used in realistic programs. We explain in this paper how a declarative debugger of wrong answers for the lazy functional-logic language Curry can be extended to debug programs including the encapsulated search, an important feature of this language designed to control non-deterministic computation steps. We show how this can be done without introducing any changes in the compiler.", "num_citations": "5\n", "authors": ["1835"]}
{"title": "Acerca de una enumeraci\u00f3n peirceana de los racionales\n", "abstract": " Se construye efectivamente una funci\u00f3n hiyectiva entre el conjunto de los n\u00fameros naturales y el conjunto de los n\u00fameros racionales, fundamentada en una propuesta elaborada por Charles Sanders Peirce en 1909, donde se recorren progresiones aritm\u00e9ticas, n\u00fameros de Farey y Fibonacci, aritm\u00e9tica modular y comportamiento fractal. El art\u00edculo presenta los algoritmos de construcci\u00f3n de la funci\u00f3n de los n\u00fameros naturales en los racionales y de su inversa, que adem\u00e1s se han implementado en lenguaje C y MapleV y cuyos archivos se encuentran disponibles.", "num_citations": "5\n", "authors": ["1835"]}
{"title": "Debugging meets testing in erlang\n", "abstract": " We propose a bidirectional collaboration between declarative debugging and testing for detecting errors in the sequential subset of the programming language Erlang. In our proposal, the information obtained from the user during a debugging session is stored in form of unit tests. These test cases can be employed afterwards to check, through testing, if the bug has been actually corrected. Moreover, the debugger employs already existing tests to determine the correctness of some subcomputations, helping the user to locate the error readily. The process, contrarily to usual debugger frameworks is cumulative: if later we find a new bug we have more information from the previous debugging and testing iterations that can contribute to find the error readily.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Two type extensions for the constraint modeling language MiniZinc\n", "abstract": " In this paper we present two type extensions for the modeling language MiniZinc that allow the representation of some problems in a more natural way. The first proposal, called MiniZinc\u22c6, extends existing types with additional values. The user can specify both the extension of a predefined type with new values, and the behavior of the operations with relation to the new types. We illustrate the usage of MiniZinc\u22c6 to model SQL-like problems with integer variables extended with NULL values. The second extension, MiniZinc+, introduces union types in the language. This allows defining recursive types such as trees, which are very useful for modeling problems that involve complex structures. A new case statement is introduced to select the different components of union type terms. The paper shows how a model defined using these extensions can be transformed into a MiniZinc model which is equivalent to the\u00a0\u2026", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Test-Case Generation for SQL Nested Queries with Existential Conditions\n", "abstract": " This paper presents a test-case generator for SQL queries. Starting with a set of related SQL views that can include existential subqueries in the conditions, the technique finds a database instance that can be used as a test-case for the target view. The proposal reduces the problem of generating the test-cases to a Constraint Satisfaction Problem using finite domain constraints. In particular, we present a new approach for existential conditions that makes possible to find test-cases for a wider set of queries. The soundness and correctness of the technique with respect to a simple operational semantics for SQL queries without aggregates is proven. The theoretical ideas have been implemented in an available prototype.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Finite type extensions in Constraint Programming (extended version)\n", "abstract": " Many problems are naturally modelled by extending an existing type with additional values. For example for modelling database problems with nulls natural models use integers with an additional null value. Similarly models involving integers may naturally be extended to handle\u2212\u221e and+\u221e. We extend MiniZinc to MiniZinc+ to allow modelling with extended types. The user can specify both the extension of a predefined type with new values, and the behavior of the operations with relation to the new types. The resulting model MiniZinc+ model is transformed to a MiniZinc model which is equivalent to the original model. We illustrate the usage of MiniZinc+ to model Boolean circuits allowing undefined inputs and scheduling problems considering special time values.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "351 New Common Proper-Motion Pairs from the Sloan Digital Sky Survey\n", "abstract": " This paper presents 351 previously uncataloged pairs with separation under 100 arcseconds and proper motion over 70 milliseconds of arc/year. These pairs are the result of an extensive study that started with 96,205 candidate pairs from the Sloan Digital Survey (SDSS). Different criteria explained in the paper are applied to increase the probability of a physical bound between the components.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Declarative debugging of missing answers in constraint functional-logic programming\n", "abstract": " It is well known that constraint logic and functional-logic programming languages have many advantages, and there is a growing trend to develop and incorporate effective tools to this class of declarative languages. In particular, debugging tools are a practical need for diagnosing the causes of erroneous computations. Recently [1], we have presented a prototype tool for the declarative diagnosis of wrong computed answers in CFLP (D), a new generic scheme for lazy Constraint Functional-Logic Programming which can be instantiated by any constraint domain D given as parameter [2]. The declarative diagnosis of missing answers is another well-known debugging problem in constraint logic programming [4]. This poster summarizes an approach to this problem in CFLP (D). From a programmer\u2019s viewpoint, a tool for diagnosing missing answers can be used to experiment wether the program rules for certain functions are sufficient or not for computing certain expected answers. For example, consider a CFLP (H)-program fragment written in T OY [3], where strict equality and disequality constraints are used for generating family relationships based on the basic family facts shown in Fig. 1.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Implementing Dynamic-Cut in TOY\n", "abstract": " This paper presents the integration of the optimization known as dynamic cut within the functional-logic system T OY. The implementation automatically detects deterministic functions at compile time, and includes in the generated code the test for detecting at run-time the computations that can actually be pruned. The outcome is a much better performance when executing deterministic functions including either or-branches in their definitional trees or extra variables in their conditions, with no serious overhead in the rest of the computations. The paper also proves the correctness of the criterion used for detecting deterministic functions wrt the semantic calculus CRWL.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Dynamic-cut with definitional trees\n", "abstract": " The detection of deterministic computations at run-time can be used to introduce dynamic cuts pruning the search space and thus increasing the efficiency of Functional-Logic systems. This idea was introduced in an early work of R. Loogen and S. Winkler. However the proposal of these authors cannot be used in current implementations because it did not consider non-deterministic functions and was not oriented to the demand driven strategy. Our work adapts and extends the technique, both showing how to deal with non-deterministic computations and how definitional trees can be employed to locate the places where the cuts will be introduced. An implementation based on a Prolog-translation is proposed, making the technique easy to implement in current systems generating Prolog code. Some experiments showing the effectiveness of the cut are presented.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Extensions: A technique for structuring functional-logic programs\n", "abstract": " Monads are a technique widely used in functional programming languages to address many different problems. This paper presents extensions, a functional-logic programming technique that constitutes an alternative to monads in several situations. Extensions permit the definition of easily reusable functions in the same way as monads, but are based on simpler concepts taken from logic programming, and hence they lead to more appealing and natural definitions of types and functions. Moreover, extensions are compatible with interesting features typical of logic programming, like multiple modes of use, while monads are not.", "num_citations": "4\n", "authors": ["1835"]}
{"title": "Short term cloud nowcasting for a solar power plant based on irradiance historical data\n", "abstract": " This work considers the problem of forecasting the normal solar irradiance with high spatial and temporal resolution (5 minutes). The forecasting is based on a dataset registered during one year from the high resolution radiometric network at a operational solar power plan at Almeria, Spain. In particular, we show a technique for forecasting the irradiance in the next few minutes from the irradiance values obtained on the previous hour. Our proposal employs a type of recurrent neural network known as LSTM, which can learn complex patterns and that has proven its usability for forecasting temporal series. The results show a reasonable improvement with respect to other prediction methods typically employed in the studies of temporal series.", "num_citations": "3\n", "authors": ["1835"]}
{"title": "New Northern Hemisphere Common Proper-Motion Pairs from the UCAC-3 Catalog\n", "abstract": " This paper presents 310 new common proper-motion pairs obtained by data mining the recently released UCAC-3 in positive declinations. The pairs were selected by using statistical criteria and have been confirmed by checking the photographic plates.", "num_citations": "3\n", "authors": ["1835"]}
{"title": "Declarative debugging of Maude functional modules\n", "abstract": " We introduce a declarative debugger for Maude functional modules, which correspond to executable specifications in membership equational logic. First we describe the construction of appropriate debugging trees for oriented equational and membership inferences. These trees are obtained as the result of collapsing in proof trees all  those nodes whose correction does not need any justification.  Since Maude supports the reflective features in its underlying logic, it includes a predefined META-LEVEL module providing access to metalevel concepts such as specifications or computations as usual data. This allows us to generate and navigate the debugging tree of a Maude computation using operations in Maude itself. Even the  user interface of the declarative debugger for Maude can be specified in Maude itself. We describe in detail this metalevel implementation of our tool.   Finally, we include several extended examples to illustrate the use of the declarative debugger and its main features, such as two different strategies to traverse the  debugging tree, use of a correct module to reduce the number of questions asked to the user, selection of trusted vs. suspicious statements by means of labels, and trusting of statements \u201con the \ufb02y.\u201d", "num_citations": "3\n", "authors": ["1835"]}
{"title": "A functional logic alternative to monads\n", "abstract": " Monads are a technique widely used in functional programming languages to address many dierent problems. This paper presents extensions, a functional-logic programming technique that constitutes an alternative to monads in several situations. Extensions permit the denition of easily reusable functions in the same way as monads, but are based on simpler concepts taken from logic programming, and hence they lead to more appealing and natural denitions of types and functions. Moreover, extensions are compatible with interesting features typical of logic programming, like multiple modes of use, while monads are not. This property further contributes to the employment of the same code to solve dierent problems.", "num_citations": "3\n", "authors": ["1835"]}
{"title": "A program transformation for converting java assertions into control-flow statements\n", "abstract": " We present a technique for checking the validity of Java assertions using an arbitrary automated test-case generator. Our framework transforms the program by introducing code that detects whether the assertion conditions are met by every direct and indirect method call within a certain depth level. Then, any automated test-case generator can be used to look for input examples that falsify the conditions. The program transformation ensures that the value obtained for these inputs represents a path of method calls that ends with a violation of some assertion. We show experiments with two different automatic test-case generators that demonstrate not just the applicability of our proposal but also that we can get a better coverage than the same test-case generators without our transformation.", "num_citations": "2\n", "authors": ["1835"]}
{"title": "Finite type extensions in constraint programming\n", "abstract": " Many problems are naturally modelled by extending an existing type with additional values. For example for modelling database problems with nulls natural models use booleans and integers with an additional null value. Similarly models involving integers may naturally be extended to handle-\u221e and+\u221e. We extend the constraint modelling language MiniZinc to MiniZinc+ to allow modelling with extended types. The user can specify both the extension of a predefined type with new values, and the behavior of the operations with relation to the new types. The resulting MiniZinc+ model is transformed to a MiniZinc model which is equivalent to the original model. We illustrate the usage of MiniZinc+ to model SQL like problems with integer variables extended with NULL values.", "num_citations": "2\n", "authors": ["1835"]}
{"title": "Six Proper Motion Pairs Measured with the 2-meter Faulkes Telescope North\n", "abstract": " Multiple observations were made of six faint common proper motion pairs with the 2-meter Faulkes Telescope North on Haleakala by Maui middle school and high school students and their supporters. Of the six pairs, two are reported as newly discovered proper motion binaries. Individual reductions versus a single \u2018track and stack\u2019reduction were compared.", "num_citations": "2\n", "authors": ["1835"]}
{"title": "New Common Proper-Motion Pairs from the IPHAS-POSS-I Survey\n", "abstract": " The aim of this paper is to examine the IPHAS-POSS-I survey looking for previously uncataloged common proper motion pairs. This is done by selecting pairs of stars with separation under 90 arc seconds and also similar and significant proper motion. Different criteria are applied to reduce the set of pairs increasing the probability of a physical bound between the two components. The result of this research is a set of 34 new common proper motion pairs.", "num_citations": "2\n", "authors": ["1835"]}
{"title": "A logical framework for the algorithmic debugging of lazy functional-logic programs\n", "abstract": " Traditional debugging techniques are not well suited for lazy functional programming, because of the difficult-to-predict evaluation order. Therefore, declarative debugging techniques have been proposed, which allow to focus on the intended meaning of programs, abstracting away operational concerns. Similar techniques are known also for logic programming and for combined functional logic languages. The aim of this paper is to provide theoretical foundations for the declarative debugging of wrong answers in lazy functional logic programming. We propose a logical framework which formalizes both the intended meaning and the execution model of programs in a simple language which combines the expressivity of pure Prolog and a significant subset of Haskell. As a novelty wrt previous related works, we obtain a completely formal specification of the debugging method. In particular, we extend known soundness and completeness results for the debugging of wrong answers in logic programming to a substantially more difficult context. This work should serve as a clear guideline for a future prototype implementation of a debugging system.", "num_citations": "2\n", "authors": ["1835"]}
{"title": "Querubismo: un estudio de tres generaciones\n", "abstract": " Todos los casos fueron diagnosticados por sus manifestaciones cl\u00ednico-radiol\u00f3gicas, realiz\u00e1ndose un seguimiento de los pacientes a lo largo del tiempo. En las tres generaciones se hallaron imagenes radiol\u00f3gicas radiol\u00facidas en ambos maxilares. El lugar t\u00edpico de las lesiones fue la regi\u00f3n anterior y posterior de la mand\u00edbula, as\u00ed como las tuberosidades maxilares. En cuatro de los cinco casos observamos alteraciones dentales tales como agenesias, ectopias, api\u00f1amiento y malposiciones en la dentici\u00f3n temporal y/o permanente. Se comenta la evoluci\u00f3n seguida por los pacientes, as\u00ed como el planteamiento del tratamiento.", "num_citations": "2\n", "authors": ["1835"]}
{"title": "A unified framework for declarative debugging and testing\n", "abstract": " Context:Debugging is the most challenging and time consuming task in software development. However, it is not properly integrated in the software development cycle, because the result of so much effort is not available in further iterations of the cycle, and the debugging process itself does not benefit from the outcome of other phases such as testing.Objective:We propose to integrate debugging and testing within a single unified framework where each phase generates useful information for the other and the outcomes of each phase are reused.Method:We consider a declarative debugging setting that employs tests to automatically entail the validity of some subcomputations, thus decreasing the time and effort needed to find a bug. Additionally, the debugger stores as new tests the information collected from the user during the debugging phase. This information becomes part of the program test suite, and can be\u00a0\u2026", "num_citations": "1\n", "authors": ["1835"]}
{"title": "Checking Java Assertions Using Automated Test-Case Generation\n", "abstract": " We present a technique for checking the validity of Java assertions using an arbitrary automated test-case generator. Our framework transforms the program by introducing code that detects whether the assertion conditions are met by every direct and indirect method call within a certain depth level. Then, any automated test-case generator can be used to look for input examples that falsify the conditions. We show by means of experimental results the effectiveness of our proposal.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "Constraint Programming Meets SQL\n", "abstract": " We present a proposal for introducing SQL tuples into the modeling programming language MINIZ-INC. The domain of the new decision variables is defined by arbitrary relational database tables indicated by the user. The new setting increases the expressiveness of MINIZINC, allowing the modeler to mix the usual finite domains already existing in the language with string constraints typical from SQL such as concat, substr, or like. In order to obtain the solutions of these combined models, we first replace the atomic constraints involving strings by boolean variables. The result is a standard MINIZINC model, which can be solved by any off-the-shelf solver. Then, each individual solution is applied to the remainder string constraints, which are then solved using an SQL query. We discuss how both languages, MINIZINC and SQL, benefit from this combination.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "A zoom-declarative debugger for sequential Erlang programs (extended version)\n", "abstract": " We present a declarative debugger for sequential Erlang programs. The tool is started by the user when a program produces some unexpected result. It automatically builds a computation tree representing the structure of the erroneous computation. The tree is then traversed asking questions to the user about the validity of some nodes of the tree, which represent the results of intermediate subcomputations, until a bug in the program is found. The navigation process first concentrates in locating an erroneous function in the program. Then, the user can refine the granularity by zooming out the function, checking the values bound to variables and the if/case/try-catch branches taken during the execution. In order to represent the erroneous computation, a semantic calculus for sequential Core Erlang programs is proposed. The debugger uses an abbreviation of the proof trees in this calculus as debugging trees, which allows us to prove the soundness of the approach. The technique has been implemented in a tool publicly available. An exhaustive analysis of the usability of the tool is also presented.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "A calculus for sequential erlang programs\n", "abstract": " We present here the evaluation semantics for sequential Erlang programs. We first introduce the syntax of the programs we want to evaluate and then present the calculus in two steps. Once the syntax has been presented, we describe the rules for computing correct values, and then we present the rules dealing with errors and throwing exceptions.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "A calculus for zoom debugging sequential Erlang programs\n", "abstract": " We present here the evaluation semantics for sequential Erlang programs specially developed to be used for \u201czoom debugging.\u201d We first introduce the syntax of the programs we want to evaluate and then present the different evaluations that take place in the calculus. The rest of the sections describes the calculus for references, values, and exceptions.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "Improving the debugging of membership equational logic specifications\n", "abstract": " Declarative debugging is a debugging technique that abstracts the execution details, that can be difficult to follow in general in declarative languages, to focus on results. It relies on a data structure called debugging tree, that represents the computation and is traversed by asking questions to the user about the correction of the computation steps related to each node. Thus, the complexity of the questions is an important factor regarding the applicability of the technique. In this paper we present a transformation for debugging trees for Maude specifications that ensures that any subterm occurring in a question has been previously replaced by the most reduced form that it has taken during the computation, thus ensuring that questions become as simple as possible.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "A Generic Scheme for Qualified Constraint Functional Logic Progamming\n", "abstract": " Qualification has been recently introduced as a generalization of uncertainty in the field of Logic Programming. In this report we investigate a more expressive language for First-Order Functional Logic Programming with Constraints and Qualification. We present a Rewriting Logic which characterizes the intended semantics of programs, and a prototype implementation based on a semantically correct program transformation. Potential applications of the resulting language include flexible information retrieval. As a concrete illustration, we show how to write program rules to compute qualified answers for user queries concerning the books available in a given library.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "Algorithmic debugging of missing answers in constraint functional-logic programming\n", "abstract": " We present a declarative method for diagnosing missing computed answers in CFLP (D), a generic scheme for lazy Constraint Functional-Logic Programming which can be instantiated by any constraint domain D given as parameter. As far as we know, declarative diagnosis of missing answers in such an expressive framework has not been tackled before. Our approach combines and extends previous work done separately for constraint logic programming and lazy functional programming languages. Diagnosis can be started whenever a user finds that the set of computed answers for a given goal with finite search space misses some expected solution wrt an intended interpretation of the program, that provides a declarative descriptions of its expected behavior. Diagnosis proceeds by exploring a proof tree, that provides a declarative view of the answer-collection process performed by the computation, and it ends up with the detection of some function definition in the program that is incomplete wrt the intended interpretation. We can prove the logical correctness of the diagnosis method under the assumption that the recollection of computed answers performed by the goal solving system can be represented as a proof tree. We argue the plausibility of this assumption, and we describe the prototype of a tool which implements the diagnosis method.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "Importancia de los factores predisponentes en la candidiasis bucal\n", "abstract": " La candidiasis bucal, causada principalmente por Candida albicans, es de gran importancia estomatol\u00f3gica, por su frecuencia, variedad cl\u00ednica, riesgo de diseminaci\u00f3n, as\u00ed como por predisponer a la transformaci\u00f3n maligna de ciertas lesiones bucales. Su etiolog\u00eda es multifactorial, favoreciendo su aparici\u00f3n la virulencia del hongo y factores del hu\u00e9sped sist\u00e9micos y/o locales. Entre los primeros destacan la adherencia del hongo a las mucosas y la producci\u00f3n de hidrolasas. En los factores sist\u00e9micos predominan aquellas patolog\u00edas o terapias que deprimen el sistema inmunitario. Los factores locales pueden deberse a una alteraci\u00f3n de la barrera mucosa oa la calidad o cantidad de saliva. Evidentemente, controlar todos estos factores predisponentes ser\u00e1 una medida fundamental a tener en cuenta en la prevenci\u00f3n y tratamiento de esta enfermedad.", "num_citations": "1\n", "authors": ["1835"]}
{"title": "A functional specification of declarative debugging for logic programming\n", "abstract": " One of the major adventages of declarative programming is that it allows users to describe what are the characteristics of the problem they would like to solve, almost dismissing the considerations about how the problem is solved actually. In the same line, the aim of algorithmic debugging(also called declarative debugging) is to base the debugging process in the declarative meaning of the the program. In this work we rst look at declarative debugging as a general framework, introducing a scheme based on the concept of computation tree. We will discuss three possible strategies and present their specications in a functional language, Haskell [HAS97]. Indeed our debuggers do not intend to be ecient, but only to present clearly some ideas relative to declarative debugging. In the second part we will move into the paradigm of pure logic programming, presenting a debugging framework for logic programs written in\u00a0\u2026", "num_citations": "1\n", "authors": ["1835"]}