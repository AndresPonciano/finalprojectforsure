{"title": "Review of recent systems for automatic assessment of programming assignments\n", "abstract": " This paper presents a systematic literature review of the recent (2006--2010) development of automatic assessment tools for programming exercises. We discuss the major features that the tools support and the different approaches they are using both from the pedagogical and the technical point of view. Examples of these features are ways for the teacher to define tests, resubmission policies, security issues, and so forth. We have also identified a list of novel features, like assessing web software, that are likely to get more research attention in the future. As a conclusion, we state that too many new systems are developed, but also acknowledge the current reasons for the phenomenon. As one solution we encourage opening up the existing systems and joining efforts on developing those further. Selected systems from our survey are briefly described in Appendix A.", "num_citations": "494\n", "authors": ["928"]}
{"title": "Predicting academic performance: a systematic literature review\n", "abstract": " The ability to predict student performance in a course or program creates opportunities to improve educational outcomes. With effective performance prediction approaches, instructors can allocate resources and instruction more accurately. Research in this area seeks to identify features that can be used to make predictions, to identify algorithms that can improve predictions, and to quantify aspects of student performance. Moreover, research in predicting student performance seeks to determine interrelated features and to identify the underlying reasons why certain features work better than others. This working group report presents a systematic literature review of work in the area of predicting student performance. Our analysis shows a clearly increasing amount of research in this area, as well as an increasing variety of techniques used. At the same time, the review uncovered a number of issues with research\u00a0\u2026", "num_citations": "105\n", "authors": ["928"]}
{"title": "Two-dimensional parson\u2019s puzzles: The concept, tools, and first observations\n", "abstract": " Parson\u2019s programming puzzles are a family of code construction assignments where lines of code are given, and the task is to form the solution by sorting and possibly selecting the correct code lines. We introduce a novel family of Parson\u2019s puzzles where the lines of code need to be sorted in two dimensions. The vertical dimension is used to order the lines, whereas the horizontal dimension is used to change control flow and code blocks based on indentation as in Python. Python blocks have no explicit begin/end statements or curly braces to mark where the block starts or stops. Instead, indentation is used to define starts and stops of blocks and functions.", "num_citations": "57\n", "authors": ["928"]}
{"title": "Service-oriented approach to improve interoperability of e-learning systems\n", "abstract": " We present a design and open source implementation for a service oriented e-learning system, which utilizes external services for supporting a wide range of learning content and also offers a REST API for external clients to fetch information stored in the system. The design will separate different concerns, such as user authentication and exercise assessment, into separate services, which together form a complete e-learning environment. A key component of the design is identifying a general set of characteristics among existing exercise assessment systems, by which the assessment methods are grouped into three types: synchronous, asynchronous and static exercises.", "num_citations": "50\n", "authors": ["928"]}
{"title": "Mutation analysis vs. code coverage in automated assessment of students' testing skills\n", "abstract": " Learning to program should include learning about proper software testing. Some automatic assessment systems, eg Web-CAT, allow assessing student-generated test suites using coverage metrics. While this encourages testing, we have observed that sometimes students can get rewarded from high coverage although their tests are of poor quality. Exploring alternative methods of assessment, we have tested mutation analysis to evaluate students' solutions. Initial results from applying mutation analysis to real course submissions indicate that mutation analysis could be used to fix some problems of code coverage in the assessment. Combining both metrics is likely to give more accurate feedback.", "num_citations": "48\n", "authors": ["928"]}
{"title": "Quality of WordPress plug-ins: an overview of security and user ratings\n", "abstract": " We have applied static analysis to find out how vulnerable the plugins available at the official Word Press plug in directory are to well known security exploits. We have compared the amount of potential vulnerabilities and vulnerability density to the user ratings, to determine if user ratings can be used for finding secure plugins. We conclude that the quality of the plugins varies and there is no clear correlation between the ratings of plugins and the number of vulnerabilities detected in them. Indeed, an additional manual review exposed a simple but severe SQL injection vulnerability in a plug in, which has both good user ratings and a high download count. We recommend plugins to be individually inspected for typical vulnerabilities before using them in any Word Press powered site.", "num_citations": "36\n", "authors": ["928"]}
{"title": "Software visualization today: Systematic literature review\n", "abstract": " Software visualization means visualizing various aspects and artifacts related to software. By this definition a wide range of different software engineering aspects from program comprehension to understanding software process and usage are covered. This paper presents the results of systematic literature review spanning six years of software visualization literature. The main result shows that the most studied topics in the past six years are related to software structure, behavior and evolution. Software process and usage are addressed only in few studies. In the future studying the adoption of software visualization tools in industry context would be beneficial.", "num_citations": "26\n", "authors": ["928"]}
{"title": "Analysis of source code snapshot granularity levels\n", "abstract": " Systems that record students' programming process have become increasingly popular during the last decade. The granularity of stored data varies across these systems and ranges from storing the final state, eg a solution, to storing fine-grained event streams, eg every key-press made while working on a task. Researchers that study such data make assumptions based on the granularity. If no fine-grained data exists, the baseline assumption is that a student proceeds in a linear fashion from one recorded state to the next. In this work, we analyze three different granularities of data;(1) submissions,(2) snapshots (ie save, compile, run, test events), and (3) keystroke-events. Our study provides insight on the quantity of lost data when storing data at a specific granularity and shows how the lost data varies depending on previous programming experience and the programming assignment type.", "num_citations": "26\n", "authors": ["928"]}
{"title": "Plagiarism in take-home exams: help-seeking, collaboration, and systematic cheating\n", "abstract": " Due to the increased enrollments in Computer Science education programs, institutions have sought ways to automate and streamline parts of course assessment in order to be able to invest more time in guiding students' work.", "num_citations": "25\n", "authors": ["928"]}
{"title": "Adapting moodle to better support CS education\n", "abstract": " Many commercial or open-source systems for organizing courses are available, offering access to course materials, communication support, and receiving and grading student submissions. However, most of these systems are by default not ideally prepared to address specific demands of Computer Science (CS) education. We explore how Moodle as one of the most popular and free systems can be better adapted to support the needs of CS education and provide concrete guidance on features and extensions that could be explored. This report and work based on it can significantly improve courses for educators and students alike", "num_citations": "25\n", "authors": ["928"]}
{"title": "Comparison of time metrics in programming\n", "abstract": " Research on the indicators of student performance in introductory programming courses has traditionally focused on individual metrics and specific behaviors. These metrics include the amount of time and the quantity of steps such as code compilations, the number of completed assignments, and metrics that one cannot acquire from a programming environment. However, the differences in the predictive powers of different metrics and the cross-metric correlations are unclear, and thus there is no generally preferred metric of choice for examining time on task or effort in programming. In this work, we contribute to the stream of research on student time on task indicators through the analysis of a multi-source dataset that contains information about students' use of a programming environment, their use of the learning material as well as self-reported data on the amount of time that the students invested in the course\u00a0\u2026", "num_citations": "22\n", "authors": ["928"]}
{"title": "Test data generation for programming exercises with symbolic execution in Java PathFinder\n", "abstract": " Automatic assessment of programming exercises is typically based on testing approach. Most automatic assessment frameworks execute tests and evaluate test results automatically, but the test data generation is not automated. No matter that such test data generation techniques and tools are available.", "num_citations": "16\n", "authors": ["928"]}
{"title": "Computational thinking as an emergent learning trajectory of mathematics\n", "abstract": " In the 21st century, the skills of computational thinking complement those of traditional math teaching. In order to gain the knowledge required to teach these skills, a cohort of math teachers participated in an in-service training scheme conducted as a massive open online course (MOOC). This paper analyses the success of this training scheme and uses the results of the study to focus on the skills of computational thinking, and to explore how math teachers expect to integrate computing into the K-12 math syllabus. The coursework and feedback from the MOOC course indicate that they readily associate computational thinking with problem solving in math. In addition, some of the teachers are inspired by the new opportunities to be creative in their teaching. However, the set of programming concepts they refer to in their essays is insubstantial and unfocused, so these concepts are consolidated here to form a\u00a0\u2026", "num_citations": "12\n", "authors": ["928"]}
{"title": "Creating and visualizing test data from programming exercises\n", "abstract": " Automatic assessment of programming exercises is typically based on testing approach. Most automatic assessment frameworks execute tests and evaluate test results automatically, but the test data generation is not automated. No matter that automatic test data generation techniques and tools are available. We have researched how the Java PathFinder software model checker can be adopted to the specific needs of test data generation in automatic assessment. Practical problems considered are: how to derive test data directly from students\u2019 programs (ie, without annotation) and how to visualize and how to abstract test data automatically for students? Interesting outcomes of our research are that with minor refinements generalized symbolic execution with lazy initialization (a test data generation algorithm implemented in PathFinder) can be used to construct test data directly from students\u2019 programs without\u00a0\u2026", "num_citations": "12\n", "authors": ["928"]}
{"title": "Information visualization heuristics in practical expert evaluation\n", "abstract": " While traditional HCI heuristics can be used to find usability issues also from information visualization systems, specialized heuristics tailored for the information visualization (InfoViz) domain can be more effective and focus on the special characteristics of these systems. In this study, we describe the application of ten information visualization heuristics from prior research and their testing in practical heuristic evaluation. We found that the selected heuristics were useful with good coverage in our application case. However, based on our observations, we argue that interaction, veracity, and aesthetics related heuristics should be added to the previously used set. The lack of domain knowledge made the evaluators somewhat uneasy with their capability to carry out the investigation in-depth. We suggest to train domain experts with understanding of the data and application domain to carry out the evaluation to get\u00a0\u2026", "num_citations": "11\n", "authors": ["928"]}
{"title": "Automatic test data generation for programming exercises with symbolic execution and Java PathFinder\n", "abstract": " Test data demonstration presented in this work is based on partially initialized object graphs and symbolic execution. The idea is to provide symbolic object graphs for students. Each symbolic object graph can be instantiated into (several) concrete test data so that all the inputs derived from the same symbolic structure lead into identical execution paths.", "num_citations": "11\n", "authors": ["928"]}
{"title": "Using and collecting fine-grained usage data to improve online learning materials\n", "abstract": " As educators seek to create better learning materials, knowledge about how students actually use the materials is priceless. The advent of online learning materials has allowed tracking of student movement on levels not previously possible with on-paper materials: server logs can be parsed for details on when students opened certain pages. But such data is extremely coarse and only allows for rudimentary usage analysis. How do students move within the course pages? What do they read in detail and what do they glance over? Traditionally, answering such questions has required complex setups with eye tracking labs. In this paper we investigate how fine-grained data about student movement within an online learning material can be used to improve said material in an informed fashion. Our data is collected by a JavaScript-component that tracks which elements of the online learning material are visible on the\u00a0\u2026", "num_citations": "10\n", "authors": ["928"]}
{"title": "How do students solve parsons programming problems?--execution-based vs. line-based feedback\n", "abstract": " In large introductory programming classes, there typically are no resources for adequate individual guidance. Automatic feedback for programming tasks can facilitate students' learning by allowing them to get immediate individual feedback regardless of time and place. This paper presents a study on how the type of automatic feedback in Parsons problems affects how students solve them. Students on their first programming class were divided into two groups and, in two assignments, each group in turn received different type of feedback. The type of feedback had an effect on how students constructed their programs and how quickly they were able to complete them. With feedback based on execution as opposed to the visible arrangement of code, the programs were more frequently executable when feedback was requested and, overall, feedback was requested less frequently. Based on the analysis, we discuss\u00a0\u2026", "num_citations": "10\n", "authors": ["928"]}
{"title": "Predicting academic success based on learning material usage\n", "abstract": " In this work, we explore students' usage of online learning material as a predictor of academic success. In the context of an introductory programming course, we recorded the amount of time that each element such as a text paragraph or an image was visible on the students' screen. Then, we applied machine learning methods to study to what extent material usage predicts course outcomes. Our results show that the time spent with each paragraph of the online learning material is a moderate predictor of student success even when corrected for student time-on-task, and that the information can be used to identify at-risk students. The predictive performance of the models is dependent on the quantity of data, and the predictions become more accurate as the course progresses. In a broader context, our results indicate that course material usage can be used to predict academic success, and that such data can be\u00a0\u2026", "num_citations": "9\n", "authors": ["928"]}
{"title": "Open source widget for parson's puzzles\n", "abstract": " We introduce js-parsons-MIT licensed JavaScript widget to embed Parson's puzzles to any HTML. The novelty of js-parsons is the 2-dimensional drag-and-drop of the code lines. Firstly, the code lines in the solution need to be in correct order as in the existing solutions. Secondly, since our exercises present Python, code blocks are created by indenting the code lines. This is done by drag-and-dropping the lines in horizontal direction. In addition, js-parsons can record how puzzles are solved and send the logs to a server. We hope to use the logging feature to understand how students solve puzzles and how puzzles should be designed to be more effective.", "num_citations": "9\n", "authors": ["928"]}
{"title": "The internet of bodies needs a human data model\n", "abstract": " Today, creating innovative Internet of Bodies solutions requires manually gathering the needed information from an increasing number of services and personal devices. In this article, we tackle this challenge by presenting Human Data Model-a programming framework for combining information from several sources, performing computations over that information to high-level abstractions, and then providing these abstractions to proactively schedule computer-human interactions.", "num_citations": "8\n", "authors": ["928"]}
{"title": "Code complexity in introductory programming courses\n", "abstract": " Instructors of introductory programming courses would benefit from having a metric for evaluating the sophistication of student code. Since introductory programming courses pack a wide spectrum of topics in a short timeframe, student code changes quickly, raising questions of whether existing software complexity metrics effectively reflect student growth as reflected in their code. We investigate code produced by over 800 students in two different Python-based CS1 courses to determine if frequently used code quality and complexity metrics (eg, cyclomatic and Halstead complexities) or metrics based on length and syntactic complexity are more effective as a heuristic for gauging students\u2019 progress through a course. We conclude that the traditional metrics do not correlate well with time passed in the course. In contrast, metrics based on syntactic complexity and solution size correlate strongly with time in the course, suggesting that they may be more appropriate for evaluating how student code evolves in a course context.", "num_citations": "8\n", "authors": ["928"]}
{"title": "Preventing keystroke based identification in open data sets\n", "abstract": " Large-scale courses such as Massive Online Open Courses (MOOCs) can be a great data source for researchers. Ideally, the data gathered on such courses should be openly available to all researchers. Studies could be easily replicated and novel studies on existing data could be conducted. However, very fine-grained data such as source code snapshots can contain hidden identifiers. For example, distinct typing patterns that identify individuals can be extracted from such data. Hence, simply removing explicit identifiers such as names and student numbers is not sufficient to protect the privacy of the users who have supplied the data. At the same time, removing all keystroke information would decrease the value of the shared data significantly.", "num_citations": "8\n", "authors": ["928"]}
{"title": "Curricular concept maps as structured learning diaries: Collecting data on self-regulated learning and conceptual thinking for learning analytics applications\n", "abstract": " The collection and selection of the data used in learning analytics applications deserve more attention. Optimally, selection of data should be guided by pedagogical purposes instead of data availability. Using design science research methodology, we designed an artifact to collect time-series data on students\u2019 self-regulated learning and conceptual thinking. Our artifact combines curriculum data, concept mapping, and structured learning diaries. We evaluated the artifact in a case study, verifying that it provides relevant data, requires a limited amount of effort from students, and works in different educational contexts. Combined with learning analytics applications and interventions, our artifact provides possibilities to add value for students, teachers, and academic leaders.", "num_citations": "7\n", "authors": ["928"]}
{"title": "Admitting Students through an Open Online Course in Programming: A Multi-year Analysis of Study Success\n", "abstract": " Since 2012, part of computer science student body at the University of Helsinki has been selected by using a massively open online version of the same introductory programming course that our freshmen take. In this multi-year study, we compare study success between students accepted through the online course (MOOC intake) and students accepted through the traditional entrance exam and high school matriculation exam based intake (normal intake). Our findings indicate that the MOOC intake perform better in computer science studies when looking at completed credits and grade point average, but there is no difference when considering other courses. Retention among the MOOC intake is better than among the normal intake. Additionally, students in the MOOC intake are more likely to complete their capstone project and Bachelor's thesis in the studied time-frame. However, the MOOC intake makes the\u00a0\u2026", "num_citations": "7\n", "authors": ["928"]}
{"title": "What communication tools do students use in software projects and how do different tools suit different parts of project work?\n", "abstract": " In software engineering education, the goal is often to provide students with authentic assignments using actual tools of the trade. Students are often allowed to select their preferred tools without specifying what to use for e.g. communication within the team, scheduling, bug tracking, etc. However, there is an abundance of tools to choose from with more appearing rapidly, which can make it difficult for students or staff to select appropriate tools for each task. In this paper, we study the suitability of several commonly used communication and collaboration tools on different tasks that students encounter in team assignments. We surveyed students' experiences with different tools in a university-level web software development course.", "num_citations": "7\n", "authors": ["928"]}
{"title": "Automated assessment of programming assignments: visual feedback, assignment mobility, and assessment of students' testing skills\n", "abstract": " The main objective of this thesis is to improve the automated assessment of programming assignments from the perspective of assessment tool developers.   We have developed visual feedback on functionality of students' programs and explored methods to control the level of detail in visual feedback. We have found that visual feedback does not require major changes to existing assessment platforms. Most modern platforms are web based, creating an opportunity to describe visualizations in JavaScript and HTML embedded into textual feedback. Our preliminary results on the effectiveness of automatic visual feedback indicate that students perform equally well with visual and textual feedback. However, visual feedback based on automatically extracted object graphs can take less time to prepare than textual feedback of good quality.   We have also developed programming assignments that are easier to port from one server environment to another by performing assessment on the client-side. This not only makes it easier to use the same assignments in different server environments but also removes the need for sandboxing the execution of students' programs. The approach will likely become more important in the future together with interactive study materials becoming more popular. Client-side assessment is more suitable for self-studying material than for grading because assessment results sent by a client are often too easy to falsify.   Testing is an important part of programming and automated assessment should also cover students' self-written tests. We have analyzed how students behave when they are rewarded for structural test\u00a0\u2026", "num_citations": "7\n", "authors": ["928"]}
{"title": "Search of the emotional design effect in programming revised\n", "abstract": " In this paper, we validate and extend previous findings on using emotional design in online learning materials by using a randomized controlled trial in the context of a partially-online university level programming course. For students who did not master the content beforehand, our results echo previous observations: emotional design material was not perceived more favourably, while materials\u2019 perceived quality was correlated with learning outcomes. Emotionally designed material lead to better learning outcomes per unit of time, but it didn\u2019t affect students navigation in the material.", "num_citations": "4\n", "authors": ["928"]}
{"title": "10 Automated Visual Feedback from Programming Assignments\n", "abstract": " Most modern assessment platforms for programming assignments are web-oriented and used with a browser (Douce et al., 2005). Students upload their work to the system and get (almost) immediate feedback from different aspects of their program, eg correctness, test coverage, style, etc (Ala-Mutka, 2005). We feel that the browser platform, however, is not used up to its full potential. Using HTML and JavaScript in the feedback itself could open new possibilities. In this paper, we explore ways for offering visual feedback in existing systems for automated assessment of programming assignments without radical changes to the assessment platforms. We also present initial results of effectiveness and some results from an attitude survey.The use of visualizations in automated assessment of correctness of programming assignments is rare. Students get textual feedback from the functionality of their (textual) programs. Yet, as summarized by Helminen and Malmi (2010), visualizations are widely used in programming education, eg in programming learning environments such as Scratch, Jeliot, BlueJ and GreenFoot, and programming microworlds such as Karel.", "num_citations": "4\n", "authors": ["928"]}
{"title": "Serverless automatic assessment of Javascript exercises.\n", "abstract": " Because of the web, JavaScript (JS) is one of the most popular programming languages today. Tools like GMail or Facebook are built heavily on JS. Despite the importance, JS is rarely in the core of programming courses. However, it still has a role in many courses [1, 2, 3]. In this paper, we introduce an open source tool to create small, automatically assessed JavaScript programming exercises (see Figure 1). Automatic assessment is based on unit tests, JSLint and various software metrics. Embedding an exercise into an existing web page only requires inserting the following or a similar HTML block:< form>< textarea id=\" jsassess-editor\">//initial code for students< div id=\" exerciseButtons\">< a href=\"#\" id=\" submitButton\"> Get feedback< div id=\" jsassess-feedback\">< script> exerciseOptions={\u2019jslint\u2019: true,\u2019tests\u2019:[\u2019sub_sum_qunit. html\u2019],\u2019commonspath\u2019:\u2019../javascript/\u2019}; In addition, teacher needs to provide unit tests for each new exercise. The fact that the assessment happens inside the student\u2019s own browser is the novelty of our work. Installation and sandboxing of a server are not required. This makes it easy to add exercises into any web page. The downside is that exercises are for self study purposes since grades submitted from a browser could be tampered with. Google Code Playground 1 and W3Schools interactive demonstrations 2 are similar to our system. However, these do not provide automatic assessment and are hard to integrate into other websites.", "num_citations": "4\n", "authors": ["928"]}
{"title": "Relation of Individual Time Management Practices and Time Management of Teams\n", "abstract": " Full research paper\u2014Team configuration, work practices, and communication have a considerable impact on the outcomes of student software projects. This study observes 150 college students who first individually solve exercises and then carry out a class project in teams of three. All projects had the same requirements. We analyzed how students\u2019 behavior on individual pre-project exercises predict team project outcomes, investigated how students\u2019 time management practices affected other team members, and analyzed how students divided their work among peers. Our results indicate that teams consisting of only low-performing students were the most dysfunctional in terms of workload balance, whereas teams with both low-and high-performing students performed almost as well as teams consisting of only high-performing students. This suggests that teams should combine students of varying skill levels\u00a0\u2026", "num_citations": "3\n", "authors": ["928"]}
{"title": "Taxonomizing features and methods for identifying at-risk students in computing courses\n", "abstract": " Since computing education began, we have sought to learn why students struggle in computer science and how to identify these at-risk students as early as possible. Due to the increasing availability of instrumented coding tools in introductory CS courses, the amount of direct observational data of student working patterns has increased significantly in the past decade, leading to a flurry of attempts to identify at-risk students using data mining techniques on code artifacts. The goal of this work is to produce a systematic literature review to describe the breadth of work being done on the identification of at-risk students in computing courses. In addition to the review itself, which will summarize key areas of work being completed in the field, we will present a taxonomy (based on data sources, methods, and contexts) to classify work in the area.", "num_citations": "3\n", "authors": ["928"]}
{"title": "Friends and gurus: Do students ask for help from those they know or those who would know\n", "abstract": " Collaboration is beneficial to learning, and in the software engineering it also prepares students to working methods used in the industry. Previous studies have found that students' friendships from before the course predict communication during courses. Moreover, how well a student is connected with peers is a good indicator of study success. In this study, we explore how much help seeking in team work is guided by previous social connections and to what extent students with best skills in the problem domain act as hubs of interaction. We studied group work in a university level Web software programming course. Based on log data and a questionnaire conducted at the end of the course, we found that while students knowing each other was the basis of group formation, within those groups students with higher measured knowledge were more likely to be asked for help. Student's exam score positively correlate\u00a0\u2026", "num_citations": "3\n", "authors": ["928"]}
{"title": "Dynamic software updating techniques in practice and educator's guides: a review\n", "abstract": " Patching a program during its execution without restarting is called dynamic software updating (DSU). DSU is well acknowledged in research, but rarely applied in practice as witnessed by constant need for reboots and restarts of both applications as well as operating systems. This raises the question of how well DSU related techniques are supported in education. In this paper, we review how the major software engineering and education guides acknowledge dynamic software updating techniques. Our analysis indicates that although DSU is not explicitly mentioned in the guides, the need is already well motivated and many DSU concepts are implicitly supported. Based on this, we argue that DSU could be introduced as an optional topic in software engineering studies.", "num_citations": "3\n", "authors": ["928"]}
{"title": "Does Using Structured Learning Diaries Affect Self-regulation or Study Engagement? An Experimental Study in Engineering Education\n", "abstract": " Previous research suggests that structured learning diaries can increase students\u2019 self-regulation skills. However, learning diaries also imply great effort for students, and more research is needed to understand the effect of diaries on students\u2019 motivation and engagement. In the current study, we investigate whether our approach of using curricular concept maps as structured learning diaries has an effect on students\u2019 self-regulation or study engagement. 104 first-year engineering master\u2019s students were randomly assigned to experimental and control groups. The structured learning diary using a digital tool was a compulsory weekly assignment for the experimental group. Both groups completed pre- and post-test questionnaires on self-regulation and study engagement. Using Repeated Measures ANOVA, we did not find statistically significant differences between the experimental and the control groups in self\u00a0\u2026", "num_citations": "2\n", "authors": ["928"]}
{"title": "Achievement goal orientation profiles and performance in a programming MOOC\n", "abstract": " It has been suggested that performance goals focused on appearing talented (appearance goals) and those focused on outperforming others (normative goals) have different consequences, for example, regarding performance. Accordingly, applying this distinction into appearance and normative goals alongside mastery goals, this study explores what kinds of achievement goal orientation profiles are identified among over 2000 students participating in an introductory programming MOOC. Using Two-Step cluster analysis, five distinct motivational profiles are identified. Course performance and demographics of students with different goal orientation profiles are mostly similar. Students with Combined Mastery and Performance Goals perform slightly better than students with Low Goals. The observations are largely in line with previous studies conducted in different contexts. The differentiation of appearance and\u00a0\u2026", "num_citations": "2\n", "authors": ["928"]}
{"title": "Teaching Container-Based DevOps Practices\n", "abstract": " We present the design of a online course that focuses on container-based virtualization as part of the DevOps toolchain. In addition, we outline the professional background of participants taking the course, and describe how this affects perceived previous knowledge of DevOps. We found out that the self-evaluated conceptual understanding of DevOps topics is nearly equal regardless of the participants professional identity (e.g., student or developer). However, there are significant differences in how much participants have used tools like Docker before. We conclude that there is a clear need for lifelong learning among software engineering professionals as (future) developers often struggle in operations related skills such as command line or networking.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Code reviews, software inspections, and code walkthroughs: Systematic mapping study of research topics\n", "abstract": " Code reviews have been used to improve code quality since the 1970s. Most practitioners in the field of software have some experience with respect to the technique. In this mapping study we illustrate what kinds of research questions are addressed in code review literature. The following themes emerged from analysis of 75 original articles: (1)\u00a0description or comparison of different code review practices, (2) behavior of reviewers (e.g., eye tracking studies), (3) communication and teamwork, (4) outcomes of code reviews (e.g., what kinds of problems are identified), (5) how properties of code to be reviewed affect reviewing, and (6) reasons for conducting code reviews. About half of the studies have been conducted with students and novices. The numbers of industry papers has significantly increased when compared to the previous reviews in the field.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Criterion-based grading, agile goal setting, and course (un) completion strategies\n", "abstract": " When teaching large groups of students with heterogeneous backgrounds and different learning goals, it is essential to personalize the learning experience. In this chapter, we describe how we have implemented this in a university-wide introductory programming course. Each student sets a personal target grade, i.e., the grade they aim at, based on how deep an understanding of programming they need (depending on their major subject, etc.) and on how much effort they are willing to invest in the course. To enable such setup, course assignments are divided into different levels and the grading directs the students in choosing which assignments to work on to meet the goals they have set. Furthermore, the students can change their target grade during the course in an agile manner.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Oppimisanalytiikka digitaalisessa ympa\u0308risto\u0308ssa\u0308\n", "abstract": " Oppimisanalytiikal-la tarkoitetaan op-pimiseen liittyv\u00e4n tiedon mittaamista, tallentamista, analysointia ja analyysitulosten hy\u00f6dynt\u00e4mist\u00e4. Oppimista on analysoitu vuosituhansia ja opetustakin jo hyv\u00e4 tovi, joten aihe ei ehk\u00e4 kuulosta tuoreelta. Oppimisymp\u00e4rist\u00f6jen digitalisaatio on kuitenkin mahdollistanut suurten, alati kasvavien tietomassojen automaattisen ker\u00e4\u00e4misen ja luonut n\u00e4in pohjan modernin oppimisanalytiikan voimakkaalle kasvulle.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Hammer and Nails-Crucial Practices and Tools in Ad Hoc Student Teams\n", "abstract": " We have observed students teams on a software engineering project course to understand what software engineering practices they end up using and how do they experience the usefulness of the selected practices and tools. In our context, the most often applied practices and tools were planning meeting, commitment to using tasks, self-selected communication tools, a revision control, and project management systems. We found out that student valued various face-to-face activities the most - even more than they were able to practice them. Finally, the wide variety of communication tools students take even from their leisure time and apply in the course setting surprised us.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Notes on eye tracking in programming education\n", "abstract": " Eye tracking is an interesting approach to trace how programmers read source code. Although it is relatively straightforward to find out where a programmer focus his or her eyes and how focus travels, interpreting this is much more difficult. Why a programmer looks at something and why his eyes move to something else? In this report, I describe my interpretations of two short eye traces where experienced programmers have read a short Java program to find out what it does. I briefly discuss potential pitfalls of interpreting eye tracking data and possible avenues of future research.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Initial Set of Services for Algorithm Visualization\n", "abstract": " When considering algorithm visualization (AV) systems, there are parts of the software that each system implement separately, but with ultimately the same functionality. Examples of this include graph drawing (ie calculating positions of nodes for a graph to draw it esthetically) and hypertext integration. Pop-up questions are another common feature and R\u00f6\u00dfling and H\u00e4ussage (2004) have actually implemented a tool-independent Java library to answer this need. In addition, R\u00f6\u00dfling (2009) has introduced design patterns for implementing some common features.The benefits of service oriented architectures include the reuse of components, ease of exposing and integrating legacy systems as services, loose coupling of components, and more rapid development of new systems by service composition. We feel that since most of the AV systems work online nowadays, it would make sense to provide the common parts of AV software as web services.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Automatic assessment of javascript exercises\n", "abstract": " In this paper, we present js-assess online playground for automatically assessed JavaScript programming exercises. We show how such automatic assessment systems can be implemented on top of JavaScript tools already used by the software industry. Furthermore, we demonstrate how automatically assessed assignments can be easily embedded to any web page without a server, as assessment runs inside the browser\u2019s JavaScript engine.", "num_citations": "2\n", "authors": ["928"]}
{"title": "Deadlines and MOOCs: How Do Students Behave in MOOCs with and without Deadlines\n", "abstract": " Full research paper\u2014Online education can be delivered in many ways. For example, some MOOCs let students to proceed with their own pace, while others rely on strict schedules. Although the variety of how MOOCs can be organized is generally well understood, less is known about how the different ways of organizing MOOCs affect retention. In this work, we compare self-paced and fixed-schedule MOOCs in terms of retention and work-load. Using data from over 8.000 students participating in two versions of a massive open online course in programming, we observe that drop-out rates at the beginning of the courses are greater than towards the end of the courses, with self-paced MOOC being more extreme in this respect. Mostly because of different starts, the fixed-schedule course has a better overall retention rate (45%) than its self-paced counterpart (13%). We hypothesize that students initial investment of\u00a0\u2026", "num_citations": "1\n", "authors": ["928"]}
{"title": "An Exploration of Cognitive Shifting in Writing Code\n", "abstract": " Programming is considered a demanding task that requires focusing on detail at code level. Students learning to program need to learn to think like a programmer, which involves coming up with plans needed to solve problems, and they need to learn to write the code that corresponds to the plans that they have thought of. The use of multiple files creates additional overhead to the process, as part of the code is not visible to the student. If a student does not remember the contents of a particular file, she needs to consciously move from writing code in one file to reading code in another file. This conscious transition of attention from one location to another is known as cognitive shifting. Using key-level data collected from a programming exam, we analyze students' movements within files and between files, and relate these movements with students' performance in the course. Our results indicate that frequently moving\u00a0\u2026", "num_citations": "1\n", "authors": ["928"]}