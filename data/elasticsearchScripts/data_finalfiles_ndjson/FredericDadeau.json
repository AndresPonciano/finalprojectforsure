{"title": "Mutation-based test generation from security protocols in HLPSL\n", "abstract": " In the recent years, important efforts have been made for offering a dedicated language for modelling and verifying security protocols. Outcome of the European project AVISPA, the High-Level Security Protocol Language (HLPSL) aims at providing a means for verifying usual security properties (such as data secrecy) in message exchanges between agents. Nevertheless, verifying the security protocol model does not guarantee that the actual implementation of the protocol will fulfil these properties. We propose in this paper a testing technique that makes it possible to validate an implementation of a security protocol, based on a HLPSL model. We introduce a set of mutation operators for HLPSL models that aim at introducing leaks in the security protocols. The mutated models are then analysed by the AVISPA tool set that will produce counter-example traces leading to the leaks, thus providing the test cases. We\u00a0\u2026", "num_citations": "46\n", "authors": ["2028"]}
{"title": "Symbolic animation of JML specifications\n", "abstract": " This paper presents a model-based framework for the symbolic animation of object-oriented specifications. A customized set-theoretic solver is used to simulate the execution of the system and handle constraints on state variables. We define a framework for animating object-oriented specifications with dynamic object creations, interactions and inheritance. We show how this technique can be applied to Java Modeling Language (JML) specifications, making it possible to animate Java programs that only contain method interfaces and no code!", "num_citations": "43\n", "authors": ["2028"]}
{"title": "Automated boundary test generation from JML specifications\n", "abstract": " We present an original approach for the automated computation of model-based test cases from specifications written in Java Modeling Language (JML). We aim at activating all the behaviors from the JML method specifications. Therefore, we extract each behavior and we compute the pertinent test data for the input parameters; we select the boundary values of the ordered domains, and we consider specific features for the objects, involving inheritance and aliasing. Finally, a preamble for each test case is computed by symbolic animation of the JML specification using constraint logic programming techniques. Thus, we are able to automatically generate executable Java test sequences to be run on the system under test. Moreover, this process requires the less possible intervention from a validation engineer.", "num_citations": "37\n", "authors": ["2028"]}
{"title": "Checking JML specifications with B machines\n", "abstract": " This paper presents a solution to the lack of tool-support for the JML models verification. We propose an approach for expressing JML specifications within the B abstract machines notation. The B machines generated from the JML can then be checked to ensure their correctness. Thus, we deduce the correctness of the original JML specification, ensured by rewriting rules which give the semantical equivalence of the two models. More generally, this translation can be applied to object-oriented specification languages using before-after predicates.", "num_citations": "25\n", "authors": ["2028"]}
{"title": "Selective test generation method for evolving critical systems\n", "abstract": " We present in this paper the implementation of a model-based testing technique for evolving systems. These latters are described in UML using class/object diagrams and state charts, augmented with OCL constraints. Based on two versions of a given model, an automated process deduces the impact of model evolutions on the existing tests. Our methodology then classifies tests into different test suites to test evolution, regression, stagnation and deletion on the concrete system. We introduce the notion of tests and test suites life cycles that help defining the purpose of each test at a given step of the system evolution, and thus, their classification in different test suites. The approach is illustrated on a realistic case study, and the improvements w.r.t. other regression testing techniques are discussed.", "num_citations": "24\n", "authors": ["2028"]}
{"title": "Mastering combinatorial explosion with the tobias-2 test generator\n", "abstract": " This paper briefly describes the second version of the Tobias combinatorial test generator. This version improves the architecture of the tool to include filtering and test selection mechanisms. These mechanisms, associated with an efficient implementation, allow to generate and filter test suites of up to 1 million test cases.", "num_citations": "23\n", "authors": ["2028"]}
{"title": "JML-testing-tools: A symbolic animator for JML specifications using CLP\n", "abstract": " This paper describes a tool for symbolically animating JML specifications using Constraint Logic Programming. A customized solver handles constraints that represent the value of instance fields. We have extended a model-based approach to be able to handle object-oriented specifications. Our tool is also able to check properties during the simulation and exhibit counter-examples for false properties. Therefore, it can be used both for semi-automated verification and for validation purposes.", "num_citations": "23\n", "authors": ["2028"]}
{"title": "Proving and debugging set-based specifications\n", "abstract": " We present a technique to prove invariants of model-based specifications in a fragment of set theory. Proof obligations containing set theory constructs are translated to first-order logic with equality augmented with (an extension of) the theory of arrays with extensionality. The idea underlying the translation is that sets are represented by their characteristic function which, in turn, is encoded by an array of Booleans indexed on the elements of the set. A theorem proving procedure automating the verification of the proof obligations obtained by the translation is described. Furthermore, we discuss how a sub-formula can be extracted from a failed proof attempt and used by a model finder to build a counter-example. To be concrete, we use a B specification of a simple process scheduler on which we illustrate our technique.", "num_citations": "20\n", "authors": ["2028"]}
{"title": "jSynoPSys\u2013a scenario-based testing tool based on the symbolic animation of B machines\n", "abstract": " This paper presents the jSynoPSys tool that implements the concept of Scenario-Based Testing from B machines. This consists in describing execution scenarios, expressed as regular expressions over the operations of the system, coupled with intermediate system states that have to be reached when the scenario is unfolded. The tool relies on the BZ-Testing-Tools engine, originally designed to perform symbolic animation and boundary test generation from B machines. The main advantage of our Scenario-Based Testing technique is that it performs a full abstraction of the operation parameter values, that are instantiated at the end, when the scenario has been completely unfolded, using constraint solving techniques.", "num_citations": "19\n", "authors": ["2028"]}
{"title": "A compositional automata-based semantics for property patterns\n", "abstract": " Dwyer et al. define a language to specify dynamic properties based on predefined patterns and scopes. To define a property, the user has to choose a pattern and a scope among a limited number of them. Dwyer et al. define the semantics of these properties by translating each composition of a pattern and a scope into usual temporal logics (LTL, CTL, etc.). First, this translational semantics is not compositional and thus not easily extensible to other patterns/scopes. Second, it is not always faithful to the natural semantics of the informal definitions.                 In this paper, we propose a compositional automata-based approach defining the semantics of each pattern and each scope by an automaton. Then, we propose a composition operation in such a way that the property semantics is defined by composing the automata. Hence, the semantics is compositional and easily extensible as we show it by handling\u00a0\u2026", "num_citations": "17\n", "authors": ["2028"]}
{"title": "Safety Property Driven Test Generation from JML Specifications\n", "abstract": " This paper describes the automated generation of test sequences derived from a JML specification and a safety property written in an ad hoc language, named JTPL. The functional JML model is animated to build the test sequences w.r.t. the safety properties, which represent the test targets. From these properties, we derive strategies that are used to guide the symbolic animation. Moreover, additional JML annotations reinforce the oracle in order to guarantee that the safety properties are not violated during the execution of the test suite. Finally, we illustrate this approach on an industrial JavaCard case study.", "num_citations": "17\n", "authors": ["2028"]}
{"title": "Praspel: A specification language for contract-based testing in php\n", "abstract": " We introduce in this paper a new specification language named Praspel, for PHP Realistic Annotation and SPEcification Language. This language is based on the Design-by-Contract paradigm. Praspel clauses annotate methods of a PHP class in order to both specify their contracts, using pre- and postconditions, and assign realistic domains to the method parameters. A realistic domains describes a set of concrete, and hopefully relevant, values that can be assigned to the data of a program (class attributes and method parameters). Praspel is implemented into a unit test generator for PHP that offers a random test data generator, which computes test data, coupled with a runtime assertion checker, which decides whether a test passes or fails by checking the satisfaction of the contracts at run-time.", "num_citations": "15\n", "authors": ["2028"]}
{"title": "Combining scenario-and model-based testing to ensure posix compliance\n", "abstract": " We present in this paper a way to produce test suites for the POSIX mini-challenge, based on a formal model of a file system manager, written using a B machine. By this case study, we illustrate the limitations of a fully-automated testing process, which justifies the use of scenarios that complements the classical functional testing approach. Scenarios are expressed through schemas, focusing only on operation chaining. They are played on the model using a symbolic animation engine in order to automatically compute pertinent operation parameter values, based on model coverage criteria such as behavioral or data coverage. We concretize our experimentation by testing the POSIX conformance of two different file systems: a recent Linux distribution, and a customized Java implementation of POSIX used to evaluate the relevance of our approach.", "num_citations": "14\n", "authors": ["2028"]}
{"title": "Model\u2010based mutation testing from security protocols in HLPSL\n", "abstract": " In recent years, important efforts have been made for offering a dedicated language for modelling and verifying security protocols. Outcome of the European project AVISPA, the high\u2010level security protocol language (HLPSL) aims at providing a means for verifying usual security properties (such as data secrecy) in message exchanges between agents. However, verifying the security protocol model does not guarantee that the actual implementation of the protocol will fulfil these properties. This article presents a model\u2010based testing approach, relying on the mutation of HLPSL models to generate abstract test cases. The proposed mutations aim at introducing leaks in the security protocols and represent real\u2010world implementation errors. The mutated models are then analysed by the automated validation of Internet security protocols and applications tool set, which produces, when the mutant protocol is declared\u00a0\u2026", "num_citations": "13\n", "authors": ["2028"]}
{"title": "Measuring test properties coverage for evaluating UML/OCL model-based tests\n", "abstract": " We propose in the paper a test property specification language, dedicated to UML/OCL models. This language is intended to express temporal properties on the executions of the system, that one wants to test. It is based on patterns, specifying the behaviours one wants to exhibit/avoid, and scopes, defining the piece of execution trace on which a given pattern applies. Each property is a combination of a scope and a pattern, providing a means for a validation engineer to easily express temporal properties on a system, without using complex formal notations. Properties have the semantics of an event-based transition system whose coverage can be measured so as to evaluate the relevance of a given test suite. These principles aim at being used in the context of a research project, in which the security properties are expressed on an industrial case study of a smart card operating system. This approach\u00a0\u2026", "num_citations": "13\n", "authors": ["2028"]}
{"title": "Directed random reduction of combinatorial test suites\n", "abstract": " Combinatorial testing consists in generating (possibly large) test suites by combining both the sequencing of several operations, and the selection of test data. The TOBIAS tool is based on this generation technique. The combinatorial part of the approach makes both its strength and its weakness. Indeed, the more tests are produced, the more confidence the user may have in his/her program. Nevertheless, simple patterns may result in millions of test cases due to the combinatorial explosion problem, leading to intractable testsuites. To overcome this weakness, TOBIAS makes it possible to connect the generator to\" selectors\" that choose a subset of the test suite based on various techniques or criteria.", "num_citations": "13\n", "authors": ["2028"]}
{"title": "EWET: Data collection and interface for the genetic analysis of Echinococcus multilocularis based on EmsB microsatellite\n", "abstract": " Evolution and dispersion history on Earth of organisms can best be studied through biological markers in molecular epidemiological studies. The biological diversity of the cestode Echinococcus multilocularis was investigated in different cladistic approaches. First the morphological aspects were explored in connection with its ecology. More recently, molecular aspects were investigated to better understand the nature of the variations observed among isolates. The study of the tandemly repeated multilocus microsatellite EmsB allowed us to attain a high genetic diversity level where other classic markers have failed. Since 2006, EmsB data have been collected on specimens from various endemic foci of the parasite in Europe (in historic and newly endemic areas), Asia (China, Japan and Kyrgyzstan), and North America (Canada and Alaska). Biological data on the isolates and metadata were also recorded (e.g. host, geographical location, EmsB analysis, citation in the literature). In order to make available the data set of 1,166 isolates from classic and aberrant domestic and wild animal hosts (larval lesions and adult worms) and from human origin, an open web access interface, developed in PHP, and connected to a PostgreSQL database, was developed in the EmsB Website for the Echinococcus Typing (EWET) project. It allows researchers to access data collection, perform genetic analyses online (e.g. defining the genetic distance between their own samples and the samples in the database), consult distribution maps of EmsB profiles, and record and share their new EmsB genotyping data. In order to standardize the EmsB analyses performed\u00a0\u2026", "num_citations": "12\n", "authors": ["2028"]}
{"title": "A compositional automata-based semantics and preserving transformation rules for testing property patterns\n", "abstract": " Dwyer et\u00a0al. provide a language to specify dynamic properties based on a limited number of predefined patterns and scopes. The semantics of these properties is defined by translating each combination of a pattern and a scope into usual temporal logics (linear temporal logic, CTL, etc.). This translational semantics suffers from two main issues. It is not easily extensible to other patterns or scopes, and it is not always faithful to the natural semantics. In this article, we propose a compositional automata-based approach defining the semantics of each pattern and each scope by an automaton, after which the semantics is composed. Hence, the semantics is compositional and the language is easily extensible. We compare the two semantics by model checking. In some cases, our semantics reveals a lack of homogeneity within Dwyer et\u00a0al.\u2019s semantics. Finally, we apply this approach in the context of property\u00a0\u2026", "num_citations": "12\n", "authors": ["2028"]}
{"title": "Constraint-based software testing\n", "abstract": " Constraint-Based Testing (CBT) is the process of generating test cases from programs or models by using the Constraint Programming technology. Recently, this method received much attention due to several Research projects launched in France and abroad. This paper aims at presenting the main CBT tools developped by four Research labs: CEA Laboratoire de S\u00fbret\u00e9 des Logiciels, INRIA Lande research team, Laboratoire d\u2019Informatique de Franche-Comt\u00e9, and CeP team of", "num_citations": "12\n", "authors": ["2028"]}
{"title": "Efficient detection of multi-step cross-site scripting vulnerabilities\n", "abstract": " Cross-Site Scripting (XSS) vulnerability is one of the most critical breaches that may compromise the security of Web applications. Reflected XSS is usually easy to detect as the attack vector is immediately executed, and classical Web application scanners are commonly efficient to detect it. However, they are less efficient to discover multi-step XSS, which requires behavioral knowledge to be detected. In this paper, we propose a Pattern-driven and Model-based Vulnerability Testing approach (PMVT) to improve the capability of multi-step XSS detection. This approach relies on generic vulnerability test patterns, which are applied on a behavioral model of the application under test, in order to generate vulnerability test cases. A toolchain, adapted from an existing Model-Based Testing tool, has been developed to implement this approach. This prototype has been experimented and validated on real-life Web\u00a0\u2026", "num_citations": "11\n", "authors": ["2028"]}
{"title": "Test Generation and Evaluation from High-Level Properties for Common Criteria Evaluations--The TASCCC Testing Tool\n", "abstract": " In this paper, we present a model-based testing tool resulting from a research project, named TASCCC. This tool is a complete tool chain dedicated to property-based testing in UML/OCL, that integrates various technologies inside a dedicated Eclipse plug-in. The test properties are expressed in a dedicated language based on property patterns. These properties are then used for two purposes. First, they can be employed to evaluate the relevance of a test suite according to specific coverage criteria. Second, it is possible to generate test scenarios that will illustrate or exercise the property. These test scenarios are then unfolded and animated on the Smartesting's Certify It model animator, that is used to filter out infeasible sequences. This tool has been used in industrial partnership, aiming at providing an assistance for Common Criteria evaluations, especially by providing test generation reports used to show the\u00a0\u2026", "num_citations": "11\n", "authors": ["2028"]}
{"title": "JML2B: Checking JML specifications with B machines\n", "abstract": " This paper introduces a tool, named JML2B, destined to check the consistency of JML specifications. JML2B is a solution to the lack of tool-support for the JML models verification. Our tool translates JML specifications into the B abstract machines notation. The generated B machines can then be checked to ensure their correctness. When the proof fails, it is possible to retrieve the mistakes in the original JML specification.", "num_citations": "11\n", "authors": ["2028"]}
{"title": "Instantiation of parameterized data structures for model-based testing\n", "abstract": " Model-based testing is bound, by essence, to use the enumerated data structures of the system under test (SUT). On the other hand, formal modeling often involves the use of parameterized data structures in order to be more general (such a model should be sufficient to test many implementation variants) and to abstract irrelevant details. Consequently, the validation engineer is sooner or later required to instantiate these parameters. At the current time, this instantiation activity is a matter of experience and knowledge of the SUT. This work investigates how to rationalize the instantiation of the model parameters.               It is obvious that a poor instantiation may badly influence the quality of the resulting tests. However, recent results in instantiation-based theorem proving and their application to software verification show that it is often possible to guess the smallest most general data enumeration. We first\u00a0\u2026", "num_citations": "11\n", "authors": ["2028"]}
{"title": "Grammar-based testing using realistic domains in PHP\n", "abstract": " This paper presents an integration of grammar-based testing in a framework for contract-based testing in PHP. It relies on the notion of \\gtypes, that make it possible to assign domains to data, by means of contract assertions written inside the source code of a PHP application. Then a test generation tool uses the contracts to generate relevant test data for unit testing. Finally a runtime assertion checker validates the assertions inside the contracts (among others membership of data to \\gtypes) to establish the conformance verdict. We introduce here the possibility to generate and validate complex textual data specified by a grammar written in a dedicated grammar description language. This approach is tool-supported and experimented on the validation of web applications.", "num_citations": "10\n", "authors": ["2028"]}
{"title": "Scenario-based testing from UML/OCL behavioral models\n", "abstract": " We present in this article a way to produce test suites applied to the POSIX mini-challenge based on a behavioral model of a file system manager written in UML/OCL. We illustrate the limitations of a fully automated test generation approach, which justifies the use of test scenarios as a complement to a functional testing approach. Scenarios are expressed through regular expressions describing sequences of operations, possibly punctuated by intermediate states that have to be reached by the execution of the model. Scenarios are unfolded into extended sequences of operations that are played on the model using symbolic animation techniques. We experimented our approach by testing the conformance of two different file systems w.r.t. the POSIX standard: a recent Linux distribution and a customized Java implementation of POSIX used to evaluate the relevance of our approach and its complementarity\u00a0\u2026", "num_citations": "10\n", "authors": ["2028"]}
{"title": "AB formal framework for security developments in the domain of smart card applications\n", "abstract": " We propose in this paper a formal framework based on the B method, that supports the development of secured smart card applications. Accordingly to the Common Criteria methodology, we focus on the formal definition and modelling of access control policies by means of dedicated B models expressing, on one hand, the access control rules, and, on the other hand, the dynamics of the system. These models are then weaved to produce a security kernel. From there, we propose a conformance relationship that aims at establishing whether a concrete representation of the system complies, at the security level, with the security kernel. This embraces both a well-defined notion of security conformance as well as traceability allowing to relate basic events appearing at the level of applications with abstract security policies. This approach is put in practice on an industrial case study in the context of the POS\u00e9\u00a0\u2026", "num_citations": "10\n", "authors": ["2028"]}
{"title": "Coverage criteria for model-based testing using property patterns\n", "abstract": " We present in this paper a model-based testing approach aiming at generating test cases from a UML/OCL model and a given test property. The property is expressed using a dedicated formalism based on patterns, and automatically translated into an automaton. We propose new automata coverage criteria that are tailored to the property automata we consider. These criteria are based on the coverage of a relevant subset of the transitions related to the original property, aiming at producing test cases that illustrate the dynamics of the system described in the property. In addition, we propose to produce test cases that can ensure the robustness of the system w.r.t. the property, by mutating the property automaton, in order to try to provoke events that would be forbidden by the property. This approach has been implemented into a large tool set and it has been experimented on realistic case studies, in the context of industrial research projects.", "num_citations": "9\n", "authors": ["2028"]}
{"title": "Model-based filtering of combinatorial test suites\n", "abstract": " Tobias is a combinatorial test generation tool which can efficiently generate a large number of test cases by unfolding a test pattern and computing all combinations of parameters. In this paper, we first propose a model-based testing approach where Tobias test cases are first run on an executable UML/OCL specification. This animation of test cases on a model allows to filter out invalid test sequences produced by blind enumeration, typically the ones which violate the pre-conditions of operations, and to provide an oracle for the valid ones. We then introduce recent extensions of the Tobias tool which support an incremental unfolding and filtering process, and its associated toolset. This allows to address explosive test patterns featuring a large number of invalid test cases, and only a small number of valid ones. For instance, these new constructs could mandate test cases to satisfy a given predicate at some\u00a0\u2026", "num_citations": "7\n", "authors": ["2028"]}
{"title": "Automated UML models merging for web services testing\n", "abstract": " This paper presents a method for merging Unified Modelling Language (UML) models, which takes place in a quality evaluation framework for Web Services (WSs). This framework, called iTac Tests and Certified Quality of Services (iTac-QoS), is an extended Universal Description Discovery and Integration (UDDI) server using model-based testing to assess quality. Depending on the results of the test execution, a mark is given to the WSs. Until now, our framework was limited to WSs without composition. This was justified by the fact that it is impossible for vendors to create a good model of a foreign product. Our method proposes to automatically merge the models (produced by each vendor) of the WSs involved in the composition. For each type of diagram present in the models (class, instance or statechart diagram), a method is proposed to produce a unique model. In addition to this, a solution is proposed to\u00a0\u2026", "num_citations": "7\n", "authors": ["2028"]}
{"title": "Model-based vulnerability testing of payment protocol implementations\n", "abstract": " We investigate an approach to automate model-based vulnerability testing of payment protocols used by e-commerce applications. We aim to improve the efficiency and performance of logical vulnerability testing. The proposed approach is based on a formal specification of the protocol implementation (SUT) and vulnerability attack scenario exploitation for driving the test execution. This approach is illustrated with a use case example bookshop application and one of the most used payment protocols: PayPal Express.", "num_citations": "6\n", "authors": ["2028"]}
{"title": "Grey-box testing and verification of Java/JML\n", "abstract": " We present in this paper the application of constraint solving techniques to the validation and automated test cases generation for Java programs, annotated with JML specifications. The Java/JML code is translated into a constraint representation based on a subset of the set-theory, which is well-suited for modelling object-oriented programs. Symbolic code execution techniques can then be applied to produce test cases, using classical structural test selection criteria, or to detect possible runtime errors, and non-conformances between the Java code and its embedded JML model.", "num_citations": "6\n", "authors": ["2028"]}
{"title": "\u00c9valuation symbolique \u00e0 contraintes pour la validation-Application \u00e0 Java/JML\n", "abstract": " Mes travaux de th\u00e8se s' articulaient autour de la validation de mod\u00e8les et de programmes. En ce sens, les mod\u00e8les sont valid\u00e9s par animation, de mani\u00e8re \u00e0 s' assurer qu'ils d\u00e9crivent le bon comportement du syst\u00e8me qu'ils repr\u00e9sentent. Il s' agit d'un processus semi-automatique, car l'utilisateur s\u00e9lectionne les actions du syst\u00e8me \u00e0 ex\u00e9cuter et effectue la comparaison entre les descriptions informelles donn\u00e9es dans le cahier des charges et les r\u00e9sultats produits par le mod\u00e8le. Un mod\u00e8le valid\u00e9 est ensuite utilis\u00e9 dans l'objectif de produire des cas de tests fonctionnels destin\u00e9s \u00e0 \u00eatre jou\u00e9s sur une implantation ou un syst\u00e8me sous test. Le mod\u00e8le formel est ainsi utilis\u00e9 \u00e0 deux niveaux: d'une part, il permet de calculer de mani\u00e8re automatique les suites de tests, et, d'autre part, il sert d'oracle pour \u00e9tablir le verdict du test. Au cours de ces travaux, nous nous sommes int\u00e9ress\u00e9s \u00e0 la validation de programmes Java par l'interm\u00e9diaire de son langage de mod\u00e9lisation associ\u00e9, nomm\u00e9 JML. Suite aux exp\u00e9riences et aux savoirs-faire accumul\u00e9s au sein de l'\u00e9quipe Techniques Formelles et \u00e0 Contraintes du Laboratoire d'Informatique de Franche-Comt\u00e9, nous avons choisi d'appliquer une repr\u00e9sentation logico-ensembliste des mod\u00e8les JML, reposant sur des solveurs de contraintes pour g\u00e9rer les valeurs des variables des mod\u00e8les objets que nous traitons. A partir de cette repr\u00e9sentation symbolique, nous avons exprim\u00e9 l'animation symbolique d'un mod\u00e8le objet bas\u00e9 sur la s\u00e9mantique de Java, utilisant les descriptions formelles contenues dans les pr\u00e9-et postconditions des sp\u00e9cifications des m\u00e9thodes. Nous nous sommes ensuite appuy\u00e9s sur la d\u00e9finition\u00a0\u2026", "num_citations": "6\n", "authors": ["2028"]}
{"title": "Scenario\u2010based testing using symbolic animation of B models\n", "abstract": " This article presents a model\u2010based test generation technique, from user\u2010defined scenarios, for behavioral models expressed as B machines. Scenarios are expressed using a customized formalism, based on regular expressions, that makes it possible to describe sequences of operation calls possibly reaching specific states of the system. A symbolic animation engine, simulating the execution of a model using constraint logic programming, is then exploited to play the unfolded scenarios on the model and to instantiate the test cases, providing the expected results used to establish the conformance verdict. This approach is tool supported by a research prototype and has been successfully applied in an industrial context of a smart card applet. This tool is extended by a scenario generator, which automatically generates testing strategies for exercising user\u2010defined properties, written using specific patterns\u00a0\u2026", "num_citations": "5\n", "authors": ["2028"]}
{"title": "A verifiable conformance relationship between smart card applets and B security models\n", "abstract": " We propose a formal framework based on the B method, that supports the development of secured smart card applications. Accordingly to the Common Criteria methodology, we start from a formal definition and modelling of security policies, as access control policies. At the end of the development process, smart card applications are implemented in a standardized way, based on both the life cycle of smart card applets and the APDU protocol. In this paper, we define a conformance relationship that aims at establishing how smart card applications can be related to security requirement models. This embraces both the notions of security conformance as well as traceability allowing to relate basic events appearing at the level of applications with abstract security policies. This approach has been developed in the RNTL POS\u00c9 project, involving a smart card issuer, Gemalto.", "num_citations": "5\n", "authors": ["2028"]}
{"title": "Measuring a java test suite coverage using jml specifications\n", "abstract": " We propose in this paper a way to measure the coverage of a Java test suite by considering the JML specification associed to the Java program under test. This approach is based on extracting a predicate-based graph from the JML method specifications. We then measure the coverage of this latter w.r.t. nodes of the graph that are visited by the test suite. In addition, we propose to check whether the test suite satisfies classical condition coverage criteria. We also introduce a tool, to be used as precompiler for Java, that is in charge of measuring and reporting the coverage according to these criteria.", "num_citations": "5\n", "authors": ["2028"]}
{"title": "Temporal property patterns for model-based testing from UML/OCL\n", "abstract": " This article describes a new property- and model-based testing approach using UML/OCL models, driven by temporal property patterns and a tool for assisting the temporal properties formalization. The patterns are expressed in the TOCL language, an adaptation of Dwyer\u2019s property patterns to OCL. The patterns are used to formalize temporal requirements without having to learn a complex temporal logics such as LTL or CTL. From these properties, automata are automatically computed. These can be used for two purposes. First, it is possible to evaluate the quality of a test suite by measuring the coverage of a property using its associated automaton. Second, the automaton can be used to drive the test generation in order to produce complementary test cases. To this end, we defined dedicated coverage criteria, targeting specific events of the property, and aiming either at illustrating the expected\u00a0\u2026", "num_citations": "4\n", "authors": ["2028"]}
{"title": "Test Generation Using Symbolic Animation of Models.\n", "abstract": " In the domain of embedded systems, models are often used either to generate code, possibly after refinement steps, but they also provide a functional view of the modeled system that can be used to produce black-box test cases, without considering the actual details of implementation of this system. In this process, the tests are generated by appling given test selection criteria on the model. These test cases are then played on the system and the results obtained are compared with the results predicted by the model, in order to ensure the conformance between the concrete system and its abstract representation. Test selection criteria aim at achieving a reasonable coverage of the functionalities or requirements of the system, without involving a heavyweight human intervention. We present in this chapter work on the B notation to support model design, intermediate verification, and test generation. In B machines, the\u00a0\u2026", "num_citations": "4\n", "authors": ["2028"]}
{"title": "Model-based testing using symbolic animation and machine learning\n", "abstract": " We present in this paper a technique based on symbolic animation of models that aims at producing model-based tests. In order to guide the animation of the model, we rely on the use of a deterministic finite automaton (DFA) of the model that is built using a well-known machine learning algorithm, that considers a complex model as a black-box component, whose behavior is inferred. Since the DFA obtained in this way may be an over-approximation and, thus, admit traces that were not admitted on the original model, this abstraction is refined using counter-examples made of unfeasible traces. The computation of counter-examples is performed using a systematic coverage of the DFA states and transitions, producing test sequences that are replayed on the model, providing either test cases for offline testing, or counter-examples that aim at refining the abstraction.", "num_citations": "4\n", "authors": ["2028"]}
{"title": "On the use of uniform random generation of automata for testing\n", "abstract": " Developing efficient and automatic testing techniques is one of the major challenges facing software validation community. In this paper, we show how a uniform random generation process of finite automata, developed in a recent work by Bassino and Nicaud, is relevant for many faces of automatic testing. The main contribution is to show how to combine two major testing approaches: model-based testing and random testing. This leads to a new testing technique successfully experimented on a realistic case study. We also illustrate how the power of random testing, applied on a Chinese Postman Problem implementation, points out an error in a well-known algorithm. Finally, we provide some statistics on model-based testing algorithms.", "num_citations": "4\n", "authors": ["2028"]}
{"title": "Teaching Model-Based Testing with {L} eirios {T} est {G} enerator\n", "abstract": " This paper proposes a technique to encourage the interest of students in learning formal methods. Our course is focused on the B method, involving basic knowledge of set theory, invariance proofs, refinement techniques and so on. While lectures and tutorials cover a large range of such concepts, the practical work is focused on applying the principles of a model-based approach in the context of test generation. This paper explains the pratical outcome of the course, through the Leirios Test Generator tool, that gives an interesting and playful use of the B method, by simulating the execution of the model through animation, and by generating tests \u2013based on the B model\u2013 that can be run on an implementation. In order to make sure that students will be interested in applying these techniques, we challenge them to play a game consisting in detecting mutants of a program with their model-based tests. The feedback from the students is very positive here, and suggests that formal methods are more likely to be understood if their interest is shown through a concrete application.", "num_citations": "4\n", "authors": ["2028"]}
{"title": "How symbolic animation can help designing an efficient formal model\n", "abstract": " This paper presents a non-conventional application of symbolic animation. We propose to assist the modeller in building an efficient formal model, by automatically detecting potential weaknesses or imprecisions in the model. We propose to detect inconsistencies within the formal models written with pre- and postconditions, and to point out unusual model properties, such as a weak invariant or unreachable effects. Our approach is based on constraint solving technologies to perform the animation and to detect the various problems.", "num_citations": "4\n", "authors": ["2028"]}
{"title": "Identifying and generating missing tests using machine learning on execution traces\n", "abstract": " Testing IT systems has become a major bottleneck for many companies. Besides the growing complexity of such systems, shorter release cycles and increasing quality requirements have led to increased verification and validation costs. However, analysis of existing testing procedures reveals that not all artifacts are exploited to tame this cost increase. In particular, customer traces are usually ignored by validation engineers. In this paper, we use machine learning from execution traces (both customer traces and test execution traces) to identify test needs and to generate new tests in the context of web services and API testing. Log files of customer traces are split into smaller traces (user sessions) then encoded into Pandas DataFrames for data analysis and machine learning. Clustering algorithms are used to analyse the customer traces and compare them with existing system tests, and machine learning models\u00a0\u2026", "num_citations": "3\n", "authors": ["2028"]}
{"title": "Test fonctionnel de conformit\u00e9 vis-\u00e0-vis d'une politique de cont\u00f4le d'acc\u00e8s\n", "abstract": " Les travaux pr\u00e9sent\u00e9s dans cet article s'articulent autour de la validation du contr\u00f4le d'acc\u00e8s d\u00e9fini par des politiques de s\u00e9curit\u00e9. Nous nous int\u00e9ressons \u00e0 la validation par g\u00e9n\u00e9ration de tests \u00e0 partir d'un mod\u00e8le de s\u00e9curit\u00e9 \u00e9crit en B et d\u00e9crivant les fonctionnalit\u00e9s de l'application. Nous utilisons l'outil Meca, qui prend en entr\u00e9e un mod\u00e8le fonctionnel et une description d'une politique de s\u00e9curit\u00e9 sous la forme de machines abstraites B, et qui g\u00e9n\u00e8re un noyau de s\u00e9curit\u00e9 pour le mod\u00e8le fonctionnel. Ce noyau de s\u00e9curit\u00e9 est en charge d'intercepter tous les acc\u00e8s des sujets aux objets, et restreint les comportements \u00e0 ceux satisfaisant les exigences de s\u00e9curit\u00e9. Nous pr\u00e9sentons une \u00e9tude de cas compl\u00e8te sur une application de type porte-monnaie \u00e9lectronique, agr\u00e9ment\u00e9e d'une politique de s\u00e9curit\u00e9 discr\u00e9tionnaire.", "num_citations": "3\n", "authors": ["2028"]}
{"title": "Guiding the correction of parameterized specifications\n", "abstract": " Finding inductive invariants is a key issue in many domains such as program verification, model based testing, etc. However, few approaches help the designer in the task of writing a correct and meaningful model, where correction is used for consistency of the formal specification w.r.t. its inner invariant properties. Meaningfulness is obtained by providing many explicit views of the model, like animation, counter-example extraction, and so on. We propose to ease the task of writing a correct and meaningful formal specification by combining a panel of provers, a set-theoretical constraint solver and some model-checkers.", "num_citations": "3\n", "authors": ["2028"]}
{"title": "Complementary test selection criteria for model-based testing of security components\n", "abstract": " This article presents a successful industrial application of a model-based testing approach to the validation of security components. We present a smart combination of three test selection criteria applied to testing security requirements of components such as Hardware Security Modules. This combination relies on the use of static test selection criteria, namely structural model coverage, complemented by dynamic test selection criteria, based on abstract test scenarios or temporal properties, designed to target corner cases of security functional requirements. Our approach is implemented in an industrial and scalable MBT tool. We evaluated and successfully applied it on three real-world security components. The outcome of these experiences showed that the three test selection criteria target distinct kinds of errors in the software and are able to reveal inconsistencies in the specification. Moreover, a 5-year\u00a0\u2026", "num_citations": "2\n", "authors": ["2028"]}
{"title": "Leirios test generator: from research to teaching, through industry\n", "abstract": " Once upon a time, at the far far away University of Franche-Comt\u00e9, existed a research prototype named BZ-Testing-Tools. This tool provided symbolic animation features and test generation from models written as B abstract machines. Based on the scientific and industrial success of the tool, a company had been created, named LEIRIOS Technologies. The BZ-Testing-Tools environment was transferred in the company and redesigned, giving birth to the LEIRIOS Test Generator (LTG). This tool is now being used in the industry by embedded software developers in order to assist them in the validation phase of their product. LTG is still used in the computer science department of the University of Franche-Comt\u00e9 for which it provides a tool support for the practical sessions of the software engineering courses. We illustrate the features of the tool and its use as a teaching environment for the B method on a concrete application of formal modelling. The main idea is that modelling for test generation is a motivating way to introduce formal methods. Teaching the complete application of a model-based test generation process is thus made possible by using the LTG tool. Our students are drawing a benefit from this experience and live happily everafter, using formal methods.", "num_citations": "2\n", "authors": ["2028"]}
{"title": "A case study in matching test and proof coverage\n", "abstract": " This paper studies the complementarity of test and deductive proof processes for Java programs specified in JML (Java Modeling Language). The proof of a program may be long and difficult, especially when automatic provers give up. When a theorem is not automatically proved, there are two possibilities: either the theorem is correct and there are not enough pieces of information to deal with the proof, or the theorem is incorrect. In order to discriminate between those two alternatives, testing techniques can be used. Here, we present experiments around the use of the JACK tool to prove Java programs annotated with JML assertions. When JACK fails to decide proof obligations, we use a combinatorial testing tool, TOBIAS, to produce large test suites that exercise the unproved program parts. The key issue is to establish the relevance of the test suite with respect to the unproved proof obligations. Therefore, we use\u00a0\u2026", "num_citations": "2\n", "authors": ["2028"]}
{"title": "Evaluation symbolique contraintes pour la validation\n", "abstract": " Je tiens en premier lieu remercier mes deux responsables, Bruno Legeard et Fabrice Bouquet, pour la direction qu\u2019ils ont su faire prendre cette th\u0141se, et les pr\u00d8cieux conseils distill\u00d8s durant ces ann\u00d8es. Une grand merci \u00d8galement aux rapporteurs, Christine Paulin-Mohring et Yves Ledru, qui ont montr\u00d8 l\u2019int\u00d8r\u0152t port\u00d8 mes travaux en acceptant cette lourde tche. Je n\u2019oublie pas non plus Bernard Botella pour ses comp\u00d8tences et son exp\u00d8-rience du monde industriel qui ont fait de lui un examinateur de marque. Pour nir, je remercie Jacques Julliand d\u2019avoir accept\u00d8 de se joindre au jury et d\u2019en avoir pris la place de Pr\u00d8sident.Je souhaite \u00d8galement remercier ici les membres du LIFC qui m\u2019ont accueilli bras ouverts, me faisant passer du statut d\u2019\u00d8tudiant celui de coll\u0141gue, en particulier: Jacques, Franoise, Olga (OK vainqueur par KO!), Alain et Isabelle. Je salue \u00d8galement mes acolytes du bureau 414: Pierre\u00a0\u2026", "num_citations": "2\n", "authors": ["2028"]}
{"title": "Using constraint logic programming for the symbolic animation of formal models\n", "abstract": " Inria - Using Constraint Logic Programming for the Symbolic Animation of Formal Models Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support HAL-Inria Les publications, logiciels... des scientifiques Inria Accueil D\u00e9poser Consulter tout HAL par date de publication/r\u00e9daction par domaine par type de publication par collection arXiv les derniers d\u00e9p\u00f4ts Publications Inria Recherche Services HalTools : cr\u00e9er sa page web Haltools : export RAWEB X2Hal : import par lot Consulter les structures de recherche connues de HAL Documentation Aide en ligne de HAL V3 Derni\u00e8res \u00e9volutions de HAL V3 Documentation API HAL Ajouter des vignettes Aide en ligne Haltools Aide en ligne de X2hal OpenAccess Inria \u2026", "num_citations": "2\n", "authors": ["2028"]}
{"title": "Online testing of dynamic reconfigurations wrt adaptation policies\n", "abstract": " Self-adaptation of complex systems is a very active domain of research with numerous application domains. Component systems are designed as sets of components that may reconfigure themselves according to adaptation policies, which describe needs for reconfiguration. In this context, an adaptation policy is designed as a set of rules that indicate, for a given set of configurations, which reconfiguration operations can be triggered, with fuzzy values representing their utility. The adaptation policy has to be faithfully implemented by the system, especially w.r.t. the utility occurring in the rules, which are generally specified for optimizing some extra-functional properties (e.g. minimizing resource consumption). In order to validate adaptive systems\u2019 behaviour, this paper presents a model-based testing approach, which aims to generate large test suites in order to measure the occurrences of reconfigurations and compare them to their utility values specified in the adaptation rules. This process is based on a usage model of the system used to stimulate the system and provoke reconfigurations. As the system may reconfigure dynamically, this online  test generator observes the system responses and evolution in order to decide the next appropriate test step to perform. As a result, the relative frequencies of the reconfigurations can be measured in order to determine whether the adaptation policy is faithfully implemented. To illustrate the approach the paper reports on experiments on the case study of platoons of autonomous vehicles.", "num_citations": "1\n", "authors": ["2028"]}
{"title": "Contract-based testing for PHP with Praspel\n", "abstract": " We summarize several contributions related to the PHP Realistic Annotation and SPEcification Language (Praspel). This language extends PHP programs with annotations for the formal specification of the behavior of their functions and for the declaration of types for their data. These contracts are used to automate test generation, by deriving test cases and test data, and test execution, by checking assertions at run-time in order to establish the test verdict. Our approach to contract-based testing for PHP is fully implemented into a PHP framework currently in use by several web companies.", "num_citations": "1\n", "authors": ["2028"]}
{"title": "Apprentissage de la programmation en cycle 2 avec un jeu vid\u00e9o collaboratif\n", "abstract": " Nous pr\u00e9sentons dans cet article un jeu vid\u00e9o destin\u00e9 \u00e0 l\u2019apprentissage collaboratif de la programmation, nomm\u00e9 Collabots. Ce jeu met en sc\u00e8ne des robots que deux joueurs doivent programmer pour atteindre un objectif. L\u2019originalit\u00e9 r\u00e9side dans le fait que le jeu se joue \u00e0 deux joueurs et n\u00e9cessite l\u2019interaction entre les robots de chaque joueur pour r\u00e9soudre les puzzles, obligeant les enfants \u00e0 communiquer entre eux pour synchroniser leurs actions. Nous proposons un protocole exp\u00e9rimental qui visera \u00e0 \u00e9valuer la pertinence de ce jeu pour l\u2019apprentissage de la programmation dans les classes de primaire.", "num_citations": "1\n", "authors": ["2028"]}
{"title": "A Model-Based Testing Approach for Security Protocols\n", "abstract": " This talk presents results recently published in Software Testing, Verification and Reliability. In recent years, important efforts have been made for offering a dedicated language for modelling and verifying/proving security protocols. However, verifying the security protocol model does not guarantee that the actual implementation of the protocol will fulfil these properties. In this talk we present a model-based testing approach, relying on the mutation of HLPSL - the specification language of the AVISPA tool - models to generate abstract test cases. The proposed mutations aim at introducing leaks in the security protocols and represent real-world implementation errors.", "num_citations": "1\n", "authors": ["2028"]}
{"title": "Mbeetle-un outil pour la generation de tests a-la-volee a l'aide de modeles\n", "abstract": " Le Model-Based Testing est une activit\u00e9 permettant, \u00e0 partir de la mod\u00e9lisation du syst\u00e8me sous test (SUT), de g\u00e9n\u00e9rer des tests pour la validation du SUT par rapport aux sp\u00e9cifications de ce syst\u00e8me. Cet article pr\u00e9sente MBeeTle, un outil de g\u00e9n\u00e9ration de test \u00e0-la-vol\u00e9e pour le MBT, ainsi que ses principes et ces strat\u00e9gies de g\u00e9n\u00e9ration. Il permet la recherche des anomalies profondes et la validation du mod\u00e8le de test en g\u00e9n\u00e9rant et ex\u00e9cutant des pas de test sur la base d'une approche al\u00e9atoire. MBeeTle est pr\u00e9sent\u00e9 avec une exp\u00e9rimentation sur la une norme d'interfaces utilisateurs et logicielles pour les syst\u00e8mes d'exploitation (POSIX).", "num_citations": "1\n", "authors": ["2028"]}
{"title": "Introduction du code informatique \u00e0 l'\u00e9cole primaire-retour d'exp\u00e9riences\n", "abstract": " L\u2019introduction du code informatique \u00e0 l\u2019\u00e9cole, d\u00e8s le cycle 3 (CM1, CM2, 6e) appara\u00eet dans les programmes scolaires de la rentr\u00e9e 2016. Nous nous sommes int\u00e9ress\u00e9s dans ce travail \u00e0 proposer des activit\u00e9s d\u2019initiation \u00e0 l\u2019informatique pour les \u00e9l\u00e8ves sous forme d\u2019activit\u00e9s de deux types. D\u2019une part, des activit\u00e9s dites d\u00e9connect\u00e9es, sur table avec du mat\u00e9riel p\u00e9dagogique, qui visent \u00e0 l\u2019apprentissage de concepts transverses, notamment ici la repr\u00e9sentation des donn\u00e9es (nombres et images). D\u2019autre part, des activit\u00e9s dites connect\u00e9es, effectu\u00e9es sur tablette ou ordinateur, et qui visent \u00e0 l\u2019apprentissage de l\u2019algorithmique. Ces activit\u00e9s ont \u00e9t\u00e9 exp\u00e9riment\u00e9es dans plusieurs classes de CM2 de la r\u00e9gion, et dans une classe d\u2019ULIS pour laquelle des adaptations ont d\u00fb \u00eatre mises en place. Les r\u00e9sultats montrent un retour tr\u00e8s positif des \u00e9l\u00e8ves et des professeurs qui ont appr\u00e9ci\u00e9 cet accompagnement pour la mise en place de cette discipline ainsi d\u00e9mystifi\u00e9e.", "num_citations": "1\n", "authors": ["2028"]}
{"title": "Constraints in Software Testing, Verification and Analysis CSTVA'2013\n", "abstract": " Recent years have seen an increasing interest in the application of constraint solving techniques to test, verify and analyze software systems. A significant body of constraint-based techniques has been proposed and investigated in the context of test input generation, model-based testing, symbolic execution, static analysis, program verification, and many other areas. These techniques use or extend constraint solvers such as SAT and SMT solvers to reason about boolean, integer, real and floating-point data types, as well as complex data structures, control structures, method calls and other program features. The constraint systems that result from this work usually share many common features and are relevant to a variety of application domains. Following a first meeting held with the Principles and Practice of Constraint Programming (CP) conference in 2006, and three subsequent meetings at the International\u00a0\u2026", "num_citations": "1\n", "authors": ["2028"]}
{"title": "G\u00e9n\u00e9ration automatique de tests \u00e0 partir de mod\u00e8les UML/ALF\n", "abstract": " Alors que la complexit\u00e9 des syst\u00e8mes informatis\u00e9s ne cesse de s\u2019 accro\u00eetre, leur part logicielle est de plus en plus cons\u00e9quente. De nombreuses catastrophes li\u00e9es au logiciel sont survenues par le pass\u00e9: le crash de la fus\u00e9e Ariane 5, le bogue de carte de cr\u00e9dit en Allemagne, etc... Pour emp\u00eacher ce genre de catastrophes, la communaut\u00e9 scientifique concentre ses efforts sur l\u2019am\u00e9lioration des techniques de pr\u00e9vention d\u2019erreurs. Une de ces techniques est la v\u00e9rification formelle: l\u2019objectif est d\u2019\u00e9tablir la preuve, \u00e0 l\u2019aide de logique math\u00e9matique, que le syst\u00e8me respecte un certain nombres de propri\u00e9t\u00e9s. Cependant, la v\u00e9rification formelle est extr\u00eamement co\u00fbteuse (en ressources humaines et mat\u00e9rielles), et n\u2019est justifiable que pour des syst\u00e8mes critiques (syst\u00e8mes de transport, syst\u00e8mes financiers, etc...). Une alternative \u00e0 la preuve de programme est le test: le but n\u2019est pas d\u2019ex\u00e9cuter un logiciel avec toutes les valeurs d\u2019entr\u00e9es possibles, mais plut\u00f4t d\u2019\u00e9lire certaines valeurs comme repr\u00e9sentants des diff\u00e9rents comportements du programme. L\u2019effort est moindre, et pour la plupart des syst\u00e8mes, la confiance obtenue suffisante.", "num_citations": "1\n", "authors": ["2028"]}
{"title": "AB Formal Framework for Security Developments in the Domain of Smart Card Applications\n", "abstract": " We propose in this paper a formal framework based on the B method, that supports the development of secured smart card applications.", "num_citations": "1\n", "authors": ["2028"]}
{"title": "A combination of model-based testing and random testing approaches using automata\n", "abstract": " Developing efficient and automatic testing techniques is one of the major challenges facing software validation community. In this paper, we show how a uniform random generation process of finite automata, developed in a recent work by Bassino and Nicaud, is relevant for many faces of automatic testing. The main contribution is to show how to combine two major testing approaches: model-based testing and random testing. This leads to a new testing technique successfully experimented on a realistic case study. We also illustrate how the power of random testing, applied on a Chinese Postman Problem implementation, points out an error in a well-known algorithm. Finally, we provide some statistics on model-based testing algorithms.", "num_citations": "1\n", "authors": ["2028"]}