{"title": "AutoBayes: A system for generating data analysis programs from statistical models\n", "abstract": " Data analysis is an important scientific task which is required whenever information needs to be extracted from raw data. Statistical approaches to data analysis, which use methods from probability theory and numerical analysis, are well-founded but difficult to implement: the development of a statistical data analysis program for any given application is time-consuming and requires substantial knowledge and experience in several areas. In this paper, we describe AUTOBAYES, a program synthesis system for the generation of data analysis programs from statistical models. A statistical model specifies the properties for each problem variable (i.e. observation or parameter) and its dependencies in the form of a probability distribution. It is a fully declarative problem description, similar in spirit to a set of differential equations. From such a model, AUTOBAYES generates optimized and fully commented C/C++ code\u00a0\u2026", "num_citations": "123\n", "authors": ["1752"]}
{"title": "Specification-based browsing of software component libraries\n", "abstract": " Specification-based retrieval provides exact content-oriented access to component libraries but requires too much deductive power. Specification-based browsing evades this bottleneck by moving any deduction into an off-line indexing phase. In this paper, we show how match relations are used to build an appropriate index and how formal concept analysis is used to build a suitable navigation structure. This structure has the single-focus property (i.e., any sensible subset of a library is represented by a single node) and supports attribute-based (via explicit component properties) and object-based (via implicit component similarities) navigation styles. It thus combines the exact semantics of formal methods with the interactive navigation possibilities of informal methods. Experiments show that current theorem provers can solve enough of the emerging proof problems to make browsing feasible. The\u00a0\u2026", "num_citations": "118\n", "authors": ["1752"]}
{"title": "NORA/HAMMR: Making deduction-based software component retrieval practical\n", "abstract": " Deduction-based software component retrieval uses pre- and postconditions as indexes and search keys and an automated theorem prover (ATP) to check whether a component matches. This idea is very simple but the vast number of arising proof tasks makes a practical implementation very hard. We thus pass the components through a chain of filters of increasing deductive power. In this chain, rejection filters based on signature matching and model checking techniques are used to rule out non-matches as early as possible and to prevent the subsequent ATP from \"drowning\". Hence, intermediate results of reasonable precision are available at (almost) any time of the retrieval process. The final ATP step then works as a confirmation filter to lift the precision of the answer set. We implemented a chain which runs fully automatically and uses SETHEO for model checking and the automated prover SETHEO as\u00a0\u2026", "num_citations": "86\n", "authors": ["1752"]}
{"title": "ESBMC 1.22\n", "abstract": " We have implemented an improved memory model for ESBMC which better takes into account C\u2019s memory alignment rules and optimizes the generated SMT formulae. This simultaneously improves ESBMC\u2019s precision and performance.", "num_citations": "64\n", "authors": ["1752"]}
{"title": "Using automated theorem provers to certify auto-generated aerospace software\n", "abstract": " We describe a system for the automated certification of safety properties of NASA software. The system uses Hoare-style program verification technology to generate proof obligations which are then processed by an automated first-order theorem prover (ATP). For full automation, however, the obligations must be aggressively preprocessed and simplified. We discuss the unique requirements this application places on the ATPs and demonstrate how the individual simplification stages, which are implemented by rewriting, influence the ability of the ATPs to solve the proof tasks. Our results are based on 13 certification experiments that lead to more than 25,000 proof tasks which have each been attempted by Vampire, Spass, and e-setheo.", "num_citations": "56\n", "authors": ["1752"]}
{"title": "VCR: A VDM-based software component retrieval tool\n", "abstract": " We present a tool which allows implicit VDM speci cations to be used as search keys for the retrieval of software components. A preprocessing phase utilizes signature matching to lter promising candidates out of a component library. The actual speci cation matching phase builds proof obligations from the speci cations of key and candidates and feeds them into a theorem prover. Validated obligations denote matching components. First experiments clearly demonstrate the feasibility of this approach. We thus get a high-precision retrieval tool which helps programmers in locating components which exactly match their needs.", "num_citations": "48\n", "authors": ["1752"]}
{"title": "Correctness of source-level safety policies\n", "abstract": " Program certification techniques formally show that programs satisfy certain safety policies. They rely on the correctness of the safety policy which has to be established externally. In this paper we investigate an approach to show the correctness of safety policies which are formulated as a set of Hoare-style inference rules on the source code level. We develop a framework which is generic with respect to safety policies and which allows us to establish that proving the safety of a program statically guarantees dynamic safety, i.e., that the program never violates the safety property during its execution. We demonstrate our framework by proving safety policies for memory access safety and memory read/write limitations to be sound and complete. Finally, we formulate a set of generic safety inference rules which serve as the blueprint for the implementation of a verification condition generator which can be\u00a0\u2026", "num_citations": "46\n", "authors": ["1752"]}
{"title": "A generic annotation inference algorithm for the safety certification of automatically generated code\n", "abstract": " Code generators for realistic application domains are not directly verifiable in practice. In the certifiable code generation approach the generator is extended to generate logical annotations (ie, pre-and postconditions and loop invariants) along with the programs, allowing fully automated program proofs of different safety properties. However, this requires access to the generator sources, and remains difficult to implement and maintain because the annotations are cross-cutting concerns, both on the object-level (ie, in the generated code) and on the meta-level (ie, in the generator). Here we describe a new generic post-generation annotation inference algorithm that circumvents these problems. We exploit the fact that the output of a code generator is highly idiomatic, so that patterns can be used to describe all code constructs that require annotations. The patterns are specific to the idioms of the targeted code\u00a0\u2026", "num_citations": "44\n", "authors": ["1752"]}
{"title": "Synthesizing certified code\n", "abstract": " Code certification is a lightweight approach for formally demonstrating software quality. Its basic idea is to require code producers to provide formal proofs that their code satisfies certain quality properties. These proofs serve as certificates that can be checked independently. Since code certification uses the same underlying technology as program verification, it requires detailed annotations (e.g., loop invariants) to make the proofs possible. However, manually adding annotations to the code is time-consuming and error-prone.             We address this problem by combining code certification with automatic program synthesis. Given a high-level specification, our approach simultaneously generates code and all annotations required to certify the generated code. We describe a certification extension of AutoBayes, a synthesis tool for automatically generating data analysis programs. Based on built-in domain\u00a0\u2026", "num_citations": "42\n", "authors": ["1752"]}