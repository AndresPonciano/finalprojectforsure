{"title": "Mining software repair models for reasoning on the search space of automated program fixing\n", "abstract": " This paper is about understanding the nature of bug fixing by analyzing thousands of bug fix transactions of software repositories. It then places this learned knowledge in the context of automated program repair. We give extensive empirical results on the nature of human bug fixes at a large scale and a fine granularity with abstract syntax tree differencing. We set up mathematical reasoning on the search space of automated repair and the time to navigate through it. By applying our method on 14 repositories of Java software and 89,993 versioning transactions, we show that not all probabilistic repair models are equivalent.", "num_citations": "178\n", "authors": ["132"]}
{"title": "Astor: A program repair library for java\n", "abstract": " During the last years, the software engineering research community has proposed approaches for automatically repairing software bugs. Unfortunately, many software artifacts born from this research are not available for repairing Java programs. To-reimplement those approaches from scratch is costly. To facilitate experimental replications and comparative evaluations, we present Astor, a publicly available program repair library that includes the implementation of three notable repair approaches (jGenProg, jKali and jMutRepair). We envision that the research community will use Astor for setting up comparative evaluations and explore the design space of automatic repair for Java. Astor offers researchers ways to implement new repair approaches or to modify existing ones. Astor repairs in total 33 real bugs from four large open source projects.", "num_citations": "158\n", "authors": ["132"]}
{"title": "Do the fix ingredients already exist? an empirical inquiry into the redundancy assumptions of program repair approaches\n", "abstract": " Much initial research on automatic program repair has focused on experimental results to probe their potential to find patches and reduce development effort. Relatively less effort has been put into understanding the hows and whys of such approaches. For example, a critical assumption of the GenProg technique is that certain bugs can be fixed by copying and re-arranging existing code. In other words, GenProg assumes that the fix ingredients already exist elsewhere in the code. In this paper, we formalize these assumptions around the concept of``temporal redundancy''. A temporally redundant commit is only composed of what has already existed in previous commits. Our experiments show that a large proportion of commits that add existing code are temporally redundant. This validates the fundamental redundancy assumption of GenProg.", "num_citations": "99\n", "authors": ["132"]}
{"title": "Empirical review of Java program repair tools: A large-scale experiment on 2,141 bugs and 23,551 repair attempts\n", "abstract": " In the past decade, research on test-suite-based automatic program repair has grown significantly. Each year, new approaches and implementations are featured in major software engineering venues. However, most of those approaches are evaluated on a single benchmark of bugs, which are also rarely reproduced by other researchers. In this paper, we present a large-scale experiment using 11 Java test-suite-based repair tools and 2,141 bugs from 5 benchmarks. Our goal is to have a better understanding of the current state of automatic program repair tools on a large diversity of benchmarks. Our investigation is guided by the hypothesis that the repairability of repair tools might not be generalized across different benchmarks. We found that the 11 tools 1) are able to generate patches for 21% of the bugs from the 5 benchmarks, and 2) have better performance on Defects4J compared to other benchmarks, by\u00a0\u2026", "num_citations": "50\n", "authors": ["132"]}
{"title": "Alleviating patch overfitting with automatic test generation: a study of feasibility and effectiveness for the Nopol repair system\n", "abstract": " Among the many different kinds of program repair techniques, one widely studied family of techniques is called test suite based repair. However, test suites are in essence input-output specifications and are thus typically inadequate for completely specifying the expected behavior of the program under repair. Consequently, the patches generated by test suite based repair techniques can just overfit to the used test suite, and fail to generalize to other tests. We deeply analyze the overfitting problem in program repair and give a classification of this problem. This classification will help the community to better understand and design techniques to defeat the overfitting problem. We further propose and evaluate an approach called UnsatGuided, which aims to alleviate the overfitting problem for synthesis-based repair techniques with automatic test case generation. The approach uses additional automatically\u00a0\u2026", "num_citations": "43\n", "authors": ["132"]}
{"title": "Ultra-large repair search space with automatically mined templates: The cardumen mode of astor\n", "abstract": " Astor is a program repair library which has different modes. In this paper, we present the Cardumen mode of Astor, a repair approach based mined templates that has an ultra-large search space. We evaluate the capacity of Cardumen to discover test-suite adequate patches (aka plausible patches) over the 356 real bugs from Defects4J [11]. Cardumen finds 8935 patches over 77 bugs of Defects4J. This is the largest number of automatically synthesized patches ever reported, all patches being available in an open-science repository. Moreover, Cardumen identifies 8 unique patches, that are patches for Defects4J bugs that were never repaired in the whole history of program repair.", "num_citations": "40\n", "authors": ["132"]}
{"title": "Towards the quality improvement of cross-platform mobile applications\n", "abstract": " During last ten years, the number of smartphones and mobile applications has been constantly growing. Android, iOS and Windows Mobile are three mobile platforms that cover almost all smartphones in the world in 2017. Developing a mobile app involves first to choose the platforms the app will run, and then to develop specific solutions (i.e., native apps) for each chosen platform using platform-related toolkits such as Android SDK. A cross-platform mobile application is an app that runs on two or more mobile platforms. Several frameworks have been proposed to simplify the development of cross-platform mobile applications and to reduce development and maintenance costs. They are called cross-platform mobile app development frameworks. However, to our knowledge, the life-cycle and the quality of crossplatforms mobile applications built using those frameworks have not been studied in depth. Our main\u00a0\u2026", "num_citations": "40\n", "authors": ["132"]}
{"title": "A comprehensive study of automatic program repair on the QuixBugs benchmark\n", "abstract": " Automatic program repair papers tend to repeatedly use the same benchmarks. This poses a threat to the external validity of the findings of the program repair research community. In this paper, we perform an empirical study of automatic repair on a benchmark of bugs called QuixBugs, which has been little studied. In this paper,(1) We report on the characteristics of QuixBugs;(2) We study the effectiveness of 10 program repair tools on it;(3) We apply three patch correctness assessment techniques to comprehensively study the presence of overfitting patches in QuixBugs. Our key results are:(1) 16/40 buggy programs in QuixBugs can be repaired with at least a test suite adequate patch;(2) A total of 338 plausible patches are generated on the QuixBugs by the considered tools, and 53.3% of them are overfitting patches according to our manual assessment;(3) The three automated patch correctness assessment\u00a0\u2026", "num_citations": "38\n", "authors": ["132"]}
{"title": "An empirical study on quality of Android applications written in Kotlin language\n", "abstract": " Context During the last years, developers of mobile applications have the possibility to use new paradigms and tools for developing mobile applications. For instance, since 2017, Android developers have the official support to write Android applications using Kotlin language. Kotlin is programming language fully interoperable with Java that combines object-oriented and functional features.   Objective The goal of this paper is twofold. First, it aims to study the degree of adoption of Kotlin language on the development of open-source Android applications and to measure the amount of Kotlin code inside those applications. Secondly, it aims to measure the quality of Android applications that are written using Kotlin and to compare it with the quality of Android applications written using Java.   Method We first defined a method to detect Kotlin applications from a dataset of open-source Android applications. Then, we\u00a0\u2026", "num_citations": "34\n", "authors": ["132"]}
{"title": "Astor: Exploring the design space of generate-and-validate program repair beyond GenProg\n", "abstract": " This article contributes to defining the design space of program repair. Repair approaches can be loosely characterized according to the main design philosophy, in particular \u201cgenerate- and-validate\u201d and synthesis-based approaches. Each of those repair approaches is a point in the design space of program repair. Our goal is to facilitate the design, development and evaluation of repair approaches by providing a framework that: a) contains components commonly present in most approaches, b) provides built-in implementations of existing repair approaches. This paper presents a Java framework named Astor that focuses on the design space of generate-and-validate repair approaches. The key novelty of Astor is to provides explicit extension points to explore the design space of program repair. Thanks to those extension points, researchers can both reuse existing program repair components and implement new\u00a0\u2026", "num_citations": "26\n", "authors": ["132"]}
{"title": "Test case generation for program repair: A study of feasibility and effectiveness\n", "abstract": " Among the many different kinds of program repair techniques, one widely studied family of techniques is called test suite based repair. Test-suites are in essence input-output specifications and are therefore typically inadequate for completely specifying the expected behavior of the program under repair. Consequently, the patches generated by test suite based program repair techniques pass the test suite, yet may be incorrect. Patches that are overly specific to the used test suite and fail to generalize to other test cases are called overfitting patches. In this paper, we investigate the feasibility and effectiveness of test case generation in alleviating the overfitting issue. We propose two approaches for using test case generation to improve test suite based repair, and perform an extensive evaluation of the effectiveness of the proposed approaches in enabling better test suite based repair on 224 bugs of the Defects4J repository. The results indicate that test case generation can change the resulting patch, but is not effective at turning incorrect patches into correct ones. We identify the problems related with the ineffectiveness, and anticipate that our results and findings will lead to future research to build test-case generation techniques that are tailored to automatic repair systems.", "num_citations": "26\n", "authors": ["132"]}
{"title": "Coming: A tool for mining change pattern instances from git commits\n", "abstract": " Software repositories such as Git have become a relevant source of information for software engineer researchers. For instance, the detection of commits that fulfill a given criterion (e.g., bugfixing commits) is one of the most frequent tasks done to understand the software evolution. However, to our knowledge, there is no open-source tool that, given a Git repository, returns all the instances of a given code change pattern. In this paper we present Coming, a tool that takes as input a Git repository and mines instances of code change patterns present on each commit. For that, Coming computes fine-grained code changes between two consecutive revisions, analyzes those changes to determine if they correspond to an instance of a change pattern (specified by the user using XML), and finally, after analyzing all the commits, it presents a) the frequency of code changes and b) the instances found in each commit. We\u00a0\u2026", "num_citations": "23\n", "authors": ["132"]}
{"title": "When app stores listen to the crowd to fight bugs in the wild\n", "abstract": " App stores are digital distribution platforms that put available apps that run on mobile devices. Current stores are software repositories that deliver apps upon user requests. However, when an app has a bug, the store continues delivering defective apps until the developer uploads a fixed version, thus impacting on the reputation of both store and app developer. In this paper, we envision a new generation of app stores that: (a) reduce human intervention to maintain mobile apps; and (b) enhance store services with smart and autonomous functionalities to automatically increase the quality of the delivered apps. We sketch a prototype of our envisioned app store and we discuss the functionalities that current stores an enhance by incorporating automatic software repair techniques.", "num_citations": "22\n", "authors": ["132"]}
{"title": "Automated patch assessment for program repair at scale\n", "abstract": " In this paper, we do automatic correctness assessment for patches generated by program repair systems. We consider the human-written patch as ground truth oracle and randomly generate tests based on it, a technique proposed by Shamshiri et al., called Random testing with Ground Truth (RGT) in this paper. We build a curated dataset of 638 patches for Defects4J generated by 14 state-of-the-art repair systems, we evaluate automated patch assessment on this dataset. The results of this study are novel and significant: First, we improve the state of the art performance of automatic patch assessment with RGT by 190% by improving the oracle; Second, we show that RGT is reliable enough to help scientists to do overfitting analysis when they evaluate program repair systems; Third, we improve the external validity of the program repair knowledge with the largest study ever.", "num_citations": "16\n", "authors": ["132"]}
{"title": "Cvs-vintage: A dataset of 14 cvs repositories of java software\n", "abstract": " This paper presents a dataset of 14 CVS repositories of Java applications. This dataset aims at supporting the replication of early papers in the field of software evolution and mining software repositories. By building this dataset, we saved some CVS repositories from a probable death by deletion.", "num_citations": "13\n", "authors": ["132"]}
{"title": "Mining repair actions for guiding automated program fixing\n", "abstract": " Automated program fixing consists of generating source code in order to fix bugs in an automated manner. Our intuition is that automated program fixing can imitate human-based program fixing. Hence, we present a method to mine repair actions from software repositories. A repair action is a small semantic modification on code such as adding a method call. We then decorate repair actions with a probability distribution also learnt from software repositories. Our probabilistic repair models enable us to mathematically reason on the automated software repair process. By applying our method on 14 repositories of Java software and 89993 versioning transactions, we show that our probabilistic repair actions are able to guide the automated fixing process in the repair space, with a probabilistic focus on likely repair shapes first.", "num_citations": "13\n", "authors": ["132"]}
{"title": "ASTOR: Evolutionary automatic software repair for Java\n", "abstract": " Context: During last years, many automatic software repair approaches have been presented by the software engineering research community. According to the corresponding papers, these approaches are able to repair real defects from open source projects. Problematic: Some previous publications in the automatic repair field do not provide the implementation of theirs approaches. Consequently, it is not possible for the research community to re-execute the original evaluation, to set up new evaluations (for example, to evaluate the performance against new defects) or to compare approaches against each others. Solution: We propose a publicly available automatic software repair tool called Astor. It implements three state-of-the-art automatic software repair approaches in the context of Java programs (including GenProg and a subset of PAR's templates). The source code of Astor is licensed under the GNU General Public Licence (GPL v2).", "num_citations": "12\n", "authors": ["132"]}
{"title": "Automated classification of overfitting patches with statically extracted code features\n", "abstract": " Automatic program repair (APR) aims to reduce the cost of manually fixing software defects. However, APR suffers from generating a multitude of overfitting patches, those patches that fail to correctly repair the defect beyond making the tests pass. This paper presents a novel overfitting patch detection system called ODS to assess the correctness of APR patches. ODS first statically compares a patched program and a buggy program in order to extract code features at the abstract syntax tree (AST) level. Then, ODS uses supervised learning with the captured code features and patch correctness labels to automatically learn a probabilistic model. The learned ODS model can then finally be applied to classify new and unseen program repair patches. We conduct a large-scale experiment to evaluate the effectiveness of ODS on patch correctness classification based on 10,302 patches from Defects4J, Bugs.jar and\u00a0\u2026", "num_citations": "10\n", "authors": ["132"]}
{"title": "On the adoption, usage and evolution of Kotlin features in Android development\n", "abstract": " Background: Google announced Kotlin as an Android official programming language in 2017, giving developers an option of writing applications using a language that combines object-oriented and functional features. Aims: The goal of this work is to understand the usage of Kotlin features considering four aspects: i) which features are adopted, ii) what is the degree of adoption, iii) when are these features added into Android applications for the first time, and iv) how the usage of features evolves along with applications' evolution. Method: Exploring the source code of 387 Android applications, we identify the usage of Kotlin features on each version application's version and compute the moment that each feature is used for the first time. Finally, we identify the evolution trend that better describes the usage of these features. Results: 15 out of 26 features are used on at least 50% of applications. Moreover, we found\u00a0\u2026", "num_citations": "9\n", "authors": ["132"]}
{"title": "The patches of the nopol automatic repair system on the bugs of defects4j version 1.1. 0\n", "abstract": " HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers.", "num_citations": "8\n", "authors": ["132"]}
{"title": "How and Why did developers migrate Android Applications from Java to Kotlin? A study based on code analysis and interviews with developers\n", "abstract": " Nowadays, the majority of the apps running on mobile devices are Android apps developed in Java. However, developers now have the possibility to write Android applications using a new programming language: Kotlin. Android developers can: a) start writing an Android application from scratch using Koltin, b) evolve their existing Android applications written in Java by adding Kotlin code (that is possible thanks to the interoperability between those languages), or c) migrate their Android apps from Java to Kotlin. This paper aims at studying this latter case. We want to know Why and How Android developers have migrated Java code to Kotlin. For that, we first built a tool, named MigA, which analyzes the history of applications having Java and Kotlin code and is able to detect commits that migrate code. We executed MigA on a dataset with 374 Android applications. Then, we interviewed 78 developers from those applications that have written, at least, one commit that migrates Java code to Kotlin. Our main goal was to know why those developers have done that code migrations. This paper presents the main ten reasons of migration that we obtained from the interviews. Moreover, by combining code analysis done by MigA and the information obtained from the interviews, we present a deeper characterization of the migration activity. Finally, we present and discuss the experiences and advises we obtained from developers that migrated code.", "num_citations": "6\n", "authors": ["132"]}
{"title": "E-APR: mapping the effectiveness of automated program repair techniques\n", "abstract": " Automated Program Repair (APR) is a fast growing area with numerous new techniques being developed to tackle one of the most challenging software engineering problems. APR techniques have shown promising results, giving us hope that one day it will be possible for software to repair itself. In this paper, we focus on the problem of objective performance evaluation of APR techniques. We introduce a new approach, Explaining Automated Program Repair (E-APR), which identifies features of buggy programs that explain why a particular instance is difficult for an APR technique. E-APR is used to examine the diversity and quality of the buggy programs used by most researchers, and analyse the strengths and weaknesses of existing APR techniques. E-APR visualises an instance space of buggy programs, with each buggy program represented as a point in the space. The instance space is constructed\u00a0\u2026", "num_citations": "5\n", "authors": ["132"]}
{"title": "Program repair at arbitrary fault depth\n", "abstract": " Program repair has been an active research area for over a decade and has achieved great strides in terms of scalable automated repair tools. In this paper we argue that existing program repair tools lack an important ingredient, which limits their scope and their efficiency: a formal definition of a fault, and a formal characterization of fault removal. To support our conjecture, we consider GenProg, an archetypical program repair tool, and modify it according to our definitions of fault and fault removal; then we show, by means of empirical experiments, the impact that this has on the effectiveness and efficiency of thee tool.", "num_citations": "5\n", "authors": ["132"]}
{"title": "Two datasets of questions and answers for studying the development of cross-platform mobile applications using Xamarin framework\n", "abstract": " A cross-platform mobile application is an application that runs on multiple mobile platforms (Android, iOS). Several frameworks have been proposed to simplify the development of cross-platform mobile applications and, therefore, to reduce development and maintenance costs. Between them, cross-compiler mobile development frameworks, such as Xamarin from Microsoft, transform the application's code written in intermediate (aka non-native) language to native code for each target platform (Android, iOS). However, to our best knowledge, there is not much research about the advantages and disadvantages of the use of those frameworks during the development and maintenance phases of mobile applications. The objective of this paper is to present two datasets of questions and answers (Q&A) related to the development of mobile applications using Xamarin. Our datasets have 85,908 questions mined from the\u00a0\u2026", "num_citations": "4\n", "authors": ["132"]}
{"title": "Discovering discussion topics about development of cross-platform mobile applications using a cross-compiler development framework\n", "abstract": " There are billions of smartphone devices around the world and the large majority of them run either Android or iOS platforms. A cross-platform mobile application is an application that runs on multiple mobile platforms. One strategy for developing this kind of mobile applications involves to develop, using platform-related toolkits, a native application for each chosen platform. Several frameworks have been proposed to simplify the development of cross-platform mobile applications and, therefore, to reduce development and maintenance costs. Between them, the cross-compiler mobile development frameworks transform the application\u2019s code written in intermediate (aka non-native) language to native code for each desired platform. However, to our best knowledge, there is no much research about the advantages and disadvantages of the use of cross-compiler frameworks during the development and maintenance phases of mobile applications.This paper aims at contributing with one of the first bricks in that research direction. We study what mobile developers that use cross-compiler frameworks ask about when they develop and maintain cross-platform mobile applications. In particular, we focus on one framework: Xamarin from Microsoft. For that, we first created two datasets of questions and answers (Q&A) related to the development of mobile applications using Xamarin by mining two Q&A sites: Xamarin Forum and Stack Overflow. We analyzed and compared the number of questions, views and accepted answers from each site. Then, we applied Latent Dirichlet Allocation (LDA) on Xamarin-related questions to discover the main topics asked\u00a0\u2026", "num_citations": "3\n", "authors": ["132"]}
{"title": "Extraction and analysis of knowledge for automatic software repair\n", "abstract": " Bug fixing is a frequent activity in the software life cycle. The activity aims at removing the gap between the expected behavior of a program and what it actually does. This gap encompasses different anomalies such as the failure of a program facing to a given scenario. Bug fixing is a task historically done by software developers. However, in the recent years, several automatic software repair approaches have emerged to automatically synthesize bug fixes. Unfortunately, bug fixing could be even hard and expensive for automatic program repair approaches. In this thesis, we aim at adding repair approaches strategies to optimize the search of solutions in the repair search space. These strategies consume information extracted from repairs done by developers. Then, for validating the repair approaches and our strategies, we focus on the evaluation of automatic repair approaches. We aim at introducing methodologies for defining how researchers can evaluate repair approaches in a meaningful manner. For example, the performance of a repair approach depends on the defect dataset  used to evaluate the approach. First, we define a methodology to define defect datasets that minimize the possibility of biased results.We present a dataset that includes a particular kind of defect: if conditional defects. Then, we aim at measuring the repairability of this kind of defect by evaluating three state-of-the-art automatic software repair approaches.", "num_citations": "3\n", "authors": ["132"]}
{"title": "A Comprehensive Study of Code-removal Patches in Automated Program Repair\n", "abstract": " Automatic Program Repair (APR) techniques can promisingly help reducing the cost of debugging. Many relevant APR techniques follow the generate-and-validate approach, that is, the faulty program is iteratively modified with different change operators and then validated with a test suite until a plausible patch is generated. In particular, Kali is a generate-and-validate technique developed to investigate the possibility of generating plausible patches by only removing code. Former studies show that indeed Kali successfully addressed several faults. This paper addresses the case of code-removal patches in automated program repair investigating the reasons and the scenarios that make their creation possible, and the relationship with patches implemented by developers. Our study reveals that code-removal patches are often insufficient to fix bugs, and proposes a comprehensive taxonomy of code-removal patches that provides evidence of the problems that may affect test suites, opening new opportunities for researchers in the field of automatic program repair.", "num_citations": "2\n", "authors": ["132"]}
{"title": "Neural Program Repair with Execution-based Backpropagation\n", "abstract": " Neural machine translation (NMT) architectures have achieved promising results for automatic program repair. Yet, they have the limitation of generating low-quality patches(e.g., not compilable patches). This is because the existing works only optimize a purely syntactic loss function based on characters and tokens without incorporating program-specific information during neural net weight optimization. In this paper, we proposea novel program repair model called RewardRepair. The core novelty of RewardRepair is to improve NMT-based program repair with a loss function based on program compilation and test execution information, rewarding the network to produce patches that compile and that do not overfit. We conduct several experiments to evaluate RewardRepair showing that it is feasible and effective to use compilation and test execution results to optimize the underlying neural repair model.", "num_citations": "1\n", "authors": ["132"]}
{"title": "Hyperparameter Optimization for AST Differencing\n", "abstract": " Computing the differences between two versions of the same program is an essential task for software development and software evolution research. AST differencing is the most advanced way of doing so, and an active research area. Yet, AST differencing still relies on default configurations or manual tweaking. In this paper we present a novel approach named DAT for hyperparameter optimization of AST differencing. We thoroughly state the problem of hyper configuration for AST differencing. We show that our data-driven approach to hyperoptimize AST differencing systems increases the edit-script quality in up to 53% of cases.", "num_citations": "1\n", "authors": ["132"]}
{"title": "Appendix of\" Mining Software Repair Models for Reasoning on the Search Space of Automated Program Fixing\"\n", "abstract": " This is the companion paper of \"Mining Software Repair Models for Reasoning on the Search Space of Automated Program Fixing\", accepted for publication in Empirical Software Engineering (Springer) on Sep. 11, 2013.", "num_citations": "1\n", "authors": ["132"]}