{"title": "Recording the reasons for design decisions\n", "abstract": " We outline a generic model for representing design deliberation and the relation between deliberation and the generation of method-specific artifacts. A design history is regarded as a network consisting of artifacts and deliberation nodes. Artifacts represent specifications or design-documents. Deliberation nodes represent issues, alternatives or justifications. Existing artifacts give rise to issues about the evolving design, an alternative is one of several positions that respond to the issue (perhaps calling for the creation or modification of an artifact), and a justification is a statement giving the reasons for and against the related alternative. The model is applied to the development of a text formatter. The example necessitates some tailoring of the generic model to the method adopted in the development, Liskov and Guttag's design method. We discuss the experiment and the method-specific extensions. The example\u00a0\u2026", "num_citations": "438\n", "authors": ["1706"]}
{"title": "Relationship-based access control: its expression and enforcement through hybrid logic\n", "abstract": " Access control policy is typically defined in terms of attributes, but in many applications it is more natural to define permissions in terms of relationships that resources, systems, and contexts may enjoy. The paradigm of relationship-based access control has been proposed to address this issue, and modal logic has been used as a technical foundation.", "num_citations": "96\n", "authors": ["1706"]}
{"title": "Distributed systems analysis with CCS\n", "abstract": " Distributed systems analysis with CCS | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksDistributed systems analysis with CCS ABSTRACT No abstract available. Index Terms 1.Distributed systems analysis with CCS 1.Computing methodologies 1.Distributed computing methodologies 1.Distributed programming languages 2.Information systems 1.Information systems applications 1.Process control systems 3.Software and its engineering 1.Software notations and tools 1.Formal language definitions 2.General programming languages 1.Language types 1.Distributed programming languages 4.Theory of computation 1.\u2026", "num_citations": "95\n", "authors": ["1706"]}
{"title": "A simple and expressive semantic framework for policy composition in access control\n", "abstract": " In defining large, complex access control policies, one would like to compose sub-policies, perhaps authored by different organizations, into a single global policy. Existing policy composition approaches tend to be ad-hoc, and do not explain whether too many or too few policy combinators have been defined. We define an access controlpolicy as a four-valued predicate that maps accesses to either grant, deny, conflict, or unspecified. These correspond to the four elements of the Belnap bilattice. Functions on this bilattice are then extended to policies to serve as policy combinators. We argue that this approach provides a simple andnatural semantic framework for policy composition, with a minimal but functionally complete set of policy combinators. We define derived, higher-level operators that are convenient for the specification of access control policies, and enable the decoupling of conflict resolution from policy\u00a0\u2026", "num_citations": "76\n", "authors": ["1706"]}
{"title": "Access control via Belnap logic: Intuitive, expressive, and analyzable policy composition\n", "abstract": " Access control to IT systems increasingly relies on the ability to compose policies. Hence there is benefit in any framework for policy composition that is intuitive, formal (and so \u201canalyzable\u201d and \u201cimplementable\u201d), expressive, independent of specific application domains, and yet able to be extended to create domain-specific instances. Here we develop such a framework based on Belnap logic. An access-control policy is interpreted as a four-valued predicate that maps access requests to either grant, deny, conflict, or unspecified -- the four values of the Belnap bilattice. We define an expressive access-control policy language PBel, having composition operators based on the operators of Belnap logic. Natural orderings on policies are obtained by lifting the truth and information orderings of the Belnap bilattice. These orderings lead to a query language in which policy analyses, for example, conflict freedom, can be\u00a0\u2026", "num_citations": "68\n", "authors": ["1706"]}
{"title": "\u03bcABC: A Minimal Aspect Calculus\n", "abstract": " Aspect-oriented programming is emerging as a powerful tool for system design and development. In this paper, we study aspects as primitive computational entities on par with objects, functions and horn-clauses. To this end, we introduce \u03bcABC, a name-based calculus, that incorporates aspects as primitive. In contrast to earlier work on aspects in the context of object-oriented and functional programming, the only computational entities in \u03bcABC are aspects. We establish a compositional translations into \u03bcABC from a functional language with aspects and higher-order functions. Further, we delineate the features required to support an aspect-oriented style by presenting a translation of \u03bcABC into an extended \u03c0-calculus.", "num_citations": "59\n", "authors": ["1706"]}
{"title": "Access-control policies via Belnap logic: Effective and efficient composition and analysis\n", "abstract": " It is difficult to develop and manage large, multi-author access control policies without a means to compose larger policies from smaller ones. Ideally, an access-control policy language will have a small set of simple policy combinators that allow for all desired policy compositions. In \\cite{BH07}, a policy language was presented having policy combinators based on Belnap logic, a four-valued logic in which truth values correspond to policy results of \"grant\", \"deny\", \"conflict\", and \"undefined\". We show here how policies in this language can be analyzed, and study the expressiveness of the language. To support policy analysis, we define a query language in which policy analysis questions can be phrased. Queries can be translated into a fragment of first-order logic for which satisfiability and validity checks are computable by SAT solvers or BDDs. We show how policy analysis can then be carried out through model\u00a0\u2026", "num_citations": "57\n", "authors": ["1706"]}
{"title": "A practical technique for process abstraction\n", "abstract": " With algebraic laws a process can be simplified before verifying its equivalence with another process. Also needed are laws to allow a process to be simplified before verifying that it satisfies a temporal logic formula. Most previous work on this problem is based on property-preserving mappings between transition systems. The results presented here allow direct simplification of process terms for some important classes of temporal properties.", "num_citations": "55\n", "authors": ["1706"]}
{"title": "Validating safety models with fault trees\n", "abstract": " In verifying a safety-critical system, one usually begins by building a model of the basic system and of its safety mechanisms. If the basic system model does not reflect reality, the verification results are misleading. We show how a model of a system can be compared with the system\u2019s fault trees to help validate the failure behaviour of the model. To do this, the meaning of fault trees are formalised in temporal logic and a consistency relation between models and fault trees is defined. An important practical feature of the technique is that it allows models and fault trees to be compared even if some events in the fault tree are not found in the system model.", "num_citations": "47\n", "authors": ["1706"]}
{"title": "A case study in safety-critical design\n", "abstract": " We have modelled the design of a safety-critical railway system in the process calculus CCS, described important properties of the design in temporal logic, and verified with the Concurrency Workbench that some of the properties hold of the model. Verifying properties of a design, rather than an implementation, presented special problems, particularly in capturing in the formal model the kinds of abstraction found in the design, and in showing that the verified properties would also hold in all implementations of the design.", "num_citations": "44\n", "authors": ["1706"]}
{"title": "A Language for Value-passing CCS\n", "abstract": " This paper, taken directly from Appendix C of 1], gives the syntax and semantics for a value-passing CCS. Our language is based on the value-passing version of CCS presented by Milner in 2]. Like Milner, we de ne the semantics of our notation by translation to basic CCS. Unlike Milner, our notation supports both parametrized and indexed actions, and includes sets, tuples, and lists as built-in data types.", "num_citations": "39\n", "authors": ["1706"]}
{"title": "Model checking and fault tolerance\n", "abstract": " We present an algebraic approach to the model checking of fault-tolerant systems. Fault models and fault-handling mechanisms are modelled using special-purpose process operators. Besides providing for natural models, special-purpose operators allow systems with large state spaces to be verified using systems with small state spaces. To support this verification technique we show that a kind of simulation relation on processes preserves all process operators in tyft/tyxt format.", "num_citations": "33\n", "authors": ["1706"]}
{"title": "Calculating the benefits of sponsored data for an individual content provider\n", "abstract": " Sponsored content is a mechanism in which content providers can pay the operator of a wireless network to make their content free to end users. Such offerings have recently been introduced in both the US and Asia and they raise many challenging questions regarding which sites should be candidates for sponsoring and how much the service provider should charge the content provider. Recent papers have proposed models for the economic dynamics between the participants in the system but all of these models require multiple parameters including the expected traffic increase due to the sponsoring and additional revenue that the content provider receives for each extra view. In this paper we offer two contributions. We first describe a detailed methodology for extracting these parameters given access to traffic data and published financial reports. We then discuss how this type of analysis can be used to select\u00a0\u2026", "num_citations": "24\n", "authors": ["1706"]}
{"title": "Understanding quota dynamics in wireless networks\n", "abstract": " In designing new service plans, network service providers need to understand how consumption of voice or data service will change in response to pricing signals. It is difficult to acquire such information from customer usage data because voice minutes and data bandwidth are typically sold in the form of large quotas. We address this issue by studying how end-users consume their quotas, both in a prepaid setting (where users pay in advance and refill as needed) and a postpaid setting (where users pay each month for a fixed amount of quota). Our presentation has three main parts. In the first we present data on quota usage for prepaid voice/text services and show that users reduce their voice usage when their balances become low. Moreover, when balances are low there is a tendency to shift from voice to SMS. In the second part, we provide descriptive models of both prepaid and postpaid services. The main\u00a0\u2026", "num_citations": "22\n", "authors": ["1706"]}
{"title": "Foundations for Features.\n", "abstract": " The feature interaction problem arose in the field of telecommunications but is now recognized as a general problem of software engineering. Capturing the idea of feature interaction in a simple and precise way has proven difficult. This paper briefly surveys existing notions of feature and feature interaction.", "num_citations": "22\n", "authors": ["1706"]}
{"title": "Features as service transformers\n", "abstract": " A primary goal of telecommunications companies is to reduce time to market. An obstacle to this goal in telephone switching equipment is that unwanted interactions between call processing features are difficult to discover, making extensive testing necessary. We present an approach to the specification of call processing features in which a feature is seen as a service transformer. We then define two notions of feature interaction, and illustrate how they can be used for the detection of feature interactions.", "num_citations": "19\n", "authors": ["1706"]}
{"title": "The formalization and analysis of a communications protocol\n", "abstract": " The MSMIE protocol [SBC89] allows processors in a distributed system to communicate via shared memory. It was designed to meet the reliability and efficiency needs of applications such as nuclear safety systems. We present a formal model of the MSMIE protocol expressed in the notation CCS. Desirable properties of the protocol are expressed in the modal mu-calculus, an expressive modal logic. We show that the protocol lacks an important liveness property. In actual operation, additional operating constraints are checked to avoid potential problems. We present a modified protocol and show that it possesses the liveness property even without checking operating constraints. We also show how parts of the analysis were automated with the Concurrency Workbench.", "num_citations": "19\n", "authors": ["1706"]}
{"title": "An industrial application of modal process logic\n", "abstract": " Modal process logic is an extension of CCS that allows for more expressive specifications. We show how modal process logic was successfully applied in the development of a failure recovery protocol for an air-traffic information system now in service at Heathrow airport. Two example systems are used to show that CCS itself was not suitable for this application.", "num_citations": "16\n", "authors": ["1706"]}
{"title": "The formalization and analysis of a communications protocol\n", "abstract": " The MSMIE protocol (Santoline et al., 1989) was designed to allow processors in a nuclear safety system to communicate efficiently and reliably via shared memory. Our formalization and analysis shows that the protocol lacks an important liveness property. In actual operation, timing constraints are checked to avoid potential problems. We present a modified protocol that possesses the liveness property even without such constraints. We also show how parts of the analysis were automated with the Concurrency Workbench.", "num_citations": "16\n", "authors": ["1706"]}
{"title": "A hierarchical approach to service negotiation\n", "abstract": " Service negotiation allows a service client to negotiate with a service provider on the terms of service. Much existing work on service negotiation assumes that a provider will define its negotiation strategy in terms of the state of its resources. This approach can lead to complex strategy and assumes, unrealistically, that providers have full knowledge and control of their resources. We propose a hierarchical model of service negotiation in which negotiation strategy is defined in terms of sub-negotiations with internal or external agents. This model helps to manage the complexity of negotiation strategy by allowing it to be decomposed, with each component having well-defined scope. In this paper we present our hierarchical negotiation model, and a negotiation protocol and negotiation policy language based on it.", "num_citations": "11\n", "authors": ["1706"]}
{"title": "Method and apparatus for alerting mobile telephone call participants that a vehicle's driver is occupied\n", "abstract": " A method and apparatus for improving safety when a driver of a vehicle such as an automobile is engaged in a conversation with another party (or other parties) using a mobile telecommunications device such as a cell phone. Specifically, a situation that requires an elevated attention level of the driver is automatically detected, and in response thereto, an audible alert to at least one of the remote parties to the conversation is automatically provided. The detection of a situation that requires an elevated attention level of the driver and/or the generation of the audible alert to the (one or more) remote parties may be effectuated by the driver's mobile telecommunications device (ie, cell phone) or by a network element in the telecommunications network being used to effectuate the call.", "num_citations": "11\n", "authors": ["1706"]}
{"title": "Text-Based Communication Services Based On User-Specified Privacy Settings\n", "abstract": " A text-based communication service executes a collaborative data security protocol and/or pricing of services based at least in part on a user-specified privacy policy. The user-specified privacy policy may dictate, for example, a manner of filtering or encryption of user text and may be implemented in text-based communication services including, without limitation, webmail, social networking, web search and Instant Messaging services.", "num_citations": "10\n", "authors": ["1706"]}
{"title": "Applying formal methods to a protocol standard and its implementations\n", "abstract": " We explore the use of formal methods in the analysis of the SONET Automatic Protection Switching (APS) protocol. Unlike most protocol studies, we look at both conformance and interoperability aspect of APS. We use the Concurrency Workbench of North Carolina [9] to show proper interoperation of network elements running the protocol, and use the VeriSoft tool [12] to show conformance of Lucent Technologies APS implementation to the APS standard. We define a new notion of conformance, identify problems with APS, suggest general improvements to the structure of protocol standards, and suggest how protocol implementations can be written to allow conformance checks to be automated.", "num_citations": "10\n", "authors": ["1706"]}
{"title": "Applying process refinement to a safety-relevant system\n", "abstract": " Development by sound re nement steps is an important method for showing the correctness of a system relative to its speci cation. The re nement of sequential systems has been studied extensively over the past two decades, but the re nement of concurrent systems has received much less attention. Various notions of process re nement have been suggested, such as observation equivalence 7], language inclusion 5], and other preorder relations 9, 3], but so far little evidence of their utility has been garnered from attempts at applying them to real systems.Here we present a case study showing the application of modal process logic 6] to the formal re nement of a failure-recovery protocol used in a safety-relevant air transport application. Intuitively, modal process logic allows speci cations to express that certain actions must be performed by an implementation, and that other actions may be performed by an implementation. This sense of re nement was found to t the application problem well.", "num_citations": "9\n", "authors": ["1706"]}
{"title": "Machine-to-Machine Anomaly Detection\n", "abstract": " A method and apparatus for configuring an anomaly detector by constructing a classifier using supervised learning and applying that classifier to classify M2M traffic as either \u201canomalous\u201d or \u201cnon-anomalous\u201d with respect to a particular host. Anomaly detection is provided using one or more constructed classifiers. Each classifier is akin to an object that supports two main operations:(1) train: given a set of labeled feature vectors, construct a classifier; and (2) classify: given a feature vector, output a particular classification (ie, result) selected from two classes defined as anomalous or non-anomalous. A non-anomalous result is indicative of host flow data that is typically associated with a particular host (ie, safe traffic). An anomalous result is indicative of host flow data that is not typically associated with a particular host (ie, unsafe traffic).", "num_citations": "6\n", "authors": ["1706"]}
{"title": "Method For Offering Wireless Data At A Discounted Rate\n", "abstract": " A method for offering wireless data at a discounted rate is provided. A wireless service provider is queried to discover discounted data transfer rates. A discount rate proposal is sent to the querying mobile user. The discount rate proposal includes a discount rate, a data bit rate, and an offered time period. If the mobile unit accepts the discount rate proposal, user data is carried at the data bit rate during the offered time period priced at the discount rate.", "num_citations": "6\n", "authors": ["1706"]}
{"title": "Automated software development with XML and the Java\u2217language\n", "abstract": " In software development with domain-specific languages (DSLs), one defines a requirements language for an application domain and then develops a compiler to generate an implementation from a requirements document. Because DSLs and DSL compilers are expensive to develop, DSLs are seen as cost effective only when many products of the same domain will be developed. In this paper, we show how the cost of DSL design and DSL compiler development can be reduced by defining DSLs as Extensible-Markup-Language (XML) dialects and by developing DSL compilers using commercial XML tools and the Java, \u2217  language. This approach is illustrated through the Call View Data Language (CDL), a new DSL that generates provisioning support code and database table definitions for Lucent Technologies' 7R/E\u2122 Network Feature Server.", "num_citations": "6\n", "authors": ["1706"]}
{"title": "A Language and Translator for Value-passing CCS\n", "abstract": " We de ne a language for value-passing CCS. The main additions of our language to the notation de ned by Milner are: a concrete data language, having set, list, and tuple data types; simple, indexed, parameterized, and indexed/parameterized actions; and action declarations to associate sets of values with actions. This paper contains a de nition of the language and a brief description of a translator to basic CCS.", "num_citations": "5\n", "authors": ["1706"]}
{"title": "Method For Sending A Portion Of A Video Stream\n", "abstract": " A Wireless Service Provider (WSP) receives a request for a video stream from a user device. The WSP determines if the video stream should have the video portion modified or removed, based upon a user's manual request or a predetermined condition being met. The modification can be removal of the video portion or the replacement of the original video portion with a lower bandwidth video portion. The modified video stream is then sent to the user device.", "num_citations": "3\n", "authors": ["1706"]}
{"title": "Program synthesis in administration of higher-order permissions\n", "abstract": " In\" administrative\" access control, policy controls permissions not just on application actions, but also on actions to modify permissions, on actions to modify permissions on those actions, and so on. One context of work in administrative policy is\" administrative RBAC\", in which policy controls the permissions of roles, the membership of roles, and other elements of RBAC access-control state.", "num_citations": "3\n", "authors": ["1706"]}
{"title": "A Case Study in the Analysis of Safety Requirements\n", "abstract": " We show how formal methods can be used to assist in developing requirements of a safety-critical system. The approach is to express the requirements in temporal logic, and then to develop a process model satisfying the requirements. The existence of such a model ensures the requirements are consistent, and also helps in their validation.", "num_citations": "3\n", "authors": ["1706"]}
{"title": "Data quota management for wireless communication systems\n", "abstract": " A wireless service provider server includes a transceiver to provide data for transmission to and receive data from one or more subscribers to a wireless service plan at a quality-of-service (QoS). The wireless service provider server also includes a processor to modify the QoS for the at least one subscriber based on a comparison of data usage by the at least one subscriber during a time interval specified by the wireless service plan and an elapsed portion of the time interval.", "num_citations": "1\n", "authors": ["1706"]}
{"title": "Capability-based communications\n", "abstract": " A capability-based communication mechanism is provided for controlling delivery of messages. A capability-based address is an address having one or more capability parameters associated therewith, where the one or more capability parameters associated with the capability-based address may be used to control delivery of messages to the capability-based address. A user or entity requests a capability-based address from a communication service provider. The communication service provider provides a capability-based address to the user or entity. The user or entity provides the capability-based address to one or more other users or entities. The delivery of messages to the user or entity with which the capability-based address is associated is controlled based on the one or more capability parameters associated with the capability-based address of the user or entity.", "num_citations": "1\n", "authors": ["1706"]}
{"title": "Refinement and dependable systems\n", "abstract": " Dependable systems must often detect, recover from, and tolerate faults. A common problem in the behavioural specification of such systems is that one cannot specify a response to faults without also specifying that faults must be able to occur, even though non-faulty systems are acceptable. Our solution is to adopt modal process logic, which allows one to distinguish between events of a specification that must be implemented and those that may be implemented. We describe the problem and illustrate the application of modal process logic to the verification of an industrial failure-recovery protocol.", "num_citations": "1\n", "authors": ["1706"]}