{"title": "Mobile values, new names, and secure communication\n", "abstract": " We study the interaction of the \"new\" construct with a rich but common form of (first-order) communication. This interaction is crucial in security protocols, which are the main motivating examples for our work; it also appears in other programming-language contexts. Specifically, we introduce a simple, general extension of the pi calculus with value passing, primitive functions, and equations among terms. We develop semantics and proof techniques for this extended language and apply them in reasoning about some security protocols.", "num_citations": "1198\n", "authors": ["660"]}
{"title": "VC3: Trustworthy data analytics in the cloud using SGX\n", "abstract": " We present VC3, the first system that allows users to run distributed MapReduce computations in the cloud while keeping their code and data secret, and ensuring the correctness and completeness of their results. VC3 runs on unmodified Hadoop, but crucially keeps Hadoop, the operating system and the hyper visor out of the TCB, thus, confidentiality and integrity are preserved even if these large components are compromised. VC3 relies on SGX processors to isolate memory regions on individual computers, and to deploy new protocols that secure distributed MapReduce computations. VC3 optionally enforces region self-integrity invariants for all MapReduce code running within isolated regions, to prevent attacks due to unsafe memory reads and writes. Experimental results on common benchmarks show that VC3 performs well compared with unprotected Hadoop: VC3's average runtime overhead is negligible\u00a0\u2026", "num_citations": "635\n", "authors": ["660"]}
{"title": "Oblivious multi-party machine learning on trusted processors\n", "abstract": " Privacy-preserving multi-party machine learning allows multiple organizations to perform collaborative data analytics while guaranteeing the privacy of their individual datasets. Using trusted SGX-processors for this task yields high performance, but requires a careful selection, adaptation, and implementation of machine-learning algorithms to provably prevent the exploitation of any side channels induced by data-dependent access patterns.", "num_citations": "431\n", "authors": ["660"]}
{"title": "Access Control Based on Execution History.\n", "abstract": " Security is a major, frequent concern in extensible software systems such as Java Virtual Machines and the Common Language Runtime. These systems aim to enable simple, classic applets and also, for example, distributed applications, Web services, and programmable networks, with appropriate security expectations. Accordingly, they feature elaborate constructs and mechanisms for associating rights with code, including a technique for determining the run-time rights of a piece of code as a function of the state of the execution stack. These mechanisms prevent many security holes, but they are inherently partial and they have proved difficult to use reliably. We motivate and describe a new model for assigning rights to code: in short, the run-time rights of a piece of code are determined by examining the attributes of any pieces of code that have run (including their origins) and any explicit requests to augment rights. This historybased model addresses security concerns while avoiding pitfalls. We analyze the model in detail; in particular, we discuss its relation to the stack-based model and to the policies and mechanisms of underlying operating systems, and we consider implementation techniques. In support of the model, we also introduce and implement high-level constructs for security, which should be incorporated in libraries or (even better) in programming languages.", "num_citations": "278\n", "authors": ["660"]}
{"title": "Modern concurrency abstractions for C#\n", "abstract": " Polyphonic C\u266f is an extension of the C\u266f language with new asynchronous concurrency constructs, based on the join calculus. We describe the design and implementation of the language and give examples of its use in addressing a range of concurrent programming problems.", "num_citations": "256\n", "authors": ["660"]}
{"title": "Design and semantics of a decentralized authorization language\n", "abstract": " We present a declarative authorization language that strikes a careful balance between syntactic and semantic simplicity, policy expressiveness, and execution efficiency. The syntax is close to natural language, and the semantics consists of just three deduction rules. The language can express many common policy idioms using constraints, controlled delegation, recursive predicates, and negated queries. We describe an execution strategy based on translation to datalog with constraints, and table-based resolution. We show that this execution strategy is sound, complete, and always terminates, despite recursion and negation, as long as simple syntactic conditions are met.", "num_citations": "206\n", "authors": ["660"]}
{"title": "Private authentication\n", "abstract": " Frequently, communication between two principals reveals their identities and presence to third parties. These privacy breaches can occur even if security protocols are in use; indeed, they may even be caused by security protocols. However, with some care, security protocols can provide authentication for principals that wish to communicate while protecting them from monitoring by third parties. We discuss the problem of private authentication and present two protocols for private authentication of mobile principals. Our protocols allow two mobile principals to communicate when they meet at a location if they wish to do so, without the danger of tracking by third parties. We also present the analysis of one of the protocols in the applied pi calculus. We establish authenticity and secrecy properties. Although such properties are fairly standard, their formulation in the applied pi calculus makes an original use of process\u00a0\u2026", "num_citations": "206\n", "authors": ["660"]}
{"title": "SecPAL: Design and semantics of a decentralized authorization language\n", "abstract": " We present a declarative authorization language. Policies and credentials are expressed using predicates defined by logical clauses, in the style of constraint logic programming. Access requests are mapped to logical authorization queries, consisting of predicates and constraints combined by conjunctions, disjunctions, and negations. Access is granted if the query succeeds against the current database of clauses. Predicates ascribe rights to particular principals, with flexible support for delegation and revocation. At the discretion of the delegator, delegated rights can be further delegated, either to a fixed depth, or arbitrarily deeply.", "num_citations": "193\n", "authors": ["660"]}
{"title": "Fully abstract compilation to JavaScript\n", "abstract": " Many tools allow programmers to develop applications in high-level languages and deploy them in web browsers via compilation to JavaScript. While practical and widely used, these compilers are ad hoc: no guarantee is provided on their correctness for whole programs, nor their security for programs executed within arbitrary JavaScript contexts. This paper presents a compiler with such guarantees. We compile an ML-like language with higher-order functions and references to JavaScript, while preserving all source program properties. Relying on type-based invariants and applicative bisimilarity, we show full abstraction: two programs are equivalent in all source contexts if and only if their wrapped translations are equivalent in all JavaScript contexts. We evaluate our compiler on sample programs, including a series of secure libraries.", "num_citations": "123\n", "authors": ["660"]}
{"title": "Square span programs with applications to succinct NIZK arguments\n", "abstract": " We propose a new characterization of NP using square span programs (SSPs). We first characterize NP as affine map constraints on small vectors. We then relate this characterization to SSPs, which are similar but simpler than Quadratic Span Programs (QSPs) and Quadratic Arithmetic Programs (QAPs) since they use a single series of polynomials rather than 2 or 3.               We use SSPs to construct succinct non-interactive zero-knowledge arguments of knowledge. For performance, our proof system is defined over Type III bilinear groups; proofs consist of just 4 group elements, verified in just 6 pairings. Concretely, using the Pinocchio libraries, we estimate that proofs will consist of 160 bytes verified in less than 6 ms.", "num_citations": "119\n", "authors": ["660"]}
{"title": "Modern Concurrency Abstractions for C#\n", "abstract": " Polyphonic C# is an extension of the C# language with new asynchronous concurrency constructs, based on the join calculus. We describe the design and implementation of the language and give examples of its use in addressing a range of concurrent programming problems.", "num_citations": "114\n", "authors": ["660"]}
{"title": "Stack inspection: Theory and variants\n", "abstract": " Stack inspection is a security mechanism implemented in runtimes such as the JVM and the CLR to accommodate components with diverse levels of trust. Although stack inspection enables the fine-grained expression of access control policies, it has rather a complex and subtle semantics. We present a formal semantics and an equational theory to explain how stack inspection affects program behaviour and code optimisations. We discuss the security properties enforced by stack inspection, and also consider variants with stronger, simpler properties.", "num_citations": "110\n", "authors": ["660"]}
{"title": "Probabilistic relational verification for cryptographic implementations\n", "abstract": " Relational program logics have been used for mechanizing formal proofs of various cryptographic constructions. With an eye towards scaling these successes towards end-to-end security proofs for implementations of distributed systems, we present RF*, a relational extension of F*, a general-purpose higher-order stateful programming language with a verification system based on refinement types. The distinguishing feature of F* is a relational Hoare logic for a higher-order, stateful, probabilistic language. Through careful language design, we adapt the F* typechecker to generate both classic and relational verification conditions, and to automatically discharge their proofs using an SMT solver. Thus, we are able to benefit from the existing features of F*, including its abstraction facilities for modular reasoning about program fragments. We evaluate RF* experimentally by programming a series of cryptographic\u00a0\u2026", "num_citations": "108\n", "authors": ["660"]}
{"title": "Implicit typing \u00e0 la ML for the join-calculus\n", "abstract": " We adapt the Damas-Milner typing discipline to the join-calculus. The main result is a new generalization criterion that extends the polymorphism of ML to join-definitions. We prove the correctness of our typing rules with regard to a chemical semantics. We also relate typed extensions of the core join-calculus to functional languages.", "num_citations": "103\n", "authors": ["660"]}
{"title": "System and method for network topology discovery\n", "abstract": " A system and method for discovering network topology by various switch training and probing methods. Segments are discovered by having computers enter a promiscuous mode and determining from packets sent to a selected computer which computers see which other computers in the network. From the segments, various switch interconnections are determined, by having different computers train switches as to a training address and seeing which computers receive probe packets sent to that training address from another computer. Various training and probing methods are described that locate intermediate segments, deep switches, switch interconnections, and edge and singleton cases. In one implementation, a master computer coordinates the other computers (and devices) in the network to send the training and probing packets, and report on received packets, in order to determine the network topology.", "num_citations": "96\n", "authors": ["660"]}
{"title": "A type discipline for authorization in distributed systems\n", "abstract": " We consider the problem of statically verifying the conformance of the code of a system to an explicit authorization policy. In a distributed setting, some part of the system may be compromised, that is, some nodes of the system and their security credentials may be under the control of an attacker. To help predict and bound the impact of such partial compromise, we advocate logic-based policies that explicitly record dependencies between principals. We propose a conformance criterion, safety despite compromised principals, such that an invalid authorization decision at an uncompromised node can arise only when nodes on which the decision logically depends are compromised. We formalize this criterion in the setting of a process calculus, and present a verification technique based on a type system. Hence, we can verify policy conformance of code that uses a wide range of the security mechanisms found in\u00a0\u2026", "num_citations": "94\n", "authors": ["660"]}
{"title": "Modular code-based cryptographic verification\n", "abstract": " Type systems are effective tools for verifying the security of cryptographic programs. They provide automation, modularity and scalability, and have been applied to large security protocols. However, they traditionally rely on abstract assumptions on the underlying cryptographic primitives, expressed in symbolic models. Cryptographers usually reason on security assumptions using lower level, computational models that precisely account for the complexity and success probability of attacks. These models are more realistic, but they are harder to formalize and automate. We present the first modular automated program verification method based on standard cryptographic assumptions. We show how to verify ideal functionalities and protocols written in ML by typing them against new cryptographic interfaces using F7, a refinement type checker coupled with an SMT-solver. We develop a probabilistic core calculus for\u00a0\u2026", "num_citations": "88\n", "authors": ["660"]}
{"title": "Ethernet topology discovery without network assistance\n", "abstract": " This work addresses the problem of layer 2 topology discovery. Current techniques concentrate on using SNMP to query information from Ethernet switches. In contrast, we present a technique that infers the Ethernet (layer 2) topology without assistance from the network elements by injecting suitable probe packets from the end-systems and observing where they are delivered. We describe the algorithm, formally characterize its correctness and completeness, and present our implementation and experimental results. Performance results show that although originally aimed at the home and small office the techniques scale to much larger networks.", "num_citations": "87\n", "authors": ["660"]}
{"title": "A hierarchy of equivalences for asynchronous calculi\n", "abstract": " We generate a natural hierarchy of equivalences for asynchronous name-passing process calculi from simple variations on Milner and Sangiorgi's definition of weak barbed bisimulation. The \u03c0-calculus, used here, and the join-calculus are examples of such calculi.             We prove that barbed congruence coincides with Honda and Yoshida's reduction equivalence, and with asynchronous labeled bisimulation when the calculus includes name matching, thus closing those two conjectures. We also show that barbed congruence is coarser when only one barb is tested. For the \u03c0-calculus it becomes an odd limit bisimulation, but for the join-calculus it coincides with both fair testing equivalence and with the weak barbed version of Sj\u00f6din and Parrow's coupled simulation.", "num_citations": "87\n", "authors": ["660"]}
{"title": "Secure implementation of channel abstractions\n", "abstract": " Communication in distributed systems often relies on useful abstractions such as channels, remote procedure calls, and remote method invocations. The implementations of these abstractions sometimes provide security properties, in particular through encryption. In this paper we study those security properties, focusing on channel abstractions. We introduce a simple high-level language that includes constructs for creating and using secure channels. The language is a variant of the join-calculus and belongs to the same family as the pi-calculus. We show how to translate the high-level language into a lower-level language that includes cryptographic primitives. In this translation, we map communication on secure channels to encrypted communication on public channels. We obtain a correctness theorem for our translation; this theorem implies that one can reason about programs in the high-level language without\u00a0\u2026", "num_citations": "86\n", "authors": ["660"]}
{"title": "JoCaml: A language for concurrent distributed and mobile programming\n", "abstract": " In these lecture notes, we give an overview of concurrent, distributed, and mobile programming using JoCaml. JoCaml is an extension of the Objective Caml language. It extends OCaml with support for concurrency and synchronization, the distributed execution of programs, and the dynamic relocation of active program fragments during execution.             The programming model of JoCaml is based on the join calculus. This model is characterized by an explicit notion of locality, a strict adherence to local synchronization, and a natural embedding of functional programming \u00e0 la ML. Local synchronization means that messages always travel to a set destination, and can interact only after they reach that destination; this is required for an efficient asynchronous implementation. Specifically, the join calculus uses ML\u2019s function bindings and pattern-matching on messages to express local synchronizations\u00a0\u2026", "num_citations": "85\n", "authors": ["660"]}
{"title": "Smart meter aggregation via secret-sharing\n", "abstract": " We design and prototype protocols for processing smart-meter readings while preserving user privacy. We provide support for computing non-linear functions on encrypted readings, implemented by adapting to our setting efficient secret-sharing-based secure multi-party computation techniques. Meter readings are jointly processed by a (public) storage service and a few independent authorities, each owning an additive share of the readings. For non-linear processing, these parties consume pre-shared materials, produced by an off-line trusted third party. This party never processes private readings; it may be implemented using trusted hardware or somewhat homomorphic encryption. The protocol involves minimal, off-line support from the meters---a few keyed hash computations and no communication overhead.", "num_citations": "83\n", "authors": ["660"]}
{"title": "Cryptographically sound implementations for typed information-flow security\n", "abstract": " In language-based security, confidentiality and integrity policies conveniently specify the permitted flows of information between different parts of a program with diverse levels of trust. These policies enable a simple treatment of security, and they can often be verified by typing. However, their enforcement in concrete systems involves delicate compilation issues. We consider cryptographic enforcement mechanisms for imperative programs with untrusted components. Such programs may represent, for instance, distributed systems connected by some untrusted network. In source programs, security depends on an abstract access-control policy for reading and writing the shared memory. In their implementations, shared memory is unprotected and security depends instead on encryption and signing. We build a translation from well-typed source programs and policies to cryptographic implementations. To establish its\u00a0\u2026", "num_citations": "83\n", "authors": ["660"]}
{"title": "Stack inspection: Theory and variants\n", "abstract": " Stack inspection is a security mechanism implemented in runtimes such as the JVM and the CLR to accommodate components with diverse levels of trust. Although stack inspection enables the fine-grained expression of access control policies, it has rather a complex and subtle semantics. We present a formal semantics and an equational theory to explain how stack inspection affects program behavior and code optimisations. We discuss the security properties enforced by stack inspection, and also consider variants with stronger, simpler properties.", "num_citations": "83\n", "authors": ["660"]}
{"title": "An asynchronous, distributed implementation of mobile ambients\n", "abstract": " We present a first distributed implementation of the Cardelli-Gordon\u2019s ambient calculus. We use Jocaml as an implementation language and we present a formal translation of Ambients into the distributed join calculus, the process calculus associated with Jocaml. We prove the correctness of the translation.", "num_citations": "81\n", "authors": ["660"]}
{"title": "Authentication primitives and their compilation\n", "abstract": " Adopting a programming-language perspective, we study the problem of implementing authentication in a distributed system. We define a process calculus with constructs for authentication and show how this calculus can be translated to a lower-level language using marshaling, multiplexing, and cryptographic protocols. Authentication serves for identity-based security in the source language and enables simplifications in the translation. We reason about correctness relying on the concepts of observational equivalence and full abstraction.", "num_citations": "78\n", "authors": ["660"]}
{"title": "Hiding names: Private authentication in the applied pi calculus\n", "abstract": " We present the analysis of a protocol for private authentication in the applied pi calculus. We treat authenticity and secrecy properties of the protocol. Although such properties are fairly standard, their formulation in the applied pi calculus makes an original use of process equivalences. In addition, we treat identity-protection properties, which are a delicate concern in several recent protocol designs.", "num_citations": "77\n", "authors": ["660"]}
{"title": "Observing and preventing leakage in mapreduce\n", "abstract": " The use of public cloud infrastructure for storing and processing large datasets raises new security concerns. Current solutions propose encrypting all data, and accessing it in plaintext only within secure hardware. Nonetheless, the distributed processing of large amounts of data still involves intensive encrypted communications between different processing and network storage units, and those communications patterns may leak sensitive information. We consider secure implementation of MapReduce jobs, and analyze their intermediate traffic between mappers and reducers. Using datasets that include personal and geographical data, we show how an adversary that observes the runs of typical jobs can infer precise information about their input. We give a new definition of data privacy for MapReduce, and describe two provably-secure, practical solutions. We implement our solutions on top of VC3, a secure\u00a0\u2026", "num_citations": "75\n", "authors": ["660"]}
{"title": "A type discipline for authorization policies\n", "abstract": " Distributed systems and applications are often expected to enforce high-level authorization policies. To this end, the code for these systems relies on lower-level security mechanisms such as, for instance, digital signatures, local ACLs, and encrypted communications. In principle, authorization specifications can be separated from code and carefully audited. Logic programs, in particular, can express policies in a simple, abstract manner.             For a given authorization policy, we consider the problem of checking whether a cryptographic implementation complies with the policy. We formalize authorization policies by embedding logical predicates and queries within a spi calculus. This embedding is new, simple, and general; it allows us to treat logic programs as specifications of code using secure channels, cryptography, or a combination. Moreover, we propose a new dependent type system for verifying\u00a0\u2026", "num_citations": "75\n", "authors": ["660"]}
{"title": "Reviewing the security of trusted software components\n", "abstract": " An analysis tool provides a call path set for reviewing the security of trusted software components during development. By examining the usage of permissions in programs and libraries within a managed execution environment, potential gaps in the security of trusted components may be identified. A call graph generator creates a permission-sensitive call graph. A call graph analyzer evaluates the permission-sensitive call graph to highlight call paths that may present security risks.", "num_citations": "72\n", "authors": ["660"]}
{"title": "SecPAL: Design and semantics of a decentralized authorization language\n", "abstract": " We present a declarative authorization language. Policies and credentials are expressed using predicates defined by logical clauses, in the style of constraint logic programming. Access requests are mapped to logical authorization queries, consisting of predicates and constraints combined by conjunctions, disjunctions, and negations. Access is granted if the query succeeds against the current database of clauses. Predicates ascribe rights to particular principals, with flexible support for delegation and revocation. At the discretion of the delegator, delegated rights can be further delegated, either to a fixed depth, or arbitrarily deeply.Our language strikes a careful balance between syntactic and semantic simplicity, policy expressiveness, and execution efficiency. The syntax is close to natural language, and the semantics consists of just three deduction rules. The language can express many common policy idioms using constraints, controlled delegation, recursive predicates, and negated queries. We describe an execution strategy based on translation to Datalog with constraints and table-based resolution. We show that this execution strategy is sound, complete, and always terminates, despite recursion and negation, as long as simple syntactic conditions are met.", "num_citations": "72\n", "authors": ["660"]}
{"title": "Enhanced security and performance of web applications\n", "abstract": " A client-side enforcement mechanism may allow application security policies to be specified at a server in a programmatic manner. Servers may specify security policies as JavaScript functions included in a page returned by the server and run before other scripts. At runtime, and during initial loading, the functions are invoked by the client on each page modification to ensure the page conforms to the security policy. As such, before a mutation takes effect, the policy may transform that mutation and the code and data of the page. Replicated code execution may take place at both the client and the server where the server runs its own shadow copy of a client-side application in a trusted execution environment so that the server may check that the method calls coming from the client correspond to a correct execution of the client-side application The redundant execution at the client can be untrusted, but serves to\u00a0\u2026", "num_citations": "69\n", "authors": ["660"]}
{"title": "Security authorization queries\n", "abstract": " In an example implementation, a bifurcated security scheme has a first level that does not allow usage of negations and a second level that does permit usage of negations. In another example implementation, an authorization query table maps respective resource-specific operations to respective associated authorization queries. In yet another example implementation, authorization queries are permitted to have negations, but individual assertions are not.", "num_citations": "60\n", "authors": ["660"]}
{"title": "A type discipline for authorization policies\n", "abstract": " Distributed systems and applications are often expected to enforce high-level authorization policies. To this end, the code for these systems relies on lower-level security mechanisms such as digital signatures, local ACLs, and encrypted communications. In principle, authorization specifications can be separated from code and carefully audited. Logic programs in particular can express policies in a simple, abstract manner. We consider the problem of checking whether a distributed implementation based on communication channels and cryptography complies with a logical authorization policy. We formalize authorization policies and their connection to code by embedding logical predicates and claims within a process calculus. We formulate policy compliance operationally by composing a process model of the distributed system with an arbitrary opponent process. Moreover, we propose a dependent type system\u00a0\u2026", "num_citations": "51\n", "authors": ["660"]}
{"title": "{ZQL}: A Compiler for Privacy-Preserving Data Processing\n", "abstract": " ZQL is a query language for expressing simple computations on private data. Its compiler produces code to certify data, perform client-side computations, and verify the correctness of their results. Under the hood, it synthesizes zero-knowledge protocols that guarantee both integrity of the query results and privacy for all other data.", "num_citations": "47\n", "authors": ["660"]}
{"title": "A security-preserving compiler for distributed programs: From information-flow policies to cryptographic mechanisms\n", "abstract": " We enforce information flow policies in programs that run at multiple locations, with diverse levels of security.", "num_citations": "45\n", "authors": ["660"]}
{"title": "Self-certification: Bootstrapping certified typecheckers in F* with Coq\n", "abstract": " Well-established dependently-typed languages like Agda and Coq provide reliable ways to build and check formal proofs. Several other dependently-typed languages such as Aura, ATS, Cayenne, Epigram, F*, F7, Fine, Guru, PCML5, and Ur also explore reliable ways to develop and verify programs. All these languages shine in their own regard, but their implementations do not themselves enjoy the degree of safety provided by machine-checked verification. We propose a general technique called self-certification that allows a typechecker for a suitably expressive language to be certified for correctness. We have implemented this technique for F*, a dependently typed language on the .NET platform. Self-certification involves implementing a typechecker for F* in F*, while using all the conveniences F* provides for the compiler-writer (e.g., partiality, effects, implicit conversions, proof automation, libraries). This\u00a0\u2026", "num_citations": "41\n", "authors": ["660"]}
{"title": "A hierarchy of equivalences for asynchronous calculi\n", "abstract": " We generate a natural hierarchy of equivalences for asynchronous name-passing process calculi from simple variations on Milner and Sangiorgi's definition of weak barbed bisimulation. The \u03c0-calculus, used here, and the join calculus are examples of such calculi. We prove that barbed congruence coincides with Honda and Yoshida's reduction equivalence, and with asynchronous labeled bisimulation when the calculus includes name matching, thus closing those two conjectures. We also show that barbed congruence is coarser when only one barb is tested. For the \u03c0-calculus, it becomes a limit bisimulation, whereas for the join calculus, it coincides with both fair testing equivalence and with the weak barbed version of Sj\u00f6din and Parrow's coupled simulation.", "num_citations": "41\n", "authors": ["660"]}
{"title": "Reliable evidence: Auditability by typing\n", "abstract": " Many protocols rely on audit trails to allow an impartial judge to verify a posteriori some property of a protocol run. However, in current practice the choice of what data to log is left to the programmer\u2019s intuition, and there is no guarantee that it constitutes enough evidence. We give a precise definition of auditability and we show how typechecking can be used to statically verify that a protocol always logs enough evidence. We apply our approach to several examples, including a full-scale auction-like protocol programmed in ML.", "num_citations": "40\n", "authors": ["660"]}
{"title": "Cryptographically sound implementations for communicating processes\n", "abstract": " We design a core language of principals running distributed programs over a public network. Our language is a variant of the pi calculus, with secure communications, mobile names, and high-level certificates, but without any explicit cryptography. Within this language, security properties can be conveniently studied using trace properties and observational equivalences, even in the presence of an arbitrary (abstract) adversary.               With some care, these security properties can be achieved in a concrete setting, relying on standard cryptographic primitives and computational assumptions, even in the presence of an adversary modeled as an arbitrary probabilistic polynomial-time algorithm. To this end, we develop a cryptographic implementation that preserves all properties for all safe programs. We give a series of soundness and completeness results that precisely relate the language to its implementation.", "num_citations": "40\n", "authors": ["660"]}
{"title": "Controlling the delegation of rights\n", "abstract": " The delegation of rights may be controlled in a number of manners. In an example implementation, a delegation authority assertion is formulated with a delegator principle, a delegatee principal, a verb phrase, a resource, and a delagation-directive verb. In another example implementation, a delegation mechanism involving an assertor, a first principal, and a second principal enables a delegation to be specifically controlled. In yet another example implementation, a chained delegation mechanism enables explicit control of a permitted transitive chaining depth.", "num_citations": "38\n", "authors": ["660"]}
{"title": "Security language expressions for logic resolution\n", "abstract": " A security language expresses assertions and authorization queries in a manner that facilitates logic resolution. In an example implementation, assertion syntax and authorization query syntax are described. In another example implementation, checks on the safety of assertions and authorization queries are described. In yet another example implementation, semantics rules are described.", "num_citations": "37\n", "authors": ["660"]}
{"title": "Secure communications processing for distributed languages\n", "abstract": " Communications processing is an important part of distributed language systems with facilities such as RPC (remote procedure call) and RMI (remote method invocation). For security, messages may require cryptographic operations in addition to ordinary marshaling. We investigate a method for wrapping communications processing around an entity with secure local communication, such as a single machine or a protected network. The wrapping extends security properties of local communication to distributed communication. We formulate and analyze the method within a process calculus.", "num_citations": "36\n", "authors": ["660"]}
{"title": "From stack inspection to access control: A security analysis for libraries\n", "abstract": " We present a new static analysis for reviewing the security of libraries for systems, such as JVMs or the CLR, that rely on stack inspection for access control. We describe its implementation for the CLR. Our tool inputs a set of libraries plus a description of the permissions granted to unknown, potentially hostile code. It constructs a permission-sensitive call graph, which can be queried to identify potential security defects. It has been applied to large pre-existing libraries. We also develop a new formal model of the essentials of access control in the CLR (types, classes and inheritance, access modifiers, permissions, and stack inspection). In this model, we state and prove the correctness of the analysis.", "num_citations": "34\n", "authors": ["660"]}
{"title": "Inheritance in the join calculus\n", "abstract": " We design an extension of the join calculus with class-based inheritance. Method calls, locks, and states are handled in a uniform manner, using asynchronous messages. Classes are partial message definitions that can be combined and transformed by means of operators for behavioral and synchronization inheritance. We also give a polymorphic type system that statically enforces basic safety properties. Our language and its type system are compatible with the JoCaml implementation of the join calculus.", "num_citations": "34\n", "authors": ["660"]}
{"title": "Bisimulations in the join-calculus\n", "abstract": " We develop a theory of bisimulation in the join-calculus. We introduce a refined operational model that makes interactions with the environment explicit, and we discuss the impact of the lexical discipline of the join-calculus on its extensional semantics. We propose several formulations of bisimulation and we establish that all formulations yield the same equivalence. We prove that this equivalence is finer than barbed congruence, but that both relations coincide in the presence of name-testing.", "num_citations": "33\n", "authors": ["660"]}
{"title": "Bisimulations in the join-calculus\n", "abstract": " We develop a theory of bisimulations in the join-calculus. We introduce a refined operational model that makes interactions with the environment explicit, and discuss the impact of the lexical scope discipline of the join-calculus on its extensional semantics. We propose several formulations of bisimulation and establish that all formulations yield the same equivalence. We prove that this equivalence is finer than barbed congruence, but that both relations coincide in the presence of name matching.", "num_citations": "29\n", "authors": ["660"]}
{"title": "Code-carrying authorization\n", "abstract": " In authorization, there is often a wish to shift the burden of proof to those making requests, since they may have more resources and more specific knowledge to construct the required proofs. We introduce an extreme instance of this approach, which we call Code-Carrying Authorization (CCA). With CCA, access-control decisions can partly be delegated to untrusted code obtained at run-time. The dynamic verification of this code ensures the safety of authorization decisions. We define and study this approach in the setting of a higher-order spi calculus. The type system of this calculus provides the needed support for static and dynamic verification.", "num_citations": "28\n", "authors": ["660"]}
{"title": "Vc3: Trustworthy data analytics in the cloud\n", "abstract": " We present VC3, the first system that allows users to run distributed MapReduce computations in the cloud while keeping their code and data secret, and ensuring the correctness and completeness of their results. VC3 runs on unmodified Hadoop, but crucially keeps Hadoop, the operating system and the hypervisor out of the TCB; thus, confidentiality and integrity are preserved even if these large components are compromised. VC3 relies on SGX processors to isolate memory regions on individual computers, and to deploy new protocols that secure distributed MapReduce computations. VC3 optionally enforces region self-integrity invariants for all MapReduce code running within isolated regions, to prevent attacks due to unsafe memory reads and writes. Experimental results on common benchmarks show that VC3 performs well compared with unprotected Hadoop: VC3\u2019s average runtime overhead is negligible for its base security guarantees, 4.5% with write integrity and 8% with read/write integrity.", "num_citations": "27\n", "authors": ["660"]}
{"title": "Principles and Applications of Refinement Types.\n", "abstract": " A refinement type {x: T| C} is the subset of the type T consisting of the values x to satisfy the formula C. In this tutorial article we explain the principles of refinement types by developing from first principles a concurrent \u03bb-calculus whose type system supports refinement types. Moreover, we describe a series of applications of our refined type theory and of related systems.", "num_citations": "27\n", "authors": ["660"]}
{"title": "CCF: A framework for building confidential verifiable replicated services\n", "abstract": " We present CCF, a framework to build permissioned confidential blockchains. CCF provides a simple programming model of a highly-available data store and a universally-verifiable log that implements a ledger abstraction. CCF leverages trust in a consortium of governing members and in a network of replicated hardware-protected execution environments to achieve high throughput, low latency, strong integrity and strong confidentiality for application data and code executing on the ledger. CCF embeds consensus protocols with Byzantine and crash faulttolerant configurations. All configurations support strong service integrity based on the ledger contents. Even if some replicas are corrupt or their keys are compromised, they can be blamed based on their signed evidence of malicious activity recorded in the ledger. CCF supports transparent, programmable governance where the power of the consortium members is tunable and their activity is similarly recorded in the ledger for full auditability. We are developing an open-source implementation of CCF based on SGX-enabled Azure Confidential Compute, built on top of the Open Enclave SDK. Experimental results show that this implementation achieves throughput/latency tradeoffs up to 3 orders of magnitude better than previous confidential blockchain designs. Its code and documentation are available at https://github. com/Microsoft/CCF.", "num_citations": "26\n", "authors": ["660"]}
{"title": "Inheritance in the join calculus\n", "abstract": " We propose an object-oriented calculus with internal concurrency and class-based inheritance that is built upon the join calculus. Method calls, locks, and states are handled in a uniform manner, using labeled messages. Classes are partial message definitions that can be combined and transformed. We design operators for behavioral and synchronization inheritance. Our model is compatible with the JoCaml implementation of the join calculus.", "num_citations": "26\n", "authors": ["660"]}
{"title": "Information-flow types for homomorphic encryptions\n", "abstract": " We develop a flexible information-flow type system for a range of encryption primitives, precisely reflecting their diverse functional and security features. Our rules enable encryption, blinding, homomorphic computation, and decryption, with selective key re-use for different types of payloads. We show that, under standard cryptographic assumptions, any well-typed probabilistic program using encryptions is secure that is, computationally non-interferent) against active adversaries, both for confidentiality and integrity. We illustrate our approach using% on classic schemes such as ElGamal and Paillier encryption. We present two applications of cryptographic verification by typing:(1) private search on data streams; and (2) the bootstrapping part of Gentry's fully homomorphic encryption. We provide a prototype typechecker for our system.", "num_citations": "22\n", "authors": ["660"]}
{"title": "Automatically securing distributed applications\n", "abstract": " A processing system for distributed multi-tier applications is provided. The system includes a server component that executes a replica of a client-side application, where a client component executes the client-side application. The client component captures events from the client-side application and transmits the events to the replica to validate the computational integrity security of the application.", "num_citations": "21\n", "authors": ["660"]}
{"title": "Computational secrecy by typing for the pi calculus\n", "abstract": " We define and study a distributed cryptographic implementation for an asynchronous pi calculus. At the source level, we adapt simple type systems designed for establishing formal secrecy properties. We show that those secrecy properties have counterparts in the implementation, not formally but at the level of bitstrings, and with respect to probabilistic polynomial-time active adversaries. We rely on compilation to a typed intermediate language with a fixed scheduling strategy. While we exploit interesting, previous theorems for that intermediate language, our result appears to be the first computational soundness theorem for a standard process calculus with mobile channels.", "num_citations": "20\n", "authors": ["660"]}
{"title": "Secure enforcement for global process specifications\n", "abstract": " Distributed applications may be specified as parallel compositions of processes that summarize their global interactions and hide local implementation details. These processes define a fixed protocol (also known as a contract, or a session) which may be used for instance to compile or verify code for these applications.               Security is a concern when the runtime environment for these applications is not fully trusted. Then, parts of their implementation may run on remote, corrupted machines, which do not comply with the global process specification. To mitigate this concern, one may write defensive implementations that monitor the application run and perform cryptographic checks. However, hand crafting such implementations is ad hoc and error-prone.               We develop a theory of secure implementations for process specifications. We propose a generic defensive implementation scheme, relying on\u00a0\u2026", "num_citations": "18\n", "authors": ["660"]}
{"title": "Compiling information-flow security to minimal trusted computing bases\n", "abstract": " Information-flow policies can express strong security requirements for programs run by distributed parties with different levels of trust. However, this security is hard to preserve as programs get compiled to distributed systems with (potentially) compromised machines. For instance, many programs involve computations too sensitive to be trusted to any of those machines. Also, many programs are not perfectly secure (non-interferent); as they selectively endorse and declassify information, their relative security becomes harder to preserve.             We develop a secure compiler for distributed information flows. To minimize trust assumptions, we rely on cryptographic protection, and we exploit hardware and software mechanisms available on modern architectures, such as secure boots, trusted platform modules, and remote attestation.             We present a security model for these mechanisms in an imperative\u00a0\u2026", "num_citations": "17\n", "authors": ["660"]}
{"title": "Trusted execution within a distributed computing system\n", "abstract": " Methods for enforcing confidentiality and integrity of code and data while running the code over the data in a distributed computing system are described. In an embodiment each machine which processes data within the system provides a secure sub-system which is protected from other parts of the machine and which receives encrypted data and encrypted code, processes the data using the received code and outputs encrypted data. When establishing the secure sub-systems, keys are exchanged between the client and secure sub-systems and the secure sub-systems provide an attestation confirming the identity of the code running in the secure sub-systems and confirming that the code is running on genuine secure sub-systems. In another embodiment a data-flow computation system is described in which chunks of input data, each comprising an identifier, are authenticated/encrypted. The identifiers are used\u00a0\u2026", "num_citations": "13\n", "authors": ["660"]}
{"title": "Security assertion revocation\n", "abstract": " Security assertion revocation enables a revocation granularity in a security scheme down to the level of individual assertions. In an example implementation, a security token includes multiple respective assertions that are associated with multiple respective assertion identifiers. More specifically, each individual assertion is associated with at least one individual assertion identifier.", "num_citations": "13\n", "authors": ["660"]}
{"title": "The Join-Calculus Language\u2013Release 1.05\n", "abstract": " The distributed implementation of the join-calculus is copyright c 1997 Institut National de Recherche en Informatique et en Automatique (INRIA). INRIA holds all ownership rights to the join-calculus language system. See the le LICENSE in the distribution for licensing information. The join-calculus system can be freely copied, but not sold. More precisely, INRIA grants any user of the join-calculus language system the right to reproduce it, provided that the copies are distributed free of charge and under the conditions given in the LICENSE le. The present documentation is distributed under the same conditions. The join-calculus system uses Objective Caml. See the le LICENSE in the Objective Caml distribution for its licensing information.", "num_citations": "13\n", "authors": ["660"]}
{"title": "Security language translations with logic resolution\n", "abstract": " Security language constructs may be translated into logic language constructs and vise versa. Logic resolution may be effected using, for example, the logic language constructs. In an example implementation, translation of a security language assertion into at least one logic language rule is described. In another example implementation, translation of a proof graph reflecting a logic language into a proof graph reflecting a security language is described. In yet another example implementation, evaluation of a logic language program using a deterministic algorithm is described.", "num_citations": "12\n", "authors": ["660"]}
{"title": "A certified compiler for verifiable computing\n", "abstract": " In cryptology, verifiable computing aims at verifying the remote execution of a program on an untrusted machine, based on its I/O and constant-sized evidence collected during its execution. Recent cryptographic schemes and compilers enable practical verifiable computations for some programs written in C, but their soundness with regards to C semantics remains informal and poorly understood. We present the first certified, semantics-preserving compiler for verifiable computing. Based on CompCert and developed in Coq, our compiler targets an architecture whose instructions consist solely of quadratic equations over a large finite field, amenable to succinct verification using the Pinocchio cryptographic scheme. We explain how to encode the integer operations of a C program first to quadratic equations, then to a single cryptographically-checkable polynomial test. We formally prove that, when compilation\u00a0\u2026", "num_citations": "11\n", "authors": ["660"]}
{"title": "Security programming with refinement types and mobile proofs\n", "abstract": " Several recent papers develop lightweight refinement type systems for ML-like languages and use them to verify the security of distributed programs. In these languages, logical formulas flexibly express policies for confidentiality, integrity, and access control. Typechecking can then automatically verify programs meant to enforce these policies; this involves constructing (or checking) a proof for each of their logical refinement obligations. These type systems offer diverse flavors of erasure for refinements and their proofs. In source programs, refinement formulas may be weakened by subtyping, to enable code reuse in less demanding contexts. After typechecking, most proofs may be erased for efficiency. Others may be replaced with cryptographic evidence. Still, some proofs must be kept at runtime, so that they may be communicated, stored, and re-checked by other programs. We propose FERN, a core typed lambda\u00a0\u2026", "num_citations": "10\n", "authors": ["660"]}
{"title": "A top-down look at a secure message\n", "abstract": " In ongoing work, we are investigating the design of secure distributed implementations of high-level process calculi (in particular, of the join-calculus). We formulate implementations as translations to lower-level languages with cryptographic primitives. Cryptographic protocols are essential components of those translations. In this paper we discuss basic cryptographic protocols for transmitting a single datum from one site to another. We explain some sufficient correctness conditions for these protocols. As an example, we present a simple protocol and a proof of its correctness.", "num_citations": "10\n", "authors": ["660"]}
{"title": "i-mirror: A software managed die-stacked dram-based memory subsystem\n", "abstract": " This paper presents an operating system managed die-stacked DRAM called i-MIRROR that mirrors high locality pages from off-chip DRAM. Optimizing the problems of reducing cache tag area, reducing transfer bandwidth and improving hit latency altogether while using die-stacked DRAM as hardware cache is extremely challenging. In this paper, we show that performance and energy efficiency can be obtained by software management of die-stacked DRAM, which eliminates the need for tags, the source of aforementioned problems. In the proposed scheme, the operating system loads pages from disks to die-stacked DRAM on a page fault at the same time as they are loaded to off-chip DRAM. Our scheme maintains the pages in off-chip and die-stacked DRAM in a synchronized/mirrored state by exploiting the parallel loading capability to die-stacked and off-chip DRAM from the disk. This eliminates the need for\u00a0\u2026", "num_citations": "9\n", "authors": ["660"]}
{"title": "A formal implementation of value commitment\n", "abstract": " In an optimistic approach to security, one can often simplify protocol design by relying on audit logs, which can be analyzed a posteriori. Such auditing is widely used in practice, but no formal studies guarantee that the log information suffices to reconstruct past runs of the protocol, in order to reliably detect (and provide evidence of) any cheating. We formalize audit logs for a sample optimistic scheme, the value commitment. It is specified in a pi calculus extended with committable locations, and compiled using standard cryptography to implement secure logs. We show that our distributed implementation either respects the abstract semantics of commitments or, using information stored in the logs, detects cheating by a hostile environment.", "num_citations": "8\n", "authors": ["660"]}
{"title": "Le join-calcul: un calcul pour la programmation r\u00e9partie et mobile\n", "abstract": " Cette these propose un modele de la programmation des systemes repartis. Elle presente le join-calcul, en developpe la theorie, et l'utilise comme noyau d'un langage de programmation. Le join-calcul est un calcul de processus asynchrone avec mobilite de nom. Il peut egalement etre interprete comme une extension parallele d'un petit langage fonctionnel. Sa semantique operationnelle est definie en termes de machines chimiques abstraites, de maniere a decrire une implementation repartie. Par construction, chaque etape du calcul peut s' implementer par l'envoi d'au plus message sur un reseau asynchrone, quelle que soit la repartition du calcul a l'execution. En premiere approximation, la localisation des ressources est donc transparente. Nous explorons plusieurs raffinements du modele, en ajoutant des primitives permettant de controler dynamiquement le placement des ressources et de modeliser des pannes partielles. Nous considerons diverses notions d'equivalence entre processus adaptees aux systemes asynchrones. Ces equivalences sont structurees en une hierarchie dont chaque echelon correspond a un compromis entre finesse de l'equivalence et complexite des preuves. Nous utilisons ces equivalences pour etablir la correction de codages internes au join-calcul, et entre le join-calcul et le pi-calcul.", "num_citations": "8\n", "authors": ["660"]}
{"title": "An implementation of Ambients in JoCAML\n", "abstract": " We relate two models of distributed mobile programming, the distributed join-calculus [6, 5] and the ambient calculus [3]. Technically, these two models have a lot in common. They consist of name-passing process calculi in the spirit of the-calculus. They make explicit the spatial structure of the computation by distributing processes over a tree of nested locations (aka ambients) that stand for both machines and agents. They provide some mechanism to rearrange the location tree as part of the computation, thereby describing agent migration. Still, these two models address different aspects of wide-area distributed computations, and thus yield different interpretations of locality. In the join-calculus, locality is transparent; it may affect performances, and even behavior in case of partial failure, but otherwise it does not affect communication and migration capabilities. Much as in a distributed object system, locations can communicate with one another as soon as they have access to names of their interfaces, independently of their respective positions in the location tree. To retain a realistic programming model, interaction between locations is restricted to the asynchronous", "num_citations": "7\n", "authors": ["660"]}
{"title": "Expressive synchronization types for inheritance in the join calculus\n", "abstract": " In prior work, Fournet et al. proposed an extension of the join calculus with class-based inheritance, aiming to provide a precise semantics for concurrent objects. However, as we show here, their system suffers from several limitations, which make it inadequate to form the basis of a practical implementation.               In this paper, we redesign the static semantics for inheritance in the join calculus, equipping class types with more precise information. Compared to previous work, the new type system is more powerful, more expressive and simpler. Additionally, one runtime check of the old system is suppressed in the new design. We also prove the soundness of the new system, and have implemented type inference.", "num_citations": "6\n", "authors": ["660"]}
{"title": "Multi-stakeholder media provenance management to counter synthetic media risks in news publishing\n", "abstract": " The rise of indirect content distribution via third party social media platforms has introduced a new conduit for synthetic or manipulated content. That content purports to be legitimate news, or to come from legitimate news sources, and can present the consumer with apparent brand integrity markings, which convey authority.Three major global news organizations and a leading technology provider have come together to demonstrate a mechanism to tackle this problem that can operate at scale. The BBC, The New York Times Company, and CBC/Radio-Canada in cooperation with Microsoft have developed a proposed open standards approach which can be used by large and small news organizations to protect the provenance of news stories in audio/visual/textual media.", "num_citations": "5\n", "authors": ["660"]}
{"title": "Privacy-preserving machine learning\n", "abstract": " A multi-party privacy-preserving machine learning system is described which has a trusted execution environment comprising at least one protected memory region. An code loader at the system loads machine learning code, received from at least one of the parties, into the protected memory region. A data uploader uploads confidential data, received from at least one of the parties, to the protected memory region. The trusted execution environment executes the machine learning code using at least one data-oblivious procedure to process the confidential data and returns the result to at least one of the parties, where a data-oblivious procedure is a process where any patterns of memory accesses, patterns of disk accesses and patterns of network accesses are such that the confidential data cannot be predicted from the patterns.", "num_citations": "4\n", "authors": ["660"]}
{"title": "SGX-enabled oblivious machine learning\n", "abstract": " SGX-Enabled Oblivious Machine Learning - CISPA CISPA Home About Browse Data Privacy Policy Impressum Login SGX-Enabled Oblivious Machine Learning Ohrimenko, Olga and Costa, Manuel and Fournet, C\u00e9dric and Nowozin, Sebastian and Mehta, Aastha and Schuster, Felix and Vaswani, Kapil (2016) SGX-Enabled Oblivious Machine Learning. In: Proceedings of the 25th USENIX Security Symposium (USENIX Security '16). Conference: USENIX-Security Usenix Security Symposium Full text not available from this repository. Item Type: Conference or Workshop Item (A Paper) (Paper) Additional Information: pub_id: 1011 Bibtex: ohrimenko_sgx:16 URL date: None Uncontrolled Keywords: security Divisions: Unspecified Conference: USENIX-Security Usenix Security Symposium Depositing User: Sebastian Weisgerber Date Deposited: 26 Jul 2017 10:32 Last Modified: 18 Jul 2019 12:08 Primary Research Area\u2026", "num_citations": "4\n", "authors": ["660"]}
{"title": "Cryptographic soundness for program verification by typing\n", "abstract": " Type systems are effective tools for verifying the security of cryptographic protocols and implementations. They provide automation, modularity and scalability, and have been applied to large security protocols and applications. However, they traditionally rely on abstract assumptions on the underlying cryptographic primitives, expressed in symbolic models.", "num_citations": "4\n", "authors": ["660"]}
{"title": "Trustworthy global computing: Third symposium, TGC 2007, Sophia-Antipolis, France, November 5-6, 2007, revised selected papers\n", "abstract": " This book constitutes the thoroughly refereed post-conference proceedings of the Third Symposium on Trustworthy Global Computing, TGC 2007; it also contains tutorials from the adjacent Workshop on the Interplay of Programming Languages and Cryptography.", "num_citations": "4\n", "authors": ["660"]}
{"title": "The JoCaml language beta release\n", "abstract": " The JoCaml system is an attempt to provide all join-calculus constructs for concurrency, communication, synchronization and process mobility directly as a syntactical extension of the Objective Caml language (version 1.07). Consequently, this manual does not describe the Objective CAML part of the system, which is available in a separate manual, but only how to use the JoCaml system with some knowledge of the Objective CAML system. Basically, the Join-Calculus is a special library with which Objective-Caml programs must be linked to use Join constructs. Even if the native code compiler is incorporated in the distribution, the\\join\" library is only available in bytecode. However, the JoCaml system enables programs to run both native code and bytecode in a same runtime, with some limitations. Finally, any question or bug report for any part of the distribution should be sent to jocamldev@ inria. fr, and not to any\u00a0\u2026", "num_citations": "4\n", "authors": ["660"]}
{"title": "AMP: authentication of media via provenance\n", "abstract": " Advances in graphics and machine learning have led to the general availability of easy-to-use tools for modifying and synthesizing media. The proliferation of these tools threatens to cast doubt on the veracity of all media. One approach to thwarting the flow of fake media is to detect modified or synthesized media through machine learning methods. While detection may help in the short term, we believe that it is destined to fail as the quality of fake media generation continues to improve. Soon, neither humans nor algorithms will be able to reliably distinguish fake versus real content. Thus, pipelines for assuring the source and integrity of media will be required---and increasingly relied upon. We present AMP, a system that ensures the authentication of media via certifying provenance. AMP creates one or more publisher-signed manifests for a media instance uploaded by a content provider. These manifests are\u00a0\u2026", "num_citations": "3\n", "authors": ["660"]}
{"title": "Data center privacy\n", "abstract": " A data center has a plurality of secure processing units; a plurality of data stores holding encrypted data records; and a network connecting the secure processing units and the data stores. The secure processing units comprise computing functionality configured to execute a data processing operation in parallel on the secure processing units by being configured to read encrypted records from the stores, process one or more of the encrypted records within the secure processing units, send one or more of the encrypted records to the stores. The data center is configured to carry out a secret shuffle of the data records to protect the privacy of data processed in the data center from an observer observing any one or more of: the reading of the records, the sending of the records, the writing of the records; the secret shuffle comprising a random permutation of the records hidden from the observer.", "num_citations": "3\n", "authors": ["660"]}
{"title": "Building secure SGX enclaves using F*, C/C++ and X64\n", "abstract": " Intel SGX offers hardware mechanisms to isolate code and data running within enclaves from the rest of the platform. This enables security verification on a relatively small software TCB, but the task still involves complex low-level code. Relying on the Everest verification toolchain, we use F\u2217 for developing specifications, code, and proofs; and then safely compile F\u2217 code to standalone C code. However, this does not account for all code running within the enclave, which also includes trusted C and assembly code for bootstrapping and for core libraries. Besides, we cannot expect all enclave applications to be rewritten in F\u2217, so we also compile legacy C++ defensively, using variants of/guard that dynamically enforce their safety at runtime. To reason about enclave security, we thus compose different sorts of code and verification styles, from fine-grained statically-verified F\u2217 to dynamically-monitored C++ and custom SGX instructions. This involves two related program semantics: most of the verification is conducted within F\u2217 using the target semantics of Kremlin\u2014a fragment of C with a structured memory\u2014whereas SGX features and dynamic checks embedded by defensive C++ compilers require lowerlevel X64 code, for which we use the verified assembly language for Everest (VALE) and its embedding in F\u2217.", "num_citations": "3\n", "authors": ["660"]}
{"title": "Cryptographically Verified Design and Implementation of a Distributed Key Manager\n", "abstract": " We present DKM, a distributed key management system with a cryptographically verified code base. DKM implements a new data protection API. It manages keys and policies on behalf of groups of users that share data. To ensure long-term protection, DKM supports cryptographic agility: algorithms, keys, and policies can evolve for protecting fresh data while preserving access to old data. DKM is written in C# and currently used by several large data-center applications. To verify our design and implementation, we also write a lightweight reference implementation of DKM in F#. This code closes the gap between formal cryptographic models and production code:", "num_citations": "2\n", "authors": ["660"]}
{"title": "Modular cryptographic verification by typing\n", "abstract": " Modularity in programming through the use of well defined interfaces serves the same goals as secure composition in cryptography. The intuition is that modules that export the same programming interface, as well as modules that implement the same cryptographic functionality, should be interchangeable with respect to the properties of the rest of the system, both in a programming and in a cryptographic sense. We develop a cryptographic verification method based on modular programming and typechecking. We use a composition theorem in the simulation-based security flavor to reason about mutually-replaceable modules in a cryptographic sense. We use refinement types to reason about the preservation of properties as we replace modules behind typed interfaces.Protocol modularity To reason about large software systems that rely on cryptographic algorithms, we need modularity both for programming and for cryptography. We first reason cryptographically about an ideal functionality that is emulated by a particular cryptographic module, much as with universal composability or reactive simulatability [6, 1]. We then replace the real module of the protocol by an ideal module. We repeat this until all modules are ideal. The ideal modules can be shown to export interfaces that allow us to reason about the security properties of the whole program. In a second step, we check the security of the whole program purely using typing, or other static program analyses, adapted from symbolic techniques for protocol verification [3, 5]. We illustrate our approach on variants of the code of a sample protocol for authenticating remote procedure calls (RPC\u00a0\u2026", "num_citations": "2\n", "authors": ["660"]}
{"title": "On the computational soundness of cryptographic verification by typing\n", "abstract": " Type systems are effective tools for establishing the security of cryptographic protocols and their implementations. They offer modularity and scalability, and have been successfully applied to the verification of large protocols and applications [eg Bhargavan et al., 2009]. However, they traditionally rely on abstract assumptions on cryptographic primitives, expressed in symbolic models. In this talk, I present recent and ongoing work on designing (and adapting) type systems to rely instead on computational assumptions [Abadi et al., 2006, Fournet and Rezk, 2008]. These results and others [eg Laud, 2005, 2008] suggest that typing can be just as effective under more standard and realistic hypotheses. In particular, I plan to demo the automated verification of protocols written in ML by typing against a cryptographic interface, using the F7 refinement-type checker [Bengtson et al., 2008, Bhargavan et al., 2008]. For each cryptographic library, the computational soundness of typechecking follows from a code-based game-hopping argument between different ML implementations of the same interface, according to standard assumptions such as IND-CCA2 or INT-CMA.", "num_citations": "2\n", "authors": ["660"]}
{"title": "Variable Expressions in Security Assertions\n", "abstract": " A security scheme enables control over variables that are expressed in security assertions. In an example implementation, a security type is implicitly assigned to variables based on their syntactic position within a given assertion. In another example implementation, a security scheme enforces strong variable typing such that each variable in an assertion binds to only a single security type. In yet another example implementation, a security scheme constrains the binding behavior of two variables with respect to each other.", "num_citations": "2\n", "authors": ["660"]}
{"title": "High-level programming for e-cash\n", "abstract": " We consider symbolic characterizations of the Compact E-Cash protocol of Camenisch, Hohenberger, and Lysyanskaya [CHL05]. E-cash protocols [Cha82, CFN88] aim at providing robust abstractions for anonymous payment protocols. Properties of interest include, for instance, that users can spend coins anonymously, that users cannot forge coins, and that user should not spend the same coin twice without being eventually caught. These protocols involve sophisticated cryptographic constructions. Relying on recent work on optimistic value commitment [FGN08], we design a calculus with E-cash primitives. Our calculus has a simple, symbolic semantics; it can be used for programming with E-cash and for reasoning on its properties, while shielding the programmer from its cryptographic implementation. We consider two variants of the symbolic semantics. An abstract semantics rules out any double spending (by design). A more realistic, intermediate semantics accounts for the possibility of double spending, with reliable detection. We first relate these two semantics, then relate the intermediate semantics to the computational properties of the underlying E-cash protocol.", "num_citations": "1\n", "authors": ["660"]}
{"title": "Modular optimized subtransmission and distribution substations based on a functional analysis\n", "abstract": " This paper shows how a functional analysis can lead to the design of a new kind of switchgear, and to imagine new substation arrangements. It describes how the concept of combined circuit breaker/disconnector has been homologated.", "num_citations": "1\n", "authors": ["660"]}