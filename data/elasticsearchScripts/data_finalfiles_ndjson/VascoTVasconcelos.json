{"title": "Language primitives and type discipline for structured communication-based programming\n", "abstract": " We introduce basic language constructs and a type discipline as a foundation of structured communication-based concurrent programming. The constructs, which are easily translatable into the summation-less asynchronous \u03c0-calculus, allow programmers to organise programs as a combination of multiple flows of (possibly unbounded) reciprocal interactions in a simple and elegant way, subsuming the preceding communication primitives such as method invocation and rendez-vous. The resulting syntactic structure is exploited by a type discipline \u00e0 la ML, which offers a high-level type abstraction of interactive behaviours of programs as well as guaranteeing the compatibility of interaction patterns between processes in a well-typed program. After presenting the formal semantics, the use of language constructs is illustrated through examples, and the basic syntactic results of the type discipline are\u00a0\u2026", "num_citations": "1029\n", "authors": ["668"]}
{"title": "Linear type theory for asynchronous session types\n", "abstract": " Session types support a type-theoretic formulation of structured patterns of communication, so that the communication behaviour of agents in a distributed system can be verified by static typechecking. Applications include network protocols, business processes and operating system services. In this paper we define a multithreaded functional language with session types, which unifies, simplifies and extends previous work. There are four main contributions. First is an operational semantics with buffered channels, instead of the synchronous communication of previous work. Second, we prove that the session type of a channel gives an upper bound on the necessary size of the buffer. Third, session types are manipulated by means of the standard structures of a linear type theory, rather than by means of new forms of typing judgement. Fourth, a notion of subtyping, including the standard subtyping relation for session\u00a0\u2026", "num_citations": "206\n", "authors": ["668"]}
{"title": "Language primitives and type discipline for structured communication-based programming revisited: Two systems for higher-order session communication\n", "abstract": " Session primitives and types provide a flexible programming style for structured interaction, and are used to statically check the safe and consistent composition of protocols in communication-centric distributed software. Unfortunately authors working on session types have recently realised that some of the previously published systems fail to satisfy the basic theorems of Subject Reduction and Type Safety.This report discusses the issues involved in higher-order session communication, presents a formulation of the recursive types as well as proofs of the Subject Reduction and Type Safety Theorems of the original session typing system by Honda-Vasconcelos-Kubo in ESOP'98. It also proposes a variant which allows a more liberal higher-order session communication, based on an idea of Gay and Hole.", "num_citations": "191\n", "authors": ["668"]}
{"title": "Foundations of session types and behavioural contracts\n", "abstract": " Behavioural type systems, usually associated to concurrent or distributed computations, encompass concepts such as interfaces, communication protocols, and contracts, in addition to the traditional input/output operations. The behavioural type of a software component specifies its expected patterns of interaction using expressive type languages, so types can be used to determine automatically whether the component interacts correctly with other components. Two related important notions of behavioural types are those of session types and behavioural contracts. This article surveys the main accomplishments of the last 20 years within these two approaches.", "num_citations": "187\n", "authors": ["668"]}
{"title": "Typed concurrent objects\n", "abstract": " Based on a name-passing calculus and on its typing system the paper shows how to build several language constructors towards a strongly-typed object-oriented concurrent programming language. The basic calculus incorporates the notions of asynchronous labelled messages, concurrent objects composed of labelled methods, and a form of abstraction on processes allowing in particular to declare polymorphic classes. We introduce a notion of values as name-expressions, and show how to create subclasses of existing classes. A systematic translation of the derived constructors into the basic calculus provides for semantics and for typing rules for the new constructors.", "num_citations": "172\n", "authors": ["668"]}
{"title": "Secure information flow as typed process behaviour\n", "abstract": " We propose a new type discipline for the \u03c0-calculus in which secure information flow is guaranteed by static type checking. Secrecy levels are assigned to channels and are controlled by subtyping. A behavioural notion of types capturing causality of actions plays an essential role for ensuring safe information flow in diverse interactive behaviours, making the calculus powerful enough to embed known calculi for type-based security. The paper introduces the core part of the calculus, presents its basic syntactic properties, and illustrates its use as a tool for programming language analysis by a sound embedding of a secure multi-threaded imperative calculus of Volpano and Smith. The embedding leads to a practically meaningful extension of their original type discipline.", "num_citations": "170\n", "authors": ["668"]}
{"title": "Principal typing schemes in a polyadic \u03c0-calculus\n", "abstract": " The present paper introduces a typing system for a version of Milner's polyadic \u03c0-calculus, and a typing inference algorithm linear on the size of the input. The central concept underlying the typing system is the notion of type assignment, where each free name in a term is assigned a type, the term itself being given multiple nametype pairs. This observation leads to a clean typing system for Milner's sorting, and induces an efficient algorithm to infer the typing of a term. The typing system enjoys a subject-reduction property and possesses a notion of principal typing scheme. The algorithm to reconstruct the principal typing scheme of a process, or to detect its inexistence, is proved correct with respect to the typing system.", "num_citations": "142\n", "authors": ["668"]}
{"title": "Type checking a multithreaded functional language with session types\n", "abstract": " We define a language whose type system, incorporating session types, allows complex protocols to be specified by types and verified by static type checking. A session type, associated with a communication channel, specifies the state transitions of a protocol and also the data types of messages associated with transitions; thus type checking can verify both correctness of individual messages and correctness of sequences of transitions. Previously, session types have mainly been studied in the context of the \u03c0-calculus; instead, our formulation is based on a multithreaded functional language with side-effecting input/output operations. Our typing judgements statically describe dynamic changes in the types of channels, and our function types not only specify argument and result types but also describe changes in channels. We formalize the syntax, semantics and type checking system of our language, and prove\u00a0\u2026", "num_citations": "125\n", "authors": ["668"]}
{"title": "Modular session types for distributed object-oriented programming\n", "abstract": " Session types allow communication protocols to be specified type-theoretically so that protocol implementations can be verified by static type-checking. We extend previous work on session types for distributed object-oriented languages in three ways. (1) We attach a session type to a class definition, to specify the possible sequences of method calls. (2) We allow a session type (protocol) implementation to be modularized , i.e. partitioned into separately-callable methods. (3) We treat session-typed communication channels as objects, integrating their session types with the session types of classes. The result is an elegant unification of communication channels and their session types, distributed object-oriented programming, and a form of typestates supporting non-uniform objects, i.e. objects that dynamically change the set of available methods. We define syntax, operational semantics, a sound type system, and a\u00a0\u2026", "num_citations": "124\n", "authors": ["668"]}
{"title": "Disciplining orchestration and conversation in service-oriented computing\n", "abstract": " We give a formal account of a calculus for modeling service-based systems, suitable to describe both service composition (orchestration) and the protocol that services run when invoked (conversation). The calculus includes primitives for defining and invoking services, for isolating conversations between clients and servers, and for orchestrating services. The calculus is equipped with a reduction and a labeled transition semantics related by an equivalence result. To hint how the structuring mechanisms of the language can be exploited for static analysis we present a simple type system guaranteeing the compatibility between client and server protocols, an application of bisimilarity to prove equivalence among services, and we discuss deadlock-avoidance.", "num_citations": "115\n", "authors": ["668"]}
{"title": "Fundamentals of session types\n", "abstract": " We present a reconstruction of session types in a linear pi calculus where types are qualified as linear or unrestricted. Linearly qualified communication channels are guaranteed to occur in exactly one thread, possibly multiple times; unrestricted (or shared) channels may appear in an unbounded number of threads. In our language each channel is characterized by two distinct variables, one used for reading, the other for writing; scope restriction binds together two variables, thus establishing the correspondence between the two ends of the same channel. This mechanism allows a precise control of resources via a conventional linear type system. Furthermore, the uniform treatment of linear and shared channels leads to a surprisingly simply theory which, in addition, extends typability when compared to traditional systems for session types. We build the language gradually, starting from simple input/output, then\u00a0\u2026", "num_citations": "114\n", "authors": ["668"]}
{"title": "A typing system for a calculus of objects\n", "abstract": " The present paper introduces an implicitly typed object calculus intended to capture intrinsic aspects of concurrent objects communicating via asynchronous message passing, together with a typing system assigning typings to terms in the calculus. Types meant to describe the kind of messages an object may receive are assigned to the free names in a program, resulting in a scenario where a program is assigned multiple name-type pairs, constituting a typing for the process. Programs that comply to the typing discipline are shown not to suffer from runtime errors. Furthermore the calculus possesses a notion of principal typings, from which all typings that make a program well-typed can be extracted. We present an efficient algorithm to extract the principal typing of a process.", "num_citations": "97\n", "authors": ["668"]}
{"title": "Session types for inter-process communication\n", "abstract": " We define a language whose type system, incorporating session types, allows complex protocols to be specified by types and verified by static typechecking. A session type, associated with a communication channel, specifies not only the data types of individual messages, but also the state transitions of a protocol and hence the allowable sequences of messages. Although session types are well understood in the context of the \u03c0-calculus, our formulation is based on \u03bb-calculus with side-effecting input/output operations and is different in significant ways. Our typing judgements statically describe dynamic changes in the types of channels, our channel types statically track aliasing, and our function types not only specify argument and result types but also describe changes in channel types. After formalising the syntax, semantics and typing rules of our language, and proving a subject reduction theorem, we outline some possibilities for extending this work to a concurrent object-oriented language.", "num_citations": "83\n", "authors": ["668"]}
{"title": "Session types for functional multithreading\n", "abstract": " We define a language whose type system, incorporating session types, allows complex protocols to be specified by types and verified by static typechecking. A session type, associated with a communication channel, specifies the state transitions of a protocol and also the data types of messages associated with transitions; thus typechecking can verify both correctness of individual messages and correctness of sequences of transitions. Previously session types have mainly been studied in the context of the \u03c0-calculus; instead, our formulation is based on a multi-threaded functional language with side-effecting input/output operations. Our typing judgements statically describe dynamic changes in the types of channels, our channel types statically track aliasing, and our function types not only specify argument and result types but also describe changes in channels. We formalize the syntax, semantics and\u00a0\u2026", "num_citations": "66\n", "authors": ["668"]}
{"title": "Typing non-uniform concurrent objects\n", "abstract": " Concurrent objects may offer services non-uniformly, constraining the acceptance of messages on the states of objects. We advocate a looser view of communication errors. Safe programmes must guarantee that every message has a chance of being received if it requests a method that may become enabled at some point in the future. We formalise non-uniform concurrent objects in TyCO, a name-passing object calculus, and ensure program safety via a type system. Types are terms of a process algebra that describes dynamic aspects of the behaviour of objects.", "num_citations": "54\n", "authors": ["668"]}
{"title": "Protocol-based verification of message-passing parallel programs\n", "abstract": " We present ParTypes, a type-based methodology for the verification of Message Passing Interface (MPI) programs written in the C programming language. The aim is to statically verify programs against protocol specifications, enforcing properties such as fidelity and absence of deadlocks. We develop a protocol language based on a dependent type system for message-passing parallel programs, which includes various communication operators, such as point-to-point messages, broadcast, reduce, array scatter and gather. For the verification of a program against a given protocol, the protocol is first translated into a representation read by VCC, a software verifier for C. We successfully verified several MPI programs in a running time that is independent of the number of processes or other input parameters. This contrasts with alternative techniques, notably model checking and runtime verification, that suffer from the\u00a0\u2026", "num_citations": "53\n", "authors": ["668"]}
{"title": "Fundamentals of session types\n", "abstract": " We present a reconstruction of session types in a linear pi calculus where types are qualified as linear or unrestricted. Linearly qualified communication channels are guaranteed to occur in exactly one thread, possibly multiple times. In our language each channel is characterised by two distinct variables, one used for reading, the other for writing; scope restriction binds together two variables, thus establishing the correspondence between the two ends of a same channel. This mechanism allows a precise control of resources via a linear type system. We build the language gradually, starting from simple input/output, then adding choice, recursive types, replication and finally subtyping. We also present an algorithmic type checking system.", "num_citations": "49\n", "authors": ["668"]}
{"title": "Session typing for a featherweight Erlang\n", "abstract": " As software tends to be increasingly concurrent, the paradigm ofmessage passing is becoming more prominent in computing. The language Erlang offers an intuitive and industry-testedimplementation of process-oriented programming, combining pattern-matching with message mailboxes, resulting in concise, elegant programs. However, it lacks a successful static verification mechanism that ensures safety and determinism of communications with respect to well-defined specifications. We present a session typing system for a featherweight Erlang calculus that encompasses the main communication abilities of the language. In this system, structured types are used to govern the interaction of Erlang processes, ensuring that their behaviour is safe with respect to a defined protocol. The expected properties of subject reduction and type safety are established.", "num_citations": "46\n", "authors": ["668"]}
{"title": "Behavioural types for a calculus of concurrent objects\n", "abstract": " We present a new type system for TyCO, a name-passing calculus of concurrent objects. The system captures dynamic aspects of objects' behaviours, namely non-uniform service availability of active objects. The notion of processes without errors is loosened, demanding only weak fairness in the treatment of messages.", "num_citations": "46\n", "authors": ["668"]}
{"title": "A linear account of session types in the pi calculus\n", "abstract": " We present a reconstruction of session types in a conventional pi calculus where types are qualified as linear or unrestricted. Linearly typed communication channels are guaranteed to occur in exactly one thread, possibly multiple times. We equip types with a constructor that denotes the two ends of a same communication channel. In order to assess the flexibility of the new type system, we provide three distinct encodings (from the linear lambda calculus, from the linear pi calculus, and from the pi calculus with polarized variables) into our system. For each language we present operational and typing correspondences, showing that our system effectively subsumes the linear pi calculus as well as foregoing works on session types.", "num_citations": "43\n", "authors": ["668"]}
{"title": "Type inference for deadlock detection in a multithreaded polymorphic typed assembly language\n", "abstract": " We previously developed a polymorphic type system and a type checker for a multithreaded lock-based polymorphic typed assembly language (MIL) that ensures that well-typed programs do not encounter race conditions. This paper extends such work by taking into consideration deadlocks. The extended type system verifies that locks are acquired in the proper order. Towards this end we require a language with annotations that specify the locking order. Rather than asking the programmer (or the compiler's backend) to specifically annotate each newly introduced lock, we present an algorithm to infer the annotations. The result is a type checker whose input language is non-decorated as before, but that further checks that programs are exempt from deadlocks.", "num_citations": "41\n", "authors": ["668"]}
{"title": "Gradual session types\n", "abstract": " Session types are a rich type discipline, based on linear types, that lift the sort of safety claims that come with type systems to communications. However, web-based applications and micro services are often written in a mix of languages, with type disciplines in a spectrum between static and dynamic typing. Gradual session types address this mixed setting by providing a framework which grants seamless transition between statically typed handling of sessions and any required degree of dynamic typing.   We propose GradualGV as an extension of the functional session type system GV with dynamic types and casts. We demonstrate type and communication safety as well as blame safety, thus extending previous results to functional languages with session-based communication. The interplay of linearity and dynamic types requires a novel approach to specifying the dynamics of the language.", "num_citations": "40\n", "authors": ["668"]}
{"title": "Distribution and mobility with lexical scoping in process calculi\n", "abstract": " We propose a simple model of distribution for mobile processes, independent of the underlying calculus. Conventional processes compute within sites; inter-site computation is achieved by message sending and object migration, both obeying a lexical scope. We focus on the semantics of networks, on programming practice, and on physical realization with current technology.", "num_citations": "34\n", "authors": ["668"]}
{"title": "Checking the conformance of Java classes against algebraic specifications\n", "abstract": " We present and evaluate an approach for the run-time conformance checking of Java classes against property-driven algebraic specifications. Our proposal consists in determining, at run-time, whether the classes subject to analysis behave as required by the specification. The key idea is to reduce the conformance checking problem to the runtime monitoring of contract-annotated classes, a process supported today by several runtime assertion-checking tools. Our approach comprises a rather conventional specification language, a simple language to map specifications into Java types, and a method to automatically generate monitorable classes from specifications, allowing for a simple, but effective, runtime monitoring of both the specified classes and their clients.", "num_citations": "31\n", "authors": ["668"]}
{"title": "A process-calculus approach to typed concurrent objects\n", "abstract": " I propose an untyped name-passing calculus and a series of decidable type systems assigning types to names in terms. The calculus, designed according to the modern trends in name-passing calculi, is intended to capture the basic concepts of concurrent objects. The type systems, developed along the lines of those for-calculi, provide for partial-speci cation in the form of communication protocols for programs, and for partial-correctness wherein typable terms are assured not to run into errors at execution time. Terms are built from names and labels by means of ve constructors, the innovations being guarded labelled-sums describing objects composed of labelled methods and asynchronous labelled messages selecting a method in the target object. The remaining constructors are fairly standard in name-passing calculi and comprise concurrent composition, local name creation (or scope restriction), and replication.The type systems assign types to names, and typings (that is, sets of nametype pairs) to terms. Simple types are built from type-variables by means of a single record constructor that uses the labels in the syntax of the calculus. To realize typing terms containing circular name-structures, a recursive type constructor is introduced, recursive types being viewed as regular (that is, having nitely many subtrees) in nite trees. The main properties of these type systems are subject-reduction (implying that typable terms do not encounter errors at execution time), decidability of typing assignment, and computability of typing inference. Nonetheless, no notion of typing subsumption, and hence of principal typings, seems to be possible in these\u00a0\u2026", "num_citations": "28\n", "authors": ["668"]}
{"title": "Affine sessions\n", "abstract": " Session types describe the structure of protocols from the point of view of each participating channel. In particular, the types describe the type of communicated values, and also the dynamic alternation of input and output actions on the same channel, by which a protocol can be statically verified. Crucial to any term language with session types is the notion of linearity, which guarantees that channels exhibit exactly the behaviour prescribed by their type. We relax the condition of linearity to that of affinity, by which channels exhibit at most the behaviour prescribed by their types. This more liberal setting allows us to incorporate an elegant error handling mechanism which simplifies and improves related works on exceptions. Moreover, our treatment does not affect the progress properties of the language: sessions never get stuck.", "num_citations": "27\n", "authors": ["668"]}
{"title": "Verification of MPI programs using session types\n", "abstract": " Developing safe, concurrent (and parallel) software systems is a hard task in multiple aspects, particularly the sharing of information and the synchronization among multiple participants of the system. In the message passing paradigm, this is achieved by sending and receiving messages among different participants, raising a number of verification problems. For instance, exchanging messages in a wrong order may prevent the system from progressing, causing a deadlock.MPI is the most commonly used protocol for high-performance, message-based parallel programs, and the need for formal verification approaches is well acknowledged by much recent work (e.g., see [1]).", "num_citations": "27\n", "authors": ["668"]}
{"title": "Context-free session types\n", "abstract": " Session types describe structured communication on heterogeneously typed channels at a high level. Their tail-recursive structure imposes a protocol that can be described by a regular language. The types of transmitted values are drawn from the underlying functional language, abstracting from the details of serializing values of structured data types.Context-free session types extend session types by allowing nested protocols that are not restricted to tail recursion. Nested protocols correspond to deterministic context-free languages. Such protocols are interesting in their own right, but they are particularly suited to describe the low-level serialization of tree-structured data in a type-safe way.", "num_citations": "26\n", "authors": ["668"]}
{"title": "A concurrent programming language with refined session types\n", "abstract": " We present SePi, a concurrent programming language based on the monadic pi-calculus, where interaction is governed by linearly refined session types. On top of the core calculus and type system, and in order to facilitate programming, we introduce a number of abbreviations and derived constructs. This paper provides a brief introduction to the language.", "num_citations": "25\n", "authors": ["668"]}
{"title": "Modular session types for objects\n", "abstract": " Session types allow communication protocols to be specified type-theoretically so that protocol implementations can be verified by static type checking. We extend previous work on session types for distributed object-oriented languages in three ways. (1) We attach a session type to a class definition, to specify the possible sequences of method calls. (2) We allow a session type (protocol) implementation to be modularized, i.e. partitioned into separately-callable methods. (3) We treat session-typed communication channels as objects, integrating their session types with the session types of classes. The result is an elegant unification of communication channels and their session types, distributed object-oriented programming, and a form of typestate supporting non-uniform objects, i.e. objects that dynamically change the set of available methods. We define syntax, operational se-mantics, a sound type system, and a sound and complete type checking algorithm for a small distributed class-based object-oriented language with structural subtyping. Static typing guarantees that both sequences of messages on channels, and sequences of method calls on objects, conform to type-theoretic specifications, thus ensuring type-safety. The language includes expected features of session types, such as delegation, and expected features of object-oriented programming, such as encapsulation of local state.", "num_citations": "24\n", "authors": ["668"]}
{"title": "Towards deductive verification of MPI programs against session types\n", "abstract": " The Message Passing Interface (MPI) is the de facto standard message-passing infrastructure for developing parallel applications. Two decades after the first version of the library specification, MPI-based applications are nowadays routinely deployed on super and cluster computers. These applications, written in C or Fortran, exhibit intricate message passing behaviours, making it hard to statically verify important properties such as the absence of deadlocks. Our work builds on session types, a theory for describing protocols that provides for correct-by-construction guarantees in this regard. We annotate MPI primitives and C code with session type contracts, written in the language of a software verifier for C. Annotated code is then checked for correctness with the software verifier. We present preliminary results and discuss the challenges that lie ahead for verifying realistic MPI program compliance against session types.", "num_citations": "24\n", "authors": ["668"]}
{"title": "Lexically scoped distribution: what you see is what you get\n", "abstract": " We define a lexically scoped, asynchronous and distributed \u03c0-calculus, with local communication and process migration. This calculus adopts the network-awareness principle for distributed programming and follows a simple model of distribution for mobile calculi: a lexical scope discipline combines static scoping with dynamic linking, associating channels to a fixed site throughout computation. This discipline provides for both remote invocation and process migration. A simple type system is a straightforward extension of that of the \u03c0-calculus, adapted to take into account the lexical scope of channels. An equivalence law captures the essence of this model: a process behavior depends on the channels it uses, not on where it runs.", "num_citations": "24\n", "authors": ["668"]}
{"title": "A virtual machine for a process calculus\n", "abstract": " Despite extensive theoretical work on process-calculi, virtual machine specifications and implementations of actual computational models are still scarce.             This paper presents a virtual machine for a strongly typed, polymorphic, concurrent, object-oriented programming language based on the TyCO process calculus. The system runs byte-code files, assembled from an intermediate assembly language representation, which is in turn generated by a compiler. Code optimizations are provided by the compiler coupled with a type-inference system. The design and implementation of the virtual machine focuses on performance, compactness, and architecture independence with a view to mobile computing. The assembly code emphasizes readability and efficient byte code generation. The byte code has a simple layout and is a compromise between size and performance. We present some performance\u00a0\u2026", "num_citations": "24\n", "authors": ["668"]}
{"title": "Predicative polymorphism in \u03c0-calculus\n", "abstract": " We present a formulation of the polyadic \u03c0-calculus featuring a syntactic category for agents, together with a typing system assigning polymorphic types to agents. The new presentation introduces an operator to express recursion, and an ML-style let-constructor allowing to associate an agent to an agent-variable, and use the latter several times in a program. The essence of the monomorphic type system is the assignment of types to names, and multiple name-type pairs to programs [14]. The polymorphic type system incorporates a form of abstraction over types, and inference rules allowing to introduce and eliminate the abstraction operator. The extended system preserves most of the syntactic properties of the monomorphic system, including subject-reduction and computability of principal typings. We present an algorithm to extract the principal typing of a process, and prove it correct with respect to the\u00a0\u2026", "num_citations": "24\n", "authors": ["668"]}
{"title": "Typing progress in communication-centred systems\n", "abstract": " We present a type system for the analysis of progress in session-based communication centred systems. Our development is carried out in a minimal setting considering classic (binary) sessions, but building on and generalising previous work on progress analysis in the context of conversation types. Our contributions aim at underpinning forthcoming works on progress for session-typed systems, so as to support richer verification procedures based on a more foundational approach. Although this work does not target expressiveness, our approach already addresses challenging scenarios which are unaccounted for elsewhere in the literature, in particular systems that interleave communications on received session channels.", "num_citations": "23\n", "authors": ["668"]}
{"title": "Typing liveness in multiparty communicating systems\n", "abstract": " Session type systems are an effective tool to prove that communicating programs do not go wrong, ensuring that the participants of a session follow the protocols described by the types. In a previous work we introduced a typing discipline for the analysis of progress in binary sessions. In this paper we generalize the approach to multiparty sessions following the conversation type approach, while strengthening progress to liveness. We combine the usual session-like fidelity analysis with the liveness analysis and devise an original treatment of recursive types allowing us to address challenging configurations that are out of the reach of existing approaches.", "num_citations": "22\n", "authors": ["668"]}
{"title": "Asynchronous functional session types\n", "abstract": " Session types support a type-theoretic formulation of structured patterns of communication, so that the communication behaviour of agents in a distributed system can be verified by static type checking. Applications include network protocols, business processes, and operating system services. In this paper we define a multithreaded functional language with session types, which unifies, simplifies and extends previous work. There are three main contributions. First: an operational semantics with buffered channels, instead of the synchronous communication of previous work. Second: session type manipulation by means of the standard structures of a linear type theory, rather than by means of new forms of typing judgement. Third: a notion of subtyping, including the standard subtyping relation for session types (imported into the functional setting) and a novel form of subtyping between standard and linear function types. Our new approach significantly simplifies session types in the functional setting, clarifies their essential features, and provides a secure foundation for language developments such as polymorphism and object-orientation, as well as further forms of static analysis including estimating the size of communication buffers.", "num_citations": "22\n", "authors": ["668"]}
{"title": "Channels as objects in concurrent object-oriented programming\n", "abstract": " There is often a sort of a protocol associated to each class, stating when and how certain methods should be called. Given that this protocol is, if at all, described in the documentation accompanying the class, current mainstream object-oriented languages cannot provide for the verification of client code adherence against the sought class behaviour. We have defined a class-based concurrent object-oriented language that formalises such protocols in the form of usage types. Usage types are attached to class definitions, allowing for the specification of (1) the available methods, (2) the tests clients must perform on the result of methods, and (3) the object status - linear or shared - all of which depend on the object's state. Our work extends the recent approach on modular session types by eliminating channel operations, and defining the method call as the single communication primitive in both sequential and concurrent settings. In contrast to previous works, we define a single category for objects, instead of distinct categories for linear and for shared objects, and let linear objects evolve into shared ones. We introduce a standard sync qualifier to prevent thread interference in certain operations on shared objects. We formalise the language syntax, the operational semantics, and a type system that enforces by static typing that methods are called only when available, and by a single client if so specified in the usage type. We illustrate the language via a complete example.", "num_citations": "21\n", "authors": ["668"]}
{"title": "Dynamic interfaces\n", "abstract": " We define a small class-based object-oriented language in which the availability of methods depends on an object\u2019s abstract state: objects\u2019 interfaces are dynamic. Each class has a session type which provides a global specification of the availability of methods in each state. A key feature is that the abstract state of an object may depend on the result of a method whose return type is an enumeration. Static typing guarantees that methods are only called when they are available. We present both a type system, in which the typing of a method specifies pre-and post-conditions for its object\u2019s state, and a typechecking algorithm, which infers the preand post-conditions from the session type, and prove type safety results. Inheritance is included; a subtyping relation on session types, related to that found in previous literature, characterizes the relationship between method availability in a subclass and in its superclass. We illustrate the language and its type system with example based on a Java-style iterator and a hierarchy of classes for accessing files, and conclude by outlining several ways in which our theory can be extended towards more practical languages.", "num_citations": "21\n", "authors": ["668"]}
{"title": "Session-based compilation framework for multicore programming\n", "abstract": " This paper outlines a general picture of our ongoing work under EU Mobius and Sensoria projects on a type-based compilation and execution framework for a class of multicore CPUs. Our focus is to harness the power of concurrency and asynchrony in one of the major forms of multicore CPUs based on distributed, non-coherent memory, through the use of type-directed compilation. The key idea is to regard explicit asynchronous data transfer among local caches as typed communication among processes. By typing imperative processes with a variant of session types, we obtain both type-safe and efficient compilation into processes distributed over multiple cores with local memories.", "num_citations": "20\n", "authors": ["668"]}
{"title": "Linearly refined session types\n", "abstract": " Session types capture precise protocol structure in concurrent programming, but do not specify properties of the exchanged values beyond their basic type. Refinement types are a form of dependent types that can address this limitation, combining types with logical formulae that may refer to program values and can constrain types using arbitrary predicates. We present a pi calculus with assume and assert operations, typed using a session discipline that incorporates refinement formulae written in a fragment of Multiplicative Linear Logic. Our original combination of session and refinement types, together with the well established benefits of linearity, allows very fine-grained specifications of communication protocols in which refinement formulae are treated as logical resources rather than persistent truths.", "num_citations": "19\n", "authors": ["668"]}
{"title": "Label-dependent session types\n", "abstract": " Session types have emerged as a typing discipline for communication protocols. Existing calculi with session types come equipped with many different primitives that combine communication with the introduction or elimination of the transmitted value.   We present a foundational session type calculus with a lightweight operational semantics. It fully decouples communication from the introduction and elimination of data and thus features a single communication reduction, which acts as a rendezvous between senders and receivers. We achieve this decoupling by introducing label-dependent session types, a minimalist value-dependent session type system with subtyping. The system is sufficiently powerful to simulate existing functional session type systems. Compared to such systems, label-dependent session types place fewer restrictions on the code. We further introduce primitive recursion over natural numbers at\u00a0\u2026", "num_citations": "18\n", "authors": ["668"]}
{"title": "Bridging the gap between algebraic specification and object-oriented generic programming\n", "abstract": " Although generics became quite popular in mainstream object- oriented languages and several specification languages exist that support the description of generic components, conformance relations between object-oriented programs and formal specifications that have been established so far do not address genericity. In this paper we propose a notion of refinement mapping that allows to define correspondences between parameterized specifications and generic Java classes. Based on such mappings, we put forward a conformance notion useful for the extension of ConGu, a tool-based approach we have been developing to support runtime conformance checking of Java programs against algebraic specifications, so that it becomes applicable to a more comprehensive range of situations, namely those that appear in the context of a typical Algorithms and Data Structures course.", "num_citations": "18\n", "authors": ["668"]}
{"title": "A multithreaded typed assembly language\n", "abstract": " We present an assembly language targeted at shared memory multiprocessors, where CPU cores synchronize via locks, acquired with a traditional test and set lock instruction. We show programming examples taken from the literature on Operating Systems, and discuss a typing system that enforces a strict protocol on lock usage and that prevents race conditions.", "num_citations": "17\n", "authors": ["668"]}
{"title": "A multi-threaded asynchronous language\n", "abstract": " We describe a reference implementation of a multi-threaded run-time system for a core programming language based on a process calculus. The core language features processes running in parallel and communicating through asynchronous messages as the fundamental abstractions. The programming style is fully declarative, focusing on the interaction patterns between processes. The parallelism, implicit in the syntax of the programs, is effectively extracted by the language compiler and explored by the run-time system.", "num_citations": "17\n", "authors": ["668"]}
{"title": "DiTyCO: An experiment in code mobility from the realm of process calculi\n", "abstract": " We propose a simple formal model of distribution for mobile objects in the context of the TyCO process calculus. Code mobility is induced by lexical scoping on names and template process definitions. Objects and messages migrate towards the site where their prefix names are lexically bound. Template process definitions, on the other hand, are downloaded from the site where they are defined, and are instantiated locally upon arrival. Based on this model we describe the run-time support for distribution and code mobility implemented in DiTyCO, an extension of the TyCO programming language.", "num_citations": "17\n", "authors": ["668"]}
{"title": "Processes, functions, and datatypes\n", "abstract": " Based on a name\u2010passing calculus and on its typing system we show how to build several language constructors towards strongly\u2010typed concurrent programming languages. In particular, we introduce a notion of datatype declaration, and show how to create values of a datatype and how to take such values apart. Further expressions include a form of abstraction and of application. Expressions evaluate to names and can replace any (non\u2010binding) name in the calculus, thus achieving a clean incorporation of expressions in a name\u2010passing calculus. A systematic translation of the derived constructors into the basic calculus provides for the semantics and for typing rules for the new constructors. \u00a9 1999 John Wiley & Sons, Inc.", "num_citations": "17\n", "authors": ["668"]}
{"title": "Trace semantics for actor systems\n", "abstract": " The theory of traces is used to describe the behavior of actor systems. The semantics is built from two simple concepts: a set of events representing the reception of messages by objects, and a binary symmetric and irreflexive relation on events\u2014independence\u2014representing permissible concurrency. Causality, the dual notion of concurrency, is expressed by the dependence relation\u2014the complement of independence. A particular execution of a system is described by a trace: a labeled acyclic graph where nodes are labeled with events and the only edges are between nodes labeled with dependent events. The behavior of a system is viewed as the set of traces representing all possible executions. Finally, a composition operation on systems and a synchronization operation on behaviors are presented: they allow to derive the behavior of complex systems from the behavior of its components.", "num_citations": "16\n", "authors": ["668"]}
{"title": "Duality of session types: The final cut\n", "abstract": " Duality is a central concept in the theory of session types. Since a flaw was found in the original definition of duality for recursive types, several other definitions have been published. As their connection is not obvious, we compare the competing definitions, discuss tradeoffs, and prove some equivalences. Some of the results are mechanized in Agda.", "num_citations": "15\n", "authors": ["668"]}
{"title": "Linearity, session types and the Pi calculus\n", "abstract": " We present a type system based on session types that works on a conventional pi calculus. Types are equipped with a constructor that describes the two ends of a single communication channel, this being the only type available for describing the behaviour of channels. Session types, in turn, describe the behaviour of each individual channel end, as usual. A novel notion of typing context split allows for typing processes not typable with extant type systems. We show that our system guarantees that typed processes do not engage in races for linear resources. We assess the expressiveness of type system by providing three distinct encodings\u2014from the pi calculus with polarised variables, from the pi calculus with accept and request primitives, and from the linear pi calculus\u2014into our system. For each language we present operational and typing correspondences, showing that our system effectively subsumes foregoing works on linear and session types. In the case of the linear pi calculus we also provide a completeness result.", "num_citations": "15\n", "authors": ["668"]}
{"title": "Session-based type discipline for pi calculus with matching\n", "abstract": " Introduction. In [7] we have introduced an extension of the first session typing system [10] that allows higherorder session communication. In the new system, the reduction rule for session passing k![k]. P| k?(k). Q\u2192 P| Q does not allow the transmission of an arbitrary channel. In most situations a receiving process k?(k). Q can be alpha-converted ahead of communication so that the bound channel k syntactically matches the free channel k in the object of the sending process [11]. The exception happens exactly when k is free in Q: alpha-conversion becomes impossible (for it would capture the free variable k), and communication cannot occur. A more liberal rule allows the transmission of an arbitrary channel, implying a substitution on the client side. k![k]. P| k?(x). Q\u2192 P| Q [k/x]", "num_citations": "14\n", "authors": ["668"]}
{"title": "Asynchronous timed session types\n", "abstract": " We present a behavioural typing system for a higher-order timed calculus using session types to model timed protocols. Behavioural typing ensures that processes in the calculus perform actions in the timewindows prescribed by their protocols. We introduce duality and subtyping for timed asynchronous session types. Our notion of duality allows typing a larger class of processes with respect to previous proposals. Subtyping is critical for the precision of our typing system, especially in the presence of session delegation. The composition of dual (timed asynchronous) types enjoys progress when using an urgent receive semantics, in which receive actions are executed as soon as the expected message is available. Our calculus increases the modelling power of extant calculi on timed sessions, adding a blocking receive primitive with timeout and a primitive that consumes an arbitrary amount of time in a given range.", "num_citations": "12\n", "authors": ["668"]}
{"title": "History-based access control for distributed processes\n", "abstract": " This paper presents a type system to control the migration of code between network nodes in a concurrent distributed framework, using the D\u03c0 language. We express resource access policies as types and enforce policies via a type system. Types describe paths travelled by migrating code, enabling the control of history sensitive access to resources. Sites are logically organised in subnetworks that share the same security policies, statically specified by a network administrator. The type system guarantees that well-typed networks are exempt from security policy violations at runtime.", "num_citations": "12\n", "authors": ["668"]}
{"title": "Deductive verification of parallel programs using Why3\n", "abstract": " The Message Passing Interface specification (MPI) defines a portable message-passing API used to program parallel computers. MPI programs manifest a number of challenges on what concerns correctness: sent and expected values in communications may not match, resulting in incorrect computations possibly leading to crashes; and programs may deadlock resulting in wasted resources. Existing tools are not completely satisfactory: model-checking does not scale with the number of processes; testing techniques wastes resources and are highly dependent on the quality of the test set. As an alternative, we present a prototype for a type-based approach to programming and verifying MPI like programs against protocols. Protocols are written in a dependent type language designed so as to capture the most common primitives in MPI, incorporating, in addition, a form of primitive recursion and collective choice. Protocols are then translated into Why3, a deductive software verification tool. Source code, in turn, is written in WhyML, the language of the Why3 platform, and checked against the protocol. Programs that pass verification are guaranteed to be communication safe and free from deadlocks. We verified several parallel programs from textbooks using our approach, and report on the outcome.", "num_citations": "11\n", "authors": ["668"]}
{"title": "The stream-based service-centred calculus: a foundation for service-oriented programming\n", "abstract": " We give a formal account of stream-based, service-centered calculus (SSCC), a calculus for modelling service-based systems, suitable to describe both service composition (orchestration) and the protocols that services follow when invoked (conversation). The calculus includes primitives for defining and invoking services, for isolating conversations (called sessions) among clients and servers, and for orchestrating services. The calculus is equipped with a reduction and a labelled transition semantics related by an equivalence result. SSCC provides a good trade-off between expressive power for modelling and simplicity for analysis. We assess the expressive power by modelling van der Aalst workflow patterns and an automotive case study from the European project Sensoria. For analysis, we present a simple type system ensuring compatibility of client and service protocols. We also study the behavioural\u00a0\u2026", "num_citations": "11\n", "authors": ["668"]}
{"title": "Coordinating phased activities while maintaining progress\n", "abstract": " In order to develop reliable applications for parallel machines, programming languages and systems need to provide for flexible parallel programming coordination techniques. Barriers, clocks and phasers constitute promising synchronisation mechanisms, but they exhibit intricate semantics and allow writing programs that can easily deadlock. We present an operational semantics and a type system for a fork/join programming model equipped with a flexible variant of phasers. Our proposal allows for a precise control over the maximum number of synchronisation steps each task can be ahead of others. A type system ensures that programs do not deadlock, even when they use multiple phasers.", "num_citations": "11\n", "authors": ["668"]}
{"title": "A concurrent programming environment with support for distributed computations and code mobility\n", "abstract": " We propose a programming model for distributed concurrent systems with mobile objects in the context of a process calculus. Code mobility is induced by lexical scoping on names. Objects and messages migrate towards the site where their prefixes are lexically bound. Class definitions, on the other hand, are downloaded from the site where they are defined, and are instantiated locally upon arrival. We provide several programming examples to demonstrate the expressiveness of the model. Finally, based on this model we describe an architecture for a run-time system supporting concurrent, distributed computations and code mobility.", "num_citations": "10\n", "authors": ["668"]}
{"title": "An Abstract Machine for an Object-Calculus\n", "abstract": " We present an abstract machine speci cation for TyCO (Typed Concurrent Objects), a namepassing calculus that aims at capturing fundamental concepts present in Concurrent Object-Oriented Languages.TyCO has built-in labeled messages and ephemeral object s that communicate asynchronously. Persistent objects are supported through instantiation of recursive classes. Concurrency is pervasive and synchronous communication can be implemented by passing continuations in messages. Strong, static typing is provided by a type inference algorithm that supports a form of predicative polymorphism.", "num_citations": "10\n", "authors": ["668"]}
{"title": "Behavioural theory at work: program transformations in a service-centred calculus\n", "abstract": " We analyse the relationship between object-oriented modelling and session-based, service-oriented modelling, starting from a typical UML Sequence Diagram and providing a program transformation into a service-oriented model. We also provide a similar transformation from session-based specifications into request-response specifications. All transformations are specified in SSCC\u2014a process calculus for modelling and analysing service-oriented systems\u2014and proved correct with respect to a suitable form of behavioural equivalence (full weak bisimilarity). Since the equivalence is proved to be compositional, results remain valid in arbitrary contexts.", "num_citations": "9\n", "authors": ["668"]}
{"title": "TRUTH AND ACTION OSMOSIS (THE TAO COMPUTATION MODEL)\n", "abstract": " We propose a computation model based on the separation between truth and action. The state of an agent is considered to consist of two components: the task, representing actions to be performed, and the database, representing certain truths. The task specifies a composition (parallel, sequential, choice, synchronous) of elementary actions: queries and commands. Queries may only be executed when certain truths are entailed by the database. Commands always execute and as an effect may change the database. We thus have the osmosis metaphor: the task and database are separated as if by a membrane through which information flows in both directions causing the system to evolve. Truth may enable actions (queries) to be accomplished, and actions (commands) may change what is true. Commands are assumed to have a deterministic nature. We discuss the fundamental semantic properties needed for\u00a0\u2026", "num_citations": "9\n", "authors": ["668"]}
{"title": "An algebra of behavioural types\n", "abstract": " We propose a process algebra, the Algebra of Behavioural Types, as a language for typing concurrent objects. A type is a higher-order labelled transition system that characterises all possible life cycles of a concurrent object. States represent interfaces of objects; state transitions model the dynamic change of object interfaces. Moreover, a type provides an internal view of the objects that inhabits it: a synchronous one, since transitions correspond to message reception. To capture this internal view of objects we define a notion of bisimulation, strong on labels and weak on silent actions. We study several algebraic laws that characterise this equivalence, and obtain completeness results for image-finite types.", "num_citations": "8\n", "authors": ["668"]}
{"title": "Communication errors in the \u03c0-calculus are undecidable\n", "abstract": " We present an undecidability proof of the notion of communication errors in the polyadic \u03c0-calculus. The demonstration follows a general pattern of undecidability proofs\u2014reducing a well-known undecidable problem to the problem in question. We make use of an encoding of the \u03bb-calculus into the \u03c0-calculus to show that the decidability of communication errors would solve the problem of deciding whether a lambda term has a normal form.", "num_citations": "8\n", "authors": ["668"]}
{"title": "Recursive types in a calculus of objects\n", "abstract": " We introduce a calculus for concurrent objects composed of labelled methods and communicating via asynchronous message passing, intended to capture some basic features present in most notions of objects. A decidable typing system allows to statically verify that all possible communications in a given program are secure in the precise sense that no object will ever receive a message for which it does not possess an appropriate method.Then we extend the class of typable terms by introducing in nite types in the form of recursively de ned type expressions, along the lines of Cardone and Coppo for the-calculus and of Vasconcelos and Honda for the polyadic-calculus. The new system preserves all the syntactical properties of the simple typing assignment system, including the subject-reduction and the computability of principal typings.", "num_citations": "8\n", "authors": ["668"]}
{"title": "Deciding the Bisimilarity of Context-Free Session Types.\n", "abstract": " We present an algorithm to decide the equivalence of contextfree session types, practical to the point of being incorporated in a compiler. We prove its soundness and completeness. We further evaluate its behaviour in practice. In the process, we introduce an algorithm to decide the bisimilarity of simple grammars.", "num_citations": "7\n", "authors": ["668"]}
{"title": "HeadREST: A Specification Language for RESTful APIs\n", "abstract": " Representational State Transfer (REST), an architectural style providing an abstract model of the web, is by far the most popular platform to build web applications. Developing such applications require well-documented interfaces. However, and despite important initiatives such as the Open API Specification, the support for interface description is currently quite limited, focusing essentially on simple syntactic aspects. In this paper we present HeadREST, a dependently-typed language that allows describing semantic aspects of interfaces in a style reminiscent of Hoare triples.", "num_citations": "7\n", "authors": ["668"]}
{"title": "Controlling security policies in a distributed environment\n", "abstract": " This paper presents a type system to control the migration of code between nodes in a concurrent distributed framework, using Dpi. We express resource policies with types and enforce them via a type system. Sites are organised hierarchically in subnetworks that share the same security policies, statically specified by a network administrator. The type system guarantees that, at runtime, there are no security policies violations", "num_citations": "7\n", "authors": ["668"]}
{"title": "A Lexically Scoped Distributed -Calculus\n", "abstract": " We define the syntax, the operational semantics, and a type system for lsd-pi, an asynchronous and distributed -calculus with local communication and process migration. The calculus follows a simple model of distribution for mobile calculi, with a lexical scoping mechanism that provides both for remote communication and for process migration, making explicit migration primitives superfluous", "num_citations": "7\n", "authors": ["668"]}
{"title": "Core-TyCO, The Language Definition, Version 0.1\n", "abstract": " This is the second report on TyCO, a (still) experimental strongly and implicitly typed concurrent object oriented programming language based on a predicative polymorphic calculus of objects, featuring asynchronous messages, objects, and process declarations, together with a predicative polymorphic type system", "num_citations": "7\n", "authors": ["668"]}
{"title": "Runtime Verification for Generic Classes with ConGu 2\n", "abstract": " Even though generics became quite popular in mainstream object-oriented (OO) languages, approaches for checking at runtime the conformance of such programs against formal specifications still lack appropriate support. In order to overcome this limitation within ConGu, a tool-based approach we have been developing to support runtime conformance checking of Java programs against algebraic specifications, we recently proposed a notion of refinement mapping that allows to define correspondences between parametric specifications and generic classes. Based on such mappings, we also put forward a notion of conformance between the two concepts. In this paper we present how the new notion of conformance is supported by version 2 of the ConGu tool.", "num_citations": "6\n", "authors": ["668"]}
{"title": "Session types for linear multithreaded functional programming\n", "abstract": " The construction of reliable concurrent and distributed systems is an extremely difficult endeavour. For complex systems, it requires modular development strategies based on precise interface specifications that allow the various modules to interact properly. In this extended abstract we are concerned with message passing systems where partners engage in long and complex interactions, as opposed to, say, remote procedure calls composed of a pair of simple interactions.", "num_citations": "6\n", "authors": ["668"]}
{"title": "Lambda and pi calculi, CAM and SECD machines\n", "abstract": " We analyse machines that implement the call-by-value reduction strategy of the \u03bb-calculus: two environment machines \u2013 CAM and SECD \u2013 and two encodings into the -calculus. Plotkin completes the picture by showing that there is a convergent correspondence from the \u03bb-calculus into SECD.", "num_citations": "6\n", "authors": ["668"]}
{"title": "Testing implementations of algebraic specifications with design-by-contract tools\n", "abstract": " We present an approach for testing Java implementations of abstract data types (ADTs) against their specifications. The key idea is to reduce this problem to the run-time monitoring of contract annotated classes, which is supported today by several runtime assertion-checking tools. The approach comprises an ADT specification language that allows automatic generation of monitorable contracts and a refinement language that supports the specification of the details of object-oriented implementations of ADTs", "num_citations": "6\n", "authors": ["668"]}
{"title": "Fine-grained multithreading with process calculi\n", "abstract": " This paper presents a multithreaded abstract machine for the TyCO process calculus. We argue that process calculi provide a powerful framework to reason about fine-grained parallel computations. They allow for the construction of formally verifiable systems on which to base high-level programming idioms, combined with efficient compilation schemes into multithreaded architectures.", "num_citations": "6\n", "authors": ["668"]}
{"title": "Towards an algebra of dynamic object types\n", "abstract": " We propose an algebra of object types that characterises the semantics of concurrent objects in a process calculus setting where the communication is asynchronous. The types are non-uniform, and provide an internal (and synchronous) view of the objects that inhabit them. These ideas, along with the algebraic laws, are based on a notion of bisimulation that is unlike other notions in the literature.", "num_citations": "6\n", "authors": ["668"]}
{"title": "Imperative objects with dependent types\n", "abstract": " Index refinements (or dependent types over a restricted domain) enable the expression of many desirable invariants that can be verified at compile time. We propose to incorporate a system of index refinements in a small, class-based, imperative, object-oriented language. While rooted in techniques formulated for dependently-typed functional languages, our type system is able to capture more than just value properties and pure computations. Index refinements, combined with a notion of pre-and post-type to track state, give programmers the ability to reason about effectful computations. Our type system distinguishes between two classes of objects, imposing an affine discipline to objects whose types are governed by indices, as opposed to conventional objects which can be freely shared. We have designed and implemented an expressive and decidable type system, which we illustrate through a number of\u00a0\u2026", "num_citations": "5\n", "authors": ["668"]}
{"title": "Types for X10 Clocks\n", "abstract": " X10 is a modern language built from the ground up to handle future parallel systems, from multicore machines to cluster configurations. We take a closer look at a pair of synchronisation mechanisms: finish and clocks. The former waits for the termination of parallel computations, the latter allow multiple concurrent activities to wait for each other at certain points in time. In order to better understand these concepts we study a type system for a stripped down version of X10. The main result assures that well typed programs do not run into the errors identified in the X10 language reference, namely the ClockUseException. The study will open, we hope, doors to a more flexible utilisation of clocks in the X10 language.", "num_citations": "5\n", "authors": ["668"]}
{"title": "Compiling the \u03c0-calculus into a Multithreaded Typed Assembly Language\n", "abstract": " We extend a previous work on a multithreaded typed assembly language (MIL) targeted at shared memory multiprocessors, and describe the design of a type-preserving compiler from the \u03c0-calculus into MIL. The language enforces a policy on lock usage through a typing system that also ensures race-freedom for typable programs, while allowing for typing various important concurrency patterns. Our translation to MIL generates code that is then linked to a library supporting a generic unbounded buffer monitor, variant of Hoare's bounded buffer monitor, entirely written in MIL. Such a monitor shields client code (the \u03c0-calculus compiler in particular) from the hazardous task of direct lock manipulation, while allowing for the representation of \u03c0-calculus channels. The compiler produces type correct MIL programs from type correct source code, generating low-contention cooperative multithreaded programs.", "num_citations": "5\n", "authors": ["668"]}
{"title": "Congu, Checking Java Classes Against Property-Driven Algebraic Specifications\n", "abstract": " Congu is a tool that supports the checking of Java classes against property-driven algebraic specifications. This document presents the specification, languages, the tool usage, and its implementation, version 1.32. Chapter 1 describes the two specification languages: the language of abstract data types specifications, and that for defining refinement mappings between these specifications and Java classes. Chapter 2 explains how to install and use Congu tool. And finally, Chapter 3 presents the implementation details of the tool", "num_citations": "5\n", "authors": ["668"]}
{"title": "An operational semantics and a typing system for ABCL/1 based on a calculus of objects\n", "abstract": " The present report presents an operational semantics and a typing system for ABCL/1 programs, based on a name-passing calculus. The particular calculus we use, TyCO, features asynchronous labelled message passing, explicit objects composed of labelled methods, and operators to compose objects and messages concurrently, and to generate new names. The calculus is only implicitly typed in that no type information is presented in programs, but else inferred through a typing assignment system. The operational semantics is obtained by a systematic translation of the constructors present in the ABCL/1 language into TyCO processes. The type assignment system is derived from this encoding and from TyCO type inference rules. The encoding provides a very ne grain semantics that makes explicit the order of evaluation in methods, and highlights the most complex features present in ABCL/1, namely wait-for forms and express-messages. The typing system provides a means to statically separate\\safe programs\" from programs that may run into errors at runtime, and in particular avoids testing the type of arguments in methods. There is an algorithm capable of extracting the most general type of an ABCL/1 program, or to detect its inexistence.", "num_citations": "5\n", "authors": ["668"]}
{"title": "A Note on a Typing System for the Higher-Order-Calculus\n", "abstract": " We study a typing assignment system for the higher-order-calculus. The system proposed is a straightforward extension of the typing system for the polyadic-calculus proposed by Kohei Honda and the author 6], by introducing a new type constructor for agents (ie, processes abstracted on some sequence of names and variables.) We also present an e cient typing reconstruction algorithm to extract the most general typing of an agent or to detect its inexistence, and prove its correctness with respect to the typing system. Finally we show that well-sorted agents are typable, and that typable agents are well-sorted, thus establishing the correspondence between Sangiorgi's sorting system 4] and the typing assignment system.", "num_citations": "5\n", "authors": ["668"]}
{"title": "Especifica\u00e7\u00e3o de Interfaces Aplicacionais REST\n", "abstract": " A programa\u00e7\u00e3o de servi\u00e7os web com interfaces aplicacionais REST \u00e9 atualmente muito popular. O desenvolvimento de aplica\u00e7\u00f5es clientes destes servi\u00e7os exige que as interfaces estejam bem documentadas. No entanto, e apesar de iniciativas importantes como a Open API Specification, o suporte \u00e0 descri\u00e7\u00e3o destas interfaces \u00e9 atualmente bastante limitado, focado essencialmente nos aspetos sint\u00e1ticos. Neste artigo apresenta-se a linguagem HeadREST que permite ultrapassar estas limita\u00e7\u00f5es e descrever tamb\u00e9m os aspetos sem\u00e2nticos das interfaces num estilo reminescente dos triplos de Hoare e recorrendo a tipos refinados. A linguagem \u00e9 apresentada atrav\u00e9s de pequenos exemplos extra\u00eddos de um dos estudos de caso que desenvolvemos com o intuito de a avaliar. Discute-se ainda a forma de validar a boa forma\u00e7\u00e3o das especifica\u00e7\u00f5es HeadREST e uma t\u00e9cnica para a gera\u00e7\u00e3o de testes para verificar a conformidade de uma API REST relativamente \u00e0 sua descri\u00e7\u00e3o.", "num_citations": "4\n", "authors": ["668"]}
{"title": "Theory and applications of behavioural types (dagstuhl seminar 17051)\n", "abstract": " This report documents the programme and the outcomes of Dagstuhl Seminar 17051\" Theory and Applications of Behavioural Types\". Behavioural types describe the dynamic aspects of programs, in contrast to data types, which describe the fixed structure of data. Perhaps the most well-known form of behavioural types is session types, which are type-theoretic specifications of communication protocols. More generally, behavioural types include typestate systems, which specify state-dependent availability of operations; choreographies, which specify collective communication behaviour; and behavioural contracts. In recent years, research activity in behavioural types has increased dramatically, in both theoretical and practical directions. Theoretical work has explored new relationships between established behavioural type systems and areas such as linear logic, automata theory, process calculus testing theory, dependent type theory, and model-checking. On the practical side, there are several implementations of programming languages, programming language extensions, software development tools, and runtime monitoring systems, which are becoming mature enough to apply to real-world case studies. The seminar brought together researchers from the established, largely European, research community in behavioural types, and other participants from outside Europe and from related research topics such as effect systems and actor-based languages. The questions that we intended to explore included:-How can we understand the relationships between the foundations of session types in terms of linear logic, automata, denotational\u00a0\u2026", "num_citations": "4\n", "authors": ["668"]}
{"title": "Protocol-based verification of MPI programs\n", "abstract": " We present a methodology for the verification of Message Passing   Interface (MPI) programs written in C.  The aim is to statically   verify programs against protocol specifications, enforcing   properties such as fidelity and absence of deadlocks.  We make use   of a protocol language based on a dependent type system for   message-passing parallel programs.   %    For the verification of a program against a given protocol, the   protocol is first translated into a representation read by VCC, a   software verifier for the~C programming language.   %    The program is then annotated with specific assertions that,   together with a pre-established set of contracts for MPI primitives,   guide the verifier to either prove or disprove the program's   conformance to the protocol.        We successfully verified MPI programs in a running time that is   independent of the number of processes or other input parameters.   This contrasts with other techniques, notably model checking and   symbolic execution, that suffer from the state-explosion problem.   We experimentally evaluated our approach against TASS, a state-of-the-art tool for MPI program verification.", "num_citations": "4\n", "authors": ["668"]}
{"title": "Specification and verification of protocols for MPI programs\n", "abstract": " We present an approach for the validation of Message Passing Interface (MPI) programs. The aim is to type-check programs against session-type based protocol specifications, enforcing properties such as protocol fidelity, absence of race conditions or deadlocks. We design and implement a protocol specification language based on dependent multiparty session types. The language is equipped with a type formation system and an operational semantics, and its correctness is ensured by a progress property for well formed types. For verification, the protocol is translated into the language of VCC, a software verifier for the C programming language. C+ MPI programs are annotated with assertions that help the verifier either prove or disprove the conformance of programs against protocols. A large part of the necessary annotations are automatically introduced by an annotator we developed. We successfully validated several publicly available MPI programs with this approach.", "num_citations": "4\n", "authors": ["668"]}
{"title": "Type-directed compilation for multicore programming\n", "abstract": " In this paper, we outline a general picture of our ongoing work on a compilation and execution framework for a class of multicore CPUs [Gelsinger, P., P. Gargini, G. Parker and A. Yu, Microprocessors circa 2000, IEEE SPectrum (1989), pp. 43\u201347; Olukotun, K., B. A. Nayfeh, L. Hammond, K. G. Wilson and K. Chang, The case for a single-chip multiprocessor, in: ASPLOS, 1996, pp. 2\u201311; Pham, D. et al., The design and implementation of a first-generation cell processor, in: ISSCC Dig. Tech. Papers (2005), pp. 184\u2013185]. Our focus is to harness the power of concurrency and asynchrony in one of the major forms of multicore CPUs based on distributed, noncoherent memory [Pham, D. et al., The design and implementation of a first-generation cell processor, in: ISSCC Dig. Tech. Papers (2005), pp. 184\u2013185], using the well-known technology of type-directed compilation [Morrisett, G., D. Walker, K. Crary and N. Glew\u00a0\u2026", "num_citations": "4\n", "authors": ["668"]}
{"title": "Coordination Models and Languages\n", "abstract": " Coordination Models and Languages - NASA/ADS Now on home page ads icon ads Enable full ADS view NASA/ADS Coordination Models and Languages Field, John ; Vasconcelos, Vasco T. Abstract Publication: Lecture Notes in Computer Science Pub Date: 2009 DOI: 10.1007/978-3-642-02053-7 Bibcode: 2009LNCS......F Keywords: Computer Science; Software Engineering; Programming Techniques; Software Engineering/Programming and Operating Systems; Computer Communication Networks; Models and Principles; Information Systems Applications (incl.Internet) full text sources Publisher | \u00a9 The SAO/NASA Astrophysics Data System adshelp[at]cfa.harvard.edu The ADS is operated by the Smithsonian Astrophysical Observatory under NASA Cooperative Agreement NNX16AC86A NASA logo Smithsonian logo Resources About ADS ADS Help What's New Careers@ADS Social @adsabs ADS Blog Project \u2026", "num_citations": "4\n", "authors": ["668"]}
{"title": "MiKO---Mikado Koncurrent Objects\n", "abstract": " The motivation for the Mikado migration model is to provide programming constructs for controlling code mobility that are as independent as possible from the particular programming language used to program the code. The main idea is to regard a domain (or site, or locality), where mobile code may enter or exit, as a membrane enclosing running processes, and offering services that have to be called for entering or exiting the domain. MiKO---Mikado Koncurrent Objects is a particular instance of this model, where the membrane is explicitly split in two parts: the methods defining the interface, and a process part describing the data for, and the behavior of, the interface. The talk presents the syntax, operational semantics, and type system of MiKO, together with an example. It concludes by briefly mentioning the implementation of a language based on the calculus.", "num_citations": "4\n", "authors": ["668"]}
{"title": "Tyco gently\n", "abstract": " TyCO stands for \"TYped Concurrent Objects\". Not that the language includes any form of primitive objects. Instead, a few basic constructors provide for a form of Object-Based Programming (that is, objects but no inheritance). The language is quite simple. The basic syntax reduces to half-a-dozen constructors. To help in writing common programming patterns, a few derived constructors are available. This report introduces TyCO by example, rather than explaining the language first and giving examples second", "num_citations": "4\n", "authors": ["668"]}
{"title": "Core-TyCO: Appendix to the Language Definition, yielding Version 0.2\n", "abstract": " This is the third report on TyCO, a (still) experimental strongly and implicitly typed concurrent object based programming language based on a predicative polymorphic calculus of objects, featuring asynchronous messages, objects, and procedures, together with a predicative polymorphic typing assignment system, assigning monomorphic types to variables and polymorphic types to procedures", "num_citations": "4\n", "authors": ["668"]}
{"title": "Gradual session types\n", "abstract": " Session types are a rich type discipline, based on linear types, that lifts the sort of safety claims that come with type systems to communications. However, web-based applications and microservices are often written in a mix of languages, with type disciplines in a spectrum between static and dynamic typing. Gradual session types address this mixed setting by providing a framework which grants seamless transition between statically typed handling of sessions and any required degree of dynamic typing. We propose Gradual GV as a gradually typed extension of the functional session type system GV. Following a standard framework of gradual typing, Gradual GV consists of an external language, which relaxes the type system of GV using dynamic types; an internal language with casts, for which operational semantics is given; and a cast-insertion translation from the former to the latter. We demonstrate type and\u00a0\u2026", "num_citations": "3\n", "authors": ["668"]}
{"title": "Dependent Types for Class-based Mutable Objects\n", "abstract": " We present an imperative object-oriented language featuring a dependent type system designed to support class-based programming and inheritance. Programmers implement classes in the usual imperative style, and may take advantage of a richer dependent type system to express class invariants and restrictions on how objects are allowed to change and be used as arguments to methods. By way of example, we implement insertion and deletion for binary search trees in an imperative style, and come up with types that ensure the binary search tree invariant. This is the first dependently-typed language with mutable objects that we know of to bring classes and index refinements into play, enabling types (classes) to be refined by indices drawn from some constraint domain. We give a declarative type system that supports objects whose types may change, despite being sound. We also give an algorithmic type system that provides a precise account of quantifier instantiation in a bidirectional style, and from which it is straightforward to read off an implementation. Moreover, all the examples in the paper have been run, compiled and executed in a fully functional prototype that includes a plugin for the Eclipse IDE.", "num_citations": "3\n", "authors": ["668"]}
{"title": "Coordination Models and Languages: 11th International Conference, COORDINATION 2009, Lisbon, Portugal, June 9-12, 2009, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 11th International Conference on Coordination Models and Languages, COORDINATION 2009, held in Lisbon, Portugal, in June 2009, as one of the federated conferences on Distributed Computing Techniques, DisCoTec 2009. The 14 revised full papers presented were carefully reviewed and selected from 61 submissions. The subject-matter is to explore the spectrum of languages, middleware, services, and algorithms that separate behavior from interaction, therefore increasing modularity, simplifying reasoning, and ultimately enhancing software development.", "num_citations": "3\n", "authors": ["668"]}
{"title": "Compiling the -calculus into a Multithreaded Typed Assembly Language\n", "abstract": " Current trends in hardware made available multi-core CPU systems to ordinary users, challenging researchers to devise new techniques to bring software into the multi-core world. However, shaping software for multi-cores is more envolving than simply balancing workload among cores. In a near future (in less than a decade) Intel prepares to manufacture and ship 80-core processors; programmers must perform a paradigm shift from sequential to concurrent programming and produce software adapted for multi-core platforms. In the last decade, proposals have been made to compile formal concurrent and functional languages, notably the -calculus, typed concurrent objects, and the -calculus, into assembly languages. The last work goes a step further and presents a series of type-preserving compilation steps leading from System F to a typed assembly language. Nevertheless, all theses works are targeted at sequential architectures. This paper proposes a type-preserving translation from the -calculus into MIL, a multithreaded typed assembly language for multi-core/multi-processor architectures. We start from a simple asynchronous typed version of the -calculus and translate it into MIL code that is then linked to a run-time library (written in MIL) that provides support for implementation of the -calculus primitives (e.g., queuing messages and processes). In short, we implement a message-passing paradigm in a shared memory architecture", "num_citations": "3\n", "authors": ["668"]}
{"title": "CONCUR 2007-Concurrency Theory: 18th International Conference, CONCUR 2007, Lisbon, Portugal, September 3-8, 2007, Proceedings\n", "abstract": " This volume constitutes the refereed proceedings of the 17th International Conference on Concurrency Theory. Thirty full papers are presented along with three important invited papers. Each of these papers was carefully reviewed by the editors. Topics include model checking, process calculi, minimization and equivalence checking, types, semantics, probability, bisimulation and simulation, real time, and formal languages.", "num_citations": "3\n", "authors": ["668"]}
{"title": "Trace semantics for concurrent objects\n", "abstract": " The theory of traces (the theory of free partial commutative monoids) is used to describe the behavior of systems of concurrent objects. A composition operation on systems and a synchronization operation on behaviors are presented: they allow to derive the behavior of complex systems from the behavior of its components.To address fundamental issues of concurrent semantics for objects in general, we concentrate on a simple model where objects communicate via asynchronous message passing and are only capable of sending messages, creating more objects and changing the way they react to incoming messages. The semantics is built from two simple concepts: a set of events representing the reception of messages by objects, and a binary symmetric and irre exive relation on events| independence| representing permissible concurrency. Causality, the dual notion of concurrency, is expressed by the dependence relation| the complement of independence. Executions of systems are described by a traces: labeled acyclic graphs where nodes are labeled with events and the only edges are between di erent nodes labeled with dependent events. The behavior of a system is the set of traces representing all possible executions.", "num_citations": "3\n", "authors": ["668"]}
{"title": "SafeRESTScript: statically checking REST API consumers\n", "abstract": " Consumption of REST services has become a popular means of invoking code provided by third parties, particularly in web applications. Nowadays programmers of web applications can choose TypeScript over JavaScript to benefit from static type checking that enables validating calls to local functions or to those provided by libraries. Errors in calls to REST services, however, can only be found at run-time. In this paper, we present SafeRESTScript (SRS, for short) a language that extends the support of static analysis to calls to REST services, with the ability to statically find common errors such as missing or invalid data in REST calls and misuse of the results from such calls. SafeRESTScript features a syntax similar to JavaScript and is equipped with (i) a rich collection of types (including objects, arrays and refinement types)and (ii) primitives to natively support REST calls that are statically validated against specifications of the corresponding APIs. Specifications are written in HeadREST, a language that also features refinement types and supports the description of semantic aspects of REST APIs in a style reminiscent of Hoare triples. We present SafeRESTScript and its validation system, based on a general-purpose verification tool (Boogie). The evaluation of SafeRESTScript and of the prototype implementations for its validator, available in the form of an Eclipse plugin, is also discussed.", "num_citations": "2\n", "authors": ["668"]}
{"title": "Mixed Sessions\n", "abstract": " Session types describe patterns of interaction on communicating channels. Traditional session types include a form of choice whereby servers offer a collection of options, of which each client picks exactly one. This sort of choice constitutes a particular case of separated choice: offering on one side, selecting on the other. We introduce mixed choices in the context of session types and argue that they increase the flexibility of program development at the same time that they reduce the number of synchronisation primitives to exactly one. We present a type system incorporating subtyping and prove preservation and absence of runtime errors for well-typed processes. We further show that classical (conventional) sessions can be faithfully and tightly embedded in mixed choices. Finally, we discuss algorithmic type checking and a runtime system built on top of a conventional (choice-less) message-passing architecture.", "num_citations": "2\n", "authors": ["668"]}
{"title": "The computational content of atomic polymorphism\n", "abstract": " We show that the number-theoretic functions definable in the atomic polymorphic system () are exactly the extended polynomials. Two proofs of the above result are presented: one, reducing the functions\u2019 definability problem in  to definability in the simply typed lambda calculus () and the other, directly adapting Helmut Schwichtenberg\u2019s strategy for definability in  to the atomic polymorphic setting. The uniformity granted in the polymorphic system, when compared with the simply typed lambda calculus, is emphasized.", "num_citations": "2\n", "authors": ["668"]}
{"title": "Freest: Context-free session types in a functional language\n", "abstract": " FreeST is an experimental concurrent programming language. Based on a core linear functional programming language, it features primitives to fork new threads, and for channel creation and communication. A powerful type system of context-free session types governs the interaction on channels. The compiler builds on a novel algorithm for deciding type equivalence of context-free session types. This abstract provides a gentle introduction to the language and discusses the validation process and runtime system.", "num_citations": "2\n", "authors": ["668"]}
{"title": "Type-based verification of message-passing parallel programs\n", "abstract": " We present a type-based approach to the verification of the communication structure of parallel programs. We model parallel imperative programs where a fixed number of processes, each equipped with its local memory, communicates via a rich diversity of primitives, including point-to-point messages, broadcast, reduce, and array scatter and gather. The paper proposes a decidable dependent type system incorporating abstractions for the various   communication operators, a form of primitive recursion, and   collective choice. Term types may refer to values in the programming   language, including integer, floating point and arrays. The paper   further introduces a core programming language for imperative,   message-passing, parallel programming, and shows that the language   enjoys progress.", "num_citations": "2\n", "authors": ["668"]}
{"title": "Monitoring java code using ConGu\n", "abstract": " Design by Contract (DBC)[1] is widely used for the specification of object-oriented software. There are a number of languages and tools (eg,[2, 3, 4, 5]) that allow equipping classes and methods with invariants, pre and post-conditions, which can be monitored for violations at runtime. In the DBC approach, specifications are class interfaces (Java interfaces, Eiffel abstract classes, etc) annotated with contracts expressed in a particular assertion language, which is usually an extension of the language of boolean expressions of the OO language.To build contracts using these languages one must observe the following:(i) contracts are built from boolean assertions, thus procedures (methods that do not return values) cannot be used;(ii) contracts should refer only to the public features of the class because client classes must be able not only to understand contracts, but also to invoke operations that are referred to in them\u2014eg, clients must be able to test pre-conditions;(iii) to be monitorable, a contract cannot have side effects, thus it cannot invoke methods that modify the state. These restrictions bring severe limitations to the kind of properties we can express directly through contracts. Unless we define a number of, otherwise dispensable, additional methods, we are left with very poor specifications. Model-based approaches to DBC, like those proposed for Z [6], Larch [7], JML [5], and AsmL [8], overcome these limitations by specifying the behavior of a class, not via the methods available in the class, but else through very abstract implementations based on basic elements available in the adopted specification language. Rather than a model based\u00a0\u2026", "num_citations": "2\n", "authors": ["668"]}
{"title": "Bisimulations in SSCC\n", "abstract": " This report studies different definitions of bisimulation within the Stream-Based Service-Centered Calculus (SSCC) and shows that both strong and weak ground bisimulation are non-input congruences.", "num_citations": "2\n", "authors": ["668"]}
{"title": "Language primitives and type discipline for structured communication-based programming revisited\u2014two systems for higher-order session communication. DI\n", "abstract": " CITI - Technical Report - Language Primitives and Type Discipline for Structured Communication-Based Programming Revisited: Two Systems for Higher-Order Session Communication CITI has stopped operations in 2014, to co-launch NOVA LINCS THIS SITE IS NOT BEING UPDATED SINCE 2013 citi banner Home \\ Publications \\ Technical Report Page Login CITI Welcome Research Areas Organization Executive Board Advisory Board Contacts Useful Information People CITI Members Visitors Activities Research Projects Publications Seminars @ CITI External Talks & Seminars Graduation Activities Organization of Events Editorial Committees Prototypes Visits & Missions Activity Reports Search & Query Search BibTeX Generator banner bottom File Top Language Primitives and Type Discipline for Structured Communication-Based Programming Revisited: Two Systems for Higher-Order Session Communication \u2026", "num_citations": "2\n", "authors": ["668"]}
{"title": "A New Approach to Functional Session Types\n", "abstract": " Session types support a type-theoretic formulation of structured patterns of communication, so that the communication behaviour of agents in a distributed system can be verified by static type checking. Applications include network protocols, business processes, and operating system services. The theory of session types has been studied extensively for the pi calculus and related languages, to a lesser extent for functional languages, and more recently for object oriented languages. In this paper we define a multithreaded functional language with session types, which unifies, simplifies and extends previous work. There are three main contributions. First: manipulating sessions by means of the standard structures of a linear type theory, rather than by means of new forms of typing judgement. Second: presenting an operational semantics with buffered channels, instead of the synchronous communication of previous\u00a0\u2026", "num_citations": "2\n", "authors": ["668"]}
{"title": "The impact of linearity information on the performance of TyCO\n", "abstract": " We describe a linear channel inference system for the TyCO programming language, where channel usage is tracked through method invocations as well as definition instantiations. We then apply linear channel information to optimize code generation for a multithreaded runtime system. The impact in terms of speed and space is analyzed.", "num_citations": "2\n", "authors": ["668"]}
{"title": "The call-by-value -calculus, the SECD machine, and the -calculus\n", "abstract": " We present an encoding of the call-by-value -calculus into the -calculus, alternative to the well-known Milner's encodings. We show that our encoding is barbed congruent (under typed contexts) to Milner's \"light\" encoding, and that it takes two -steps to mimic a beta-reduction for normalizing terms. We describe a translation of Plotkin's SECD machine into the -calculus, and show that there is an operational correspondence between a SECD machine and its encoding. Equipped with a notion of a state-based machine and two kinds of correspondences between them, we compare the encodings of the call-by-value -calculus and the SECD machine into the -calculus", "num_citations": "2\n", "authors": ["668"]}
{"title": "Compiling Object Calculi\n", "abstract": " Despite extensive theoretical work on process-calculi, abstract machine speci cations and implementations of actual computational models are still scarce. Moreover, a general framework for compiling languages based on these calculi is still elusive. We propose a core assembly language onto which process-calculi based languages may be compiled and present a speci cation for a self-contained abstract machine that runs this assembly code. We also include compilation examples of features of well known calculi and discuss possible optimizations. Finally, we report preliminary performance results obtained with an implementation of the abstract machine coupled with an experimental language based on the TyCO-calculus.", "num_citations": "2\n", "authors": ["668"]}
{"title": "A framework for compiling object calculi\n", "abstract": " We give a speci cation for an abstract machine for object calculi. The instruction set is intended to work as a target assembly language to which high level concurrent languages may be compiled. As a case example the compilation of the TyCO object calculus is treated. Some preliminary results on a prototype implementation are given.", "num_citations": "2\n", "authors": ["668"]}
{"title": "TyCO Abstract Machine, The Definition\n", "abstract": " We present an abstract machine speci cation for TyCO (Typed Concurrent Objects), a namepassing calculus that aims at capturing fundamental concepts present in Concurrent Object-Oriented Languages.TyCO has built-in labeled messages and ephemeral objects that communicate asynchronously. Persistent objects are supported through instantiation of recursive classes. Concurrency is pervasive and synchronous communication can be implemented by passing continuations in messages. Strong, static typing is provided by a type inference algorithm that supports a form of predicative polymorphism.", "num_citations": "2\n", "authors": ["668"]}
{"title": "Unification of kinded infinite trees\n", "abstract": " We study the problem of unifying infinite trees with variables subject to constraints on the trees they may be substituted for. The constraints are given by mappings from variables to trees, called kindings. In particular, we show that if a set of equations over a given kinding is unifiable, it has a most general unifier using only a subset of the variables in the set of equations and in the kinding. We present an efficient algorithm to extract the most general unifier of a regular (having a finite number of subtrees) and unifiable set of equations over a given kinding. The results extend those of Huet on unification of regular trees, and those of Ohori on unification of kinded finite trees.", "num_citations": "2\n", "authors": ["668"]}
{"title": "An operational semantics and a type for ABCL/1 based on a calculus of objects\n", "abstract": " CiNii \u8ad6\u6587 - An Operational Semantics and a Type for ABCL/1 Based on a Calculus of Objects CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3\u696d\u52d9\u306e\u518d\u958b\u306b\u3064\u3044\u3066 An Operational Semantics and a Type for ABCL/1 Based on a Calculus of Objects VASCONCELOS VT \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 VASCONCELOS VT \u53ce\u9332\u520a\u884c\u7269 Object-Oriented Computing III, Lecture Notes, Lake Biwa, Japan, 1995 Object-Oriented Computing III, Lecture Notes, Lake Biwa, Japan, 1995, 1995 Kindai Kagaku Sha \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u4e26\u884c\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u305f\u3081\u306e\u578b\u30b7\u30b9\u30c6\u30e0\u3068\u30b3\u30f3\u30d1\u30a4\u30eb\u6280\u6cd5 \u516b\u6749 \u660c\u5b8f , Masahiro Yasugi , \u4eac\u90fd\u5927\u5b66\u60c5\u5831\u5b66\u7814\u7a76\u79d1 , Graduate School of Informatics Kyoto \u2026", "num_citations": "2\n", "authors": ["668"]}
{"title": "Statically Checking REST API Consumers\n", "abstract": " Consumption of REST services has become a popular means of invoking code provided by third parties, particularly in web applications. Nowadays programmers of web applications can choose TypeScript over JavaScript to benefit from static type checking that enables validating calls to local functions or to those provided by libraries. Errors in calls to REST services, however, can only be found at runtime. In this paper, we present SRS, a language that extends the support of static analysis to calls to REST services, with the ability to statically find common errors such as missing or invalid data in REST calls and misuse of the results from such calls. SRS features a syntax similar to JavaScript and is equipped with a rich collection of types and primitives to natively support REST calls that are statically validated against specifications of the corresponding APIs written in the HeadREST language.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Mixed Sessions: the Other Side of the Tape\n", "abstract": " The original paper on Mixed Sessions introduce the side A of the tape: there is an encoding of classical sessions into mixed sessions. Here we present side B: there is a translation of (a subset of) mixed sessions into classical session types. We prove that the translation is a minimal encoding, according to the criteria put forward by Kouzapas, P\\'erez, and Yoshida.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Safe (REST) Script\n", "abstract": " O consumo de servi\u00e7os REST \u00e9 uma forma muito popular de invocar c\u00f3digo fornecido por terceiros. Porque \u00e9 particularmente predominante em aplica\u00e7\u00f5es web, muitos clientes destes servi\u00e7os s\u00e3o escritos em JavaScript e, recentemente, tamb\u00e9m em TypeScript. Ao escolher o TypeScript, os programadores passam a usufruir de uma an\u00e1lise est\u00e1tica de tipos que consegue verificar a corre\u00e7\u00e3o das chamadas \u00e0s fun\u00e7\u00f5es locais ou fornecidas por bibliotecas. No entanto, erros no consumo dos servi\u00e7os REST s\u00e3o encontrados apenas em tempo de execu\u00e7\u00e3o. Este artigo apresenta o SafeRestScript, uma linguagem desenvolvida com o objetivo de mostrar que \u00e9 poss\u00edvel estender o apoio da an\u00e1lise est\u00e1tica ao consumo de servi\u00e7os web. O SafeRestScript oferece uma cole\u00e7\u00e3o rica de tipos\u2014com objetos, arrays e tipos refinados\u2014que \u00e9 partilhada com o HeadREST, a linguagem para descrever as APIs dos servi\u00e7os REST consumidos.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Dependent Types for Class-based Mutable Objects (Artifact)\n", "abstract": " This artifact is based on DOL, a Dependent Object-oriented Language featuring dependent types, mutable objects and class-based inheritance with subtyping. The typechecker written in Xtend, a flexible and expressive dialect of Java, is a direct implementation of the algorithmic type system described in the companion paper. It uses a direct interface to Z3 theorem prover via its API for Java. The artifact ships with an IDE developed as an Eclipse plugin based on the Xtext framework.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Deductive Verification of MPI Protocols\n", "abstract": " This chapter presents the PARTYPES framework to statically verify C programs that use the Message Passing Interface, the widely used standard for message-based parallel applications. Programs are checked against a protocol specification that captures the interaction in an MPI program. The protocol language is based on a dependent type system that is able to express various MPI communication primitives, including point-to-point and collective operations. The verification uses VCC, a mechanical verifier for concurrent C programs. It takes the program protocol written in VCC format, an annotated version of the MPI library, and the program to verify, and checks whether the program complies with the protocol.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Gastric cancer in Portugal: Where do we stand, East or West?\n", "abstract": " OBJECTIVO/INTRODU\u00c7\u00c3O: The incidence of gastric cancer in Portugal is high and the environmental factors are the main risk, as diet intake and Helicobacter pylori infection. It was demonstrated that in the north of Portugal the gastric cancer has a higher incidence. The purpose of this analysis is to describe the clinicopathologic features of gastric cancer in a Central Hospital in Lisbon in the last 8 years, and compare those with similar features attributed to east and west countries.MATERIAL E M\u00c9TODOS: We analyzed 464 patients with gastric adenocarcinoma according to the anatomical location, clinical stage and pathological classification (Lauren).RESULTADOS: In the total gastric cancers, 30 were located in the cardia, 11 in the fundus, 131 in the body, 255 in the antrum and 37 were multicentric. Histologically 461 cancer were adenocarcinoma (52% intestinal type; 26% diffuse type; 16% mixed morphology and 6% unclassifed) and 3 were mixed adenoneuroendocrine carcinoma (MANEC). The Clinical stage (TNM) of the patients was: stage 0 (Tis) 1%, stage I 17%, stage II 24%, stage III 38%, stage IV 20%; in 63% of patients a radical surgery was performed.DISCUSS\u00c3O: In conclusion, the results of our institution have clinical and pathologic resemblance with the gastric cancer of the eastern countries. This should direct us in an equivalent oncosurgical approach.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Selected Papers On Programming Language Approaches To Concurrency And Communication-Centric Software (PLACES 2014)\n", "abstract": " Selected papers on Programming Language Approaches to Concurrency and Communication-cEntric Software (PLACES 2014) \u00d7 Close The Infona portal uses cookies, ie strings of text saved by a browser on the user's device. The portal can access those files and use them to remember the user's data, such as their chosen settings (screen view, interface language, etc.), or their login data. By using the Infona portal the user accepts automatic saving and using this information for portal operation purposes. More information on the subject can be found in the Privacy Policy and Terms of Service. By closing this window the user confirms that they have read the information on cookie usage, and they accept the privacy policy and the way cookies are used by the portal. You can change the cookie settings in your browser. I accept Polski English Login or register account remember me Password recovery INFONA - science \u2026", "num_citations": "1\n", "authors": ["668"]}
{"title": "Especifica\u00e7\u00e3o e Verifica\u00e7\u00e3o de Protocolos para Programas MPI\n", "abstract": " Resumo Message Passing Interface (MPI) \u00e9 a infraestrutura padr\u00e3o de troca de mensagens para o desenvolvimento de aplica\u00e7\u00f5es paralelas. Duas d\u00e9cadas ap\u00f3s a primeira vers\u00e3o da sua especifica\u00e7\u00e3o, aplica\u00e7\u00f5es baseadas em MPI correm hoje rotineiramente em super computadores e em grupos de computadores. Estas aplica\u00e7\u00f5es, escritas em C ou Fortran, exibem intrincados comportamentos, o que torna dif\u00edcil verificar estaticamente propriedades importantes, tais como a aus\u00eancia de corridas ou impasses.A abordagem que apresentamos neste artigo pretende validar programas escritos na linguagem C utilizando primitivas de comunica\u00e7\u00e3o MPI. Encontra-se dividida em duas linhas orientadoras. Definimos um protocolo de comunica\u00e7\u00e3o numa linguagem que cri\u00e1mos para o efeito, inspirada nos tipos de sess\u00e3o. Este protocolo \u00e9 depois traduzido para a linguagem de um verificador de software para C, o VCC. Anotamos depois o programa C com asser\u00e7\u00f5es que levam o verificador a provar ou a refutar a conformidade do programa com o protocolo. Grande parte das anota\u00e7\u00f5es necess\u00e1rias s\u00e3o introduzidas automaticamente por um anotador que desenvolvemos. At\u00e9 \u00e0 data conseguimos validar com sucesso v\u00e1rios programas que atestam o sucesso da nossa abordagem.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Dynamic Roles in Multiparty Communicating Systems\n", "abstract": " Communication protocols in distributed systems often specify the roles of the parties involved in the communications, eg, for enforcing security policies or task assignment purposes. Ensuring that implementations follow role-based protocol specifications is challenging, especially in scenarios found, eg, in business processes and web applications, where multiple peers are involved, single peers participate in several roles, or single roles are carried out by several peers. We present a type-based analysis for statically verifying role-based multiparty interactions, based on a simple \u03c0-calculus model and prior work on conversation types. Our main result ensures well-typed systems follow the role-based protocols prescribed by the types, and addresses systems where roles have dynamic distributed implementations.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Typing dynamic roles in multiparty interaction\n", "abstract": " We present a type-based analysis for role-based multiparty interaction. Novel to our approach are the notions that a role specified in a protocol may be carried out by several parties, and that one party may assume di%erent roles at di%erent stages of the protocol. We build on Conversation Types by adding roles to protocol specifications. Systems are modeled in \u21e4-calculus extended with labeled communication and role annotations. The main result shows that well-typed systems follow the role-based protocols prescribed by the types, addressing systems where roles have dynamic distributed implementations.", "num_citations": "1\n", "authors": ["668"]}
{"title": "Runtime checking Java code using ConGu\n", "abstract": " Reposit\u00f3rio da Universidade de Lisboa: Runtime checking Java code using ConGu Skip navigation P\u00e1gina principal Percorrer Comunidades & Colec\u00e7\u00f5es Percorrer Itens por: Data de publica\u00e7\u00e3o Autor Orientador T\u00edtulo Assunto Tipo de Documento Tipo de Acesso \u00cdndice de Autoridade Idioma portugu\u00eas english Entrar \u00c1rea Pessoal Servi\u00e7o de alertas Editar conta Reposit\u00f3rio da Universidade de Lisboa logo 1.Reposit\u00f3rio da Universidade de Lisboa 2.Comunidades & Colec\u00e7\u00f5es 3.Faculdade de Ci\u00eancias (FC) 4.Departamento de Inform\u00e1tica / Department of Informatics (FC-DI) 5.Lasige - Large-Scale Informatics Systems Laboratory (FC-DI-Lasige) 6.FC-DI-Lasige - Articles in International Journals Utilize este identificador para referenciar este registo: http://hdl.handle.net/10451/14683 T\u00edtulo: Runtime checking Java code using ConGu Autor: Vasco T. Vasconcelos Isabel Nunes Ant\u00f3nia Lopes Nuno Ramiro Pedro Crispim \u2026", "num_citations": "1\n", "authors": ["668"]}
{"title": "The Automotive Case Study in the Sensoria Core Calculi\n", "abstract": " In this note we show how two case studies from the automotive scenario can be represented in SSCC [4] in a satisfactory way. The first case study (a sight service that dinamically shows sights according to the driver\u2019s preferences) is straightforward to model. The second case study (a dinner service that allows the driver to make a reservation at a restaurant with some interaction) raises some problems with communication and typing of the resulting processes, which we then show can be solved without compromising the motivation behind SSCC.", "num_citations": "1\n", "authors": ["668"]}
{"title": "TyCO User\u2019s Manual, Version 0.2\n", "abstract": " TyCO is a form of the asynchronous-calculus featuring rst class objects, asynchronous messages and template de nitions. The calculus formally describes the concurrent interaction of ephemeral objects through asynchronous communication. Synchronous communication is implemented with continuations. Templates are speci cations of processes abstracted on a sequence of variables allowing, for example, for classes to be modeled. Unbounded behavior is modeled through explicit instantiation of recursive templates. A type system 7] assigns monomorphic types to variables and polymorphic types to templates variables. TyCO provides a very clean model for an object-oriented language which combines the bene ts of the formal framework of process calculi with the characteristics of actor systems. Actually, objects in TyCO are reminiscent of actors 1, 2] in several ways:", "num_citations": "1\n", "authors": ["668"]}
{"title": "Towards an algebra of dynamic object types\n", "abstract": " We propose an algebra of object types that characterises the semantics of concurrent objects in a process calculus setting where the communication is asynchronous. The types are non-uniform, and provide an internal and synchronous view of the objects that inhabit them. These ideas, along with the algebraic laws, are based on a notion of bisimulation that is unlike other notions in the literature.", "num_citations": "1\n", "authors": ["668"]}
{"title": "A Predicative Polymorphic Type System for a Calculus of Objects\n", "abstract": " The present paper introduces alt ulltyped calculus of $\\cdot $ intended objects to capture intrinsic aspects of con-current objects communicating via $\\dot {\\zeta}\\iota sync1\\iota\\iota\\cdot 0\\iota tO $ us message passing, together with a typing system assigll-ing typings to terms in tlle calculus. Types llleclllt to describe the kind $ oi $ messages an objcct $ m_ {\\dot {c}}\\iota y\\iota\\cdot (\\backslash.-$ ceive are assigned to the free names in a $1 $) $\\iota\\cdot og\\iota\\cdot i111 $, resulting in a scenario where a program is assiglied multiple name-type pairs. Tlten, a ML-like let ([(} $ c1_ {\\dot {C}}\\iota-$ ration is introduced together witlt an extension of\\dagger. $| _ {1 (}\\backslash $. monomorphic typing assignment system, wllicli allows to declare a term of a polynlorplzic type and $ n $ bc it. multiple times with different types, illstances of tlie type of the declared terln. Tbe systcm enjoys desirable properties, such as subject-lcduction wllidl illl-plies that programs that coniply to the $ tyl $) $ i\\iota\\downarrow gel $ isci-pline do not suffer frorn $1^{\\cdot} tntinle $ errors, $\\dot {\\subset}\\iota\\backslash $ well as thc existence and computability of $1 $) $\\iota\\cdot i_ {t1} ci_ {1}) _ {\\subset}\u2019\\iota 1$ types. Ful-thermore, we present au efficient algoritlnn to extract tlle principal typing of a term.", "num_citations": "1\n", "authors": ["668"]}