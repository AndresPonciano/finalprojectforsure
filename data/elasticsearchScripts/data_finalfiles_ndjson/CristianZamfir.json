{"title": "Preventing shilling attacks in online recommender systems\n", "abstract": " Collaborative filtering techniques have been successfully employed in recommender systems in order to help users deal with information overload by making high quality personalized recommendations. However, such systems have been shown to be vulnerable to attacks in which malicious users with carefully chosen profiles are inserted into the system in order to push the predictions of some targeted items. In this paper we propose several metrics for analyzing rating patterns of malicious users and evaluate their potential for detecting such shilling attacks. Building upon these results, we propose and evaluate an algorithm for protecting recommender systems against shilling attacks. The algorithm can be employed for monitoring user ratings and removing shilling attacker profiles from the process of computing recommendations, thus maintaining the high quality of the recommendations.", "num_citations": "362\n", "authors": ["1824"]}
{"title": "Parallel symbolic execution for automated real-world software testing\n", "abstract": " This paper introduces Cloud9, a platform for automated testing of real-world software. Our main contribution is the scalable parallelization of symbolic execution on clusters of commodity hardware, to help cope with path explosion. Cloud9 provides a systematic interface for writing\" symbolic tests\" that concisely specify entire families of inputs and behaviors to be tested, thus improving testing productivity. Cloud9 can handle not only single-threaded programs but also multi-threaded and distributed systems. It includes a new symbolic environment model that is the first to support all major aspects of the POSIX interface, such as processes, threads, synchronization, networking, IPC, and file I/O. We show that Cloud9 can automatically test real systems, like memcached, Apache httpd, lighttpd, the Python interpreter, rsync, and curl. We show how Cloud9 can use existing test suites to generate new test cases that capture\u00a0\u2026", "num_citations": "290\n", "authors": ["1824"]}
{"title": "Execution synthesis: a technique for automated software debugging\n", "abstract": " Debugging real systems is hard, requires deep knowledge of the code, and is time-consuming. Bug reports rarely provide sufficient information, thus forcing developers to turn into detectives searching for an explanation of how the program could have arrived at the reported failure point.", "num_citations": "275\n", "authors": ["1824"]}
{"title": "Cloud9: A software testing service\n", "abstract": " Cloud9 aims to reduce the resource-intensive and laborintensive nature of high-quality software testing. First, Cloud9 parallelizes symbolic execution (an effective, but still poorly scalable test automation technique) to large shared-nothing clusters. To our knowledge, Cloud9 is the first symbolic execution engine that scales to large clusters of machines, thus enabling thorough automated testing of real software in conveniently short amounts of time. Preliminary results indicate one to two orders of magnitude speedup over a state-of-the-art symbolic execution engine. Second, Cloud9 is an on-demand software testing service: it runs on compute clouds, like Amazon EC2, and scales its use of resources over a wide dynamic range, proportionally with the testing task at hand.", "num_citations": "272\n", "authors": ["1824"]}
{"title": "Deadlock Immunity: Enabling Systems to Defend Against Deadlocks.\n", "abstract": " Deadlock immunity is a property by which programs, once afflicted by a given deadlock, develop resistance against future occurrences of that and similar deadlocks. We describe a technique that enables programs to automatically gain such immunity without assistance from programmers or users. We implemented the technique for both Java and POSIX threads and evaluated it with several real systems, including MySQL, JBoss, SQLite, Apache ActiveMQ, Limewire, and Java JDK. The results demonstrate effectiveness against real deadlock bugs, while incurring modest performance overhead and scaling to 1024 threads. We therefore conclude that deadlock immunity offers programmers and users an attractive tool for coping with elusive deadlocks.", "num_citations": "202\n", "authors": ["1824"]}
{"title": "Automated software testing as a service\n", "abstract": " This paper makes the case for TaaS--automated software testing as a cloud-based service. We present three kinds of TaaS: a\" programmer's sidekick\" enabling developers to thoroughly and promptly test their code with minimal upfront resource investment; a\" home edition\" on-demand testing service for consumers to verify the software they are about to install on their PC or mobile device; and a public\" certification service,\" akin to Underwriters Labs, that independently assesses the reliability, safety, and security of software.", "num_citations": "197\n", "authors": ["1824"]}
{"title": "Data races vs. data race bugs: telling the difference with Portend\n", "abstract": " Even though most data races are harmless, the harmful ones are at the heart of some of the worst concurrency bugs. Alas, spotting just the harmful data races in programs is like finding a needle in a haystack: 76%-90% of the true data races reported by state-of-the-art race detectors turn out to be harmless [45]. We present Portend, a tool that not only detects races but also automatically classifies them based on their potential consequences: Could they lead to crashes or hangs? Could their effects be visible outside the program? Are they harmless? Our proposed technique achieves high accuracy by efficiently analyzing multiple paths and multiple thread schedules in combination, and by performing symbolic comparison between program outputs. We ran Portend on 7 real-world applications: it detected 93 true data races and correctly classified 92 of them, with no human effort. 6 of them are harmful races. Portend's\u00a0\u2026", "num_citations": "135\n", "authors": ["1824"]}
{"title": "Selective symbolic execution\n", "abstract": " Symbolic execution is a powerful technique for analyzing program behavior, finding bugs, and generating tests, but suffers from severely limited scalability: the largest programs that can be symbolically executed today are on the order of thousands of lines of code. To ensure feasibility of symbolic execution, even small programs must curtail their interactions with libraries, the operating system, and hardware devices. This paper introduces selective symbolic execution, a technique for creating the illusion of fullsystem symbolic execution, while symbolically running only the code that is of interest to the developer. We describe a prototype that can symbolically execute arbitrary portions of a full system, including applications, libraries, operating system, and device drivers. It seamlessly transitions back and forth between symbolic and concrete execution, while transparently converting system state from symbolic to concrete and back. Our technique makes symbolic execution practical for large software that runs in real environments, without requiring explicit modeling of these environments.", "num_citations": "128\n", "authors": ["1824"]}
{"title": "RaceMob: Crowdsourced data race detection\n", "abstract": " Some of the worst concurrency problems in multi-threaded systems today are due to data races---these bugs can have messy consequences, and they are hard to diagnose and fix. To avoid the introduction of such bugs, system developers need discipline and good data race detectors; today, even if they have the former, they lack the latter.", "num_citations": "105\n", "authors": ["1824"]}
{"title": "Automatic generation of program execution that reaches a given failure point\n", "abstract": " An execution of a target software program that causes a particular bug to manifest itself is generated. A target software program is received. A bug report generated by an execution of the target software program is received. The bug report describes a particular bug within the target software program. A bug type of the particular bug is received. A synthesized execution file is generated based on the target software program, the bug report, and the bug type. The synthesized execution file specifies an execution of the target software program that causes the particular bug to manifest itself.", "num_citations": "38\n", "authors": ["1824"]}
{"title": "Automated classification of data races under both strong and weak memory models\n", "abstract": " Data races are one of the main causes of concurrency problems in multithreaded programs. Whether all data races are bad, or some are harmful and others are harmless, is still the subject of vigorous scientific debate [Narayanasamy et al. 2007; Boehm 2012]. What is clear, however, is that today's code has many data races [Kasikci et al. 2012; Jin et al. 2012; Erickson et al. 2010], and fixing data races without introducing bugs is time consuming [Godefroid and Nagappan 2008]. Therefore, it is important to efficiently identify data races in code and understand their consequences to prioritize their resolution.    We present Portend+, a tool that not only detects races but also automatically classifies them based on their potential consequences: Could they lead to crashes or hangs? Could their effects be visible outside the program? Do they appear to be harmless? How do their effects change under weak memory models\u00a0\u2026", "num_citations": "22\n", "authors": ["1824"]}
{"title": "Debug Determinism: The Sweet Spot for Replay-Based Debugging.\n", "abstract": " Deterministic replay tools offer a compelling approach to debugging hard-to-reproduce bugs. Recent work on relaxed-deterministic replay techniques shows that replay debugging with low in-production overhead is possible. However, despite considerable progress, a replaydebugging system that offers not only low in-production runtime overhead but also high debugging utility, remains out of reach. To this end, we argue that the research community should strive for debug determinism\u2014a new determinism model premised on the idea that effective debugging entails reproducing the same failure and the same root cause as the original execution. We present ideas on how to achieve and quantify debug determinism and give preliminary evidence that a debugdeterministic system has potential to provide both low in-production overhead and high debugging utility.", "num_citations": "21\n", "authors": ["1824"]}
{"title": "Low-overhead bug fingerprinting for fast debugging\n", "abstract": " There is a gap between the information available at the time of a software failure and the information actually shipped to developers in the corresponding bug report. As a result, identifying the cause of the bug based on this bug report is often difficult. To close this gap, we propose bug fingerprints\u2014an augmentation of classic automated bug reports with runtime information about how the reported bug occurred in production.               Classic automated bug reporting systems contain at most a coredump that describes the final manifestation of a bug. In contrast, bug fingerprints contain additional small amounts of highly relevant runtime information that helps understand how the bug occurred. We show how these \u201cfingerprints\u201d can be used to speed up both manual and automated debugging. As a proof of concept, we present DCop, a system for collecting such runtime information about deadlocks and including\u00a0\u2026", "num_citations": "18\n", "authors": ["1824"]}
{"title": "Automated debugging for arbitrarily long executions\n", "abstract": " One of the most energy-draining and frustrating parts of software development is playing detective with elusive bugs. In this paper we argue that automated postmortem debugging of failures is feasible for real, inproduction systems with no runtime recording. We propose reverse execution synthesis (RES), a technique that takes a coredump obtained after a failure and automatically computes the suffix of an execution that leads to that coredump. RES provides a way to then play back this suffix in a debugger deterministically, over and over again. We argue that the RES approach could be used to (1) automatically classify bug reports based on their root cause,(2) automatically identify coredumps for which hardware errors (eg, bad memory), not software bugs are to blame, and (3) ultimately help developers reproduce the root cause of the failure in order to debug it.", "num_citations": "15\n", "authors": ["1824"]}
{"title": "Parallel symbolic execution on cluster of commodity hardware\n", "abstract": " A symbolic execution task is dynamically divided among multiple computing nodes. Each of the multiple computing nodes explores a different portion of a same symbolic execution tree independently of other computing nodes. Workload status updates are received from the multiple computing nodes. A workload status update includes a length of a job queue of a computing node. A list of the multiple computing nodes ordered based on the computing nodes' job queue lengths is generated. A determination is made regarding whether a first computing node in the list is underloaded. A determination is made regarding whether a last computing node in the list is overloaded. Responsive to the first computing node being underloaded and the last computing node being overloaded, a job transfer request is generated that instructs the last computing node to transfer a set of one or more jobs to the first computing node.", "num_citations": "11\n", "authors": ["1824"]}
{"title": "Automating the debugging of datacenter applications with ADDA\n", "abstract": " Debugging data-intensive distributed applications running in datacenters is complex and time-consuming because developers do not have practical ways of deterministically replaying failed executions. The reason why building such tools is hard is that non-determinism that may be tolerable on a single node is exacerbated in large clusters of interacting nodes, and datacenter applications produce terabytes of intermediate data exchanged by nodes, thus making full input recording infeasible. We present ADDA, a replay-debugging system for datacenters that has lower recording and storage overhead than existing systems. ADDA is based on two techniques: First, ADDA provides control plane determinism, leveraging our observation that many typical datacenter applications consist of a separate \u201ccontrol plane\u201d and \u201cdata plane\u201d, and most bugs reside in the former. Second, ADDA does not record \u201cdata plane\u201d inputs\u00a0\u2026", "num_citations": "9\n", "authors": ["1824"]}
{"title": "{CORD}: A Collaborative Framework for Distributed Data Race Detection\n", "abstract": " Modern concurrent software is riddled with data races and these races constitute the source of many problems. Data races are hard to detect accurately before software is shipped and, once they cause failures in production, developers find it challenging to reproduce and debug them.", "num_citations": "8\n", "authors": ["1824"]}
{"title": "Live Migration of User Environments Across Wide Area Networks\n", "abstract": " A complex challenge in mobile computing is to allow the user to migrate her highly customised environment while moving to a different location and to continue work without interruption. I motivate why this is a highly desirable capability and conduct a survey of the current approaches towards this goal and explain their limitations. I then propose a new architecture to support user mobility by live migration of a user\u2019s operating system instance over the network. Previous work includes the Collective and Internet Suspend/Resume projects that have addressed migration of a user\u2019s environment by suspending the running state and resuming it at a later time. In contrast to previous work, this work addresses live migration of a user\u2019s operating  system instance across wide area links. Live migration is done by performing most of the migration while the operating system is still running, achieving very little downtime and preserving all network connectivity.  I developed an initial proof of concept of this solution. It relies on migrating whole operating systems using the Xen virtual machine and provides a way to perform live migration of persistent storage as well as the network connections across subnets. These challenges have not been addressed previously in this scenario. In a virtual machine environment, persistent storage is provided by virtual block devices. The architecture supports decentralized virtual block device replication across wide area network links, as well as migrating network connection across subnetworks using the Host Identity Protocol. The proposed architecture is compared against existing solutions and an initial performance evaluation\u00a0\u2026", "num_citations": "7\n", "authors": ["1824"]}
{"title": "Automated software testing as a service\n", "abstract": " This paper makes the case for TaaS\u2014automated software testing as a cloud-based service. We present three kinds of TaaS: a \u201cprogram-mer\u2019s sidekick\u201d enabling developers to thoroughly and promptly test their code with minimal upfront resource investment; a \u201chome edition\u201d on-demand testing service for consumers to verify the soft-ware they are about to install on their PC or mobile device; and a public \u201ccertification service,\u201d akin to Underwriters Labs, that inde-pendently assesses the reliability, safety, and security of software. TaaS automatically tests software, without human involvement from the service user\u2019s or provider\u2019s side. This is unlike today\u2019s \u201ctesting as a service\u201d businesses, which employ humans to write tests. Our goal is to take recently proposed techniques for auto-mated testing\u2014even if usable only on toy programs\u2014and make them practical by modifying them to harness the resources of com-pute clouds. Preliminary work suggests it is technically feasible to do so, and we find that TaaS is also compelling from a social and business point of view.", "num_citations": "3\n", "authors": ["1824"]}
{"title": "Automating the debugging of datacenter applications with ADDA\n", "abstract": " Debugging data-intensive distributed applications running in a datacenter (\u201cdatacenter applications\u201d) is complex and time-consuming. Developers wish they had a way to deterministically replay failed executions with little human effort, but unfortunately no such tool exists today. We see two challenges in replay-based debugging: First, the clusters used to run datacenter applications consist of many nodes, so the nondeterminism resulting from multithreaded execution on a single node is compounded by the size of the cluster. Second, datacenter applications produce terabytes of intermediate data shipped from one node to the next\u2014the total data volume, itself proportional to cluster size, makes full input recording for potential subsequent replay infeasible. We present ADDA, a replay-debugging system for datacenter applications. We observe that these applications often consist of a separate \u201ccontrol plane\u201d and \u201cdata plane,\u201d and that the applications\u2019 initial inputs are typically persisted in append-only storage for reasons unrelated to debugging. Building upon these observations, ADDA leverages the control/data plane separation to make recording of debug-critical data scalable even in large clusters, it deterministically re-synthesizes intermediate data based on the (already available) initial inputs, and performs reduced-scale replay, ie, recreates failed executions on just a subset of the original cluster. We show that ADDA scales well and deterministically replays real-world failures in Hypertable and Memcached. We also argue that ADDA\u2019s techniques generalize to a broader set of datacenter applications.", "num_citations": "2\n", "authors": ["1824"]}
{"title": "Live migration of virtual block devices\n", "abstract": " II. VIRTUAL BLOCK DEVICE MIGRATION We have developed and evaluated a prototype for Xen [2] live migration without NAS. Virtual block devices are live migrated with the aid of DRBD [6], a popular cluster disk mirroring software.Our prototype extends Xen live migration with an XMLRPC client and daemon that handle VBD migration through a set of commands issued to the DRBD replicated devices. Live migration commands from Xen\u2019s privileged domains are intercepted and signal the destination to start the resynchronization process which copies to the destination the outdated blocks. Once the replicas are up to date, DRBD mirrors writes to the two virtual block devices synchronously meaning that at any moment the drives are up to date. From this moment on, the last stage of memory migration can start and the user\u2019s virtual machine can be resumed at the new site. At this point, the two replicas can be detached, leaving no residual dependencies to the originating site. Our prototype shows that live VBD migration is feasible and does not significantly impact migration time and downtime.", "num_citations": "2\n", "authors": ["1824"]}
{"title": "An efficient ecash platform for smart phones\n", "abstract": " This paper describes the ECash project under development at the\" Politehnica\" University Bucharest, in the IBM eGovernment laboratory. Our project implements a system where digital cash can be downloaded, over an Internet connection, on the smart phone and can be used for transacting with Bluetooth enabled vendors. We present an efficient implementation of a new electronic cash protocol. Both the protocol and the implementation are designed for mobile devices with limited computing power and storage space. The system is based on a lightweight cryptographic primitive, the Merkle Hash-Tree and uses only symmetric cryptography, therefore it has the smallest coin size compared to previous protocols. Our system shifts all the complexity to the bank so that in our case the vendor can also be a mobile device running under the same constraints.", "num_citations": "2\n", "authors": ["1824"]}
{"title": "Execution Synthesis: A Technique for Automating the Debugging of Software\n", "abstract": " Debugging real systems is hard, requires deep knowledge of the target code, and is time-consuming. Bug reports rarely provide sufficient information for debugging, thus forcing developers to turn into detectives searching for an explanation of how the program could have arrived at the reported failure state.This thesis introduces execution synthesis, a technique for automating this detective work: given a program and a bug report, execution synthesis automatically produces an execution of the program that leads to the reported bug symptoms. Using a combination of static analysis and symbolic execution, the technique \u201csynthesizes\u201d a thread schedule and various required program inputs that cause the bug to manifest. The synthesized execution can be played back deterministically in a regular debugger, like gdb. This is particularly useful in debugging concurrency bugs, because it transforms otherwise non-deterministic bugs into bugs that can be deterministically observed in a debugger.", "num_citations": "1\n", "authors": ["1824"]}