{"title": "Managing Multiple Feature Models: Foundations, Language and Applications\n", "abstract": " L\u2019ing\u00e9nierie des lignes de produits logiciels (LdPs) est un paradigme pour la mod\u00e9lisation et le d\u00e9veloppement de familles de syst\u00e8mes logiciels plut\u00f4t que de syst\u00e8mes logiciels individuels. Son objectif porte sur les moyens de produire et maintenir efficacement des produits logiciels similaires en exploitant ce qu\u2019ils ont en commun et en g\u00e9rant ce qui varie entre eux. Par analogie, la pratique dans l\u2019industrie automobile est de construire une ligne de production dans laquelle des variations personnalis\u00e9es mais tout de m\u00eame similaires de mod\u00e8les de voitures sont produits. Les feature models (FMs) sont une repr\u00e9sentation fondamentale pour sp\u00e9cifier et raisonner sur la commonalit\u00e9 et la variabilit\u00e9 des LdPs en termes de features (caract\u00e9ristiques). Les FMs deviennent de plus en plus complexes, manipul\u00e9s par plusieurs d\u00e9veloppeurs ou organisations, utilis\u00e9s pour d\u00e9crire des features \u00e0 divers niveaux d\u2019abstraction et qui sont mises en relation de diff\u00e9rentes fa\u00e7ons. Maintenir un seul gros FM n\u2019est ni r\u00e9aliste ni souhaitable. Au contraire une tendance forte est de consid\u00e9rer de multiples FMs. Dans cette th\u00e8se, nous d\u00e9veloppons les fondations th\u00e9oriques et un support pratique pour g\u00e9rer de multiples FMs. Nous concevons et d\u00e9veloppons un ensemble d\u2019op\u00e9rateurs de composition et de d\u00e9composition (aggregate, merge, slice) pour supporter la s\u00e9paration des pr\u00e9occupations. Les op\u00e9rateurs sont formellement d\u00e9finis et impl\u00e9ment\u00e9s avec un algorithme qui garantit des propri\u00e9t\u00e9s s\u00e9mantiques. Nous montrons comment les op\u00e9rateurs de composition et de d\u00e9composition peuvent \u00eatre combin\u00e9s ensemble ou avec d\u2019autres op\u00e9rateurs d\u2019\u00e9dition ou de\u00a0\u2026", "num_citations": "41\n", "authors": ["1517"]}
{"title": "Synthesis of attributed feature models from product descriptions\n", "abstract": " Many real-world product lines are only represented as nonhierarchical collections of distinct products, described by their configuration values. As the manual preparation of feature models is a tedious and labour-intensive activity, some techniques have been proposed to automatically generate boolean feature models from product descriptions. However, none of these techniques is capable of synthesizing feature attributes and relations among attributes, despite the huge relevance of attributes for documenting software product lines. In this paper, we introduce for the first time an algorithmic and parametrizable approach for computing a legal and appropriate hierarchy of features, including feature groups, typed feature attributes, domain values and relations among these attributes. We have performed an empirical evaluation by using both randomized configuration matrices and real-world examples. The initial\u00a0\u2026", "num_citations": "32\n", "authors": ["1517"]}
{"title": "Towards synthesis of attack trees for supporting computer-aided risk analysis\n", "abstract": " Attack trees are widely used in the fields of defense for the analysis of risks (or threats) against electronics systems, computer control systems or physical systems. Based on the analysis of attack trees, practitioners can define actions to engage in order to reduce or annihilate risks. A major barrier to support computer-aided risk analysis is that attack trees can become largely complex and thus hard to specify. This paper is a first step towards a methodology, formal foundations as well as automated techniques to synthesize attack trees from a high-level description of a system. Attacks are expressed as a succession of elementary actions and high-level actions can be used to abstract and organize attacks into exploitable attack trees. We describe our tooling support and identify open challenges for supporting the analysis of risks.", "num_citations": "26\n", "authors": ["1517"]}
{"title": "Automating variability model inference for component-based language implementations\n", "abstract": " Recently, domain-specific language development has become again a topic of interest, as a means to help designing solutions to domain-specific problems. Componentized language frameworks, coupled with variability modeling, have the potential to bring language development to the masses, by simplifying the configuration of a new language from an existing set of reusable components. However, designing variability models for this purpose requires not only a good understanding of these frameworks and the way components interact, but also an adequate familiarity with the problem domain.", "num_citations": "25\n", "authors": ["1517"]}
{"title": "ATSyRa: an integrated environment for synthesizing attack trees\n", "abstract": " Attack trees are widely considered in the fields of security for the analysis of risks (or threats) against electronics, computer control, or physical systems. A major barrier is that attack trees can become largely complex and thus hard to specify. This paper presents ATSyRA, a tooling environment to automatically synthesize attack trees of a system under study. ATSyRA provides advanced editors to specify high-level descriptions of a system, high-level actions to structure the tree, and ways to interactively refine the synthesis. We illustrate how users can specify a military building, abstract and organize attacks, and eventually obtain a readable attack tree.", "num_citations": "23\n", "authors": ["1517"]}
{"title": "Tackling high variability in video surveillance systems through a model transformation approach\n", "abstract": " This work explores how model-driven engineering techniques can support the configuration of systems in domains presenting multiple variability factors. Video surveillance is a good candidate for which we have an extensive experience. Ultimately, we wish to automatically generate a software component assembly from an application specification, using model to model transformations. The challenge is to cope with variability both at the specification and at the implementation levels. Our approach advocates a clear separation of concerns. More precisely, we propose two feature models, one for task specification and the other for software components. The first model can be transformed into one or several valid component configurations through step-wise specialization. This paper outlines our approach, focusing on the two feature models and their relations. We particularly insist on variability and constraint\u00a0\u2026", "num_citations": "22\n", "authors": ["1517"]}
{"title": "Exploring the Synergies Between Feature Models and Ontologies.\n", "abstract": " A factor slowing down the use of feature models is that either the concepts or the relations expressed in a feature model are not defined at all, or defined in an unsatisfactory manner; feature models are sometimes too vague to be analyzed by a reasoning tool. It is thus difficult to determine if the features in a feature model are arranged and structured consistently with domain knowledge and if they are accurately expressed, organized and represented. Ontology modeling can improve feature modeling by providing additional information relevant for the domain in which a feature model is constructed. Finding synergies between feature models and ontologies will aid an SPL engineer in accurately expressing, organizing and representing features in their feature models. In this paper, we look at potential benefits in using the two modeling formalisms together, we identify issues and challenges considering the gap between the two formalisms and discuss the importance of this gap. We report on our current ideas and results.", "num_citations": "19\n", "authors": ["1517"]}
{"title": "A decision-making process for exploring architectural variants in systems engineering\n", "abstract": " In systems engineering, practitioners shall explore numerous architectural alternatives until choosing the most adequate variant. The decision-making process is most of the time a manual, time-consuming, and error-prone activity. The exploration and justification of architectural solutions is ad-hoc and mainly consists in a series of tries and errors on the modeling assets. In this paper, we report on an industrial case study in which we apply variability modeling techniques to automate the assessment and comparison of several candidate architectures (variants). We first describe how we can use a model-based approach such as the Common Variability Language (CVL) to specify the architectural variability. We show that the selection of an architectural variant is a multi-criteria decision problem in which there are numerous interactions (veto, favor, complementary) between criteria.", "num_citations": "9\n", "authors": ["1517"]}
{"title": "A formal modeling and analysis framework for software product line of preemptive real-time systems\n", "abstract": " This paper presents a formal analysis framework to analyze a family of platform products wrt real-time properties. First, we propose an extension of the widely-used feature model, called Property Feature Model (PFM), that distinguishes features and properties explicitly Second, we present formal behavioral models of components of a real-time scheduling unit such that all real-time scheduling units implied by a PFM are automatically composed to be analyzed against the properties given by the PFM. We apply our approach to the verification of the schedulability of a family of scheduling units using the symbolic and statistical model checkers of Uppaal.", "num_citations": "8\n", "authors": ["1517"]}
{"title": "Large-scale analysis of chess games with chess engines: A preliminary report\n", "abstract": " The strength of chess engines together with the availability of numerous chess games have attracted the attention of chess players, data scientists, and researchers during the last decades. State-of-the-art engines now provide an authoritative judgement that can be used in many applications like cheating detection, intrinsic ratings computation, skill assessment, or the study of human decision-making. A key issue for the research community is to gather a large dataset of chess games together with the judgement of chess engines. Unfortunately the analysis of each move takes lots of times. In this paper, we report our effort to analyse almost 5 millions chess games with a computing grid. During summer 2015, we processed 270 millions unique played positions using the Stockfish engine with a quite high depth (20). We populated a database of 1+ tera-octets of chess evaluations, representing an estimated time of 50 years of computation on a single machine. Our effort is a first step towards the replication of research results, the supply of open data and procedures for exploring new directions, and the investigation of software engineering/scalability issues when computing billions of moves.", "num_citations": "6\n", "authors": ["1517"]}
{"title": "On the power of abstraction: a model-driven co-evolution approach of software code\n", "abstract": " Model-driven software engineering fosters abstraction through the use of models and then automation by transforming them into various artefacts, in particular to code, for example: 1) from architectural models to code, 2) from metamodels to API code (with EMF in Eclipse), 3) from entity models to front-end and back-end code in Web stack application (with JHispter), etc. In all these examples, the generated code is usually enriched by developers with additional code implementing advanced functionalities (eg, checkers, recommenders, etc.) to build a full coherent system. When the system must evolve, so are the models to re-generate the code. As a result, the developers' enriched code may be impacted and thus need to co-evolve accordingly. Many approaches support the co-evolution of various artifacts, but not the co-evolution of code. This paper sheds light on this issue and envisions to fill this gap.", "num_citations": "4\n", "authors": ["1517"]}
{"title": "Tooling support for variability and architectural patterns in systems engineering\n", "abstract": " In systems engineering, the deployment of software components is error-prone since numerous safety and security rules have to be preserved. Furthermore, many deployments on different heterogeneous platforms are possible. In this paper we present a technological solution to assist industrial practitioners in producing a safe and secure solution out of numerous architectural variants. First, we introduce a pattern technology that provides correct-by-construction deployment models through the reuse of modeling artifacts organized in a catalog. Second, we develop a variability solution, connected to the pattern technology and based on an extension of the common variability language, for supporting the synthesis of model-based architectural variants. This paper describes a live demonstration of an industrial effort seeking to bridge the gap between variability modeling and model-based systems engineering\u00a0\u2026", "num_citations": "4\n", "authors": ["1517"]}
{"title": "Interactive visualisation of products in online configurators: a case study for variability modelling technologies\n", "abstract": " Numerous companies develop interactive environments to assist users in customising sales products through the selection of configuration options. A visual representation of these products is an important factor in terms of user experience. However, an analysis of 100+ existing configurators highlights that not all provide visual representations of configured products. One of the current challenges is the trade-off developers face between either the memory consuming use of pregenerated images of all the combinations of options, or rendering products on the fly, which is non trivial to implement efficiently. We believe that a new approach to associate product configurations to visual representations is needed to compose and render them dynamically. In this paper we present a formal statement of the problem and a model-driven perspective for addressing it as well as our ongoing work and further challenges.", "num_citations": "4\n", "authors": ["1517"]}
{"title": "Machine learning and configurable systems: a gentle introduction\n", "abstract": " The goal of this tutorial is to give a gentle introduction to how machine learning can be used to support software product line configuration. This is our second practical tutorial in this trending field. The tutorial is based on a systematic literature review and includes practical tasks (specialization, performance and bug prediction) on real-world systems (Linux, VaryLaTeX, x264). The material is designed for academics and practitioners with basic knowledge in software product lines and machine learning.", "num_citations": "3\n", "authors": ["1517"]}
{"title": "Software unbundling: Challenges and perspectives\n", "abstract": " Unbundling is a phenomenon that consists of dividing an existing software artifact into smaller ones. It can happen for different reasons, one of them is the fact that applications tend to grow in functionalities and sometimes this can negatively influence the user experience. For example, mobile applications from well-known companies are being divided into simpler and more focused new ones. Despite its current importance, little is known or studied about unbundling or about how it relates to existing software engineering approaches, such as modularization. Consequently, recent cases point out that it has been performed unsystematically and arbitrarily. In this article, our main goal is to present this novel and relevant concept and its underlying challenges in the light of software engineering, also exemplifying it with recent cases. We relate unbundling to standard software modularization, presenting the new\u00a0\u2026", "num_citations": "3\n", "authors": ["1517"]}
{"title": "Towards managing variability in the safety design of an automotive hall effect sensor\n", "abstract": " This paper discusses the merits and challenges of adopting software product line engineering (SPLE) as the main development process for an automotive Hall Effect sensor. This versatile component is integrated into a number of automotive applications with varying safety requirements (eg, windshield wipers and brake pedals).", "num_citations": "3\n", "authors": ["1517"]}
{"title": "First international workshop on languages for modelling variability (MODEVAR 2019)\n", "abstract": " Feature models were invented in 1990 and have been recognised as one of the main contributions to the software product line community. Although there have been several attempts to establish a sort of standard variability modelling language, there is still no consensus. There can be many motivations to have one but there is one that is very important: information sharing among researchers, tools or developers. This first international workshop is an interactive event where all participants shall share knowledge about how to build up a simple variability modelling language that all the community can agree on.", "num_citations": "2\n", "authors": ["1517"]}
{"title": "Efficient and complete FD-solving for extended array constraints\n", "abstract": " Array constraints are essential for handling data structures in automated reasoning and software verification. Unfortunately, the use of a typical finite domain (FD) solver based on local consistency-based filtering has strong limitations when constraints on indexes are combined with constraints on array elements and size. This paper proposes an efficient and complete FD-solving technique for extended constraints over (possibly unbounded) arrays. We describe a simple but particularly powerful transformation for building an equisatisfiable formula that can be efficiently solved using standard FD reasoning over arrays, even in the unbounded case. Experiments show that the proposed solver significantly outperforms FD solvers, and successfully competes with the best SMT-solvers.", "num_citations": "2\n", "authors": ["1517"]}
{"title": "A feature-based approach to system deployment and adaptation\n", "abstract": " Building large scale systems involves many design decisions, both at specification and implementation levels. This is due to numerous variants in the description of the task to achieve and its execution context as well as in the assembly of software components. We have modeled variability for large scale systems using feature diagrams, a formalism well suited for modeling variablility. These models are built with a clear separation of concerns between specification and implementation aspects. They are used at design and deployment time as well as at execution time. Our test application domain is video surveillance systems, from a software engineering perspective. These are good candidates to put model driven engineering to the test, because of the huge variability in both the surveillance tasks and the video analysis algorithms. They are also dynamically adaptive systems, thus suitable for models at run time\u00a0\u2026", "num_citations": "2\n", "authors": ["1517"]}
{"title": "Characterizing Black-box Composition Operators via Generated Tailored Benchmarks.\n", "abstract": " The integration of a model composition operator into a system is a challenging task: the properties associated with such operators can drastically change how the developers will be able to use it. In this paper, we describe a modelling framework that allows a software developer, who is not an expert in model composition, to describe the interface of the operators she wants to use, and describe the properties she expects from them to fit her needs (eg, idempotence, commutativity, associativity). This abstract description is used to pilot a property-based testing approach on generated code. We applied the approach to two case studies: feature model composition and Git merging.", "num_citations": "1\n", "authors": ["1517"]}
{"title": "Machine Learning and Configurable Systems: A Gentle Introduction\n", "abstract": " The goal of this tutorial is to give an introduction to how machine learning can be used to support activities related to the engineering of configurable systems and software product lines. To the best of our knowledge, this is the first practical tutorial in this trending field. The tutorial is based on a systematic literature review and includes practical tasks (specialization, performance prediction) on real-world systems (VaryLaTeX, x264).", "num_citations": "1\n", "authors": ["1517"]}