{"title": "Towards a theory of declarative knowledge\n", "abstract": " We identify a useful class of logic programs with negation, called stratified programs, that disallow certain combinations of recursion and negation. Programs in this class have a simple declarative and procedural meaning based, respectively, on model theory and a back-chaining interpreter. The standard model of a stratified program, which gives the program a declarative meaning and is independent of the stratification, is characterized in two ways. One is based on a fixed point theory of nonmonotonic operators and the other on an abstract declarative characterization. The back-chaining interpreter also determines the standard model. Finally, we prove the consistency of Clark's completion for stratified programs and attempt to clarify the sources of some previously reported difficulties with negation in logic programming.", "num_citations": "1769\n", "authors": ["1740"]}
{"title": "Principles of constraint programming\n", "abstract": " Constraints are everywhere: most computational problems can be described in terms of restrictions imposed on the set of possible solutions, and constraint programming is a problem-solving technique that works by incorporating those restrictions in a programming environment. It draws on methods from combinatorial optimisation and artificial intelligence, and has been successfully applied in a number of fields from scheduling, computational biology, finance, electrical engineering and operations research through to numerical analysis. This textbook for upper-division students provides a thorough and structured account of the main aspects of constraint programming. The author provides many worked examples that illustrate the usefulness and versatility of this approach to programming, as well as many exercises throughout the book that illustrate techniques, test skills and extend the text. Pointers to current research, extensive historical and bibliographic notes, and a comprehensive list of references will also be valuable to professionals in computer science and artificial intelligence", "num_citations": "1343\n", "authors": ["1740"]}
{"title": "Logic Programming.\n", "abstract": " Logic programming (in short LP) is a simple, yet powerful formalism suit-able for progranuming and for knowledge representation. It was introduced in 1974 by H. Kowalski. LP grew out of ann earlier work on automatic theorein proving based on the resolution method. The major difference is that LP can be used not only for proving but also for computing. In fact, LP offers a new programming paradigm, which was originally realized in Prolog, a programming language introduced in early seventies by a group led by A. Colruerauer.After an initially slow start LP grew twenty years later to an impressive field in computer science, in which by now a couple of thousand articles have been published. Recently, The Journal of Logic Programming celebrated its tenth year anniversary. A couple of annual conferences are nowadays taking place and interest in the subject does not seen to be waning. On the contrary. The logic\u00a0\u2026", "num_citations": "959\n", "authors": ["1740"]}
{"title": "Contributions to the theory of logic programming\n", "abstract": " Horn clauses of first-order predicate logic can be regarded as a high-level programming language when SLD-resoluUon, a special-purpose resolution theorem prover, is used as interpreter. Consequently, the semantics of Horn clauses can be studied both by model-theoreuc and fixpomt methods (in the sense of Scott). This posslbihty is exploited here by identifying the least (greatest) fixpomt with a least (greatest) model Successful termination of SLD-resolution is characterized by least fixpomts A semantic characterization of t'mlte failure of SLD-resoluuon is given, which coincides with the greatest fixpomt only for a special case of clauses. It is shown that nondetermmistlc flowchart schemata of bounded nondeterminaey are modeled by this special case; the connection between finite fadure and greatest fixpomt is then used to give a semantic characterization of termmauon, blocking, and nontermination of such\u00a0\u2026", "num_citations": "929\n", "authors": ["1740"]}
{"title": "Verification of sequential and concurrent programs\n", "abstract": " HIS BOOK CONTAINS a most comprehensive text that presents syntax-directed and compositional methods for the formal veri?-T cation of programs. The approach is not language-bounded in the sense that it covers a large variety of programming models and features that appear in most modern programming languages. It covers the classes of-quential and parallel, deterministic and non-deterministic, distributed and object-oriented programs. For each of the classes it presents the various c-teria of correctness that are relevant for these classes, such as interference freedom, deadlock freedom, and appropriate notions of liveness for parallel programs. Also, special proof rules appropriate for each class of programs are presented. In spite of this diversity due to the rich program classes cons-ered, there exist a uniform underlying theory of veri? cation which is synt-oriented and promotes compositional approaches to veri? cation, leading to scalability of the methods. The text strikes the proper balance between mathematical rigor and-dactic introduction of increasingly complex rules in an incremental manner, adequately supported by state-of-the-art examples. As a result it can serve as a textbook for a variety of courses on di? erent levels and varying durations. It can also serve as a reference book for researchers in the theory of veri?-tion, in particular since it contains much material that never before appeared in book form. This is specially true for the treatment of object-oriented p-grams which is entirely novel and is strikingly elegant.", "num_citations": "842\n", "authors": ["1740"]}
{"title": "Ten years of Hoare's logic: A survey\u2014Part I\n", "abstract": " A survey of various results concerning Hoare's approach to proving partial and total correctness of programs is presented. Emphasis is placed on the soundness and completeness issues. Various proof systems for while programs, recursive procedures, local variable declarations, and procedures with parameters, together with the corresponding soundness, completeness, and incompleteness results, are discussed.", "num_citations": "832\n", "authors": ["1740"]}
{"title": "Logic programming and negation: A survey\n", "abstract": " We survey here various approaches which were proposed to incorporate negation in logic programs. We concentrate on the proof-theoretic and model-theoretic issues and the relationships between them.", "num_citations": "652\n", "authors": ["1740"]}
{"title": "From logic programming to Prolog\n", "abstract": " Prolog is some twenty years old and so is logic programming. However, they were developed separately and these two developments never really merged. In particular, the books on Prolog place an emphasis on the explanation of various language features and concentrate on teaching the programming style and techniques. In contrast, the books on logic programming deal with the theoretical foundations of the subject and place an emphasis on the mathematical theory of the underlying concepts. As a result of these separate developments, verification of Prolog programs fell somewhere in the middle and did not receive the attention it deserved. Many Prolog programs are much simpler and shorter than their counterparts written in imperative programming languages. But for practically every Prolog program there exists a fine line separating the queries which yield correct results from the queries which \u201cgo wrong\u201d. So program verification is as important for Prolog as for other programming languages. The aim of this book is to introduce the foundations of logic programming and elements of Prolog, and show how the former can be applied to reason about the latter. To make the book also appropriate for teaching Prolog, a separate chapter on advanced features of Prolog is included. Due to its structure the book makes it possible to teach in the same course, in an integrated way, both logic programming and Prolog. It is appropriate for the senior undergraduate and for the graduate courses. In fact, we used it for both of them.Throughout the theoretical chapters some basic mathematical ability is needed to follow the arguments. We assume from the\u00a0\u2026", "num_citations": "536\n", "authors": ["1740"]}
{"title": "Constraint logic programming using ECLiPSe\n", "abstract": " Constraint logic programming lies at the intersection of logic programming, optimisation and artificial intelligence. It has proved a successful tool in many areas including production planning, transportation scheduling, numerical analysis and bioinformatics. Eclipse is one of the leading software systems that realise its underlying methodology. Eclipse is exploited commercially by Cisco, and is freely available and used for teaching and research in over 500 universities. This book has a two-fold purpose. It's an introduction to constraint programming, appropriate for one-semester courses for upper undergraduate or graduate students in computer science or for programmers wishing to master the practical aspects of constraint programming. By the end of the book, the reader will be able to understand and write constraint programs that solve complex problems. Second, it provides a systematic introduction to the Eclipse system through carefully-chosen examples that guide the reader through the language and illustrate its power, versatility and utility.", "num_citations": "532\n", "authors": ["1740"]}
{"title": "Limits for automatic verification of finite-state concurrent systems\n", "abstract": " In one of the most exciting developments in the theory of program correctness, Clarke and Emerson [1] and Queille and Sifakis [4] developed systems which automatically check whether a given finite-state concurrent program satisfies a given temporal formula. These systems allow us to verify the correctness of various nontrivial concurrent programs automatically. For example, automatic verification of correctness of the alternating bit protocol on the system of [2] took just over 19 seconds of CPU time.An obvious limitation of these systems comes from the fact that only finite-state programs can be checked for correctness. Although many interesting concurrent programs are in fact finite-state, they are often given schematically in terms of a parameter n, representing the number of concurrent processes. Such a schematic program really represents an infinite sequence of uniformly defined finite-state programs. Consider, for example, solutions to the mutual exclusion problem. A solution for n processes competing for access to a critical section is to be correct for any value of n;;;,: 2. To check correctness of such a solution using the systems of [1, 2, 4](provided, for each n;;;,: 2, the solution uses only a finite number of states), one would have to verify the solutions for", "num_citations": "525\n", "authors": ["1740"]}
{"title": "Foundations of deductive databases and logic programming\n", "abstract": " Foundations of Deductive Databases and Logic Programming focuses on the foundational issues concerning deductive databases and logic programming. The selection first elaborates on negation in logic programming and towards a theory of declarative knowledge. Discussions focus on model theory of stratified programs, fixed point theory of nonmonotonic operators, stratified programs, semantics for negation in terms of special classes of models, relation between closed world assumption and the completed database, negation as a failure, and closed world assumption. The book then takes a look at negation as failure using tight derivations for general logic programs, declarative semantics of logic programs with negation, and declarative semantics of deductive databases and logic programs. The publication tackles converting AND-control to OR-control by program transformation, optimizing dialog, equivalences of logic programs, unification, and logic programming and parallel complexity. Topics include parallelism and structured and unstructured data, parallel algorithms and complexity, solving equations, most general unifiers, systems of equations and inequations, equivalences of logic programs, and optimizing recursive programs. The selection is a valuable source of data for researchers interested in pursuing further studies on the foundations of deductive databases and logic programming.", "num_citations": "497\n", "authors": ["1740"]}
{"title": "A proof system for communicating sequential processes\n", "abstract": " An axiomatic proof system is presented for proving partial correctness and absence of deadlock (and failure) of communicating sequential processes. The key (meta) rule introduces cooperation between proofs, a new concept needed to deal with proofs about synchronization by message passing. CSP's new convention for distributed termination of loops is dealt with. Applications of the method involve correctness proofs for two algorithms, one for distributed partitioning of sets, the other for distributed computation of the greatest common divisor of n numbers.", "num_citations": "474\n", "authors": ["1740"]}
{"title": "Acyclic programs\n", "abstract": " We study here a natural subclass of the locally stratified programs which we call acyclic. Acyclic programs enjoy several natural properties. First, they terminate for a large and natural class of general goals, so they could be used as terminating PROLOG programs. Next, their semantics can be defined in several equivalent ways. In particular we show that the immediate consequence operator of an acyclic programP has a unique fixpointM                                    p                 , which coincides with the perfect model ofP, is the unique Herbrand model of the completion ofP and can be identified with the unique fixpoint of the 3-valued immediate consequence operator associated withP. The completion of an acylic programP is shown to satisfy an even stronger property: addition of a domain closure axiom results in a theory which is complete and decidable with respect to a large class of formulas including the variable\u00a0\u2026", "num_citations": "357\n", "authors": ["1740"]}
{"title": "A generic approach to coalition formation\n", "abstract": " We propose an abstract approach to coalition formation that focuses on simple merge and split rules transforming partitions of a group of players. We identify conditions under which every iteration of these rules yields a unique partition. The main conceptual tool is a specific notion of a stable partition. The results are parametrized by a preference relation between partitions of a group of players and naturally apply to coalitional TU-games, hedonic games and exchange economy games.", "num_citations": "332\n", "authors": ["1740"]}
{"title": "Concepts in programming languages\n", "abstract": " This general textbook on programming languages is designed for undergraduate andbeginning graduate students with some knowledge of basic programming. It teaches the concepts that appear in programming languages, issues that arise in their implementation, and the way that language design affects program development. Each chapter contains an extensive list of homework exercises, tested at several universities. A unique feature of the book is the comprehensive presentation of and comparison between major object-oriented programming languages. Separate chapters examine the history of objects, Simula and Smalltalk, and the prominent languages C++ and Java, giving the reader a solid understanding of the design goals for each of these languages and the central trade-offs between programming expressiveness and implementation efficiency.", "num_citations": "305\n", "authors": ["1740"]}
{"title": "The essence of constraint propagation\n", "abstract": " We show that several constraint propagation algorithms (also called (local) consistency, consistency enforcing, Waltz, filtering or narrowing algorithms) are instances of algorithms that deal with chaotic iteration. To this end we propose a simple abstract framework that allows us to classify and compare these algorithms and to establish in a uniform way their basic properties.", "num_citations": "302\n", "authors": ["1740"]}
{"title": "Countable nondeterminism and random assignment\n", "abstract": " Four semantics for a small programming language involving unbounded (but countable) nondeterminism are provided. These comprise an operational semantics, two state transformation semantics based on the Egli-Milner and Smyth orders, respectively, and a weakest precondition semantics. Their equivalence is proved. A Hoare-like proof system for total correctness is also introduced and its soundness and completeness in an appropriate sense are shown. Finally, the recursion theoretic complexity of the notions introduced is studied. Admission of countable nondeterminism results in a lack of continuity of various semantic functions, and this is shown to be necessary for any semantics satisfying appropriate conditions. In proofs of total correctness, one resorts to the use of (countable) ordinals, and it is shown that all recursive ordinals are needed.", "num_citations": "263\n", "authors": ["1740"]}
{"title": "Ten years of Hoare's logic: A survey\u2014Part II: Nondeterminism\n", "abstract": " A survey of various results concerning the use of Hoare's logic in proving correctness of nondeterministic programs is presented. Various proof systems together with the example proofs are given and the corresponding soundness and completeness proofs of the systems are discussed. Programs allowing bounded and countable nondeterminism are studied. Proof systems deal with partial and total correctness, freedom of failure and the issue of fairness. The paper is a continuation of Part I by Apt (1981), where various results concerning Hoare's approach to proving correctness of sequential programs are presented.", "num_citations": "230\n", "authors": ["1740"]}
{"title": "Reasoning about termination of pure Prolog programs\n", "abstract": " We provide a theoretical basis for studying termination of (general) logic programs with the Prolog selection rule. To this end we study the class of left terminating programs. These are logic programs that terminate with the Prolog selection rule for all ground goals. We offer a characterization of left terminating positive programs by means of the notion of an acceptable program that provides us with a practical method of proving termination. The method is illustrated by giving a simple proof of termination of the quicksort program for the desired class of goals. Then we extend this approach to the class of general logic programs by modifying the concept of acceptability. We prove that acceptable general programs are left terminating. The converse implication does not hold but we show that under the assumption of non-floundering from ground goals every left terminating general program is acceptable. Finally, we prove\u00a0\u2026", "num_citations": "222\n", "authors": ["1740"]}
{"title": "Appraising fairness in languages for distributed programming\n", "abstract": " The relations among various languages and models for distributed computation and various possible definitions of fairness are considered. Natural semantic criteria are presented which an acceptable notion of fairness should satisfy. These are then used to demonstrate differences among the basic models, the added power of the fairness notion, and the sensitivity of the fairness notion to irrelevant semantic interleavings of independent operations. These results are used to show that from the considerable variety of commonly used possibilities, only strong process fairness is appropriate forCSP if these criteria are adopted. We also show that under these criteria, none of the commonly used notions of fairness are fully aceptable for a model with an n-way synchronization mechanism. The notion of fairness most often mentioned for Ada is shown to be fully acceptable. For a model with nonblockingsend\u00a0\u2026", "num_citations": "213\n", "authors": ["1740"]}
{"title": "Reasoning about Prolog programs: from modes through types to assertions\n", "abstract": " We provide here a systematic comparative study of the relative strength and expressive power of a number of methods for program analysis of Prolog. Among others we show that these methods can be arranged in the following hierarchy: mode analysis \u21d2 type analysis \u21d2 monotonic properties \u21d2 nonmonotonic run-time properties. We also discuss a method allowing us to prove global run-time properties.", "num_citations": "151\n", "authors": ["1740"]}
{"title": "Lectures in game theory for computer scientists\n", "abstract": " Games provide mathematical models for interaction. Numerous tasks in computer science can be formulated in game-theoretic terms. This fresh and intuitive way of thinking through complex issues reveals underlying algorithmic questions and clarifies the relationships between different domains. This collection of lectures, by specialists in the field, provides an excellent introduction to various aspects of game theory relevant for applications in computer science that concern program design, synthesis, verification, testing and design of multi-agent or distributed systems. Originally devised for a Spring School organised by the GAMES Networking Programme in 2009, these lectures have since been revised and expanded, and range from tutorials concerning fundamental notions and methods to more advanced presentations of current research topics. This volume is a valuable guide to current research on game-based methods in computer science for undergraduate and graduate students. It will also interest researchers working in mathematical logic, computer science and game theory.", "num_citations": "131\n", "authors": ["1740"]}
{"title": "Proof rules and transformations dealing with fairness\n", "abstract": " We provide proof rules enabling the treatment of two fairness assumptions in the context of Dijkstra's do-od-programs. These proof rules are derived by considering a transformed version of the original program which uses random assignments z\u2254? and admits only fair computations. Various, increasingly complicated, examples are discussed. In all cases reasonably simple proofs can be given. The proof rules use well-founded structures corresponding to infinite ordinals and deal with the original programs and not their translated versions.", "num_citations": "116\n", "authors": ["1740"]}
{"title": "Introduction to logic programming\n", "abstract": " We provide a systematic and self-contained introduction to the theory of logic programming.", "num_citations": "114\n", "authors": ["1740"]}
{"title": "Arithmetic classification of perfect models of stratified programs\n", "abstract": " We study here the recursion theoretic complexity of the perfect (Herbrand) models of stratified logic programs. We show that these models lie arbitrarily high in the arithmetic hierarchy. As a byproduct we obtain a similar characterization of the recursion theoretic complexity of the set of consequences in a number of formalisms for non-monotonic reasoning. We show that under some circumstances this complexity can be brought down to recursive enumerability.", "num_citations": "112\n", "authors": ["1740"]}
{"title": "Stable partitions in coalitional games\n", "abstract": " We propose a notion of a stable partition in a coalitional game that is parametrized by the concept of a defection function. This function assigns to each partition of the grand coalition a set of different coalition arrangements for a group of defecting players. The alternatives are compared using their social welfare. We characterize the stability of a partition for a number of most natural defection functions and investigate whether and how so defined stable partitions can be reached from any initial partition by means of simple transformations. The approach is illustrated by analyzing an example in which a set of stores seeks an optimal transportation arrangement.", "num_citations": "103\n", "authors": ["1740"]}
{"title": "An analysis of loop checking mechanisms for logic programs\n", "abstract": " We systematically study loop checking mechanisms for logic programs by considering their soundness, completeness, relative strength and related concepts. We introduce a natural concept of a simple loop check and prove that no sound and complete simple loop check exists, even for programs without function symbols. Then we introduce a number of sound simple loop checks and identify natural classes of Prolog programs without function symbols for which they are complete. In these classes a limited form of recursion is allowed. As a by-product we obtain an implementation of the closed world assumption of Reiter (1978) and a query evaluation algorithm for these classes of logic programs.", "num_citations": "101\n", "authors": ["1740"]}
{"title": "A new definition of SLDNF-resolution\n", "abstract": " We propose a new, \u201ctop-down\u201d definition of SLDNF-resolution that retains the spirit of the original definition, but avoids the difficulties noted in the literature. We compare it with the \u201cbottom-up\u201d definition of Kunen [7].", "num_citations": "94\n", "authors": ["1740"]}
{"title": "Modular termination proofs for logic and pure Prolog programs\n", "abstract": " We provide a uniform and simplified presentation of the methods of Bezem (1993)(first published as (Bezem 1989)) and of Apt and Pedreschi (1993)(first published as (Apt and Pedreschi 1990)) for proving termination of logic and PRO LOG programs. Then we show how these methods can be refined so that they can be used in a modular way.", "num_citations": "92\n", "authors": ["1740"]}
{"title": "On the unification free Prolog programs\n", "abstract": " We provide simple conditions which allow us to conclude that in case of several well-known Prolog programs the unification algorithm can be replaced by iterated matching. The main tools used here are types and generic expressions for types. As already noticed by other researchers, such a replacement offers a possibility of improving the efficiency of program's execution.", "num_citations": "88\n", "authors": ["1740"]}
{"title": "Fairness in parallel programs: The transformational approach\n", "abstract": " Program transformations are proposed as a means of providing fair parallelism semantics for parallel programs with shared variables. The transformations are developed in two steps. First, abstract schedulers that implement the various fairness policies are introduced. These schedulers use random assignments z := ? to represent the unbounded nondeterminism induced by fairness. Concrete schedulers are derived by suitably refining the ?. The transformations are then obtained by embedding the abstract schedulers into the parallel programs. This embedding is proved correct on the basis of a simple transition semantics. Since the parallel structure of the original program is preserved, the transformations also provide a basis for syntax-directed proofs of total correctness under the fairness assumption. These proofs make use of infinite ordinals.", "num_citations": "88\n", "authors": ["1740"]}
{"title": "Formal justification of a proof system for communicating sequential processes\n", "abstract": " In a previous paper a proof system dealing with partial correctness of communicating sequential processes was introduced. Soundness and relative completeness of this system are proved here. It is also m&cated in what way the semantics and the proof system can be extended to deal with the total correctness of the programs", "num_citations": "87\n", "authors": ["1740"]}
{"title": "Alma-O: An imperative language that supports declarative programming\n", "abstract": " We describe here an implemented small programming language, called Alma-O, that augments the expressive power of imperative programming by a limited number of features inspired by the logic programming paradigm. These additions encourage declarative programming and make it a more attractive vehicle for problems that involve search. We illustrate the use of Alma-O by presenting solutions to a number of classical problems, including \u03b1-\u03b2 search, STRIPS planning, knapsack, and Eight Queens. These solutions are substantially simpler than their counterparts written in the imperative or in the logic programming style and can be used for different purposes without any modification. We also discuss here the implementation of Alma-O and an operational, executable, semantics of a   large subset of the language.", "num_citations": "81\n", "authors": ["1740"]}
{"title": "Proving termination of general Prolog programs\n", "abstract": " We study here termination of general logic programs with the Prolog selection rule. To this end we extend the approach of Apt and Pedreschi [AP90] and consider the class of left terminating general programs. These are general logic programs that terminate with the Prolog selection rule for all ground goals. We introduce the notion of an acceptable program and prove that acceptable programs are left terminating. This provides us with a practical method of proving termination.             The converse implication does not hold but we show that under the assumption of non-floundering from ground goals every left terminating program is acceptable. Finally, we prove that various ways of defining semantics coincide for acceptable programs. The method is illustrated by giving simple proofs of termination of a \u201cgame\u201d program and the transitive closure program for the desired class of goals.", "num_citations": "77\n", "authors": ["1740"]}
{"title": "The Logic Programming Paradigm: A 25-Year Perspective\n", "abstract": " This exciting new text reveals both the evolution of this programming paradigm since its inception and the impressively broad scope of current research in the field. The contributors to this book are all leading world experts in Logic Programming, and they deal with both theoretical and practical issues. They address such diverse topics as: computational molecular biology, machine learning, mobile computing, multi-agent systems, planning, numerical computing and dynamical systems, database systems, an alternative to the\" formulas as types\" approach, program semantics and analysis, and natural language processing. XXXXXXX Neuer Text Logic Programming was founded 25 years ago. This exciting book reveals both the evolution of this programming paradigm and its impressively broad scope of current research. The contributions by leading computer scientists deal with both theoretical and practical issues. They address diverse topics such as: computational molecular biology, machine learning, mobile computing, multi-agent systems, numerical computing and dynamical systems, database systems, program semantics, natural language processing, and promising future directions.", "num_citations": "76\n", "authors": ["1740"]}
{"title": "On the occur-check-free Prolog programs\n", "abstract": " In most PROLOG implementations, for efficiency occur-check is omitted from the unification algorithm. This paper provides natural syntactic conditions that allow the occur-check to be safely omitted. The established results apply to most well-known PROLOG programs, including those that use difference lists, and seem to explain why this omission does not lead in practice to any complications. When applying these results to general programs, we show their usefulness for proving absence of floundering. Finally, we propose a program transformation that transforms every program into a program for which only the calls to the built-in unification predicate need to be resolved by a unification algorithm with the occur-check.", "num_citations": "76\n", "authors": ["1740"]}
{"title": "A Cook's tour of countable nondeterminism\n", "abstract": " We provide four semantics for a small programming language involving unbounded (but countable) nondeterminism. These comprise an operational one, two denotational ones based on the Egli-Milner and Smyth orders, respectively, and a weakest precondition semantics. Their equivalence is proved. We also introduce a Hoare-like proof system for total correctness and show its soundness and completeness in an appropriate sense. Admission of countable nondeterminism results in a lack of continuity of various semantic functions; moreover some of the partial orders considered are in general not cpo's and in proofs of total correctness one has to resort to the use of (countable) ordinals. Proofs will appear in the full version of the paper.", "num_citations": "72\n", "authors": ["1740"]}
{"title": "Automatic generation of constraint propagation algorithms for small finite domains\n", "abstract": " We study here constraint satisfaction problems that are based on predefined, explicitly given finite constraints. To solve them we propose a notion of rule consistency that can be expressed in terms of rules derived from the explicit representation of the initial constraints.               This notion of local consistency is weaker than arc consistency for constraints of arbitrary arity but coincides with it when all domains are unary or binary. For Boolean constraints rule consistency coincides with the closure under the well-known propagation rules for Boolean constraints.               By generalizing the format of the rules we obtain a characterization of arc consistency in terms of so-called inclusion rules. The advantage of rule consistency and this rule based characterization of the arc consistency is that the algorithms that enforce both notions can be automatically generated, as CHR rules. So these algorithms could be\u00a0\u2026", "num_citations": "68\n", "authors": ["1740"]}
{"title": "Verification of logic programs with delay declarations\n", "abstract": " Logic programs augmented with delay declarations form a higly expressive programming language in which dynamic networks of processes that communicate asynchronously by means of multiparty channels can be easily created. In this paper we study correctness these programs. In particular, we propose proof methods allowing us to deal with occur check freedom, absence of deadlock, absence of errors in presence of arithmetic relations, and termination. These methods turn out to be simple modifications of the corresponding methods dealing with Prolog programs. This allows us to derive correct delay declarations by analyzing Prolog programs. Finally, we point out difficulties concerning proofs of termination.", "num_citations": "67\n", "authors": ["1740"]}
{"title": "Diffusion in social networks with competing products\n", "abstract": " We introduce a new threshold model of social networks, in which the nodes influenced by their neighbours can adopt one out of several alternatives. We characterize the graphs for which adoption of a product by the whole network is possible (respectively necessary) and the ones for which a unique outcome is guaranteed. These characterizations directly yield polynomial time algorithms that allow us to determine whether a given social network satisfies one of the above properties.               We also study algorithmic questions for networks without unique outcomes. We show that the problem of computing the minimum possible spread of a product is NP-hard to approximate with an approximation ratio better than \u03a9(n), in contrast to the maximum spread, which is efficiently computable. We then move on to questions regarding the behavior of a node with respect to adopting some (resp. a given) product. We\u00a0\u2026", "num_citations": "65\n", "authors": ["1740"]}
{"title": "The rough guide to constraint propagation\n", "abstract": " We provide here a simple, yet very general framework that allows us to explain several constraint propagation algorithms in a systematic way. In particular, using the notions commutativity and semi-commutativity, we show how the well-known AC-3, PC-2, DAC and DPC algorithms are instances of a single generic algorithm. The work reported here extends and simplifies that of Apt [1].", "num_citations": "61\n", "authors": ["1740"]}
{"title": "A static analysis of CSP programs\n", "abstract": " A static analysis is proposed as a method of reducing complexity of the correctness proofs of CSP programs. This analysis is based on considering all possible sequences of communications which can arise in computations during which the boolean guards are not interpreted. Several examples are provided which clarify its various aspects.", "num_citations": "60\n", "authors": ["1740"]}
{"title": "Constraint programming viewed as rule-based programming\n", "abstract": " We study here a natural situation when constraint programming can be entirely reduced to rule-based programming. To this end we explain first how one can compute on constraint satisfaction problems using rules represented by simple first-order formulas. Then we consider constraint satisfaction problems that are based on predefined, explicitly given constraints. To solve them we first derive rules from these explicitly given constraints and limit the computation process to a repeated application of these rules, combined with labeling. We consider two types of rule here. The first type, that we call equality rules, leads to a new notion of local consistency, called rule consistency that turns out to be weaker than arc consistency for constraints of arbitrary arity (called hyper-arc consistency in Marriott & Stuckey (1998)). For Boolean constraints rule consistency coincides with the closure under the well-known propagation\u00a0\u2026", "num_citations": "58\n", "authors": ["1740"]}
{"title": "On the safe termination of Prolog programs\n", "abstract": " We systematically study loop checking mechanisms for logic programs by considering their soundness, completeness, relative strength and related concepts. We introduce a natural concept of a simple loop check and prove that no sound and complete simple loop check exists, even for programs without function symbols. Then we introduce a number of sound simple loop checks and identify a natural class of PROLOG programs for which they are complete. In this class a limited form of recursion is allowed. As a by-product we obtain an implementation of the closed world assumption of Reiter [R] and a query evaluation algorithm for a class of logic programs without function symbols.", "num_citations": "58\n", "authors": ["1740"]}
{"title": "A decision procedure for term algebras with queues\n", "abstract": " In software verification it is often required to prove statements about heterogeneous domains containing elements of various sorts, such as counters, stacks, lists, trees and queues. Any domain with counters, stacks, lists, and trees (but not queues) can be easily seen a special case of the term algebra, and hence a decision procedure for term algebras can be applied to decide the first-order theory of such a domain. We present a quantifier-elimination procedure for the first-order theory of term algebra extended with queues. The complete axiomatization and decidability of this theory can be immediately derived from the procedure.", "num_citations": "55\n", "authors": ["1740"]}
{"title": "Correctness proofs of distributed termination algorithms\n", "abstract": " The problem of correctness of the solutions to the distributed termination problem of Francez [7] is addressed. Correctness criteria are formalized in the customary framework for program correctness. A very simple proof method is proposed and applied to show correctness of a solution to the problem. It allows us to reason about liveness properties of temporal logic (see, e.g., Manna and Pnueli [12]) using a new notion of weak total correctness.", "num_citations": "55\n", "authors": ["1740"]}
{"title": "Fair termination revisited\u2014with delay\n", "abstract": " A proof method for establishing the fair termination and total correctness of both nondeterministic and concurrent programs is presented. The method calls for the extension of state by auxiliary delay variables which count down to the instant in which certain action will be scheduled. It then uses well-founded ranking to prove fair termination allowing nested fair selection and loops.", "num_citations": "53\n", "authors": ["1740"]}
{"title": "Second order arithmetic and related topics\n", "abstract": " Second order arithmetic A2 is a theory which considers the properties of sets of natural numbers. Being an extension of Peano arithmetic, the second order arithmetic is a theory in which one can already state the induction axiom in the desired form. On the other hand, the restrictions of the language force us to construct the sets by usfrig the comprehension scheme.Although A2 seems to be a fairly weak system, it is already possible to formalize within it quite a big part of classical mathematics. It is even possible to do that in some subsystems of A2 with the scheme of comprehension suitably restricted. In this paper we do not consider the above subject and we always assume the full comprehension scheme. A number of results concern the second order arithmetic with the scheme of choice. The intermediate systems-almost unknown so far 1 are not considered here.", "num_citations": "51\n", "authors": ["1740"]}
{"title": "Recursive assertions and parallel programs\n", "abstract": " We prove that recursive assertions are enough for proofs of parallel programs considered in Owicki and Gries [7]. In other words, we prove that for any parallel program S and recursive assertions p and q if {p} S{q} is true under the standard interpretation in natural numbers then all intermediate assertions needed in the proof can be chosen recursive. Finally, we show that if auxiliary variables are used only as program counters then the above result does not hold.", "num_citations": "50\n", "authors": ["1740"]}
{"title": "From chaotic iteration to constraint propagation\n", "abstract": " We show how the constraint propagation process can be naturally explained by means of chaotic iteration.", "num_citations": "49\n", "authors": ["1740"]}
{"title": "Maintenance of stratified databases viewed as a belief revision system\n", "abstract": " We study here declarative and dynamic aspects of non-monotonic reasoning in the context of deductive databases. More precisely, we consider here maintenance of a special class of indefinite deductive databases, called stratified databases, introduced in Apt, Blair and Walker [ABW] and Van Gelder [VG] in which recursion \u201cthrough\u201d negation is disallowed.", "num_citations": "48\n", "authors": ["1740"]}
{"title": "Declarative programming in Prolog\n", "abstract": " We try to assess to what extent declarative programming can be realized in Prolog and which aspects of correctness of Prolog programs can be dealt with by means of declarative interpretation.", "num_citations": "45\n", "authors": ["1740"]}
{"title": "The many faces of rationalizability\n", "abstract": " The rationalizability concept was introduced in \\cite{Ber84} and \\cite{Pea84} to assess what can be inferred by rational players in a non-cooperative game in the presence of common knowledge. However, this notion can be defined in a number of ways that differ in seemingly unimportant minor details. We shed light on these differences, explain their impact, and clarify for which games these definitions coincide. Then we apply the same analysis to explain the differences and similarities between various ways the iterated elimination of strictly dominated strategies was defined in the literature. This allows us to clarify the results of \\cite{DS02} and \\cite{CLL05} and improve upon them. We also consider the extension of these results to strict dominance by a mixed strategy. Our approach is based on a general study of the operators on complete lattices. We allow transfinite iterations of the considered operators and clarify the need for them. The advantage of such a general approach is that a number of results, including order independence for some of the notions of rationalizability and strict dominance, come for free.", "num_citations": "42\n", "authors": ["1740"]}
{"title": "Meta-Logics and Logic Programming\n", "abstract": " Krzysztof R. Apt & Franco Turini, Meta-Logics and Logic Programming - PhilPapers Sign in | Create an account PhilPapers PhilPeople PhilArchive PhilEvents PhilJobs PhilPapers home Syntax Advanced Search Syntax Advanced Search Syntax Advanced Search Meta-Logics and Logic Programming Krzysztof R. Apt & Franco Turini (1995) Abstract This article has no associated abstract. (fix it) Keywords Logic programming Logic, Symbolic and mathematical Categories Areas of Mathematics in Philosophy of Mathematics (categorize this paper) Buy this book $7.61 used (86% off) $65.79 new Amazon page ISBN(s) 0262011522 0262011522 Request removal from index Revision history Download options PhilArchive copy Upload a copy of this paper Check publisher's policy Papers currently archived: 59,916 External links This \u2026", "num_citations": "42\n", "authors": ["1740"]}
{"title": "Two normal form theorems for CSP programs\n", "abstract": " We define two normal forms for CSP programs. In the First Normal Form, each process contains only one I/O repetitive command and all its I/O commands appear as guards of this command. In the Second Normal Form, all guards of this I/O repetitive command are I/O guards. We describe an inductive method that transforms any CSP program into an equivalent program in first or second normal form. The notion of equivalence is discussed. It is shown that no transformation into second normal form can preserve deadlock freedom.", "num_citations": "42\n", "authors": ["1740"]}
{"title": "Coordination games on graphs\n", "abstract": " We introduce natural strategic games on graphs, which capture the idea of coordination in a local setting. We show that these games have an exact potential and have strong equilibria when the graph is a pseudoforest. We also exhibit some other classes of graphs for which a strong equilibrium exists. However, in general strong equilibria do not need to exist. Further, we study the (strong) price of stability and anarchy. Finally, we consider the problems of computing strong equilibria and of determining whether a joint strategy is a strong equilibrium.", "num_citations": "41\n", "authors": ["1740"]}
{"title": "Epistemic protocols for distributed gossiping\n", "abstract": " Gossip protocols aim at arriving, by means of point-to-point or group communications, at a situation in which all the agents know each other's secrets. We consider distributed gossip protocols which are expressed by means of epistemic logic. We provide an operational semantics of such protocols and set up an appropriate framework to argue about their correctness. Then we analyze specific protocols for complete graphs and for directed rings.", "num_citations": "40\n", "authors": ["1740"]}
{"title": "Proof rules dealing with fairness\n", "abstract": " We provide proof rules allowing to deal with two fairness assumptions in the context of Dijkstra's do-od programs. These proof rules are obtained by considering a translated version of the original program which uses random assignment x:=? and admits only fair runs. The proof rules use infinite ordinals and deal with the original programs and not their translated versions.", "num_citations": "40\n", "authors": ["1740"]}
{"title": "The role of commutativity in constraint propagation algorithms\n", "abstract": " Constraing propagation algorithms form an important part of most of  the constraint programming systems. We provide here a simple, yet very general framework that allows us to explain several constraint propagation algorithms in a systematic way. In this framework we proceed in two steps. First, we introduce a generic iteration algorithm on partial orderings and prove its correctness in an abstract setting. Then we instantiate this algorithm with specific partial orderings and functions to obtain specific constraint propagation algorithms. In particular, using the notions commutativity and semi-commutativity, we show that the AC-3, PC-2, DAC, and DPC algorithms for achieving (directional) arc consistency and (directional) path consistency are instances of a single generic algorithm. The work reported here extends and simplifies that of Apt [1999a].", "num_citations": "39\n", "authors": ["1740"]}
{"title": "Search and imperative programming\n", "abstract": " We augment the expressive power of imperative programming in order to make it a more attractive vehicle for problems that involve search. The proposed additions are limited yet powerful and are inspired by the logic programming paradigm. We illustrate their use by presenting solutions to a number of classical problems, including the straight search problem, the knapsack problem, and the 8 queens problem. These solutions are substantially simpler than their counterparts written in the conventional way and can be used for different purposes without any modification. The proposed language is an intermediate stage on the road towards a realization of a strongly typed constraint programming language that combines the advantages of the logic programming and imperative programming.", "num_citations": "39\n", "authors": ["1740"]}
{"title": "Program verification and prolog\n", "abstract": " We show here that veri cation of Prolog programs can be systematically carried out within a simple framework which comprises syntactic analysis, declarative semantics, modes and types. We apply these techniques to study termination, partial correctness, occurcheck freedom, absence of errors and absence of oundering. Finally, we discuss which aspects of these techniques can be automated. Notes. This research was partly supported by the ESPRIT Basic Research Action 6810 (Compulog 2). A preliminary, shorter, version of this paper appeared as Apt 3].", "num_citations": "39\n", "authors": ["1740"]}
{"title": "Real time clocks versus virtual clocks\n", "abstract": " Symmetric distributed termination algorithms are systematically developed. Solution are first presented in an abstract setting of Dijkstra, Feijen and Van Gasteren [DFG] and then gradually transformed into solutions to the distributed termination problem of Francez [F]. The initially used global real time clock is eventually replaced by local virtual clocks. A dependence between the degree of clock synchronization and the efficiency of the solutions is indicated.", "num_citations": "38\n", "authors": ["1740"]}
{"title": "Modeling the distributed termination convention of CSP\n", "abstract": " One of its features, which was subsequently criticized, was the so-called distributed termination convention of repetitive commands (see, eg,[12]). A repetitive command is a construct of the form*[bl; al--* Si", "num_citations": "38\n", "authors": ["1740"]}
{"title": "A classification of weakly acyclic games\n", "abstract": " Weakly acyclic games form a natural generalization of the class of games that have the finite improvement property (FIP). In such games one stipulates that from any initial joint strategy some finite improvement path exists. We classify weakly acyclic games using the concept of a scheduler introduced in Simon and Apt (Choosing products in social networks, 2012). We also show that finite games that can be solved by the iterated elimination of never best response strategies are weakly acyclic. Finally, we explain how the schedulers allow us to improve the bounds on finding a Nash equilibrium in a weakly acyclic game.", "num_citations": "37\n", "authors": ["1740"]}
{"title": "Why the occur-check is not a problem\n", "abstract": " In most Prolog implementations for the efficiency reasons so-called occur-check is omitted from the unification algorithm. We provide here natural syntactic conditions which allow the occur-check to be safely omitted. The established results apply to most well-known Prolog programs and seem to explain why this omission does not lead in practice to any complications.", "num_citations": "37\n", "authors": ["1740"]}
{"title": "Appraising fairness in distributed languages\n", "abstract": " The relations among various languages and models for distributed computation and various possible definitions of fairness are considered. Natural semantic criteria are presented which an acceptable notion of fairness should satisfy. These are then used to demonstrate differences among the basic models, the added power of the fairness notion, and the sensitivity of the fairness notion to irrelevant semantic interleavings of independent operations. These results are used to show that from the considerable variety of commonly used possibilities, only strong process fairness is appropriate for CSP if these criteria are adopted. We also show that under these criteria, none of the commonly used notions of fairness are fully acceptable for a model with an n-way synchronization mechanism. Finally, the notion of fairness most often mentioned for Ada is shown to be fully acceptable.", "num_citations": "34\n", "authors": ["1740"]}
{"title": "Logics and models of concurrent systems\n", "abstract": " The cooperation test [Apt, Francez & de Roever] was originally conceived to capture the proof theoretical analogue of distributed message exchange between disjoint processes, as opposed to the interference freedom test [Owicki & Gries], being the proof theoretical analogue of concurrent communication by means of interference through jointly shared variables. Some authors ([Levin & Gries, Lamport & Schneider, Schlichting and Schneider]) stress that both forms of communication can be proof theoretically characterized using interference freedom only, since proofs for both ultimately amount to an invariance proof of a big global assertion [Ashcroft], invariance of whose parts amounts to interference freedom. Yet I feel that the characteristic nature of the cooperation test is still preserved in the analysis of these authors, because in their analysis of CSP the part dealing with interference freedom specializes to maintenance of a global invariant, the expression of which requires per process the introduction of auxiliary variables which are updated in that process only, thus preserving the concept of disjointness (as opposed to sharing), since now all variables from different processes are disjoint. The cooperation test has been applied to characterize concurrent communication as occurring in Hoare's Communicating Sequential Processes (CSP)[Hoare 2], Ichbiah's ADA [ARM], and Brinch Hansen's Distributed Processes (DP)[Brinch Hansen]. This characterization has been certified through soundness and completeness proofs [Apt 2, Gerth]. As in the interference freedom test this characterization consists of two stages, a local sequential stage and a\u00a0\u2026", "num_citations": "33\n", "authors": ["1740"]}
{"title": "Fifty years of Hoare\u2019s logic\n", "abstract": " We present a history of Hoare\u2019s logic.", "num_citations": "31\n", "authors": ["1740"]}
{"title": "A proof theoretic view of constraint programming\n", "abstract": " We provide here a proof theoretic account of constraint programming that attempts to capture the essential ingredients of this programming style. We exemplify it by presenting proof rules for linear constraints over interval domains, and illustrate their use by analyzing the constraint propagation process for the SEND+ MORE= MONEY puzzle. We also show how this approach allows one to build new constraint solvers.", "num_citations": "30\n", "authors": ["1740"]}
{"title": "Implementation of narrowing: The Prolog-based approach\n", "abstract": " We present the problem of integrating functional languages and logic languages. We explain why the narrowing-based techniques have so far prevailed as operational mechanisms for the functional logic interpreters. We then discuss various strategies of narrowing. Finally we explain how to simulate these strategies of narrowing using the leftmost SLD-resolution rule of Prolog, and compare some experimental results with those obtained with direct narrowing implementations.", "num_citations": "30\n", "authors": ["1740"]}
{"title": "Programmverifikation: Sequentielle, parallele und verteilte Programme\n", "abstract": " In letzter Zeit ist die Problematik der Korrektheit von Computerprogrammen st\u00e4rker in das Bewu\u00dftsein von Fachleuten und \u00d6ffentlichkeit ger\u00fcckt. Dies liegt daran, da\u00df Computerprogramme heute in vielf\u00e4ltiger Weise zur Steuerung von Abl\u00e4ufen eingesetzt werden, die unser t\u00e4gliches Leben betreffen. Als Beispiele seien hier das Buchen von Reisen, der Betrieb von Geldautomaten sowie die Steuerung von Eisenbahnen und Flugzeugen genannt. F\u00fcr die Kunden von Reiseb\u00fcros und Banken sowie die Passagiere von Bahnen und Flugzeugen ist der Sicherheitsaspekt der Systeme von zentraler Bedeutung. Zum Beispiel sollen Bargeldauszahlungen das richtige Konto belasten und Flugzeuge auf dem gew\u00fcnschten Kurs bleiben. Deshalb ist es wichtig, da\u00df die steuernden Computerprogramme korrekt arbeiten, dh vorher festgelegte Anforderungen fehlerfrei erf\u00fcllen. Ein Teil der Informatik befa\u00dft sich daher mit der Aufgabe, Methoden zur systematischen Erstellung korrekter Programme zu entwickeln.Den oben genannten Anwendungen ist gemeinsam, da\u00df die Computerprogramme eine Anzahl von Komponenten koordinieren m\u00fcssen, die unabh\u00e4ngig voneinander oder \u201cparallel\" arbeiten k\u00f6nnen, z. B. die Buchungsstationen in den einzelnen Reiseb\u00fcros oder die Sensoren und Stellwerke bei der Bahnsteuerung, Deshalb ist bei der Erstellung der zugeh\u00f6rigen Computerprogramme die Beherrschung der Prinzipien der korrekten parallelen Programmierung wichtig. Ein erster Schritt zur Erstellung korrekter Programme ist die Methodik der Programmverifikation, dh der systematische Nachweis der Fehlerfreiheit von Programmen. Das ist das Thema des\u00a0\u2026", "num_citations": "28\n", "authors": ["1740"]}
{"title": "Formulas as programs\n", "abstract": " We provide here a computational interpretation of first-order logic based on a constructive interpretation of satisfiability w.r.t. a fixed but arbitrary interpretation. In this approach the formulas themselves axe programs. This contrasts with the so-called formulas as types approach in which the proofs of the formulas are typed terms that can be taken as programs. This view of computing is inspired by logic programming and constraint logic programming but differs from them in a number of crucial aspects.                 Formulas as programs is argued to yield a realistic approach to programming that has been realized in the implemented programming language Alma-0 [ABPS98] that combines the advantages of imperative and logic programming. The work here reported can also be used to reason about the correctness of non-recursive Alma-0 programs that do not include destructive assignment.", "num_citations": "26\n", "authors": ["1740"]}
{"title": "Choosing products in social networks\n", "abstract": " We study the consequences of adopting products by agents who form a social network. To this end we use the threshold model introduced in [1], in which the nodes influenced by their neighbours can adopt one out of several alternatives, and associate with each such social network a strategic game between the agents. The possibility of not choosing any product results in two special types of (pure) Nash equilibria.               We show that such games may have no Nash equilibrium and that determining the existence of a Nash equilibrium, also of a special type, is NP-complete. The situation changes when the underlying graph of the social network is a DAG, a simple cycle, or has no source nodes. For these three classes we determine the complexity of establishing whether a (special type of) Nash equilibrium exists.               We also clarify for these categories of games the status and the complexity of the finite\u00a0\u2026", "num_citations": "25\n", "authors": ["1740"]}
{"title": "Recursive assertions are not enough-or are they?\n", "abstract": " Call a set of assertions A complete (with respect to a class of programs S) if for any p, q\u2208 A and S\u2208 S, wherever {p} S {q} holds, then all intermediate assertions can be chosen from A. This paper is devoted to the study of the problem which sets of assertions are complete in the above sense. We prove that any set of recursive assertions containing true and false is not complete. We prove the completeness for while programs of some more powerful assertions, eg the set of recursively enumerable assertions. Finally, we show that by allowing the use of an \u2018auxilliary\u2019coordinate, the set of recursive assertions is complete for while programs.", "num_citations": "25\n", "authors": ["1740"]}
{"title": "Welfare undominated Groves mechanisms\n", "abstract": " A common objective in mechanism design is to choose the outcome (for example, allocation of resources) that maximizes the sum of the agents\u2019 valuations, without introducing incentives for agents to misreport their preferences. The class of Groves mechanisms achieves this; however, these mechanisms require the agents to make payments, thereby reducing the agents\u2019 total welfare.               In this paper we introduce a measure for comparing two mechanisms with respect to the final welfare they generate. This measure induces a partial order on mechanisms and we study the question of finding minimal elements with respect to this partial order. In particular, we say a non-deficit Groves mechanism is welfare undominated if there exists no other non-deficit Groves mechanism that always has a smaller or equal sum of payments. We focus on two domains: (i) auctions with multiple identical units and unit\u00a0\u2026", "num_citations": "24\n", "authors": ["1740"]}
{"title": "Texts in Computer Science\n", "abstract": " The Guide to Reliable Distributed Systems: Building High-Assurance Applications and Cloud-Hosted Services is a heavily edited new edition of a prior edition that went under the name Reliable Distributed Computing; the new name reflects a new focus on Cloud Computing. The term refers to the technological infrastructure supporting today\u2019s web systems, social networking, e-commerce and a vast array of other applications. The emergence of the cloud has been a transformational development, for a number of reasons: cost, flexibility, new ways of managing and leveraging large data sets. There are other benefits that we will touch on later. The cloud is such a focus of product development and so associated with overnight business success stories today that one could easily write a text focused on the cloud \u201cas is\u201d and achieve considerable success with the resulting text. After all, the cloud has enabled companies\u00a0\u2026", "num_citations": "24\n", "authors": ["1740"]}
{"title": "Undominated groves mechanisms\n", "abstract": " The family of Groves mechanisms, which includes the well-known VCG mechanism (also known as the Clarke mechanism), is a family of efficient and strategy-proof mechanisms. Unfortunately, the Groves mechanisms are generally not budget balanced. That is, under such mechanisms, payments may flow into or out of the system of the agents, resulting in deficits or reduced utilities for the agents. We consider the following problem: within the family of Groves mechanisms, we want to identify mechanisms that give the agents the highest utilities, under the constraint that these mechanisms must never incur deficits.", "num_citations": "23\n", "authors": ["1740"]}
{"title": "Generic Programming: International Seminar on Generic Programming Dagstuhl Castle, Germany, April 27-May 1, 1998, Selected Papers\n", "abstract": " This book constitutes the thoroughly refereed post-proceedings of the International Seminar on Generic Programming held in Dagstuhl Castle, Germany in April/May 1998. The 20 revised full papers were carefully reviewed for inclusion in the book. As the first book entirely devoted to the new paradigm of generic programming, this collection offers topical sections on foundations and methodology comparisons, programming methodology, language design, and applications.", "num_citations": "23\n", "authors": ["1740"]}
{"title": "Arrays, bounded quantification and iteration in logic and constraint logic programming\n", "abstract": " We claim that programming within the logic programming paradigm suffers from lack of attention given to iteration and arrays. To convince the reader about their merits we present several examples of logic and constraint logic programs which use iteration and arrays instead of explicit recursion and lists. These programs are substantially simpler than their counterparts written in the conventional way. They are easier to write and to understand, are guaranteed to terminate and their declarative character makes it simpler to argue about their correctness. Iteration is implemented by means of bounded quantification.", "num_citations": "23\n", "authors": ["1740"]}
{"title": "Order independence and rationalizability\n", "abstract": " Two natural strategy elimination procedures have been studied for strategic games. The first one involves the notion of (strict, weak, etc) dominance and the second the notion of rationalizability. In the case of dominance the criterion of order independence allowed us to clarify which notions and under what circumstances are robust. In the case of rationalizability this criterion has not been considered. In this paper we investigate the problem of order independence for rationalizability by focusing on three naturally entailed reduction relations on games. These reduction relations are distinguished by the adopted reference point for the notion of a better response. Additionally, they are parametrized by the adopted system of beliefs. We show that for one reduction relation the outcome of its (possibly transfinite) iterations does not depend on the order of elimination of the strategies. This result does not hold for the other two reduction relations. However, under a natural assumption the iterations of all three reduction relations yield the same outcome. The obtained order independence results apply to the frameworks considered in Bernheim 84 and Pearce 84. For finite games the iterations of all three reduction relations coincide and the order independence holds for three natural systems of beliefs considered in the literature.", "num_citations": "22\n", "authors": ["1740"]}
{"title": "Uniform proofs of order independence for various strategy elimination procedures\n", "abstract": " We provide elementary and uniform proofs of order independence for various strategy elimination procedures for finite strategic games, both for dominance by pure and by mixed strategies. The proofs follow the same pattern and focus on the structural properties of the dominance relations. They rely on Newman's Lemma established in 1942 and related results on the abstract reduction systems.", "num_citations": "22\n", "authors": ["1740"]}
{"title": "Some remarks on boolean constraint propagation\n", "abstract": " We study here the well-known propagation rules for Boolean constraints. First we propose a simple notion of completeness for sets of such rules and establish a completeness result. Then we show an equivalence in an appropriate sense between Boolean constraint propagation and unit propagation, a form of resolution for propositional logic.               Subsequently we characterize one set of such rules by means of the notion of hyper-arc consistency introduced in Mohr & Masini (1988). Also, we clarify the status of a similar, though different, set of rules introduced in Simonis (1989) and more fully in Codognet & Diaz (1996).", "num_citations": "22\n", "authors": ["1740"]}
{"title": "A declarative approach for first-order built-in's of Prolog\n", "abstract": " We provide here a framework for studying Prolog programs with various built-in's that include arithmetic operations, and such metalogical relations likevar andground. To this end we propose a new, declarative semantics and prove completeness of the Prolog computation mechanism w.r.t. this semantics. We also show that this semantics is fully abstract in an appropriate sense. Finally, we provide a method for proving termination of Prolog programs with built-in's which uses this semantics. The method is shown to be modular and is illustrated by proving termination of a number of programs including the unify program of Sterling and Shapiro [17].", "num_citations": "22\n", "authors": ["1740"]}
{"title": "Declarative interpretations reconsidered\n", "abstract": " Three semantics have been proposed as the most promising candidates for a declarative interpretation for logic programs and pure Prolog programs: the least Herbrand model, the least term model, ie the C-semantics, and the S-semantics. Previous results show that a strictly increasing information ordering between these semantics exists for the class of all programs. In particular, the S-semantics allows us to model computed answer substitutions, which is not the case for the other two. We study here the relationship between these three semantics for specific classes of programs. We show that for a large class of programs (which is Turing complete) these three semantics are isomorphic. As a consequence, given a query, we can extract from the least Herbrand model of the program all computed answer substitutions. This result is applied to propose a method for proving partial correctness of programs based on the least Herbrand model.", "num_citations": "22\n", "authors": ["1740"]}
{"title": "Semantics and proof theory of PASCAL procedures\n", "abstract": " Our paper is devoted to an investigation of (recursive) procedures with the parameter mechanisms of call-by-value and callrby-variable (the FORTRAN call-by-reference) as occurring in the language PASCAL. We use the method of denotational semantics (SCOTT & STRACHEY [15], MILNE & STRACHEY [13]) and propose proof rules in the style of HOARE [7].Our analysis is presented within the framework of a simple sublanguage of PASCAL, containing simple and subscripted variables, a few simple kinds of expressions, assignment, sequential composition, conditionals, declarations of simple variables, of arrays and of procedures, and procedure calls. It turns out that an adequate treatment of procedures in this setting-ie, a treatment which describes their meaning both exactly as in the PASCAL report and with sufficient mathematical rigour-is already quite complicated, reason why we have organised the\u00a0\u2026", "num_citations": "22\n", "authors": ["1740"]}
{"title": "Social network games\n", "abstract": " One of the natural objectives of the field of the social networks is to predict agents' behaviour. To better understand the spread of various products through a social network (Apt and Markakis (2011, Lecture Notes in Computer Science, pp. 212\u2013223)) introduced a threshold model, in which the nodes influenced by their neighbours can adopt one out of several alternatives. To analyse the consequences of such product adoption we associate here with each such social network a natural strategic game between the agents. In these games the payoff of each player weakly increases when more players choose his strategy, which is exactly opposite to the congestion games. The possibility of not choosing any product results in two special types of (pure) Nash equilibria. We show that such games may have no Nash equilibrium and that determining an existence of a Nash equilibrium, also of a special type, is NP-complete\u00a0\u2026", "num_citations": "21\n", "authors": ["1740"]}
{"title": "An analysis of arithmetic constraints on integer intervals\n", "abstract": " Arithmetic constraints on integer intervals are supported in many constraint programming systems. We study here a number of approaches to implement constraint propagation for these constraints. To describe them we introduce integer interval arithmetic. Each approach is explained using appropriate proof rules that reduce the variable domains. We compare these approaches using a set of benchmarks. For the most promising approach we provide results that characterize the effect of constraint propagation.", "num_citations": "21\n", "authors": ["1740"]}
{"title": "Social networks with competing products\n", "abstract": " We introduce a new threshold model of social networks, in which the nodes influenced by their neighbours can adopt one out of several alternatives. We characterize social networks for which adoption of a product by the whole network is possible (respectively necessary) and the ones for which a unique outcome is guaranteed. These characterizations directly yield polynomial time algorithms that allow us to determine whether a given social network satisfies one of the above properties. We also study algorithmic questions for networks without unique outcomes. We show that the problem of determining whether a final network exists in which all nodes adopted some product is NP-complete. In turn, we also resolve the complexity of the problems of determining whether a given node adopts some (respectively, a given) product in some (respectively, all) network (s). Further, we show that the problem of computing the\u00a0\u2026", "num_citations": "20\n", "authors": ["1740"]}
{"title": "Verification of object-oriented programs: A transformational approach\n", "abstract": " We show that verification of object-oriented programs by means of the assertional method can be achieved in a simple way by exploiting a syntax-directed transformation from object-oriented programs to recursive programs. This transformation suggests natural proofs rules and its correctness helps us to establish soundness and relative completeness of the proposed proof system. One of the difficulties is how to properly deal in the assertion language with the instance variables and aliasing. The discussed programming language supports arrays, instance variables, failures and recursive methods with parameters. We also explain how the transformational approach can be extended to deal with other features of object-oriented programming, like classes, inheritance, subtyping and dynamic binding.", "num_citations": "20\n", "authors": ["1740"]}
{"title": "Turn-based stochastic games\n", "abstract": " We give a taxonomy of winning objectives in stochastic turn-based games, discuss their basic properties, and present an overview of the existing results. A special attention is devoted to games with infinitely many vertices.", "num_citations": "20\n", "authors": ["1740"]}
{"title": "Principles of constraint programming\n", "abstract": " Constraint programming is an alternative approach to programming in which the programming process is limited to a generation of requirements (constraints) and a solution of these requirements by means of general or domain speci c methods. The general methods are usually concerned with techniques of reducing the search space and with speci c search methods. In contrast, the domain speci c methods are usually provided in the form of special purpose algorithms or specialised packages, usually called constraint solvers. Typical examples of constraint solvers are: a program that solves systems of linear equations, a package for linear programming, an implementation of the uni cation algorithm, a cornerstone of automated theorem proving.Problems that can be solved in a natural way by means of constraint programming are usually those for which e cient algorithms are lacking (for example computationally intractable problems) or for which formalization in terms of laws (for example electrical engineering) leads to a more exible style of programming in which the dependencies between the relevant variables can be expressed in the most general form. In fact, many problems that need to be solved by means of computing are not precisely de ned or their precise speci cation may depend on the quality of a solution (such as the speed with which it is computed) to an initial version of the problem. When solving such problems one needs to proceed by several iterations. Modelling these problems by means of constraints can be often bene cial. Indeed, the appropriate modi cation of the program can then be often taken care of by modi cation of\u00a0\u2026", "num_citations": "20\n", "authors": ["1740"]}
{"title": "Preserving Liveness: Comments on ``Safety and Liveness from a Methodological Point of View''\n", "abstract": " Dederichs and Weber [4] define what it means for a property to be a liveness property with respect to a safety property. They argue that specifications should be written in the form P\u2229 Q, where Q is a liveness property with respect to the safety property P. They also criticize Alpern and Schneider\u2019s general definitions of safety and liveness [2]:", "num_citations": "20\n", "authors": ["1740"]}
{"title": "Coordination games on directed graphs\n", "abstract": " We study natural strategic games on directed graphs, which capture the idea of coordination in the absence of globally common strategies. We show that these games do not need to have a pure Nash equilibrium and that the problem of determining their existence is NP-complete. The same holds for strong equilibria. We also exhibit some classes of games for which strong equilibria exist and prove that a strong equilibrium can then be found in linear time.", "num_citations": "19\n", "authors": ["1740"]}
{"title": "CP-nets and Nash equilibria\n", "abstract": " We relate here two formalisms that are used for different purposes in reasoning about multi-agent systems. One of them are strategic games that are used to capture the idea that agents interact with each other while pursuing their own interest. The other are CP-nets that were introduced to express qualitative and conditional preferences of the users and which aim at facilitating the process of preference elicitation. To relate these two formalisms we introduce a natural, qualitative, extension of the notion of a strategic game. We show then that the optimal outcomes of a CP-net are exactly the Nash equilibria of an appropriately defined strategic game in the above sense. This allows us to use the techniques of game theory to search for optimal outcomes of CP-nets and vice-versa, to use techniques developed for CP-nets to search for Nash equilibria of the considered games.", "num_citations": "19\n", "authors": ["1740"]}
{"title": "Selfishness level of strategic games\n", "abstract": " We introduce a new measure of the discrepancy in strategic games between the social welfare in a Nash equilibrium and in a social optimum, that we call selfishness level. It is the smallest fraction of the social welfare that needs to be offered to each player to achieve that a social optimum is realized in a pure Nash equilibrium. The selfishness level is unrelated to the price of stability and the price of anarchy and is invariant under positive linear transformations of the payoff functions. Also, it naturally applies to other solution concepts and other forms of games.", "num_citations": "18\n", "authors": ["1740"]}
{"title": "Operations Research Techniques in Constraint Programming\n", "abstract": " The past four and a half years I have been a PhD student at the CWI in Amsterdam, with great pleasure. I have carried out my research in the group PNA1, which contains researchers from operations research as well as constraint programming. This turned out to be a fertile basis for my investigations on the combination of the two fields. My supervisor, Krzysztof Apt, was working on a somewhat different research topic. To illustrate this, we have not written a single joint paper in all those years, although this is probably also due to his ethical views on science. As a result, I have performed my research rather independently, which I have appreciated very much. Nevertheless, Krzysztof has supported and advised me in many different ways. I want to thank him for his guidance and, perhaps as important, confidence. Krzysztof realized that a background in constraint programming and operations research alone is not necessarily sufficient to perform interesting research on their combination. Hence, I was sent to Bologna, to collaborate with an expert in the field: Michela Milano. I have visited Bologna several times, and these visits turned out to be very fruitful. Apart from the papers we have written together, Michela has also acted as a mentor in the research process. I believe that her influence has been very important for my development. For all this I am very grateful to her.Another pleasant aspect of my visits to Bologna has been the \u201cworking environment\u201d. I am very thankful to Andrea Lodi, Andrea Roli, Paolo Torroni, and all other members of the Drunk Brain Band for their hospitality, company, and (in some cases) interesting discussions about research\u00a0\u2026", "num_citations": "18\n", "authors": ["1740"]}
{"title": "Arithmetic Classification of Perfect Models of Stratified Programs (Addendum)\n", "abstract": " RECURSION-FREE PROGRAMS The following section completes the analysis of arithmetic complexity of perfect models and has been inadvertently omitted in the previous version of the paper. We say that a general program P is recursion-free if in its dependency graph Dp there is no cycle. Clearly recursion-free programs form a subclass of stratified programs. Recursion-free programs form a very simple generalization of the class of hierarchical programs introduced in [C78]. Hierarchical programs satisfy an additional condition on variable occurrences in clauses that prevents floundering, ie a forced selection of a non-ground negative literal in an SLDNF-derivation. In this section we study the complexity of perfect models of recursion-free programs.", "num_citations": "18\n", "authors": ["1740"]}
{"title": "Proving correctness of CSP programs\u2014a tutorial\n", "abstract": " A structured presentation of a proof system for CSP programs is given. The presentation is based on the approach of Apt, Francez and de Roever [AFR]. Its new aspects are the use of static analysis and of proofs from assumptions instead of proof outlines. Also, in contrast to [AFR] total correctness is studied.", "num_citations": "18\n", "authors": ["1740"]}
{"title": "A systematic approach to language constructs for concurrent programs\n", "abstract": " Several styles and notations for representing concurrent programs are shortly explained and related to each other. It is basically demonstrated how the different language concepts found in concurrent programming conceptually evolve from classical styles of functional and applicative programming.", "num_citations": "18\n", "authors": ["1740"]}
{"title": "Common knowledge in interaction structures\n", "abstract": " We consider two simple variants of a framework for reasoning about knowledge amongst communicating groups of players. Our goal is to clarify the resulting epistemic issues. In particular, we investigate what is the impact of common knowledge of the underlying hypergraph connecting the players, and under what conditions common knowledge distributes over disjunction. We also obtain two versions of the classic result that common knowledge cannot be achieved in the absence of a simultaneous event (here a message sent to the whole group).", "num_citations": "17\n", "authors": ["1740"]}
{"title": "One more revolution to make: free scientific publishing\n", "abstract": " Springer-Verlag, John Wiley, and others. The second type is represented by the academic publishers (for example, Cambridge University Press, Princeton University Press, MIT Press, to name a few)\u2014and publishers associated with the learned societies such as ACM, IEEE, and SIAM. For a number of years the scientific publishers have increased the subscription prices to scientific journals by a margin exceeding the inflation rate; for-profit publishers increased their prices much more. According to the Association of Research Libraries the unit cost of scientific journals increased 169% from 1986 to 1997, while the consumer prices index increased only 46%(see [6]). These price increases led to a dramatic decline in the quality of scientific libraries. The current situation is that conglomerates of large university libraries often have to share the costs to afford access to the portals built by commercial publishers over the\u00a0\u2026", "num_citations": "17\n", "authors": ["1740"]}
{"title": "The randomness assumption in word frequency statistics\n", "abstract": " The mathematical and computational tools available for the study of word frequency distributions have become increasingly powerful since Zipf published his seminal studies some 60 years ago (Zipf 1935, 1949). The first frequency counts were obtained manually, either by going through a text and filing new words and updating the frequencies of words already encountered on slips of paper, or by going through (manually compiled) concordances. The first statistician to study word frequency distributions, GU Yule, obtained the data for his book on \u201cThe statistical study of literary vocabulary\u201d(Yule, 1944) in this way. The first frequency dictionary of Dutch,\u201cDe meest voorkomende woorden en woordcombinaties in het Nederlandsch\u201d, was similarly compiled manually by De la Court in 1937.The first frequency list of Dutch obtained by means of a computer was compiled at the Mathematical Centre in 1965 by van Berckel\u00a0\u2026", "num_citations": "17\n", "authors": ["1740"]}
{"title": "A theory of first-order built-in's of prolog\n", "abstract": " We provide here a framework for studying Prolog programs with various built-in's that include arithmetic operations, and such metalogical relations like var and ground. To this end we propose a new, declarative semantics and prove completeness of the Prolog computation mechanism w.r.t. this semantics. Finally, we provide a method for proving termination of Prolog programs with built-in's which uses this semantics. The method is shown to be modular.", "num_citations": "17\n", "authors": ["1740"]}
{"title": "The Alma project, or how first-order logic can help us in imperative programming\n", "abstract": " The aim of the Alma project is the design of a strongly typed constraint programming language that combines the advantages of logic and imperative programming.               The first stage of the project was the design and implementation of Alma- 0, a small programming language that provides a support for declarative programming within the imperative programming framework. It is ob- tained by extending a subset of Modula-2 by a small number of features inspired by the logic programming paradigm               In this paper we discuss the rationale for the design of Alma-0, the ben- effts of the resulting hybrid programming framework, and the current work on adding constraint processing capabilities to the language. In particular, we discuss the role of the logical and customary variables, the interaction between the constraint store and the program, and the need for lists.", "num_citations": "16\n", "authors": ["1740"]}
{"title": "Transformations realizing fairness assumptions for parallel programs\n", "abstract": " Parallel programs with shared variables are studied under a semantics which assumes the fair execution of all parallel components. We present transformations which reduce this fair semantics to a simple interleaving semantics with help of random assignments z:=?. In fact, different notions of fairness are considered: impartiality, liveness, weak and strong fairness. All transformations preserve the structure of the original programs and are thus suitable as a basis for syntax-directed correctness proofs.", "num_citations": "16\n", "authors": ["1740"]}
{"title": "Completeness with finite systems of intermediate assertions for recursive program schemes\n", "abstract": " It is proved that in the general case of arbitrary context-free schemes a program is (partially) correct with respect to given initial and final assertions if and only if a suitable finite system of intermediate assertions can be found. Assertions are allowed from the extended state space . This result contrasts with the results of [2], where it is proved that if assertions are taken from the original state space , then in the general case an infinite system of intermediate assertions is needed. The extension of the state space allows a unification in the relational framework of [2], of the (essence of the) results of [2], and of [4], [5] and [6], and provides a semantic counterpart of the use of auxiliary variables.", "num_citations": "16\n", "authors": ["1740"]}
{"title": "Exercises in denotational semantics\n", "abstract": " The present paper is a progress report about our work on semantics and proof theory of programming languages. We study a number of fundamental programming concepts occurring eg in the language PASCAL, viz. assignment, sequential composition, conditionals, locality, and (recursive) procedures with parameters called-by-value and called-byvariable. Our goal is the development of a formalism which satisfies two requirements-Semantic adequacy: the definitions capture exactly the meaning attributed to these concepts in the PASCAL report.", "num_citations": "16\n", "authors": ["1740"]}
{"title": "Paradoxes in social networks with multiple products\n", "abstract": " We show that various paradoxes can arise in a natural class of social networks. They demonstrate that more services or products may have adverse consequences for all members of the network and conversely that restricting the number of choices may be beneficial for every member of the network. These phenomena have been confirmed by a number of empirical studies. In our analysis we use a simple threshold model of social networks introduced in Apt and Markakis (2011), and more fully in Apt and Markakis (2014). In this model the agents, influenced by their neighbours, can adopt one out of several alternatives. We identify and analyze here four types of paradoxes that can arise in these networks. These paradoxes shed light on possible inefficiencies arising when one modifies the sets of products available to the agents forming a social network or the network structure. One of the paradoxes\u00a0\u2026", "num_citations": "15\n", "authors": ["1740"]}
{"title": "Constraint-based qualitative simulation\n", "abstract": " We consider qualitative simulation involving a finite set of qualitative relations in presence of complete knowledge about their interrelationship. We show how it can be naturally captured by means of constraints expressed in temporal logic and constraint satisfaction problems. The constraints relate at each stage the past of a simulation with its future. The benefit of this approach is that it readily leads to an implementation based on constraint technology that can be used to generate simulations and to answer queries about them.", "num_citations": "15\n", "authors": ["1740"]}
{"title": "Alma-0: An imperative language that supports declarative programming\n", "abstract": " We describe here an implemented small programming language, called Alma-0, that augments the expressive power of imperative programming by a limited number of features inspired by the logic programming paradigm. These additions encourage declarative programming and make it a more attractive vehicle for problems that involve search. We illustrate the use of Alma-0 by presenting solutions to a number of classical problems, including \u03b1-\u03b2 search, STRIPS planning, knapsack, and Eight Queens. These solutions are substantially simpler than their counterparts written in the imperative or in the logic programming style and can be used for different purposes without any modification. We also discuss here the implementation of Alma-0 and an operational, executable, semantics of a large subset of the language.", "num_citations": "15\n", "authors": ["1740"]}
{"title": "A closer look at declarative interpretations\n", "abstract": " Three semantics have been proposed as the most promising candidates for a declarative interpretation for logic programs and pure Prolog programs: the least Herbrand model, the least term model, ie, the C-semantics, and the I-semantics. Previous results show that a strictly increasing information ordering between these semantics exists for the class of all programs. In particular, the I-semantics allows us to model the computed answer substitutions, which is not the case for the other two. We study here the relationship between these three semantics for specific classes of programs. We show that for a large class of programs (which is Turing complete), these three semantics are isomorphic. As a consequence, given a query, we can extract from the least Herbrand model of a program in this class all computed answer substitutions. However, for specific programs the least Herbrand model is tedious to construct and\u00a0\u2026", "num_citations": "15\n", "authors": ["1740"]}
{"title": "Formal description of programming concepts\n", "abstract": " In software engineering there is a growing need for formalization as a basis for developing powerful computer assisted methods. This volume contains seven extensive lectures prepared for a series of IFIP seminars on the Formal Description of Programming Concepts. The authors are experts in their fields and have contributed substantially to the state of the art in numerous publications. The lectures cover a wide range in the theoretical foundations of programming and give an up-to-date account of the semantic models and the related tools which have been developed in order to allow a rigorous discussion of the problems met in the construction of correct programs. In particular, methods for the specification and transformation of programs are considered in detail. One lecture is devoted to the formalization of concurrency and distributed systems and reflects their great importance in programming. Further topics are the verification of programs and the use of sophisticated type systems in programming. This compendium on the theoretical foundations of programming is also suitable as a textbook for special seminars on different aspects of this broad subject.", "num_citations": "15\n", "authors": ["1740"]}
{"title": "Report of\n", "abstract": " Report of Page 1 VICTORIA Report of INSPECTOR APPOINTED TO INVESTIGATE THE AFFAIRS OF CO-OPERATIVE FARMIERS AND) GRAZIERS DIRECT MEAT SUPPLY LTD . Volume 2 September 1979 Ordered by the Legislative Assembly to be printed Af EF F() / RAE FD ATKINSON, GOVERNMENT PRINTER, MELBOURNE | 93() Page 2 \u304d\uff64\u5c0er \u25cf\u25cf Page 3 Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule Schedule 6 A - Q 10 - 00cS l l. - 00 SAAAA 15 \u2013 ] 6 \u2013 L. TS \"T\" OF SCHEDULES Names of witnesses List of exhibits List of civil actions . Cheque chart Document from which cheque chart was prepared . Summary of Society\" s profit and loss statenents L968 \u30bb\u25cb L975\u3002 Summary of Society\" s balance sheets l968 to l975 . Summary of Society\" s profit and loss \u2026", "num_citations": "14\n", "authors": ["1740"]}
{"title": "Edsger Wybe Dijkstra (1930\u20132002): A portrait of a genius\n", "abstract": " Edsger Wybe Dijkstra was born in Rotterdam on 11 May 1930. His mother was a mathematician and father  a chemist. In 1956 he graduated from the University of Leiden in mathematics and theoretical physics. In  1959 he received his PhD from the University of Amsterdam for his thesis entitled \u2018Communication with an  Automatic Computer\u2019, devoted to a description of the assembly language designed for the first commercial  computer developed in the Netherlands, the X1. It also dealt with the concept of an interrupt, a novelty at  that time. His PhD thesis supervisor was Aad van Wijngaarden.", "num_citations": "14\n", "authors": ["1740"]}
{"title": "View of constraint programming\n", "abstract": " View of constraint programming University of Amsterdam University of Amsterdam UvA Terms of use Contact UvA-DARE (Digital Academic Repository) Home Advanced Search Browse My selection Search UvA-DARE Author KR Apt Year 1998 Title View of constraint programming Journal Fundamenta Informaticae Volume | Issue number 33 | 3 Pages (from-to) 263-293 Document type Article Faculty Interfacultary Research Institutes Institute Institute for Logic, Language and Computation (ILLC) Language Undefined/Unknown Note - Persistent Identifier https://hdl.handle.net/11245/1.153551 Disclaimer/Complaints regulations If you believe that digital publication of certain material infringes any of your rights or (privacy) interests, please let the Library know, stating your reasons. In case of a legitimate complaint, the Library will make the material inaccessible and/or remove it from the website. Please Ask the Library, or \u2026", "num_citations": "14\n", "authors": ["1740"]}
{"title": "Polling systems\n", "abstract": " A polling systern is a queueing system in which several queues are attended by a single server. Spurred by various important applications, the field of polling systems is going through a period of feverish activity. The first part of this paper surveys some of the main developments. The second part generalizes the theory of polling systems to the case in which the customer arrival process depends on the position of the server, and to the case in which customers travel from queue to queue.", "num_citations": "14\n", "authors": ["1740"]}
{"title": "Logic programs with external procedures\n", "abstract": " We present a clean approach to integrating logic programs with functional procedures written in other programming languages. Many existing logic programming systems allow for use of such external procedures in logic programs. In these systems the integration is achieved on the level of implementation so that the integrated programs have no declarative semantics. Our integrated programs have a declarative semantics and a sound operational semantics. The declarative semantics is constructed by viewing the integrated programs as equational logic programs. To define the operational semantics a special kind of unification, called Sunification, is introduced. The operational semantics is based on an extension of SLD-resolution that employs S-unification and a concept of delay. The operational semantics is sound but incomplete with respect to the declarative semantics. The incompleteness is a consequence of our general assumptions about the nature of the external procedures. However, the oper...", "num_citations": "14\n", "authors": ["1740"]}
{"title": "The role of monotonicity in the epistemic analysis of strategic games\n", "abstract": " It is well-known that in finite strategic games true common belief (or common knowledge) of rationality implies that the players will choose only strategies that survive the iterated elimination of strictly dominated strategies. We establish a general theorem that deals with monotonic rationality notions and arbitrary strategic games and allows to strengthen the above result to arbitrary games, other rationality notions, and transfinite iterations of the elimination process. We also clarify what conclusions one can draw for the customary dominance notions that are not monotonic. The main tool is Tarski\u2019s Fixpoint Theorem. View Full-Text", "num_citations": "13\n", "authors": ["1740"]}
{"title": "A denotational semantics for first-order logic\n", "abstract": " In Apt and Bezem [AB99] we provided a computational interpretation of first-order formulas over arbitrary interpretations. Here we complement this work by introducing a denotational semantics for first-order logic. Additionally, by allowing an assignment of a non-ground term to a variable we introduce in this framework logical variables.               The semantics combines a number of well-known ideas from the areas of semantics of imperative programming languages and logic programming. In the resulting computational view conjunction corresponds to sequential composition, disjunction to \u201cdon\u2019t know\u201d nondeterminism, existential quantification to declaration of a local variable, and negation to the \u201cnegation as finite failure\u201d rule. The soundness result shows correctness of the semantics with respect to the notion of truth. The proof resembles in some aspects the proof of the soundness of the SLDNF-resolution.", "num_citations": "13\n", "authors": ["1740"]}
{"title": "Meta-variables in logic programming, or in praise of ambivalent syntax\n", "abstract": " We show here that meta-variables of Prolog admit a simple declarative interpretation. This allows us to extend the usual theory of SLD-resolution to the case of logic programs with meta-variables, and to establish soundness and strong completeness of the corresponding extension of the SLD-resolution. The key idea is the use of ambivalent syntax which allows us to use the same symbols as function and relation symbols. We also study the problem of absence of run-time errors in presence of meta-variables. We prove that this problem is undecidable. However, we also provide some sufficient and polynomial-time-decidable conditions which imply absence of run-time errors.", "num_citations": "13\n", "authors": ["1740"]}
{"title": "Studies in pure Prolog: termination\n", "abstract": " We provide a theoretical basis for studying termination of logic programs with the Prolog selection rule. To this end we study the class of left terminating programs. These are logic programs that terminate with the Prolog selection rule for all ground goals. First we show that various ways of defining semantics coincide for left terminating programs. Then we offer a characterization of left terminating programs that provides us with a practical method of proving termination. The method is proven to be complete and is illustrated by giving simple proofs of termination of the quicksort, permutation and mergesort programs for the desired class of goals.", "num_citations": "13\n", "authors": ["1740"]}
{"title": "On the Computational Complexity of Gossip Protocols.\n", "abstract": " Gossip protocols deal with a group of communicating agents, each holding a private information, and aim at arriving at a situation in which all the agents know each other secrets. Distributed epistemic gossip protocols are particularly simple distributed programs that use formulas from an epistemic logic. Recently, the implementability of these distributed protocols was established (which means that the evaluation of these formulas is decidable), and the problems of their partial correctness and termination were shown to be decidable, but their exact computational complexity was left open. We show that for any monotonic type of calls the implementability of a distributed epistemic gossip protocol is a PNP-complete problem, while the problems of its partial correctness and termination are in coNPNP.", "num_citations": "12\n", "authors": ["1740"]}
{"title": "Comparing the notions of optimality in CP-nets, strategic games and soft constraints\n", "abstract": " The notion of optimality naturally arises in many areas of applied mathematics and computer science concerned with decision making. Here we consider this notion in the context of three formalisms used for different purposes in reasoning about multi-agent systems: strategic games, CP-nets, and soft constraints. To relate the notions of optimality in these formalisms we introduce a natural qualitative modification of the notion of a strategic game. We show then that the optimal outcomes of a CP-net are exactly the Nash equilibria of such games. This allows us to use the techniques of game theory to search for optimal outcomes of CP-nets and vice-versa, to use techniques developed for CP-nets to search for Nash equilibria of the considered games. Then, we relate the notion of optimality used in the area of soft constraints to that used in a generalization of strategic games, called graphical games. In particular\u00a0\u2026", "num_citations": "12\n", "authors": ["1740"]}
{"title": "Relative strength of strategy elimination procedures\n", "abstract": " We compare here the relative strength of four widely used procedures on finite strategic games: iterated elimination of weakly/strictly dominated strategies by a pure/mixed strategy. A complication is that none of these procedures is based on a monotonic operator. To deal with this problem we use 'global' versions of these operators.", "num_citations": "12\n", "authors": ["1740"]}
{"title": "Infinite qualitative simulations by means of constraint programming\n", "abstract": " We introduce a constraint-based framework for studying infinite qualitative simulations concerned with contingencies such as time, space, shape, size, abstracted into a finite set of qualitative relations. To define the simulations we combine constraints that formalize the background knowledge concerned with qualitative reasoning with appropriate inter-state constraints that are formulated using linear temporal logic.               We implemented this approach in a constraint programming system (ECL                   i                  PS                   e                 ) by drawing on the ideas from bounded model checking. The implementation became realistic only after several rounds of optimizations and experimentation with various heuristics.               The resulting system allows us to test and modify the problem specifications in a straightforward way and to combine various knowledge aspects. To demonstrate the expressiveness\u00a0\u2026", "num_citations": "12\n", "authors": ["1740"]}
{"title": "A sound and complete Hoare-like proof system for a fragment of PASCAL\n", "abstract": " A sound and complete Hoare-like proof system for a fragment of PASCAL (1978) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication A sound and complete Hoare-like proof system for a fragment of PASCAL (1978) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title A sound and complete Hoare-like proof system for a fragment of PASCAL Author KR Apt (Krzysztof) Date issued 1978-01-01 Access Open Access Language English Type Other Publisher Stichting Mathematisch Centrum Publication https://ir.cwi.nl/pub/10581 Persistent Identifier urn:NBN:nl:ui:18-10581 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> Privacy statement >>> Disclaimer >>> DANS \u2026", "num_citations": "12\n", "authors": ["1740"]}
{"title": "The H-index can be easily manipulated\n", "abstract": " We prove two complexity results about the H-index concerned with the Google scholar merge operation on one's scientific articles. The results show that, although it is hard to merge one's articles in an optimal way, it is easy to merge them in such a way that one's H-index increases. This suggests the need for an alternative scientific performance measure that is resistant to this type of manipulation.", "num_citations": "11\n", "authors": ["1740"]}
{"title": "Common beliefs and public announcements in strategic games with arbitrary strategy sets\n", "abstract": " We provide an epistemic analysis of arbitrary strategic games based on possibility correspondences. We first establish a generic result that links true common beliefs (and, respectively, common knowledge) of players' rationality defined by means of `monotonic' properties, with the iterated elimination of strategies that do not satisfy these properties. It allows us to deduce the customary results concerned with true common beliefs of rationality and iterated elimination of strictly dominated strategies as simple corollaries. This approach relies on Tarski's Fixpoint Theorem. We also provide an axiomatic presentation of this generic result. This allows us to clarify the proof-theoretic principles assumed in players' reasoning. Finally, we provide an alternative characterization of the iterated elimination of strategies based on the concept of a public announcement. It applies to `global properties'. Both classes of properties include the notions of rationalizability and the iterated elimination of strictly dominated strategies.", "num_citations": "11\n", "authors": ["1740"]}
{"title": "Management of stratified databases\n", "abstract": " 1.1. ObjectivesThe aim of this paper is to propose a knowledge based management system (KBMS in short) whose main characteristics are: use of incomplete information, immediate visualization of modifications, generation of explanations, simulation and\" undo\" capabilities. Our proposal has a clear semantics allowing us to account for the use of incomplete information in an interactive environment. We believe that due to the above features our proposal can be used as a system for interactive problem solving and decision making. The framework in which we carry out our investigations is that of deductive databases, or more generally rule based programming. While proposing such a system we have in mind the following objectives:", "num_citations": "11\n", "authors": ["1740"]}
{"title": "Correctness proofs of distributed termination algorithms\n", "abstract": " The problem of correctness of the solutions to the distributed termination problem of Francez [F] is addressed. Correctness criteria are formalized in the customary framework for program correctness. A very simple proof method is proposed and applied to show correctness of a solution to the problem.", "num_citations": "11\n", "authors": ["1740"]}
{"title": "Common knowledge in a logic of gossips\n", "abstract": " Gossip protocols aim at arriving, by means of point-to-point or group communications, at a situation in which all the agents know each other secrets. Recently a number of authors studied distributed epistemic gossip protocols. These protocols use as guards formulas from a simple epistemic logic, which makes their analysis and verification substantially easier. We study here common knowledge in the context of such a logic. First, we analyze when it can be reduced to iterated knowledge. Then we show that the semantics and truth for formulas without nested common knowledge operator are decidable. This implies that implementability, partial correctness and termination of distributed epistemic gossip protocols that use non-nested common knowledge operator is decidable, as well. Given that common knowledge is equivalent to an infinite conjunction of nested knowledge, these results are non-trivial generalizations of the corresponding decidability results for the original epistemic logic, established in (Apt & Wojtczak, 2016). K. R. Apt & D. Wojtczak (2016): On Decidability of a Logic of Gossips. In Proc. of JELIA 2016, pp. 18-33, doi:10.1007/ 978-3-319-48758-8_2.", "num_citations": "10\n", "authors": ["1740"]}
{"title": "Decidability of fair termination of gossip protocols\n", "abstract": " Gossip protocols deal with a group of communicating agents, each holding some private information, and aim at arriving at a situation in which all the agents know each other secrets. Distributed epistemic gossip protocols are particularly simple distributed programs that use as guards formulas from an epistemic logic. We showed recently that the implementability of these distributed gossip protocols and the problems of their partial correctness and termination are decidable, but the problem of decidability of their fair termination was left open. We study here rule-fair and agent-fair termination of these protocols and show that both properties are decidable.", "num_citations": "10\n", "authors": ["1740"]}
{"title": "A primer on strategic games.\n", "abstract": " This is a short introduction to the subject of strategic games. We focus on the concepts of best response, Nash equilibrium, strict and weak dominance, and mixed strategies, and study the relation between these concepts in the context of the iterated elimination of strategies. Also, we discuss some variants of the original definition of a strategic game. Finally, we introduce the basics of mechanism design and use pre-Bayesian games to explain it.", "num_citations": "10\n", "authors": ["1740"]}
{"title": "Direct proofs of order independence\n", "abstract": " We establish a generic result concerning order independence of a dominance relation on finite games. It allows us to draw conclusions about order independence of various dominance relations in a direct and simple way.", "num_citations": "10\n", "authors": ["1740"]}
{"title": "Programmation par r\u00e8gles et strat\u00e9gies pour la g\u00e9n\u00e9ration automatique de m\u00e9canismes de combustion d'hydrocarbures polycycliques\n", "abstract": " {L'objectif principal de cette th\u00e8se est d'explorer l'utilisation des syst\u00e8mes {\\a} base de r\u00e8gles et strat\u00e9gies, pour un probl\u00e8me complexe de cin\u00e9tique chimique\\,: la g\u00e9n\u00e9ration automatique de m\u00e9canismes r\u00e9actionnels. Les r\u00e9actions chimiques s' expriment naturellement par des r\u00e8gles de r\u00e9\u00e9criture conditionnelles. Le contr {\\^ o} le de l'encha {\\^\\i} nement des r\u00e9actions chimiques se d\u00e9crit facilement dans un langage de strat\u00e9gies, tel que celui du syst\u00e8me ELAN, d\u00e9velopp\u00e9 dans l'\u00e9quipe Protheo. La th\u00e8se pr\u00e9sente les concepts de base de la cin\u00e9tique chimique, les probl\u00e8mes chimiques et informatiques li\u00e9s {\\a} la conception et {\\a} la validation d'un m\u00e9canisme r\u00e9actionnel, et propose une structure g\u00e9n\u00e9rale pour le g\u00e9n\u00e9rateur de m\u00e9canismes r\u00e9actionnels appel\u00e9 GasEl. Notre recherche s' est focalis\u00e9e sur le g\u00e9n\u00e9rateur de m\u00e9canisme primaire. Nous proposons des solutions pour le codage des esp\u00e8ces chimiques, des r\u00e9actions et de leur encha {\\^\\i} nement, et nous pr\u00e9sentons le prototype que nous avons d\u00e9velopp\u00e9 en ELAN. La repr\u00e9sentation des esp\u00e8ces chimiques utilise la notion de graphes mol\u00e9culaires et leur codage par une structure de termes, appel\u00e9s termes GasEl. Les r\u00e9actions chimiques sont exprim\u00e9es par des r\u00e8gles de r\u00e9\u00e9criture sur des graphes mol\u00e9culaires et cod\u00e9es par un ensemble de r\u00e8gles de r\u00e9\u00e9criture conditionnelles sur les termes GasEl. Le langage de strat\u00e9gies du syst\u00e8me ELAN est utilis\u00e9 pour exprimer l'encha {\\^\\i} nement des r\u00e9actions dans le g\u00e9n\u00e9rateur de m\u00e9canisme primaire. Cette approche est illustr\u00e9e par dix r\u00e9actions g\u00e9n\u00e9riques de la pyrolyse oxydante. Les validations chimiques qualitatives du prototype\u00a0\u2026", "num_citations": "10\n", "authors": ["1740"]}
{"title": "A comparative study of arithmetic constraints on integer intervals\n", "abstract": " We propose here a number of approaches to implement constraint propagation for arithmetic constraints on integer intervals. To this end we introduce integer interval arithmetic. Each approach is explained using appropriate proof rules that reduce the variable domains. We compare these approaches using a set of benchmarks.", "num_citations": "10\n", "authors": ["1740"]}
{"title": "The semantics of equational logic programming as an instance of CLP\n", "abstract": " We show how functional (ie equational) and logic programming can be integrated within the Constraint Logic Programming paradigm. The resulting language CLP () is specialized in solving equations with respect to a Horn equational theory. CLP () inherits all the semantic properties of the CLP scheme, including a new semantics which models answer constraints. The operational semantics of CLP () is de ned by a constraint solver based on conditional narrowing. Several strategies to obtain an incremental constraint solver are considered.In this paper we show how equational and logic programming can be integrated within the constraint logic programming paradigm thus inheriting all the CLP semantic properties. In the last few years several approaches to the integration of logic and equational programming have been developed [4, 9, 16, 22, 24, 29, 32, 7, 45, 46]. One relevant approach [29, 35] de nes equational logic programs as logic programs augmented by Horn equational theories. Interpreted function symbols can appear as arguments of relations and existentially quanti ed variables can occur as arguments of functions. Function de nition and evaluation are thus embedded in a logical framework. To properly cope with the equational theory, the conventional SLD-resolution mechanism based on a (syntactical) uni cation algorithm of logic programs has to be modi ed. The operational semantics of an equational logic language is based on", "num_citations": "10\n", "authors": ["1740"]}
{"title": "Proving termination of parallel programs\n", "abstract": " In Owicki and Gries [2] a well known proof method for verifying parallel programs based on the interference freedom test was introduced. We show that their extension of the method to deal with termination is incorrect and suggest two ways of repairing it.", "num_citations": "10\n", "authors": ["1740"]}
{"title": "Logicomix: An epic search for truth\n", "abstract": " This exceptional graphic novel recounts the spiritual odyssey of philosopher Bertrand Russell. In his agonized search for absolute truth, Russell crosses paths with legendary thinkers like Gottlob Frege, David Hilbert, and Kurt G\u00f6del, and finds a passionate student in the great Ludwig Wittgenstein. But his most ambitious goal-to establish unshakable logical foundations of mathematics-continues to loom before him. Through love and hate, peace and war, Russell persists in the dogged mission that threatens to claim both his career and his personal happiness, finally driving him to the brink of insanity. This story is at the same time a historical novel and an accessible explication of some of the biggest ideas of mathematics and modern philosophy. With rich characterizations and expressive, atmospheric artwork, the book spins the pursuit of these ideas into a highly satisfying tale. Probing and ingeniously layered, the book throws light on Russell's inner struggles while setting them in the context of the timeless questions he spent his life trying to answer. At its heart, Logicomix is a story about the conflict between an ideal rationality and the unchanging, flawed fabric of reality.", "num_citations": "9\n", "authors": ["1740"]}
{"title": "Towards free access to scientific literature\n", "abstract": " Internet has profoundly changed the way scientific research is carried out. This in turn has altered our attitudes concerning access to scientific information. In this article we review a number of recent initiatives in various fields of science. We argue that the scientists in general, and mathematicians in particular, should actively support a transition towards free access to scientific literature.In the software world a bizarre dichotomy established itself. On the one hand we have the Microsoft products, such as Windows, Word, and Excel that are not free and the source code of which is not available. On the other hand we also have the Linux operating system and other so-called GNU software that is free and the source code of which is open.", "num_citations": "9\n", "authors": ["1740"]}
{"title": "Logic Programming Languages Constraints, Functions, and Objects\n", "abstract": " Krzysztof R. Apt, JW de Bakker & JJMM Rutten, Logic Programming Languages Constraints, Functions, and Objects - PhilPapers Sign in | Create an account PhilPapers PhilPeople PhilArchive PhilEvents PhilJobs PhilPapers home Syntax Advanced Search Syntax Advanced Search Syntax Advanced Search Logic Programming Languages Constraints, Functions, and Objects Krzysztof R. Apt, JW de Bakker & JJMM Rutten (1993) Abstract This article has no associated abstract. (fix it) Keywords Logic programming languages Categories Areas of Mathematics in Philosophy of Mathematics (categorize this paper) Buy this book Find it on Amazon.com ISBN(s) 0262011344 0262011344 Options Edit this record Mark as duplicate Export citation Find it on Scholar Request removal from index Revision history Download options PhilArchive copy Upload a copy of this paper Check publisher's policy Papers currently archived: \u2026", "num_citations": "9\n", "authors": ["1740"]}
{"title": "Introduction to logic programming (revised and extended version)\n", "abstract": " Introduction to logic programming (revised and extended version) (1988) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication Introduction to logic programming (revised and extended version) (1988) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Introduction to logic programming (revised and extended version) Series Department of Computer Science [CS] Author KR Apt (Krzysztof) Date issued 1988-01-01 Access Closed Access Language English Type Other Publisher CWI Publication https://ir.cwi.nl/pub/5976 Persistent Identifier urn:NBN:nl:ui:18-5976 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> Privacy statement >>> Disclaimer >>> DANS is an institute of \u2026", "num_citations": "9\n", "authors": ["1740"]}
{"title": "When Are Two Gossips the Same? Types of Communication in Epistemic Gossip Protocols\n", "abstract": " We provide an in-depth study of the knowledge-theoretic aspects of communication in so-called gossip protocols. Pairs of agents communicate by means of calls in order to spread information---so-called secrets---within the group. Depending on the nature of such calls knowledge spreads in different ways within the group. Systematizing existing literature, we identify 18 different types of communication, and model their epistemic effects through corresponding indistinguishability relations. We then provide a classification of these relations and show its usefulness for an epistemic analysis in presence of different communication types. Finally, we explain how to formalise the assumption that the agents have common knowledge of a distributed epistemic gossip protocol.", "num_citations": "8\n", "authors": ["1740"]}
{"title": "Verification of distributed epistemic gossip protocols\n", "abstract": " Gossip protocols aim at arriving, by means of point-to-point or group communications, at a situation in which all the agents know each other secrets. Distributed epistemic gossip protocols use as guards formulas from a simple epistemic logic and as statements calls between the agents. They are natural examples of knowledge based programs. We prove here that these protocols are implementable, that their partial correctness is decidable and that termination and two forms of fair termination of these protocols are decidable, as well. To establish these results we show that the definition of semantics and of truth of the underlying logic are decidable.", "num_citations": "8\n", "authors": ["1740"]}
{"title": "On decidability of a logic of gossips\n", "abstract": " Gossip protocols aim at arriving, by means of point-to-point or group communications, at a situation in which all the agents know each other secrets, see, e.g., [11]. In [1], building upon [3], we studied distributed epistemic gossip protocols, which are examples of knowledge based programs introduced in [6]. These protocols use as guards formulas from a simple epistemic logic. We show here that these protocols are implementable by proving that it is decidable to determine whether a formula with no nested modalities is true after a sequence of calls. Building upon this result we further show that the problems of partial correctness and of termination of such protocols are decidable, as well.", "num_citations": "8\n", "authors": ["1740"]}
{"title": "First-order logic as a constraint programming language\n", "abstract": " We provide a denotational semantics for first-order logic that captures the two-level view of the computation process typical for constraint programming. At one level we have the usual program execution. At the other level an automatic maintenance of the constraint store takes place.             We prove that the resulting semantics is sound with respect to the truth definition. By instantiating it by specific forms of constraint management policies we obtain several sound evaluation policies of first-order formulas. This semantics can also be used a basis for sound implementation of constraint maintenance in presence of block declarations and conditionals.", "num_citations": "8\n", "authors": ["1740"]}
{"title": "Programming in alma-0, or imperative and declarative programming reconciled\n", "abstract": " In (Apt et al, TOPLAS 1998) we introduced the imperative programming language Alma-0 that supports declarative programming. In this paper we illustrate the hybrid programming style of Alma-0 by means of various examples that complement those presented in (Apt et al, TOPLAS 1998). The presented Alma-0 programs illustrate the versatility of the language and show that ``don't know'' nondeterminism can be naturally combined with assignment.", "num_citations": "8\n", "authors": ["1740"]}
{"title": "On the power of subsumption and context checks\n", "abstract": " Loop checking is a mechanism used to prune infinite SLD-derivations. Here we study two classes of loop checking mechanisms \u2014 subsumption checks and context checks. We analyze their soundness, completeness relative strength and related concepts. We prove their soundness (no computed answer substitution to a goal is missed) and demonstrate their completeness (all resulting derivations are finite) for some classes of logic programs. The completeness theorems for the subsumption checks make use of a simple version of Kruskal's Tree Theorem [K], called Higman's Lemma [H].             This paper is a sequel to Apt, Bol and Klop [ABK] where a formal framework for studying loop checking mechanisms was introduced and where so-called equality checks were studied.", "num_citations": "8\n", "authors": ["1740"]}
{"title": "Introduction to Program Verification.\n", "abstract": " We provide a systematic introduction to program verification based on the assertional method. We study here deterministic, nondeterministic, parallel and distributed programs and deal with such properties as partial correctness, termination, absence of failures, interference freedom and deadlock freedom.", "num_citations": "8\n", "authors": ["1740"]}
{"title": "Social network games with obligatory product selection\n", "abstract": " Recently, Apt and Markakis introduced a model for product adoption in social networks with multiple products, where the agents, influenced by their neighbours, can adopt one out of several alternatives (products). To analyze these networks we introduce social network games in which product adoption is obligatory. We show that when the underlying graph is a simple cycle, there is a polynomial time algorithm allowing us to determine whether the game has a Nash equilibrium. In contrast, in the arbitrary case this problem is NP-complete. We also show that the problem of determining whether the game is weakly acyclic is co-NP hard. Using these games we analyze various types of paradoxes that can arise in the considered networks. One of them corresponds to the well-known Braess paradox in congestion games. In particular, we show that social networks exist with the property that by adding an additional product to a specific node, the choices of the nodes will unavoidably evolve in such a way that everybody is strictly worse off.", "num_citations": "7\n", "authors": ["1740"]}
{"title": "Public announcements in strategic games with arbitrary strategy sets\n", "abstract": " In [Van Benthem 2007] the concept of a public announcement is used to study the effect of the iterated elimination of strictly dominated strategies. We offer a simple generalisation of this approach to cover arbitrary strategic games and many optimality notions. We distinguish between announcements of optimality and announcements of rationality.", "num_citations": "6\n", "authors": ["1740"]}
{"title": "Schedulers for rule-based constraint programming\n", "abstract": " We study here schedulers for a class of rules that naturally arise in the context of rule-based constraint programming. We systematically derive a scheduler for them from a generic iteration algorithm of Apt [4]. We apply this study to so-called membership rules of Apt and Monfroy [5]. This leads to an implementation that yields for these rules a considerably better performance than their execution as standard CHR rules.", "num_citations": "6\n", "authors": ["1740"]}
{"title": "The logic programming paradigm and prolog\n", "abstract": " This is a tutorial on logic programming and Prolog appropriate for a course on programming languages for students familiar with imperative programming.", "num_citations": "6\n", "authors": ["1740"]}
{"title": "Reasoning about termination of Prolog programs\n", "abstract": " BackgroundProlog is a programming language based on logic programming. However, the use of a \ufb01xed selection rule combined with the depth \ufb01rst search in the resulting search trees makes Prolog and logic prograrnming different. As a consequence various completeness results lin. king the procedural and declarative interpretation of logic programs cannot be directly applied to Prolog programs. This mismatch makes it di\ufb01icult to study Prolog programs using only the logic programming theory. Clearly the main problem is the issue of termination: a Prolog interpreter will miss a solution if all success nodes lie to the right of an in\ufb01nite path in the search tree. In this paper we propose to study Prolog programs that terminate for all ground goals. By termination we mean here \ufb01niteness of all possible Prolog derivations starting in the initial goal. We call such programs left terminating. The restriction to such programs\u00a0\u2026", "num_citations": "6\n", "authors": ["1740"]}
{"title": "An axiomatization of the intermittent assertion method using temporal logic\n", "abstract": " The intermittent assertion method proposed by Burstall [B] and subsequently popularized by Manna and Waldinger [MW] is axiomatized using a fragment of temporal logic. The proposed proof system allows to reason about while-programs. The proof system is proved to be arithmetically sound and complete in the sense of Harel [H]. The results of the paper generalize a corresponding result of Pnueli             The system decomposes into two parts. The first part allows to prove liveness properties using as axioms theorems of the second part allowing to prove simple safety properties.             The completeness proof is constructive and provides a heuristic for proving specific limeness formulas.", "num_citations": "6\n", "authors": ["1740"]}
{"title": "Omega-models in analytical hierarchy\n", "abstract": " Omega-models in analytical hierarchy (1972) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication Omega-models in analytical hierarchy (1972) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Omega-models in analytical hierarchy Published in Bulletin de l'Acad\u00e9mie Polonaise des Sciences, 901 - 904 Author KR Apt (Krzysztof) Date issued 1972-01-01 Access Open Access Language English Type Article Publisher PAN Publication https://ir.cwi.nl/pub/10234 Persistent Identifier urn:NBN:nl:ui:18-10234 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> Privacy statement >>> Disclaimer >>> DANS is an institute of KNAW and NWO Go to page top Go back to \u2026", "num_citations": "6\n", "authors": ["1740"]}
{"title": "Proof-theoretic analysis of rationality for strategic games with arbitrary strategy sets\n", "abstract": " In the context of strategic games, we provide an axiomatic proof of the statement                                                                        (Imp)                                            Common knowledge of rationality implies that the players will choose only strategies that survive the iterated elimination of strictly dominated strategies.                                                                                       Rationality here means playing only strategies one believes to be best responses. This involves looking at two formal languages. One, , is first-order, and is used to formalise optimality conditions, like avoiding strictly dominated strategies, or playing a best response. The other, , is a modal fixpoint language with expressions for optimality, rationality and belief. Fixpoints are used to form expressions for common belief and for iterated elimination of non-optimal strategies.", "num_citations": "5\n", "authors": ["1740"]}
{"title": "Optimal strategies in sequential bidding\n", "abstract": " We are interested in mechanisms that maximize social welfare. In [1] this problem was studied for multi-unit auctions with unit demand bidders and for the public project problem, and in each case social welfare undominated mechanisms in the class of feasible and incentive compatible mechanisms were identified. One way to improve upon these optimality results is by allowing the players to move sequentially. With this in mind, we study here sequential versions of two feasible Groves mechanisms used for single item auctions: the Vickrey auction and the Bailey-Cavallo mechanism. Because of the absence of dominant strategies in this sequential setting, we focus on a weaker concept of an optimal strategy. For each mechanism we introduce natural optimal strategies and observe that in each mechanism these strategies exhibit different behaviour. However, we then show that among all optimal strategies, the one we introduce for each mechanism maximizes the social welfare when each player follows it. The resulting social welfare can be larger than the one obtained in the simultaneous setting. Finally, we show that, when interpreting both mechanisms as simultaneous ones, the vectors of the proposed strategies form a Pareto optimal Nash equilibrium in the class of optimal strategies.", "num_citations": "5\n", "authors": ["1740"]}
{"title": "Syntax directed analysis of liveness properties of while programs\n", "abstract": " A syntax directed proof system which allows to prove liveness properties of while-programs is introduced. The proof system is proved to be arithmetically sound and complete in the sense of Harel (\u201cLecture Notes in Comput. Sci. Vol. 68,\u201d Springer-Verlag, Berlin/New York, 1979). The results of the paper generalize a corresponding result Pneuli (\u201cPrc. 18th Sympos. FOCS\u201d IEEE, Providence, R. I., 1977) proves for unstructured programs. The proof system decomposes into two parts. The first part allows to prove simple safety properties. These properties are used as axioms in the second proof system which deals with liveness properties. The completeness proof is constructive and provides a heuristic for proving specific liveness properties.", "num_citations": "5\n", "authors": ["1740"]}
{"title": "Quarterly\n", "abstract": " The SWRWCP in collaboration with Saint Elizabeth Health Care (SEHC) has completed phase I of a pilot project to provide virtual-Enterostomal Therapy (v-ET) consultation services to patients with complex wounds in long-term care (LTC). Five LTC facilities participated in the phase 1 pilot including Greenwood Court, McCormick Home, Mount Hope Centre for Long Term Care, Maple View Long Term Care, and Greenwood Court. The v-ET program was created to test an innovative approach to providing \u201con demand\u201d and \u201cjust in time\u201d access to a wound care expert in LTC facilities using a virtual consultative approach.A significant increase in wound care knowledge of front-line LTC clinicians was demonstrated as well as a trend towards improved cost efficiency. Phase II is currently underway and we are actively recruiting to increase the number of LTC facilities and also include rural hospitals with minimal access to specialized wound consultants. If your facility is interested in participating in phase II of the project, please contact Lyndsay Orr at", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Self-stabilization through the lens of game theory\n", "abstract": " In 1974 Dijkstra introduced the seminal concept of self-stabilization that turned out to be one of the main approaches to fault-tolerant computing. We show here how his three solutions can be formalized and reasoned about using the concepts of game theory. We also determine the precise number of steps needed to reach self-stabilization in his first solution.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Common knowledge in email exchanges\n", "abstract": " We consider a framework in which a group of agents communicates by means of emails, with the possibility of replies, forwards and blind carbon copies (BCC). We study the epistemic consequences of such email exchanges by introducing an appropriate epistemic language and semantics. This allows us to find out what agents learn from the emails they receive and to determine when a group of agents acquires common knowledge of the fact that an email was sent. We also show that in our framework from the epistemic point of view the BCC feature of emails cannot be simulated using messages without BCC recipients.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Sequential pivotal mechanisms for public project problems\n", "abstract": " It is well-known that for several natural decision problems no budget balanced Groves mechanisms exist. This has motivated recent research on designing variants of feasible Groves mechanisms (termed as \u2018redistribution of VCG (Vickrey-Clarke-Groves) payments\u2019) that generate reduced deficit. With this in mind, we study sequential mechanisms and consider optimal strategies that could reduce the deficit resulting under the simultaneous mechanism. We show that such strategies exist for the sequential pivotal mechanism of the well-known public project problem. We also exhibit an optimal strategy with the property that a maximal social welfare is generated when each player follows it. Finally, we show that these strategies can be achieved by an implementation in Nash equilibrium. All proofs can be found in the full version posted in Computing Research Repository (CoRR),                                     http://arxiv\u00a0\u2026", "num_citations": "4\n", "authors": ["1740"]}
{"title": "While Programs\n", "abstract": " In A Deterministic program there is at most one instruction to be executed \u201cnext,\u201d so that from a given initial state only one execution sequence is generated. In classical programming languages like Pascal, only deterministic programs can be written. In this chapter we study a small class of deterministic programs, called while programs, which are included in all other classes of programs studied in this book. We start by defining the syntax (Section 3.1), then introduce an operational semantics (Section 3.2), subsequently study program verification by introducing proof systems allowing us to prove various program properties and prove the soundness of the introduced proof systems (Section 3.3). This pattern is repeated for all classes of programs studied in this book. We introduce here two semantics \u2014partial correctness and total correctness semantics. The former does not take into account the possibility of\u00a0\u2026", "num_citations": "4\n", "authors": ["1740"]}
{"title": "A comparison of the notions of optimality in soft constraints and graphical games\n", "abstract": " The notion of optimality naturally arises in many areas of applied mathematics and computer science concerned with decision making. Here we consider this notion in the context of two formalisms used for different purposes and in different research areas: graphical games and soft constraints. We relate the notion of optimality used in the area of soft constraint satisfaction problems (SCSPs) to that used in graphical games, showing that for a large class of SCSPs that includes weighted constraints every optimal solution corresponds to a Nash equilibrium that is also a Pareto efficient joint strategy.             We also study alternative mappings including one that maps graphical games to SCSPs, for which Pareto efficient joint strategies and optimal solutions coincide.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Sequential mechanism design\n", "abstract": " In the customary VCG (Vickrey-Clarke-Groves) mechanism truth-telling is a dominant strategy. In this paper we study the sequential VCG mechanism and show that other dominant strategies may then exist. We illustrate how this fact can be used to minimize taxes using examples concerned with Clarke tax and public projects.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Explaining constraint programming\n", "abstract": " We discuss here constraint programming (CP) by using a proof-theoretic perspective. To this end we identify three levels of abstraction. Each level sheds light on the essence of CP.             In particular, the highest level allows us to bring CP closer to the computation as deduction paradigm. At the middle level we can explain various constraint propagation algorithms. Finally, at the lowest level we can address the issue of automatic generation and optimization of the constraint propagation algorithms.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "The STO-problem is NP-hard\n", "abstract": " A finite set of term equations E is called subject to the occur-check (STO) if a sequence of actions of the Martelli-Montanari unification algorithm starts with E and ends with a failure due to occur-check. We prove here that the problem of deciding whether E is STO is NP-hard.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Efficient computing of least fixpoints\n", "abstract": " We systematically derive efficient algorithms for computing the least fixpoints of monotonic operators in the context of deductive databases. To this purpose we identify additivity as a key property assumed from the operator and study additive operators on complete lattices. To handle the general case certain combinations of additive operators need to be considered.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Equivalence of operational and denotational semantics for a fragment of PASCAL\n", "abstract": " A fragment of PASCAL is considered in which nested systems of procedure declarations are allowed. Procedures can call parametersby value or by variable. Three semantics for the fragment are considered-two denotational ones and one operational and proved all three to be equivalent. INTRODUCTIONMuch work has been done on comparisons between various methods of describing the semantics of programming languages. Without aiming at completeness we mention the papers of Lauer ('71), Hoare & Lauer ('74), Milne & Strachey ('76), Milner ('76) and Stoy ('76). In this paper we focus on two methods of description-denotational and operational semantics. The aim is to show that they are equivalent for a fragment of PASCAL. The considered language (taken from Apt & De Bakker) contains simple and subscripted variables, some simple types of expressions, assignment, sequential c9mposition, conditionals, declaration of simple and array variables, systems of (recursive) procedure declarations and procedure calls. Procedures can call parameters by value or variable.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Infinitistic rules of proof and their semantics\n", "abstract": " We consider problems connected with the semantics of infinitary rules of proof formulated in the language of the second order arithmetics. We answer negatively two questions of Enderton concerning the semantics of his. sil-rule. Finally, we discuss the problem of the existence of a satisfactory syntactical ft-rule.", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Non-finite axiomatizability of the second order arithmetic\n", "abstract": " The following theorem is proved: Assume V= L. Let (A) be the second order arithmetic,. and let S be the set of all true II~ formulas of the language of (A). Then Cn (S) does not contain\u00b7", "num_citations": "4\n", "authors": ["1740"]}
{"title": "Open problems in a logic of gossips\n", "abstract": " Gossip protocols are programs used in a setting in which each agent holds a secret and the aim is to reach a situation in which all agents know all secrets. Such protocols rely on a point-to-point or group communication. Distributed epistemic gossip protocols use epistemic formulas in the component programs for the agents. The advantage of the use of epistemic logic is that the resulting protocols are very concise and amenable for a simple verification. Recently, we introduced a natural modal logic that allows one to express distributed epistemic gossip protocols and to reason about their correctness. We proved that the resulting protocols are implementable and that all aspects of their correctness, including termination, are decidable. To establish these results we showed that both the definition of semantics and of truth of the underlying logic are decidable. We also showed that the analogous results hold for an extension of this logic with the 'common knowledge' operator. However, several, often deceptively simple, questions about this logic and the corresponding gossip protocols remain open. The purpose of this paper is to list and elucidate these questions and provide for them an appropriate background information in the form of partial of related results.", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Strategic games\n", "abstract": " Mathematical game theory, as launched by Von Neumann and Morgenstern in their seminal book [22], followed by Nash\u2019contributions [11, 12], has become a standard tool in Economics for the study and description of various economic processes, including competition, cooperation, collusion, strategic behaviour and bargaining. Since then it has also been successfuly used in Biology, Political Sciences, Psychology and Sociology. With the advent of the Internet game theory became increasingly relevant in Computer Science.", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Proceeding of the 13th Conference on Theoretical Aspects of Rationality and Knowledge\n", "abstract": " K. Apt (ed.), Proceeding of the 13th Conference on Theoretical Aspects of Rationality and Knowledge - PhilPapers Sign in | Create an account PhilPapers PhilPeople PhilArchive PhilEvents PhilJobs PhilPapers home Syntax Advanced Search Syntax Advanced Search Syntax Advanced Search Proceeding of the 13th Conference on Theoretical Aspects of Rationality and Knowledge K. Apt (ed.) ACM (2011) Abstract This article has no associated abstract. (fix it) Keywords No keywords specified (fix it) Categories Epistemology, Misc in Epistemology (categorize this paper) Buy this book Find it on Amazon.com Options Edit this record Mark as duplicate Export citation Find it on Scholar Request removal from index Translate to english Revision history Download options PhilArchive copy Upload a copy of this paper Check publisher's policy Papers currently archived: 56,287 External links This entry has no external links. \u2026", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Modular verification of recursive programs\n", "abstract": " We argue that verification of recursive programs by means of the assertional method of C.A.R. Hoare can be conceptually simplified using a modular reasoning. In this approach some properties of the program are established first and subsequently used to establish other program properties. We illustrate this approach by providing a modular correctness proof of the Quicksort program.", "num_citations": "3\n", "authors": ["1740"]}
{"title": "A distributed platform for mechanism design\n", "abstract": " We describe a structured system for distributed mechanism design. It consists of a sequence of layers. The lower layers deal with the operations relevant for distributed computing only, while the upper layers are concerned only with communication among players, including broadcasting and multicasting, and distributed decision making. This yields a highly flexible distributed system whose specific applications are realized as instances of its top layer. This design supports fault-tolerance, prevents manipulations and makes it possible to implement distributed policing. The system is implemented in Java. We illustrate it by discussing a number of implemented examples.", "num_citations": "3\n", "authors": ["1740"]}
{"title": "New Perspectives on Games and Interaction\n", "abstract": " This volume is a collection of papers presented at the 2007 colloquium on new perspectives on games and interaction at the Royal Dutch Academy of Sciences in Amsterdam. The purpose of the colloquium was to clarify the uses of the concepts of game theory, and to identify promising new directions. This important collection testifies to the growing importance of game theory as a tool to capture the concepts of strategy, interaction, argumentation, communication, cooperation and competition. Also, it provides evidence for the richness of game theory and for its impressive and growing application.", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Rule-based versus procedure-based view of logic programming\n", "abstract": " Logic programming is a rule-based formalism: a program consists of a collection of rules that are activated by means of an initial query. This approach to programming has to do with the automated theorem proving roots of logic programs. In fact, each rule or query is a Horn clause and the computation process corresponds to a specialised form of the resolution method. In imperative programs, for example in Pascal or C, a different view is taken according to which a program consists of a collection of procedure declarations together with an initial statement. Each procedure declaration consists of a procedure name followed by (the specification of the types of) the formal parameters and the procedure body, which is a statement. In turn, the statements are defined by structural induction starting with the atomic statements and using compound statements. We call this approach a procedure-based formalism.In this paper, to keep the arguments simple, we restrict our attention to logic programs without negation, usually called definite programs. We refer to them simply as\" logic programs\". Our aim is to clarify to what procedurebased formalism logic programming corresponds. Since syntactically logic programs are defined in a subset of first-order logic-the one consisting of the Horn clauses-it is possible to define syntactically the appropriate", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Comparing negation in logic programming and in Prolog\n", "abstract": " We compare here two uses of negation-in logic programming and in Prolog. As in Prolog negation is defined by means of meta-programming facilities and the cut operator, this requires a careful reexamination of the assumptions about the underlying syntax and a precise definition of the computational processes involved. After taking care of these matters we establish a formal result showing an equivalence in appropriate sense between these two uses of negation. This result allows us to argue about correctness of various known Prolog programs which use negation by reasoning about the corresponding general logic programs.", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Using transformations to verify parallel programs\n", "abstract": " We argue that the verification of parallel programs can be considerably simplified by using program transformations. We illustrate this approach by proving correctness of two parallel programs under the assumption of fairness: asynchronous fixed point computation and parallel zero search.", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Arithmetic classification of perfect models of stratified programs (Extended version)\n", "abstract": " Arithmetic classification of perfect models of stratified programs (Extended version) (1989) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication Arithmetic classification of perfect models of stratified programs (Extended version) (1989) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Arithmetic classification of perfect models of stratified programs (Extended version) Series Department of Computer Science [CS] Author KR Apt (Krzysztof); HA Blair Date issued 1989-01-01 Access Closed Access Language English Type Other Publisher CWI Publication https://ir.cwi.nl/pub/5851 Persistent Identifier urn:NBN:nl:ui:18-5851 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> \u2026", "num_citations": "3\n", "authors": ["1740"]}
{"title": "Strategy elimination in games with interaction structures\n", "abstract": " We study games in the presence of an interaction structure, which allows players to communicate their preferences, assuming that each player initially only knows his own preferences. We study the outcomes of iterated elimination of strictly dominated strategies (IESDS) that can be obtained in any given state of communication.               We also give epistemic foundations for these \u201cintermediate\u201d IESDS outcomes. This involves firstly describing the knowledge that the players would have in any state of communication, using the framework from Apt et al. [3]. We then prove that when there is common knowledge of rationality, each intermediate outcome is entailed by the knowledge in the relevant state of communication.", "num_citations": "2\n", "authors": ["1740"]}
{"title": "Epistemic analysis of strategic games with arbitrary strategy sets\n", "abstract": " We provide here an epistemic analysis of arbitrary strategic games based on the possibility correspondences. Such an analysis calls for the use of transfinite iterations of the corresponding operators. Our approach is based on Tarski's Fixpoint Theorem and applies both to the notions of rationalizability and the iterated elimination of strictly dominated strategies.", "num_citations": "2\n", "authors": ["1740"]}
{"title": "A generic approach to coalition formation\n", "abstract": " A Generic Approach to Coalition Formation University of Amsterdam University of Amsterdam UvA Terms of use Contact UvA-DARE (Digital Academic Repository) Home Advanced Search Browse My selection Search UvA-DARE Author SA Witzel KR Apt Year 2006 Title A Generic Approach to Coalition Formation Book/source title Proceedings of the 1st International Workshop on Computational Social Choice (COMSOC-2006) Publisher Amsterdam: ILLC Document type Conference contribution Faculty Interfacultary Research Institutes Institute Institute for Logic, Language and Computation (ILLC) Language Undefined/Unknown Permalink https://hdl.handle.net/11245/1.267894 Disclaimer/Complaints regulations If you believe that digital publication of certain material infringes any of your rights or (privacy) interests, please let the Library know, stating your reasons. In case of a legitimate complaint, the Library will make \u2026", "num_citations": "2\n", "authors": ["1740"]}
{"title": "A logical analysis of Boolean constraints'\n", "abstract": " In Apt (1998) we provided a proof theoretic account of constraint programming. Here we show how it can be used to analyse Boolean constraints. More precisely, We show here how a Boolean constraint solver based on the look-ahead search strategy can be defined in a purely logical way. To this end we characterize arc consistency for Boolean constraints by proof theoretic means. As a byproduct we clarify the status of the proof rules introduced in Codognet & Diaz (1996) that form a basis of their Boolean constraint solver. These considerations lead to a simple Boolean constraint solver that generates all solutions to a given set of Boolean constraints. It performs well on various benchmarks.", "num_citations": "2\n", "authors": ["1740"]}
{"title": "Logic Programming\n", "abstract": " 4. Computability. 5. Negative information 6. General goals. 7. Stratified programs 8. Related topics Appendix. Note", "num_citations": "2\n", "authors": ["1740"]}
{"title": "Semantics of the infinitistic rules of proof\n", "abstract": " This paper is devoted to the study of the infinitistic rules of proof i.e. those which admit an infinite number of premises. The best known of these rules is the \u03c9-rule. Some properties of the \u03c9-rule and its connection with the \u03c9-models on the basis of the \u03c9-completeness theorem gave impulse to the development of the theory of models for admissible fragments of the language . On the other hand the study of representability in second order arithmetic with the \u03c9-rule added revealed for the first time an analogy between the notions of re-cursivity and hyperarithmeticity which had an important influence on the further development of generalized recursion theory.The consideration of the subject of infinitistic rules in complete generality seems to be reasonable for several reasons. It is not completely clear which properties of the \u03c9-rule were essential for the development of the above-mentioned topics. It is also worthwhile to\u00a0\u2026", "num_citations": "2\n", "authors": ["1740"]}
{"title": "Assessing the Success and Impact of Hoare\u2019s Logic\n", "abstract": " In this chapter we retrace the main steps in the development of Hoare\u2019s logic and try to answer the question of what made it a successful approach to program ver ification. To understand the success of Hoare\u2019s logic, it is useful to reflect on the earlier approaches to program verification. As early as 1949, twenty years before Hoare\u2019s seminal article [Hoare 1969], Alan M. Turing discussed the correctness proof of an example program for the", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Coordination Games on Weighted Directed Graphs\n", "abstract": " We study strategic games on weighted directed graphs, where each player\u2019s payoff is defined as the sum of the weights on the edges from players who chose the same strategy, augmented by a fixed nonnegative integer bonus for picking a given strategy. These games capture the idea of coordination in the absence of globally common strategies. We identify natural classes of graphs for which finite improvement or coalition-improvement paths of polynomial length always exist, and consequently a (pure) Nash equilibrium or a strong equilibrium can be found in polynomial time. The considered classes of graphs are typical in network topologies: simple cycles correspond to the token ring local area networks, whereas open chains of simple cycles correspond to multiple independent rings topology from the recommendation G.8032v2 on Ethernet ring protection switching. For simple cycles, these results are optimal in\u00a0\u2026", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Well-Founded Extensive Games with Perfect Information\n", "abstract": " We consider extensive games with perfect information with well-founded game trees and study the problems of existence and of characterization of the sets of subgame perfect equilibria in these games. We also provide such characterizations for two classes of these games in which subgame perfect equilibria exist: two-player zero-sum games with, respectively, two and three outcomes.", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Reasoning about call-by-value: a missing result in the history of Hoare's logic\n", "abstract": " We provide a sound and relatively complete Hoare-like proof system for reasoning about partial correctness of recursive procedures in presence of local variables and the call-by-value parameter mechanism, and in which the correctness proofs are linear in the length of the program. We argue that in spite of the fact that Hoare-like proof systems for recursive procedures were intensively studied, no such proof system has been proposed in the literature.", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Logicomix: An Epic Search for Truth by Apostolos Doxiadis, Christos H. Papadimitriou, Alecos Papadatos, Annie di Donna\n", "abstract": " Logicomix: An Epic Search for Truth by Apostolos Doxiadis, Christos H. Papadimitriou, Alecos Papadatos, Annie di Donna \u00d7 Close The Infona portal uses cookies, ie strings of text saved by a browser on the user's device. The portal can access those files and use them to remember the user's data, such as their chosen settings (screen view, interface language, etc.), or their login data. By using the Infona portal the user accepts automatic saving and using this information for portal operation purposes. More information on the subject can be found in the Privacy Policy and Terms of Service. By closing this window the user confirms that they have read the information on cookie usage, and they accept the privacy policy and the way cookies are used by the portal. You can change the cookie settings in your browser. I accept Polski English Login or register account remember me Password recovery INFONA - science \u2026", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Post your articles in ArXiv: Math and CoRR!\n", "abstract": " Post your articles in ArXiv:Math and CoRR! University of Amsterdam University of Amsterdam UvA Terms of use Contact UvA-DARE (Digital Academic Repository) Home Advanced Search Browse My selection Search UvA-DARE Author KR Apt Year 2007 Title Post your articles in ArXiv:Math and CoRR! Journal Nieuw Archief voor Wiskunde Volume | Issue number 5/9 | 2 Pages (from-to) 98-99 Document type Article Faculty Interfacultary Research Institutes Institute Institute for Logic, Language and Computation (ILLC) Language Undefined/Unknown Permalink https://hdl.handle.net/11245/1.276077 Disclaimer/Complaints regulations If you believe that digital publication of certain material infringes any of your rights or (privacy) interests, please let the Library know, stating your reasons. In case of a legitimate complaint, the Library will make the material inaccessible and/or remove it from the website. Please Ask the \u2026", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Schedulers and redundancy for a class of constraint propagation rules\n", "abstract": " We study here schedulers for a class of rules that naturally arise in the context of rule-based constraint programming. We systematically derive a scheduler for them from a generic iteration algorithm of Apt (2000). We apply this study to so-called membership rules of Apt and Monfroy (2001). This leads to an implementation that yields a considerably better performance for these rules than their execution as standard CHR rules. Finally, we show how redundant rules can be identified and how appropriately reduced sets of rules can be computed.", "num_citations": "1\n", "authors": ["1740"]}
{"title": "A new constraint-based framework for qualitative reasoning\n", "abstract": " We introduce a constraint-based framework for studying various aspects of qualitative reasoning concerned with contingencies such as time, space, shape, size, abstracted into a finite set of qualitative relations. In this framework, in contrast to the customary approach, the qualitative relations are modelled as variables. We show how this approach allows us to treat in a natural way aspect integration, planning and qualitative simulation. The appropriate inter-state constraints are formulated using linear temporal logic. We implemented this approach in the constraint programming system ECLi PSe by drawing on the ideas from bounded model checking. To illustrate the simplicity of this approach we discuss various examples of planning and qualitative simulation, including a qualitative version of the piano movers problem and a simulation of juggling. In each of them the solutions were successfully found by our implementation. The resulting system allows us to test and modify the problem specifications in a straightforward way.", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Review of\" Programming with constraints: an introduction\" by Marriott, K. and Stuckey, PJ\n", "abstract": " Review of \"Programming with constraints: an introduction\" by... (1999) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication Review of \"Programming with constraints: an introduction\" by... (1999) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title Review of \"Programming with constraints: an introduction\" by Marriott, K. and Stuckey, PJ Published in Artificial Intelligence in Medicine, 16, 315 - 319. ISSN 0933-3657. Author KR Apt (Krzysztof) Supporting host Networks and Optimization Date issued 1999-01-01 Access Open Access Language English Type Article Publisher Elsevier Publication https://ir.cwi.nl/pub/10574 Persistent Identifier urn:NBN:nl:ui:18-10574 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@\u2026", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Deterministic programs\n", "abstract": " In a deterministic program there is at most one instruction to be executed \u201cnext,\u201d so that from a given initial state only one execution sequence is generated. In classical programming languages like Pascal, only deterministic programs can be written. In this chapter we study a small class of deterministic programs, which are included in all other classes of programs studied in this book.", "num_citations": "1\n", "authors": ["1740"]}
{"title": "A Natural Term Language\n", "abstract": " In 1989 Cor Baayen was the prime mover behind the decision to start long-term work on the logic of natural language at CWI. Work in this area had found an occasional refuge at the centre before, witness Janssen 13], but the seed of a full scale research group inLogic and Language'was sown in the Autumn of 1989. Right now, ve years later, the group consists of ve researchers (six if we count a distinguished longtime guest), all but one supported by external funds. Fortunately for the rest of CWI we anticipate that this rate of growth will not be sustained in the future.The main focus of current CWI research inLogic and Language'is on connections between programming language semantics and natural language semantics and on the design and analysis of suitable representation languages for natural language meaning. The connection with programming is explained by the fact that natural language representation should account for incrementality of processing, ie, for the fact that we tend to understand each natural language utterance in the context of our understanding of what we have heard before. The semantics of a natural language text T consisting of T1 followed by T2 will specify that T1 sets up a context which is passed on as input to T2, and that the meaning of T can be described as an increment of the meaning of T1. This has a straightforward parallel in the analysis of computation: the semantics of a computer program P consisting of two parts P1 and P2, in that order, will specify that the result of the computation to which P1 refers is passed on as input to P2, and that the output of P2 for this input is the nal output of P. The paper starts with\u00a0\u2026", "num_citations": "1\n", "authors": ["1740"]}
{"title": "A New World Underneath Standard Logic: Cylindric Algebra, Modality and Quantification\n", "abstract": " A New World Underneath Standard Logic: Cylindric Algebra,... (1994) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication A New World Underneath Standard Logic: Cylindric Algebra,... (1994) Open access . Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title A New World Underneath Standard Logic: Cylindric Algebra, Modality and Quantification Author JFAK van Benthem (Johan) Editor KR Apt (Krzysztof); A. Schrijver (Lex); NM Temme (Nico) Supporting host Logic and language Date issued 1994-12-01 Access Open Access Language English Type Book Part Publisher Stichting Mathematisch Centrum Publication https://ir.cwi.nl/pub/13473 ISBN 978-90-6196-450-6 Persistent Identifier urn:NBN:nl:ui:18-13473 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van \u2026", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Proving correctness of concurrent programs: A quick introduction\n", "abstract": " A systematic presentation of Hoare type approach to proving correctness of concurrent programs is provided Various proof systems for oondeterministic programs, disjoint parallel programs., parallel programs with shared variables and synchronization constructs are studied. Special emphasis is put on the issue of f aimess.", "num_citations": "1\n", "authors": ["1740"]}
{"title": "The temporal logic of programs\n", "abstract": " The temporal logic of programs (1983) | www.narcis.nl KNAW KNAW Narcis Back to search results CWI Publication The temporal logic of programs (1983) Pagina-navigatie: Main Save publication Save as MODS Export to Mendeley Save as EndNote Export to RefWorks Title The temporal logic of programs Author KR Apt (Krzysztof) Date issued 1983-01-01 Access Closed Access Language English Type Article Publisher -- Publication https://ir.cwi.nl/pub/10591 OpenURL Search this publication in (your) library Persistent Identifier urn:NBN:nl:ui:18-10591 Metadata XML Source CWI Go to Website Navigation: Home about narcis login Nederlands contact Anna van Saksenlaan 51 2593 HW Den Haag narcis@dans.knaw.nl More >>> Youtube Newsletter >>> Privacy statement >>> Disclaimer >>> DANS is an institute of KNAW and NWO Driven by data Go to page top Go back to contents Go back to site navigation \u2026", "num_citations": "1\n", "authors": ["1740"]}
{"title": "Recursive embeddings of partial orderings\n", "abstract": " Let be a countable atomless Boolean algebra and let X be a countable partial ordering. We prove that there exists an embedding of X into which is recursive in X, and which destroys all suprema and infima of X which can be destroyed. We show that the above theorem is false when we try to preserve all suprema and infima of X instead of destroying them.", "num_citations": "1\n", "authors": ["1740"]}