{"title": "A spatial logic for querying graphs\n", "abstract": " We study a spatial logic for reasoning about labelled directed graphs, and the application of this logic to provide a query language for analysing and manipulating such graphs. We give a graph description using constructs from process algebra. We introduce a spatial logic in order to reason locally about disjoint subgraphs. We extend our logic to provide a query language which preserves the multiset semantics of our graph model. Our approach contrasts with the more traditional set-based semantics found in query languages such as TQL, Strudel and GraphLog.", "num_citations": "146\n", "authors": ["1753"]}
{"title": "Towards a program logic for JavaScript\n", "abstract": " JavaScript has become the most widely used language for client-side web programming. The dynamic nature of JavaScript makes understanding its code notoriously difficult, leading to buggy programs and a lack of adequate static-analysis tools. We believe that logical reasoning has much to offer JavaScript: a simple description of program behaviour, a clear understanding of module boundaries, and the ability to verify security contracts. We introduce a program logic for reasoning about a broad subset of JavaScript, including challenging features such as prototype inheritance and\" with\". We adapt ideas from separation logic to provide tractable reasoning about JavaScript code: reasoning about easy programs is easy; reasoning about hard programs is possible. We prove a strong soundness result. All libraries written in our subset and proved correct with respect to their specifications will be well-behaved, even\u00a0\u2026", "num_citations": "129\n", "authors": ["1753"]}
{"title": "TaDA: A logic for time and data abstraction\n", "abstract": " To avoid data races, concurrent operations should either be at distinct times or on distinct data. Atomicity is the abstraction that an operation takes effect at a single, discrete instant in time, with linearisability being a well-known correctness condition which asserts that concurrent operations appear to behave atomically. Disjointness is the abstraction that operations act on distinct data resource, with concurrent separation logics enabling reasoning about threads that appear to operate independently on disjoint resources.               We present TaDA, a program logic that combines the benefits of abstract atomicity and abstract disjointness. Our key contribution is the introduction of atomic triples, which offer an expressive approach to specifying program modules. By building up examples, we show that TaDA supports elegant modular reasoning in a way that was not previously possible.", "num_citations": "126\n", "authors": ["1753"]}
{"title": "A trusted mechanised JavaScript specification\n", "abstract": " JavaScript is the most widely used web language for client-side applications. Whilst the development of JavaScript was initially just led by implementation, there is now increasing momentum behind the ECMA standardisation process. The time is ripe for a formal, mechanised specification of JavaScript, to clarify ambiguities in the ECMA standards, to serve as a trusted reference for high-level language compilation and JavaScript implementations, and to provide a platform for high-assurance proofs of language properties. We present JSCert, a formalisation of the current ECMA standard in the Coq proof assistant, and JSRef, a reference interpreter for JavaScript extracted from Coq to OCaml. We give a Coq proof that JSRef is correct with respect to JSCert and assess JSRef using test262, the ECMA conformance test suite. Our methodology ensures that JSCert is a comparatively accurate formulation of the English\u00a0\u2026", "num_citations": "125\n", "authors": ["1753"]}
{"title": "Context logic and tree update\n", "abstract": " Spatial logics have been used to describe properties of tree-like structures (Ambient Logic) and in a Hoare style to reason about dynamic updates of heap-like structures (Separation Logic). We integrat this work by analyzing dynamic updates to tree-like structures with pointers (such as XML with identifiers and idrefs). Na\u00edve adaptations of the Ambient Logic are not expressive enough to capture such local updates. Instead we must explicitly reason about arbitrary tree contexts in order to capture updates throughout the tree. We introduce Context Logic, study its proof theory and models, and show how it generalizes Separation Logic and its general theory BI. We use it to reason locally about a small imperative programming language for updating trees, using a Hoare logic in the style of O'Hearn, Reynolds and Yang, and show that weakest preconditions are derivable. We demonstrate the robustness of our approach\u00a0\u2026", "num_citations": "117\n", "authors": ["1753"]}
{"title": "Unfold/fold transformations of logic programs\n", "abstract": " Unfold/fold transformations of logic programs \u2014 University of Bristol Skip to main navigation Skip to search Skip to main content University of Bristol Logo Help & Terms of Use Home Profiles Research Units Research Outputs Projects Student theses Datasets Activities Prizes Facilities/Equipment Search by expertise, name or affiliation Unfold/fold transformations of logic programs PA Gardner, JC Shepherdson School of Mathematics Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter in a book Overview Translated title of the contribution Unfold/fold transformations of logic programs Original language English Title of host publication Essays in honour of Alan Robinson Editors JL Lassez, G Plotkin Publisher Massachusetts Institute of Technology (MIT) Press Pages 542 - 564 Number of pages 22 ISBN (Print) 026212156 Publication status Published - 1991 Cite this APA Author BIBTEX Harvard \u2026", "num_citations": "95\n", "authors": ["1753"]}
{"title": "Explicit fusions\n", "abstract": " We introduce explicit fusions of names. To \u2018fuse\u2019 two names is to declare that they may be used interchangeably. An explicit fusion is one that can exist in parallel with some other process, allowing us to ask for instance how a process might behave in a context where x = y.We present the \u03c0F -calculus, a simple process calculus with explicit fusions. It is similar in many respects to the fusion calculus but has a simple local reaction relation. We give embeddings of the \u03c0-calculus and the fusion calculus.We provide a bisimulation congruence for the \u03c0F-calculus and compare it with hyper-equivalence in the fusion calculus.", "num_citations": "80\n", "authors": ["1753"]}
{"title": "Discovering needed reductions using type theory\n", "abstract": " The identification of the needed redexes in a term is an undecidable problem. We introduce a (partially decidable) type assignment system, which distinguishes certain redexes called the allowable redexes. For a well-typed term e, allowable redexes are needed redexes. In addition, with principal typing, all the needed redexes of a normalisable term are allowable. Using these results, we are able to identify all the needed reductions of a principally typed normalisable term. Possible applications of these results include strictness and sharing analysis for functional programming languages, and a reduction strategy for well-typed terms which satisfies L\u00e9vy's notion of optimal reduction.", "num_citations": "79\n", "authors": ["1753"]}
{"title": "From separation logic to first-order logic\n", "abstract": " Separation logic is a spatial logic for reasoning locally about heap structures. A decidable fragment of its assertion language was presented in\u00a0[1], based on a bounded model property. We exploit this property to give an encoding of this fragment into a first-order logic containing only the propositional connectives, quantification over the natural numbers and equality. This result is the first translation from Separation Logic into a logic which does not depend on the heap, and provides a direct decision procedure based on well-studied algorithms for first-order logic. Moreover, our translation is compositional in the structure of formulae, whilst previous results involved enumerating either heaps or formulae arising from the bounded model property.", "num_citations": "71\n", "authors": ["1753"]}
{"title": "Context logic as modal logic: completeness and parametric inexpressivity\n", "abstract": " Separation Logic, Ambient Logic and Context Logic are based on a similar style of reasoning about structured data. They each consist of a structural (separating) composition for reasoning about disjoint subdata, and corresponding structural adjoint(s) for reasoning hypothetically about data. We show how to interpret these structural connectives as modalities in Modal Logic and prove completeness results. The structural connectives are essential for describing properties of the underlying data, such as weakest preconditions for Hoare reasoning for Separation and Context Logic, and security properties for Ambient Logic. In fact, we introduced Context Logic to reason about tree update, precisely because the structural connectives of the Ambient Logic did not have enough expressive power. Despite these connectives being essential, first Lozes then Dawar, Gardner and Ghelli proved elimination results for\u00a0\u2026", "num_citations": "65\n", "authors": ["1753"]}
{"title": "Processes in space\n", "abstract": " We introduce a geometric process algebra based on affine geometry, with the aim of describing the concurrent evolution of geometric structures in 3D space. We prove a relativity theorem stating that algebraic equations are invariant under rigid body transformations.", "num_citations": "64\n", "authors": ["1753"]}
{"title": "Manipulating trees with hidden labels\n", "abstract": " We define an operational semantics and a type system for manipulating semistructured data that contains hidden information. The data model is simple labeled trees with a hiding operator. Data manipulation is based on patternmatching, with types that track the use of hidden labels.", "num_citations": "64\n", "authors": ["1753"]}
{"title": "Local Hoare reasoning about DOM\n", "abstract": " The W3C Document Object Model (DOM) specifies an XML update library. DOM is written in English, and is therefore not compositional and not complete. We provide a first step towards a compositional specification of DOM. Unlike DOM, we are able to work with a minimal set of commands and obtain a complete reasoning for straight-line code. Our work transfers O'Hearn, Reynolds and Yang's local Hoare reasoning for analysing heaps to XML, viewing XML as an in-place memory store as does DOM. In particular, we apply recent work by Calcagno, Gardner and Zarfaty on local Hoare reasoning about simple tree update to this real-world DOM application. Our reasoning not only formally specifies a significant subset of DOM Core Level 1, but can also be used to verify, for example, invariant properties of simple Javascript programs.", "num_citations": "61\n", "authors": ["1753"]}
{"title": "Modelling dynamic web data\n", "abstract": " We introduce the X d \u03c0 calculus, a peer-to-peer model for reasoning about dynamic web data. Web data is not just stored statically. Rather it is referenced indirectly, for example using hyperlinks, service calls, or scripts for dynamically accessing data, which require the complex coordination of data and processes between sites. The X d \u03c0 calculus models this coordination by integrating the XML data structure with process orchestration techniques associated with the distributed pi-calculus. We study behavioural equivalences for X d \u03c0, to analyze the various possible patterns of data and process interaction.", "num_citations": "58\n", "authors": ["1753"]}
{"title": "Expressiveness and complexity of graph logic\n", "abstract": " We investigate the complexity and expressive power of a spatial logic for reasoning about graphs. This logic was previously introduced by Cardelli, Gardner and Ghelli, and provides the simplest setting in which to explore such results for spatial logics. We study several forms of the logic: the logic with and without recursion, and with either an exponential or a linear version of the basic composition operator. We study the combined complexity and the expressive power of the four combinations. We prove that, without recursion, the linear and exponential versions of the logic correspond to significant fragments of first-order (FO) and monadic second-order (MSO) Logics; the two versions are actually equivalent to FO and MSO on graphs representing strings. However, when the two versions are enriched with \u03bc-style recursion, their expressive power is sharply increased.Both are able to express PSPACE-complete\u00a0\u2026", "num_citations": "56\n", "authors": ["1753"]}
{"title": "Representing logics in type theory\n", "abstract": " Computer Science today has many examples of logics given by proof systems. Although one intuitively knows how to use these systems and recognise correct derivations, there is no definitive account which captures this intuition. It is therefore natural to seek a framework for representing logics, which unifies the structure common to all logical systems. We introduce such a framework, called ELF and based on the Edinburgh Logical Framework (ELF). The major advantage of ELF is that it allows us to give precise definitions of representation. Such definitions are not possible with ELF since information is lost during encoding; the adequacy theorems of ELF representations are only applicable to particular encodings and cannot be generalised. We rectify this deficiency using the extra distinctions between terms provided by the universes of a pure type system which yields a simple presentation of the type theory of ELF. To do this, we extend these type systems to include signatures and/3ij-equivalence.Using the ideas underlying representation in ELF+, we give a standard presentation of the logics under consideration, based on Martin-L\u00f6f's notion of judgements and Aczel's work on Frege structures. This presentation forms a reference point from which to investigate representations in ELF; it is not itself a framework since we do not specify a logic using a finite amount of information. Logics which do not fit this pattern are particularly interesting as they are more difficult, if not impossible, to encode.", "num_citations": "55\n", "authors": ["1753"]}
{"title": "Automatic parallelization with separation logic\n", "abstract": " Separation logic is a recent approach to the analysis of pointer programs in which resource separation is expressed with a logical connective in assertions that describe the state at any given point in the program. We extend this approach to express properties of memory separation between different points in the program, and present an algorithm for determining independences between program statements which can be used for parallelization.", "num_citations": "51\n", "authors": ["1753"]}
{"title": "Explicit fusions\n", "abstract": " We introduce explicit fusions of names. An explicit fusion is a process that exists concurrently with the rest of the system and enables two names to be used interchangeably. Explicit fusions provide a small-step account of reaction in process calculi such as the pi calculus and the fusion calculus. In this respect they are similar to the explicit substitutions of Abadi, Cardelli and Curien, which do the same for the lambda calculus. In this paper, we give a technical foundation for explicit fusions. We present the pi-F calculus, a simple process calculus with explicit fusions, and define a strong bisimulation congruence. We study the embeddings of the fusion calculus and the pi calculus. The former is fully abstract with respect to bisimulation.", "num_citations": "51\n", "authors": ["1753"]}
{"title": "Local reasoning for the POSIX file system\n", "abstract": " We provide a program logic for specifying a core subset of the sequential POSIX file system, and for reasoning abstractly about client programs working with the file system.", "num_citations": "41\n", "authors": ["1753"]}
{"title": "Colosl: Concurrent local subjective logic\n", "abstract": " A key difficulty in verifying shared-memory concurrent programs is reasoning compositionally about each thread in isolation. Existing verification techniques for fine-grained concurrency typically require reasoning about either the entire shared state or disjoint parts of the shared state, impeding compositionality. This paper introduces the program logic CoLoSL, where each thread is verified with respect to its subjective view of the global shared state. This subjective view describes only that part of the state accessed by the thread. Subjective views may arbitrarily overlap with each other, and expand and contract depending on the resource required by the thread. This flexibility gives rise to small specifications and, hence, more compositional reasoning for concurrent programs. We demonstrate our reasoning on a range of examples, including a concurrent computation of a spanning tree of a graph.", "num_citations": "38\n", "authors": ["1753"]}
{"title": "A process model of actin polymerisation\n", "abstract": " Actin is the monomeric subunit of actin filaments which form one of the three major cytoskeletal networks in eukaryotic cells. Actin dynamics, be it the polymerisation of actin monomers into filaments or the reverse process, plays a key role in many cellular activities such as cell motility and phagocytosis. There is a growing number of experimental, theoretical and mathematical studies on the components of actin polymerisation and depolymerisation. However, it remains a challenge to develop compositional models of actin dynamics, e.g., by using differential equations. In this paper, we propose compositional process algebra models of actin polymerisation, and present a geometric representation of these models that allows to generate movies reflecting their dynamics.", "num_citations": "37\n", "authors": ["1753"]}
{"title": "The fusion machine\n", "abstract": " We present a new model for the distributed implementation of pi-like calculi, which permits strong correctness results that are simple to prove. We describe the distributed channel machine\u2014 a distributed version of a machine proposed by Cardelli. The distributed channel machine groups pi processes at their channels (or locations), in contrast with the more common approach of incorporating additional location information within pi processes. We go on to describe the fusion machine. It uses a form of concurrent constraints called fusions\u2014 equations on channel names\u2014 to distribute fragments of these processes between remote channels. This fragmentation avoids the movement of large continuations between locations, and leads to a more efficient implementation model.", "num_citations": "34\n", "authors": ["1753"]}
{"title": "From action calculi to linear logic\n", "abstract": " Milner introduced action calculi as a framework for investigating models of interactive behaviour. We present a type-theoretic account of action calculi using the propositions-as-types paradigm; the type theory has a sound and complete interpretation in Power's categorical models. We go on to give a sound translation of our type theory in the (type theory of) intuitionistic linear logic, corresponding to the relation between Benton's models of linear logic and models of action calculi. The conservativity of the syntactic translation is proved by a model-embedding construction using the Yoneda lemma. Finally, we briefly discuss how these techniques can also be used to give conservative translations between various extensions of action calculi.", "num_citations": "34\n", "authors": ["1753"]}
{"title": "JaVerT: JavaScript verification toolchain\n", "abstract": " The dynamic nature of JavaScript and its complex semantics make it a difficult target for logic-based verification. We introduce JaVerT, a semi-automatic JavaScript Verification Toolchain, based on separation logic and aimed at the specialist developer wanting rich, mechanically verified specifications of critical JavaScript code. To specify JavaScript programs, we design abstractions that capture its key heap structures (for example, prototype chains and function closures), allowing the developer to write clear and succinct specifications with minimal knowledge of the JavaScript internals. To verify JavaScript programs, we develop JaVerT, a verification pipeline consisting of: JS-2-JSIL, a well-tested compiler from JavaScript to JSIL, an intermediate goto language capturing the fundamental dynamic features of JavaScript; JSIL Verify, a semi-automatic verification tool based on a sound JSIL separation logic; and verified\u00a0\u2026", "num_citations": "32\n", "authors": ["1753"]}
{"title": "Modular termination verification for non-blocking concurrency\n", "abstract": " We present Total-TaDA, a program logic for verifying the total correctness of concurrent programs: that such programs both terminate and produce the correct result. With Total-TaDA, we can specify constraints on a thread\u2019s concurrent environment that are necessary to guarantee termination. This allows us to verify total correctness for non-blocking algorithms, e.g. a counter and a stack. Our specifications can express lock- and wait-freedom. More generally, they can express that one operation cannot impede the progress of another, a new non-blocking property we call non-impedance. Moreover, our approach is modular. We can verify the operations of a module independently, and build up modules on top of each other.", "num_citations": "32\n", "authors": ["1753"]}
{"title": "DOM: Towards a Formal Specification.\n", "abstract": " The W3C Document Object Model (DOM) specifies an XML update library. DOM is written in English, and is therefore not compositional and not complete. We provide a first step towards a compositional specification of DOM. Unlike DOM, we are able to work with a minimal set of commands and obtain a complete reasoning for straight-line code. Our work transfers O\u2019Hearn, Reynolds and Yang\u2019s local Hoare reasoning for analysing heaps to XML, viewing XML as an in-place memory store as does DOM. In particular, we apply recent work by Calcagno, Gardner and Zarfaty on local Hoare reasoning about a simple tree-update language to DOM, showing that our reasoning scales to DOM. Our reasoning not only formally specifies a significant subset of DOM Core Level 1, but can also be used to verify eg invariant properties of simple Javascript programs.", "num_citations": "32\n", "authors": ["1753"]}
{"title": "A process model of Rho GTP-binding proteins\n", "abstract": " Rho GTP-binding proteins play a key role as molecular switches in many cellular activities. In response to extracellular stimuli and with the help of regulators (GEF, GAP, Effector, GDI), these proteins serve as switches that interact with their environment in a complex manner. Based on the structure of a published ordinary differential equations (ODE) model, we first present a generic process model for the Rho GTP-binding proteins, and compare it with the ODE model. We then extend the basic model to include the behaviour of the GDI regulators and explore the parameter space for the extended model with respect to biological data from the literature. We discuss the challenges this extension brings and the directions of further research. In particular, we present techniques for modular representation and refinement of process models, where, for example, different Rho proteins with different rates for regulator\u00a0\u2026", "num_citations": "30\n", "authors": ["1753"]}
{"title": "Abstraction and refinement for local reasoning\n", "abstract": " Local reasoning has become a well-established technique in program verification, which has been shown to be useful at many different levels of abstraction. In separation logic, we use a low-level abstraction that is close to how the machine sees the program state. In context logic, we work with high-level abstractions that are close to how the clients of modules see the program state.We apply program refinement to local reasoning, demonstrating that high-level local reasoning is sound for module implementations.We consider two approaches: one that preserves the high-level locality at the low level; and one that breaks the high-level \u2019fiction\u2019 of locality.", "num_citations": "28\n", "authors": ["1753"]}
{"title": "Adjunct elimination through games in static ambient logic\n", "abstract": " Spatial logics are used to reason locally about disjoint data structures. They consist of standard first-order logic constructs, spatial (structural) connectives and their corresponding adjuncts. Lozes has shown that the adjuncts add no expressive power to a spatial logic for analysing tree structures, a surprising and important result. He also showed that a related logic does not have this adjunct elimination property. His proofs yield little information on the generality of adjunct elimination. We present a new proof of these results based on model-comparison games, and strengthen Lozes\u2019 results. Our proof is directed by the intuition that adjuncts can be eliminated when the corresponding moves are not useful in winning the game. The proof is modular with respect to the operators of the logic, providing a general technique for determining which combinations of operators admit adjunct elimination.", "num_citations": "28\n", "authors": ["1753"]}
{"title": "A simple abstraction for complex concurrent indexes\n", "abstract": " Indexes are ubiquitous. Examples include associative arrays, dictionaries, maps and hashes used in applications such as databases, file systems and dynamic languages. Abstractly, a sequential index can be viewed as a partial function from keys to values. Values can be queried by their keys, and the index can be mutated by adding or removing mappings. Whilst appealingly simple, this abstract specification is insufficient for reasoning about indexes accessed concurrently. We present an abstract specification for concurrent indexes. We verify several representative concurrent client applications using our specification, demonstrating that clients can reason abstractly without having to consider specific underlying implementations. Our specification would, however, mean nothing if it were not satisfied by standard implementations of concurrent indexes. We verify that our specification is satisfied by algorithms based\u00a0\u2026", "num_citations": "27\n", "authors": ["1753"]}
{"title": "Footprints in local reasoning\n", "abstract": " Local reasoning about programs exploits the natural local behaviour common in programs by focussing on the footprint - that part of the resource accessed by the program. We address the problem of formally characterising and analysing the footprint notion for abstract local functions introduced by Calcagno, O\u2019Hearn and Yang. With our definition, we prove that the footprints are the only essential elements required for a complete specification of a local function. We also show that, for well-founded models (which is usually the case in practice), a smallest specification always exists that only includes the footprints, thus formalising the notion of small axioms in local reasoning. We also present results for the non-well-founded case, and introduce the natural class of one-step local functions for which the footprints are the smallest safe states.", "num_citations": "27\n", "authors": ["1753"]}
{"title": "Linear forwarders\n", "abstract": " A linear forwarder is a process which receives one message on a channel and sends it on a different channel. Such a process allows for a simple implementation of the asynchronous pi calculus, by means of a direct encoding of the pi calculus\u2019 input capability (that is, where a received name is used as the subject of subsequent input). This encoding is fully abstract with respect to barbed congruence.               Linear forwarders are actually the basic mechanism of an earlier implementation of the pi calculus called the fusion machine. We modify the fusion machine, replacing fusions by forwarders. The result is more robust in the presence of failures, and more fundamental.", "num_citations": "24\n", "authors": ["1753"]}
{"title": "From process calculi to process frameworks\n", "abstract": " We present two process frameworks: the action calculi of Milner, and the fusion systems of Gardner and Wischik. The action calculus framework is based on process constructs arising from the \u03c0-calculus. We give a non-standard presentation of the \u03c0-calculus, to emphasise the similarities between the calculus and the framework. The fusion system framework generalises a new process calculus called the \u03c0F                         -calculus. We describe the \u03c0F-calculus, which is based on different process constructs to those of the \u03c0-calculus, and show that the generalisation from the calculus to the framework is simple. We compare the frameworks by studying examples.", "num_citations": "24\n", "authors": ["1753"]}
{"title": "Closed action calculi\n", "abstract": " Action calculi provide a framework for capturing many kinds of interactive behaviour by focussing on the primitive notion of names. We introduce a name-free account of action calculi, called the closed action calculi, and show that there is a strong correspondence between the original presentation and the name-free presentation. We also add free names plus natural axioms to the closed world, and show that the abstraction operator can be constructed as a derived operator. Our results show that in some sense names are inessential. However, the purpose of action calculi is to understand formalisms which mimic the behaviour of interactive systems. Perhaps more significantly therefore, these results highlight the important presentational role that names play.", "num_citations": "21\n", "authors": ["1753"]}
{"title": "Fault-tolerant resource reasoning\n", "abstract": " Separation logic has been successful at verifying that programs do not crash due to illegal use of resources. The underlying assumption, however, is that machines do not fail. In practice, machines can fail unpredictably for various reasons, e.g. power loss, corrupting resources. Critical software, e.g. file systems, employ recovery methods to mitigate these effects. We introduce an extension of the Views framework to reason about such methods. We use concurrent separation logic as an instance of the framework to illustrate our reasoning, and explore programs using write-ahead logging, e.g. an ARIES recovery algorithm.", "num_citations": "20\n", "authors": ["1753"]}
{"title": "Reasoning about the POSIX file system: local update and global pathnames\n", "abstract": " We introduce a program logic for specifying a core sequential subset of the POSIX file system and for reasoning abstractly about client programs working with the file system. The challenge is to reason about the combination of local directory update and global pathname traversal (including'..'and symbolic links) which may overlap the directories being updated. Existing reasoning techniques are either based on first-order logic and do not scale, or on separation logic and can only handle linear pathnames (no'..'or symbolic links). We introduce fusion logic for reasoning about local update and global pathname traversal, introducing a novel effect frame rule to propagate the effect of a local update on overlapping pathnames. We apply our reasoning to the standard recursive remove utility (rm-r), discovering bugs in well-known implementations.", "num_citations": "18\n", "authors": ["1753"]}
{"title": "A name-free account of action calculi\n", "abstract": " Action calculi provide a unifying framework for representing a variety of models of communication, such as CCS, Petri nets and the \u03c0-calculus, within a unified setting. A central idea is to model the interaction between actions using names. We introduce a name-free account of action calculi, called the closed action calculi, and show that there is a strong correspondence between the original presentation and the name-free presentation. These results show that, although names play an important presentational role, they are in some sense inessential.", "num_citations": "18\n", "authors": ["1753"]}
{"title": "A new type theory for representing logics\n", "abstract": " We propose a new type theory for representing logics, called LF+ and based on the Edinburgh Logical Framework. The new framework allows us to give, apparently for the first time, general definitions which capture how well a logic has been represented. Using our definitions, we show that, for example, first-order logic can be wellrepresented in LF+, whereas linear and relevant logics cannot. These syntactic definitions of representation have a simple formulation as indexed isomorphisms, which both confirms that our approach is a natural one, and provides a link between type-theoretic and categorical approaches to frameworks.", "num_citations": "18\n", "authors": ["1753"]}
{"title": "JaVerT 2.0: Compositional symbolic execution for JavaScript\n", "abstract": " We propose a novel, unified approach to the development of compositional symbolic execution tools, bridging the gap between classical symbolic execution and compositional program reasoning based on separation logic. Using this approach, we build JaVerT 2.0, a symbolic analysis tool for JavaScript that follows the language semantics without simplifications. JaVerT 2.0 supports whole-program symbolic testing, verification, and, for the first time, automatic compositional testing based on bi-abduction. The meta-theory underpinning JaVerT 2.0 is developed modularly, streamlining the proofs and informing the implementation. Our explicit treatment of symbolic execution errors allows us to give meaningful feedback to the developer during whole-program symbolic testing and guides the inference of resource of the bi-abductive execution. We evaluate the performance of JaVerT 2.0 on a number of JavaScript data\u00a0\u2026", "num_citations": "17\n", "authors": ["1753"]}
{"title": "Skeletal semantics and their interpretations\n", "abstract": " The development of mechanised language specification based on structured operational semantics, with applications to verified compilers and sound program analysis, requires huge effort. General theory and frameworks have been proposed to help with this effort. However, none of this work provides a systematic way of developing concrete and abstract semantics, connected together by a general consistency result. We introduce a skeletal semantics of a language, where each skeleton describes the complete semantic behaviour of a language construct. We define a general notion of interpretation, which provides a systematic and language-independent way of deriving semantic judgements from the skeletal semantics. We explore four generic interpretations: a simple well-formedness interpretation; a concrete interpretation; an abstract interpretation; and a constraint generator for flow-sensitive analysis. We\u00a0\u2026", "num_citations": "16\n", "authors": ["1753"]}
{"title": "Steps in modular specifications for concurrent modules (invited tutorial paper)\n", "abstract": " The specification of a concurrent program module is a difficult problem. The specifications must be strong enough to enable reasoning about the intended clients without reference to the underlying module implementation. We survey a range of verification techniques for specifying concurrent modules, in particular highlighting four key concepts: auxiliary state, interference abstraction, resource ownership and atomicity. We show how these concepts combine to provide powerful approaches to specifying concurrent modules.", "num_citations": "15\n", "authors": ["1753"]}
{"title": "Strong bisimulation for the explicit fusion calculus\n", "abstract": " The pi calculus holds the promise of compile-time checks for whether a given program will have the correct interactive behaviour. The theory behind such checks is bisimulation. In the synchronous pi calculus, it is well-known that the various natural definitions of (strong) bisimulation yield different relations. In contrast, for the asynchronous pi calculus, they collapse to a single relation. We show that the definitions transfer naturally from the pi calculus to the explicit fusion calculus (a symmetric variant of the synchronous pi calculus), where they also collapse, and yield a simpler theory.               The important property of explicit fusions is that an explicit fusion in parallel with a term allows fused names to be substituted for each other. This means that parallel contexts become as discriminating as arbitrary contexts, and that open bisimilarity is more natural for the explicit fusion calculus than it was for the pi calculus\u00a0\u2026", "num_citations": "15\n", "authors": ["1753"]}
{"title": "Equivalences between logics and their representing type theories\n", "abstract": " We propose a new framework for representing logics, called LF+, which is based on the Edinburgh Logical Framework. The new framework allows us to give, apparently for the first time, general definitions that capture how well a logic has been represented. These definitions are possible because we are able to distinguish in a generic way that part of the LF+ entailment corresponding to the underlying logic. This distinction does not seem to be possible with other frameworks. Using our definitions, we show that, for example, natural deduction first-order logic can be well-represented in LF+, whereas linear and relevant logics cannot. We also show that our syntactic definitions of representation have a simple formulation as indexed isomorphisms, which both confirms that our approach is a natural one and provides a link between type-theoretic and categorical approaches to frameworks.", "num_citations": "15\n", "authors": ["1753"]}
{"title": "Linear forwarders\n", "abstract": " A linear forwarder is a process that receives one message on a channel and sends it on a different channel. We use linear forwarders to provide a distributed implementation of Milner\u2019s asynchronous pi calculus. Such a distributed implementation is known to be difficult due to input capability, where a received name is used as the subject of a subsequent input. This allows the dynamic creation of large input processes in the wrong place, thus requiring comparatively large code migrations in order to avoid consensus problems. Linear forwarders constitute a small atom of input capability that is easy to move.We show that the full input capability can be simply encoded using linear forwarders. We also design a distributed machine, demonstrating the ease with which we can implement the pi calculus using linear forwarders. We also show that linear forwarders allow for a simple encoding of distributed choice and have\u00a0\u2026", "num_citations": "14\n", "authors": ["1753"]}
{"title": "Small specifications for tree update\n", "abstract": " O\u2019Hearn, Reynolds and Yang introduced Separation Logic to provide modular reasoning about simple, mutable data structures in memory. They were able to construct small specifications of programs, by reasoning about the local parts of memory accessed by programs. Gardner, Calcagno and Zarfaty generalised this work, introducing Context Logic to reason about more complex data structures. In particular, they developed a formal, compositional specification of the Document Object Model, a W3C XML update library. Whilst keeping to the spirit of local reasoning, they were not able to retain small specifications. We introduce Segment\u00a0Logic, which provides a more fine-grained analysis of the tree structure and yields small specifications. As well as being aesthetically pleasing, small specifications are important for reasoning about concurrent tree update.", "num_citations": "13\n", "authors": ["1753"]}
{"title": "A concurrent specification of POSIX file systems\n", "abstract": " POSIX is a standard for operating systems, with a substantial part devoted to specifying file-system operations. File-system operations exhibit complex concurrent behaviour, comprising multiple actions affecting different parts of the state: typically, multiple atomic reads followed by an atomic update. However, the standard's description of concurrent behaviour is unsatisfactory: it is fragmented; contains ambiguities; and is generally under-specified. We provide a formal concurrent specification of POSIX file systems and demonstrate scalable reasoning for clients. Our specification is based on a concurrent specification language, which uses a modern concurrent separation logic for reasoning about abstract atomic operations, and an associated refinement calculus. Our reasoning about clients highlights an important difference between reasoning about modules built over a heap, where the interference on the shared state is restricted to the operations of the module, and modules built over a file system, where the interference cannot be restricted as the file system is a public namespace. We introduce specifications conditional on context invariants used to restrict the interference, and apply our reasoning to the example of lock files.", "num_citations": "12\n", "authors": ["1753"]}
{"title": "DOM: specification and client reasoning\n", "abstract": " We present an axiomatic specification of a key fragment of DOM using structural separation logic. This specification allows us to develop modular reasoning about client programs that call the DOM.", "num_citations": "12\n", "authors": ["1753"]}
{"title": "Verifying concurrent graph algorithms\n", "abstract": " We show how to verify four challenging concurrent fine-grained graph-manipulating algorithms, including graph copy, a speculatively parallel Dijkstra, graph marking and spanning tree. We develop a reasoning method for such algorithms that dynamically tracks the contributions and responsibilities of each thread operating on a graph, even in cases of arbitrary recursive thread creation. We demonstrate how to use a logic without abstraction () to carry out abstract reasoning in the style of iCAP, by building the abstraction into the proof structure rather than incorporating it into the semantic model of the logic.", "num_citations": "12\n", "authors": ["1753"]}
{"title": "Adjunct elimination in context logic for trees\n", "abstract": " We study adjunct-elimination results for Context Logic applied to trees, following previous results by Lozes for Separation Logic and Ambient Logic. In fact, it is not possible to prove such elimination results for the original single-holed formulation of Context Logic. Instead, we prove our results for multi-holed Context Logic.", "num_citations": "12\n", "authors": ["1753"]}
{"title": "Gillian, part i: a multi-language platform for symbolic execution\n", "abstract": " We introduce Gillian, a platform for developing symbolic analysis tools for programming languages. Here, we focus on the symbolic execution engine at the heart of Gillian, which is parametric on the memory model of the target language. We give a formal description of the symbolic analysis and a modular implementation that closely follows this description. We prove a parametric soundness result, introducing restriction on abstract states, which generalises path conditions used in classical symbolic execution. We instantiate to obtain trusted symbolic testing tools for JavaScript and C, and use these tools to find bugs in real-world code, thus demonstrating the viability of our parametric approach.", "num_citations": "11\n", "authors": ["1753"]}
{"title": "TaDA Live: Compositional reasoning for termination of fine-grained concurrent programs\n", "abstract": " We introduce TaDA Live, a separation logic for reasoning compositionally about the termination of blocking fine-grained concurrent programs. The logic contributes several innovations to obtain modular rely/guarantee style reasoning for liveness properties and to blend them with logical atomicity. We illustrate the subtlety of our specifications and reasoning on some paradigmatic examples.", "num_citations": "11\n", "authors": ["1753"]}
{"title": "The Definitive Guide to Pylons\n", "abstract": " Spurred by the enormous popularity of Ruby on Rails, web frameworks have revolutionized the way developers of all programming languages tackle the often complex task of web application development. Some of the most exciting activity in this area can be seen in the Python community, one of the wildly popular frameworks to enter the fray being Pylons (http://www. PylonsHQ. com). Co-founder and lead developer James Gardner brings you a comprehensive introduction to Pylons, the web framework that uses the best of Ruby, Python, and Perl and the emerging WSGI standard to provide structure and flexibility. With expert guidance from the author, you\u2019ll learn how to create your own Pylons\u2013driven web site using SQLAlchemy and FormEncode and attain the mastery of advanced Pylons features, such as internationalization and localization, packaging and deployment.", "num_citations": "11\n", "authors": ["1753"]}
{"title": "Local reasoning about data update\n", "abstract": " We present local Hoare reasoning about data update, introducing Context Logic for analysing structured data. We apply our reasoning to tree update, heap update, and term rewriting. Our reasoning about heap update is exactly analogous to the local Hoare reasoning of Separation Logic. Our reasoning about tree update and term rewriting can only be done with Context Logic.", "num_citations": "11\n", "authors": ["1753"]}
{"title": "Behavioural equivalences for dynamic Web data\n", "abstract": " We study behavioural equivalences for dynamic web data in X                 d\u03c0, a model for reasoning about behaviour found in (for example)dynamic web page programming, applet interaction, and web-service orchestration. X                 d\u03c0 is based on an idealised model of semistructured data, and an extension of the \u03c0-calculus with locations and operations for interacting with data.The equivalences are non-standard due to the integration of data and processes, and the presence of locations.", "num_citations": "11\n", "authors": ["1753"]}
{"title": "Querying trees with pointers\n", "abstract": " We introduce a data model for semi-structured data and explore a spatial logic for reasoning about this model. This note is part of an on-going project to develop a pattern-matching language for analysing and manipulating semi-structured data. This work was first reported in Appsem 2001 and the session on spatial logic at MFPS 2002.", "num_citations": "11\n", "authors": ["1753"]}
{"title": "Types and models for higher-order action calculi\n", "abstract": " Milner introduced action calculi as a framework for representing models of interactive behaviour. He also introduced the higher-order action calculi, which add higher-order features to the basic setting. We present type theories for action calculi and higher-order action calculi, and give the categorical models of the higher-order calculi. As applications, we give a semantic proof of the conservativity of higher-order action calculi over action calculi, and a precise connection with Moggi's computational lambda calculus and notions of computation.", "num_citations": "11\n", "authors": ["1753"]}
{"title": "A process model of rho gtp-binding proteins in the context of phagocytosis\n", "abstract": " At the early stages of the phagocytic signalling, Rho GTP-binding proteins play a key role. With the stimulus from the cell membrane and with the help from the regulators (GEF, GAP, Effector, GDI), these proteins serve as switches that interact with their environment in a complex manner. We present a generic process model for the Rho GTP-binding proteins, and compare it with a previous model that uses ordinary differential equations. We then extend the basic model to include the behaviour of the GDIs. We discuss the challenges this extension brings and directions of further research.", "num_citations": "9\n", "authors": ["1753"]}
{"title": "A perspective on specifying and verifying concurrent modules\n", "abstract": " The specification of a concurrent program module, and the verification of implementations and clients with respect to such a specification, are difficult problems. A specification should be general enough that any reasonable implementation satisfies it, yet precise enough that it can be used by any reasonable client. We survey a range of techniques for specifying concurrent modules, using the example of a counter module to illustrate the benefits and limitations of each. In particular, we highlight four key concepts underpinning these techniques: auxiliary state, interference abstraction, resource ownership and atomicity. We demonstrate how these concepts can be combined to achieve two powerful approaches for specifying concurrent modules and verifying implementations and clients, which remove the limitations highlighted by the counter example.", "num_citations": "8\n", "authors": ["1753"]}
{"title": "JuS: Squeezing the sense out of JavaScript programs\n", "abstract": " We introduce JuS (JavaScript under Scrutiny), a first step towards a static-analysis tool for JavaScript based on a program logic in the style of separation logic. In particular, we focus on reasoning automatically about the JavaScript variable store. Because of prototype-based inheritance and with statements, even reasoning about variables is not trivial in JavaScript. We evaluate our tool on examples from the Firefox test suite which illustrate the scoping mechanism of the JavaScript variable store.", "num_citations": "8\n", "authors": ["1753"]}
{"title": "Concur 2004--Concurrency Theory: 15th International Conference, London, UK, August 31-September 3, 2004, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 15th International Conference on Concurrency Theory, CONCUR 2004, held in London, UK in August/September 2004. The 29 revised full papers presented together with 4 invited papers were carefully reviewed and selected from 134 submissions. Among the topics covered are concurrency related aspects of models of computation, semantic domains, process algebras, Petri nets, event structures, real-time systems, hybrid systems, decidability, model checking, verification techniques, refinement, term and graph rewriting, distributed programming, constraint logic programming, object-oriented programming, typing systems and algorithms, case studies, tools, and environments for programming and verification.", "num_citations": "8\n", "authors": ["1753"]}
{"title": "Abstract Specifications for Concurrent Maps\n", "abstract": " Despite recent advances in reasoning about concurrent data structure libraries, the largest implementations in java.util.concurrent have yet to be verified. The key issue lies in the development of modular specifications, which provide clear logical boundaries between clients and implementations. A solution is to use recent advances in fine-grained concurrency reasoning, in particular the introduction of abstract atomicity to concurrent separation logic reasoning. We present two specifications of concurrent maps, both providing the clear boundaries we seek. We show that these specifications are equivalent, in that they can be built from each other. We show how we can verify client programs, such as a concurrent set and a producer-consumer client. We also give a substantial first proof that the main operations of ConcurrentSkipListMap in java.util.concurrent satisfy the map specification. This work\u00a0\u2026", "num_citations": "6\n", "authors": ["1753"]}
{"title": "An introduction to context logic\n", "abstract": " This paper provides a gentle introduction to Context Logic. It contains work previously published with Calcagno [1,2], and is based on Gardner\u2019s notes for her course on Local Reasoning about Data Update at the Appsem PhD summer school [3] and Zarfaty\u2019s thesis [4].", "num_citations": "6\n", "authors": ["1753"]}
{"title": "Local reasoning about tree update\n", "abstract": " Separation Logic and Context Logic have been used to reason locally about heap update and simple tree update. We study local reasoning based on Context Logic for a more realistic, local tree-update language which combines update commands with queries. This combination results in updates at multiple locations, which significantly affects the complexity of the reasoning.", "num_citations": "6\n", "authors": ["1753"]}
{"title": "A program logic for first-order encapsulated webassembly\n", "abstract": " We introduce Wasm Logic, a sound program logic for first-order, encapsulated WebAssembly. We design a novel assertion syntax, tailored to WebAssembly's stack-based semantics and the strong guarantees given by WebAssembly's type system, and show how to adapt the standard separation logic triple and proof rules in a principled way to capture WebAssembly's uncommon structured control flow. Using Wasm Logic, we specify and verify a simple WebAssembly B-tree library, giving abstract specifications independent of the underlying implementation. We mechanise Wasm Logic and its soundness proof in full in Isabelle/HOL. As part of the soundness proof, we formalise and fully mechanise a novel, big-step semantics of WebAssembly, which we prove equivalent, up to transitive closure, to the original WebAssembly small-step semantics. Wasm Logic is the first program logic for WebAssembly, and represents a first step towards the creation of static analysis tools for WebAssembly.", "num_citations": "5\n", "authors": ["1753"]}
{"title": "Towards logic-based verification of javascript programs\n", "abstract": " In this position paper, we argue for what we believe is a correct pathway to achieving scalable symbolic verification of JavaScript based on separation logic. We highlight the difficulties imposed by the language, the current state-of-the-art in the literature, and the sequence of steps that needs to be taken. We briefly describe, our semi-automatic toolchain for JavaScript verification.", "num_citations": "5\n", "authors": ["1753"]}
{"title": "Symmetric action calculi\n", "abstract": " Many calculi for describing interactive behaviour involve names, nameabstraction and name-restriction. Milner\u2019s reflexive action calculi provide a framework for exploring such calculi. It is based on names and nameabstraction. We introduce an alternative framework, the symmetric action calculi, based on names, co-names and name-restriction (or hiding). Name-abstraction is intepreted as a derived operator. The symmetric framework conservatively extends the reflexive framework. It allows for a natural intepretation of a variety of calculi: we give interpretations for the \u03c0-calculus, the \u03c0I-calculus and a variant of the fusion calculus. We then give a combinatory version of the symmetric framework, in which name-restriction also is expressed as a derived operator. This combinatory account provides an intermediate step between our non-standard use of names in graphs, and the more standard graphical structure arising from category theory. To conclude, we briefly illustrate the connection between our work and Yoshida\u2019s process graphs.", "num_citations": "5\n", "authors": ["1753"]}
{"title": "Abstract local reasoning for concurrent libraries: mind the gap\n", "abstract": " We study abstract local reasoning for concurrent libraries. There are two main approaches: provide a specification of a library by abstracting from concrete reasoning about an implementation; or provide a direct abstract library specification, justified by refining to an implementation. Both approaches have a significant gap in their reasoning, due to a mismatch between the abstract connectivity of the abstract data structures and the concrete connectivity of the concrete heap representations. We demonstrate this gap using structural separation logic (SSL) for specifying a concurrent tree library and concurrent abstract predicates (CAP) for reasoning about a concrete tree implementation. The gap between the abstract and concrete connectivity emerges as a mismatch between the SSL tree predicates and CAP heap predicates. This gap is closed by an interface function I which links the abstract and concrete connectivity\u00a0\u2026", "num_citations": "4\n", "authors": ["1753"]}
{"title": "Reasoning about high-level tree update and its low-level implementation\n", "abstract": " We relate Context Logic reasoning about a high-level tree update language with Separation Logic reasoning about a low-level implementation.", "num_citations": "4\n", "authors": ["1753"]}
{"title": "Behavioural equivalences for dynamic Web data\n", "abstract": " Peer-to-peer systems provide a simple and effective platform for data integration on the Internet, exchanging dynamic documents using Web services. Dynamic documents contain both data and references to external sources in the form of links, calls to Web services, or coordination scripts. XML standards and industrial platforms for Web services provide a technological basis for building such systems. Process algebras provide a formal framework for studying and understanding their formal properties. We have previously introduced X d \u03c0, a calculus for reasoning about dynamic Web data. It consists of locations, containing dynamic documents and \u03c0-like processes which communicate with each other, query and update these documents, and migrate to other peers to continue execution. Here, we study network equivalences for X d \u03c0 and Core X d \u03c0, a reformulation of X d \u03c0 which embeds the location structure in the\u00a0\u2026", "num_citations": "4\n", "authors": ["1753"]}
{"title": "A Trusted Infrastructure for Symbolic Analysis of Event-Driven Web Applications\n", "abstract": " We introduce a trusted infrastructure for the symbolic analysis of modern event-driven Web applications. This infrastructure consists of reference implementations of the DOM Core Level 1, DOM UI Events, JavaScript Promises and the JavaScript async/await APIs, all underpinned by a simple Core Event Semantics which is sufficiently expressive to describe the event models underlying these APIs. Our reference implementations are trustworthy in that three follow the appropriate standards line-by-line and all are thoroughly tested against the official test-suites, passing all the applicable tests. Using the Core Event Semantics and the reference implementations, we develop JaVerT. Click, a symbolic execution tool for JavaScript that, for the first time, supports reasoning about JavaScript programs that use multiple event-related APIs. We demonstrate the viability of JaVerT. Click by proving both the presence and absence of bugs in real-world JavaScript code.", "num_citations": "2\n", "authors": ["1753"]}
{"title": "A Trusted Mechanised Specification of JavaScript: One Year On\n", "abstract": " The JSCert project provides a Coq mechanised specification of the core JavaScript language. A key part of the project was to develop a methodology for establishing trust, by designing JSCert in such a way as to provide a strong connection with the JavaScript standard, and by developing JSRef, a reference interpreter which was proved correct with respect to JSCert and tested using the standard Test262 test suite. In this paper, we assess the previous state of the project at POPL\u201914 and the current state of the project at CAV\u201915. We evaluate the work of POPL\u201914, providing an analysis of the methodology as a whole and a more detailed analysis of the tests. We also describe recent work on extending JSRef to include Google\u2019s V8 Array library, enabling us to cover more of the language and to pass more tests.", "num_citations": "2\n", "authors": ["1753"]}
{"title": "Abstract Local Reasoning for Concurrent Libraries\n", "abstract": " We study abstract local reasoning for concurrent libraries. There are two main approaches: provide a specification of a library by abstracting from concrete reasoning about an implementation; or provide a direct abstract library specification, justified by refining to an implementation. Both approaches have a significant gap in their reasoning, due to a mismatch between the abstract connectivity of the abstract data structures and the concrete connectivity of the concrete heap representations. We demonstrate this gap using structural separation logic (SSL) for specifying a concurrent tree library and concurrent abstract predicates (CAP) for reasoning about a concrete tree implementation. The gap between the abstract and concrete connectivity emerges as a mismatch between the SSL tree predicates and CAP heap predicates. This gap is closed by an interface function I which links the abstract and concrete connectivity\u00a0\u2026", "num_citations": "2\n", "authors": ["1753"]}
{"title": "Programming Languages and Systems: 22nd European Symposium on Programming, ESOP 2013, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS\u00a0\u2026\n", "abstract": " This book constitutes the refereed proceedings of the 22nd European Symposium on Programming, ESOP 2013, held as part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2013, which took place in Rome, Italy, in March 2013. The 31 papers, presented together with a full-length invited talk, were carefully reviewed and selected from 120 full submissions. The contributions have been organized according to ten topical sections on programming techniques; programming tools; separation logic; gradual typing; shared-memory concurrency and verification; process calculi; taming concurrency; model checking and verification; weak-memory concurrency and verification; and types, inference, and analysis.", "num_citations": "2\n", "authors": ["1753"]}
{"title": "Local reasoning about mashups\n", "abstract": " Web mashups are complex programs that dynamically compose data and code from many sources. Whereas data is sometimes formally specified by XML schema, code never is. This makes it difficult to construct reliable software. Using local Hoare reasoning, introduced in separation logic to reason about eg C programs and extended in context logic to reason about eg the DOM library, we are able to reason about mashup programs, proving that they are fault-free and providing specifications for code that are analogous to XML schema for data.", "num_citations": "2\n", "authors": ["1753"]}
{"title": "Locality refinement\n", "abstract": " We study refinement in the setting of local reasoning. In particular, we explore general translations that preserve and that break locality.", "num_citations": "2\n", "authors": ["1753"]}
{"title": "Adjunct elimination through games\n", "abstract": " Spatial logics are used to reason locally about disjoint data structures. They consist of standard first-order logic constructs, spatial (structural) connectives and their corresponding adjuncts. Lozes has shown that the adjuncts add no expressive power to a spatial logic for analysing tree structures, a surprising and important result. He also showed that a related logic does not have this adjunct elimination property. His proofs yield little information on the generality of adjunct elimination. We present a new proof of these results based on modelcomparison games, and strengthen Lozes\u2019 results. Our proof is directed by the intuition that adjuncts can be eliminated when the corresponding moves are not useful in winning the game. The proof is modular with respect to the operators of the logic, providing a general technique for determining which combinations of operators admit adjunct elimination.", "num_citations": "2\n", "authors": ["1753"]}
{"title": "September 1994\n", "abstract": " BEFORE THE ARKANSAS PUBLIC SERVICE COMMISSION IN THE MATTER OF AN INVESTIGATION ) OF OVERALL GAS PURCHASING PRACTICES ) OF ARKLA Page 1 BEFORE THE ARKANSAS PUBLIC SERVICE COMMISSION IN THE MATTER OF AN INVESTIGATION ) OF OVERALL GAS PURCHASING PRACTICES ) OF ARKLA, INC., AND ITS VARIOUS ) DOCKET NO. -036-U SUSIDIARY COMPANIES INCLUDING, BUT ) - . LL c?.! NOT LIMITED TO, THE ARKLA-ARKOMA 1 TRANSACTIONS 1 STAFF RESPONSE TO ARKLA'S APPLICATION FOR REHEARING ON THE COMMISSION'S ORDER NO. For the reasons stated in Staff's Response to Petition for Re-hearing, filed August 31, 1990, and for the reasons stated by the Commission in its Order No. 26, Arkla's Application for Rehearing of Order No. 21 should be denied. =EREFORE, Staff prays that Arkla's Application for Rehearing on the Commission's \u2026", "num_citations": "2\n", "authors": ["1753"]}
{"title": "Gillian: Compositional Symbolic Execution for All\n", "abstract": " We present Gillian, a language-independent framework for the development of compositional symbolic analysis tools. Gillian supports three flavours of analysis: whole-program symbolic testing, full verification, and bi-abduction. It comes with fully parametric meta-theoretical results and a modular implementation, designed to minimise the instantiation effort required of the user. We evaluate Gillian by instantiating it to JavaScript and C, and perform its analyses on a set of data-structure libraries, obtaining results that indicate that Gillian is robust enough to reason about real-world programming languages.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "Gillian, Part II: Real-World Verification for JavaScript and C\n", "abstract": " We introduce verification based on separation logic to Gillian, a multi-language platform for the development of symbolic analysis tools which is parametric on the memory model of the target language. Our work develops a methodology for constructing compositional memory models for Gillian, leading to a unified presentation of the JavaScript and C memory models. We verify the JavaScript and C implementations of the AWS Encryption SDK message header deserialisation module, specifically designing common abstractions used for both verification tasks, and find two bugs in the JavaScript and three bugs in the C implementation.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "Data Consistency in Transactional Storage Systems: a Centralised Approach\n", "abstract": " We introduce an interleaving operational semantics for describing the client-observable behaviour of atomic transactions on distributed key-value stores. Our semantics builds on abstract states comprising centralised, global key-value stores and partial client views. We provide operational definitions of consistency models for our key-value stores which are shown to be equivalent to the well-known declarative definitions of consistency model for execution graphs. We explore two immediate applications of our semantics: specific protocols of geo-replicated databases (e.g. COPS) and partitioned databases (e.g. Clock-SI) can be shown to be correct for a specific consistency model by embedding them in our centralised semantics; programs can be directly shown to have invariant properties such as robustness results against a weak consistency model.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "Views: Compositional reasoning for concurrent programs (draft extended version)\n", "abstract": " We present a framework for reasoning compositionally about concurrent programs. At its core is the notion of a view: an abstraction of the state that takes account of the possible interference due to other threads. Threads\u2019 views are composable, and an update to the state by one thread must preserve the views of other threads. We prove soundness for our framework, and demonstrate its utility by studying examples. In particular, we show that several variants of concurrent separation logic, type systems, and concurrent abstract predicates can all be seen as instantiations of our framework. Soundness for particular instantiations simply follows from the soundness of our framework.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "Decidability of context logic\n", "abstract": " We consider the problem of decidability for Context Logic for sequences, ranked trees and unranked trees. We show how to translate quantifier-free formulae into finite automata that accept just the sequences or trees which satisfy the formulae. Satisfiability is thereby reduced to the language emptiness problem for finite automata, which is simply a question of reachability. This reduction shows that Context Logic formulae define languages that are regular; indeed, we show that for sequences they are exactly the star-free regular languages. We also show that satisfiability is still decidable when quantification over context hole labels is added to the logic, by reducing the problem to the quantifier-free case.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "A Note on Context Logic DRAFT\n", "abstract": " This note describes joint work with Cristiano Calcagno and Uri Zarfaty. It introduces the general theory of Context Logic, and has been written for the Appsem Summer School 2005. It should be read in conjunction with Reynold\u2019s paper on Separation Logic: A Logic for shared Mutable data Structures, and our paper on Context Logic and Tree Update. We acknowledge support from EPSRC.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "Ubiquitous Data\n", "abstract": " Distributed database technology has long recognised that it is often expedient to move process to data rather than data to process, and this is also part of the rationale for the Grid. With current technology, a distributed process or query involves only a small number of sites. However the trend is towards increasingly distributed data; and when our queries require data from thousands or millions of sites, ubiquitous computing and ubiquitous data will become one and the same.Background. The topic of databases emerged from the interplay of two requirements. The first was to have a simple abstraction for structured data; the second was to make the manipulation of large quantities of this data both robust and efficient. The relational model was invented for the first of these. It proposed a simple tabular data model and an algebra of operations on tables. What is remarkable about this algebra is that it also met second requirement, in that its equational theory served as a basis for query optimisation and queries could be efficiently implemented through query rewriting, indexing and join techniques. This accounted for the success of relational databases; the details are described in any good database textbook.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "Calculi for Interactive Systems: Theory and Experiment\n", "abstract": " The objectives of the project were, briefly:(1) To study and design a foundational calculus and prototype programming language, based on the \u03c0-calculus, for describing and analysing migratory distributed systems;(2) To further develop the theory of action calculi, a graphical formalisation of interactive systems, to compare disciplines and study common concepts;(3) To test this framework upon existing and new calculi.The proposal was organised in two strands, specific and general, essentially (1) and (2) above. The work has proceeded in this manner, with continual exchange of ideas on topics shared between the strands, such as: the behavioural equivalence of processes; the interplay between connectivity (\u2018wiring\u2019, channels or naming) and locality (machine, scope of name, ambient) in modelling migratory systems; implementation of a calculus by an abstract machine; labelled transition systems; and many others. The next two sections of this report give details of the work done on the two main strands, named exactly as in the proposal.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "A tool for implementing action graphs\n", "abstract": " We describe a specification tool for action graphs, which allows the user to naturally switch between between the syntactic and graphical presentations. The implementation includes a general matching algorithm for identifying redexes in a graph, and for animating reductions.", "num_citations": "1\n", "authors": ["1753"]}
{"title": "Higher-Order and Reflexive Action Calculi: Their Type Theory and Models1\n", "abstract": " Action calculi have been introduced by Milner as a framework for representing models of interactive behaviour. Two natural extensions of action calculi have been proposed: the higher-order action calculi, which add higher-order features to the basic setting, and the reflexive action calculi, which allow circular bindings of processes and gives recursion in the presense of higher-order features.In this paper, we present simple type theories for action calculi, higher-order action calculi and reflexive action calculi. We also give the categorical models of the extensions, by enriching Power\u2019s models of action calculi. As applications, we give a semantic proof of the conservativity of higher-order action calculi over action calculi, and a precise connection with Moggi\u2019s computational lambda calculus and notions of computation. We also relate the models of higher-order reflexive action calculi to models of recursive computation, by following the observation that the trace operator of Joyal, Street and Verity can be used to model recursion.", "num_citations": "1\n", "authors": ["1753"]}