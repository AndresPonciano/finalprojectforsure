{"title": "Search-based refactoring for software maintenance\n", "abstract": " The high cost of software maintenance could be reduced by automatically improving the design of object-oriented programs without altering their behaviour. We have constructed a software tool capable of refactoring object-oriented programs to conform more closely to a given design quality model, by formulating the task as a search problem in the space of alternative designs. This novel approach is validated by two case studies, where programs are automatically refactored to increase flexibility, reusability and understandability as defined by a contemporary quality model. Both local and simulated annealing searches were found to be effective in this task.", "num_citations": "193\n", "authors": ["792"]}
{"title": "Search-based software maintenance\n", "abstract": " The high cost of software maintenance could potentially be greatly reduced by the automatic refactoring of object-oriented programs to increase their understandability, adaptability and extensibility. This paper describes a novel approach in providing automated refactoring support for software maintenance; the formulation of the task as a search problem in the space of alternative designs. Such a search is guided by a quality evaluation function that must accurately reflect refactoring goals. We have constructed a search-based software maintenance tool and report here the results of experimental refactoring of two Java programs, which yielded improvements in terms of the quality functions used. We also discuss the comparative merits of the three quality functions employed and the actual effect on program design that resulted from their use", "num_citations": "188\n", "authors": ["792"]}
{"title": "Search\u2010based refactoring: an empirical study\n", "abstract": " Object\u2010oriented systems that undergo repeated addition of functionality commonly suffer a loss of quality in their underlying design. This problem must often be remedied in a costly refactoring phase before further maintenance programming can take place. Recently search\u2010based approaches to automating the task of software refactoring, based on the concept of treating object\u2010oriented design as a combinatorial optimization problem, have been proposed. However, because search\u2010based refactoring is a novel approach it is yet to be established as to which search techniques are most suitable for the task. In this paper we report the results of an empirical comparison of simulated annealing (SA), genetic algorithms (GAs) and multiple ascent hill\u2010climbing (HCM) in search\u2010based refactoring. A prototype automated refactoring tool is employed, capable of making radical changes to the design of an existing program\u00a0\u2026", "num_citations": "165\n", "authors": ["792"]}
{"title": "Automated application of design patterns: a refactoring approach\n", "abstract": " Getting a design right first time is impossible. One of the major advances in software development thinking in the past decade has been the notion that the process of building a software system should be an evolutionary one [10, 81, 48, 3]. Rather than the classical waterfall model where analysis is fully completed before design, and design fully completed before implementation, evolutionary approaches are based on building a simple version of what is required and extending this iteratively to build a more complicated system. As John Gall put it:", "num_citations": "143\n", "authors": ["792"]}
{"title": "A methodology for the automated introduction of design patterns\n", "abstract": " In reengineering legacy code it is frequently useful to introduce a design pattern in order to add clarity to the system and thus facilitate further program evolution. We show that this type of transformation can be automated in a pragmatic manner and present a methodology for the development of design pattern transformations. We address the issues of the definition of a starting point for the transformation, the decomposition of a pattern into minipatterns and the development of corresponding minitransformations that can introduce these minipatterns to a program. We argue that behaviour preservation is a key issue and develop a rigorous argument of this for each minitransformation we discover. The architecture of an existing software prototype is also discussed and the results of applying this methodology to develop a transformation for the Factory Method pattern are presented.", "num_citations": "113\n", "authors": ["792"]}
{"title": "Rascal: A recommender agent for software components in an agile environment\n", "abstract": " As software organisations mature, their repository of reusable software components from previous projects will grow considerably. Remaining conversant with all components in such a repository presents a significant challenge to developers. Indeed the retrieval of a particular component in this large search space may prove problematic. We propose to infer the need for a component and proactively recommend that component to the developer using a technique which is consistent with the principles of Agile development. Our RASCAL recommender agent tracks usage histories of a group of users to recommend to an individual user components that are expected to be needed by that user. Unlike many traditional recommender systems we may recommend items which the developer has actually employed previously. We introduce a technique for ordering the set of recommended software components and present a comparative analysis of applying this technique to a number of Collaborative Filtering algorithms. We also investigate the relationship between the number of usage histories collected and recommendation accuracy. Our overall results indicate that RASCAL is a very promising tool for allowing developers discover reusable components at no additional cost.", "num_citations": "110\n", "authors": ["792"]}
{"title": "Automated software evolution towards design patterns\n", "abstract": " During the evolution of a software system, it may be necessary to refactor the software in order to make it more flexible and amenable to new requirements that are being introduced. A typical aim of such a refactoring is to apply a suitable design pattern to the program in order to enhance its flexibility. Performing such a transformation by hand is an error-prone process, so automated support would be useful. We have developed a methodology for the creation of automated transformations that can apply a design pattern to an existing program. In this paper we present a brief description of this methodology, and report on the results of using this methodology to develop program transformations that can apply the Gamma et al design patterns. It is found that in almost 75% of cases a satisfactory transformation is developed, and that much of the commonality between design patterns can be captured in reusable\u00a0\u2026", "num_citations": "64\n", "authors": ["792"]}
{"title": "Composite refactorings for Java programs\n", "abstract": " There has been much interest in refactoring recently, but little work has been done on tool support for refactoring or on demonstrating that a refactoring does indeed preserve program behaviour. We propose a method for developing composite refactorings for Java programs in such a way that a rigorous demonstration of behaviour preservation is possible.", "num_citations": "62\n", "authors": ["792"]}
{"title": "Securing Java through software watermarking.\n", "abstract": " \u042b\u0433 \u0438\u043b \u0436 \u0434 \u0436 \u043d \u0437 \u0431 \u0433\u0436 \u0433 \u0437\u0438 \u0430 \u0438\u0433 \u0438 \u043b \u0436 \u0439\u0437 \u0433 \u0422 \u043a\u2104 \u041a \u042c \u0430 \u0438\u043d \u0438\u0433 \u0434\u0436\u0433\u043a \u0433\u043b\u0432 \u0436\u0437 \u0434 \u0433 \u0434 \u0436 \u0438 \u0422 \u043a \u0434\u0436\u0433 \u0436 \u0431\u0437 \u043b\u0433\u0439\u0430 \u0437 \u0433\u0434\u043d\u0436 \u0438 \u0433\u0432 \u0436\u0432\u0437 \u0433\u043a \u0436 \u0422 \u043a \u0434\u0436\u0433 \u0436 \u0431\u0437\u041a \u042b\u0433 \u0438\u043b \u0436 \u043b \u0438 \u0436\u0431 \u0436 \u0432 \u0432\u0438 \u0430\u0437 \u0430\u0438 \u0436 \u0432 \u0434\u0436\u0433 \u0436 \u0431 \u0438\u0433 \u0432\u0419 \u0430\u0439 \u0433\u043b\u0432 \u0436\u0437 \u0434 \u0432 \u0433\u0436\u0431 \u0438 \u0433\u0432\u041a \u0421\u0432 \u0438 \u0437 \u0434 \u0434 \u0436 \u043b \u0437 \u0436 \u0439\u0436\u0419 \u0436 \u0432\u0438 \u0437\u0438 \u0438 \u0433 \u0438 \u0436\u0438 \u0432 \u0437\u0433 \u0438\u043b \u0436 \u043b \u0438 \u0436\u0431 \u0436 \u0432 \u0432 \u0433\u043b \u0437 \u0419 \u0432 \u0430 \u0438 \u0438 \u0433\u0432 \u0438 \u0433\u0436\u043d \u0432 \u0431\u0434\u0436\u0433\u043a \u0433\u0439\u0436 \u0432\u0433\u043b\u0430 \u0433 \u0437\u0433 \u0438\u043b \u0436 \u043b \u0438 \u0436\u0431 \u0436 \u0432 \u041a \u042f \u0434\u0436 \u0437 \u0432\u0438 \u043b \u0438 \u0436\u0431 \u0436 \u0432 \u0437 \u0431 \u0438 \u0438 \u0437 \u0437 \u0433\u0432 \u0437 \u0432 \u0430 \u0438 \u0438 \u0433\u0432 \u0438 \u0433\u0436\u043d\u041a", "num_citations": "57\n", "authors": ["792"]}
{"title": "Automated refactoring to introduce design patterns\n", "abstract": " Software systems have to be flexible in order to cope with evolving requirements. However, since it is impossible to predict with certainty what future requirements will emerge, it is also impossible to know exactly what flexibility to build into a system. Design patterns are often used to provide this flexibility, so this question frequently reduces to whether or not to apply a given design pattern. We address this problem by developing a methodology for the construction of automated transformations that introduce design patterns. This enables a programmer to safely postpone the application of a design pattern until the flexibility it provides becomes necessary. Our approach deals with the issues of reuse of existing transformations, preservation of program behaviour and the application of the transformations to existing program code.", "num_citations": "53\n", "authors": ["792"]}
{"title": "Towards automated design improvement through combinatorial optimisation\n", "abstract": " In this paper we present a novel approach to the problem of automated design improvement: by treating object-oriented design as a combinatorial optimisation of metrics, we have developed a prototype software engineering tool capable of improving a design with respect to a conflicting set of goals. As the prioritisation of different goals is determined by weights associated with each metric, we also describe here a method of assigning coherent weights to a set of metrics based on object-oriented design heuristics. The combinatorial optimisation approach to automated design improvement is illustrated here by means of a simple case study, which shows the effect of applying our prototype tool to a small inheritance hierarchy. Results indicate that a balance between metrics has been achieved, as several potentially conflicting design goals are accommodated.", "num_citations": "45\n", "authors": ["792"]}
{"title": "A stochastic approach to automated design improvement\n", "abstract": " The object-oriented approach to software development facilitates and encourages programming practices that increase reusability, correctness and maintainability in code. This is achieved in Java by providing mechanisms for inheritance, abstraction and encapsulation. By measuring properties that indicate to what extent these mechanisms are utilised we can determine to a large extent how good a design is. However, because these properties often conflict with other goals such as high cohesion and low coupling it can be difficult for a programmer to recognise the best compromise. We propose the novel approach of treating object-oriented design as a combinatorial optimisation problem, where the goal is maximisation of a set of design metrics. With a view to developing a fully automated design improvement tool we have developed a prototype that uses a small metrics suite combined with automated refactorings to move methods to their optimum positions in the class hierarchy. The action of this simulated annealing system produces a new design that is superior in terms of the metrics used and when judged on object-oriented principles.", "num_citations": "44\n", "authors": ["792"]}
{"title": "Getting the Most from Search-based Refactoring\n", "abstract": " Object-oriented systems that undergo repeated addition of functionality commonly suffer a loss of quality in their underlying design. This problem must often be remedied in a costly refactoring phase before further maintenance programming can take place. Recently search-based approaches to automating the task of softwarere factoring, based on the concept of treating object-oriented designas a combinatorial optimisation problem, have been proposed. However, because search-based refactoring is a novel approach it has yet to be established which search techniques are most suitable forthe task.", "num_citations": "38\n", "authors": ["792"]}
{"title": "Knowledge reuse for software reuse\n", "abstract": " Software reuse can provide significant improvements in software productivity and quality whilst reducing development costs. Expressing software reuse intentions can be difficult though. A developer may aspire to reuse a software component but experience difficulty expressing their reuse intentions in a manner that is compatible with, or understood by, the component retrieval system. Various intelligent retrieval techniques have been developed that assist a developer in locating or discovering components in an efficient manner. These solutions share a common shortcoming: the developer must be capable of anticipating all reuse opportunities and initiating the retrieval process. There is a need for a comprehensive technique that not only assists with retrievals but that can also identify reuse opportunities.", "num_citations": "36\n", "authors": ["792"]}
{"title": "Improving software security using search-based refactoring\n", "abstract": " Security metrics have been proposed to assess the security of software applications based on the principles of \u201creduce attack surface\u201d and \u201cgrant least privilege.\u201d While these metrics can help inform the developer in choosing designs that provide better security, they cannot on their own show exactly how to make an application more secure. Even if they could, the onerous task of updating the software to improve its security is left to the developer. In this paper we present an approach to automated improvement of software security based on search-based refactoring. We use the search-based refactoring platform, Code-Imp, to refactor the code in a fully-automated fashion. The fitness function used to guide the search is based on a number of software security metrics. The purpose is to improve the security of the software immediately prior to its release and deployment. To test the value of this approach we\u00a0\u2026", "num_citations": "29\n", "authors": ["792"]}
{"title": "A problem-based approach to teaching design patterns\n", "abstract": " The traditional lecture-based approach to course delivery is particularly inappropriate in teaching design patterns effectively. In this paper, we describe our efforts to develop a problem-based approach to the introduction of design patterns in the undergraduate curriculum. Our principal contribution is the development of a set of pattern exercises that enables students to experiment with patterns and to see clearly the advantages accrued by using patterns.", "num_citations": "21\n", "authors": ["792"]}
{"title": "Recommending library methods: An evaluation of the vector space model (VSM) and latent semantic indexing (LSI)\n", "abstract": " The development and maintenance of a reuse repository requires significant investment, planning and managerial support. To minimise risk and ensure a healthy return on investment, reusable components should be accessible, reliable and of a high quality. In this paper we concentrate on accessability; we describe a technique which enables a developer to effectively and conveniently make use of large scale libraries. Unlike most previous solutions to component retrieval, our tool, RASCAL, is a proactive component recommender.               RASCAL recommends a set of task-relevant reusable components to a developer. Recommendations are produced using Collaborative Filtering (CF). We compare and contrast CF effectiveness when using two information retrieval techniques, namely Vector Space Model (VSM) and Latent Semantic Indexing (LSI). We validate our technique on real world examples and\u00a0\u2026", "num_citations": "20\n", "authors": ["792"]}
{"title": "Program restructuring to introduce design patterns\n", "abstract": " In restructuring legacy code it may be useful to introduce a design pattern in order to add clarity to the system and thus facilitate further program evolution. We show that aspects of this transformation can be automated and present a nascent high-level language for describing transformations that introduce design patterns. The role of preconditions in preserving program behaviour during this process is also discussed. We conclude by considering the value of this approach in dealing with legacy code.", "num_citations": "17\n", "authors": ["792"]}
{"title": "A recommender agent for software libraries: An evaluation of memory-based and model-based collaborative filtering\n", "abstract": " Software agents can conveniently facilitate knowledge discovery and knowledge sharing across an organisation. We contend that programming tasks are often mimicked, that knowledge concerning reusable libraries can be extracted automatically from source code repositories, and that this knowledge can then be filtered and presented to a developer in a manner that will encourage and support future software reuse. We describe RASCAL, a recommender agent that continually recommends a set of task-relevant library methods to a developer. RASCAL learns information regarding how a particular reusable library is used and then employs this insight to make task-relevant recommendations to a developer. In this paper we detail our RASCAL agent and compare two recommendation techniques, namely memory-based and model-based collaborative filtering. We are interested in producing a scalable and efficient\u00a0\u2026", "num_citations": "15\n", "authors": ["792"]}
{"title": "Automated design improvement by example\n", "abstract": " The high cost of software maintenance could potentially be reduced by automatically improving the design of object-oriented programs without altering their behaviour. We have constructed a software tool capable of refactoring objectoriented programs to conform more closely to design quality models based on a set of metrics, by formulating the task as a search problem in the space of alternative designs. However, no consensus exists on a single quality model for object-oriented design, since the definition of \u2018quality\u2019can depend on the purpose, pedigree and perception of the maintenance programmer. We therefore demonstrate here the flexibility of our approach by automatically refactoring several Java programs to conform with quality models based on the metric values of example programs. Results show that an object-oriented program can be automatically refactored to reduce its dissimilarity in terms of a set of design metrics to another program having some desirable trait, such as ease of maintenance.", "num_citations": "14\n", "authors": ["792"]}
{"title": "A Case Study on Recommending Reusable Software Components using Collaborative Filtering\n", "abstract": " The demand for quality, highly functional software reinforces the need for reusable software components. However, as repositories of reusable components increase in size and complexity, the challenge for developers to remain conversant with all components becomes greater. This paper proposes a software recommendation system based on collaborative filtering, which has been shown to be effective in other domains. Based on the usage patterns of existing classes and the class currently being developed, our system proposes a set of reuse candidates to the programmer. We present the results of our analysis of the usage of Swing classes in several open-source applications and find that the collaborative filtering technique is promising in providing recommendations in this context.", "num_citations": "14\n", "authors": ["792"]}
{"title": "Experiences with software product line development in risk management software\n", "abstract": " Software Product Lines are intended to reduce time to market, improve quality and decrease costs. In this paper we examine the evolution of a single system to a Software Product Line, and evaluate if these benefits have occurred in this case. We describe in detail how this evolution took place and relate our experiences to those described in the current literature. Three tenets used by the company involved helped avoid some of the known pitfalls. A configurable core asset version of functionality is compared to the previous customizable version of the same functionality. From analyzing empirical data collected over a ten-year period, we find that efficiency and quality have improved, while costs have been reduced. The high initial investment associated with evolving to an SPL has been postponed by taking small steps towards an SPL architecture. In addition, this approach has enabled us to expand our product into\u00a0\u2026", "num_citations": "13\n", "authors": ["792"]}
{"title": "An eclipse plugin to support agile reuse\n", "abstract": " Reuse in an Agile context is largely an unexplored research topic. On the surface, these two software engineering techniques would appear to be incompatible due to contradictory principles. For example, Agile components are usually accompanied with little or no support materials, which is likely to hamper their reuse. However we propose that Agile Reuse is possible and indeed advantageous.               We have developed an Eclipse plug-in, named RASCAL, to support Agile Reuse. RASCAL is a recommender agent that infers the need for a reusable component and proactively recommends that component to the developer using a technique consistent with Agile principles. We present the benefits and the challenges encountered when implementing an Agile Reuse tool, paying particular to attention to the XP methodology, and detail our recommendation technique. Our overall results suggest RASCAL is\u00a0\u2026", "num_citations": "13\n", "authors": ["792"]}
{"title": "Dependency in software watermarking\n", "abstract": " The advent of bytecode languages such as Java and advances in decompilation tools has made it easier to infringe the copyright of software. This presents a serious challenge to the software industry, as modern Internet software is highly distributed and the potential for software piracy is immense. Software watermarking has been proposed as one means of protecting the intellectual property in software. The strategy is to embed secret ownership information (i.e., a 'watermark') in a program that cannot be easily removed by unauthorized parties but that can be reliably extracted by an authorized decoder. We investigate a practical implementation of dynamic graph watermarking, focusing particularly on embedding stealthy watermark generating code in the program's text. Our scheme is based on the premise that watermarking code should not be distinguishable from ordinary program code. This is because one\u00a0\u2026", "num_citations": "13\n", "authors": ["792"]}
{"title": "Automated Application of Design Patterns to Legacy Code.\n", "abstract": " In reengineering legacy code it is frequently useful to introduce a design pattern in order to add clarity to the system and thus facilitate further program evolution. We show that this type of transformation can be automated in a pragmatic manner and propose a methodology for the development of design pattern transformations. We address the issues of the definition of a starting point for the transformation, the decomposition of a pattern into minipatterns and the development of corresponding minitransformations that can introduce these minipatterns to a program. The architecture of an existing software prototype is also discussed and the results of applying this methodology to develop a transformation for the Factory Method pattern are presented.", "num_citations": "10\n", "authors": ["792"]}
{"title": "LASER: A Lexical Approach to Analogy in Software Reuse.\n", "abstract": " Software reuse is the process of creating a software system from existing software components, rather than creating it from scratch. With the increase in size and complexity of existing software repositories, the need to provide intelligent support to the programmer becomes more pressing. An analogy is a comparison of certain similarities between things which are otherwise unlike. This concept has shown to be valuable in developing UML-level reuse techniques. In the LASER project we apply lexically-driven Analogy at the code level, rather than at the UML-level, in order to retrieve matching components from a repository of existing components. Using the lexical ontology Word-Net, we have conducted a case study to assess if class and method names in open source applications are used in a semantically meaningful way. Our results demonstrate that both hierarchical reuse and parallel reuse can be enhanced through the use of lexically-driven Analogy.", "num_citations": "8\n", "authors": ["792"]}
{"title": "Design patterns: The devils in the detail\n", "abstract": " The application of a design pattern in an industrial context is frequently a much more involved task than is described the pattern description itself. In this experience paper we report on a number of problems encountered in the application of several common patterns in commercial software systems. The problems we examine range in nature from details of the runtime environment that hamper pattern implementation (Singleton), to the software upgrade process breaking a pattern's promise (Abstract Factory), to the consequences of the tight source code coupling produced by pattern application (Facade).", "num_citations": "6\n", "authors": ["792"]}
{"title": "Towards Automating the Introduction of the Decorator Pattern to Avoid Subclass Explosion\n", "abstract": " The applicability of the decorator pattern is two-fold: it may be used to enable the dynamic addition of functionality to objects or, in certain cases, to circumvent subclass explosion. This paper illustrates how the decorator pattern can be introduced to a class hierarchy in a semi-automatic fashion in order to solve the latter problem.", "num_citations": "5\n", "authors": ["792"]}
{"title": "Inheritance versus Delegation: which is more energy efficient?\n", "abstract": " Energy consumption of software is receiving more attention as concerns regarding climate change increase. One factor that significantly impacts how much energy is expended by a software application is the design of the software itself. Existing studies find few consistent results regarding the impact of common refactorings on energy consumption, nor do they define a concrete set of metrics that measure the energy efficiency of software. In this paper, we present the results of preliminary experiments that explore the Replace Inheritance with Delegation refactoring, and its inverse, to assess the impact these design-level refactorings have on energy consumption in the Java programming language. In the tested programs, inheritance proved to be more energy efficient than delegation, with a reduction in run time of 77% and a reduction in average power consumption of 4%. We subsequently propose a research plan\u00a0\u2026", "num_citations": "4\n", "authors": ["792"]}
{"title": "Recommending library methods: An evaluation of bayesian network classifiers\n", "abstract": " Programming tasks are often mirrored inside an organisation, across a community or within a specific domain. We propose that final source codes can be mined, that knowledge and insight can be automatically obtained and that this knowledge can be reused for the benefit of future developments. We focus on reusable software libraries; we wish to learn information about how such libraries are used and then elegantly pass this information onto individual developers.In this paper we investigate a Collaborative Filtering approach of recommending library methods to a individual developer for a particular task. The central idea is that we find source codes that are the most relevant to the task at hand and use these to suggest useful library methods to a developer. To determine the similarity and relevance of source code, we investigate and compare a number of Bayesian clustering techniques including Bayesian Networks and Na\u0131ve-Bayes. We present results and discuss the suitability of Bayesian networks to this domain.", "num_citations": "4\n", "authors": ["792"]}
{"title": "Automated support for agile software reuse\n", "abstract": " Agile software development methodologies tend towards sparse up-front design and minimal commenting of source code. Researchers in the Department of Computer Science, University College Dublin are investigating ways of providing automated support for software reuse in this code-centric context.In recent years there has been a trend towards lightweight, flexible software development methodologies, collectively known as Agile Processes. In these approaches the focus is on the source code produced rather than design documentation or methodological considerations. This presents a new challenge to the age-old problem of software reuse, specifically the task of recommending software components. Approaches that involve design-level reuse (eg, based on UML descriptions) are no longer valid as this design documentation is typically not produced. Approaches that rely on the programmer adding extra\u00a0\u2026", "num_citations": "4\n", "authors": ["792"]}
{"title": "Search-based refactoring for layered architecture repair: An initial investigation\n", "abstract": " Layered architectures are popular because of the flexibility and maintainability benefits they provide. However, experience shows that as a project grows, architecture erosion can occur resulting in the deterioration of the original layering intended by the system architect. To address this problem, we propose the application of search-based refactoring to fully automate the detection and correction of access violations in a layered architecture. We extend the search-based refactoring framework, Code-Imp, to provide the metrics and refactorings necessary for architecture violation repair and perform a case study on the open source project DSpace, which was previously identified as suffering from architectural erosion. A number of hill-climbing and simulated annealing variants are applied in the investigations. We found that while simulated annealing could remove 78% of the layering violations, it resulted in an incoherent design. First-ascent hill climbing was able to produce a 65% reduction in layering violations and yielded a functionally coherent design where the majority of the refactorings performed moved items to locations that were appropriate based on the architectural documentation. From these results we conclude that search-based refactoring is a useful and promising technique for the automated repair of access violations in layered architectures. c 2015 Published by Elsevier Ltd.", "num_citations": "3\n", "authors": ["792"]}
{"title": "Impact of stack overflow code snippets on software cohesion: a preliminary study\n", "abstract": " Developers frequently copy code snippets from publicly-available resources such as Stack Overflow (SO). While this may lead to a 'quick fix' for a development problem, little is known about how these copied code snippets affect the code quality of the recipient application, or how the quality of the recipient classes subsequently evolve over the time of the project. This has an impact on whether such code copying should be encouraged, and how classes that receive such code snippets should be monitored during evolution. To investigate this issue, we used instances from the SOTorrent database where Java snippets had been copied from Stack Overflow into GitHub projects. In each case, we measured the quality of the recipient class just prior to the addition of the snippet, immediately after the addition of the snippet, and at a later stage in the project. Our goal was to determine if the addition of the snippet caused\u00a0\u2026", "num_citations": "2\n", "authors": ["792"]}
{"title": "The case for explicit coupling constraints\n", "abstract": " A software element defined in one place is typically used in many places. When it is changed, all its occurrences may need to be changed too, which can severely hinder software evolution. This has led to the support of encapsulation in modern programming languages. Unfortunately, as is shown in this paper, this is not enough to express all the constraints that are needed to decouple programming elements that evolve at different paces. In this paper we show that: a language can be defined to easily express very general coupling constraints; violations to these constraints can be detected automatically. We then demonstrate several places where the need for coupling constraints arose in open-source Java projects. These constraints were expressed in comments when explicit constraints would have enabled automatic treatment.", "num_citations": "2\n", "authors": ["792"]}