{"title": "An introduction to quantum computing for non-physicists\n", "abstract": " Richard Feynman's observation that certain quantum mechanical effects cannot be simulated efficiently on a computer led to speculation that computation in general could be done more efficiently if it used these quantum effects. This speculation proved justified when Peter Shor described a polynomial time quantum algorithm for factoring intergers.In quantum systems, the computational space increases exponentially with the size of the system, which enables exponential parallelism. This parallelism could lead to exponentially faster quantum algorithms than possible classically. The catch is that accessing the results, which requires measurement, proves tricky and requires new nontraditional programming techniques.The aim of this paper is to guide computer  scientists through the barriers that separate quantum computing from conventional computing. We introduce basic principles of quantum mechanics to\u00a0\u2026", "num_citations": "510\n", "authors": ["1710"]}
{"title": "Quantum computing: A gentle introduction\n", "abstract": " A thorough exposition of quantum computing and the underlying concepts of quantum physics, with explanations of the relevant mathematics and numerous examples. The combination of two of the twentieth century's most influential and revolutionary scientific theories, information theory and quantum mechanics, gave rise to a radically new view of computing and information. Quantum information processing explores the implications of using quantum mechanics instead of classical mechanics to model information and its processing. Quantum computing is not about changing the physical substrate on which computation is done from classical to quantum but about changing the notion of computation itself, at the most basic level. The fundamental unit of computation is no longer the bit but the quantum bit or qubit. This comprehensive introduction to the field offers a thorough exposition of quantum computing and the underlying concepts of quantum physics, explaining all the relevant mathematics and offering numerous examples. With its careful development of concepts and thorough explanations, the book makes quantum computing accessible to students and professionals in mathematics, computer science, and engineering. A reader with no prior knowledge of quantum physics (but with sufficient knowledge of linear algebra) will be able to gain a fluent understanding by working through the book.", "num_citations": "307\n", "authors": ["1710"]}
{"title": "The evolution of technology within a simple computer model\n", "abstract": " Technology\u2014the collection of devices and methods available to human society\u2014evolves by constructing new devices and methods from ones that previously exist, and in turn offering these as possible components\u2014building blocks\u2014for the construction of further new devices and elements. The collective of technology in this way forms a network of elements where novel elements are created from existing ones and where more complicated elements evolve from simpler ones. We model this evolution within a simple artificial system on the computer. The elements in our system are logic circuits. New elements are formed by combination from simpler existing elements (circuits), and if a novel combination satisfies one of a set of needs, it is retained as a building block for further combination. We study the properties of the resulting build out. We find that our artificial system can create complicated technologies (circuits\u00a0\u2026", "num_citations": "185\n", "authors": ["1710"]}
{"title": "Formal verification of Ada programs\n", "abstract": " The Penelope verification editor and its formal basis are described. Penelope is a prototype system for the interactive development and verification of programs that are written in a rich subset of sequential Ada. Because it generates verification conditions incrementally, Penelope can be used to develop a program and its correctness proof in concert. If an already-verified program is modified, one can attempt to prove the modified version by replaying and modifying the original sequence of proof steps. Verification conditions are generated by predicate transformers whose logical soundness can be proven by establishing a precise formal connection between predicate transformation and denotational definitions in the style of continuation semantics. Penelope's specification language, Larch/Ada, belongs to the family of Larch interface languages. It scales up properly, in the sense that one can demonstrate the\u00a0\u2026", "num_citations": "131\n", "authors": ["1710"]}
{"title": "Compiler specification and verification\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "126\n", "authors": ["1710"]}
{"title": "Simple and effective defense against evil twin access points\n", "abstract": " Wireless networking is widespread in public places such as cafes. Unsuspecting users may become victims of attacks based on\" evil twin\" access points. These rogue access points are operated by criminals in an attempt to launch man-in-the-middle attacks. We present a simple protection mechanism against binding to an evil twin. The mechanism leverages short authentication string protocols for the exchange of cryptographic keys. The short string verification is performed by encoding the short strings as a sequence of colors, rendered sequentially by the user's device and by the designated access point of the cafe. The access point must have a light capable of showing two colors and must be mounted prominently in a position where users can have confidence in its authenticity. We conducted a usability study with patrons in several cafes and participants found our mechanism very usable.", "num_citations": "96\n", "authors": ["1710"]}
{"title": "Systems and methods for creating an interactive 3D visualization of indexed media\n", "abstract": " A 3D graphical user interface includes a two-dimensional ground-plane layout representing the relationship between one or more leaf elements of a tree data structure. The interface further includes at least one building-like structure, each of the at least one building-like structure corresponding to a respective one of the one or more leaf elements. Each of the at least one building-like structure provides a summary of media associated with the respective one of the more leaf elements corresponding to at least one building-like structure.", "num_citations": "93\n", "authors": ["1710"]}
{"title": "Stanford Pascal verifier user manual\n", "abstract": " The Stanford Pascal verifier is an interactive program verification system. It automates much of the work necessary to analyze a program for consistency with its documentation, and to give a rigorous mathematical proof of such consistency or to pin-point areas of inconsistency. It has been shown to have applications as an aid to programming, and to have potential for development as a new and useful tool in the production of reliable software.Descriptors:", "num_citations": "85\n", "authors": ["1710"]}
{"title": "A genetic algorithm for video segmentation and summarization\n", "abstract": " We describe a genetic segmentation algorithm for video. This algorithm operates on segments of a string representation. It is similar to both classical genetic algorithms that operate on bits of a string and genetic grouping algorithms that operate on subsets of a set. For evaluating segmentations, we define similarity adjacency functions, which are extremely expensive to optimize with traditional methods. The evolutionary nature of genetic algorithms offers a further advantage by enabling incremental segmentation. Applications include video summarization and indexing for browsing, plus adapting to user access patterns.", "num_citations": "74\n", "authors": ["1710"]}
{"title": "Usable and secure portable storage\n", "abstract": " Described is a technique for providing shared access to an encrypted portable memory device which improves both usability and security by allowing the owner of the encrypted storage device to designate access to specified files only to the next host to mount the secure disk. The number of steps required to perform a file sharing operation is greatly reduced with this system and access to the contents of the protected storage device can be granted with greater granularity.", "num_citations": "70\n", "authors": ["1710"]}
{"title": "ADA exception handling: an axiomatic approach\n", "abstract": " A method of documenting exception propagation and handling in Ada programs is proposed. Exception propagation declarations are introduced as a new component of Ada specifications, permitting documentation of those exceptions that can be propagated by a subprogram. Exception handlers are documented by entry assertions. Axioms and proof rules for Ada exceptions given. These rules are simple extensions of previous rules for Pascal and define an axiomatic semantics of Ada exceptions. As a result, Ada programs specified according to the method can be analyzed by formal proof techniques for consistency with their specifications, even if they employ exception propagation and handling to achieve required results (i.e., nonerror situations). Example verifications are given.", "num_citations": "68\n", "authors": ["1710"]}
{"title": "Interactive techniques for organizing and retrieving thumbnails and notes on large displays\n", "abstract": " The present invention relates to techniques for supporting organizational, labeling and retrieval tasks on an electronic tabletop, wall or large display. In various embodiments of the invention, a dynamic visualization is used to show a current working set of documents. In an embodiment of the invention, the rest of the collection is represented in the background as small dots. In an embodiment of the invention, when a user moves objects into groups or creates a label, relevant objects in the background are automatically retrieved and moved into the foreground. In an embodiment of the invention, retrieved objects along with relevant objects in the current set are highlighted and decorated with arrows pointing to their relevant groups. In an embodiment of the invention, the movement is animated to provide user feedback when objects must travel long distances on a large display.", "num_citations": "54\n", "authors": ["1710"]}
{"title": "Tools for quantum algorithms\n", "abstract": " We present efficient implementations of a number of operations for quantum computers. These include controlled phase adjustments of the amplitudes in a superposition, permutations, approximations of transformations and generalizations of the phase adjustments to block matrix transformations. These operations generalize those used in proposed quantum search algorithms.", "num_citations": "37\n", "authors": ["1710"]}
{"title": "Method and system for constructing adaptive and resilient software\n", "abstract": " A dependency action system uses redundant sets of dynamically reconfigurable functional components to achieve robustness and fault tolerance, and to achieve self-optimization by learning and planning techniques that use time-stamps and or computation stamps as a key indicator. The dependency action system is based on functional components, or actions, which act on data values that are stored in stamped storage locations. Data is read and written to these storage locations, updating the stamps as appropriate. The execution of an action is controlled by the stamps of its enabling and disabling storage locations. The dependency action system specifies an action as enabled if new data has arrived in the enabling storage locations. Updating the stamp of the disabling storage locations disables the action. If an alternative action succeeds and produces a value, the other alternative actions become disabled. If\u00a0\u2026", "num_citations": "32\n", "authors": ["1710"]}
{"title": "System and method for human assisted secure information exchange\n", "abstract": " A system that assures a user that two specific devices have exchanged information correctly over an insecure communication channel. In a typical application, the channel would be a wireless network connection and the information would consist of the public keys of the two devices. The exchanged public keys would subsequently be used to secure any further communication between the two devices. The system requires that both devices have an output modality interpretable by a human. One of the devices must have an input modality that can be operated by the user. The input and output modalities can be very simple eg, they can consist of a button and LEDs. The users would press the button multiple times. On each press, the LEDs on both devices display a color and the user compares the colors and that they are synchronous. A noticeable delay or color difference signifies a security threat.", "num_citations": "21\n", "authors": ["1710"]}
{"title": "Program verification based on denotation semantics\n", "abstract": " A theory of partial correctness proofs is formulated in Scott's logic computable junctions. This theory allows mechanical construction of verification condition solely on the basis of a denotational language definition. Extensionally these conditions, the resulting proofs, and the required program augmentation are similar to those of Hoare style proofs; conventional input, output, and invariant assertions in a first order assertion language are required. The theory applies to almost any sequential language defined by a continuation semantics; for example, there are no restrictions on aliasing or side-effects. Aspects of\" static semantics\", such as type and declaration constraints, which are expressed in the denotational definition are validated as part of the verification condition generation process.", "num_citations": "20\n", "authors": ["1710"]}
{"title": "Methods and systems for automatically generating provably correct computer program code\n", "abstract": " A provably correct computer program can be generated using genetic programming techniques. A desired behavior is used to define a formal specification. An initial population of programs is created where each program has a meaning that can be defined using a formalization technique. A fitness function is applied to measure a distance between the meaning of a program, ie, its actual behavior, and the specification. Any program having a zero value as the measure of distance between the meaning of the program and the specification is determined to be provably correct. After the fitness of some or all of the programs in the current generation of programs has been computed, a provably correct program has not yet been found in the current generation, mutation and/or crossover techniques are performed on at least some of the fittest individuals in the current generation to create the programs of a next generation.", "num_citations": "17\n", "authors": ["1710"]}
{"title": "A Genetic Segmentation Algorithm for Image Data Streams and Video.\n", "abstract": " We describe a genetic segmentation algorithm for image data streams and video. This algorithm operates on segments of a string representation. It is similar to both classical genetic algorithms that operate on bits of a string and genetic grouping algorithms that operate on subsets of a set. It employs a segment fair crossover operation. For evaluating segmentations, we define similarity adjacency functions, which are extremely expensive to optimize with traditional methods. The evolutionary nature of genetic algorithms offers a further advantage by enabling incremental segmentation. Applications include browsing and summarizing video and collections of visually rich documents, plus a way of adapting to user access patterns.", "num_citations": "17\n", "authors": ["1710"]}
{"title": "An exercise in automatic program verification\n", "abstract": " This paper describes in some detail the computer-aided proof of a permutation program obtained using the Stanford Pascal verifier. We emphasize the systematic way in which a proof can be developed from an intuitive understanding of the program. The paper fillustrates the current state of the art in automatic program verification.", "num_citations": "15\n", "authors": ["1710"]}
{"title": "System and method for automatic design of components in libraries\n", "abstract": " Embodiments of the present invention introduce a novel recursive assembly process to automatically create a library of components. It starts with simple components used as building blocks and proceeds by repeatedly combining these randomly into more complex ones. The utility and quality of these random combinations of components are measured against a set of functional goals. Useful combinations then become new components in the library that can be used as building blocks for further random combination. This description is not intended to be a complete description of, or limit the scope of, the invention. Other features, aspects, and objects of the invention can be obtained from a review of the specification, the figures, and the claims.", "num_citations": "12\n", "authors": ["1710"]}
{"title": "Annealing algorithm for non-rectangular shaped stained glass collages\n", "abstract": " The present invention relates to a method to make effective use of non rectangular display space for displaying a collage. In an embodiment of the invention, a heterogeneous set of images can be arranged to display the region of interest of the images to avoid overlapping regions of interest. The background gaps between the regions of interest can be filled by extending the regions of interest using a Voronoi technique. This produces a stained glass effect for the collage. In an embodiment of the present invention, the technique can be applied to irregular shapes including circular shapes with a hole in the middle. In an embodiment of the present invention, the technique can be used to print labels for disks.", "num_citations": "11\n", "authors": ["1710"]}
{"title": "A practical method of documenting and verifying Ada programs with packages\n", "abstract": " We present a method of formal specification of Ada programs containing packages. The method suggests concepts and guidelines useful for giving adequate informal documentation of packages by means of comments.The method depends on (1) the standard inductive assertion technique for subprograms, (2) the use of history sequences in assertions specifying the declaration and use of packages, and (3) the addition of three categories of specifications to Ada package declarations: (a) visible specifications, (b) boundary specifications, (c) internal specifications.Axioms and proof rules for the Ada package constructs (declaration, instantiation, and function and procedure call) are given in terms of history sequences and package specifications. These enable us to construct formal proofs of the correctness of Ada programs with packages. The axioms and proof rules are easy to implement in automated program\u00a0\u2026", "num_citations": "10\n", "authors": ["1710"]}
{"title": "Program Veriflcation at Stanford: Past, Present, Future\n", "abstract": " In late 1971 Shigeru Igarashi, Ralph London, David Luckham, and Robin Milner were working at the Stanford Artificial Intelligence Laboratory. At the same time Niklaus Wirth was visiting the Computer Science Department at Stanford. Robin Milner was implementing LCF [25, 26], a formal system to reason about programs based on Dana Scott\u2019s logic of computable functions.", "num_citations": "7\n", "authors": ["1710"]}
{"title": "Theory of Compiler Specification and Verification.\n", "abstract": " The formal specification, design, implementation, and verification of a compiler for a Pascal-like language is described. All components of the compilation process such as scanning, parsing, type checking, and code generation are considered. The implemented language contains most control structures of Pascal, recursive procedures and functions, and jumps. It provides user defined data types including arrays, records, and pointers. A simple facility for input-output is provided. The target language assumes a stack machine including a display mechanism to handle procedure and function calls. The compiler itself is written in Pascal Plus, a dialect of Pascal accepted by the Stanford verifier. The Stanford verifier is used to give a complete formal machine checked verification of the compiler. One of the main problem areas considered is the formal mathematical treatment of programming languages and compilers suitable as input for automated program verification systems. Several technical and methodological problems of mechanically verifying large software systems are considered. Some new verification techniques are developed, notably methods to reason about pointers, fixed points, and quantification. These techniques are of general importance and are not limited to compiler verification. The result of this research demonstrates that construction of large correct programs is possible with the existing verification technology. It indicates that verification will become a useful software engineering tool in the future. Several problem areas of current verification systems are pointed out and areas for future research are outlined. AuthorDescriptors:", "num_citations": "7\n", "authors": ["1710"]}
{"title": "Systems and methods for creating an interactive 3d visualization of indexed media\n", "abstract": " A 3D graphical user interface includes a two-dimensional ground-plane layout representing the relationship between one or more leaf elements of a tree data structure The interface further includes at least one building-like structure, each of the at least one building-like structures corresponding to a respective one of the one or more leaf elements. Each of the at least one building-like structure provides a summary of media associated with the respective one of the more leaf elements corresponding to that at least one building-like structure.", "num_citations": "6\n", "authors": ["1710"]}
{"title": "Formal methods in practice\n", "abstract": " Technology transfer from academic research to industrial practice is hampered by social, political, and economic problems more than by technical issues. This paper describes one instance of successful technology transfer based on a special-purpose language and an associated translation tool tailored to the customer's needs. The key lesson to be learned from this example is that mathematical formalisms must be transparent to the user. Formalisms can be effectively employed if they are represented by tools that fit into existing work processes. It is suggested that special-purpose, domain-specific languages and their translators are an important vehicle to transition advanced technology to practice. This approach enables domain experts to solve problems using familiar terminology. It enables engineers of all disciplines to utilize computers without becoming software engineers. In doing so, we not only mitigate the\u00a0\u2026", "num_citations": "6\n", "authors": ["1710"]}
{"title": "A Collaborative Approach to Stochastic Load Balancing with Networked queues of autonomous service clusters\n", "abstract": " Load balancing has been an increasingly important issue for handling computational intensive tasks in a distributed system such as in grid and cluster computing. In such systems, multiple server instances are installed for handling requests from client applications, and each request (or task) typically needs to stay in a queue before an available server is assigned to process it. In this paper, we propose a high-performance queueing method for implementing a shared queue for collaborative clusters of servers. Each cluster of servers maintains a local queue and queues of different clusters are networked to form a unified (or shared) queue that may dispatch tasks to all available servers. We propose a new randomized algorithm for forwarding requests in an overcrowded local queue to a networked queue based on load information of the local and neighboring clusters. The algorithm achieves both load balancing and\u00a0\u2026", "num_citations": "5\n", "authors": ["1710"]}
{"title": "Common intermediate design language\n", "abstract": " The common intermediate design language (CIDL) is a high-level executable system design language intended for the evolutionary prototyping of large distributed software systems. CIDL was designed to be the target language for code synthesis from high-level system descriptions and the source language for translation into Ada. The resulting design is a typed language with higher-order functions, polymorphism, and concurrency constructs. The language uses types as a representation of formal specifications.< >", "num_citations": "5\n", "authors": ["1710"]}
{"title": "Systems and methods for creating an interactive 3d visualization of indexed media\n", "abstract": " A 3D graphical user interface includes a two-dimensional ground-plane layout representing the relationship between one or more leaf elements of a tree data structure The interface further includes at least one building-like structure, each of the at least one building-like structures corresponding to a respective one of the one or more leaf elements. Each of the at least one building-like structure provides a summary of media associated with the respective one of the more leaf elements corresponding to that at least one building-like structure.", "num_citations": "4\n", "authors": ["1710"]}
{"title": "Quantum computing\n", "abstract": " Changing the model underlying information and computation from a classical mechanical to a quantum mechanical one yields faster algorithms, novel cryptographic mechanisms, and alternative methods of communication. Quantum algorithms can perform a select set of tasks vastly more efficiently than any classical algorithm, but for many tasks it has been proven that quantum algorithms provide no advantage. The breadth of quantum computing applications is still being explored. Major application areas include security and the many fields that would benefit from efficient quantum simulation. The quantum information processing viewpoint provides insight into classical algorithmic issues as well as a deeper understanding of entanglement and other non-classical aspects of quantum physics.", "num_citations": "4\n", "authors": ["1710"]}
{"title": "ADA Exceptions: Specification and Proof Techniques.\n", "abstract": " A method of documenting exception propagation and handling in Ada programs is proposed. Exception propagation declarations are introduced as a new component of Ada specifications. This permits documentation of those exceptions that can be propagated by a subprogram. Exception handlers are documented by entry assertions. Axioms and proof rules for Ada exceptions are given. These rules are simple extensions of previous rules for Pascal and define an axiomatic semantics of Ada exceptions. As a result, Ada programs specified according to the method can be analysed by formal proof techniques for consistency with their specifications, even if they employ exception propagation and handling to achieve required results ie non error situations. Example verifications are given. AuthorDescriptors:", "num_citations": "4\n", "authors": ["1710"]}
{"title": "Formal Verification of ADA Programs\n", "abstract": " This paper describes the Penelope verification editor and its formal basis. Penelope is a prototype system for the interactive development and verification of programs that are written in a rich subset of sequential", "num_citations": "1\n", "authors": ["1710"]}