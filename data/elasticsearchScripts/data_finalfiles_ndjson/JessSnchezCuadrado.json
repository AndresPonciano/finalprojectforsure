{"title": "RubyTL: A practical, extensible transformation language\n", "abstract": " Model transformation is a key technology of model driven development approaches. A lot of research therefore is being carried out to understand the nature of model transformations and find out desirable characteristics of transformation languages. In recent years, several transformation languages have been proposed.               We present the RubyTL transformation language which has been designed as an extensible language\u2013a set of core features along with an extension mechanism. RubyTL provides a framework for experimenting with features of hybrid transformation languages. In addition, RubyTL has been created as a domain specific language embedded in the Ruby programming language. In this paper we show the core features of the language through a simple example and explain how the language can be extended to provide more features.", "num_citations": "159\n", "authors": ["588"]}
{"title": "When and how to use multilevel modelling\n", "abstract": " Model-Driven Engineering (MDE) promotes models as the primary artefacts in the software development process, from which code for the final application is derived. Standard approaches to MDE (like those based on MOF or EMF) advocate a two-level metamodelling setting where Domain-Specific Modelling Languages (DSMLs) are defined through a metamodel that is instantiated to build models at the metalevel below. Multilevel modelling (also called deep metamodelling) extends the standard approach to metamodelling by enabling modelling at an arbitrary number of metalevels, not necessarily two. Proposers of multilevel modelling claim this leads to simpler model descriptions in some situations, although its applicability has been scarcely evaluated. Thus, practitioners may find it difficult to discern when to use it and how to implement multilevel solutions in practice. In this article, we discuss those situations\u00a0\u2026", "num_citations": "134\n", "authors": ["588"]}
{"title": "Morsa: A scalable approach for persisting and accessing large models\n", "abstract": " Applying Model-Driven Engineering (MDE) in industrial-scale systems requires managing complex models which may be very large. These models must be persisted in a scalable way that allows their manipulation by client applications without fully loading them.               In this paper we propose Morsa, an approach that provides scalable access to large models through load on demand; model persistence is supported by a NoSQL database. We discuss some load on demand algorithms and database design alternatives. A prototype that integrates transparently with EMF is presented and its evaluation demonstrates that it is capable of fully loading large models with a limited amount of memory. Moreover, a benchmark has been executed, exhibiting better performance than the EMF XMI file-based persistence and the most representative model repository, CDO.", "num_citations": "102\n", "authors": ["588"]}
{"title": "Model-driven reverse engineering of legacy graphical user interfaces\n", "abstract": " Businesses are more and more modernizing the legacy systems they developed with Rapid Application Development (RAD), so that they can benefit from the new platforms and technologies. In these systems, the Graphical User Interface (GUI) layout is implicitly given by the position of the GUI elements (ie coordinates). However, taking advantage of current features of GUI technologies often requires an explicit, high-level layout model. We propose a Model-Driven Engineering process to perform reverse engineering of RAD-built GUIs, which is focused on discovering the implicit layout, and produces a GUI model where the layout is explicit. Based on the information we obtain, other reengineering activities can be performed, for example, to adapt the GUI for mobile device screens.", "num_citations": "87\n", "authors": ["588"]}
{"title": "Building domain-specific languages for model-driven development\n", "abstract": " Today, the popularity of dynamic languages such as Python and Ruby is growing beyond their use as scripting languages. In fact, Sun, Microsoft, and other companies are supporting some dynamic languages on their development platforms. Developers increasingly find that dynamic languages' features help them enhance their productivity, while common misconceptions about them, such as poor performance and reliability, are disappearing. Embedding domain-specific language in a dynamic language rather than constructing a compiler or interpreter can improve program readability and development time.", "num_citations": "87\n", "authors": ["588"]}
{"title": "Example-driven meta-model development\n", "abstract": " The intensive use of models in model-driven engineering (MDE) raises the need to develop meta-models with different aims, such as the construction of textual and visual modelling languages and the specification of source and target ends of model-to-model transformations. While domain experts have the knowledge about the concepts of the domain, they usually lack the skills to build meta-models. Moreover, meta-models typically need to be tailored according to their future usage and specific implementation platform, which demands knowledge available only to engineers with great expertise in specific MDE platforms. These issues hinder a wider adoption of MDE both by domain experts and software engineers. In order to alleviate this situation, we propose an interactive, iterative approach to meta-model construction, enabling the specification of example model fragments by domain experts, with the\u00a0\u2026", "num_citations": "81\n", "authors": ["588"]}
{"title": "Bottom-up meta-modelling: An interactive approach\n", "abstract": " The intensive use of models in Model-Driven Engineering (MDE) raises the need to develop meta-models with different aims, like the construction of textual and visual modelling languages and the specification of source and target ends of model-to-model transformations. While domain experts have the knowledge about the concepts of the domain, they usually lack the skills to build meta-models. These should be tailored according to their future usage and specific implementation platform, which demands knowledge available only to engineers with great expertise in MDE platforms. These issues hinder a wider adoption of MDE both by domain experts and software engineers.               In order to alleviate this situation we propose an interactive, iterative approach to meta-model construction enabling the specification of model fragments by domain experts, with the possibility of using informal drawing tools\u00a0\u2026", "num_citations": "81\n", "authors": ["588"]}
{"title": "Model-driven engineering with domain-specific meta-modelling languages\n", "abstract": " Domain-specific modelling languages are normally defined through general-purpose meta-modelling languages like the MOF. While this is satisfactory for many model-driven engineering (MDE) projects, several researchers have identified the need for domain-specific meta-modelling (DSMM) languages. These provide customised domain-specific meta-modelling primitives aimed at the definition of modelling languages for a specific domain, as well as the construction of meta-model families. Unfortunately, current approaches to DSMM rely on ad hoc methods which add unnecessary complexity to the realization of DSMM in practice. Hence, the goal of this paper is to simplify the definition and usage of DSMM languages. For this purpose, we apply multi-level meta-modelling for the systematic engineering of DSMM architectures. Our method integrates techniques to control the meta-modelling primitives\u00a0\u2026", "num_citations": "72\n", "authors": ["588"]}
{"title": "A Component Model for Model Transformations\n", "abstract": " Model-driven engineering promotes an active use of models to conduct the software development process. In this way, models are used to specify, simulate, verify, test and generate code for the final systems. Model transformations are key enablers for this approach, being used to manipulate instance models of a certain modelling language. However, while other development paradigms make available techniques to increase productivity through reutilization, there are few proposals for the reuse of model transformations across different modelling languages. As a result, transformations have to be developed from scratch even if other similar ones exist. In this paper, we propose a technique for the flexible reutilization of model transformations. Our proposal is based on generic programming for the definition and instantiation of transformation templates, and on component-based development for the encapsulation\u00a0\u2026", "num_citations": "68\n", "authors": ["588"]}
{"title": "Modularization of model transformations through a phasing mechanism\n", "abstract": " In recent years a great effort has been devoted to understanding the nature of model transformations. As a result, several mechanisms to improve model transformation languages have been proposed. Phasing has been mentioned in some works as a rule scheduling or organization mechanism, but without any detail. In this paper, we present a phasing mechanism in the context of rule-based transformation languages. We explain the structure and the behavior of the mechanism, and how it can be integrated in a language. We also analyze how the mechanism promotes modularity, internal transformation composition and helps to solve usual transformation problems. Besides, we show several examples of application to illustrate the usefulness of the mechanism.", "num_citations": "65\n", "authors": ["588"]}
{"title": "Approaches for model transformation reuse: Factorization and composition\n", "abstract": " Reusability is one of the principal software quality factors. In the context of model driven development (MDD), reuse of model transformations is also considered a key activity to achieve productivity and quality. It is necessary to devote important research efforts to find out appropriate reusability mechanisms for transformation tools and languages. In this paper we present two approaches for reusing model transformation definitions. Firstly, we tackle the creation of related model transformations, showing how the factorization of common parts can be achieved. Secondly, we describe a proposal on the composition of existing, separated transformation definitions so that they can be used to solve a concrete transformation problem. We illustrate both proposals with examples taken from the development of a software product line for adventure games, which has been implemented using the modularization\u00a0\u2026", "num_citations": "62\n", "authors": ["588"]}
{"title": "Static analysis of model transformations\n", "abstract": " Model transformations are central to Model-Driven Engineering (MDE), where they are used to transform models between different languages; to refactor and simulate models; or to generate code from models. Thus, given their prominent role in MDE, practical methods helping in detecting errors in transformations and automate their verification are needed. In this paper, we present a method for the static analysis of ATL model transformations. The method aims at discovering typing and rule errors, like unresolved bindings, uninitialized features or rule conflicts. It relies on static analysis and type inference, and uses constraint solving to assert whether a source model triggering the execution of a given problematic statement can possibly exist. Our method is supported by a tool that integrates seamlessly with the ATL development environment. To evaluate the usefulness of our method, we have used it to analyse a\u00a0\u2026", "num_citations": "60\n", "authors": ["588"]}
{"title": "Applying model-driven engineering in small software enterprises\n", "abstract": " Model-Driven Engineering (MDE) is increasingly gaining acceptance in the software engineering community, however its adoption by the industry is far from successful. The number of companies applying MDE is still very limited. Although several case studies and reports have been published on MDE adoption in large companies, experience reports on small enterprises are still rare, despite the fact that they represent a large part of the software companies ecosystem.In this paper we report on our practical experience in two transfer of technology projects on two small companies. In order to determine the degree of success of these projects we present some factors that have to be taken into account in transfer of technology projects. Then, we assess both projects analyzing these factors and applying some metrics to give hints about the potential productivity gains that MDE could bring. We also comment on some\u00a0\u2026", "num_citations": "58\n", "authors": ["588"]}
{"title": "Generic model transformations: write once, reuse everywhere\n", "abstract": " Model transformation is one of the core techniques in Model Driven Engineering. Many transformation languages exist nowadays, but few offer mechanisms directed to the reuse of whole transformations or transformation fragments in different contexts.             Taking inspiration from generic programming, in this paper we define model transformation templates. These templates are defined over meta-model concepts which later can be bound to specific meta-models. The binding mechanism is flexible as it permits mapping concepts and meta-models with certain kinds of structural heterogeneities. The approach is general and can be applied to any model transformation language. In this paper we report on its application to ATL.", "num_citations": "58\n", "authors": ["588"]}
{"title": "A model-based approach to families of embedded domain-specific languages\n", "abstract": " With the emergence of model-driven engineering (MDE), the creation of domain-specific languages (DSLs) is becoming a fundamental part of language engineering. The development cost of a DSL should be modest compared to the cost of developing a general-purpose programming language. Reducing the implementation effort and providing reuse techniques are key aspects for DSL approaches to be really effective. In this paper, we present an approach to build embedded domain-specific languages applying the principles of model-driven engineering. On the basis of this approach, we will tackle reuse of DSLs by defining families of DSLs, addressing reuse both from the DSL developer and user point of views. A family of DSLs will be built up by composing several DSLs, so we will propose composition mechanisms for the abstract syntax, concrete syntax, and model transformation levels of a DSL's definition\u00a0\u2026", "num_citations": "55\n", "authors": ["588"]}
{"title": "Uncovering errors in ATL model transformations using static analysis and constraint solving\n", "abstract": " Model transformations play a prominent role in Model-Driven Engineering (MDE), where they are used to transform models between languages, to refactor and simulate models, or to generate code from models. However, while the reliability of any MDE process depends on the correctness of its transformations, methods helping in detecting errors in transformations and automate their verification are still needed. To improve this situation, we propose a method for the static analysis of one of the most widely used model transformation languages: ATL. The method proceeds in three steps. Firstly, it infers typing information from the transformation and detects potential errors statically. Then, it generates OCL path conditions for the candidate errors, stating the requirements for a model to hit the problematic statements in the transformation. Last, it relies on constraint solving to generate a test model fragment or witness\u00a0\u2026", "num_citations": "45\n", "authors": ["588"]}
{"title": "Pattern-based development of domain-specific modelling languages\n", "abstract": " Model-Driven Engineering (MDE) promotes the use of models to conduct all phases of software development in an automated way. Models are frequently defined using Domain- Specific Modelling Languages (DSMLs), which many times need to be developed for the domain at hand. However, while constructing DSMLs is a recurring activity in MDE, there is scarce support for gathering, reusing and enacting knowledge for their design and implementation. This forces the development of every new DSML to start from scratch. To alleviate this problem, we propose the construction of DSMLs and their modelling environments aided by patterns which gather knowledge of specific domains, design alternatives, concrete syntax, dynamic semantics and functionality for the modelling environment. They may have associated services, realized via components. Our approach is supported by a tool that enables the construction\u00a0\u2026", "num_citations": "44\n", "authors": ["588"]}
{"title": "A repository for scalable model management\n", "abstract": " Applying model-driven engineering (MDE) in industrial-scale systems requires managing complex models which may be very large. These models must be persisted in a way that allows their manipulation by client applications without fully loading them. In this paper, we propose Morsa, a model repository that provides scalable manipulation of large models through load on demand and incremental store; model persistence is supported by a NoSQL database. We discuss some load on demand and incremental store algorithms as well as a database design. A prototype that integrates transparently with EMF is presented, and its evaluation demonstrates that it is capable of fully managing large models with a limited amount of memory. Moreover, a set of benchmarks has been executed, exhibiting better performance than the EMF XMI file-based persistence and the most widely used model repository, CDO.", "num_citations": "36\n", "authors": ["588"]}
{"title": "Optimization patterns for OCL-based model transformations\n", "abstract": " Writing queries and navigation expressions in OCL is an important part of the task of developing a model transformation definition. When such queries are complex and the size of the models is significant, performance issues cannot be neglected.               In this paper we present five patterns intended to optimize the performance of model transformations when OCL queries are involved. For each pattern we will give an example as well as several implementation alternatives. Experimental data gathered by running benchmarks is also shown to compare the alternatives.", "num_citations": "35\n", "authors": ["588"]}
{"title": "Towards a family of model transformation languages\n", "abstract": " Many model transformation languages of different nature have been proposed during the last years, each one of them suitable for a certain kind of transformation task. However, a complex transformation problem may not fall into a single transformation category, making the solution written in the chosen transformation language suboptimal, as some concerns cannot be handled naturally.               To tackle this issue, we propose to define a model transformation tool as a family of model transformation languages. Each member of the family is a simple language intended to deal with a particular kind of transformation task. In this paper we discuss the different issues involved, such as design decisions, interoperability among languages, and composability. We illustrate the paper with a transformation from UML and OCL to Java, in which languages for pattern matching, mapping, attribution and target-oriented\u00a0\u2026", "num_citations": "31\n", "authors": ["588"]}
{"title": "Quick fixing ATL transformations with speculative analysis\n", "abstract": " Model transformations are central components of most model-based software projects. While ensuring their correctness is vital to guarantee the quality of the solution, current transformation tools provide limited support to statically detect and fix errors. In this way, the identification of errors and their correction are nowadays mostly manual activities which incur in high costs. The aim of this work is to improve this situation. Recently, we developed a static analyser that combines program analysis and constraint solving to identify errors in ATL model transformations. In this paper, we present a novel method and system that uses our analyser to propose suitable quick fixes for ATL transformation errors, notably some non-trivial, transformation-specific ones. Our approach supports speculative analysis to help developers select the most appropriate fix by creating a dynamic ranking of fixes, reporting on the\u00a0\u2026", "num_citations": "29\n", "authors": ["588"]}
{"title": "Streaming model transformations: Scenarios, challenges and initial solutions\n", "abstract": " Several styles of model transformations are well-known and widely used, such as batch, live, incremental and lazy transformations. While they permit tackling advanced scenarios, some applications deal with models that are only available as a possibly infinite stream of elements. Hence, in streaming transformations, source model elements are continuously produced by some process, or very large models are fragmented and fed into the transformation engine. This poses a series of issues that cannot be tackled using current transformation engines. In this paper we motivate the applicability of this kind of transformations, explore the elements involved, and review several strategies to deal with them. We also propose a concrete approach, built on top of the Eclectic transformation tool.", "num_citations": "28\n", "authors": ["588"]}
{"title": "Gra2MoL: A domain specific transformation language for bridging grammarware to modelware in software modernization\n", "abstract": " Model-driven engineering (MDE) can be used both to create new software systems and to evolve or modernize existing software systems. In model-driven software evolution, models are extracted from the system and then MDE techniques are applied to make it evolve. Most evolution scenarios involve dealing with existing source code written in some programming languages. Therefore, a bridge from grammarware to MDE must be built to extract models from such a source code. In this paper we present an approach for the extraction of models conforming to a target metamodel from source code conforming to the grammar of a programming language. This approach is based on the definition of a grammar-to-model transformation language, named Gra2MoL, which is a language specially tailored to address the grammarware-modelware bridge in modernization scenarios. The language promotes grammar reuse, and provides domain-specific features such as a powerful query language to traverse syntax trees.", "num_citations": "24\n", "authors": ["588"]}
{"title": "ODaaS: Towards the model-driven engineering of open data applications as data services\n", "abstract": " The Data-as-a-Service (DaaS, or Data Services) paradigm enables an on-demand, service-based access to data, relying on similar principles to Software-as-a-Service (SaaS). DaaS permits centralized data quality management, a uniform view and access to heterogeneous data, and enables exposing a richer, domain-specific data model to users. Within this context, we are witnessing a trend in institutions to make information public as open data. However, such information is normally released \"as-is\", in heterogeneous formats, requiring costly, ad-hoc pre-processing steps for cleansing and analysis of its underlying structure. This paper proposes an adaptation of the DaaS paradigm for the construction of open data applications. For this purpose, we introduce an architecture based on Model-Driven Engineering (MDE), consisting of (i) multi-level modelling for the description of domains, based on generic meta\u00a0\u2026", "num_citations": "23\n", "authors": ["588"]}
{"title": "A-posteriori typing for model-driven engineering\n", "abstract": " Model-Driven Engineering is founded on the ability to create and process models conformant to a meta-model. Hence, meta-model classes are used in two ways: as templates to create objects, and as classifiers for them. While these two aspects are inherently tied in most meta-modelling approaches, in this paper, we discuss the benefits of their decoupling. Thus, we rely on standard mechanisms for object creation and propose a-posteriori typing as a means to reclassify objects and enable multiple, partial, dynamic typings. This approach enhances flexibility, permitting unanticipated reutilization (as existing model management operations defined for a meta-model can be reused with other models once they get reclassified), as well as model transformation by reclassification. We show the underlying theory behind the introduced concepts, and illustrate its applicability using our MetaDepth meta-modelling tool.", "num_citations": "22\n", "authors": ["588"]}
{"title": "Reusable abstractions for modeling languages\n", "abstract": " Model-driven engineering proposes the use of models to describe the relevant aspects of the system to be built and synthesize the final application from them. Models are normally described using Domain-Specific Modeling Languages (DSMLs), which provide primitives and constructs of the domain. Still, the increasing complexity of systems has raised the need for abstraction techniques able to produce simpler versions of the models while retaining some properties of interest. The problem is that developing such abstractions for each DSML from scratch is time and resource consuming.In this paper, our goal is reducing the effort to provide modeling languages with abstraction mechanisms. For this purpose, we have devised some techniques, based on generic programming and domain-specific meta-modeling, to define generic abstraction operations that can be reused over families of modeling languages sharing\u00a0\u2026", "num_citations": "22\n", "authors": ["588"]}
{"title": "Integrating open services for building educational environments\n", "abstract": " The increasing popularity of Massive Open Online Courses (MOOCs) has raised the need for highly scalable, customizable, open learning environments. At the same time, there is a growing trend to open the services that the companies offer on the web with open APIs and in the form of REST services, facilitating their integration in customized applications. The goal of this work is to show how such open services can be used for the support of on-line educational systems. These services were not created for an education context, so it is necessary to complement it with functionalities for supporting aspects such as evaluations, monitoring or collaboration. This article discusses on the strategies for integrating services for education and presents two cases studies: first, SMLearning, a collaborative learning environment supported by social media platforms Facebook and YouTube, and second, an application for project\u00a0\u2026", "num_citations": "22\n", "authors": ["588"]}
{"title": "Reusing Model Transformations across Heterogeneous Metamodels\n", "abstract": " Model transformations are key enablers for multi-paradigm modeling. However, currently there is little support for reusing transformations in different contexts since they are tightly coupled to the metamodels they are defined upon, and hence reusing them for other metamodels becomes challenging. Inspired from generic programming, we proposed generic model-to-model transformations, which are defined over so-called metamodel concepts, which are later bound to specific metamodels. Nevertheless, the current binding mechanism lacks automated resolution support for recurring structural heterogeneities between metamodels. Therefore, based on a systematic classification of heterogeneities, we propose a flexible binding mechanism being able to automatically resolve recurring structural heterogeneities between metamodels. For this, the binding model is analyzed and required adaptors are automatically added to the transformation.", "num_citations": "22\n", "authors": ["588"]}
{"title": "Reverse engineering of model transformations for reusability\n", "abstract": " Reuse techniques are key for the industrial adoption of Model-Driven Engineering (MDE). However, while reusability has been successfully applied to programming languages, its use is scarce in MDE and, in particular, in model transformations.               In previous works, we developed an approach that enables the reuse of model transformations for different meta-models. This is achieved by defining reusable components that encapsulate a generic transformation template and expose an interface called concept declaring the structural requirements that any meta-model using the component should fulfil. Binding the concept to one of such meta-models induces an adaptation of the template, which becomes applicable to the meta-model. To facilitate reuse, concepts need to be concise, reflecting only the minimal set of requirements demanded by the transformation.               In this paper, we automate the\u00a0\u2026", "num_citations": "21\n", "authors": ["588"]}
{"title": "A plugin-based language to experiment with model transformation\n", "abstract": " Model transformation is a key technology of model driven software development approaches. Several transformation languages have appeared in the last few years, but more research is still needed for an in-depth understanding of the nature of model transformations and to discover desirable features of transformation languages. Research interest is primarily focused on experimentation with languages by writing transformations for real problems.               RubyTL is a hybrid transformation language defined as a Ruby internal domain specific language, and is designed as an extensible language: a plugin mechanism allows new features to be added to core features. In this paper, we describe this plugin mechanism, devised to facilitate the experimentation with possible features of RubyTL. Through an example, we show how to add a new language feature, specifically we will develop a plugin to organize a\u00a0\u2026", "num_citations": "20\n", "authors": ["588"]}
{"title": "A layout inference algorithm for Graphical User Interfaces\n", "abstract": " Context: Graphical User Interface (GUI) toolkits currently provide layout managers which lay out widgets in views according to certain constraints that characterise each type of layout manager. In some scenarios such as GUI migration and the automated generation of GUIs from wireframes, the layout of views is implicitly expressed through the use of coordinates. In these cases, it is desirable to represent the layout explicitly in terms of layout managers.Objective: To represent a coordinate-based GUI in terms of a set of layout managers, in order to provide different alternative solutions for a given view and select the best alternative.Method: The layout inference process consists of two phases. Firstly, the coordinate-based positioning system is changed to a relative positioning system based on directed graphs and Allen relations. Secondly, an exploratory algorithm based on pattern matching and graph rewriting is\u00a0\u2026", "num_citations": "16\n", "authors": ["588"]}
{"title": "Deriving ocl optimization patterns from benchmarks\n", "abstract": " Writing queries and navigation expressions in OCL is an important part of the task of developing a model transformation definition. When such queries are complex and the size of the models is significant, performance issues cannot be neglected.", "num_citations": "16\n", "authors": ["588"]}
{"title": "Quick fixing ATL model transformations\n", "abstract": " The correctness of model transformations is key to obtain reliable MDE solutions. However, current transformation tools provide limited support to statically detect and correct errors. This way, the identification of errors and their correction are mostly manual activities. Our aim is to improve this situation. Based on a static analyser for ATL model transformations which we have previously built, we present a method and a system to propose quick fixes for transformation errors. The analyser is based on a combination of program analysis and constraint solving, and our quick fix generation technique makes use of the analyser features to provide a range of fixes, notably some nontrivial, transformation-specific ones. Our approach integrates seamlessly with the ATL editor. We provide an evaluation based on an existing faulty transformation, and automatically generated transformation mutants, showing overall good results.", "num_citations": "15\n", "authors": ["588"]}
{"title": "The Program Is the Model: Enabling Transformations@run.time\n", "abstract": " The increasing application of Model-Driven Engineering in a wide range of domains, in addition to pure code generation, raises the need to manipulate models at runtime, as part of regular programs. Moreover, certain kinds of programming tasks can be seen as model transformation tasks, and thus we could take advantage of model transformation technology in order to facilitate them.             In this paper we report on our works to bridge the gap between regular programming and model transformation by enabling the manipulation of Java APIs as models. Our approach is based on the specification of a mapping between a Java API (e.g., Swing) and a meta-model describing it. A model transformation definition is written against the API meta-model and we have built a compiler that generates the corresponding Java bytecode according to the mapping. We present several application scenarios and discuss\u00a0\u2026", "num_citations": "15\n", "authors": ["588"]}
{"title": "Using ATL transformation services in the MDEForge collaborative modeling platform\n", "abstract": " In the last years, the increasing complexity of Model-Driven Engineering (MDE) tools and techniques has led to higher demands in terms of computation, interoperability, and configuration management. Harnessing the software-as-a-service (SaaS) paradigm and shifting applications from local, mono-core implementations to cloud-based architectures is key to enhance scalability and flexibility. To this end, we propose MDEForge: an extensible, collaborative modeling platform that provides remote model management facilities and prevents the user from focussing on time-consuming, and less creative procedures. This demo paper illustrates the extensibility of MDEForge by integrating ATL services for the remote execution, automated testing, and static analysis of ATL transformations. The usefulness of their employment under the SaaS paradigm is demonstrated with a case-study showing a wide range of\u00a0\u2026", "num_citations": "14\n", "authors": ["588"]}
{"title": "Towards the systematic construction of domain-specific transformation languages\n", "abstract": " General-purpose transformation languages, like ATL or QVT, are the basis for model manipulation in Model-Driven Engineering (MDE). However, as MDE moves to more complex scenarios, there is the need for specialized transformation languages for activities like model merging, migration or aspect weaving, or for specific domains of wide use like UML. Such domain-specific transformation languages (DSTLs) encapsulate transformation knowledge within a language, enabling the reuse of recurrent solutions to transformation problems.               Nowadays, many DSTLs are built in an ad-hoc manner, which requires a high development cost to achieve a full-featured implementation. Alternatively, they are realised by an embedding into general-purpose transformation or programming languages like ATL or Java.               In this paper, we propose a framework for the systematic creation of DSTLs. First, we\u00a0\u2026", "num_citations": "14\n", "authors": ["588"]}
{"title": "Reverse engineering of event handlers of rad-based applications\n", "abstract": " Businesses are more and more modernising the legacy systems they developed with Rapid Application Development (RAD) environments, so that they can benefit from the new platforms and technologies. When facing the modernisation of applications developed with RAD environments, developers must deal with event handling code that typically mixes concerns such as GUI and business logic. In this paper we propose a model-based approach to tackle the reverse engineering of event handlers in RAD-based applications. Event handling code is transformed into an intermediate representation that captures the high-level behaviour of the code. From this representation, some modernisation tasks can be automated, and we propose the migration to a different architecture as an example. In particular, from PL/SQL code, a new Ajax application will be generated, where business logic, user interface and control\u00a0\u2026", "num_citations": "14\n", "authors": ["588"]}
{"title": "AnATLyzer: An advanced IDE for ATL model transformations\n", "abstract": " Model transformations (MTs) are key in model-driven engineering as they automate model manipulation. Their early verification is essential because a bug in a MT may affect many projects using it. Still, there is a lack of analysis tools applicable to non-toy transformations developed with practical MT languages.", "num_citations": "13\n", "authors": ["588"]}
{"title": "Flexible Model-to-Model Transformation Templates: An Application to ATL.\n", "abstract": " Abstract Model transformation is one of the core techniques in Model-Driven Engineering. Many transformation languages exist nowadays, but few offer mechanisms directed to the reuse of whole transformations or transformation fragments in different contexts. Taking inspiration from generic programming, in this paper we define model transformation templates. These templates are not defined over concrete meta-models, but on so-called meta-model concepts which later can be bound to specific meta-models. The binding mechanism is flexible as it permits mapping concepts and meta-models with certain kinds of structural heterogeneities. The approach is general and can be applied to any model transformation language. In this paper we report on its application to ATL.", "num_citations": "13\n", "authors": ["588"]}
{"title": "A phasing mechanism for model transformation languages\n", "abstract": " In recent years a great effort has been devoted to understanding the nature of model transformations. As a result, several mechanisms to improve model transformation languages have been proposed. Phasing has been proposed in some works as a rule scheduling or organization mechanism, but without any detail.", "num_citations": "13\n", "authors": ["588"]}
{"title": "Reusing model transformations through typing requirements models\n", "abstract": " Model transformations are key elements of Model-Driven Engineering (MDE), where they are used to automate the manipulation of models. However, they are typed with respect to concrete source and target meta-models and hence their reuse for other (even similar) meta-models becomes challenging.                 In this paper, we describe a method to extract a typing requirements model (TRM) from an ATL model-to-model transformation. A TRM describes the requirements that the transformation needs from the source and target meta-models in order to obtain a transformation with a syntactically correct typing. A TRM is made of three parts, two of them describing the requirements for the source and target meta-models, and the last expressing dependencies between both. We define a notion of conformance of meta-model pairs with respect to TRMs. This way, the transformation can be used with any meta\u00a0\u2026", "num_citations": "12\n", "authors": ["588"]}
{"title": "Comparison between internal and external DSLs via RubyTL and Gra2MoL\n", "abstract": " Domain Specific Languages (DSL) are becoming increasingly more important with the emergence of Model-Driven paradigms. Most literature on DSLs is focused on describing particular languages, and there is still a lack of works that compare different approaches or carry out empirical studies regarding the construction or usage of DSLs. Several design choices must be made when building a DSL, but one important question is whether the DSL will be external or internal, since this affects the other aspects of the language. This chapter aims to provide developers confronting the internal-external dichotomy with guidance, through a comparison of the RubyTL and Gra2MoL model transformations languages, which have been built as an internal DSL and an external DSL, respectively. Both languages will first be introduced, and certain implementation issues will be discussed. The two languages will then be\u00a0\u2026", "num_citations": "12\n", "authors": ["588"]}
{"title": "Towards effective mutation testing for ATL\n", "abstract": " The correctness of model transformations is crucial to obtain high-quality solutions in model-driven engineering. Testing is a common approach to detect errors in transformations, which requires having methods to assess the effectiveness of the test cases and improve their quality. Mutation testing permits assessing the quality of a test suite by injecting artificial faults in the system under test. These emulate common errors made by competent developers and are modelled using mutation operators. Some researchers have proposed sets of mutation operators for transformation languages like ATL. However, their suitability for an effective mutation testing process has not been investigated, and there is no automated mechanism to generate test models that increase the quality of the tests. In this paper, we use transformations created by third parties to evaluate the effectiveness ATL mutation operators proposed in the\u00a0\u2026", "num_citations": "11\n", "authors": ["588"]}
{"title": "Reusable Model Transformation Components with bent\u014d\n", "abstract": " Building high-quality transformations that can be used in real projects is complex and time-consuming. For this reason, the ability to reuse existing transformations in different, unforeseen scenarios is very valuable. However, there is scarce tool support for this task.                 This paper presents bent\u014d, a tool which supports the development and execution of reusable transformation components. In bent\u014d, a reusable transformation is written as a regular ATL transformation, but it uses concepts as meta-models. Reuse is achieved by binding such concepts to meta-models, which induces the transformation adaptation. Moreover, composite components enable chaining transformations, and it is possible to convert an existing transformation into a reusable component. Bent\u014d is implemented as an Eclipse plug-in, available as free software.", "num_citations": "11\n", "authors": ["588"]}
{"title": "MAR: a structure-based search engine for models\n", "abstract": " The availability of shared software models provides opportunities for reusing, adapting and learning from them. Public models are typically stored in a variety of locations, including model repositories, regular source code repositories, web pages, etc. To profit from them developers need effective search mechanisms to locate the models relevant for their tasks. However, to date, there has been little success in creating a generic and efficient search engine specially tailored to the modelling domain.", "num_citations": "10\n", "authors": ["588"]}
{"title": "Abstracting modelling languages: A reutilization approach\n", "abstract": " Model-Driven Engineering automates the development of information systems. This approach is based on the use of Domain-Specific Modelling Languages (DSMLs) for the description of the relevant aspects of the systems to be built. The increasing complexity of the target systems has raised the need for abstraction techniques able to produce simpler versions of the models, but retaining certain properties of interest. However, developing such abstractions for each DSML from scratch is a time and resource consuming activity.               Our solution to this situation is a number of techniques to build reusable abstractions that are defined once and can be reused over families of modelling languages sharing certain requirements. As a proof of concept, we present a catalogue of reusable abstractions, together with an implementation in the MetaDepth multi-level meta-modelling tool.", "num_citations": "10\n", "authors": ["588"]}
{"title": "Open meta-modelling frameworks via meta-object protocols\n", "abstract": " Meta-modelling is central to Model-Driven Engineering. Many meta-modelling notations, approaches and tools have been proposed along the years, which widely vary regarding their supported modelling features. However, current approaches tend to be closed and rigid with respect to the supported concepts and semantics. Moreover, extending the environment with features beyond those natively supported requires highly technical knowledge. This situation hampers flexibility and interoperability of meta-modelling environments.In order to alleviate this situation, we propose open meta-modelling frameworks, which can be extended and configured via meta-object protocols (MOPs). Such environments offer extension points on events like element instantiation, model loading or property access, and enable selecting particular model elements over which the extensions are to be executed. We show how MOP\u00a0\u2026", "num_citations": "7\n", "authors": ["588"]}
{"title": "Umbra Designer: Graphical modelling for telephony services\n", "abstract": " Almira Labs is a software company that develops value-added services for the telecommunications industry. It is focused on innovative technologies that enable enterprise business and mobile and landline operators to offer next-generation voice-driven applications for all types of phones. Telephony services are built atop the proprietary Umbra framework, which is a Java API relying on the JAIN SLEE standard for event-based communication applications.               This paper describes Umbra Designer, a novel graphical modelling tool for the visual development of telephony services, from which Java code for the Umbra framework is synthesized. In this way, it is easy to develop ready-to-use services, even by users not familiar with the Java API or the JAIN SLEE standard. We also report on some experiments aimed at measuring the efficiency gain derived from using the graphical tool, compared with coding\u00a0\u2026", "num_citations": "7\n", "authors": ["588"]}
{"title": "GUI Generation from Wireframes\n", "abstract": " Wireframes are useful for discussing and refining the user interface of a new application. After the client has validated the GUI, frequently developers have to spend time on recreating the GUI in a development environment for a specific language, and then the created wireframes are discarded. We propose a model-based approach to infer the high level layout of the GUI based on wireframes in order to be able to generate a proper final GUI for different technologies.", "num_citations": "7\n", "authors": ["588"]}
{"title": "Parametrizaci\u00f3n de las transformaciones horizontales en el modelo de herradura\n", "abstract": " En los procesos de modernizaci\u00f3n o reingenier\u00eda de software se aplica generalmente el denominado modelo de herradura. En este modelo hay transformaciones verticales entre artefactos software de diferente nivel de abstracci\u00f3n y transformaciones horizontales en el mismo nivel de abstracci\u00f3n. A pesar de ser un modelo conocido y usado en numerosos trabajos todav\u00eda no se ha explorado completamente c\u00f3mo automatizarlo. En este art\u00edculo se discuten los problemas existentes para su automatizaci\u00f3n, y se motiva la problem\u00e1tica con un caso real de modernizaci\u00f3n. Se describe una aproximaci\u00f3n basada en la parametrizaci\u00f3n de transformaciones horizontales con informaci\u00f3n descubierta en las transformaciones verticales y los cambios realizados en los modelos de niveles superiores.", "num_citations": "7\n", "authors": ["588"]}
{"title": "Building MDE cloud services with distil\n", "abstract": " Model-Driven Engineering (MDE) techniques, like transformations, queries, and code generators, were devised for local, single-CPU architectures. However, the increasing complexity of the systems to be built and their high demands in terms of computation, memory and storage, requires more scalable and flexible MDE techniques, likely using services and the cloud. Nonetheless, the cost of developing MDE solutions on the cloud is high without proper automation mechanisms. In order to alleviate this situation, we present DISTIL, a domain-specific language to describe MDE services, which is able to generate (NoSQL-based) respositories for the artefacts of interest, and skeletons for (single or composite) services, ready to be deployed in Heroku. We illustrate the approach through the construction of a repository and a set of cloud-based services for bent \u00afo reusable transformation components.", "num_citations": "6\n", "authors": ["588"]}
{"title": "Experiments with a High-Level Navigation Language\n", "abstract": " Writing navigation expressions is an important part of the task of developing a model transformation definition. When navigation is complex and the size of source models is significant, performance issues cannot be neglected. Model transformation languages often implement some variants of OCL as their navigation language. Writing efficient code in OCL is usually a difficult task because of the nature of the language and the lack of optimizing OCL compilers. Moreover, optimizations generally reduce readability.               An approach to tackle this issue is to raise the level of abstraction of the navigation language. We propose to complement the regular navigation language of model transformation languages with a high-level navigation language, in order to improve both performance and readability. This paper reports on the initial results of our experiments creating the HLN language: a declarative high\u00a0\u2026", "num_citations": "6\n", "authors": ["588"]}
{"title": "Optimising OCL synthesized code\n", "abstract": " OCL is a important element of many Model-Driven Engineering tools, used for different purposes like writing integrity constraints, as navigation language in model transformation languages or to define transformation specifications. There are refactorings approaches for manually written OCL code, but there is not any tool for the simplification of OCL expressions which have been automatically synthesized (e.g., by a repair system). These generated expressions tend to be complex and unreadable due to the nature of the generative process. However, to be useful this code should be as simple and resemble manually written code as much as possible.               In this work we contribute a set of refactorings intended to optimise OCL expressions, notably covering cases likely to arise in generated OCL code. We also contribute the implementation of these refactorings, built as a generic transformation component\u00a0\u2026", "num_citations": "5\n", "authors": ["588"]}
{"title": "Rapid development of interactive applications based on online social networks\n", "abstract": " Online social networks, like Twitter or Google+, are widely used for all kind of purposes, and the proliferation of smartphones enables their use anywhere, anytime. The instant messaging capabilities of these services are used in an ad-hoc way for social activities, like organizing meetings or gathering preferences among a group of friends, or as a means to contact community managers of companies or services.               Provided with automation mechanisms, posts (messages in social networks) can be used as a dialogue mechanism between users and computer applications. In this paper we propose the concept of post-based application, an application that uses short messages as a medium to obtain input commands from users and produce outputs, describing several scenarios where these applications are of interest. In addition, we provide an automated, Model-Driven Engineering approach (currently\u00a0\u2026", "num_citations": "5\n", "authors": ["588"]}
{"title": "Twiagle: A Tool for Engineering Applications Based on Instant Messaging over Twitter\n", "abstract": " Microblogging services, like Twitter, are widely used for all kind of purposes, like organizing meetings, gathering preferences among friends, or contact community managers of companies or services.               With suitable automation, tweets can be used as a dialogue mechanism between users and computer applications, and we have built a tool, named Twiagle, to construct tweet-based applications. Twiagle includes a pattern-matching language to express the interesting parts to be detected and selected from tweets, and an action language to query matched tweets, aggregate information from them or synthesize messages.", "num_citations": "5\n", "authors": ["588"]}
{"title": "Automated reuse of model transformations through typing requirements models\n", "abstract": " Model transformations are key elements of model-driven engineering, where they are used to automate the manipulation of models. However, they are typed with respect to concrete source and target meta-models, making their reuse for other (even similar) meta-models challenging. To improve this situation, we propose capturing the typing requirements for reusing a transformation with other meta-models by the notion of a typing requirements model (TRM). A TRM describes the prerequisites that a model transformation imposes on the source and target meta-models to obtain a correct typing. The key observation is that any meta-model pair that satisfies the TRM is a valid reuse context for the transformation at hand. A TRM is made of two domain requirement models (DRMs) describing the requirements for the source and target meta-models, and a compatibility model expressing dependencies between them. We\u00a0\u2026", "num_citations": "4\n", "authors": ["588"]}
{"title": "Scheduling model\u2010to\u2010model transformations with continuations\n", "abstract": " Model transformations are at the heart of model\u2010driven engineering because they allow the automation of diverse kinds of model manipulations. Transformation scheduling is a key issue in the design and implementation of many transformation languages. This paper reports our results using continuations as the underlying technique for building a scheduling mechanism implicitly driven by data dependence among transformation rules. To support our experiments, we have built a proof\u2010of\u2010concept model transformation language, which is also reported here. First, we motivate the problem by analyzing the scheduling mechanism of current model transformation languages. Then, we introduce the notion of continuation, showing its applicability to model transformations. Afterwards, we present our approach, notably explaining how dependence is specified and giving the scheduling algorithm. We also analyze the lazy\u00a0\u2026", "num_citations": "4\n", "authors": ["588"]}
{"title": "Una experiencia en transferencia de tecnolog\u00eda de desarrollo de software dirigido por modelos\n", "abstract": " En la actualidad, existe un consenso dentro de la comunidad del software en que el", "num_citations": "4\n", "authors": ["588"]}
{"title": "RubyTL: un Lenguaje de Transformaci\u00f3n de Modelos Extensible.\n", "abstract": " Departamento de Inform\u00e1tica y Sistemas Facultad de Inform\u00e1tica Universidad de Murcia Campus de Espinardo, 30100 e-mail:{jesusc, jmolina, marcos}@ um. es, web: http://gts. inf. um. es", "num_citations": "4\n", "authors": ["588"]}
{"title": "A proposal to improve performance of ATL collections\n", "abstract": " This paper presents a proposal to replace the current implementation of collections in the ATL-VM (based on the Java collection library) with a new implementation that supports inmutable collections natively.", "num_citations": "3\n", "authors": ["588"]}
{"title": "A verified catalogue of OCL optimisations\n", "abstract": " OCL is widely used by model-driven engineering tools with different purposes like writing integrity constraints for meta-models, as a navigation language in model transformation languages or to define transformation specifications. Another scenario is the automatic generation of OCL code by a repair system. These generated expressions tend to be complex and unreadable due to the nature of the generative process. However, to be useful this code should be simple and resemble manually written code as much as possible when a developer must manually maintain it. There exists refactorings approaches for manually written OCL code, but there is no tool targeted to the optimisation of OCL expressions which have been automatically synthesised. Moreover, there is no available catalogue of OCL refactorings which can be integrated seamlessly into a tool. In this work, we contribute a set of refactorings intended to\u00a0\u2026", "num_citations": "2\n", "authors": ["588"]}
{"title": "Model Finding in the EMF Ecosystem.\n", "abstract": " The EMF framework is the main meta-modelling framework used nowadays. It has a rich ecosystem of plug-ins and tools built with and for it, including the option of enriching meta-models with OCL constraints. However, the EMF ecosystem lacks usable model finding approaches. Given a meta-model, a model finder automatically searches for models that satisfy a given set of formulas (eg, OCL constraints). This feature can be used for a number of purposes, including model verification and model synthesis. In this paper, we present an approach to support model finding in the EMF ecosystem that is designed to realize several scenarios including model consistency, example generation, partial solution completion and scrolling. Moreover, it allows several OCL variants to be plugged-in via an intermediate representation. This approach has been realized in a tool called EFinder. We have assessed the usability of the approach by implementing three advanced application scenarios and evaluated its verification capabilities by analyzing OCL constraints from an external OCL dataset containing about 300 valid EMF/OCL specifications. Our model finder is able to process about 65% of these EMF/OCL models.", "num_citations": "2\n", "authors": ["588"]}
{"title": "DSLs para la extracci\u00f3n de modelos en modernizaci\u00f3n\n", "abstract": " La Modernizaci\u00f3n Dirigida por Modelos ha emergido recientemente como una nueva \u00e1rea de investigaci\u00f3n dedicada a la automatizaci\u00f3n basada en modelos de procesos de evoluci\u00f3n de software. En los pr\u00f3ximos anos se necesitar\u00e1 un gran esfuerzo para encontrar principios, t\u00e9cnicas y m\u00e9todos para esta nueva \u00e1rea y ser\u00e1 crucial la experiencia adquirida en el desarrollo de casos de estudio reales de modernizaci\u00f3n. En este art\u0131culo presentamos dos DSLs para la extracci\u00f3n de modelos: Gra2MoL para la extracci\u00f3n a partir de c\u00f3digo fuente conforme a una gram\u00e1tica y H2MoL para el caso de texto que no est\u00e1 bien formado, como por ejemplo HTML. El diseno de estos lenguajes es fruto de la experiencia adquirida en un proyecto de migraci\u00f3n de aplicaciones de la plataforma Struts a JSF, en el que se han aplicado las t\u00e9cnicas basadas en modelos.", "num_citations": "2\n", "authors": ["588"]}
{"title": "\" Generacion des interfaces de usuario a partir de wireframes\n", "abstract": " En los ultimos anos han aparecido un gra numero de herramientas de wireframing destinadas especialmente al desino de sitis y paginas web. Un wireframe es una de las representaciones usadas en el diseno de interfaces graficas de usuario (GUI) que muestra la estructura de la interfaz (que controles se utilizan y como se disponen en el area de visualizacion) sin atender a detalles come colores o imagenes. En este trabajo presentamos una solucion basada en tecnicas de Ingenieria de Software Dirigida por Modelos (MDE) para generar codigo final de la implementacion de una GUI a partir de un wireframe. Las tecnicas MDE nos han proporcionado varias ventajas importantes como i) disponer de una representacion de lato nivel del conocimiento extradio en el proceso de ingenieria inversa aplicado a los wireframes, ii) independencia de este proceso de la herramienta wireframing usada y del toolkit de GUI destino, iii) no es necesario que la alineacion de los controls sea precisa y iv) la calidad del codigo generado mediante la obtencion de interfaces flexibles", "num_citations": "1\n", "authors": ["588"]}
{"title": "Utilidad de las transformaciones modelo-modelo en la generaci\u00f3n autom\u00e1tica de c\u00f3digo.\n", "abstract": " Aunque las transformaciones modelo-modelo son un elemento clave de MDA, todav\u00eda hay dudas sobre su utilidad en escenarios reales. De hecho, algunos paradigmas de Desarrollo de Software Dirigido por Modelos, e incluso algunas de las herramientas MDA m\u00e1s populares, plantean un enfoque generativo basado en transformaciones modelo-c\u00f3digo. En este art\u00edculo se analiza la utilidad de las transformaciones modelo-modelo a partir de un problema real de una empresa, en concreto la generaci\u00f3n autom\u00e1tica de c\u00f3digo para la integraci\u00f3n de software existente. El problema se ha resuelto desde dos perspectivas diferentes que se contrastan, una que genera el c\u00f3digo directamente a partir de un modelo y otra que utiliza transformaciones modelo-modelo para mejorar la legibilidad y el mantenimiento.", "num_citations": "1\n", "authors": ["588"]}