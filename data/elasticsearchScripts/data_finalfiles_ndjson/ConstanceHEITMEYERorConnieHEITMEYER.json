{"title": "Automated consistency checking of requirements specifications\n", "abstract": " This article describes a formal analysis technique, called consistency checking, for automatic detection of errors, such as type errors, nondeterminism, missing cases, and circular definitions, in requirements specifications. The technique is designed to analyze requirements specifications expressed in the SCR (Software Cost Reduction) tabular notation. As background, the SCR approach to specifying requirements is reviewed. To provide a formal semantics for the  SCR notation and a foundation for consistency checking, a formal requirements model is introduced; the model represents a software system as a finite-state automation which produces externally visible outputs in response to changes in monitored environmental quantities. Results of two experiments are presented which evaluated the utility and scalability of our technique for consistency checking in real-world avionics application. The role of\u00a0\u2026", "num_citations": "797\n", "authors": ["1469"]}
{"title": "Using model checking to generate tests from requirements specifications\n", "abstract": " Recently, many formal methods, such as the SCR (Software Cost Reduction) requirements method, have been proposed for improving the quality of software specifications. Although improved specifications are valuable, the ultimate objective of software development is to produce software that satisfies its requirements. To evaluate the correctness of a software implementation, one can apply black-box testing to determine whether the implementation, given a sequence of system inputs, produces the correct system outputs. This paper describes a specification-based method for constructing a suite of test sequences, where a test sequence is a sequence of inputs and outputs for testing a software implementation. The test sequences are derived from a tabular SCR requirements specification containing diverse data types, i.e., integer, boolean, and enumerated types. From the functions defined in the SCR\u00a0\u2026", "num_citations": "544\n", "authors": ["1469"]}
{"title": "Using abstraction and model checking to detect safety violations in requirements specifications\n", "abstract": " Exposing inconsistencies can uncover many defects in software specifications. One approach to exposing inconsistencies analyzes two redundant specifications, one operational and the other property-based, and reports discrepancies. This paper describes a \"practical\" formal method, based on this approach and the SCR (software cost reduction) tabular notation, that can expose inconsistencies in software requirements specifications. Because users of the method do not need advanced mathematical training or theorem-proving skills, most software developers should be able to apply the method without extraordinary effort. This paper also describes an application of the method which exposed a safety violation in the contractor-produced software requirements specification of a sizable, safety-critical control system. Because the enormous state space of specifications of practical software usually renders direct\u00a0\u2026", "num_citations": "250\n", "authors": ["1469"]}
{"title": "Formal methods for real-time computing: an overview\n", "abstract": " La presente simulazione \u00e8 stata realizzata sulla base delle regole riportate nel DM 598/2018 e allegata Tabella A. Cineca non si assume alcuna responsabilit\u00e0 in merito all\u2019uso che il diretto interessato o terzi faranno della simulazione. Si specifica inoltre che la simulazione contiene calcoli effettuati con dati e algoritmi di pubblico dominio e deve quindi essere considerata come un mero ausilio al calcolo svolgibile manualmente o con strumenti equivalenti. Informazioni sui dati: vengono considerati tutti i prodotti in stato definitivo. Per i prodotti indicizzati wos/scopus, l\u2019anno di riferimento e la tipologia sono quelli riportati in banca-dati.", "num_citations": "246\n", "authors": ["1469"]}
{"title": "A security model for military message systems\n", "abstract": " Military systems that process classified information must operate in a secure manner; that is, they must adequately protect information against unauthorized disclosure, modification, and withholding. A goal of current research in computer security is to facilitate the construction of multilevel secure systems, systems that protect information of different classifications from users with different clearances. Security models are used to define the concept of security embodied by a computer system. A single model, called the Bell and LaPadula model, has dominated recent efforts to build secure systems but has deficiencies. We are developing a new approach to defining security models based on the idea that a security model should be derived from a specific application. To evaluate our approach, we have formulated a security model for a family of military message systems. This paper introduces the message system\u00a0\u2026", "num_citations": "244\n", "authors": ["1469"]}
{"title": "The Generalized Railroad Crossing: A Case Study in Formal Verification of Real-Time Systems.\n", "abstract": " A new solution to the Generalized Railroad Crossing problem, based on timed automata, invariants and simulation mappings, is presented and evaluated. The solution shows formally the correspondence between four system descriptions an axiomatic specification, an operational specification, a discrete system implementation, and a system implementation that works with a continuous gate model.Descriptors:", "num_citations": "238\n", "authors": ["1469"]}
{"title": "SCR: A toolset for specifying and analyzing software requirements\n", "abstract": " A controversial issue in the formal methods community is the degree to which mathematical sophistication and theorem proving skills should be needed to apply a formal method and its support tools. This paper describes the SCR (Software Cost Reduction) tools, part of a \u201cpractical\u201d formal method\u2014a. method with a solid mathematical foundation that software developers can apply without theorem proving skills, knowledge of temporal and higher order logics, or consultation with formal methods experts. The SCR method provides a tabular notation for specifying requirements and a set of \u201clight-weight\u201d tools that detect several classes of errors automatically. The method also provides support for more \u201cheavy-duty\u201d tools, such as a model checker. To make model checking feasible, users can automatically apply one or more abstraction methods.", "num_citations": "211\n", "authors": ["1469"]}
{"title": "Model checking complete requirements specifications using abstraction\n", "abstract": " Although model checking has proven remarkably effective in detecting errors in hardware designs, its success in the analysis of software specifications has been limited. Model checking algorithms for hardware verification commonly use Binary Decision Diagrams (BDDs) to represent predicates involving the many Boolean variables commonly found in hardware descriptions. Unfortunately, BDD representations may be less effective for analyzing software specifications, which usually contain not only Booleans but variables spanning a wide range of data types. Further, software specifications typically have huge, sometimes infinite, state spaces that cannot be model checked directly using conventional symbolic methods. One promising but largely unexplored approach to model checking software specifications is to apply mathematically sound abstraction methods. Such methods extract a reduced model\u00a0\u2026", "num_citations": "199\n", "authors": ["1469"]}
{"title": "SCR: A toolset for specifying and analyzing requirements\n", "abstract": " A set of CASE tools is described for developing formal requirements specifications expressed in the SCR (Software Cost Reduction) tabular notation. The tools include an editor for building the specifications, a consistency checker for testing the specifications for consistency with a formal requirements model, a simulator for symbolically executing the specifications, and a verifier for checking that the specifications satisfy selected application properties. As background, the SCR method for specifying requirements is reviewed and a formal requirements model is introduced. Examples are presented to illustrate the tools.", "num_citations": "196\n", "authors": ["1469"]}
{"title": "Consistency checking of SCR-style requirements specifications\n", "abstract": " The paper describes a class of formal analysis called consistency checking that mechanically checks requirements specifications, expressed in the SCR tabular notation, for application independent properties. Properties include domain coverage, type correctness, and determinism. As background, the SCR notation for specifying requirements is reviewed. A formal requirements model describing the meaning of the SCR notation is summarized, and consistency checks derived from the formal model are described. The results of experiments to evaluate the utility of automated consistency checking are presented. Where consistency checking of requirements fits in the software development process is discussed.", "num_citations": "193\n", "authors": ["1469"]}
{"title": "On the need for practical formal methods\n", "abstract": " A controversial issue in the formal methods community is the degree to which mathematical sophistication and theorem proving skills should be needed to apply a formal method. A fundamental assumption of this paper is that formal methods research has produced several classes of analysis that can prove useful in software development. However, to be useful to software practitioners, most of whom lack advanced mathematical training and theorem proving skills, current formal methods need a number of additional attributes, including more user-friendly notations, completely automatic (i.e., pushbutton) analysis, and useful, easy to understand feedback. Moreover, formal methods need to be integrated into a standard development process. I discuss additional research and engineering that is needed to make the current set of formal methods more practical. To illustrate the ideas, I present several examples\u00a0\u2026", "num_citations": "133\n", "authors": ["1469"]}
{"title": "A benchmark for comparing different approaches for specifying and verifying real-time systems\n", "abstract": " To be considered correct or useful, real-time systems must deliver results within specified time intervals, either without exception or with high probability. Recently, a large number of formal methods have been invented for specifying and verifying real-time systems. It has been suggested that these formal methods need to be tested out on actual real-time systems. Such testing will allow the scalability of the methods to be assessed and also will uncover new problems requiring a formal solution. However, before these methods can be productively applied to industrial systems, greater understanding is needed about how they compare eg, what classes of problems they are designed to solve, the availability of mechanical support, etc.. To provide insight into the utility of different methods for solving real-time problems, the authors have developed a generic version of a real-time railroad crossing system. Their plan is to use this example as a benchmark for comparing different formalisms. In this paper, the authors define the problem, describe three classes of formalisms that can be applied, and summarize efforts currently in progress to specify the system of interest and prove properties about its behavior.Descriptors:", "num_citations": "131\n", "authors": ["1469"]}
{"title": "Tools for constructing requirements specification: the SCR toolset at the age of ten\n", "abstract": " While human effort is critical to creating requirements specifications and human inspection can detect many specification errors, software tools find errors inspections miss and also find certain classes of errors more cheaply. This paper describes a set of tools for constructing and analyzing requirements specifications in the SCR Software Cost Reduction tabular notation. The tools include a specification editor, a consistency checker, a simulator, and tools for verifying application properties including a model checker, a verifier, a property checker based on decision procedures, and an invariant generator. The paper also describes the practical systems to which the tools are being applied as well as some new tools recently added to the toolset, eg a tool that constructs a sound and complete abstraction from a property and a specification. To illustrate the tools, the paper describes their use in developing a requirements specification for an automobile cruise control system.Descriptors:", "num_citations": "120\n", "authors": ["1469"]}
{"title": "Applying formal methods to a certifiably secure software system\n", "abstract": " A major problem in verifying the security of code is that the code's large size makes it much too costly to verify in its entirety. This paper describes a novel and practical approach to verifying the security of code which substantially reduces the cost of verification. In this approach, a compact security model containing only information needed to reason about the security properties of interest is constructed and the security properties are represented formally in terms of the model. To reduce the cost of verification, the code to be verified is partitioned into three categories and only the first category, which is less than 10 percent of the code in our application, requires formal verification. The proof of the other two categories is relatively trivial. Our approach was developed to support a common criteria evaluation of the separation kernel of an embedded software system. This paper describes 1) our techniques and theory for\u00a0\u2026", "num_citations": "117\n", "authors": ["1469"]}
{"title": "Software cost reduction\n", "abstract": " Software Cost Reduction SCR is a set of techniques for designing software systems developed by David Parnas and researchers from the US Naval Research Laboratory NRL beginning in the late 1970s. A major goal of the original SCR research team was to evaluate the utility and scalability of software engineering principles by applying the principles to the reconstruction of software for a practical system, the Operational Flight Program OFP for the US Navys A-7 aircraft. The process of applying the principles produced a number of new techniques for software design, which were demonstrated in a requirements document 18 and several software design documents eg, a module guide 6 for the A-7. Further research during the 1990s produced two formal models, the Four Variable Model 37 and the SCR requirements model 15, and a set of software tools for analyzing SCR-style requirements documents 16.Descriptors:", "num_citations": "115\n", "authors": ["1469"]}
{"title": "Tools for formal specification, verification, and validation of requirements\n", "abstract": " Although formal methods for developing computer systems have been available for more than a decade, few have had significant impact in practice. A major barrier to their use is that software developers find formal methods difficult to understand and apply. One exception is a formal method called SCR for specifying computer system requirements which, due to its easy to use tabular notation and its demonstrated scalability, has already achieved some success in industry. Recently a set of software tools, including a specification editor, a consistency checker, a simulator, and a verifier has been developed to support the SCR method. This paper describes recent enhancements to the SCR tools: a new dependency graph browser which displays the dependencies among the variables in the specification, an improved consistency checker which produces detailed feedback about detected errors, and an assertion\u00a0\u2026", "num_citations": "107\n", "authors": ["1469"]}
{"title": "Automatic generation of state invariants from requirements specifications\n", "abstract": " Automatic generation of state invariants, properties that hold in every reachable state of a state machine model, can be valuable in software development. Not only can such invariants be presented to system users for validation, in addition, they can be used as auxiliary assertions in proving other invariants. This paper describes an algorithm for the automatic generation of state invariants that, in contrast to most other such algorithms, which operate on programs, derives invariants from requirements specifications. Generating invariants from requirements specifications rather than programs has two advantages: 1) because requirements specifications, unlike programs, are at a high level of abstraction, generation of and analysis using such invariants is easier, and 2) using invariants to detect errors during the requirements phase is considerably more cost-effective than using invariants later in software development\u00a0\u2026", "num_citations": "106\n", "authors": ["1469"]}
{"title": "Evaluating two aspects of direct manipulation in advanced cockpits\n", "abstract": " Increasing use of automation in computer systems, such as advanced cockpits, presents special challenges in the design of user interfaces. The challenge is particularly difficult when automation is intermittent because the interface must support smooth transitions from automated to manual mode. A theory of direct manipulation predicts that this interface style will smooth the transition. Interfaces were designed to test the prediction and to evaluate two aspects of direct manipulation, semantic distance and engagement. Empirical results supported the theoretical prediction and also showed that direct engagement can have some adverse effects on another concurrent manual task. Generalizations of our results to other complex systems are presented.", "num_citations": "96\n", "authors": ["1469"]}
{"title": "Formal specification and verification of data separation in a separation kernel for an embedded system\n", "abstract": " Although many algorithms, hardware designs, and security protocols have been formally verified, formal verification of the security of software is still rare. This is due in large part to the large size of software, which results in huge costs for verification. This paper describes a novel and practical approach to formally establishing the security of code. The approach begins with a well-defined set of security properties and, based on the properties, constructs a compact security model containing only information needed to rea-son about the properties. Our approach was formulated to provide evidence for a Common Criteria evaluation of an embedded soft-ware system which uses a separation kernel to enforce data separation. The paper describes 1) our approach to verifying the kernel code and 2) the artifacts used in the evaluation: a Top Level Specification (TLS) of the kernel behavior, a formal definition of\u00a0\u2026", "num_citations": "95\n", "authors": ["1469"]}
{"title": "TAME: A PVS interface to simplify proofs for automata models\n", "abstract": " Although a number of mechanical provers have been introduced and applied widely by academic researchers, these provers are rarely used in the practical development of software. For mechanical provers to be used more widely in practice, two major barriers must be overcome. First, the languages provided by the mechanical provers for expressing the required system behavior must be more natural for software developers. Second, the reasoning steps supported by mechanical provers are usually at too low and detailed a level and therefore discourage use of the prover. To help remove these barriers, we are developing a system called TAME, a high-level user interface to PVS for specifying and proving properties of automata models. TAME provides both a standard specification format for automata models and numerous high-level proof steps appropriate for reasoning about automata models. In previous work, we have shown how TAME can be useful in proving properties about systems described as Lynch-Vaandrager Timed Automata models. TAME has the potential to be used as a PVS interface for other specification methods that are specialized to define automata models. This paper first describes recent improvements to TAME, and then presents our initial results in using TAME to provide theorem proving support for the SCR Software Cost Reduction requirements method, a method with a wide range of other mechanized support.Descriptors:", "num_citations": "81\n", "authors": ["1469"]}
{"title": "MT: A toolset for specifying and analyzing real-time systems\n", "abstract": " This paper introduces MT, a collection of integrated tools for specifying and analyzing real-time systems using the Modechart language. The toolset includes facilities for creating and editing Modechart specifications. Users may symbolically execute the specifications with an automatic simulation tool to make sure that the specified behavior is what was intended. They may also invoke a verifier that uses model-checking to determine whether the specifications imply (satisfy) any of a broad class of safety assertions. To illustrate the toolset's capabilities as well as several issues that arise when formal methods are applied to real-world systems, the paper includes specifications and analysis procedures for a software component taken from an actual Naval real-time system.< >", "num_citations": "81\n", "authors": ["1469"]}
{"title": "Proving invariants of I/O automata with TAME\n", "abstract": " This paper describes a specialized interface to PVS called TAME (Timed Automata Modeling Environment) which provides automated support for proving properties of I/O automata. A major goal of TAME is to allow a software developer to use PVS to specify and prove properties of an I/O automaton efficiently and without first becoming a PVS expert. To accomplish this goal, TAME provides a template that the user completes to specify an I/O automaton and a set of proof steps natural for humans to use for proving properties of automata. Each proof step is implemented by a PVS strategy and possibly some auxiliary theories that support that strategy. We have used the results of two recent formal methods studies as a basis for two case studies to evaluate TAME. In the first formal methods study, Romijn used I/O automata to specify and verify memory and remote procedure call components of a concurrent\u00a0\u2026", "num_citations": "79\n", "authors": ["1469"]}
{"title": "Verifying SCR requirements specifications using state exploration\n", "abstract": " Researchers at the Naval Research Laboratory NRL have been developing a formal method, known as the SCR Software Cost Reduction method, to specify the requirements of software systems using tables. NRL has developed a formal state machine model defining the SCR semantics and support tools for analysis and validation. Recently, a verification capability was added to the SCR toolset. Users can now invoke the Spin model checker within the toolset to establish properties of a specification. This paper describes the results of our initial experiments to verify properties of SCR requirements specifications using Spin. After reviewing the SCR requirements method and introducing our formal requirements model, we describe how SCR specifications can be translated into an imperative programming notation. We also describe how we limit state explosion by verifying abstractions of the original requirements specification. These abstractions are derived using the formula to be verified and special attributes of SCR specifications. The paper concludes with the results of our experiments with Spin and a discussion of ongoing and future work.Descriptors:", "num_citations": "64\n", "authors": ["1469"]}
{"title": "Mechanical verification of timed automata: A case study\n", "abstract": " The paper reports the results of a case study on the feasibility of developing and applying mechanical methods, based on the proof system PVS, to prove propositions about real time systems specified in the Lynch-Vaandrager timed automata model. In using automated provers to prove propositions about systems described by a specific mathematical model, both the proofs and the proof process can be simplified by exploiting the spectral properties of the mathematical model. The paper presents the PVS specification of three theories that underlie the timed automata model, a template for specifying timed automata models in PVS and an example of its instantiation, and both hand proofs and the corresponding PVS proofs of two propositions. It concludes with a discussion of our experience in applying PVS to specify and reason about real time systems modeled as timed automata.", "num_citations": "64\n", "authors": ["1469"]}
{"title": "Abstract Requirements Specification: A New Approach and Its Application\n", "abstract": " An abstract requirements specification states system requirements precisely without describing a real or a paradigm implementation. Although such specifications have important advantages, they are difficult to produce for complex systems and hence are seldom seen in the \"real\" programming world. This paper introduces an approach to producing abstract requirements specifications that applies to a significant class of real-world systems, including any system that must reconstruct data that have undergone a sequence of transformations. tions. It also describes how the approach was used to produce a requirements document for SCP, a small, but nontrivial Navy communications system. The specification techniques used in the SCP requirements document are introduced and illustrated with examples.", "num_citations": "62\n", "authors": ["1469"]}
{"title": "The SCR method for formally specifying, verifying, and validating requirements: tool support\n", "abstract": " SCR*, a set of tools for developing requirements specifications for real-time embedded systems, is described. The tools, which are based on a formal requirements model, include a specification editor, a consistency checker, and a simulator. Recent additions to SCR* are a dependency graph broJvser and a verifier.", "num_citations": "61\n", "authors": ["1469"]}
{"title": "Applying the SCR requirements method to the light control case study\n", "abstract": " To date, the SCR (Software Cost Reduction) requirements method has been used in industrial environments to specify the requirements of many practical systems, including control systems for nuclear power plants and avionics systems. This paper describes the use of the SCR method to specify the requirements of the Light Control System (LCS), the subject of a case study at the Dagstuhl Seminar on Requirements Capture, Documentation, and Validation in June 1999. It introduces a systematic process for constructing the LCS requirements specification, presents the specification of the LCS in the SCR tabular notation, discusses the tools that we applied to the LCS specification, and concludes with a discussion of a number of issues that arose in developing the specification.", "num_citations": "51\n", "authors": ["1469"]}
{"title": "Program synthesis from formal requirements specifications using APTS\n", "abstract": " Formal specifications of software systems are extremely useful because they can be rigorously analyzed, verified, and validated, giving high confidence that the specification captures the desired behavior. To transfer this confidence to the actual source code implementation, a formal link is needed between the specification and the implementation. Generating the implementation directly from the specification provides one such link. A program transformation system such as Paige's APTS can be useful in developing a source code generator. This paper describes a case study in which APTS was used to produce code generators that construct C source code from a requirements specification in the SCR (Software Cost Reduction) tabular notation. In the study, two different code generation strategies were explored. The first strategy uses rewrite rules to transform the parse tree of an SCR specification into a\u00a0\u2026", "num_citations": "46\n", "authors": ["1469"]}
{"title": "Developing high assurance avionics systems with the SCR requirements method\n", "abstract": " The SCR (Software Cost Reduction) requirements method is a formal method based on tables for the specification and analysis of the required behavior of safety-critical software systems. Originally developed in 1978 by NRL (Naval Research Laboratory) to document the flight program requirements of the Navy's A-7 aircraft, SCR has also been applied by a number of organizations in industry to a wide range of practical systems, including avionics and space systems. For example, in 1994, in the largest application of SCR to date, Lockheed used SCR to specify the requirements of the C-130J flight control software, which contains more than 250,000 lines of Ada code. To provide tool support for the SCR method, our group at NRL has developed an integrated suite of tools called the SCR toolset. The toolset includes a consistency checker for checking the specification for type errors and missing cases.", "num_citations": "45\n", "authors": ["1469"]}
{"title": "Verifying hybrid systems modeled as timed automata: A case study\n", "abstract": " Verifying properties of hybrid systems can be highly complex. To reduce the effort required to produce a correct proof, the use of mechanical verification techniques is promising. Recently, we extended a mechanical verification system, originally developed to reason about deterministic real-time automata, to verify properties of hybrid systems. To evaluate our approach, we applied our extended proof system to a solution, based on the Lynch-Vaandrager timed automata model, of the Steam Boiler Controller problem, a hybrid systems benchmark. This paper reviews our mechanical verification system, which builds on SRI's Prototype Verification System (PVS), and describes the features we added to handle hybrid systems. It also discusses some errors we detected in applying our system to the benchmark problem. We conclude with a summary of insights we acquired in using our system to specify and verify\u00a0\u2026", "num_citations": "45\n", "authors": ["1469"]}
{"title": "A strategy for efficiently verifying requirements\n", "abstract": " This paper describes a compositional proof strategy for verifying properties of requirements specifications. The proof strategy, which may be applied using either a model checker or a theorem prover, uses known state invariants to prove state and transition invariants. Two proof rules are presented: a standard incremental proof rule analogous to Manna and Pnueli's incremental proof rule and a compositional proof rule. The advantage of applying the compositional rule is that it decomposes a large verification problem into smaller problems which often can be solved more efficiently than the larger problem. The steps needed to implement the compositional rule are described, and the results of applying the proof strategy to two examples, a simple cruise control system and a real-world Navy system, are presented. In the Navy example, compositional verification %based on the compositional proof using either theorem\u00a0\u2026", "num_citations": "41\n", "authors": ["1469"]}
{"title": "Human-style theorem proving using PVS\n", "abstract": " A major barrier to more common use of mechanical theorem provers in verifying software designs is the significant distance between proof styles natural to humans and proof styles supported by mechanical provers. To make mechanical provers useful to software designers with some mathematical sophistication but without expertise in mechanical provers, the distance between hand proofs and their mechanized versions must be reduced. To achieve this, we are developing a mechanical prover called TAME on top of PVS. TAME is designed to process proof steps that resemble in style and size the typical steps in hand proofs. TAME's support of more natural proof steps should not only facilitate mechanized checking of hand proofs, but in addition should provide assurance that theorems proved mechanically are true for the reasons expected and also provide a basis for conceptual level feedback when a\u00a0\u2026", "num_citations": "41\n", "authors": ["1469"]}
{"title": "Formal methods for specifying, validating, and verifying requirements.\n", "abstract": " This paper describes the specification, validation and verification of system and software requirements using the SCR tabular method and tools. An example is presented to illustrate the SCR tabular notation, and an overview of each of the ten tools in the SCR toolset is presented.", "num_citations": "40\n", "authors": ["1469"]}
{"title": "SCR: A practical approach to building a high assurance COMSEC system\n", "abstract": " To date, the tabular based SCR (Software Cost Reduction) method has been applied mostly to the development of embedded control systems. The paper describes the successful application of the SCR method, including the SCR* toolset, to a different class of system, a COMSEC (Communications Security) device called CD that must correctly manage encrypted communications. The paper summarizes how the tools in SCR* were used to validate and to debug the SCR specification and to demonstrate that the specification satisfies a set of critical security properties. The development of the CD specification involved many tools in SCR*: a specification editor, a consistency checker, a simulator, the TAME interface to the theorem prover PVS, and various other analysis tools. Our experience provides evidence that use of the SCR* toolset to develop high quality requirements specifications of moderately complex\u00a0\u2026", "num_citations": "40\n", "authors": ["1469"]}
{"title": "An algorithm for strengthening state invariants generated from requirements specifications\n", "abstract": " In earlier work (Jeffords and Heitmeyer, 1998) we developed a fixpoint algorithm for automatically generating state invariants, properties that hold in each reachable state of a state machine model, from state-based requirements specifications. Such invariants are useful both in validating requirements specifications and as auxiliary lemmas in proofs that a requirements specification satisfies other invariant properties. This paper describes a new related algorithm that strengthens state invariants generated by our initial algorithm and demonstrates the new algorithm on a simplified version of an automobile cruise control system. The paper concludes by describing how the two algorithms were used to generate state invariants from a requirements specification of a cryptographic device and how the invariants in conjunction with a theorem prover were used to prove formally that the device satisfies a set of critical security\u00a0\u2026", "num_citations": "37\n", "authors": ["1469"]}
{"title": "Applying Practical formal methods to the specification and analysis of security properties\n", "abstract": " The SCR (Software Cost Reduction) toolset contains tools for specifying, debugging, and verifying system and software requirements. The utility of the SCR tools in detecting specification errors, many involving safety properties, has been demonstrated recently in projects involving practical systems, such as the International Space Station, a flight guidance system, and a U.S. weapons system. This paper briefly describes our experience in applying the tools in the development of two secure systems: a communications device and a biometrics standard for user authentication.", "num_citations": "37\n", "authors": ["1469"]}
{"title": "Applying the SCR requirements method to a weapons control panel: An experience report\n", "abstract": " ABSTRACT A major barrier to the use of formal methods in software practice is the difllculty software developers have understanding and applying the methods. To overcome this barrier, a requirements method called SCR (Software Cost Reduction) offers a user-friendly tabular notation to specify software requirements and a collection of easytouse tools that automatically detect many classes of errors in requirements specifications. This paper describes our experience in applying the SCR method and tools to a safety-critical military application-the problems encountered in translating the original contractorproduced software requirements specification into SCR and the lessons learned in applying the SCR technology to a practical system. The short time required to apply the SCR method, the serious safety violation detected, and the working system prototype produced demonstrate the utility and potential cost\u00a0\u2026", "num_citations": "34\n", "authors": ["1469"]}
{"title": "Direct manipulation and intermittent automation in advanced cockpits\n", "abstract": " Increasing use of automation in computer systems, such as advanced cockpits, present special challenges in the design of user interfaces. The challenge is particularly difficult when automation is intermittent because the interface must support smooth transitions from automated to manual mode. A theory of direct manipulation predicts that this interface style will smooth the transition. Interfaces were designed to test the prediction and to evaluate two aspects of direct manipulation semantic distance and engagement. Empirical results supported the theoretical prediction and also showed that direct engagement can have some adverse effects on another concurrent manual task. Generalizations of our results to other complex systems are presented. Direct manipulation, Adaptive automation, Intelligent cockpit, Interface style, Intermittent automation, Interface design, Aircraft interface.Descriptors:", "num_citations": "31\n", "authors": ["1469"]}
{"title": "Generating optimized code from SCR specifications\n", "abstract": " A promising trend in software development is the increasing adoption of model-driven design. In this approach, a developer first constructs an abstract model of the required program behavior in a language, such as Statecharts or Stateflow, and then uses a code generator to automatically transform the model into an executable program. This approach has many advantages---typically, a model is not only more concise than code and hence more understandable, it is also more amenable to mechanized analysis. Moreover, automatic generation of code from a model usually produces code with fewer errors than hand-crafted code.One serious problem, however, is that a code generator may produce inefficient code. To address this problem, this paper describes a method for generating efficient code from SCR (Software Cost Reduction) specifications. While the SCR tabular notation and tools have been used\u00a0\u2026", "num_citations": "30\n", "authors": ["1469"]}
{"title": "Hardware/software co-design and co-validation using the SCR method\n", "abstract": " To date, the SCR Software Cost Reduction method has been used to specify system requirements. This paper extends the SCR method to hardwaresoftware co-design and co-validation. Our approach consists of three steps. First, the SCR method is used to specify the required system behavior, ie, the required relation between environmental quantities called monitored quantities that the system monitors and environmental quantities called controlled quantities that the system controls. Next, the system designers specify the IO devices required to compute estimates of the monitored quantities and to set values of the controlled quantities. Finally, the required software behavior is specified as three modules a device-independent module, specifying how the estimated monitored quantities are to be used to compute estimates of the controlled quantities, and two device-dependent modules an input device interface module, specifying how data from the input devices are to be used to compute estimates of the monitored quantities, and an output device interface module, specifying how the values of controlled variables are written to output devices. To illustrate the approach, we use SCR to specify a simple light control system.Descriptors:", "num_citations": "29\n", "authors": ["1469"]}
{"title": "High assurance computer systems: A research agenda\n", "abstract": " As computers and their supporting communication networks have become increasingly enmeshed in our national technological fabric, we have become increasingly dependent on high assurance computer systems, ie, computer systems for which compelling evidence is required that the system delivers its services in a manner that satisfies certain critical properties. Obvious examples of high assurance systems include military systems eg, weapon systems, C4I systems, etc, flight programs for both commercial and military aircraft, air traffic control systems, financial and commerce systems, medical systems including medical databases and medical equipment, etc. Less obvious examples are the various components of the information infrastructure that supports such systems and their communications eg, the NII. These systems are extremely complicated and the science and engineering principles that underlie them are yet to be completely worked out. Nevertheless, our national well-being depends upon these systems satisfying certain critical properties including security properties, which prevent unauthorized disclosure, modification, and withholding of sensitive information, even when under attack by a hostile agent safety properties, which prevent unintended events that result in death, injury, illness, or damage to or loss of propertyDescriptors:", "num_citations": "28\n", "authors": ["1469"]}
{"title": "Applying a formal requirements method to three NASA systems: Lessons learned\n", "abstract": " Recently, a formal requirements method called SCR (software cost reduction) was used to specify software requirements of mission-critical components of three NASA systems. The components included a fault protection engine, which determines how a spacecraft should respond to a detected fault; a fault detection, isolation and recovery component, which, in response to an undesirable event, outputs a failure notification and raises one or more alarms; and a display system, which allows a space crew to monitor and control on-orbit scientific experiments. This paper demonstrates how significant and complex requirements of one of the components can be translated into an SCR specification and describes the errors detected when the authors formulated the requirements in SCR. It also discusses lessons learned in using formal methods to document the software requirements of the three components. Based on\u00a0\u2026", "num_citations": "27\n", "authors": ["1469"]}
{"title": "TAME: A specialized specification and verification system for timed automata\n", "abstract": " Assuring the correctness of specifications of real-time systems can involve significant human effort. The use of a mechanical theorem prover to encode such specifications and to verify their properties could significantly reduce this effort. A barrier to routinely encoding and mechanically verifying specifications has been the need first to master the specification language and logic of a general theorem proving system. Our approach to overcoming this barrier is to provide mechanical support for producing specifications and verifying proofs, specialized for particular mathematical models and proof techniques. We are currently developing a mechanical verification system called TAME Timed Automata Modeling Environment that provides this specialized support using SRIs Prototype Verification System PVS. Our system is intended to permit steps in reasoning similar to those in hand proofs that use model-specific techniques. TAME has recently been used to detect errors in a realistic example.Descriptors:", "num_citations": "25\n", "authors": ["1469"]}
{"title": "Formal verification of real-time systems using timed automata\n", "abstract": " The use of the Lynch-Vaandrager timed automaton model is illustrated with a solution to the Generalized Railroad Crossing problem. The solution shows formally the corre-spondence between four system descriptions: an axiomatic (ie, descriptive) specification, an operational specification represented in terms of timed automata, a discrete system implementation, and a system implementation that works with a continuous gate model.", "num_citations": "24\n", "authors": ["1469"]}
{"title": "A security model for military message systems: Retrospective\n", "abstract": " We favor an approach to building secure systems that includes an application-based security model. An instance of such a model and its formalization have been presented. Important aspects of the model are: (1) because it is framed in terms of operations and data objects that the user sees, the model captures the system's security requirements in a way that is understandable to users; (2) the model defines a hierarchy of entities and references; access to an entity can be controlled based on the path used to refer to it; (3) because the model avoids specifying implementation strategies, software developers are free to choose the most effective implementation; (4) the model and its formalization provide a basis for certifiers to assess the security of the system as a whole. Simplicity and clarity in the model's statement have been primary goals. The model's statement does not, however, disguise the complexity that is\u00a0\u2026", "num_citations": "23\n", "authors": ["1469"]}
{"title": "Consistency checks for SCR-style requirements specifications\n", "abstract": " This report describes a class of software tools that check formal requirements specifications for consistency with a requirements model. The model, which describes properties of requirements specifications based on the SCR Software Cost Reduction approach to requirements, is summarized. Two experiments are described in which condition tables and mode transition tables in an updated version of the A-7 requirements document were checked for selected properties using tools we developed. The significant number of errors found by the tools is summarized. Tool-based techniques and manual techniques for performing consistency checks are compared, and several additional consistency checks, derived from the formal model, are identified. Our work is compared with related work by Parnas and SRI concerning the automated checking of tabular specifications. Conclusions are presented concerning the utility, cost, and scalability of tool-based consistency checking.Descriptors:", "num_citations": "23\n", "authors": ["1469"]}
{"title": "Using the SCR* toolset to specify software requirements\n", "abstract": " Formulated in the late 1970s to specify the requirements of the Operational Flight Program of the A-7 aircraft, the SCR (Software Cost Reduction) requirements method is a method based on tables for specifying the requirements of software systems. During the 1980s and the early 1990s, many companies, including Bell Laboratories, Grumman, Ontario Hydro, and Lockheed, applied the SCR requirements method to practical systems. Each of these applications of SCR had, at most, weak tool support. To provide powerful, robust tool support customized for the SCR method, we have developed the SCR* toolset. To provide formal underpinnings for the method, we have also developed a formal model which defines the semantics of SCR requirements specifications.", "num_citations": "22\n", "authors": ["1469"]}
{"title": "A formal method for developing provably correct fault-tolerant systems using partial refinement and composition\n", "abstract": " It is widely agreed that building correct fault-tolerant systems is very difficult. To address this problem, this paper introduces a new model-based approach for developing masking fault-tolerant systems. As in component-based software development, two (or more) component specifications are developed, one implementing the required normal behavior and the other(s) the required fault-handling behavior. The specification of the required normal behavior is verified to satisfy system properties, whereas each specification of the required fault-handling behavior is shown to satisfy both system properties, typically weakened, and fault-tolerance properties, both of which can then be inferred of the composed fault-tolerant system. The paper presents the formal foundations of our approach, including a new notion of partial refinement and two compositional proof rules. To demonstrate and validate the approach, the\u00a0\u2026", "num_citations": "21\n", "authors": ["1469"]}
{"title": "Managing complexity in software development with formally based tools\n", "abstract": " Over the past two decades, formal methods researchers have produced a number of powerful software tools designed to detect errors in, and to verify properties of, hardware designs, software systems, and software system artifacts. Mostly used in the past to debug hardware designs, in future years, these tools should help developers improve the quality of software systems. They should be especially useful in developing high assurance software systems, where compelling evidence is required that the system satisfies critical properties, such as safety and security. This paper describes the different roles that formally based software tools can play in improving the correctness of software and software artifacts. Such tools can help developers manage complexity by automatically exposing certain classes of software errors and by producing evidence (e.g., mechanically checked proofs, results of executing automatically\u00a0\u2026", "num_citations": "21\n", "authors": ["1469"]}
{"title": "A formal statement of the MMS security model\n", "abstract": " To provide a firm foundation for proofs about the security properties of a system specification or implementation, a formal statement of its security model is needed. This paper presents a formal model that corresponds to an informal, application-based security model for military message systems (MMS) that has been documented elsewhere. Following the formal statement, some considerations that led to its present form are discussed. The paper concludes with the statement of a \"Basic Security Theorem\" for the model.", "num_citations": "20\n", "authors": ["1469"]}
{"title": "Automated tools for building secure software programs\n", "abstract": " A computer implemented tool is described that includes an assertion generator module that can automatically generate assertions, which are usable to verify application-specific security properties, for a computer software program. An assertion checker module can automatically analyze the computer software program to ensure that it satisfies the application-specific security properties. A graphical user interface module can display feedback to diagnose security flaws detected in the computer software program based on the analysis by the assertion checker module. In support of these modules are a code preprocessor module that can translate source code of the computer software program into an intermediate abstract representation, and a database module that can store the generated assertions and associated data in a database. Each of the modules can provide functionality at any time during code construction\u00a0\u2026", "num_citations": "19\n", "authors": ["1469"]}
{"title": "Applying the SCR requirements method to a simple autopilot\n", "abstract": " Although formal methods for developing computer systems have been available for more than a decade, few have had significant impact in practice. A major barrier to their use is that developers find formal methods difficult to understand and apply. One exception is a formal method called SCR for specifying computer system requirements which, due to its easy-to-use tabular notation and demonstrated scalability, has achieved some success in industry. To demonstrate and evaluate the SCR method and tools, we recently used SCR to specify the requirements of a simplified mode control panel for the Boeing 737 autopilot. This paper presents the SCR requirements specification of the autopilot, outlines the process we used to create the SCR specification from a prose description, and discusses the problems and questions that arose in developing the specification. Formalizing and analyzing the requirements specification in SCR uncovered a number of problems with the original prose description, such as incorrect assumptions about the environment, incompleteness, and inconsistency. The paper also introduces a new tabular format we found useful in understanding and analyzing the required behavior of the autopilot. Finally, the paper compares the SCR approach to requirements with that of Butler 5, who uses the PVS language and prover 14 to represent and analyze the autopilot requirements.Descriptors:", "num_citations": "19\n", "authors": ["1469"]}
{"title": "The use of quick prototypes in the secure military message systems project\n", "abstract": " This paper describes the role of quick prototyping in the Secure Military Message Systems project. The issues that are being explored with quick prototyping are identified. To date, a small prototype message system written in Franz Lisp has been implemented on a Vax 11/780. The guidelines observed and the lessons learned in constructing the prototype are discussed.", "num_citations": "19\n", "authors": ["1469"]}
{"title": "On the role of formal methods in software certification: An experience report\n", "abstract": " This paper describes how formal methods were used to produce evidence in a certification, based on the Common Criteria, of a security-critical software system. The evidence included a top level specification (TLS) of the security-relevant software behavior, a formal statement of the required security properties, proofs that the specification satisfied the properties, and a demonstration that the source code, which had been annotated with preconditions and postconditions, was a refinement of the TLS. The paper also describes those aspects of our approach which were most effective and research that could significantly increase the effectiveness of formal methods in software certification.", "num_citations": "18\n", "authors": ["1469"]}
{"title": "Applying formal methods to an information security device: An experience report\n", "abstract": " SCR (Software Cost Reduction) is a formal method for specifying and analyzing system requirements that has previously been applied to control systems. This paper describes a case study in which the SCR method was used to specify and analyze a different class of system, a cryptographic system called CD, which must satisfy a large set of security properties. The paper describes how a suite of tools supporting SCR-a consistency checker, simulator, model checker, invariant generator, theorem prover, and validity checker-were used to detect errors in the SCR specification of CD and to verify that the specification satisfies seven security properties. The paper also describes issues of concern to software developers about formal methods, e.g. ease of use, cost-effectiveness, scalability, how to translate a prose specification into a formal notation, and what process to follow in applying a formal method and discusses\u00a0\u2026", "num_citations": "18\n", "authors": ["1469"]}
{"title": "Obtaining trust in autonomous systems: Tools for formal model synthesis and validation\n", "abstract": " An important and growing class of cyber physical systems are autonomous vehicles (AVs). While the U.S. Military has used AVs, such as unmanned air vehicles, for many years, civilian use of these vehicles, e.g., By the FBI, has been steadily increasing. Plans to equip AVs with cameras, scientific instruments, and weapons, such as tear gas and pepper spray, have led to growing mistrust of AVs and calls for greater human control and oversight. This paper describes two kinds of trust needed in systems involving AVs and how a formal model and model-based simulation can help obtain such trust. It introduces two new tools to be integrated into Formal Requirements Modeling and Analysis (FORMAL), an upgrade of NRL's Software Cost Reduction (SCR) toolset, the new tools support formal modeling and symbolic execution (via simulation) of cyber physical systems. The first tool synthesizes a formal model from\u00a0\u2026", "num_citations": "17\n", "authors": ["1469"]}
{"title": "An approach to monitoring and assertion-checking of real-time specifications\n", "abstract": " The paper describes the development of a monitoring and assertion checking tool, MAC, which supports monitoring of symbolic execution traces generated by the Modechart Toolset, permitting testing of specifications early in the design phase and providing a mechanism for evaluating properties of the system on a particular execution trace. This approach avoids many of the difficulties of run time monitoring and testing such as interference and the probe effect. Monitoring and assertion checking capabilities are provided by the automatic translation of assertions in a declarative language (such as Real Time Logic) into monitoring fragments, written in Modechart, which augment the original specification to perform monitoring and assertion checking during simulation.", "num_citations": "17\n", "authors": ["1469"]}
{"title": "Requirements specifications for hybrid systems\n", "abstract": " We have presented several examples to show how the SCR requirements model can be extended to specify and to reason about hybrid systems. The next step is to extend the formal definition of the SCR model to include continuous variables, time, and accuracy. By adding such information to system and software requirements specifications, we can provide precise guidance to the developers of computer systems and a formal foundation for analyzing the behavior of these systems.", "num_citations": "17\n", "authors": ["1469"]}
{"title": "Using TAME to prove invariants of automata models: Two case studies\n", "abstract": " TAME is a special-purpose interface to PVS designed to support developers of software systems in proving properties of automata models. One of TAME's major goals is to allow a software developer who has basic knowledge of standard logic, and can do hand proofs, to use PVS to represent and to prove properties about an automaton model without first becoming a PVS expert. A second goal is for a human to be able to read and understand the content of saved TAME proofs without running them through the PVS proof checker. A third goal is to make proving properties of automata with TAME less costly in human time than proving such properties using PVS directly. Recent work by Romijn and Devillers et al., based on the I/O automata model, has provided the basis for two case studies on how well TAME achieves these goals. Romijn specified the RPC-Memory Problem and its solution, while Devillers et al\u00a0\u2026", "num_citations": "16\n", "authors": ["1469"]}
{"title": "SCR: a practical method for requirements specification\n", "abstract": " A controversial issue in the formal methods research community is the degree to which mathematical sophistication and theorem proving skills should be needed to apply a formal method. A premise of this paper is that formal methods research has produced several techniques with potential utility in practical software development, but that mathematical sophistication and theorem proving skills should not be prerequisites for using these techniques. In the paper, several attributes needed to make a formal method useful in practice are described. These attributes include user-friendly notation, automated (i.e., push-button) analysis, and easy to understand feedback. To illustrate the attributes of a practical formal method, a formal method for requirements specification called SCR (Software Cost Reduction) is introduced.", "num_citations": "16\n", "authors": ["1469"]}
{"title": "Military message systems: Current status and future directions\n", "abstract": " The need for timely message delivery coupled with decreasing computer costs is causing message handling in the Department of Defense to be increasingly automated. This paper describes the functional, security, and performance requirements of automated military message systems. In light of these requirements, four operational message systems are compared and contrasted. A summary of results is presented for the Military Message Experiment, a study of the military utility of automated message systems. The usefulness of advanced software engineering technology, especially the family methodology, is explored for military message automation. Finally, several trends and research issues in military message handling are identified.", "num_citations": "16\n", "authors": ["1469"]}
{"title": "Applying the SCR requirements specification method to practical systems: A case study\n", "abstract": " Studies have shown that the majority of errors in software systems are due to incorrect requirements specifications. The root cause of many requirements errors is the imprecision and ambiguity that arise because the software requirements are expressed in natural language. An effective way to reduce such errors is to express requirements in a formal notation. For a number of years, researchers at the Naval Research Laboratory NRL have been working on a formal method based on tables to specify the requirements of practical systems 2, 11. Known as the Software Cost Reduction SCR method, this approach was originally formulated to document the requirements of the Operational Flight Program OFP for the US Navys A-7 aircraft 2. Since SCRs introduction more than a decade ago, many industrial organizations, including Lockheed, Grumman, and Ontario Hydro, have used SCR to specify requirements. Recently, NRL has developed both a formal state machine model 12, 14 to define the SCR semantics and a set of software tools to support analysis and validation of SCR requirements specifications 10. The tools support consistency and completeness checking, simulation, and model checking.Descriptors:", "num_citations": "15\n", "authors": ["1469"]}
{"title": "Engineering CASE tools to support formal methods for real-time software development\n", "abstract": " A prototype toolset that provides comprehensive support for constructing verifiably correct real-time systems is described. The toolset supports the development of specifications in the graphical Modechart language and several methods for improving the correctness of the specifications, including formal verification, simulation, and consistency and completeness checking. An engineering approach for developing the toolset is presented that integrates software engineering principles, prototyping, and early and continued focus on user interface design. Contributions that the toolset effort makes to computer-aided software engineering (CASE) support for formal methods are summarized.<>", "num_citations": "15\n", "authors": ["1469"]}
{"title": "Developing safety-critical systems: the role of formal methods and tools\n", "abstract": " In recent years, many formal methods have been proposed to improve the quality of safety-critical software systems. These methods include new specification and modeling languages as well as formal verification techniques, such as model checking and theorem proving. This paper describes numerous ways in which tools supporting formal methods can improve the quality of both software code as well as software specifications and models. However, while promising, formal methods and their support tools are rarely used in software practice. To overcome this problem, I propose several needed improvements, which could lead to more widespread use of formal methods in the development of safety-critical systems and software.", "num_citations": "14\n", "authors": ["1469"]}
{"title": "Formal methods: A panacea or academic poppycock?\n", "abstract": " Much has been written in the past decade about the usefulness of formal methods for developing computer systems. In this talk, I describe first what I mean by a formal method, discuss some systems to which formal methods have been successfully applied recently, and present several guidelines that I and my colleagues have found useful in applying formal methods in the development of practical systems and software. I conclude with a summary of what has been accomplished to date and why some skepticism about the utility of formal methods in computer system development remains well-founded.", "num_citations": "14\n", "authors": ["1469"]}
{"title": "Requirements specification of hard real-time systems: Experience with a language and a verifier\n", "abstract": " An informal description is presented of the Modechart language and a mechanical verifier, both products of the University  of Texas SARTOR project. Modechart specifications and timing assertions are provided for two real-time examples, the second  a nontrivial function extracted from an existing avionics system. Based on NRL\u2019s experience with specifying and verifying  these examples, Modechart and the verifier are evaluated, and recommendations for improvements and enhancements are presented.  Topics for future research in real-time specification and verification are described.", "num_citations": "14\n", "authors": ["1469"]}
{"title": "Building high assurance human-centric decision systems\n", "abstract": " Many future decision support systems will be human-centric, i.e., require substantial human oversight and control. Because these systems often provide critical services, high assurance is needed that they satisfy their requirements. This paper, the product of an interdisciplinary research team of experts in formal methods, adaptive agents, and cognitive science, addresses this problem by proposing a new process for developing high assurance human-centric decision systems. This process uses AI (artificial intelligence) methods\u2014i.e., a cognitive model to predict human behavior and an adaptive agent to assist the human\u2014to improve system performance, and software engineering methods\u2014i.e., formal modeling and analysis\u2014to obtain high assurance that the system behaves as intended. The paper describes a new method for synthesizing a formal system model from Event Sequence Charts, a variant of\u00a0\u2026", "num_citations": "13\n", "authors": ["1469"]}
{"title": "Model-based construction and verification of critical systems using composition and partial refinement\n", "abstract": " This article introduces a new model-based method for incrementally constructing critical systems and illustrates its application to the development of fault-tolerant systems. The method relies on a special form of composition to combine software components and a set of proof rules to obtain high confidence of the correctness of the composed system. As in conventional component-based software development, two (or more) components are combined, but in contrast to many component-based approaches used in practice, which combine components consisting of code, our method combines components represented as state machine models. In the first phase of the method, a model is developed of the normal system behavior, and system properties are shown to hold in the model. In the second phase, a model of the required fault-handling behavior is developed and \u201cor-composed\u201d with the original system\u00a0\u2026", "num_citations": "12\n", "authors": ["1469"]}
{"title": "Applying infinite state model checking and other analysis techniques to tabular requirements specifications of safety-critical systems\n", "abstract": " Although it is most often applied to finite state models, in recent years, symbolic model checking has been extended to infinite state models using symbolic representations that encode infinite sets. This paper investigates the application of an infinite state symbolic model checker called Action Language Verifier (ALV) to formal requirements specifications of safety-critical systems represented in the SCR (Software Cost Reduction) tabular notation. After reviewing the SCR method and tools, the Action Language for representing state machine models, and the ALV infinite state model checker, the paper presents experimental results of formally analyzing two SCR specifications using ALV. The application of ALV to verify or falsify (by generating counterexample behaviors) the state and transition invariants of SCR specifications and to check Disjointness and Coverage properties is described. The results of formal\u00a0\u2026", "num_citations": "12\n", "authors": ["1469"]}
{"title": "Applying formal methods to an embedded real-time avionics system\n", "abstract": " The authors present an application of formal development methodology to an actual real-time embedded system. The formal methods used are based on Modechart a graphical state specification language for real-time systems, whose formal semantic definition provides the basis for analysis. The specifications may be automatically simulated, or verified with respect to user-provided safety, liveness, and timing assertions. The application is of non-toy size and functionality, and features many state-of-the-practice design properties, such as parallel priority-based synchronizing processes with preemption.< >", "num_citations": "12\n", "authors": ["1469"]}
{"title": "Military Message Systems: Requirements and Security Model.\n", "abstract": " Military systems that process classified information must operate in a secure manner, ie, they must adequately protect information against unauthorized disclosure, modification, and withholding. A goal of current research in computer security is to facilitate the construction of multilevel secure systems, ie, systems that protect information of different classifications from users with different clearances. Security models are used to define the concept of security embodied by a computer system. A single model, called the Bell and LaPadula model, has dominated recent efforts to build secure systems but has some deficiencies. We are developing a new approach to defining security models based on the idea that a security model should be derived from a specific application. To evaluate our approach, we are formulating a security model for a family of military message systems. This paper introduces the message system application, summarizes our approach to developing a family of secure message systems, presents our security model, and summarizes our plans. AuthorDescriptors:", "num_citations": "11\n", "authors": ["1469"]}
{"title": "Automatic program generation from formal specifications using APTS\n", "abstract": " A promising trend in software practice is the increasing adoption of model-driven design. In this approach, a developer first constructs an abstract specification of the required program behavior in a language, such as Statecharts, Stateflow, or LUSTRE, and then uses a code generator to automatically translate the specification into an executable program. This approach has major advantages over more traditional approaches. First, because a specification is more concise, it is usually more understandable than code, and hence manual inspections can detect more errors in specifications than in code. Second, a specification is also more amenable to both user validation (e.g., via simulation) and formal verification, which together provide high confidence that the specification captures the desired behavior. Finally, the automatic generation of source code usually produces software with fewer errors than\u00a0\u2026", "num_citations": "9\n", "authors": ["1469"]}
{"title": "A flexible, extensible simulation environment for testing real-time specifications\n", "abstract": " This paper describes MTSim, an extensible, customizable simulation platform for the Modechart toolset (MT). MTSim provides support for \"plugging in\" user-defined viewers useful in simulating system behavior in different ways, including application-specific ways. MTSim also supports full user participation in the generation of simulations by allowing users to inject events into the execution trace. Moreover, MTSim provides monitoring and assertion checking of execution traces and the invocation of user-specified handlers upon assertion violation. This paper also introduces an MTSim component called WebSim, a suite of simulation tools for MT, and an application-specific component of MTSim which displays the cockpit of an F-18 aircraft and which responds to user inputs to model a bomb release function.", "num_citations": "9\n", "authors": ["1469"]}
{"title": "A panacea or academic poppycock: Formal methods revisited\n", "abstract": " Many formal methods have been proposed to improve software quality. These include new specification and modeling languages as well as formal verification techniques, such as model checking and theorem proving. This paper describes several ways in which tools supporting formal methods can help improve the quality of both software code as well as software specifications and models. However, while promising, formal methods and their support tools are rarely used in practical software development. To overcome this problem, this paper describes a number of needed improvements - in techniques for requirements capture, in languages, in specifications and models, in code quality, and in code verification techniques - which could lead to more widespread use of formal methods and their support tools in practical software development.", "num_citations": "8\n", "authors": ["1469"]}
{"title": "Using TAME to prove invariants of automata models: Case studies\n", "abstract": " TAME is a special-purpose interface to PVS designed to support developers of software systems in proving properties of automata models. One of TAME's major goals is to allow a software developer who has basic knowledge of standard logic, and can do hand proofs, to use PVS to represent and to prove properties about an automaton model without first becoming a PVS expert. A second goal is for a human to be able to read and understand the content of saved TAME proofs without running them through the PVS proof checker. A third goal is to make proving properties of automata with TAME less costly in human time than proving such properties using PVS directly. Recent work by Romijn and Devillers et al., based on the I/O automata model, has provided the basis for two case studies on how well TAME achieves these goals. Romijn specified the RPC-Memory Problem and its solution, while Devillers et al. specified a tree identify protocol. Hand proofs of specification properties were provided by the authors. In addition, Devillers et al. used PVS directly to mechanize the specifications and proofs of the tree identify protocol. In one case study, the third author, a new TAME user with no previous PVS experience, used TAME to create PVS specifications of the I/O automata presented by Romijn and Devillers et al. and to check the hand proofs of invariant properties. The PVS specifications and proofs of Devillers et al. provide the basis for the other case study, which compares the TAME approach to an alternate approach which uses PVS directly.", "num_citations": "8\n", "authors": ["1469"]}
{"title": "Interface styles for adaptive automation(in military aircraft cockpits)\n", "abstract": " It is noted that some of the adverse effects of automation in cockpit design may be reduced if adaptive rather than static automation is employed. Adaptive automation is implemented dynamically in response to altering task demands. The design of a direct manipulation interface (Jacob,1989) that should offset some of automation's drawbacks is discussed. (R.E.P.)", "num_citations": "8\n", "authors": ["1469"]}
{"title": "Designing secure message systems: the military message systems (MMS) project\n", "abstract": " . abstract The goal of the Military Message Systems (MMS) project is to specify the requirements and design of a family of secure military message systems and to build full-scale prototypes of two family members. This paper describes several techniques that are being used in the MMS project: the application of Parnas' program family principle to both the requirements document and the design specification, the definition of an Intermediate Command Language to describe the user services provided by family members, the formulation of an application-based security model to define the security rules that each message system must enforce, and the construction of quick prototypes to validate requirements and to evaluate different user interface designs. The paper concludes by describing the project's current status.\u2014From the Authors' Abstract This paper provides an interim report on a current Naval Research\u00a0\u2026", "num_citations": "7\n", "authors": ["1469"]}
{"title": "A Survey of Packet Switching Techniques for Broadcast Media.\n", "abstract": " To utilize communications channels effectively, appropriate channel management schemes must be implemented. The Navy is considering several alternative multiplexing techniques for the future Naval Telecommunications System. This report surveys a number of recently proposed techniques, called packet switching techniques, that have been designed to multiplex broadcast radio channels. Included in the report are several random access techniques such as pure and slotted ALOHA, as well as a number of packet reservation schemes. We describe how each technique works and report the results of analytic and simulation of the techniquess performance. Some preliminary conclusions are stated. A subsequent report will discuss the attractiveness of these techniques for future Naval communications systems. AuthorDescriptors:", "num_citations": "7\n", "authors": ["1469"]}
{"title": "System designers, not analysts, should design: Requirements for design and innovation in a changing world\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "6\n", "authors": ["1469"]}
{"title": "Formal Methods for Developing Software Specifications: Paths to Wider Usage.\n", "abstract": " Although many formal methods have been proposed for improving the quality of software speci cations, a number of barriers to widespread use of these methods remain. This paper describes four of these barriers| failure to scale, unnatural interfaces, limited analysis capabilities, and insucient tool integration| and suggests some promising approaches for overcoming them. These approaches include automated abstraction, user interfaces designed for ease of use, and the application of powerful decision procedures. To illustrate the barriers and approaches to overcoming them, several examples are presented based on the SCR (Software Cost Reduction) requirements method.", "num_citations": "6\n", "authors": ["1469"]}
{"title": "Interface styles for the intelligent cockpit-Factors influencing automation deficit\n", "abstract": " Automation in modem cockpits presents a new challenge for interface design. This challenge is heightened because there is still relatively little experience with the new systems, the avionics hardware provides greater flexibility in display generation, and the automation being introduced has the potential to move the pilot in and out of the loop. Our response to this challenge is to design the cockpit interface style in a manner that minimizes the effects of automation deficit. As part of this effort, we are examining the factors that produce automation deficit. Results reported previously show that automation deficit in response time is related to interface style and the type of decision. Results reported here show that there are effects on tracking performance due to adaptive automation and interface style.", "num_citations": "6\n", "authors": ["1469"]}
{"title": "High assurance human-centric decision systems\n", "abstract": " Many future decision support systems will be human-centric, i.e., require substantial human oversight and control. Because these systems often provide critical services, high assurance will be needed that they satisfy their requirements. How to develop \u201chigh assurance human-centric decision systems\u201d is unknown: while significant research has been conducted in areas such as agents, cognitive science, and formal methods, how to apply and integrate the design principles and disparate models in each area is unclear. This paper proposes a novel process for developing human-centric decision systems where AI (artificial intelligence) methods-namely, cognitive models to predict human behavior and agents to assist the human-are used to achieve adequate system performance, and software engineering methods, namely, formal modeling and analysis, to obtain high assurance. To support this process, the paper\u00a0\u2026", "num_citations": "5\n", "authors": ["1469"]}
{"title": "On model-based software development\n", "abstract": " Due to its many advantages, the growing use in software practice of Model-Based Development (MBD) is a promising trend. However, major problems in MBD of software remain, for example, the failure to integrate formal system requirements models with current code synthesis methods. This chapter introduces FMBD, a formal MBD process for building software systems which addresses this problem. The goal of FMBD is to produce high assurance software systems which are correct by construction. The chapter describes three types of models built during the FMBD process, provides examples from an avionics system to illustrate the models, and proposes three major challenges in MBD as topics for future research.", "num_citations": "5\n", "authors": ["1469"]}
{"title": "Direct generation of invariants for reactive models\n", "abstract": " Recently, software practitioners, using model-based engineering and similar methods, have begun developing software from models. After creating a model of the required system behavior, a developer can obtain assurance of the model by validating that it captures the intended behavior and verifying that it satisfies critical properties. Invariants are important to both validation, as a check that the model's behavior matches the intended behavior, and verification, as auxiliaries in proving critical system properties, either automatically or with human guidance. A common approach to discovering invariants is to propose and then check candidate invariants. In contrast, our invariant generation techniques deduce invariants directly from the specification of a model. This paper presents more powerful versions of our earlier techniques for invariant generation and illustrates their utility for a real-world AirLock system.", "num_citations": "5\n", "authors": ["1469"]}
{"title": "Developing high assurance systems: On the role of software tools\n", "abstract": " Recently, researchers have developed a number of powerful, formally based software tools, such as model checkers and theorem provers. To date, these tools have largely been used to analyze hardware designs. In the future, they should have significant value for analyzing the requirements and designs of software systems, especially high assurance software systems, where compelling evidence is needed that the system satisfies critical properties, such as safety and security properties. This paper briefly describes the different roles that formally based software tools can play in debugging, verifying, and testing software systems and software system artifacts. It also describes one important activity in software development not involving tools that is often neglected and that merits greater care and attention.", "num_citations": "5\n", "authors": ["1469"]}
{"title": "Specifications for Three Members of the Military Message System (MMS) Family.\n", "abstract": " This report presents informal specifications for the user commands supported by three message systems, all members of the Military Message System MMS family. The message systems constitute a family because it is worthwhile to study their similarities before studying their differences. The members of the MMS family share a common definition of security. This report is intended to be an example of both good requirements documentation and an appropriate design for a secure message system. Keywords include Computer security, Message systems, Requirements documentation, Software engineering, Specifications, Office automation, and Program families.Descriptors:", "num_citations": "5\n", "authors": ["1469"]}
{"title": "Analyzing tabular requirements specifications using infinite state model checking\n", "abstract": " This paper investigates the application of infinite state model checking to the formal analysis of requirements specifications in the SCR (software cost reduction) tabular notation using action language verifier (ALV). After reviewing the SCR method and tools and the action language, experimental results are presented of formally analyzing two SCR specifications using ALV, The application of ALV to verify or falsify (by generating counterexamples) the state and transition invariants of SCR specifications and to check disjointness and coverage properties is described. ALV is compared with the verification techniques that have been integrated into the SCR toolset", "num_citations": "4\n", "authors": ["1469"]}
{"title": "Panel: given that hardware verification has been an uphill battle, what is the future of software verification?\n", "abstract": " This industrial panel is organized to discuss the views, experiences and opinions of formal methods practitioners from design automation, hardware and software industries, in order to understand the industrial needs and trends in using formal methods. In particular, we discuss the current thrust on application of formal verification in software development, and what hardware formal verification experiences bring to bear for formal software verification.", "num_citations": "4\n", "authors": ["1469"]}
{"title": "Automated specification-based test case generation using SCR\n", "abstract": " Automated Specification-Based Test Case Generation Using SCR Page 1 JPL IT Symposium - Automated Specification-Based Test Case Generation Using SCR n and Software Systems Automated Specification-Based Test Case Generation Using SCR JPL IT Symposium November 4,2002 Allen Nikora Constance L. Heitmeyer Quality Assurance Section Jet Propulsion Laboratory Head, Software Engineering Section Naval Research Laboratory The work described in this paper was carried out at the Jet Propulsion Laboratory, California Institute of Technology. This work was sponsored by the Software Engineering Technology element of JPL\u2019s Center for Space Mission Information and Software Systems. Date: 4 November, 2002 1 Software Engineering Technology Page 2 JPL IT Symposium - Automated Specification-Based Test Case Generation Using SCR. n and Software Systems A utom ated Specification-\u2026", "num_citations": "4\n", "authors": ["1469"]}
{"title": "A software environment for custom simulation and monitoring of real-time specifications\n", "abstract": " The testing and validation of formal specifications of high assurance real time systems requires an extensible simulation environment with support for users to generate events, customize displays, and monitor event traces. The paper describes MTSim, a customizable simulation platform for the Modechart Toolset (MT). MTSim provides support for \"plugging in\" user defined viewers as well as user participation in the generation of simulations by allowing users to inject events into the execution trace. Moreover, MTSim provides monitoring and assertion checking of execution traces and the invocation of user specified handlers upon assertion violation. The paper also introduces a MTSim component called WebSim, a suite of simulation tools for MT, and an application specific component of MTSim, which displays the cockpit of an F-18 aircraft and models its bomb release function.", "num_citations": "3\n", "authors": ["1469"]}
{"title": "Rigorous requirements for real-time systems: evolution and application of the SCR method (tutorial)\n", "abstract": " This half-day tutorial provides an in-depth introduction to the SCR (Software Cost Reduction) requirements method, a practical, industrial-strength approach to formal requirements specification. Topics covered in the tutorial include the industrial perspective on formal methods, necessary attributes of methods and tools appropriate for industrial development of requirements, how the SCR method addresses common industrial concerns, the SCR requirements model, the SCR toolset, technology transfer efforts, and results and lessons learned from application of the SCR method to commercial software development.", "num_citations": "3\n", "authors": ["1469"]}
{"title": "Requirements for the Military Message System (MMS) Family: Data Types and User Commands.\n", "abstract": " This report, an application of Parnas family methodology, describes the required user-visible behavior of a family of Military Message Systems MMS. These systems have two significant areas of commonality all enforce the rules described by the MMS security model and the user-visible data types and user commands required by each system can be extracted from a large set of data types and user commands. Based on a study of several existing message systems, this report defines the set of data types eg, message, message file, directory and user commands associated with the MMS family. We use an Intermediate Command Language ICL to describe the user commands abstractly, ie, to specify each commands effects without imposing unnecessary restrictions on either the command syntax or the physical characteristics of the users terminal. To simplify and shorten the specifications, we define a hierarchy data types. Also included is a glossary of terms. Keywords Requirements, Specifications, Security model, Program families, Functional specifications, and Message systems.Descriptors:", "num_citations": "3\n", "authors": ["1469"]}
{"title": "Developing high quality software with formal methods: What else is needed?\n", "abstract": " In recent years, many formal methods have been proposed for improving software quality. These include new specification and modeling languages, whose purpose is to precisely describe the required software behavior at a high level of abstraction, and formal verification techniques, such as model checking and theorem proving, for mechanically proving or refuting critical properties of the software. Unfortunately, while promising, these methods are rarely used in software practice. This paper describes improvements in languages, specifications and models, code quality, and code verification techniques that could, along with existing formal methods, play a major role in improving software quality.", "num_citations": "2\n", "authors": ["1469"]}
{"title": "Using SCR to specify requirements of the BART advanced automated train control system\n", "abstract": " Since its introduction in 1978, the SCR (Software Cost Reduction) tabular notation has been used to represent the requirements of numerous safety-critical systems, including avionics systems, space systems, and control systems for nuclear plants. Our group has formulated a state-machine semantics for the SCR notation and a set of software tools for analyzing requirements specifications in the SCR tabular notation. To demonstrate the benefits of the SCR method for developing safety-critical systems, this chapter describes the application of SCR to a complex portion of the Advanced Automated Train Control (AATC) system under development for the Bay Area Rapid Transit (BART) system. Examples from an SCR specification of the required behavior of the AATC system are provided. The positive impact of applying our approach to the construction of the AATC system is summarized, and some important\u00a0\u2026", "num_citations": "2\n", "authors": ["1469"]}
{"title": "Applying TAME to I/O automata: A user's perspective\n", "abstract": " Mechanical theorem provers have been shown to expose proof errors, some of them serious, that humans miss. Mechanical provers will be applied more widely if they are easier to use. The tool TAME Timed Automata Modeling Environment provides an interface to the prover PVS to simplify specifying and proving properties of automata models. Originally designed for reasoning about Lynch-Vaandrager LV timed automata, TAME has since been adapted to other automata models. This paper shows how TAME can be used to specify and verify properties of IO automata, a class of untimed automata. It also describes the experiences of a new TAME user the first author who used TAME to check Lamport-style hand proofs of invariants for two applications Romijns solution to the RPC-Memory Problem and the verification by Devillers et. al. of the tree identify phase of the IEEE 1394 bus protocol. For the latter application, the TAME mechanization of the hand proofs is compared with the more direct PVS proofs. Improvements to TAME in response to user feedback are discussed.Descriptors:", "num_citations": "2\n", "authors": ["1469"]}
{"title": "Applying formal methods to an information security device: A case study\n", "abstract": " One approach to assuring information security is to control access to information through an appropriately designed device. A cost-e ective way to provide assurance that the device meets its security requirements is to detect and correct violations of these requirements at an early stage of development: when the operational requirements are speci ed. Once it is demonstrated that an operational requirements speci cation is complete and consistent, that it captures the intended device behavior, and that the operational speci cation satis es the security requirements, this operational speci cation can be used both to guide development of implementations and to generate test sets for testing implementations. This paper describes the application of the SCR (Software Cost Reduction) requirements method and the NRL's SCR* toolset, which includes a set of veri cation and validation tools, to a US Navy communications security device. It reports on our success in proving that the operational requirements speci cation satis es a set of security properties. The paper also discusses the practicality and cost of applying formal methods to the development of security devices.", "num_citations": "2\n", "authors": ["1469"]}
{"title": "The SCR approach to requirements specification and analysis\n", "abstract": " A conceptual data schema specifies the structure of the'data base'for a computer based information system. Data stored in the data base bear information that the information system provides. Thus the schema is the major factor that determines the information system's capability of providing information. In this paper, we propose four conditions for such information bearing capability, and then examine this capability's quantitative aspect. The contribution of this work is that it deepens our understanding of an information system's capability of providing information", "num_citations": "2\n", "authors": ["1469"]}
{"title": "Computing: An Overview\n", "abstract": " This chapter defines real-time systems and illustrates them with a number of small examples. It also discusses issues central to applying formal methods in the development of real-time systems: the trade-offs between operational and descriptive specifications, dif-ferent levels of formality that can be applied, and the requirements of formal methods for building industrial-strength systems. To put the newer formal methods into perspective, two methods widely used in practice to design and analyze real-time systems, namely, structured analysis and Statecharts, are reviewed. Several promising new techniques for specifying and analyzing real-time systems are then summarized and illustrated with examples. These include graphical notations, state machine and logic-based models, process algebras, and analysis techniques, such as model checking and deductive reasoning.", "num_citations": "2\n", "authors": ["1469"]}
{"title": "The role of HCI in CASE tools supporting formal methods\n", "abstract": " From 1988 through 1992, I led two research groups the advanced interfaces section of NRLs Human-Computer Interaction HCI laboratory, which is developing advanced user interface techniques, and a software engineering group, which is designing formal methods for real-time systems. In 1989, a multidisciplinary team of HCI experts and software engineers, drawn from the two groups, began a new research task whose purpose was two-fold to evaluate existing formal methods for representing and reasoning about a systems timing behavior and to build a prototype CASE toolset supporting the most promising methods. From the beginning, we recognized that the success of the CASE tools depended not only on powerful analysis methods but also on the quality of the toolsets user interface and its software design 4. A high-quality user interface would allow developers to create, edit, and analyze specifications easily and effectively. A high-quality software design would enforce a clean separation between the user interface software and the software encoding the formal methods. A clean separation would facilitate software changes.Descriptors:", "num_citations": "2\n", "authors": ["1469"]}
{"title": "Software development for hard real-time systems\n", "abstract": " In [3], a hard real-time (IIRT) system is defined as a system'that must supply information within specified real-time limits'. Recently, the Naval Research Laboratory (NRL) initiated a new software engineering project to evaluate and extend techniques and tools for developing software for ItRT systems. We are especially interested in the scaleability of the newer techniques and tools. In particular, to what extent do these help in the software development of real world systems with critical timing constraints? Our effort will build on work completed under an earlier NRL research project, called Software Cost Reduction (SCR), that applied software engineering principles to the reconstruction of the A-7E aircraft's Operational Flight Program (OFP).", "num_citations": "2\n", "authors": ["1469"]}
{"title": "Noun Phrase Compression in Navy Messages.\n", "abstract": " An important goal of the Navys future message systems is to be able to interpret automatically the English narrative in Navy messages. To accomplish this, such systems must incorporate a natural language parser that determines the structure of English phrases and sentences. The parser does this by using a grammar, a set of rules that describes all acceptable patterns in the language. A central aim of our research is to develop a grammar that is oriented toward the particular style, or sublanguage, used in Navy messages. In this report, we describe a partial grammar for telegraphic constructs in the message sublanguage, ie constructs in which words that would normally occur are omitted when the meaning of the phrase is clear without them. Specifically, we are concerned with telegraphic noun phrases of the form Modifier Noun Modifier, where either or both of the modifiers are optional. We present a grammatical description of complex acronyms like CINCLANT Commander-in-Chief for the Atlantic, focusing on the rules that assign these expressions an internal structure. Given this description, we show that complex acronyms are hybrid expressions in that they share the properties of single words like CNO and of phrases like arrival Norfolk. AuthorDescriptors:", "num_citations": "2\n", "authors": ["1469"]}
{"title": "An Approach to Describing the Functional Requirements of an Embedded Communication System.\n", "abstract": " An abstract requirements specification describes a systems externally visible behavior without making decisions about its design. Although they have important advantages, such specifications are difficult to produce for complex systems and hence are seldom seen in the real programming world. This report describes an abstract requirements specification for a complex, real-world system the specification is intended to serve as a fully worked out example for those tasked to document the requirements of similar systems. After introducing the Navy application with which we are concerned, we demonstrate that the traditional approach of functional decomposition, where each output is expressed as a mathematical function of inputs, leads to premature design decisions. Next, we present a new approach to writing requirements documents that avoids design decisions and thus leads to an abstract specification. The new approach is compared to a similar approach used in a related project. An appendix provides an example that illustrates the formal techniques employed in the approach. AuthorDescriptors:", "num_citations": "2\n", "authors": ["1469"]}
{"title": "Idea: writing secure c programs with secprove\n", "abstract": " This paper describes SecProve, a prototype tool we are developing for checking application-specific security properties of C code, together with our vision of how such a tool can be used by a programmer to maintain security of code during its development.", "num_citations": "1\n", "authors": ["1469"]}
{"title": "Requirements models for critical systems\n", "abstract": " This chapter describes a formal approach to the modeling, specification, validation, and verification of the requirements, ie, the required externally visible behavior, of a software system. The focus is on a special class of systems called critical systems, systems which require compelling evidence that the system delivers essential services and satisfies critical properties, such as safety and security properties. The objective of a formal approach to requirements is to produce a complete, consistent, and correct model of the requirements. The approach described relies on a formal specification of the requirements model in the SCR tabular notation, which allows several kinds of tool-based analyses of the model.", "num_citations": "1\n", "authors": ["1469"]}
{"title": "Applying a compositional method to incrementally prove critical properties of an airlock system\n", "abstract": " Providing assurance that a software system satisfies its critical properties is difficult, particularly when the system must satisfy many classes of properties, such as safety, fault-tolerance, timing, and security. This paper describes the application of an incremental development and verification approach [13, 14], based on composition and refinement, to an airlock system. Initially, a model of the basic functional behavior of the system is developed and proved to satisfy a set of safety properties. This basic model is then extended with timing behavior. This timed model is a full refinement of the basic model, and related safety properties are shown to still hold for the timed model. In the third and last step, the timed model is extended with fault handling behavior. This \u201cfault-tolerant\u201d model, a partial refinement of the other two models, is shown to satisfy both weakened versions of the safety properties and additional fault-tolerance properties.", "num_citations": "1\n", "authors": ["1469"]}
{"title": "A model-based approach to testing software for critical behavior and properties\n", "abstract": " To integrate the theoretical concepts of composition and refinement with the engineering notions of software models and components, the Naval Research Laboratory has formulated a set of practical composition-based methods, with associated modeling and proof techniques, for developing critical software systems. The general approach is to develop a set of software components and to use various forms of composition to combine the components in a manner that guarantees properties of the composite system. An assumption underlying this research is that much of the software code can be generated automatically from models using automatic code generators. A problem is that the code generated by such tools still requires testing to ensure that the software delivers its critical services correctly and that the software behavior satisfies critical properties, such as safety properties. The need for testing arises\u00a0\u2026", "num_citations": "1\n", "authors": ["1469"]}
{"title": "On the utility of formal methods in the development and certification of software\n", "abstract": " During the past three decades, many formal methods have been proposed whose goal is to improve the quality of computer systems. I use the term formal method to refer to any mathematically-based technique or tool useful in either hardware or software development. Recently, formal methods have played a significantly increased role in hardware design. More and more companies that sell microprocessors and hardware chips, including Intel, IBM, and Motorola, are using formally-based tools, such as model checkers, theorem provers, and equivalence checkers, to check hardware designs for flaws. While applied less frequently in practical software development, formal methods have, in a few recent cases, also been effective in detecting software defects. A prominent example is the set of tools developed in Microsoft\u2019s SLAM project which were designed to detect flaws in device drivers [1], a primary source\u00a0\u2026", "num_citations": "1\n", "authors": ["1469"]}
{"title": "Panel on design for verification.\n", "abstract": " Although research in automated verification has produced very promising results, the question of how to effectively integrate these results into the software and hardware development processes is still unresolved. Typically, fully automated verification techniques are not scalable, and scalable verification techniques require substantial user guidance. Alternatively, developers could facilitate scalable verification by constructing software and hardware systems in ways that make them easier to verify. In this panel we will discuss the idea of design for verification.", "num_citations": "1\n", "authors": ["1469"]}
{"title": "Model Checking Complete Requirements Specifications Using Abstraction\n", "abstract": " During the last decade, model checking has proven remarkably effective for detecting errors in hardware designs and protocols. Much of this success can be traced to the use of Binary Deci-sion Diagrams (BDDs), an extremely efficient technique for symbolically representing Boolean formulae. Unfortunately, model checking has had only limited success in analyzing software specifications, largely because software specifications routinely contain not only Booleans but variables spanning a wide range of data types, including integers, reals, and enumerated types. A further barrier is the huge, in many cases infinite, state spaces that must be analyzed in model checking software specifications. Due to these very large state spaces and the rich data types commonly found in software specifications, BDD-based model checkers have proven relatively ineffective.Before practical software specifications can be analyzed\u00a0\u2026", "num_citations": "1\n", "authors": ["1469"]}
{"title": "Requirements Specifications in the Military Message System Project\n", "abstract": " A major goal of the Military Message System (MMS) pro ject is to produce requirements specifications and a software design for a family of military message systems. An important issue in the project concerns the form and content of the requirements specifications. To date, we have completed informal specifications of the MMS user commands (1) and are currently developing more formal specifications. In this paper, we briefly describe some lessons learned in producing the specifications use an somePartitioning the functional requirements Defining the requirements of a family of military message systems is a complex, time-consuming task. Early on, we recog-nized that the sets of data types and of user commands (ie, functions) that future military message systems will support are likely to differ but that the security rules enforced by such systems are reasonably stable. Thus we were able to separate the task of producing requirements specifications into two simpler (albeit still challenging!) subtasks: definition of the security rules and definition of the set of MMS user commands. The MMS security model, which is defined both informally and for-mally in (2), defines the security rules. The MMS requirements specifications define the MMS user commands. The security model imposes structure on all MMS data items. For example, each MMS data item (e. 8., message, message file) must be identified as either an object or a container, where an object is the smallest unit of information that has an explicit classification marking and a container is an information unit with its own classification that may contain objects and/or other containers. In a MMS, a\u00a0\u2026", "num_citations": "1\n", "authors": ["1469"]}