{"title": "A needed narrowing strategy\n", "abstract": " The narrowing relation over terms constitutes the basis of the most important operational semantics of languages that integrate functional and logic programming paradigms. It also plays an important role in the definition of some algorithms of unification modulo equational theories that are defined by confluent term rewriting systems. Due to the inefficiency of simple narrowing, many refined narrowing strategies have been proposed in the last decade. This paper presents a new narrowing strategy that is optimal in several respects. For this purpose, we propose a notion of a needed narrowing step that, for inductively sequential rewrite systems, extends the Huet and L\u00e9vy notion of a needed reduction step. We define a strategy, based on this notion, that computes only needed  narrowing steps. Our strategy is sound and complete for a large class of rewrite systems, is optimal with respect to the cost measure that counts\u00a0\u2026", "num_citations": "494\n", "authors": ["1764"]}
{"title": "On the verification problem of nonregular properties for nonregular processes\n", "abstract": " Investigate the verification problem of infinite-state processes w.r.t. nonregular properties, i.e. nondefinable by finite-state /spl omega/-automata. We consider processes in the algebra PA (Process Algebra) which provides sequential and parallel (merge) composition, nondeterministic choice and recursion. The algebra PA integrates and strictly subsumes the algebras BPA (Basic Process Algebra, i.e. context-free processes) and BPP (Basic Parallel Processes). On the other hand, we consider properties definable in a new temporal logic called CLTL (Constrained Linear-Time Logic) which is an extension of the linear-time temporal logic LTL with two kinds of constraints on traces: constraints on the numbers of occurrences of states expressed using Presburger formulas (occurrence constraints), and constraints on the order of appearance of states expressed using finite-state automata (pattern constraints). Pattern\u00a0\u2026", "num_citations": "84\n", "authors": ["1764"]}
{"title": "Design and implementation of a generic, logic and functional programming language\n", "abstract": " This paper presents the broad outlines of LPG, a language designed for generic specification and programming. In this language one may specify different modules which can represent either particular algebras (ADTs), families of algebras (generic data types and enrichments) or \u03a3-structures (theories). This language is based on Horn clause logic with equality which permits logic and functional programming to be combined. As modules in LPG can be generic, an instantiation mechanism is needed; such a mechanism is described here as well as the interpreter and an E-unification algorithm, thus making LPG a powerful programming language.", "num_citations": "84\n", "authors": ["1764"]}
{"title": "Admissible Graph Rewriting and Narrowing.\n", "abstract": " We address the problem of graph rewriting and narrowing as the underlying operational semantics of rule-based programming languages. We propose new optimal graph rewriting and narrowing strategies in the setting of orthogonal constructor-based graph rewriting systems. For this purpose, we first characterize a subset of graphs, called admissible graphs. A graph is admissible if none of its defined operations belongs to a cycle. We then prove the confluence, as well as the confluence modulo bisimilarity (unraveling), of the admissible graph rewriting relation. Afterwards, we define a sequential graph rewriting strategy by using Antoy's definitional trees. We show that the resulting strategy computes only needed redexes and develops optimal derivations wrt the number of steps. Finally, we tackle the graph narrowing relation over admissible graphs and propose a sequential narrowing strategy which computes independent solutions and develops shorter derivations than most general graph narrowing.", "num_citations": "76\n", "authors": ["1764"]}
{"title": "On the automatic verification of systems with continuous variables and unbounded discrete data structures\n", "abstract": " We address the verification problem of invariance properties for hybrid systems. We consider as general models of hybrid systems finite automata, supplied with (unbounded) discrete data structures and continuous variables. We focus on the case of systems manipulating discrete counters and one pushdown stack, and on the other hand, constant slope continuous variables. The use of unbounded discrete data sturcture allows to consider systems with a powerful control, and to reason about important notions as the number of occurrences of events in some computation. The use of constant slope continuous variables allows to reason for instance about the time separating events and the durations of phases within some computation interval. We present decidability results for several subclasses of such models of hybrid systems; this provides automatic verification procedures for these systems.", "num_citations": "74\n", "authors": ["1764"]}
{"title": "Parallel Evaluation Strategies for Functional Logic Languages.\n", "abstract": " We introduce novel, sound, complete, and locally optimal evaluation strategies for functional logic programming languages. Our strategies combine, in a nontrivial way, two landmark techniques in this area: the computation of unifiers performed by needed narrowing in inductively sequential rewrite systems and the simultaneous reduction of a necessary set of redexes performed by rewriting in weakly orthogonal, constructor-based rewrite systems. First, we define a sequential strategy similar in scope to other narrowing strategies used in modern lazy functional logic languages. Then, based on the sequential strategy, we define a parallel narrowing strategy that has several noteworthy characteristics: it is the first complete narrowing strategy which evaluates ground expressions in a fully deterministic, optimal way; it computes shortest derivations and minimal sets of solutions on inductively sequential rewrite systems; and when combined with term simplification, it subsumes and improves all recently developed optimizations of narrowing for overlapping rewrite rules.", "num_citations": "65\n", "authors": ["1764"]}
{"title": "On completeness of narrowing strategies\n", "abstract": " In this paper we propose some syntactical criteria on algebraic specifications that ensure completeness of narrowing strategies. We then prove a theorem relating narrowing and reduction relations. The completeness of narrowing strategies is proved and conditions for the computation of a \"minimal\" ground complete set of E-unifiers are given; as well as an algorithm transforming specifications satisfying Huet and Hullot's principle of definition, into specifications fulfilling the proposed criteria.", "num_citations": "58\n", "authors": ["1764"]}
{"title": "On constructor-based graph rewriting systems\n", "abstract": " We address the problem of graph rewriting as the underlying operational semantics of rule-based programming languages. We define a new optimal graph rewriting strategy in the setting of orthogonal constructor-based graph rewriting systems. For this purpose, we first characterize a subset of graphs, called admissible graphs. A graph is admissible if none of its defined operations belongs to a cycle. We then prove the confluence, as well as the confluence modulo bisimilarity (unraveling), of the admissible graph rewriting relation. Finally, we define a sequential graph rewriting strategy by using Antoy's definitional trees. We show that the resulting strategy computes only needed redexes and develops optimal derivations wrt the number of steps.", "num_citations": "42\n", "authors": ["1764"]}
{"title": "Security policy in a declarative style\n", "abstract": " We address the problem of controlling information leakage in a concurrent declarative programming setting. Our aim is to define verification tools in order to distinguish between authorized, or declared, information flows such as password testing (eg, ATM, login processes, etc.) and non-authorized ones. In this paper, we first propose a way to define security policies as confluent and terminating rewrite systems. Such policies define how the privacy levels of information evolve. Then, we provide a formal definition of secure processes with respect to a given security policy. We also define an actual verification algorithm of secure processes based on constraint solving.", "num_citations": "36\n", "authors": ["1764"]}
{"title": "Verifying invariance properties of timed systems with duration variables\n", "abstract": " We consider the verification problem of invariance properties for timed systems modeled by (extended) Timed Graphs with duration variables. While clocks of a Timed Graph can be seen as continuous (real valued) variables with rates 1 at each control location of the system, duration variables (also called integrators) are continuous variables having rates 0 or 1. The use of integrators allows to reason about the accumulated delays spent at some particular locations during some computation. We show that under some conditions, the verification problem of invariance properties is decidable for (closed) Timed Graphs with one integrator, the integrator can be tested and/or reset at any transition. For this, we use a new digitization technique and prove that every real computation of such systems has a valid digitization. Then, we show how to solve the verification problem in the case of a discrete time domain.", "num_citations": "33\n", "authors": ["1764"]}
{"title": "AGREE\u2013algebraic graph rewriting with controlled embedding\n", "abstract": " The several algebraic approaches to graph transformation proposed in the literature all ensure that if an item is preserved by a rule, so are its connections with the context graph where it is embedded. But there are applications in which it is desirable to specify different embeddings. For example when cloning an item, there may be a need to handle the original and the copy in different ways. We propose a conservative extension of classical algebraic approaches to graph transformation, for the case of monic matches, where rules allow one to specify how the embedding of preserved items should be carried out.", "num_citations": "31\n", "authors": ["1764"]}
{"title": "Inductively sequential term-graph rewrite systems\n", "abstract": " Definitional trees have been introduced by Sergio Antoy in order to design an efficient term rewrite strategy which computes needed outermost redexes. In this paper, we consider the use of definitional trees in the context of term-graph rewriting. We show that, unlike the case of term rewrite systems, the strategies induced by definitional trees do not always compute needed redexes, in presence of term-graph rewrite systems. We then define a new class called inductively sequential term-graph rewrite systems (istGRS) for which needed redexes are still provided by definitional trees. Systems in this class are not confluent in general. We give additional syntactic criteria over istGRS\u2019s which ensure the confluence property with respect to the set of admissible term-graphs.", "num_citations": "30\n", "authors": ["1764"]}
{"title": "Abstraction of conditional term rewriting systems\n", "abstract": " This paper introduces the notion of abstract domains for constructor-based conditional term rewriting systems and de nes the notion of abstract term rewriting systems (abstract TRS) over these domains. These new term rewriting systems are mainly used to determine or to approximate the normal forms of ground instances of concrete terms (with variables). We propose a method to compute such an abstract TRS as the least xed point of a transformation over abstract TRS's. The computed abstract TRS allows to determine e ciently an approximation of any concrete term. Among the possible applications of the introduced concepts, we quote: improvement of the implementation of functional-logic programming languages, E-uni cation, satis ability, proofs by induction, etc.", "num_citations": "30\n", "authors": ["1764"]}
{"title": "Abstract rewriting\n", "abstract": " We introduce the notion of abstract term rewriting system, R                  a               , corresponding to a constructor-based term rewriting system R. R                  a                is aimed to determine the set of possible constructors of a given term, using abstract rules in R                  a               . A characterization of an abstract term rewriting system as a fixed point is given. Among the possible applications of the introduced concepts, we quote: E-unification, proofs by consistency, type checking etc.", "num_citations": "30\n", "authors": ["1764"]}
{"title": "Verifying infinite state processes with sequential and parallel composition\n", "abstract": " We investigate the verification problem of infinite-state process wrt logic-based specifications that express properties which may be nonregular. We consider the process algebra PA which integrates and strictly subsumes the algebras BPA (basic process algebra) and BPP (basic parallel processes), by allowing both sequential and parallel compositions as well as nondeterministic choice and recursion. Many relevant properties of PA processes are nonregular, and thus can be expressed neither by classical temporal logics nor by finite state \u03c9-automata. Properties of particular interest are those involving constraints on numbers of occurrences of events. In order to express such properties, which are nonregular in general, we use the temporal logic PCTL which combines the branching-time temporal logic CTL with Presburger arithmetics. Then we tackle the verification problem of guarded PA processes wrt PCTL\u00a0\u2026", "num_citations": "29\n", "authors": ["1764"]}
{"title": "Uniform narrowing strategies\n", "abstract": " In this paper we consider solution of equations in initial models, by using narrowing relationship. We introduce the notion of uniform narrowing strategies and prove the completeness of narrowing algorithms using such strategies. Then, we define the class of uniform specifications as specifications for which every narrowing strategy is uniform, and prove their decidability.", "num_citations": "28\n", "authors": ["1764"]}
{"title": "A dynamic logic for termgraph rewriting\n", "abstract": " We propose a dynamic logic tailored to describe graph transformations and discuss some of its properties. We focus on a particular class of graphs called termgraphs. They are first-order terms augmented with sharing and cycles. Termgraphs allow one to describe classical data-structures (possibly with pointers) such as doubly-linked lists, circular lists etc. We show how the proposed logic can faithfully describe (i) termgraphs as well as (ii) the application of a termgraph rewrite rule (i.e. matching and replacement) and (iii) the computation of normal forms with respect to a given rewrite system. We also show how the proposed logic, which is more expressive than propositional dynamic logic, can be used to specify shapes of classical data-structures (e.g. binary trees, circular lists etc.).", "num_citations": "22\n", "authors": ["1764"]}
{"title": "Combining mobile processes and declarative programming\n", "abstract": " We propose a general framework for combining mobile processes and declarative programming languages, e.g., functional, logic or functional-logic languages. In contrast to existing concurrent extensions of declarative languages, we distinguish clearly between the notion of processes and that of functions or predicates. Thus, our framework is generic and may be applied to extend several kinds of declarative languages. It also extends PA process algebra in order to deal with parameter passing, mobile processes and interactive declarative programming. In our setting, declarative programs are dynamic and may be modified thanks to the actions performed by processes.", "num_citations": "22\n", "authors": ["1764"]}
{"title": "Parallel admissible graph rewriting\n", "abstract": " We investigate the rewrite relation over graphs induced by constructor-based weakly orthogonal graph rewriting systems. It is well known that this relation is not confluent in general whereas it is confluent in the case of weakly orthogonal term rewriting systems. We show, however, that the considered relation is always confluent, as well as confluent modulo bisimilarity, for a large class of graphs called admissible graphs. Afterwards, we define a parallel graph rewriting relation and propose an efficient parallel graph rewriting strategy.", "num_citations": "21\n", "authors": ["1764"]}
{"title": "Sp\u00e9cification, g\u00e9n\u00e9ricit\u00e9, prototypage: aspects du langage LPG\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "17\n", "authors": ["1764"]}
{"title": "Verification of nonregular temporal properties for context-free processes\n", "abstract": " We address the problem of the specification and the verification of processes with infinite-state spaces. Many relevant properties for such processes involve constraints on numbers of occurrences of events (truth of propositions). These properties are nonregular and hence, they are not expressible neither in the usual logics of processes nor by finite-state \u03c9-automata. We propose a logic called PCTL that allows the description of such properties. PCTL is a combination of the branching-time temporal logic CTL with Presburger arithmetic. Mainly, we study the decidability of the satisfaction relation between context-free processes and PCTL formulas. We show that this relation is decidable for a large fragment of PCTL. Furthermore, we study the satisfiability problem for PCTL. We show that this problem is highly undecidable (\u03a3                                1                 1               -complete), even for the fragment where the\u00a0\u2026", "num_citations": "17\n", "authors": ["1764"]}
{"title": "On completeness of narrowing strategies\n", "abstract": " We address the problem of unification modulo a set of equations, using the narrowing relation. We propose some syntactical criteria on algebraic specifications that ensure the completeness of narrowing strategies. We then prove a theorem relating narrowing and reduction relations. The completeness of narrowing strategies is proved and conditions for the computation of a \u201cminimal\u201d ground complete set of E-unifiers are given, as well as an algorithm transforming specifications satisfying Huet and Hullot's principle of definition into specifications fulfilling the proposed criteria.", "num_citations": "17\n", "authors": ["1764"]}
{"title": "Transformation of attributed structures with cloning\n", "abstract": " Copying, or cloning, is a basic operation used in the specification of many applications in computer science. However, when dealing with complex structures, like graphs, cloning is not a straightforward operation since a copy of a single vertex may involve (implicitly) copying many edges. Therefore, most graph transformation approaches forbid the possibility of cloning. We tackle this problem by providing a framework for graph transformations with cloning. We use attributed graphs and allow rules to change attributes. These two features (cloning/changing attributes) together give rise to a powerful formal specification approach. In order to handle different kinds of graphs and attributes, we first define the notion of attributed structures in an abstract way. Then we generalise the sesqui-pushout approach of graph transformation in the proposed general framework and give appropriate conditions under which\u00a0\u2026", "num_citations": "16\n", "authors": ["1764"]}
{"title": "Verification of context-free timed systems using linear hybrid observers\n", "abstract": " We address the verification problem of infinite timed systems. We consider context-free timed systems defined as a generalization of the (regular) timed graphs [ACD90]. Then, we propose decision procedures for the verification of invariance properties of these systems, expressed by means of observation variables. These variables record relevant informations about the computations of the observed system. They are permanently updated along these computations without any interference with the behaviour of the system. Observation variables are either additional clocks (timers), nonbounded integer variables (accumulators), or constant slope continuous (real valued) variables (integrators).", "num_citations": "16\n", "authors": ["1764"]}
{"title": "On the operational semantics of the algebraic and logic programming language LPG\n", "abstract": " This paper gives a brief description of the recent improvements of LPG, a programming language that integrates algebraic and logic programming paradigms. In this language, functions are defined by means of constructor-based conditional term rewriting systems and predicates are defined by means of Horn clauses where the bodies may contain classical literals as well as equations and negations of equations (disequations). The operational semantics of LPG is based on an extension of SLD-resolution which deals with equations and disequations by using a narrowing-based algorithm. We investigate such a narrowing-based algorithm for solving equations and disequations and give new sufficient conditions that ensure the completeness of narrowing strategies, in presence of conditional term rewrite systems. Similarities and differencies with other logic and functional languages are pointed out.", "num_citations": "15\n", "authors": ["1764"]}
{"title": "The PBPO graph transformation approach\n", "abstract": " We propose a new algebraic approach to graph transformation, called the Pullback-Pushout (pbpo ) approach, where we combine smoothly the classical modifications to a host graph specified by a first part of a rule, defined as a span of graph morphisms, with the cloning of structures specified by a second span. The motivation behind this new approach is to support cloning of structures in an elegant and efficient way. After a formal definition of the proposed approach, we demonstrate that pbpo rewriting is a conservative extension of agree and the Sesqui-Pushout approaches. Contrary to agree, we show that the proposed pbpo transformation can easily be extended to cope with attributed graphs. In general, totally attributed graphs are not closed under pbpo transformation. We propose sufficient conditions which guarantee that the attribution of transformed graphs is total. Furthermore, a pbpo transformation can\u00a0\u2026", "num_citations": "12\n", "authors": ["1764"]}
{"title": "Ensuring correctness of model transformations while remaining decidable\n", "abstract": " This paper is concerned with the interplay of the expressiveness of model and graph transformation languages, of assertion formalisms making correctness statements about transformations, and the decidability of the resulting verification problems. We put a particular focus on transformations arising in graph-based knowledge bases and model-driven engineering. We then identify requirements that should be satisfied by logics dedicated to reasoning about model transformations, and investigate two promising instances which are decidable fragments of first-order logic.", "num_citations": "12\n", "authors": ["1764"]}
{"title": "A Hoare-Like Calculus Using the SROIQ\u03c3 Logic on Transformations of Graphs\n", "abstract": " We tackle the problem of partial correctness of programs processing structures defined as graphs. We introduce a kernel imperative programming language endowed with atomic actions that participate in the transformation of graph structures and provide a decidable logic for reasoning about these transformations in a Hoare-style calculus. The logic for reasoning about the transformations (baptized ) is an extension of the Description Logic (DL) , and the graph structures manipulated by the programs are models of this logic. The programming language is non-standard in that it has an instruction set targeted at graph manipulations (such as insertion and deletion of arcs), and its conditional statements (in loops and selections) are  formulas. The main challenge solved in this paper is to show that the resulting proof problems are decidable.", "num_citations": "12\n", "authors": ["1764"]}
{"title": "Rewriting term-graphs with priority\n", "abstract": " We define a new class of rewrite systems operating over term-graphs. Our aim is twofold. First we propose to extend classical first-order rewrite rules in order to process easily data-structures with pointers (eg, circular lists, doubly linked lists etc). For that, our rules provide specific features such as pointer (edges) redirections, relabeling of existing nodes etc. Unfortunately, such features are very often source of non confluence. Our second aim is then to ensure confluence of the considered rewrite systems in the new class. We introduce the notion of term-graphs with priority and show that orthogonal rewrite systems are confluent in our setting", "num_citations": "12\n", "authors": ["1764"]}
{"title": "The pullback-pushout approach to algebraic graph transformation\n", "abstract": " Some recent algebraic approaches to graph transformation include a pullback construction involving the match, that allows one to specify the cloning of items of the host graph. We pursue further this trend by proposing the Pullback-Pushout (pb-po) Approach, where we combine smoothly the classical modifications to a host graph specified by a rule (a span of graph morphisms) with the cloning of structures specified by another rule. The approach is shown to be a conservative extension of agree (and thus of the sqpo approach), and we show that it can be extended with standard techniques to attributed graphs. We discuss conditions to ensure a form of locality of transformations, and conditions to ensure that the attribution of transformed graphs is total.", "num_citations": "10\n", "authors": ["1764"]}
{"title": "Proving correctness of logically decorated graph rewriting systems\n", "abstract": " We first introduce the notion of logically decorated rewriting systems where the left-hand sides are endowed with logical formulas which help to express positive as well as negative application conditions, in addition to classical pattern-matching. These systems are defined using graph structures and an extension of combinatory propositional dynamic logic, CPDL, with restricted universal programs, called C2PDL. In a second step, we tackle the problem of proving the correctness of logically decorated graph rewriting systems by using a Hoare-like calculus. We introduce a notion of specification defined as a tuple (Pre, Post, R, S) with Pre and Post being formulas of C2PDL, R a rewriting system and S a rewriting strategy. We provide a sound calculus which infers proof obligations of the considered specifications and establish the decidability of the verification problem of the (partial) correctness of the considered specifications.", "num_citations": "10\n", "authors": ["1764"]}
{"title": "Narrowing data-structures with pointers\n", "abstract": " We investigate the narrowing relation in a wide class of (cyclic) term-graph rewrite systems. We propose a new sound and complete narrowing-based algorithm able to solve goals in presence of data structures with pointers (e.g., circular lists, doubly linked lists etc.). We first define the class of rewrite systems we consider. Our rules provide features such as pointer (edge) redirections, relabeling of existing nodes, in addition to the creation of new nodes. Moreover, we split the set of nodes of term-graphs in two (possibly empty) subsets: (i) variables and (ii) names. Variable nodes can be mapped against any other node whereas names act as constants and thus they are supposed to match themselves. This distinction between nodes allows us to synthesize, through the narrowing process, data-structures with circular shapes. In a second step, we define the rewriting and narrowing relations. We then show the\u00a0\u2026", "num_citations": "10\n", "authors": ["1764"]}
{"title": "A component-based approach to concurrent declarative programming\n", "abstract": " In this paper we present a component-based approach to mobile concurrent declarative programming, where we model systems as sets of interacting components. We first give a definition of a component and its different constituents. Finally, we briefly present a prototype implementation through an example.", "num_citations": "9\n", "authors": ["1764"]}
{"title": "On the closure of description logics under substitutions\n", "abstract": " We investigate the extension of Description Logics (DL) with a notion of \"substitution\". Substitutions naturally arise when reasoning about programs  which modify graph structures that are characterized by DLs. They constitute also a means to express concept and role modifications such as addition or deletion of individuals (respectively, pairs of individuals) to or from concepts (respectively, roles). After a formal definition of substitutions, we conduct a systematic study of a wide range of DLs with the purpose of proving or disproving conservativity of an extension of the respective DL with substitutions. The resulting classification is a gauge of the expressiveness of description logics and their adequacy for reasoning about change of graph structures.", "num_citations": "8\n", "authors": ["1764"]}
{"title": "Logical Foundations for Reasoning about Transformations of Knowledge Bases.\n", "abstract": " This is the formalization of a method of graph transformations. Transformations are expressed by an imperative programming language which is non-standard in the sense that it features conditions (in loops and selection statements) that are description logic (DL) formulas, and a non-deterministic assignment statement (a choice operator given by a DL formula). We sketch an operational semantics of the proposed programming language and then develop a matching Hoare calculus whose pre-and post-conditions are again DL formulas. A major difficulty resides in showing that the formulas generated when calculating weakest preconditions remain within the chosen DL fragment. In particular, this concerns substitutions whose result is not directly representable. We therefore explicitly add substitution as a constructor of the logic and show how it can be eliminated by an interleaving with the rules of a traditional tableau calculus.", "num_citations": "8\n", "authors": ["1764"]}
{"title": "Graph transformation with focus on incident edges\n", "abstract": " We tackle the problem of graph transformation with particular focus on node cloning. We propose a new approach to graph rewriting, called polarized node cloning, where a node may be cloned together with either all its incident edges or with only its outgoing edges or with only its incoming edges or with none of its incident edges. We thus subsume previous works such as the sesqui-pushout, the heterogeneous pushout and the adaptive star grammars approaches. We first define polarized node cloning algorithmically, then we propose an algebraic definition. We use polarization annotations to declare how a node must be cloned. For this purpose, we introduce the notion of polarized graphs as graphs endowed with some annotations on nodes and we define graph transformations with polarized node cloning by means of sesqui-pushouts in the category of polarized graphs.", "num_citations": "8\n", "authors": ["1764"]}
{"title": "Int\u00e9gration des m\u00e9thodes de r\u00e9\u00e9criture et de recherche op\u00e9rationnelle pour la mod\u00e9lisation et la r\u00e9solution de contraintes: application \u00e0 la planification de personnel m\u00e9dical\n", "abstract": " Nous pr\u00e9sentons un travail o\u00f9 deux techniques diff\u00e9rentes, la Recherche Op\u00e9rationnelle et les techniques de r\u00e9\u00e9critures sont coupl\u00e9es afin de r\u00e9soudre des probl\u00e8mes de gestions de ressources. L'id\u00e9e g\u00e9n\u00e9rale est que si la RO fourni des algorithmes efficaces, ces derniers ne sont valides que sur des structures math\u00e9matique pr\u00e9cises or il existe des contraintes symboliques difficilement repr\u00e9sentables de cette mani\u00e8re. Nous proposons donc d'utiliser les techniques de r\u00e9\u00e9critures, qui sont g\u00e9n\u00e9rales mais gourmandes en temps, pour traiter ces derni\u00e8res et de se servir de la RO pour traiter la partie combinatoire du probl\u00e8me. Nous illustrons notre m\u00e9thode en l'appliquant \u00e0 la gestion des ressources humaines et mat\u00e9rielles d'un service de radiologie d'un h\u00f4pital parisien.", "num_citations": "8\n", "authors": ["1764"]}
{"title": "Reference manual of the LPG specification language and environment, release with disequations\n", "abstract": " CiteSeerX \u2014 Reference manual of the LPG specification language and environment, release with disequations Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA Reference manual of the LPG specification language and environment, release with disequations (1994) Cached Download as a PDF Download Links [www-lsr.imag.fr] Save to List Add to Collection Correct Errors Monitor Changes by Didier Bert , Rachid Echahed , Jean-claude Reynaud Citations: 2 - 2 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Keyphrases lpg specification language reference manual Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data \u2026", "num_citations": "8\n", "authors": ["1764"]}
{"title": "A heterogeneous pushout approach to term-graph transformation\n", "abstract": " We address the problem of cyclic termgraph rewriting. We propose a new framework where rewrite rules are tuples of the form (L,R,\u03c4, \u03c3) such that L and R are termgraphs representing the left-hand and the right-hand sides of the rule, \u03c4 is a mapping from the nodes of L to those of R and \u03c3 is a partial function from nodes of R to nodes of L. The mapping \u03c4 describes how incident edges of the nodes in L are connected in R, it is not required to be a graph morphism as in classical algebraic approaches of graph transformation. The role of \u03c3 is to indicate the parts of L to be cloned (copied). Furthermore, we introduce a notion of heterogeneous pushout and define rewrite steps as heterogeneous pushouts in a given category. Among the features of the proposed rewrite systems, we quote the ability to perform local and global redirection of pointers, addition and deletion of nodes as well as cloning and collapsing\u00a0\u2026", "num_citations": "7\n", "authors": ["1764"]}
{"title": "Specializing narrowing for timetable generation: A case study\n", "abstract": " An important property of strategies used to solve goals in functional logic programming (FLP) languages is the complete exploration of the solution space. Integrating constraints into FLP proved to be useful in many cases, as the resulting constraint functional logic programming (CFLP) offers more facilities and more efficient operational semantics. CFLP can be achieved by means of conditional rewrite systems with a narrowing-based operational semantics. A common idea to improve the efficiency of such operational semantics is to use specific algorithms from operations research as constraint solvers. If the algorithm does not return a complete set of solutions, the property of completeness might be lost. We present a real world timetabling problem illustrating this approach. We propose an algorithm, obtained as an integration of three known optimization algorithms for the linear assignment problem (LAP\u00a0\u2026", "num_citations": "7\n", "authors": ["1764"]}
{"title": "Handling declared information leakage\n", "abstract": " We address the problem of controlling information leakage in a concurrent declarative programming setting. Our aim is to define formal tools in order to distinguish between authorized, or declared, information flows such as password testing (eg, ATM, login processes, etc.) and non-authorized ones. We propose to define security policies as rewriting systems. Such policies define how the privacy levels of information evolve. A formal definition of secure processes with respect to a given security policy is given.", "num_citations": "7\n", "authors": ["1764"]}
{"title": "Adding time to functional logic programs\n", "abstract": " We introduce a new framework which constitutes a conservative extension of functional logic programming together with time features such as signals, timed terms, timed atoms and timed clauses (rules). The resulting formalism combines in a very high level and uniform way the main features of functional and logic programming with new features regarding the use of time thanks to some temporal operators. We dene rst our framework by its syntax and semantics. Then, we tackle the problem of the operational semantics by dening an ecient calculus which is proven to be sound. Finally, we show how our framework compares to related work such as tccp, temporal logic programming and synchronous languages. 1", "num_citations": "7\n", "authors": ["1764"]}
{"title": "Sur l'int\u00e9gration des langages alg\u00e9briques et logique\n", "abstract": " Ce m\u00e9moire pr\u00e9sente l'\u00e9tude d'une approche particuli\u00e8re des langages de programmation logico-fonctionnels, fond\u00e9e sur la logique des clauses de Horn avec \u00e9galit\u00e9. Nous d\u00e9finissons d'abord la syntaxe et la s\u00e9mantique des programmes que nous consid\u00e9rons. La syntaxe est celle de la logique des clauses de Horn avec \u00e9galit\u00e9. La s\u00e9mantique est donn\u00e9e par le plus petit e-modele de Herbrand associe a un programme. Nous nous int\u00e9ressons ensuite au calcul dans ce langage. Nous proposons pour cela une nouvelle r\u00e8gle appel\u00e9e sldei-resolution comme seule r\u00e8gle de calcul. Nous montrons sa coh\u00e9rence, sa compl\u00e9tude ainsi que sa completude forte. La mise en \u0153uvre de la r\u00e8gle sldei-resolution n\u00e9cessite un algorithme de resolution d'\u00e9quations. Nous \u00e9tudions de tels algorithmes fondes sur la relation de surreduction, et am\u00e9liorons ces algorithmes par l'utilisation de strat\u00e9gies de surreduction. Cependant, ces strat\u00e9gies ne sont pas compl\u00e8tes dans le cas g\u00e9n\u00e9ral. Nous proposons alors des conditions suffisantes sur ces strat\u00e9gies afin de pr\u00e9server la compl\u00e9tude des algorithmes consid\u00e9r\u00e9s. Nous caract\u00e9risons ensuite une classe de programmes, dits uniformes, pour lesquels l'utilisation de n'importe quelle strat\u00e9gie de surreduction donne un algorithme complet de resolution d'\u00e9quations. Nous donnons de plus une methode de v\u00e9rification de l'uniformit\u00e9 d'un programme. Par ailleurs, nous proposons des conditions syntaxiques pour qu'un programme soit uniforme. Enfin, nous d\u00e9crivons les principaux traits d'un langage de programmation fonde sur l'approche pr\u00e9sent\u00e9e dans ce m\u00e9moire, et l'implantation que nous avons r\u00e9alis\u00e9e", "num_citations": "7\n", "authors": ["1764"]}
{"title": "Verifying graph transformation systems with description logics\n", "abstract": " We address the problem of verification of graph transformations featuring actions such as node merging and cloning, addition and deletion of nodes and edges, node or edge labeling and edge redirection. We introduce the considered graph rewrite systems following an algorithmic approach and then tackle their formal verification by proposing a Hoare-like weakest precondition calculus. Specifications are defined as triples of the form  where Pre and Post are conditions specified in a given Description Logic (DL), R is a graph rewrite system and strategy is an expression stating in which order the rules in R are to be performed. We prove that the proposed calculus is sound and characterize which DL logics are suited or not for the targeted verification tasks, according to their expressive power.", "num_citations": "6\n", "authors": ["1764"]}
{"title": "Graph rewriting with polarized cloning\n", "abstract": " We tackle the problem of graph transformation with a particular focus on node cloning. We propose a new approach to graph rewriting where nodes can be cloned zero, one or more times. A node can be cloned together with all its incident edges, with only its outgoing edges, with only its incoming edges or with none of its incident edges. We thus subsume previous works such as the sesqui-pushout, the heterogeneous pushout and the adaptive star grammars approaches. A rewrite rule is defined as a span where the right-hand and left-hand sides are graphs while the interface is a polarized graph. A polarized graph is a graph endowed with some annotations on nodes. The way a node is cloned is indicated by its polarization annotation. We use these annotations for designing graph transformation with polarized cloning. We show how a clone of a node can be built according to the different possible polarizations and define a rewrite step as a final pullback complement followed by a pushout. This is called the polarized sesqui-pushout approach. We also provide an algorithmic presentation of the proposed graph transformation with polarized cloning.", "num_citations": "6\n", "authors": ["1764"]}
{"title": "Modeling pointer redirection as cyclic term-graph rewriting\n", "abstract": " We tackle the problem of data-structure rewriting including global and local pointer redirections. Each basic rewrite step may perform three kinds of actions:(i) Local redirection, the aim of which is to redirect specific pointers determined by means of a pattern;(ii) Replacement, that may add new information to data-structures;(iii) Global redirection, which is aimed at redirecting all pointers targeting a node towards another one. We define a new framework, following the double-pushout approach, where graph rewrite rules may mix these three kinds of actions in a row. We define first the category of graphs we consider and then we define rewrite rules as pairs of graph homomorphisms of the form L\u2190 K\u2192 R. In our setting, graph K is not arbitrary, it is used to encode pointer redirection. Furthermore, pushouts do not always exist and complement pushouts, when they exist, are not unique. Despite these concerns, our\u00a0\u2026", "num_citations": "6\n", "authors": ["1764"]}
{"title": "Integrating action definitions into concurrent declarative programming\n", "abstract": " The semantics of a process defines the actions it can execute. Thus actions constitute an essential notion for concurrent systems. In this paper, we tackle the problem of integrating the definition of actions within the context of concurrent constraint functional logic programming. We propose to define actions in a meta-language, where abstract data types of programs are available, as functions from constraint functional logic programs to themselves. We illustrate our approach through some examples and compare our approach to related work.", "num_citations": "6\n", "authors": ["1764"]}
{"title": "Reference manual of the LPG specification language and environment\n", "abstract": " \\LPG\" is an acronym standing for\\Langage pour la Programmation Generique\", ie\\Language for Generic Programming\".", "num_citations": "6\n", "authors": ["1764"]}
{"title": "Parallel graph rewriting with overlapping rules\n", "abstract": " We tackle the problem of simultaneous transformations of networks represented as graphs. Roughly speaking, one may distinguish two kinds of simultaneous or parallel rewrite relations over complex structures such as graphs: (i) those which transform disjoint subgraphs in parallel and hence can be simulated by successive mere sequential and local transformations and (ii) those which transform overlapping subgraphs simultaneously. In the latter situations, parallel transformations cannot be simulated in general by means of successive local rewrite steps. We investigate this last problem in the framework of overlapping graph transformation systems. As parallel transformation of a graph does not produce a graph in general, we propose first some sufficient conditions that ensure the closure of graphs by parallel rewrite relations. Then we mainly introduce and discuss two parallel rewrite relations over graphs. One relation is functional and thus deterministic, the other one is not functional for which we propose sufficient conditions which ensure its confluence.", "num_citations": "5\n", "authors": ["1764"]}
{"title": "Coding, executing and verifying graph transformations with small-tALCQe\n", "abstract": " This paper gives an overview of small-tALCQe, an experi-mental programming environment for a graph transformation languagethat is based on the ALCQ description logic. small-tALCQe not onlyallows developers coding and executing graph transformations but alsoassists them in analyzing and verifying their codes. We describe the com-ponents that make up small-tALCQe: the transformation language itself,the compiler for generating executable transformations, the code ana-lyzers and the prover for reasoning about transformations. All of theminteract under the hood of an Eclipse user interface to provide differentlevels of assistance for achieving correct graph transformations.", "num_citations": "5\n", "authors": ["1764"]}
{"title": "Provably correct graph transformations with small-talc\n", "abstract": " We present a prototype for executing and verifying graph transformations. The transformations are written in a simple imperative programming language, and pre-and post-conditions as well as loop invariants are specified in the Description Logic ALC (whence the name of the tool). The programming language has a precisely defined operational semantics and a sound Hoare-style calculus. The tool consists of the following sub-components: a compiler to Java for executing the transformations; a verification condition generator; and a tableau prover for an extension of ALC capable of deciding the generated verification conditions. A description of these components and their interaction is the main purpose of this paper.", "num_citations": "5\n", "authors": ["1764"]}
{"title": "A term-graph clausal logic: completeness and incompleteness results\u2605\n", "abstract": " A clausal logic allowing to handle term-graphs is defined. Term-graphs are a generalization of terms (in the usual sense) possibly containing shared subterms and cycles. The satisfiability problem for this logic is shown to be undecidable (not even semi-decidable), but some fragments are identified for which it is semi-decidable. A complete (w.r.t validity) calculus for these fragments is proposed. Some simple examples give a taste of this calculus at work.", "num_citations": "5\n", "authors": ["1764"]}
{"title": "Non strict confluent rewrite systems for data-structures with pointers\n", "abstract": " We introduce a notion of rewrite rules operating on a particular class of data-structures, represented as (cyclic) term-graphs. All basic transformations are available: node creation/deletion, node relabeling and edge redirections (including global redirections). This allows one to write algorithms handling pointers that cannot be efficiently specified using existing declarative languages. Such rewrite systems are not confluent in general, even if we stick to orthogonal, left-linear rules. In order to ensure unique normal forms, we introduce a notion of priority ordering between the nodes, which allows the programmer to control the normalization of a graph if needed. The use of total priority orderings makes rewriting purely deterministic, which is not always efficient in practice. To overcome this issue, we then show how to define more flexible strategies, which yield shorter derivations and avoid useless rewriting steps\u00a0\u2026", "num_citations": "5\n", "authors": ["1764"]}
{"title": "A Graph Clausal Logic\n", "abstract": " We propose a (clausal) logic for reasoning about term-graphs, ie terms with sharing of common subexpressions and cycles. These graphs are seen as representations of infinite terms, hence two bisimilar term-graphs are considered as equivalent. The satisfiability problem is undecidable (not even semi-decidable) for this logic, but we propose inference rules allowing to reason on the considered formulae. We illustrate their possibilities on some simple examples.", "num_citations": "5\n", "authors": ["1764"]}
{"title": "LPG: A generic, logic and functional programming language\n", "abstract": " LPG is a programming language designed to implement and to experiment new concepts in the field of specification languages. In LPG, programs are\" theories\" in Horn clause logic with equality [3][4]. Syntactically, a program is a theory presentation TP=(S,~, l'I, E, C) in which sorts (S), operators (Y.) and predicates (II) can be declared; operators are specified by conditional equations (E), and predicates are specified by Horn clauses (C). Litterals of a clause body may be equalities on terms. There are three kinds of presentations:(i) presentations of\" properties\"(ie class of structures like group theory, ring theory, etc);(ii) presentations of data types (ie definitions of sorts, operators and/or predicates) where the semantics is given by initial models;(iii) presentations of enrichments (ie hierarchical definitions of new operators and/or predicates on data types previously defined). Moreover, data type and enrichment\u00a0\u2026", "num_citations": "5\n", "authors": ["1764"]}
{"title": "True parallel graph transformations: an algebraic approach based on weak spans\n", "abstract": " We address the problem of defining graph transformations by the simultaneous application of direct transformations even when these cannot be applied independently of each other. An algebraic approach is adopted, with production rules of the form $L\\xleftarrow{l}K \\xleftarrow{i} I \\xrightarrow{r} R$, called weak spans. A parallel coherent transformation is introduced and shown to be a conservative extension of the interleaving semantics of parallel independent direct transformations. A categorical construction of finitely attributed structures is proposed, in which parallel coherent transformations can be built in a natural way. These notions are introduced and illustrated on detailed examples.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "C2PDLS: A Combination of Combinatory and Converse PDL with Substitutions.\n", "abstract": " We introduce a logic called C2PDLS, motivated by some reasoning about graph rewriting systems. C2PDLS is an extension of both combinatory propositional dynamic logic, usually written CPDL, and converse propositional dynamic logic, usually written CPDL too. In addition to the existing features of both CPDLs, the introduced logic offers the possibility to use the notion of substitutionsa la Hoare within its formulae. Such substitutions reflect the effect of some actions on graph structures such as addition or deletion of edges or nodes. These last features led us to introduce restricted universal roles over subsets of the universe. We propose a sound and complete deductive system for C2PDLS and show that its validity problem is decidable.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "Categorical abstract rewriting systems and functoriality of graph transformation\n", "abstract": " Rewriting systems are often defined as binary relations over a given set of objects. This simple definition is used to describe various properties of rewriting such as termination, confluence, normal forms etc. In this paper, we introduce a new notion of abstract rewriting in the framework of categories. Then, we define the functoriality property of rewriting systems. This property is sometimes called vertical composition. We show that most of graph transformation systems are functorial and provide a counter-example of graph transformation systems which is not functorial.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "Statically assuring secrecy for dynamic concurrent processes\n", "abstract": " We propose a new algorithm of secrecy analysis in a framework integrating declarative programming and concurrency. The analysis of a program ensures that information can only flow from less sensitive levels toward more sensitive ones. Our algorithm uses a terminating abstract operational semantics which reduces the problem of secrecy to constraint solving within finite lattices. It departs in that from the previous works essentially based on type systems. Furthermore, our proposal is general and tackles a very large class of programs, featuring dynamic process creation, general sequential composition, recursive process calls and high level synchronization.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "Redundancy of arguments reduced to induction\n", "abstract": " We demonstrate that the problem of identifying redundant arguments of function symbols, i.e. parameters which can be replaced by any expression without changing the associated semantics, boils down to proving the validity of a particular class of inductive theorems in the equational theory of confluent, sufficiently complete term rewriting systems (TRSs). Hence, existing results for proving inductive theorems can be exploited to solve the problem in many interesting cases where previously developed methods fail to recognize and remove redundancies. In particular, this novel formulation directly yields a new decidability result for the redundancy problem which is based on the so-called standard theories. As an additional result which stems from the inductive encoding of the redundancy problem, we finally propose two different techniques for the analysis of redundant arguments, which are respectively based on\u00a0\u2026", "num_citations": "4\n", "authors": ["1764"]}
{"title": "Timed term rewrite systems\n", "abstract": " We propose a new class of rewrite systems that are conservative extensions of first-order conditional term rewrite systems together with time features such as clocks, signals, timed terms, timed atoms and timed rules. We define first timed term rewrite systems by their syntax and illustrate them through some examples. We provide then a semantics based on labelled transition systems. Finally, we show how our framework compares to related work.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "On weakly orthogonal constructor-based graph rewriting\n", "abstract": " We investigate the rewrite relation over graphs induced by constructor-based weakly orthogonal graph rewriting systems. It is well known that this relation is not con uent in general whereas it is con uent in the case of weakly orthogonal term rewriting systems. We show, however, that the considered relation is always con uent, as well as con uent modulo bisimilarity, for a large class of graphs called admissible graphs. Afterwards, we consider parallel graph rewriting and propose a parallel graph rewriting strategy which is optimal with respect to strategies that do not consider the right-hand sides of the rules.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "Resolution of goals with the functional and logic programming language LPG: impact of abstract interpretation\n", "abstract": " LPG [1, 5] belongs to the class of languages designed for software specification, rapid prototyping and high-level programming. It allows one to define abstract data types, functions and predicates within one unified framework: Horn clause logic with equality. An implementation of LPG for SUN4/SunOS 4.1. 3 is available by URL ftp://ftp.\u2022 fr/pub/SC0P/LPG. The LPG calculus, designed to solve goals~ la Prolog, is mainly based on narrowing techniques. These techniques yield semi-decidable algorithms. Recently, we have shown in [2, 4] how abstract interpretation may help to improve the operational semantics of LPG-like languages. In this demonstration, we intend to present the specification and programming styles of LPG as well as the capabilities of the\" solver\" augmented with abstract term rewrite systems.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "A parallel narrowing strategy\n", "abstract": " We generalize to narrowing the notion of necessary set of redexes proposed by Sekar and Ramakrishnan for rewriting in weakly orthogonal, constructor-based rewrite systems. We de ne two strategies, one sequential and the other parallel, based on this notion. Both strategies are sound and complete. The parallel strategy is a conservative extensions of two optimal strategies. When applied to inductively sequential rewrite systems, it behaves as needed narrowing and when applied to ground terms it behaves as Sekar and Ramakrishnan rewriting strategy.", "num_citations": "4\n", "authors": ["1764"]}
{"title": "LPG: A generic, logic and functional programming language\n", "abstract": " LPG is a programming language designed to implement and experiment new concepts in the field of specification languages. In LPG, programs are theories in Horn clause logic with equality [3][4]. Syntactically, a program is a theory presentation TP=(S, Y., 1-I, E, C) in which sorts (S), operators (Z) and predicates (~) can be declared; operators are specified by conditional equations (E), and predicates are specified by Horn clauses (C). Literals of a clause body may be equalities on terms. There are three kinds of presentations: properties (ie class of structures like group theory, ring theory, etc.); data types where the semantics is given by initial models; enrichments (ie hierarchical definitions of new operators and predicates on previously defined data types).Moreover, data type and enrichment presentations may be parameterized by properties [1], thus providing generic data types and generic enrichments. It is also\u00a0\u2026", "num_citations": "4\n", "authors": ["1764"]}
{"title": "Applied graph transformation and verification with use cases in malaria surveillance\n", "abstract": " Malaria is one of the leading causes of death and illness in sub-Saharan Africa. In order to make timely decisions for control and elimination of malaria, researchers, and clinicians need access to integrated consistent knowledge sources. These knowledge sources often rely on dynamic and constantly changing databases and ontologies. It is crucial to manage changes and ensure that these changes do not cause inconsistencies in the integrated knowledge source. To this end, we propose the use of a formal model using graph transformations to monitor and manage the changes in a coherent way while preserving the consistency of the integrated structure through classical verification. In this paper, we use an algorithmic approach to graph transformation, instead of the more classical algebraic approach, to express the evolution of the data and ontological structures. In this model, each transformation is the result of\u00a0\u2026", "num_citations": "3\n", "authors": ["1764"]}
{"title": "Verifying graph transformations with guarded logics\n", "abstract": " We consider the problem of verifying graph transformations described by an imperative programming language. This question is particularly relevant for transformation of knowledge bases. We will argue in this paper that previous proof approaches based on dedicated Description Logics were technically complex and often inappropriate for reasoning about preservation of structure of knowledge bases. For these reasons, we explore here an assertion formalism based on the Guarded Fragment of predicate logic, which provides a homogeneous framework. Based on a formal semantics of our transformation language, we show how to extract proof obligations from annotated programs and how to obtain decidable correctness problems.", "num_citations": "3\n", "authors": ["1764"]}
{"title": "A set-theoretic framework for parallel graph rewriting\n", "abstract": " We tackle the problem of attributed graph transformations and propose a new algorithmic approach for defining parallel graph transformations allowing overlaps. We start by introducing some abstract operations over graph structures. Then, we define the notion of rewrite rules as three inclusions of the form . We provide six conditions that parallel graph rewrite relations should ideally satisfy, which lead us to define two distinct full parallel graph rewrite relations. A central notion of regularity of matchings is proved to be equivalent to these six conditions, and to the equality of these two relations. Furthermore, we take advantage of the symmetries that may occur in , ,  and  and define another pair of rewrite relations that factor out possibly many equivalent matchings up to their common symmetries. These definitions and the corresponding proofs combine operations on graphs with group-theoretic notions, thus illustrating the relevance of our framework.", "num_citations": "3\n", "authors": ["1764"]}
{"title": "Accords de niveau de service dans les plateformes dynamiques \u00e0 services\n", "abstract": " Les plates-formes dynamiques \u00e0 services occupent une place de plus en plus pr\u00e9pond\u00e9rante dans l'industrie. Ces plates-formes permettent la r\u00e9alisation d'applications dont l'architecture suit les paradigmes des architectures orient\u00e9es service. Elles sont le support d'ex\u00e9cution pour des services qui apparaissent et disparaissent au cours de l'ex\u00e9cution d'une application. Le niveau de service garanti par des fournisseurs de services est \u00e9galement une pr\u00e9occupation de plus en plus importante. Le niveau de service peut faire l'objet d'un accord entre les fournisseurs et leurs clients. Cet accord de niveau de service est \u00e9tabli apr\u00e8s la n\u00e9gociation d'un contrat. Dans le contexte des plates-formes dynamiques de services, l'accord doit tenir compte de la dynamique des services qui apparaissent et disparaissent souvent de mani\u00e8re impr\u00e9visible. Un des principaux verrous \u00e0 lever dans ce probl\u00e8me est la prise en compte de\u00a0\u2026", "num_citations": "3\n", "authors": ["1764"]}
{"title": "A complete assignment algorithm and its application in constraint declarative languages\n", "abstract": " An important property of answer generation strategies for functional logic programming (FLP) languages is the complete exploration of the solution space. Integrating constraints into FLP proves to be useful in many cases, as the resulting constraint functional logic programming (CFLP) offers more facilities and more efficient operational semantics. CFLP can be achieved using conditional rewrite systems with a narrowing-based operational semantics. A common idea to improve the efficiency of such operational semantics is to use specific algorithms from operations research as constraint solvers. If the algorithm does not return a complete set of solutions, the property of completeness might be lost. We present a real world timetabling problem illustrating this approach. We propose an algorithm, obtained as an integration of three known optimization algorithms for the linear assignment problem (LAP), enumerating solutions to the LAP in order of increasing weight, such that the answer generation is complete again. We show, how the narrowing process can be tailored to use this algorithm and provide an efficient way to solve the timetable generation problem.", "num_citations": "3\n", "authors": ["1764"]}
{"title": "Handling harmless interference\n", "abstract": " We address the issue of confidentiality of information in a context where some authorized functions, called conversion functions, are allowed to downgrade/upgrade the confidentiality level of information. This allows the formalization of several real-world applications, notably applications based on password technology (ATM, login process etc.), which are impossible to deal with under a strict non-interference approach. In this paper we develop a notion of harmless interferences in the sense that if it is formally possible to infer private information from public ones, if it has no impact in practice. To our knowledge this notion has not been investigated so far. We propose a formal definition of harmless interference in a concurrent declarative programming setting and define a corresponding verification algorithm based on constraint solving.", "num_citations": "3\n", "authors": ["1764"]}
{"title": "Parallel graph narrowing\n", "abstract": " We investigate graph narrowing as the operational semantics of functional logic programming languages. We mainly show and discuss how weakly needed narrowing as well as parallel narrowing may be extended to graph structures.", "num_citations": "3\n", "authors": ["1764"]}
{"title": "Parallel rewriting of attributed graphs\n", "abstract": " Some computations can be elegantly presented as the parallel or simultaneous application of rules. This is the case of cellular automata and of simultaneous assignments in Python. In both cases the expected result cannot be obtained by a sequential application of rules. A general framework of attributed graph transformations is proposed where such computations can be expressed and analyzed. Determinism is achieved by an exhaustive parallel application of rules, as in cellular automata that are shown to have a straightforward representation in this framework. A more concise parallel transformation is also proposed, where some applications of rules can be ignored thanks to their symmetries, while preserving determinism. Parallel transformations are then used to characterize the property of parallel independence.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "Parallel coherent graph transformations\n", "abstract": " Cellular automata as well as simultaneous assignments in Python can be understood as the parallel application of local rules to a grid or an environment that can be easily represented as an attributed graph. Since the result of such transformations cannot generally be obtained by a sequential application of the involved rules, this situation infringes the standard notion of parallel independence. An algebraic approach with production rules of the form is adopted and a condition of parallel coherence more general than parallel independence is formulated, that enable the definition of the Parallel Coherent Transformation (PCT). This transformation supports a generalisation of the Parallelism Theorem in the theory of adhesive HLR categories, showing that the PCT yields the expected result of sequential rewriting steps when parallel independence holds. Categories of finitely attributed structures are\u00a0\u2026", "num_citations": "2\n", "authors": ["1764"]}
{"title": "Combining Parallel Graph Rewriting and Quotient Graphs\n", "abstract": " We define two graph transformations, one by parallelizing graph rewrite rules, the other by taking quotients of graphs. The former consists in the exhaustive application of local transformations defined by graph rewrite rules expressed in a set-theoretic framework. Compared with other approaches to parallel rewriting, we allow a substantial amount of overlapping only restricted by a condition called the effective deletion property. This transformation can be reduced by factoring out possibly many equivalent matchings by the automorphism groups of the rules. The second transformation is based on the use of equivalence relations over graph items and offers a new way of performing simultaneous merging operations. The relevance of combining the two transformations is illustrated on a running example.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "Algebraic graph rewriting with controlled embedding\n", "abstract": " Graph transformation is a specification technique suitable for a wide range of applications, specially the ones that require a sophisticated notion of state. In graph transformation, states are represented by graphs and actions are specified by rules. Most algebraic approaches to graph transformation proposed in the literature ensure that if an item is preserved by a rule, so are its connections with the graph where it is embedded. But there are applications in which it is desirable to specify different embeddings. For example when cloning an item, there may be a need to handle the original and the copy in different ways. We propose a new algebraic approach to graph transformation, AGREE: Algebraic Graph Rewriting with controllEd Embedding, where rules allow one to specify how the embedding should be carried out. We define this approach in the framework of classified categories which are categories endowed\u00a0\u2026", "num_citations": "2\n", "authors": ["1764"]}
{"title": "On the verification of logically decorated graph transformations\n", "abstract": " We address the problem of reasoning on graph transformations featuring actions such as \\emph{addition} and \\emph{deletion} of nodes and edges, node \\emph{merging} and \\emph{cloning}, node or edge \\emph{labelling} and edge \\emph{redirection}. First, we introduce the considered graph rewrite systems which are parameterized by a given logic . Formulas of  are used to label graph nodes and edges. In a second step, we tackle the problem of formal verification of the considered rewrite systems by using a Hoare-like weakest precondition calculus. It acts on triples of the form  where \\texttt{Pre} and \\texttt{Post} are conditions specified in the given logic , \\texttt{R} is a graph rewrite system and \\texttt{strategy} is an expression stating how rules in \\texttt{R} are to be performed. We prove that the calculus we introduce is sound. Moreover, we show how the proposed framework can be instantiated successfully with different logics. We investigate first-order logic and several of its decidable fragments with a particular focus on different dialects of description logic (DL). We also show, by using bisimulation relations, that some DL fragments cannot be used due to their lack of expressive power.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "On simultaneous transformations with overlapping graph rewrite systems\n", "abstract": " We  tackle  the  problem  of  simultaneous  transformations  of  networks  represented  as graphs.   Roughly  speaking,  one  may  distinguish  two  kinds  of  simultaneous  or  parallel rewrite relations over complex structures such as graphs: (i) those which transform disjoint subgraphs in parallel and hence can be simulated by successive mere sequential and local transformations and (ii) those which transform overlapping subgraphs simultaneously.  In the  latter  situations,  parallel  transformations  cannot  be  simulated  in  general  by  means of  successive  local  rewrite  steps.   We  investigate  this  last  problem  in  the  framework  of overlapping graph transformation systems.  As parallel transformation of a graph does not produce  a  graph  in  general,  we  propose  first  some  sufficient  conditions  that  ensure  the closure of graphs by parallel rewrite relations.  Then we mainly introduce and discuss two parallel\u00a0\u2026", "num_citations": "2\n", "authors": ["1764"]}
{"title": "Graph Transformation: 9th International Conference, ICGT 2016, in Memory of Hartmut Ehrig, Held as Part of STAF 2016, Vienna, Austria, July 5-6, 2016, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 9th International Conference on Graph Transformation, ICGT 2016, held as part of STAF 2016, in Vienna, Austria, in July 2016. The 14 papers presented in this were carefully reviewed and selected from 33 submissions. They were organized in topical sections named: foundations, tools and algorithms, queries, and applications. The book also contains one keynote paper in full paper length. The book is dedicated to Hartmut Ehrig, one of the fathers and most productive members of the Graph Transformation community, who passed away in 2016. An obituary is included in the front matter of the volume.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "Transformation of Attributed Structures with Cloning (long version)\n", "abstract": " Copying, or cloning, is a basic operation used in the specification of many applications in computer science. However, when dealing with complex structures, like graphs, cloning is not a straightforward operation since a copy of a single vertex may involve (implicitly)copying many edges. Therefore, most graph transformation approaches forbid the possibility of cloning. We tackle this problem by providing a framework for graph transformations with cloning. We use attributed graphs and allow rules to change attributes. These two features (cloning/changing attributes) together give rise to a powerful formal specification approach. In order to handle different kinds of graphs and attributes, we first define the notion of attributed structures in an abstract way. Then we generalise the sesqui-pushout approach of graph transformation in the proposed general framework and give appropriate conditions under which attributed structures can be transformed. Finally, we instantiate our general framework with different examples, showing that many structures can be handled and that the proposed framework allows one to specify complex operations in a natural way.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "On term-graph rewrite strategies\n", "abstract": " We tackle the problem of cyclic term-graph rewriting. We first revisit the classical algorithmic approach to term-graph rewriting by providing a definition of rewrite rules of the form l h s\u2192 r h s where the left-hand sides are term-graphs and the right-hand sides are sequences of actions. Such actions, which specify how to rewrite a term-graph in a stepwise manner, contribute to simplify substantially the definition of cyclic term-graph rewriting. Then we define a new class of term-graph rewrite systems which are confluent over the so-called admissible term-graphs. Finally, we provide an efficient rewrite strategy which contracts only needed redexes and give pointers to other results regarding optimal rewrite strategies of admissible term-graphs.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "Data-structure rewriting\n", "abstract": " We tackle the problem of data-structure rewriting including pointer redirections. We propose two basic rewrite steps: (i) Local Redirection and Replacement steps the aim of which is redirecting specific pointers determined by means of a pattern, as well as adding new information to an existing data ; and (ii) Global Redirection steps which are aimed to redirect all pointers targeting a node towards another one. We define these two rewriting steps following the double pushout approach. We define first the category of graphs we consider and then define rewrite rules as pairs of graph homomorphisms of the form \"L <- K ->R\". Unfortunately, inverse pushouts (complement pushouts) are not unique in our setting and pushouts do not always exist. Therefore, we define rewriting steps so that a rewrite rule can always be performed once a matching is found.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "A generic operator over discrete time intervals\n", "abstract": " We define a new generic operator,\u2207, which can be used within any programming language which allows one to define discrete time intervals. Let \u03a40,..., \u03a4n be the consecutive instants of an interval I, ua term and v\u03a4i the value of u at instant\u03a4i. We define the expression\u2207(O, e, I) u as the first-order term (...((e O v\u03a40) O v\u03a41)... O v\u03a4n). We integrate this operator into timed rewrite systems, illustrate it through several examples and provide an efficient operational semantics which we have implemented.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "Defining actions in concurrent declarative programming\n", "abstract": " Actions are essential in the description of processes, since processes are characterised by the actions they can execute. In this paper, we tackle the problem of the definition of actions within the context of a component-based approach to concurrent declarative programming. In this computation model, a system is modeled by a set of interacting components, where each component consists of a declarative program, called store, and a set of processes.We give first an overview of the considered computation model for concurrent declarative programming. In a second step, we propose to define actions as functions from declarative programs to themselves, using a meta-language, where abstract data types of declarative programs are available. We illustrate our approach through several examples and compare our approach to related work.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "On the operational semantics of timed rewrite systems\n", "abstract": " We propose an efficient operational semantics for a new class of rewrite systems, namely timed rewrite systems. This class constitute a conservative extension of first-order conditional term rewrite systems together with time features such as clocks, signals, timed terms, timed atoms and timed rules. We define first timed rewrite systems and illustrate them through some examples. A naive approach to the operational semantics is very costly in space. We propose, for a large class of programs, an improved calculus with a linear space complexity. Finally, we show how our framework compares to related work.", "num_citations": "2\n", "authors": ["1764"]}
{"title": "An Algebraic Graph Transformation Approach for RDF and SPARQL\n", "abstract": " We consider the recommendations of the World Wide Web Consortium (W3C) about RDF framework and its associated query language SPARQL. We propose a new formal framework based on category theory which provides clear and concise formal definitions of the main basic features of RDF and SPARQL. We define RDF graphs as well as SPARQL basic graph patterns as objects of some nested categories. This allows one to clarify, in particular, the role of blank nodes. Furthermore, we consider basic SPARQL CONSTRUCT and SELECT queries and formalize their operational semantics following a novel algebraic graph transformation approach called POIM.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "All You Need Is CONSTRUCT\n", "abstract": " In SPARQL, the query forms SELECT and CONSTRUCT have been the subject of several studies, both theoretical and practical. However, the composition of such queries and their interweaving when forming involved nested queries has not yet received much interest in the literature. We mainly tackle the problem of composing such queries. For this purpose, we introduce a language close to SPARQL where queries can be nested at will, involving either CONSTRUCT or SELECT query forms and provide a formal semantics for it. This semantics is based on a uniform interpretation of queries. This uniformity is due to an extension of the notion of RDF graphs to include isolated items such as variables. As a key feature of this work, we show how classical SELECT queries can be easily encoded as a particular case of CONSTRUCT queries.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "A set-theoretic framework for parallel graph rewriting\n", "abstract": " We tackle the problem of attributed graph transformations and propose a new algorithmic approach for defining parallel graph transformations allowing overlaps. We start by introducing some abstract operations over graph structures. Then, we define the notion of rewrite rules as three inclusions of the form . We provide six conditions that parallel graph rewrite relations should ideally satisfy, which lead us to define two distinct full parallel graph rewrite relations. A central notion of regularity of matchings is proved to be equivalent to these six conditions, and to the equality of these two relations. Furthermore, we take advantage of the symmetries that may occur in , ,  and  and define another pair of rewrite relations that factor out possibly many equivalent matchings up to their common symmetries. These definitions and the corresponding proofs combine operations on graphs with group-theoretic\u00a0\u2026", "num_citations": "1\n", "authors": ["1764"]}
{"title": "Graph Transformations\n", "abstract": " This volume contains the proceedings of ICGT 2016, the 9th International Conference on Graph Transformation. The conference was held in Vienna, Austria, during July 5\u20136, 2016. ICGT 2016 took place under the auspices of the European Association of Theoretical Computer Science (EATCS), the European Association of Software Science and Technology (EASST), and the IFIP Working Group 1.3, Foundations of Systems Specification. It was affiliated with STAF (Software Technologies: Applications and Foundations), a federation of leading conferences on software technologies. The aim of the ICGT series 1 is to bring together researchers from different areas interested in all aspects of graph transformation. Graph structures are used almost everywhere when representing or modeling data and systems, not only in applied and theoretical computer science, but also in, eg, natural and engineering sciences. Graph\u00a0\u2026", "num_citations": "1\n", "authors": ["1764"]}
{"title": "SROIQsigma is decidable\n", "abstract": " We consider a dynamic extension of the description logic . This means that interpretations could evolve thanks to some actions such as addition and/or deletion of an element (respectively, a pair of elements) of a concept (respectively, of a role). The obtained logic is called  with explicit substitutions and is written . Substitution is not treated as meta-operation that is carried out immediately, but the operation of substitution may be delayed, so that sub-formulae of  are of the form , where  is a  formula and  is a substitution which encodes changes of concepts and roles. In this paper, we particularly prove that the satisfiability problem of  is decidable.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "A Modal Logic for Termgraph Rewriting\n", "abstract": " We propose a modal logic tailored to describe graph transformations and discuss some of its properties. We focus on a particular class of graphs called termgraphs. They are first-order terms augmented with sharing and cycles. Termgraphs allow one to describe classical data-structures (possibly with pointers) such as doubly-linked lists, circular lists etc. We show how the proposed logic can faithfully describe (i) termgraphs as well as (ii) the application of a termgraph rewrite rule (i.e. matching and replacement) and (iii) the computation of normal forms with respect to a given rewrite system. We also show how the proposed logic, which is more expressive than propositional dynamic logic, can be used to specify shapes of classical data-structures (e.g. binary trees, circular lists etc.).", "num_citations": "1\n", "authors": ["1764"]}
{"title": "A needed rewriting strategy for data-structures with pointers\n", "abstract": " We propose a reduction strategy for systems of rewrite rules operating on term-graphs. These term-graphs are intended to encode pointer-based data-structures that are commonly used in programming, with cycles and sharing. We show that this reduction strategy is optimal w.r.t. a given dependency schema, which intuitively encodes the \u201cinterferences\u201d among the nodes in the term-graphs. We provide a new way of computing such dependency schemata.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "Adjunction for garbage collection with application to graph rewriting\n", "abstract": " We investigate garbage collection of unreachable parts of rooted graphs from a categorical point of view. First, we define this task as the right adjoint of an inclusion functor. We also show that garbage collection may be stated via a left adjoint, hence preserving colimits, followed by two right adjoints. These three adjoints cope well with the different phases of a traditional garbage collector. Consequently, our results should naturally help to better formulate graph transformation steps in order to get rid of garbage (unwanted nodes). We illustrate this point on a particular class of graph rewriting systems based on a double pushout approach and featuring edge redirection. Our approach gives a neat rewriting step akin to the one on terms, where garbage never appears in the reduced term.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "On collapsing narrowing\n", "abstract": " Narrowing constitutes the basis of the operational semantics of modern declarative languages which integrate functional and logic programming paradigms. Efficient implementations of these languages consider first-order terms as graphs. In this paper, we investigate narrowing in the setting of graph rewriting systems. We take the full advantage of graph structures by allowing maximal sharing of subexpressions and extend the completeness results of the best known narrowing strategies such as needed narrowing or parallel narrowing to the case of constructor-based weakly admissible graph rewrite systems. The resulting graph narrowing strategies share the same optimality results as the corresponding ones for first-order terms and in addition develop shorter derivations.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "A concurrent extension of functional logic programming languages\n", "abstract": " We present a concurrent extension of functional logic programming languages together with a compositional semantics based on labelled sequences, which takes into account the environment of the program. This framework allows to specify, at a very high level, applications that need concurrency and interaction with the environment. For that, we introduce the possibility of defining processes (agents) which specify the dynamics (evolution) of a classical functional logic program, including its communication with the environment. The resulting formalism integrates in a uniform way the main features of functional, logic and concurrent programming.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "Integrating Disequations in the Algebraic and Logic Programming Language LPG.\n", "abstract": " This paper gives a brief description of the recent improvements of the algebraic and logic programming language lpg. We mainly introduce the possibility to use disequations (negation of equations), which involve user's de nable functions, in the de nition of predicates. Then we describe the operational semantics of lpg which is based on an extension of SLD? resolution in order to deal with equations and disequations. Also, we give new su cient conditions to ensure the completeness of narrowing strategies, to solve equations and disequations, in the presence of conditional term rewrite systems.", "num_citations": "1\n", "authors": ["1764"]}
{"title": "Examples of LPG specifications\n", "abstract": " Examples of LPG specifications - OpenGrey fra | eng OpenGrey Open System for Information on Grey literature in Europe Home Search Subjects Partners Export Help Search XML To cite or link to this reference: http://hdl.handle.net/10068/43558 Title : Examples of LPG specifications Authors : Bert, Didier ; Drabik, Pascal ; Echahed, Rachid ; Hufflen, Jean-Michel ; Corporate author : Informatique et Mathematiques Appliquees de Grenoble (IMAG), 38 - Saint-Martin-d'Heres (France). Lab. d'Informatique Fondamentale et d'Intelligence Artificielle ; Institut National Polytechnique de Grenoble (INPG), 38 - Grenoble (France). Lab. d'Informatique Fondamentale et d'Intelligence Artificielle (LIFIA) ; Publication year : 1990 Language : English ; Pagination/Size : 65 p. ; SIGLE classification : 09H - Computer software, programming ; Document type : R - Report ; Report number : IMAG-RT--90-58 ; Other identifier : FR ; FR_ 1992:2879 \u2026", "num_citations": "1\n", "authors": ["1764"]}
{"title": "R\u00e9\u00e9criture de graphes admissibles: Confluence et strat\u00e9gie\n", "abstract": " Nous consid\u00e9rons la r\u00e9\u00e9criture de graphes en tant que s\u00e9mantique op\u00e9rationnelle des langages \u201c\u00e9quationnels\u201d. Nous nous pla\u00e7ons dans le cadre des signatures avec constructeurs. Nous commen\u00e7ons par caract\u00e9riser un sous-ensemble de graphes dits graphes admissibles. Un graphe est admissible si aucun de ses cycles ne contient de fonction d\u00e9finie. Ensuite, nous consid\u00e9rons la relation de r\u00e9\u00e9criture sur les graphes admissibles et montrons sa confluence ainsi que sa confluence modulo \u201cla bisimulation\u201d. Enfin, nous d\u00e9finissons une strat\u00e9gie de r\u00e9\u00e9criture pour les graphes admissibles qui calcule toujours des r\u00e9dex n\u00e9cessaires (needed, en anglais).", "num_citations": "1\n", "authors": ["1764"]}