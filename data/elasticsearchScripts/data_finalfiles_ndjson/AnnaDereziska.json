{"title": "Quality assessment of mutation operators dedicated for C# programs\n", "abstract": " The mutation technique inserts faults in a program under test in order to assess or generate test cases, or evaluate the reliability of the program. Faults introduced into the source code are defined using mutation operators. They should be related to different, also object-oriented features of a program. The most research on OO mutations was devoted to Java programs. This paper describes analytical and empirical study performed to evaluate the quality of advanced mutation operators for C# programs. Experimental results demonstrate effectiveness of different mutation operators. Unit tests suites and functional tests were used in experiments. A detailed analysis was conducted on mutation operators dealing with delegates and exception handling", "num_citations": "64\n", "authors": ["617"]}
{"title": "Advanced mutation operators applicable in C# programs\n", "abstract": " This paper is devoted to advanced mutation operators for C# source code. They deal with object-oriented (OO mutations) and other complex features of the code. They require structural information about a code, unlike the standard mutations. Applicability of OO operators in C# is compared with those for other OO languages. Operators for specific features of C# language are also proposed. The detailed specification of operators can be provided in terms of pre- and post-conditions of a program transformation. Based on the operators\u2019 specification, the generation of mutated C# programs can be automated.", "num_citations": "62\n", "authors": ["617"]}
{"title": "Tool-supported advanced mutation approach for verification of C# programs\n", "abstract": " Mutation testing is a fault-based testing technique used to inject faults into an existing program and see if its test suite is sensitive enough to detect common faults. We are interested in using the mutation analysis to evaluate, compare and improve quality assurance techniques for testing object-oriented mechanisms and other advanced features of C# programs. This paper provides an overview of a current version of the CREAM system (creator of mutants), and reports on its use in experimental research. We apply advanced, object-oriented mutation operators to testing of open-source C# programs and discuss the results.", "num_citations": "49\n", "authors": ["617"]}
{"title": "Code generation and execution framework for UML 2.0 classes and state machines\n", "abstract": " \u2013 The paper presents Framework for eXecutable UML (FXU). FXU transforms UML models into programming code and supports execution of the resulting application according to the behavioral model. The code generation and execution is based on UML classes and their state machines. The FXU framework takes into account all concepts of state machines defined by the UML 2.0 specification. Ambiguities of UML state machine interpretation had to been resolved within the framework in order to obtain an executable application. During the runtime execution separate state machines and orthogonal regions are run as parallel threads. All kinds of events, states, pseudostates and activities are processed, as well. The framework was implemented and tested for C# code. The tool supports model-driven development of high quality applications.", "num_citations": "38\n", "authors": ["617"]}
{"title": "Quality evaluation of object-oriented and standard mutation operators applied to C# programs\n", "abstract": " Mutation testing is a kind of fault injection approach that can be used to generate tests or to assess the quality of test sets. For object-oriented languages, like C#, both object-oriented and standard (traditional) mutation operators should be applied. The methods that can contribute to reducing the number of applied operators and lowering the costs of mutation testing were experimentally investigated. We extended the CREAM mutation tool to support selective testing, sampling and clustering of mutants, and combining code coverage with mutation testing. We propose an approach to quality evaluation and present experimental results of mutation operators applied to C# programs.", "num_citations": "34\n", "authors": ["617"]}
{"title": "Object-oriented mutation to assess the quality of tests\n", "abstract": " The quality of a test suite can be measured using mutation analysis. Groups of OO mutation operators are proposed for testing object-oriented features. The OO operators applied to UML specification and C++ code are illustrated by an example. Experimental results demonstrate effectiveness of different mutation operators and the reduction of functional test suite.", "num_citations": "32\n", "authors": ["617"]}
{"title": "Object-oriented testing capabilities and performance evaluation of the C# mutation system\n", "abstract": " The main purpose of mutation testing approach is to check a test suite quality in terms of the adequacy to killing programs with inserted programming faults. We present advances in the C# mutation testing system that supports object-oriented mutation operators. The system enhancements related to functional requirements (mutation operators, avoiding generation of invalid and partially of equivalent mutants) and non-functional ones (speed-up using a new parser and reflection, space reduction storing mutant updates). Mutation testing of six widely used open source programs is discussed. The quality of the tests supplied with these programs was experimentally determined. Performance measures were evaluated to assess system enhancements (2-4 faster mutants creation, 10-100 times disk space reduction, tradeoff of time overhead for storing mutants of different size in a local or remote repository).", "num_citations": "30\n", "authors": ["617"]}
{"title": "Object-oriented mutation applied in common intermediate language programs originated from c\n", "abstract": " Application of object-oriented mutation operators in C# programs using a parser-based tool can be precise but requires compilation of mutants. Mutations can be introduced faster directly to the Common Intermediate Language of. NET. It can be simple for traditional mutation operators but more complicated for the object-oriented ones. We propose the reconstruction of complex object-oriented faults on the intermediate language level. The approach was tested in the ILMutator tool implementing few object-oriented mutation operators in the intermediate code derived from compiled C# programs. Exemplary mutation and performance results are given and compared to results of the parser-based mutation tool CREAM.", "num_citations": "27\n", "authors": ["617"]}
{"title": "CREAM-a System for Object-oriented Mutation of C# Programs\n", "abstract": " Creator of Mutants (CREAM) is a tool that introduces small faults called mutations into C# programs. It is useful to investigate the quality of a mutated program and effectiveness of a prepared test suite. The CREAM system generates several object-oriented types of faults, puts them into the code of the original program according to its parsed trees, and compiles the modified sources. Obtained assemblies can be tested measuring the number of revealed modifications. CREAM cooperates with NUnit for running of test suites against the set of mutants.", "num_citations": "27\n", "authors": ["617"]}
{"title": "Experimental evaluation of mutation testing approaches to python programs\n", "abstract": " Mutation testing of Python programs raises a problem of incompetent mutants. Incompetent mutants cause execution errors due to inconsistency of types that cannot be resolved before run-time. We present a practical approach in which incompetent mutants can be generated, but the solution is transparent for a user and incompetent mutants are detected by a mutation system during test execution. Experiments with 20 traditional and object-oriented operators confirmed that the overhead can be accepted. The paper presents an experimental evaluation of the first- and higher-order mutation. Four algorithms to the 2nd and 3rd order mutant generation were applied. The impact of code coverage consideration on the process efficiency is discussed. The experiments were supported by the MutPy system for mutation testing of Python programs.", "num_citations": "25\n", "authors": ["617"]}
{"title": "Analysis of mutation operators for the python language\n", "abstract": " A mutation introduced into a source code of a dynamically typed program can generate an incompetent mutant. Such a mutant manifests a type-related error that cannot be detected before the mutant execution. To avoid this problem, a program mutation can be provided at run-time, or incompetent mutants should be automatically detected and eliminated. We showed that the latter solution can effectively be applied providing selected mutation operators. This paper discusses mutation operators to be used for mutation testing of Python programs. Standard and object-oriented mutation operators were applied to the Python language. Python-related operators dealing with decorators and collection slices were proposed. The operators were implemented in MutPy, the tool for mutation testing of Python programs, and experimentally evaluated.", "num_citations": "25\n", "authors": ["617"]}
{"title": "An experimental case study to applying mutation analysis for SQL queries\n", "abstract": " This paper is devoted to evaluation of mutation operators of SQL queries that retrieve information from a database. The operators mimic various faults of the queries that are syntactically correct but produce results unintended by the developers. A case study applies the SQL mutation operators to typical queries commonly used in programs cooperating with a real database implemented in an insurance company. The experimental results of the mutation testing and performance measures are provided. Usability of operators was validated comparing distribution of generated mutants, ability to detect mutants by tests and execution times of mutants.", "num_citations": "19\n", "authors": ["617"]}
{"title": "Realization of UML class and state machine models in the C# code generation and execution framework\n", "abstract": " Anna Derezi\u0144ska and Romuald Pilitowski Institute of Computer Science, Warsaw University of Technology Nowowiejska 15/19, 00-665 Warsaw, Poland E-mail: A. Derezinska@ ii. pw. eu. pl, http://ii. pw. edu. pl/~ adr", "num_citations": "18\n", "authors": ["617"]}
{"title": "Experiences in Testing Automation of a Family of Functional-and GUI-similar Programs.\n", "abstract": " This article presents experiences in the automation of a testing process. The main goal is the unified testing of not only one program, but a whole family of programs. The family is characterized by a common functionality and therefore similar GUI interfaces. The testing process integrates extraction of the application specific data from its executable and the usage of the capture and replay testing technique. The testing of various me mbers of application family is driven by a unified, common script. The approach is illustrated by a case study. As a family of applications under test a set of RSS aggregators was used. A unified test RSSscript was developed and verified in test experiments. The results of functional, performance and regression testing are presented. The benefits and limitations of the solution are discussed.", "num_citations": "16\n", "authors": ["617"]}
{"title": "A quality estimation of mutation clustering in c# programs\n", "abstract": " Mutation testing tasks are expensive in time and resources. Different cost reduction methods were developed to cope with this problem. In this chapter experimental evaluation of mutation clustering is presented. The approach was applied for object-oriented and standard mutation testing of C# programs. The quality metric was used to compare different solutions. It calculates a tradeoff between mutations score accuracy and mutation costs in terms of number of mutants and number of tests. The results show a substantive decrease in number of mutants and tests while suffering a small decline of mutation score accuracy. However the outcome is not superior to other cost reduction methods, as selective mutation or mutant sampling.", "num_citations": "15\n", "authors": ["617"]}
{"title": "Tracing of state machine execution in the model-driven development framework\n", "abstract": " Framework for eXecutable UML (FXU) supports a model-driven approach for creation of reliable applications in C#. Basing on UML classes and their state machines, a source code is generated and executed using a run-time library. All modeling concepts of UML behavioral state machines can be used in the FXU. Tracing of program execution in terms of elements of origin state machines assists program comprehension and verification. This paper presents a new component of the framework for observing traces of program execution. The state machine tracing improved model-driven engineering of an application in comparison to the direct analysis of textual logs generated during the program execution. We discuss system requirements, steps of tracing process and advantages and disadvantages of the solution. The approach was applied in the development of an application simulating a presence server for the\u00a0\u2026", "num_citations": "14\n", "authors": ["617"]}
{"title": "Improving mutation testing process of python programs\n", "abstract": " Mutation testing helps in evaluation of test suite quality and test development. It can be directed to programs of different languages. High cost of a mutation testing process limits its applicability. This paper focuses on mutation testing of Python programs, discussing several issues of mutant creation and execution. It was showed how they can be effectively handled in the Python environment. We discuss introduction of first and higher order mutation in an abstract syntax tree with use of generators, dealing with code coverage with AST, executing mutants via mutant injection into tests. The solutions were used in reengineering of MutPy - a mutation testing tool for Python programs. The improvements were positively verified in mutation experiments.", "num_citations": "11\n", "authors": ["617"]}
{"title": "Evaluation of mutant sampling criteria in object-oriented mutation testing\n", "abstract": " Mutation testing of object-oriented programs differs from that of standard (traditional) mutation operators in accordance to the number of generated mutants and ability of tests to kill mutants. Therefore, outcomes of cost reduction analysis cannot be directly transferred from a standard mutation to an object-oriented one. Mutant sampling is one of reduction methods of the number of generated and tested mutants. We proposed different mutant sampling criteria based on equivalence partitioning in respect to object-oriented program features. The criteria were experimentally evaluated for object-oriented and standard mutation operators applied in C# programs. We compared results using a quality metric, which combines mutation score accuracy with mutation cost factors. In result, class random sampling and operator random sampling are recommended for OO and standard mutation testing, accordingly. With a\u00a0\u2026", "num_citations": "10\n", "authors": ["617"]}
{"title": "Evaluation of deletion mutation operators in mutation testing of c# programs\n", "abstract": " Deletion mutation operators were endorsed to be beneficial in effective evaluation of tests for C and Java in comparison to traditional structural mutation operators. They were also supposed to generate fewer equivalent mutants. In this work we present evaluation of deletion mutation operators in the context of structural and object-oriented operators used in first and second order mutation testing of C# programs. Deletion operators could surpass standard mutation operators in the lower number of generated mutants and decreased mutation testing time. Experiments on C# programs were conducted on statement and operator deletion mutation operators. Considering mutation time, it could be profitable to replace other structural mutation operators with the deletion ones, although there are no distinctive results in reduction of the number of equivalent mutants.", "num_citations": "10\n", "authors": ["617"]}
{"title": "Event processing in code generation and execution framework of UML state machines\n", "abstract": " While generating code not only from UML class diagrams but also from state machines, we have to cope with inconsistencies and semantic variation points of the UML specification. The Framework for eXecutable UML (FXU) transforms UML models into programming code and supports execution of the resulting application according to the behavioral model. The FXU is the first framework supporting all elements of UML 2. x state machines in code generation and execution for C# code. In this paper we focus on the event processing and determination of transition priorities resolved within the framework. Two selected problems of not-distinct event priorities occurring in orthogonal states together with proposed solutions are also presented.", "num_citations": "10\n", "authors": ["617"]}
{"title": "Mutation testing process combined with test-driven development in. net environment\n", "abstract": " In test-driven development, basic tests are prepared for a piece of program before its coding. Many short development cycles are repeated within the process, requiring a quick response of the prepared tests and the tested code extract. Mutation testing, used for evaluation and development of test cases, usually takes a considerable time to obtain a valuable test assessment. We discuss combination of these techniques in one development process. The presented ideas are implemented in VisualMutator \u2013 an extension of Visual Studio. The tool supports selected standard and object-oriented mutations of C# programs. Mutations are introduced at the level of the Common Intermediate Language of .NET. A program or its selected methods can be mutated in a batch process or during interactive sessions.", "num_citations": "9\n", "authors": ["617"]}
{"title": "Towards C# application development using UML state machines: a case study\n", "abstract": " Using a state machine for modeling a class behavior can assist effective development of an application. We discuss a model-driven approach to building a C# application based on UML class models and behavioral state machines. A case study addressed in the paper is devoted to a social network of mobile users. The core of the system is a presence server for the status services in the network. There are three main tasks performed by the server: subscription of a status of another user, publication of a new status with given rules and notification another user about a status. The system architecture and exemplary state machine models are presented. Model to code transformation and development of an executable application was realized by a Framework for eXecutable UML (FXU). Verification of the application was supported by tracing of program execution in terms of model elements using FXU Tracer. On\u00a0\u2026", "num_citations": "8\n", "authors": ["617"]}
{"title": "Interpretation of history pseudostates in orthogonal states of UML state machines\n", "abstract": " Inconsistencies and semantic variation points of the UML specification are a source of problems during code generation and execution of behavioral models. We discuss the interpretation of history concepts of UML 2.x state machines. Especially, history in complex states with orthogonal regions was considered. The clarification of this interpretation was proposed and explained by an example. The history issues and other variation points had to be resolved within the Framework for eXecutable UML (FXU). The FXU was the first framework supporting all elements of UML 2.x behavioral state machines in code generation and execution for C# code.", "num_citations": "7\n", "authors": ["617"]}
{"title": "Interpretation Problems in Code Generation from UML State Machines-a Comparative Study\n", "abstract": " A practical utilisation of a model-driven approach to an information system development is hampered by inconsistencies causing interpretation problems. This paper focuses on the state machine that is a common means for modelling behaviour. A transformation of classes with their state machines into a code assists in the efficient development of reliable applications. A set of interpretation problems of state machines was revisited in accordance with the UML specification and examined on model examples transformed to an executable code. The paper compares the implementation of the problems regarding to two tools that support the transformation and takes into account the most comprehensive set of the UML behavioural state machine concepts. The tools are the IBM Rational Rhapsody, which transforms state machines to C, C++, Java, Ada and the Framework for eXecutable UML (FXU) dealing with the C# code. The basic information about the FXU tool is also given.", "num_citations": "6\n", "authors": ["617"]}
{"title": "Analysis of emerging features of C# language towards mutation testing\n", "abstract": " Evolution of programming languages brings emerging programming features aimed at improving programming efficiency and dependability. All programming mechanisms should be taken into account in development of high quality test suites. Tests case generation and qualification can be supported by a mutation approach. Mutation technique inserts simple changes into a program under test. Faults injected into a source code are defined by mutation operators. Using these operators, many mutated programs, so-called mutants, are generated in a systematic way. Evaluating the adequacy of a test suite, mutants are run against test cases from the suite. A mutant is killed when at least one test case causes it to fail. Mutants that generate exactly the same output as the original program cannot be killed by any test and are called equivalent mutants. Ability to kill mutants is a criterion for generation and selection of test cases. Standard (traditional) mutation operators are dealing with mistakes common to all general purpose languages, eg misusing of relational, logical, arithmetical operators, of variables, constants, etc.[28]. Apart from these operators used in functions of structural programming languages or methods of object-oriented ones, other specialized operators were developed, like intra-and inter-class mutation operators dealing with objectoriented features for Java [13, 17] or C# [4-6], mutations of SQL queries [27], concurrent constructs [2] and others. A survey of mutation testing techniques and problems concerning different programming and specification languages can be found in [12]. A basic core of programming languages is usual stable\u00a0\u2026", "num_citations": "6\n", "authors": ["617"]}
{"title": "Correctness issues of UML class and state machine models in the C# code generation and execution framework\n", "abstract": " Model driven approach for program development can assist in quick generation of complex and highly reliable applications. Framework for eXecutable UML (FXU) transforms UML models into C# source code and supports execution of the application reflecting the behavioral model. The framework consists of two parts code generator and run time library. The generated and executed code corresponds to structural model specified in class diagrams and behavioral model described by state machines of these classes. All single concepts of state machines included in the UML 2.0 specification (and further) are taken into account, including all kinds of events, states, pseudostates, submachines etc. The paper discusses the correctness issues of classes and state machine models that have to be decided in the framework in order to run a model-related and high quality C# application. The solution was tested on set of\u00a0\u2026", "num_citations": "6\n", "authors": ["617"]}
{"title": "Toward generalization of mutant clustering results in mutation testing\n", "abstract": " Mutation testing is effectively used for evaluation of test case quality but suffers from high cost required for its realization. Mutated programs are injected with program changes specified by various mutation operators. One of the methods applied to the reduction of mutant number is mutant clustering. Instead of using all generated mutants, special mutant groups are distinguished and group representatives are used in further evaluation of tests. Mutant clustering gave some promising results for C programs. In case of object-oriented programs with standard and object-oriented operators the results were positive but not superior to other cost reduction techniques. An open issue is interpretation of mutant clustering results and their generalization to other projects in terms of used mutation operators. In this paper, three metrics are proposed to comprehend mutation clustering. Experimental results are analyzed\u00a0\u2026", "num_citations": "5\n", "authors": ["617"]}
{"title": "Experiences from an empirical study of programs code coverage\n", "abstract": " The paper is devoted to functional and structural testing of programs. Experimental results of a set of programs are presented. The experiments cover selection of functional tests, analysis of function and line coverage and optimization of test suites. The comparison of code coverage results and selection of the most effective tests are discussed in the relation to the test-first approach for program development. The types of the code not covered by the tests are classified for different categories.", "num_citations": "5\n", "authors": ["617"]}
{"title": "Reasoning about traceability in imperfect UML projects\n", "abstract": " [2] Denisoff M., Traceability of requirement changes in UML project and their impact into the code reliability, master thesis (in Polish), Inst, of Computer Science, Warsaw University of Technology, 2003.", "num_citations": "5\n", "authors": ["617"]}
{"title": "Operators for mutation testing of Python programs\n", "abstract": " Mutation testing that supports design of high quality test suites of a program. It is based on mutation operators that specify small changes introduced into a program. Python is an interpreted programming language with dynamic typing system. In dynamically typed programs, type consistency rules cannot be statically verified. A mutated program can be an incompetent mutant that manifests an incorrect behavior at runtime due to violation of typing rules. In this paper we specify a set of mutation operators that could be applied to Python programs. Most of them correspond to selected operators used in strongly typed general purpose languages, covering structural and object-oriented mutation operators. They were adopted to the Python language. Operators designed for Python features are also discussed. We try to avoid operators that generate many incompetent mutants. All operators can be applied before a mutated program execution and possible incompetent mutants are to be automatically detected at runtime.", "num_citations": "4\n", "authors": ["617"]}
{"title": "Model-Driven Engineering support for building C# applications\n", "abstract": " Realization of Model-Driven Engineering (MDE) vision of software development requires a comprehensive and user-friendly tool support. This paper presents a UML-based approach for building trustful C# applications. UML models are refined using profiles for assigning class model elements to C# concepts and to elements of implementation project. Stereotyped elements are verified on life and during model to code transformation in order to prevent creation of an incorrect code. The Transform OCL Fragments into C# system (T.O.F.I.C.) was created as a feature of the Eclipse environment. The system extends the IBM Rational Software Architect tool.", "num_citations": "4\n", "authors": ["617"]}
{"title": "Distributed environment integrating tools for software testing\n", "abstract": " This work is devoted to problems of testing many programs using various testing tools of different origin. We present a distributed system, called Tester, which manages and automates testing process. The system is based on client-server architecture and integrates testing tools, including commercial tools, open-source and own applications. It uses repository for storing projects to be tested and database with test results. Different performance issues concerning test automation are discussed and experimentally evaluated. The system was used in mutation testing of C# programs using object-oriented mutation operators, in experiments investigating the relation between line and assembly instruction coverage on the set of C++ programs, and statistic analysis of different program characteristics.", "num_citations": "4\n", "authors": ["617"]}
{"title": "Specification of dependency areas in UML designs\n", "abstract": " A concept of dependency areas can help in tracing an impact of artifacts of a project (requirements, elements of the UML design, extracts of the code) and assist in their evolution. The dependency area of an element of a UML design is a part of the design that is highly influenced by the given initial element. Dependency areas are identified using sets of propagation rules and strategies. Selection strategies control application of many, possible rules. Bounding strategies limit the number of elements assigned to the areas. This paper is devoted to the specification of the rules and strategies. They are specified using an extended UML meta-model and expressions in the Object Constraint Language (OCL).", "num_citations": "4\n", "authors": ["617"]}
{"title": "Enhancements of detecting gang-of-four design patterns in C# programs\n", "abstract": " Gang-of-Four design patterns are valuable architectural artefacts in object-oriented design and implementation. Detection of design patterns in an existing code takes an important role in software evolution and maintenance. A\u00a0lot of work has been devoted to development of methods and tools that support automatic detection of design patterns. There have been scarcely any attempts to detect design patterns in C# programs. We have focused on the refinement and extension of the approach of A. Nagy and B. Kovari. In this paper we discuss the rules for mining of a subset of GoF design patterns in C# applications. These rules have been used to enhance the program that detects design patterns in C# applications. The mining results of both tools were compared.", "num_citations": "3\n", "authors": ["617"]}
{"title": "Approaches to semantic mutation of behavioral state machines in Model-Driven Software Development\n", "abstract": " Behavior of UML state machines can be a source of interpretation problems in model to code transformation. Different solutions to the semantic variants could be defined as a special kind of mutations, similarly as in the mutation testing. State machines together with class models can be a source of an Model-Driven Software Development process aimed at building an executable application. We have compared several approaches to creating applications based on models in which semantic mutation operators of state machine behavior are used. The most promising approach has been utilized to extend the Framework for eXecutable UML (FXU) with semantic mutation facilities. The framework supports code generation from UML classes and their state machines as well as developing C# applications according to selected mutations of state machine behavior. The tool has been used in evaluation of a case study.", "num_citations": "3\n", "authors": ["617"]}
{"title": "Metrics in software development and evolution with design patterns\n", "abstract": " Software metrics are employed in software development and maintenance to assess different quality attributes, support processes of software design, testing, and reengineering. We overview software metrics used with regard to design patterns, especially these dealing with object-oriented program features. Metrics of this kind have also supported certain approaches to refactoring to design patterns. However, code refactoring to design patterns requires selection of suitable code parts and taking decisions about pattern application. In order to make this process partially or fully automated, specialized relevance metrics have been proposed. They were designed as a structure-based assessment of an adequacy of code to be transformed into a given design pattern. Relevance metrics for refactoring to selected design patterns (Replace Type Code with Class, Replace State-Altering Conditions with State) are\u00a0\u2026", "num_citations": "3\n", "authors": ["617"]}
{"title": "Mutation testing of ASP .NET MVC\n", "abstract": " Mutation testing deals with assessing and improving quality of a test suite for a computer program. The range and effectiveness of the method depends on the types of modifications injected by mutation operators. We have checked whether mutation testing technique can be used to evaluate test cases for ASP .NET MVC-based web applications. Several new specific mutation operators were created and discussed. The operator judgment was experimentally verified with the mutation tool implementing the operators in the Common Intermediate Language (CIL) of .NET. The results show that mutation testing can be successfully applied to an application running on a web server, but execution times of functional tests can be long.", "num_citations": "3\n", "authors": ["617"]}
{"title": "Unified automatic testing of a GUI applications' family on an example of RSS aggregators\n", "abstract": " This paper addresses a unification problem of automatic test scripts of GUI applications. We particularly focus on testing a family of applications related by a common functionality. The goal was to make a testing process to the most extend flexible and user independent. The capabilities and limitations of the solution are discussed. The strategy was showed on an example of an applications' family-RSS aggregators. The experiments of functional, performance and regression testing of RSS aggregators are presented.", "num_citations": "3\n", "authors": ["617"]}
{"title": "Evaluation and improvement of web application quality\u2013a case study\n", "abstract": " Web applications, especially those commonly used by a vast number of clients, should fulfill high quality standards. In this paper, we discuss evaluation and improvement of quality attributes on the example of web applications that support city cards for public transport in urban areas. Their quality has been assessed with a set of autonomous evaluation tools in terms of usability, findability in Internet (SEO), accessibility, design, content, mobile, and performance. Quality of the applications has been compared to quality of a new prototype developed as a Single Page Application (SPA). An improved prototype has been created that referred to suggestions offered by the tools. The case study has also presented effects of the prototype improvement on its quality attributes, and relevance of the tool usage.", "num_citations": "2\n", "authors": ["617"]}
{"title": "A structure-driven process of automated refactoring to design patterns\n", "abstract": " Design patterns can be introduced into an existing code by a code restructuring. It is counted to one of goals of code refactoring. This paper presents a process that automates this kind of refactoring. The approach is based on a structural code analysis aimed at design pattern relevance. The process consists of three main phases: code analysis, determination of a refactoring range, and realization of code restructuring. The latter is a complex code2code transformation, which comprises a series of code refactoring steps. A decision about a range of a design pattern application is taken by a user or can be automated. In both cases, it is supported by a software relevance metric. A framework for the whole process has been implemented as an extension of Eclipse. Code refactoring to exemplary design patterns can be performed in a prototype tool for Java programs.", "num_citations": "2\n", "authors": ["617"]}
{"title": "Advances in transformation of MARTE profile time concepts in Model-Driven Software Development\n", "abstract": " UML models can be extended with time concepts from the Modeling and Analysis of Real-Time and Embedded Systems (MARTE) profile. In the Model-Driven Software Development, elements enhanced by stereotypes corresponding to time concepts can be transformed into code and assisted by appropriate library support during an application development and execution. We discuss several issues of the MARTE time concept interpretation and realization in an MDSD approach. Selected solutions were implemented in FXU, a tool for building C# applications based on UML classes and state machines. Realization of the MARTE support was verified in case studies.", "num_citations": "2\n", "authors": ["617"]}
{"title": "Application of Model Transformation in the Generic Framework for Traceability\n", "abstract": " Model transformation approach allows us to develop automatic and flexible solutions for the software evolution. Application of model transformation concepts was shown for the generic framework for traceability in object-oriented designs. Three transformations within the framework were considered: the input transformation of any model to the internal format, the traceability analysis generating a dependency area for a given model, and the output transformation of the resulting dependency area. They can be realized as model-to-model transformations with respect to their metamodels and in accordance to the independently specified transformation rules. In the input and output transformations the language and tools of the QVT standard proposed by the OMG were applied. In the remaining transformation, traceability rules were defined as automata with transitions labeled with conditions and actions.", "num_citations": "2\n", "authors": ["617"]}
{"title": "Evaluation of design pattern utilization and software metrics in C# programs\n", "abstract": " Utilization of design patterns is supposed to have a considerable impact on software quality and to correlate with different software metrics. Much experimental research has considered these issues but almost none related to C# programs. This paper examines utilization of Gang-of-Four design patterns combined with results of software metrics calculated on a set of C# programs. The design patterns have been automatically detected in source code. Analyzed applications with design patterns evaluated to be more complex but in the same time better maintainable than applications without design patterns. Usage of design patterns contributed to a growth in class encapsulation. Classes that implemented design patterns were more complex that other classes used in both types of applications with and without design patterns. The outcomes could be of importance in software maintenance, reverse engineering\u00a0\u2026", "num_citations": "1\n", "authors": ["617"]}
{"title": "Mutating UML State Machine Behavior with Semantic Mutation Operators.\n", "abstract": " In Model-Driven Software Development (MDSD), an application can be built using classes and their state machines as source models. The final application can be tested as any source code. In this paper, we discuss a specific approach to mutation testing in which modifications relate to different variants of behavioural features modelled by UML state machines, while testing deals with standard executions of the final application against its test cases. We have proposed several mutation operators aimed at mutating behaviour of UML state machines. The operators take into account event processing, time management, behaviour of complex states with orthogonal regions, and usage of history pseudostates. Different possible semantic interpretations are associated with each operator. The operators have been implemented in the Framework for eXecutable UML (FXU). The framework, that supports code generation from UML classes and state machines and building target C# applications, has been extended to realize mutation testing with use of multiple libraries. The semantic mutation operators have been verified in some MDSD experiments.", "num_citations": "1\n", "authors": ["617"]}
{"title": "Experiences in Teaching Model Transformation with the QVT Language\n", "abstract": " Model transformation is a fundamental concept of Model Driven Engineering (MDE). Different general purpose or domain specific languages are applied to model-to-model (m2m) transformation. Query View Transformation language (QVT) belongs to the OMG standards. Selected MDE issues are taught to graduate students in a module of an Advanced Methods for Software Engineering course (AMSE). The course is accompanied by laboratory classes, during which meta-models and model-to-model transformations in QVT are designed and practically applied. Despite limited time, simple tasks have been solved and successfully implemented by students. We report on QVT teaching and assessment, laboratory outline, task development, achievements and obstacles faced during several editions of the AMSE course", "num_citations": "1\n", "authors": ["617"]}
{"title": "Performance evaluation of impact of state machine transformation and run-time library on a C# application\n", "abstract": " State machines are important behavioral models used in Model-Driven Development (MDD) of software applications. UML models are transformed into code and combined with a run-time library realizing state machine notions. Mapping of state machine concepts, including concurrent behavior issues, can be realized in various ways. We discuss several problems of call and time event processing and their impact of an application performance. In experiments, different solutions were evaluated and quantitatively compared. These variants were applied in refactoring of FXU - a framework for C# code generation and application development based on UML classes and state machine models.", "num_citations": "1\n", "authors": ["617"]}
{"title": "Application of time concepts from the MARTE profile in a Model-Driven Development case study\n", "abstract": " Z\u0142o\u017cone systemy s\u0105 modelowane z u\u017cyciem maszyn stanowych. Transformacje modeli s\u0142u\u017c\u0105 do budowy wykonywalnych aplikacji. Modele mog\u0105 by\u0107 uszczeg\u00f3\u0142awiane z wykorzystaniem poj\u0119\u0107 czasowych zdefiniowanych w profilu MARTE. W pracy przedstawiono projekt systemu alarmowego ilustruj\u0105cego modelowanie poj\u0119\u0107 czasowych. Transformacja i realizacja aplikacji systemu by\u0142a wykonana przy pomocy FXU-narz\u0119dzia do automatycznej generacji kodu z klas i maszyn stanowych, wspieraj\u0105cego transformacje modeli ze specyfikacj\u0105 czasu z profilu MARTE.", "num_citations": "1\n", "authors": ["617"]}
{"title": "Evaluation of the Contract-Aware Software Development Process in a Controlled Experiment\n", "abstract": " Contract-Aware Software Development (CASD) process combines the Model Driven Engineering (MDE) approach with the Design by Contract ideas performed at the modeling level. Software engineering solutions need empirical investigation on the impact of methodology on the developed products. Therefore we have designed and performed a controlled experiment analyzing the crucial parts of the process. We focused on the CASD process specialized for UML models with contracts specified in the Object Constraint Language (OCL). Models with contracts are automatically transformed into C# code. In the experiment different development phases and their products were evaluated. As a result a high consistency between contract specification at a model and a code level was confirmed. The evidences stressed very high requirements on the tool support, and some inconveniences that still limit\u00a0\u2026", "num_citations": "1\n", "authors": ["617"]}
{"title": "Towards Specialization of the Contract-Aware Software Development Process\n", "abstract": " The contract-based software implementation improves accuracy and verification capabilities of business information systems. This paper promotes contract identification in early phases of the software development and defining contracts within models. Design and implementation artifacts that are responsible for system functionality and system constraints are transformed during the consecutive development phases. Combination of the Model Driven Engineering paradigm and Design by Contract ideas constitutes the Contract Aware Software Development process (CASD). The approach is specialized for system modeling in UML, contracts specified at model level in Object Constraint Language (OCL), and the final implementation in the C# language. The specialized process is supported by the tool transforming the models with associated contracts into the corresponding programs with contracts at the\u00a0\u2026", "num_citations": "1\n", "authors": ["617"]}
{"title": "1. TWORZENIE SYSTEMU Z WYKORZYSTANIEM WSP\u00d3\u0141PRACUJ\u0104CYCH MASZYN STANOWYCH\n", "abstract": " W procesie konstruowania system\u00f3w informatycznych istotn\u0105 rol\u0119 odgrywa modelowanie, kt\u00f3re s\u0142u\u017cy do abstrakcyjnego opisu systemu i ma na celu u\u0142atwienie in\u017cynierowi pracy nad jego tworzeniem. Rozw\u00f3j technologiczny powoduje zainteresowanie coraz to bardziej skomplikowanymi systemami oraz implikuje wzrost liczby problem\u00f3w do rozwi\u0105zania. Przyk\u0142adem takich system\u00f3w jest realizacja mobilnych us\u0142ug przeznaczonych dla ca\u0142ych spo\u0142eczno\u015bci u\u017cytkownik\u00f3w w sieci Internet. Wykonanie tych us\u0142ug zale\u017cy od zmieniaj\u0105cych si\u0119 w czasie i przestrzeni relacji pomi\u0119dzy cz\u0142onkami spo\u0142eczno\u015bci oraz r\u00f3\u017cnych informacji okre\u015blaj\u0105cych ich kontekst.W jednym z podej\u015b\u0107 do procesu budowy systemu okre\u015blonym jako in\u017cynieria oparta na modelu, w skr\u00f3cie MDE (ang. Model Driven Engineering)[4], kluczow\u0105 rol\u0119 odgrywa tworzenie modeli oraz proces ich przekszta\u0142cania. Poszczeg\u00f3lne modele dotycz\u0105 wydzielonych fragment\u00f3w systemu. W miar\u0119 post\u0119pu prac nad tworzonym systemem ulegaj\u0105 one kolejnym transformacjom w celu ich uszczeg\u00f3\u0142owienia, \u0142\u0105czenia i stworzenia ostatecznego modelu w postaci konkretnej implementacji systemu. Dzi\u0119ki takiemu podej\u015bciu integracja systemu z\u0142o\u017conego z r\u00f3\u017cnych wsp\u00f3\u0142pracuj\u0105cych podsystem\u00f3w mo\u017ce by\u0107 przedstawiana i cz\u0119\u015bciowo weryfikowana ju\u017c we wczesnych etapach projektowania systemu.", "num_citations": "1\n", "authors": ["617"]}
{"title": "Towards Model Transformation-a Case Study of Generic Framework for Traceability in Object-Oriented Designs\n", "abstract": " Model transformation approach allows us to develop automatic and flexible solutions for the software evolution. Application of model transformation concepts was shown on a case study of a generic framework for traceability in object-oriented designs. Traceability analysis in the framework is based on discovering traceability relationships among model elements and identifying dependency areas for given initial elements. The analysis is controlled by a set of rules that should be easily modified according to the project notation, application domain, etc. Three transformations within the framework were considered: the input transformation of any model to the internal format, the traceability analysis generating a dependency area for a given model, and the output transformation of the resulting dependency area. They can be realized as model-to-model transformations with respect to their metamodels and in accordance to the independently specified transformation rules. The language and tools of the QVT standard proposed by the OMG were applied in the input and output transformations. In the remaining transformation, traceability rules were defined as automata with transitions labeled with conditions and actions.", "num_citations": "1\n", "authors": ["617"]}
{"title": "Internet Laboratory Instructions for Advanced Software Engineering Course.\n", "abstract": " In this paper a new software engineering laboratory introduced in the Institute of Computer Science Warsaw University of Technology in the fall 2004 is presented. Advanced Software Engineering 2 (SE-2) laboratory consists of seven exercises. Theses exercises are dedicated to requirements engineering, system design with UML [11], reuse, precise modelling with OCL\u2013Object Constraint Language [12], code coverage testing, memory leaks detection and improving application efficiency. Six out of ten SWEBOK [4] knowledge areas are practiced. For each laboratory exercise a set of training materials and instructions were developed. These materials are stored on a department server and are available for all students and lecturers of advanced Software Engineering 2 (SE-2) course. Rational Suite tools are used in laboratory.", "num_citations": "1\n", "authors": ["617"]}
{"title": "Estimating Dependability of Parallel FFT Application using Fault Injection\n", "abstract": " This paper discusses estimation of dependability of a parallel FFT application. The application uses FFTW library. Fault susceptibility is assessed using software implemented fault injection. The fault injection campaign and the experiment results are presented. The response classes to injected faults are analyzed. The accuracy of evaluated data is verified experimentally.", "num_citations": "1\n", "authors": ["617"]}
{"title": "Dependability Evaluation by Fault Injection into Multithreaded Application\n", "abstract": " This paper discusses experimental evaluation of fault susceptibility using software implemented fault injection. The considered multiprocessor system (MIMD) realizes the algorithm for collecting test results. The system was modeled as a multithreaded application. The fault injection setup and the experiment results are presented. The impact of the algorithm enhancements on the number and quality of collected data items was verified experimentally.", "num_citations": "1\n", "authors": ["617"]}