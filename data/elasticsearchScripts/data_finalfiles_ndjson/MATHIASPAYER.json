{"title": "The matter of heartbleed\n", "abstract": " The Heartbleed vulnerability took the Internet by surprise in April 2014. The vulnerability, one of the most consequential since the advent of the commercial Internet, allowed attackers to remotely read protected memory from an estimated 24--55% of popular HTTPS sites. In this work, we perform a comprehensive, measurement-based analysis of the vulnerability's impact, including (1) tracking the vulnerable population,(2) monitoring patching behavior over time,(3) assessing the impact on the HTTPS certificate ecosystem, and (4) exposing real attacks that attempted to exploit the bug. Furthermore, we conduct a large-scale vulnerability notification experiment involving 150,000 hosts and observe a nearly 50% increase in patching by notified hosts. Drawing upon these analyses, we discuss what went well and what went poorly, in an effort to understand how the technical community can respond more effectively to\u00a0\u2026", "num_citations": "766\n", "authors": ["343"]}
{"title": "SoK: Eternal War in Memory\n", "abstract": " Memory corruption bugs in software written in low-level languages like C or C++ are one of the oldest problems in computer security. The lack of safety in these languages allows attackers to alter the program's behavior or take full control over it by hijacking its control flow. This problem has existed for more than 30 years and a vast number of potential solutions have been proposed, yet memory corruption attacks continue to pose a serious threat. Real world exploits show that all currently deployed protections can be defeated. This paper sheds light on the primary reasons for this by describing attacks that succeed on today's systems. We systematize the current knowledge about various protection techniques by setting up a general model for memory corruption attacks. Using this model we show what policies can stop which attacks. The model identifies weaknesses of currently deployed techniques, as well as other\u00a0\u2026", "num_citations": "698\n", "authors": ["343"]}
{"title": "Control-flow bending: On the effectiveness of control-flow integrity\n", "abstract": " Control-Flow Integrity (CFI) is a defense which prevents control-flow hijacking attacks. While recent research has shown that coarse-grained CFI does not stop attacks, fine-grained CFI is believed to be secure.", "num_citations": "418\n", "authors": ["343"]}
{"title": "Control-flow integrity: Precision, security, and performance\n", "abstract": " Memory corruption errors in C/C++ programs remain the most common source of security vulnerabilities in today\u2019s systems. Control-flow hijacking attacks exploit memory corruption vulnerabilities to divert program execution away from the intended control flow. Researchers have spent more than a decade studying and refining defenses based on Control-Flow Integrity (CFI); this technique is now integrated into several production compilers. However, so far, no study has systematically compared the various proposed CFI mechanisms nor is there any protocol on how to compare such mechanisms. We compare a broad range of CFI mechanisms using a unified nomenclature based on (i) a qualitative discussion of the conceptual security guarantees, (ii) a quantitative security evaluation, and (iii) an empirical evaluation of their performance in the same test environment. For each mechanism, we evaluate (i) protected\u00a0\u2026", "num_citations": "225\n", "authors": ["343"]}
{"title": "T-Fuzz: fuzzing by program transformation\n", "abstract": " Fuzzing is a simple yet effective approach to discover software bugs utilizing randomly generated inputs. However, it is limited by coverage and cannot find bugs hidden in deep execution paths of the program because the randomly generated inputs fail complex sanity checks, e.g., checks on magic values, checksums, or hashes. To improve coverage, existing approaches rely on imprecise heuristics or complex input mutation techniques (e.g., symbolic execution or taint analysis) to bypass sanity checks. Our novel method tackles coverage from a different angle: by removing sanity checks in the target program. T-Fuzz leverages a coverage-guided fuzzer to generate inputs. Whenever the fuzzer can no longer trigger new code paths, a light-weight, dynamic tracing based technique detects the input checks that the fuzzer-generated inputs fail. These checks are then removed from the target program. Fuzzing then\u00a0\u2026", "num_citations": "192\n", "authors": ["343"]}
{"title": "Fine-Grained Control-Flow Integrity through Binary Hardening\n", "abstract": " Applications written in low-level languages without type or memory safety are prone to memory corruption. Attackers gain code execution capabilities through memory corruption despite all currently deployed defenses. Control-Flow Integrity (CFI) is a promising security property that restricts indirect control-flow transfers to a static set of well-known locations.                 We present Lockdown, a modular, fine-grained CFI policy that protects binary-only applications and libraries without requiring source-code. Lockdown adaptively discovers the control-flow graph of a running process based on the executed code. The sandbox component of Lockdown restricts interactions between different shared objects to imported and exported functions by enforcing fine-grained CFI checks using information from a trusted dynamic loader. A shadow stack enforces precise integrity for function returns. Our prototype\u00a0\u2026", "num_citations": "132\n", "authors": ["343"]}
{"title": "HexPADS: a platform to detect \u201cstealth\u201d attacks\n", "abstract": " Current systems are under constant attack from many different sources. Both local and remote attackers try to escalate their privileges to exfiltrate data or to gain arbitrary code execution. While inline defense mechanisms like DEP, ASLR, or stack canaries are important, they have a local, program centric view and miss some attacks. Intrusion Detection Systems (IDS) use runtime monitors to measure current state and behavior of the system to detect an attack orthogonal to active defenses.               Attacks change the execution behavior of a system. Our attack detection system HexPADS detects attacks through divergences from normal behavior using attack signatures. HexPADS collects information from the operating system on runtime performance metrics with measurements from hardware performance counters for individual processes. Cache behavior is a strong indicator of ongoing attacks like\u00a0\u2026", "num_citations": "113\n", "authors": ["343"]}
{"title": "SMoTherSpectre: exploiting speculative execution through port contention\n", "abstract": " Spectre, Meltdown, and related attacks have demonstrated that kernels, hypervisors, trusted execution environments, and browsers are prone to information disclosure through micro-architectural weaknesses. However, it remains unclear as to what extent other applications, in particular those that do not load attacker-provided code, may be impacted. It also remains unclear as to what extent these attacks are reliant on cache-based side channels. We introduce SMoTherSpectre, a speculative code-reuse attack that leverages port-contention in simultaneously multi-threaded processors (SMoTher) as a side channel to leak information from a victim process. SMoTher is a fine-grained side channel that detects contention based on a single victim instruction. To discover real-world gadgets, we describe a methodology and build a tool that locates SMoTher-gadgets in popular libraries. In an evaluation on glibc, we found\u00a0\u2026", "num_citations": "97\n", "authors": ["343"]}
{"title": "Fine-grained control-flow integrity for kernel software\n", "abstract": " Modern systems assume that privileged software always behaves as expected, however, such assumptions may not hold given the prevalence of kernel vulnerabilities. One idea is to employ defenses to restrict how adversaries may exploit such vulnerabilities, such as Control-Flow Integrity (CFI), which restricts execution to a Control-Flow Graph (CFG). However, proposed applications of CFI enforcement to kernel software are too coarse-grained to restrict the adversary effectively and either fail to enforce CFI comprehensively or are very expensive. We present a mostly-automated approach for retrofitting kernel software that leverages features of such software to enable comprehensive, efficient, fine-grained CFI enforcement. We achieve this goal by leveraging two insights. We first leverage the conservative function pointer usage patterns found in the kernel source code to develop a method to compute fine-grained\u00a0\u2026", "num_citations": "94\n", "authors": ["343"]}
{"title": "VTrust: Regaining Trust on Virtual Calls.\n", "abstract": " Virtual function calls are one of the most popular control-flow hijack attack targets. Compilers use a virtual function pointer table, called a VTable, to dynamically dispatch virtual function calls. These VTables are read-only, but pointers to them are not. VTable pointers reside in objects that are writable, allowing attackers to overwrite them. As a result, attackers can divert the control-flow of virtual function calls and launch VTable hijacking attacks. Researchers have proposed several solutions to protect virtual calls. However, they either incur high performance overhead or fail to defeat some VTable hijacking attacks.In this paper, we propose a lightweight defense solution, VTrust, to protect all virtual function calls from VTable hijacking attacks. It consists of two independent layers of defenses: virtual function type enforcement and VTable pointer sanitization. Combined with modern compilers\u2019 default configuration, ie, placing VTables in read-only memory, VTrust can defeat all VTable hijacking attacks and supports modularity, allowing us to harden applications module by module. We have implemented a prototype on the LLVM compiler framework. Our experiments show that this solution only introduces a low performance overhead, and it defeats real world VTable hijacking attacks.", "num_citations": "85\n", "authors": ["343"]}
{"title": "SoK: Shining light on shadow stacks\n", "abstract": " Control-Flow Hijacking attacks are the dominant attack vector against C/C++ programs. Control-Flow Integrity (CFI) solutions mitigate these attacks on the forward edge, i.e., indirect calls through function pointers and virtual calls. Protecting the backward edge is left to stack canaries, which are easily bypassed through information leaks. Shadow Stacks are a fully precise mechanism for protecting backwards edges, and should be deployed with CFI mitigations. We present a comprehensive analysis of all possible shadow stack mechanisms along three axes: performance, compatibility, and security. For performance comparisons we use SPEC CPU2006, while security and compatibility are qualitatively analyzed. Based on our study, we renew calls for a shadow stack design that leverages a dedicated register, resulting in low performance overhead, and minimal memory overhead, but sacrifices compatibility. We\u00a0\u2026", "num_citations": "83\n", "authors": ["343"]}
{"title": "The Correctness-Security Gap in Compiler Optimization\n", "abstract": " There is a significant body of work devoted to testing, verifying, and certifying the correctness of optimizing compilers. The focus of such work is to determine if source code and optimized code have the same functional semantics. In this paper, we introduce the correctness-security gap, which arises when a compiler optimization preserves the functionality of but violates a security guarantee made by source code. We show with concrete code examples that several standard optimizations, which have been formally proved correct, in-habit this correctness-security gap. We analyze this gap and conclude that it arises due to techniques that model the state of the program but not the state of the underlying machine. We propose a broad research programme whose goal is to identify, understand, and mitigate the impact of security errors introduced by compiler optimizations. Our proposal includes research in testing\u00a0\u2026", "num_citations": "82\n", "authors": ["343"]}
{"title": "Fine-grained user-space security through virtualization\n", "abstract": " This paper presents an approach to the safe execution of applications based on software-based fault isolation and policy-based system call authorization. A running application is encapsulated in an additional layer of protection using dynamic binary translation in user-space. This virtualization layer dynamically recompiles the machine code and adds multiple dynamic security guards that verify the running code to protect and contain the application. The binary translation system redirects all system calls to a policy-based system call authorization framework. This interposition framework validates every system call based on the given arguments and the location of the system call. Depending on the user-loadable policy and an extensible handler mechanism the framework decides whether a system call is allowed, rejected, or redirect to a specific user-space handler in the virtualization layer. This paper offers an in\u00a0\u2026", "num_citations": "82\n", "authors": ["343"]}
{"title": "Protecting bare-metal embedded systems with privilege overlays\n", "abstract": " Embedded systems are ubiquitous in every aspect of modern life. As the Internet of Thing expands, our dependence on these systems increases. Many of these interconnected systems are and will be low cost bare-metal systems, executing without an operating system. Bare-metal systems rarely employ any security protection mechanisms and their development assumptions (unrestricted access to all memory and instructions), and constraints(runtime, energy, and memory) makes applying protections challenging. To address these challenges we present EPOXY, an LLVM-based embedded compiler. We apply a novel technique, called privilege overlaying, wherein operations requiring privileged execution are identified and only these operations execute in privileged mode. This provides the foundation on which code-integrity, adapted control-flow hijacking defenses, and protections for sensitive IO are applied. We\u00a0\u2026", "num_citations": "77\n", "authors": ["343"]}
{"title": "Block oriented programming: Automating data-only attacks\n", "abstract": " With the widespread deployment of Control-Flow Integrity (CFI), control-flow hijacking attacks, and consequently code reuse attacks, are significantly more difficult. CFI limits control flow to well-known locations, severely restricting arbitrary code execution. Assessing the remaining attack surface of an application under advanced control-flow hijack defenses such as CFI and shadow stacks remains an open problem. We introduce BOPC, a mechanism to automatically assess whether an attacker can execute arbitrary code on a binary hardened with CFI/shadow stack defenses. BOPC computes exploits for a target program from payload specifications written in a Turing-complete, high-level language called SPL that abstracts away architecture and program-specific details. SPL payloads are compiled into a program trace that executes the desired behavior on top of the target binary. The input for BOPC is an SPL\u00a0\u2026", "num_citations": "74\n", "authors": ["343"]}
{"title": "{CAIN}: Silently Breaking {ASLR} in the Cloud\n", "abstract": " Modern systems rely on Address-Space Layout Randomization (ASLR) and Data Execution Prevention (DEP) to protect software against memory corruption vulnerabilities. The security of ASLR depends on randomizing regions in memory which can be broken by leaking addresses. While information leaks are common for client applications, server software has been hardened to reduce such information leaks.", "num_citations": "62\n", "authors": ["343"]}
{"title": "HI-CFG: Construction by binary analysis and application to attack polymorphism\n", "abstract": " Security analysis often requires understanding both the control and data-flow structure of a binary. We introduce a new program representation, a hybrid information- and control-flow graph (HI-CFG), and give algorithms to infer it from an instruction-level trace. As an application, we consider the task of generalizing an attack against a program whose inputs undergo complex transformations before reaching a vulnerability. We apply the HI-CFG to find the parts of the program that implement each transformation, and then generate new attack inputs under a user-specified combination of transformations. Structural knowledge allows our approach to scale to applications that are infeasible with monolithic symbolic execution. Such attack polymorphism shows the insufficiency of any filter that does not support all the same transformations as the vulnerable application. In case studies, we show this attack capability\u00a0\u2026", "num_citations": "55\n", "authors": ["343"]}
{"title": "rev. ng: a unified binary analysis framework to recover CFGs and function boundaries\n", "abstract": " Static binary analysis is a key tool to assess the security of third-party binaries and legacy programs. Most forms of binary analysis rely on the availability of two key pieces of information: the program's control-flow graph and function boundaries. However, current tools struggle to provide accurate and precise results, in particular when dealing with hand-written assembly functions and non-trivial control-flow transfer instructions, such as tail calls. In addition, most of the existing solutions are ad-hoc, rely on hand-coded heuristics, and are tied to a specific architecture.", "num_citations": "54\n", "authors": ["343"]}
{"title": "Online optimizations driven by hardware performance monitoring\n", "abstract": " Hardware performance monitors provide detailed direct feedback about application behavior and are an additional source of infor-mation that a compiler may use for optimization. A JIT compiler is in a good position to make use of such information because it is running on the same platform as the user applications. As hardware platforms become more and more complex, it becomes more and more difficult to model their behavior. Profile information that captures general program properties (like execution frequency of methods or basic blocks) may be useful, but does not capture sufficient information about the execution platform. Machine-level performance data obtained from a hardware performance monitor can not only direct the compiler to those parts of the program that deserve its attention but also determine if an optimization step actually improved the performance of the application. This paper presents an\u00a0\u2026", "num_citations": "53\n", "authors": ["343"]}
{"title": "Retrowrite: Statically instrumenting cots binaries for fuzzing and sanitization\n", "abstract": " Analyzing the security of closed source binaries is currently impractical for end-users, or even developers who rely on third-party libraries. Such analysis relies on automatic vulnerability discovery techniques, most notably fuzzing with sanitizers enabled. The current state of the art for applying fuzzing or sanitization to binaries is dynamic binary translation, which has prohibitive performance overhead. The alternate technique, static binary rewriting, cannot fully recover symbolization information and hence has difficulty modifying binaries to track code coverage for fuzzing or to add security checks for sanitizers.The ideal solution for binary security analysis would be a static rewriter that can intelligently add the required instrumentation as if it were inserted at compile time. Such instrumentation requires an analysis to statically disambiguate between references and scalars, a problem known to be undecidable in the\u00a0\u2026", "num_citations": "51\n", "authors": ["343"]}
{"title": "Datashield: Configurable data confidentiality and integrity\n", "abstract": " Applications written in C/C++ are prone to memory corruption, which allows attackers to extract secrets or gain control of the system. With the rise of strong control-flow hijacking defenses, non-control data attacks have become the dominant threat. As vulnerabilities like HeartBleed have shown, such attacks are equally devastating. Data Confidentiality and Integrity (DCI) is a low-overhead non-control-data protection mechanism for systems software. DCI augments the C/C++ programming languages with an-notations, allowing the programmer to protect selected data types. The DCI compiler and runtime system prevent illegal reads (confidentiality) and writes (integrity) to instances of these types. The programmer selects types that contain security critical information such as passwords, cryptographic keys, or identification tokens. Protecting only this critical data greatly reduces performance overhead relative to\u00a0\u2026", "num_citations": "51\n", "authors": ["343"]}
{"title": "Too much PIE is bad for performance\n", "abstract": " Compiling an application as a Position Independent Executable (PIE) enables Address Space Layout Randomization to protect the application from security attacks by mapping the executable at a random memory location. Nevertheless most applications on current x86 Linux distributions are mapped to a static address for performance reasons. This paper evaluates the overhead and side-effects of PIE using the SPEC CPU2006 benchmarks on an Intel Core i7 CPU with a recent Ubuntu distribution. Our analysis shows that the overhead for PIE on 32bit x86 is up to 26% for some benchmarks with an (arithmetic) average of 10% and a geometric mean of 9.4%. We identify the increased register pressure as the source for most of the overhead on x86.", "num_citations": "50\n", "authors": ["343"]}
{"title": "Cfixx: Object type integrity for c++ virtual dispatch\n", "abstract": " C++ relies on object type information for dynamic dispatch and casting. The association of type information to an object is implemented via the virtual table pointer, which is stored in the object itself. C++ has neither memory nor type safety, adversaries may therefore overwrite an object\u2019s type. If the corrupted type is used for dynamic dispatch, the attacker has hijacked the application\u2019s control flow. This vulnerability is widespread and commonly exploited. Firefox, Chrome, and other major C++ applications are network facing, commonly attacked, and make significant use of dynamic dispatch. Control-Flow Integrity (CFI) is the state of the art policy for efficient mitigation of control flow hijacking attacks. CFI mechanisms determine statically (ie, at compile time) the set of functions that are valid at a given call site, based on C++ semantics. We propose an orthogonal policy, Object Type Integrity (OTI), that dynamically tracks object types. Consequently, instead of allowing a set of targets for each dynamic dispatch on an object, only the single, correct target for the object\u2019s type is allowed.To show the efficacy of OTI, we present CFIXX, which enforces OTI. CFIXX enforces OTI by dynamically tracking the type of each object and enforcing its integrity against arbitrary writes. CFIXX has minimal overhead on CPU bound applications such as SPEC CPU2006-4.98%. On key applications like Chromium, CFIXX has negligible overhead on JavaScript benchmarks: 2.03% on Octane, 1.99% on Kraken, and 2.80% on JetStream. We show that CFIXX can be deployed in conjunction with CFI, providing a significant security improvement.", "num_citations": "48\n", "authors": ["343"]}
{"title": "{ACES}: Automatic compartments for embedded systems\n", "abstract": " Securing the rapidly expanding Internet of Things (IoT) is critical. Many of these \u201cthings\u201d are vulnerable bare-metal embedded systems where the application executes directly on hardware without an operating system. Unfortunately, the integrity of current systems may be compromised by a single vulnerability, as recently shown by Google\u2019s P0 team against Broadcom\u2019s WiFi SoC.", "num_citations": "47\n", "authors": ["343"]}
{"title": "Safe loading-a foundation for secure execution of untrusted programs\n", "abstract": " The standard loader (ld.so) is a common target of attacks. The loader is a trusted component of the application, and faults in the loader are problematic, e.g., they may lead to local privilege escalation for SUID binaries. Software-based fault isolation (SFI) provides a framework to execute arbitrary code while protecting the host system. A problem of current approaches to SFI is that fault isolation is decoupled from the dynamic loader, which is treated as a black box. The sandbox has no information about the (expected) execution behavior of the application and the connections between different shared objects. As a consequence, SFI is limited in its ability to identify devious application behavior. This paper presents a new approach to run untrusted code in a user-space sandbox. The approach replaces the standard loader with a security-aware trusted loader. The secure loader and the sandbox together cooperate to\u00a0\u2026", "num_citations": "45\n", "authors": ["343"]}
{"title": "HALucinator: Firmware re-hosting through abstraction layer emulation\n", "abstract": " Given the increasing ubiquity of online embedded devices, analyzing their firmware is important to security, privacy, and safety. The tight coupling between hardware and firmware and the diversity found in embedded systems makes it hard to perform dynamic analysis on firmware. However, firmware developers regularly develop code using abstractions, such as Hardware Abstraction Layers (HALs), to simplify their job. We leverage such abstractions as the basis for the re-hosting and analysis of firmware. By providing high-level replacements for HAL functions (a process termed High-Level Emulation\u2013HLE), we decouple the hardware from the firmware. This approach works by first locating the library functions in a firmware sample, through binary analysis, and then providing generic implementations of these functions in a full-system emulator.", "num_citations": "44\n", "authors": ["343"]}
{"title": "Hextype: Efficient detection of type confusion errors for c++\n", "abstract": " Type confusion, often combined with use-after-free, is the main attack vector to compromise modern C++ software like browsers or virtual machines. Typecasting is a core principle that enables modularity in C++. For performance, most typecasts are only checked statically, ie, the check only tests if a cast is allowed for the given type hierarchy, ignoring the actual runtime type of the object. Using an object of an incompatible base type instead of a derived type results in type confusion. Attackers abuse such type confusion issues to attack popular software products including Adobe Flash, PHP, Google Chrome, or Firefox. We propose to make all type checks explicit, replacing static checks with full runtime type checks. To minimize the performance impact of our mechanism HexType, we develop both low-overhead data structures and compiler optimizations. To maximize detection coverage, we handle specific object\u00a0\u2026", "num_citations": "39\n", "authors": ["343"]}
{"title": "Generating low-overhead dynamic binary translators\n", "abstract": " Dynamic (on the fly) binary translation is an important part of many software systems. In this paper we discuss how to combine efficient translation with the generation of efficient code, while providing a high-level table-driven user interface that simplifies the generation of the binary translator (BT).", "num_citations": "39\n", "authors": ["343"]}
{"title": "Enforcing least privilege memory views for multithreaded applications\n", "abstract": " Failing to properly isolate components in the same address space has resulted in a substantial amount of vulnerabilities. Enforcing the least privilege principle for memory accesses can selectively isolate software components to restrict attack surface and prevent unintended cross-component memory corruption. However, the boundaries and interactions between software components are hard to reason about and existing approaches have failed to stop attackers from exploiting vulnerabilities caused by poor isolation. We present the secure memory views (SMV) model: a practical and efficient model for secure and selective memory isolation in monolithic multithreaded applications. SMV is a third generation privilege separation technique that offers explicit access control of memory and allows concurrent threads within the same process to partially share or fully isolate their memory space in a controlled and parallel\u00a0\u2026", "num_citations": "38\n", "authors": ["343"]}
{"title": "Eternal war in memory\n", "abstract": " Software written in low-level languages like C or C++ is prone to memory corruption bugs that allow attackers to access machines, extract information, and install malware. Real-world exploits show that all widely deployed protections can be defeated.", "num_citations": "34\n", "authors": ["343"]}
{"title": "String oriented programming: when ASLR is not enough\n", "abstract": " Control-data attacks are a well known attack vector; these attacks either inject new code into running applications or reuse existing code in an unintended way to execute their malicious payload.", "num_citations": "33\n", "authors": ["343"]}
{"title": "Forgery-resistant touch-based authentication on mobile devices\n", "abstract": " Mobile devices store a diverse set of private user data and have gradually become a hub to control users' other personal Internet-of-Things devices. Access control on mobile devices is therefore highly important. The widely accepted solution is to protect access by asking for a password. However, password authentication is tedious, eg, a user needs to input a password every time she wants to use the device. Moreover, existing biometrics such as face, fingerprint, and touch behaviors are vulnerable to forgery attacks. We propose a new touch-based biometric authentication system that is passive and secure against forgery attacks. In our touch-based authentication, a user's touch behaviors are a function of some random\" secret\". The user can subconsciously know the secret while touching the device's screen. However, an attacker cannot know the secret at the time of attack, which makes it challenging to perform\u00a0\u2026", "num_citations": "32\n", "authors": ["343"]}
{"title": "Fuzzgen: Automatic fuzzer generation\n", "abstract": " Fuzzing is a testing technique to discover unknown vulnerabilities in software. When applying fuzzing to libraries, the core idea of supplying random input remains unchanged, yet it is non-trivial to achieve good code coverage. Libraries cannot run as standalone programs, but instead are invoked through another application. Triggering code deep in a library remains challenging as specific sequences of API calls are required to build up the necessary state. Libraries are diverse and have unique interfaces that require unique fuzzers, so far written by a human analyst.", "num_citations": "31\n", "authors": ["343"]}
{"title": "Protecting applications against TOCTTOU races by user-space caching of file metadata\n", "abstract": " Time Of Check To Time Of Use (TOCTTOU) race conditions for file accesses in user-space applications are a common problem in Unix-like systems. The mapping between filename and inode and device is volatile and can provide the necessary preconditions for an exploit. Applications use filenames as the primary attribute to identify files but the mapping between filenames and inode and device can be changed by an attacker.", "num_citations": "31\n", "authors": ["343"]}
{"title": "Firmfuzz: Automated iot firmware introspection and analysis\n", "abstract": " While the number of IoT devices grows at an exhilarating pace their security remains stagnant. Imposing secure coding standards across all vendors is infeasible. Testing individual devices allows an analyst to evaluate their security post deployment. Any discovered vulnerabilities can then be disclosed to the vendors in order to assist them in securing their products. The search for vulnerabilities should ideally be automated for efficiency and furthermore be device-independent for scalability.", "num_citations": "30\n", "authors": ["343"]}
{"title": "Lightweight memory tracing\n", "abstract": " Memory tracing (executing additional code for every memory access of a program) is a powerful technique with many applications, eg, debugging, taint checking, or tracking dataflow. Current approaches are limited: software-only memory tracing incurs high performance overhead (eg, for Libdft up to 10x) because every single memory access of the application is checked by additional code that is not part of the original application and hardware is limited to a small set of watched locations.", "num_citations": "28\n", "authors": ["343"]}
{"title": "Memory safety for embedded devices with nescheck\n", "abstract": " Applications for TinyOS, a popular operating system for embedded systems and wireless sensor networks, are written in nesC, a C dialect prone to the same type and memory safety vulnerabilities as C. While availability and integrity are critical requirements, the distributed and concurrent nature of such applications, combined with the intrinsic unsafety of the language, makes those security goals hard to achieve. Traditional memory safety techniques cannot be applied, due to the strict platform constraints and hardware differences of embedded systems.", "num_citations": "27\n", "authors": ["343"]}
{"title": "{JIGSAW}: Protecting Resource Access by Inferring Programmer Expectations\n", "abstract": " Processes retrieve a variety of resources, such as files, from the operating system to function. However, securely accessing resources has proven to be a challenging task, accounting for 10-15% of vulnerabilities reported each year. Current defenses address only a subset of these vulnerabilities in ad-hoc and incomplete ways. In this paper, we provide a comprehensive defense against vulnerabilities during resource access. First, we identify a fundamental reason that resource access vulnerabilities exist\u2013a mismatch between programmer expectations and the actual environment the program runs in. To address such mismatches, we propose JIGSAW, a system that can automatically derive programmer expectations and enforce it on the deployment. JIGSAW constructs programmer expectations as a name flow graph, which represents the data flows from the inputs used to construct file pathnames to the retrieval of system resources using those pathnames. We find that whether a program makes any attempt to filter such flows implies expectations about the threats the programmer expects during resource retrieval, the enabling JIGSAW to enforce those expectations. We evaluated JIGSAW on widely-used programs and found that programmers have many implicit expectations. These mismatches led us to discover two previously-unknown vulnerabilities and a default misconfiguration in the Apache webserver. JIGSAW enforces program expectations for approximately 5% overhead for Apache webservers, thus eliminating vulnerabilities due to resource access efficiently and in a principled manner.", "num_citations": "27\n", "authors": ["343"]}
{"title": "Transformation-aware Exploit Generation using a HI-CFG\n", "abstract": " A common task for security analysts is to determine whether potentially unsafe code constructs as found by static analysis or code review can be triggered by an attacker-controlled input to the program under analysis. We refer to this problem as proof-of-concept POC exploit generation. Exploit generation is challenging to automate because it requires precise reasoning across a large code base in practice it is usually a manual task. An intuitive approach to exploit generation is to break down a programs relevant computation into a sequence of transformations that map an input value into the value that can trigger an exploit. We automate this intuition by describing an approach to discover the buffer structure the chain of buffers used between transformations of a program, and use this structure to construct an exploit input by inverting one transformation at a time. We propose a new program representation, a hybrid information-and control-flow graph HI-CFG, and give algorithms to build a HI-CFG from instruction traces. We then describe how to guide program exploration using symbolic execution to efficiently search for transformation pre-images. We implement our techniques in a tool that operates on applications in x86 binary form. In two case studies we discuss how our tool creates POC exploits for 1 a vulnerability in a PDF rendering library that is reachable through multiple different transformation stages and 2 a vulnerability in the processing stage of a specific document format in AbiWord.Descriptors:", "num_citations": "26\n", "authors": ["343"]}
{"title": "malWASH: Washing malware to evade dynamic analysis\n", "abstract": " Hiding malware processes from fingerprinting is challenging. Current techniques like metamorphic algorithms and diversity generate different instances of a program, protecting it against static detection. Unfortunately, all existing techniques are prone to detection through behavioral analysis\u2013a runtime analysis that records behavior (eg, through system call invocations), and can detect executing diversified programs like malware.", "num_citations": "25\n", "authors": ["343"]}
{"title": "What you submit is who you are: A multimodal approach for deanonymizing scientific publications\n", "abstract": " The peer-review system of most academic conferences relies on the anonymity of both the authors and reviewers of submissions. In particular, with respect to the authors, the anonymity requirement is heavily disputed and pros and cons are discussed exclusively on a qualitative level. In this paper, we contribute a quantitative argument to this discussion by showing that it is possible for a machine to reveal the identity of authors of scientific publications with high accuracy. We attack the anonymity of authors using statistical analysis of multiple heterogeneous aspects of a paper, such as its citations, its writing style, and its content. We apply several multilabel, multiclass machine learning methods to model the patterns exhibited in each feature category for individual authors and combine them to a single ensemble classifier to deanonymize authors with high accuracy. To the best of our knowledge, this is the first\u00a0\u2026", "num_citations": "25\n", "authors": ["343"]}
{"title": "Cup: Comprehensive user-space protection for c/c++\n", "abstract": " Memory corruption vulnerabilities in C/C++ applications enable attackers to execute code, change data, and leak information. Current memory sanitizers do not provide comprehensive coverage of a program\u00bb s data. In particular, existing tools focus primarily on heap allocations with limited support for stack allocations and globals. Orthogonally, existing tools focus on the main executable with limited support for system libraries. Existing tools also suffer from both false positives and false negatives. We present Comprehensive User-Space Protection for C/C++,\\sysname, an LLVM sanitizer that provides complete spatial and probabilistic temporal memory safety for C/C++ programs on 64-bit architectures (with a prototype implementation for x86\\_64).\\sysname uses a hybrid metadata scheme that supports all program data including globals, heap, or stack and maintains Application Binary Interface (ABI) compatibility\u00a0\u2026", "num_citations": "23\n", "authors": ["343"]}
{"title": "Poster: Getting the point (er): On the feasibility of attacks on code-pointer integrity\n", "abstract": " Control-flow hijack attacks remain a major security problem, despite many years of research aimed at mitigating them. Code-Pointer Integrity (CPI)[2] is the first protection mechanism that systematically prevents all such attacks while keeping performance overhead low. In the upcoming S&P\u201915 paper, Evans et al.[1] claim that CPI can be bypassed on x86-64 and ARM architectures. This poster is a clarifying response to the claims in [1] that CPI as a whole has a security weakness. The CPI property by itself is secure as shown by a formal correctness proof [2]. Bugs or weaknesses in specific CPI implementations can lead to security weaknesses. We discuss different implementation alternatives, analyze their security guarantees and performance implications, and demonstrate that the attack presented in [1] is only effective against the simplest proof-ofconcept implementation of CPI. The presented attack cannot subvert the other implementation alternatives, eg, the ones using hardware-enforced segmentation or software fault isolation.I. CODE-POINTER INTEGRITY Code-Pointer Integrity (CPI)[2] is a protection mechanism that prevents all control-flow hijack attacks that are caused by memory corruption errors with low performance overhead. CPI instruments C/C++ programs at compile time, enforcing precise memory safety for all direct and indirect pointers to code in a program, which ensures the above security guarantee. CPI comes with a proof of correctness outlined in [2]. Code-Pointer Separation (CPS) is a simplified version of CPI that provides practical protection against most control-flow hijack attacks by ensuring the integrity of direct pointers\u00a0\u2026", "num_citations": "23\n", "authors": ["343"]}
{"title": "An Evil Copy: How the Loader Betrays You.\n", "abstract": " Dynamic loading is a core feature used on current systems to (i) enable modularity and reuse,(ii) reduce memory footprint by sharing code pages of libraries and executables among processes, and (iii) simplify update procedures by eliminating the need to recompile executables when a library is updated. The Executable and Linkable Format (ELF) is a generic specification that describes how executable programs are stitched together from object files produced from source code to libraries and executables. Programming languages allow fine-grained control over variables, including access and memory protections, so programmers may write defense mechanisms assuming that the permissions specified at the source and/or compiler level will hold at runtime.Unfortunately, information about memory protection is lost during compilation. We identify one case that has significant security implications: when instantiating a process, constant external variables that are referenced in executables are forcefully relocated to a writable memory segment without warning. The loader trades security for compatibility due to the lack of memory protection information on the relocated external variables. We call this new attack vector COREV for Copy Relocation Violation. An adversary may use a memory corruption vulnerability to modify such \u201cread-only\u201d constant variables like vtables, function pointers, format strings, and file names to bypass defenses (like FORTIFY SOURCE or CFI) and to escalate privileges.", "num_citations": "20\n", "authors": ["343"]}
{"title": "Requirements for fast binary translation\n", "abstract": " Fast binary translation is a key component for many modern software techniques. This paper reflects on the implementation of fastBT, a generator for low-overhead, table-based dynamic (just-in-time) binary translators. We discuss the most challenging sources of overhead, propose optimizations to further reduce these penalties, and present a detailed performance analysis with different approaches to translate indirect control transfers. To allow comparison with other systems the paper includes an empirical evaluation of fastBT relative to three other binary translation systems (DynamoRIO, HDTrans, and PIN).The fastBT generator is architecture-neutral but this paper's analysis and performance data focus on IA-32 Linux. fastBT performs well in practice: we report an overhead of 0% to 10% for the majority of benchmarks. fastBT uses a trace cache and trampolines to obtain efficiency in translation and execution of the\u00a0\u2026", "num_citations": "20\n", "authors": ["343"]}
{"title": "RAI: Securing Embedded Systems with Return Address Integrity\n", "abstract": " Embedded systems are deployed in security critical environments and have become a prominent target for remote attacks. Microcontroller-based systems (MCUS) are particularly vulnerable due to a combination of limited resources and low level programming which leads to bugs. Since MCUS are often a part of larger systems, vulnerabilities may jeopardize not just the security of the device itself but that of other systems as well. For example, exploiting a WiFi System on Chip (SoC) allows an attacker to hijack the smart phone\u2019s application processor.Control-flow hijacking targeting the backward edge (eg, Return-Oriented Programming\u2013ROP) remains a threat for MCUS. Current defenses are either susceptible to ROP-style attacks or require special hardware such as a Trusted Execution Environment (TEE) that is not commonly available on MCUS.", "num_citations": "19\n", "authors": ["343"]}
{"title": "Venerable variadic vulnerabilities vanquished\n", "abstract": " Programming languages such as C and C++ support variadic functions, ie, functions that accept a variable number of arguments (eg, printf). While variadic functions are flexible, they are inherently not type-safe. In fact, the semantics and parameters of variadic functions are defined implicitly by their implementation. It is left to the programmer to ensure that the caller and callee follow this implicit specification, without the help of a static type checker. An adversary can take advantage of a mismatch between the argument types used by the caller of a variadic function and the types expected by the callee to violate the language semantics and to tamper with memory. Format string attacks are the most popular example of such a mismatch.", "num_citations": "19\n", "authors": ["343"]}
{"title": "Hot-patching a web server: A case study of asap code repair\n", "abstract": " Software updates are the current standard to respond to software bugs. The software developer provides an update fix that is then applied by the administrator: the binary is modified and the service is restarted. Restarting a service inevitably leads to downtime and service unavailability; in the case of a multithreaded installation of Apache, restart takes several seconds and depending on the load of the web server, several hundred or even thousand client requests will be rejected with an error. Given the cost of restarts, system administrators attempt to minimize the frequency of service restarts or postpone a restart until the next maintenance window. However, to ensure the integrity of the system, code repair must happen as soon as possible (ASAP). We describe here the effectiveness of an on-the-fly update system that provides ASAP repair by integrating dynamic patches with a sandbox based on dynamic binary\u00a0\u2026", "num_citations": "18\n", "authors": ["343"]}
{"title": "Impact of GC design on power and performance for Android\n", "abstract": " Small mobile devices have evolved to versatile computing systems. Android devices run a complete software stack, including a full Linux kernel, user land with several software daemons and a virtual machine to run applications. On these mobile systems energy is a scarce resource and needs to be handled carefully. Current systems rely on governors that adjust the frequency of individual cores depending on the system load.", "num_citations": "17\n", "authors": ["343"]}
{"title": "DynSec: On-the-\ufb02y Code Rewriting and Repair\n", "abstract": " Security patches protect an application from discovered vulnerabilities and should be applied as fast as possible. On the other hand, patching the application reduces the availability of the service due to the necessary restart. System administrators need to balance system availability with a potential compromise of system integrity.", "num_citations": "16\n", "authors": ["343"]}
{"title": "USBFuzz: A Framework for Fuzzing {USB} Drivers by Device Emulation\n", "abstract": " The Universal Serial Bus (USB) connects external devices to a host. This interface exposes the OS kernels and device drivers to attacks by malicious devices. Unfortunately, kernels and drivers were developed under a security model that implicitly trusts connected devices. Drivers expect faulty hardware but not malicious attacks. Similarly, security testing drivers is challenging as input must cross the hardware/software barrier. Fuzzing, the most widely used bug finding technique, relies on providing random data to programs. However, fuzzing device drivers is challenging due to the difficulty in crossing the hardware/software barrier and providing random device data to the driver under test.", "num_citations": "15\n", "authors": ["343"]}
{"title": "{BLESA}: Spoofing Attacks against Reconnections in Bluetooth Low Energy\n", "abstract": " The Bluetooth Low Energy (BLE) protocol ubiquitously enables energy-efficient wireless communication among resource-constrained devices. To ease its adoption, BLE requires limited or no user interaction to establish a connection between two devices. Unfortunately, this simplicity is the root cause of several security issues.", "num_citations": "14\n", "authors": ["343"]}
{"title": "Performance evaluation of adaptivity in software transactional memory\n", "abstract": " Transactional memory (TM) is an attractive platform for parallel programs, and several software transactional memory (STM) designs have been presented. We explore and analyze several optimization opportunities to adapt STM parameters to a running program. This paper uses adaptSTM, a flexible STM library with a non-adaptive baseline common to current fast STM libraries to evaluate different performance options. The baseline is extended by an online evaluation system that enables the measurement of key runtime parameters like read- and write-locations, or commit- and abort-rate. The performance data is used by a thread-local adaptation system to tune the STM configuration. The system adapts different important parameters like write-set hash-size, hash-function, and write strategy based on runtime statistics on a per-thread basis. We discuss different self-adapting parameters, especially their\u00a0\u2026", "num_citations": "12\n", "authors": ["343"]}
{"title": "Magma: A ground-truth fuzzing benchmark\n", "abstract": " High scalability and low running costs have made fuzz testing the de facto standard for discovering software bugs. Fuzzing techniques are constantly being improved in a race to build the ultimate bug-finding tool. However, while fuzzing excels at finding bugs in the wild, evaluating and comparing fuzzer performance is challenging due to the lack of metrics and benchmarks. For example, crash count---perhaps the most commonly-used performance metric---is inaccurate due to imperfections in deduplication techniques. Additionally, the lack of a unified set of targets results in ad hoc evaluations that hinder fair comparison. We tackle these problems by developing Magma, a ground-truth fuzzing benchmark that enables uniform fuzzer evaluation and comparison. By introducing real bugs into real software, Magma allows for the realistic evaluation of fuzzers against a broad set of targets. By instrumenting these bugs\u00a0\u2026", "num_citations": "11\n", "authors": ["343"]}
{"title": "Specrop: Speculative exploitation of {ROP} chains\n", "abstract": " Speculative execution attacks, such as Spectre, reuse code from the victim\u2019s binary to access and leak secret information during speculative execution. Every variant of the attack requires very particular code sequences, necessitating elaborate gadget-search campaigns. Often, victim programs contain few, or even zero, usable gadgets. Consequently, speculative attacks are sometimes demonstrated by injecting usable code sequences into the victim. So far, attacks search for monolithic gadgets, a single sequence of code which performs all the attack steps.", "num_citations": "11\n", "authors": ["343"]}
{"title": "Don't race the memory bus: taming the GC leadfoot\n", "abstract": " Dynamic voltage and frequency scaling (DVFS) is ubiquitous on mobile devices as a mechanism for saving energy. Reducing the clock frequency of a processor allows a corresponding reduction in power consumption, as does turning off idle cores. Garbage collection is a canonical example of the sort of memory-bound workload that best responds to such scaling. Here, we explore the impact of frequency scaling for garbage collection in a real mobile device running Android's Dalvik virtual machine, which uses a concurrent collector. By controlling the frequency of the core on which the concurrent collector thread runs we can reduce power significantly. Running established multi-threaded benchmarks shows that total processor energy can be reduced up to 30%, with end-to-end performance loss of at most 10%.", "num_citations": "11\n", "authors": ["343"]}
{"title": "FuZZan: Efficient sanitizer metadata design for fuzzing\n", "abstract": " Fuzzing is one of the most popular and effective techniques for finding software bugs. To detect triggered bugs, fuzzers leverage a variety of sanitizers in practice. Unfortunately, sanitizers target long running experiments\u2014eg, developer test suites\u2014not fuzzing, where execution time is highly variable ranging from extremely short to long. Design decisions made for developer test suites introduce high overhead on short lived fuzzing executions, decreasing the fuzzer\u2019s throughput and thereby reducing effectiveness. The root cause of this sanitization overhead is the heavy-weight metadata structure that is optimized for frequent metadata operations over long executions. To address this, we design new metadata structures for sanitizers, and propose FuZZan to automatically select the optimal metadata structure without any user configuration. Our new metadata structures have the same bug detection capabilities as the ones they replace. We implement and apply these ideas to Address Sanitizer (ASan), which is the most popular sanitizer. Our evaluation shows that on the Google fuzzer test suite, FuZZan improves fuzzing throughput over ASan by 48% starting with Google\u2019s provided seeds (52% when starting with empty seeds on the same applications). Due to this improved throughput, FuZZan discovers 13% more unique paths given the same 24 hours and finds bugs 42% faster. Furthermore, FuZZan catches all bugs ASan does; ie, we have not traded precision for performance. Our findings show that sanitizer performance overhead is avoidable when metadata structures are designed for fuzzing, and that the performance difference will have a\u00a0\u2026", "num_citations": "9\n", "authors": ["343"]}
{"title": "Pythia: remote oracles for the masses\n", "abstract": " Remote Direct Memory Access (RDMA) is a technology that allows direct access from the network to a machine\u2019s main memory without involving its CPU. RDMA offers low-latency, high-bandwidth performance and low CPU utilization. While RDMA provides massive performance boosts and has thus been adopted by several major cloud providers, security concerns have so far been neglected.", "num_citations": "9\n", "authors": ["343"]}
{"title": "Automatic contract insertion with ccbot\n", "abstract": " Existing static analysis tools require significant programmer effort. On large code bases, static analysis tools produce thousands of warnings. It is unrealistic to expect users to review such a massive list and to manually make changes for each warning. To address this issue we propose CCBot (short for CodeContracts Bot), a new tool that applies the results of static analysis to existing code through automatic code transformation. Specifically, CCBot instruments the code with method preconditions, postconditions, and object invariants which detect faults at runtime or statically using a static contract checker. The only configuration the programmer needs to perform is to give CCBot the file paths to code she wants instrumented. This allows the programmer to adopt contract-based static analysis with little effort. CCBot's instrumented version of the code is guaranteed to compile if the original code did. This guarantee\u00a0\u2026", "num_citations": "8\n", "authors": ["343"]}
{"title": "One process to reap them all: Garbage collection as-a-service\n", "abstract": " Ubiquitous mobile platforms such as Android rely on managed language run-time environments, also known as language virtual machines (VMs), to run a diverse range of user applications (apps). Each app runs in its own private VM instance, and each VM makes its own private local decisions in managing its use of processor and memory resources. Moreover, the operating system and the hardware do not communicate their low-level decisions regarding power management with the high-level app environment. This lack of coordination across layers and across apps restricts more effective global use of resources on the device.", "num_citations": "7\n", "authors": ["343"]}
{"title": "Similarity-based matching meets malware diversity\n", "abstract": " Similarity metrics, e.g., signatures as used by anti-virus products, are the dominant technique to detect if a given binary is malware. The underlying assumption of this approach is that all instances of a malware (or even malware family) will be similar to each other. Software diversification is a probabilistic technique that uses code and data randomization and expressiveness in the target instruction set to generate large amounts of functionally equivalent but different binaries. Malware diversity builds on software diversity and ensures that any two diversified instances of the same malware have low similarity (according to a set of similarity metrics). An LLVM-based prototype implementation diversifies both code and data of binaries and our evaluation shows that signatures based on similarity only match one or few instances in a pool of diversified binaries generated from the same source code.", "num_citations": "7\n", "authors": ["343"]}
{"title": "Embracing the new threat: Towards automatically self-diversifying malware\n", "abstract": " Signature-based similarity metrics are the primary mechanism to detect malware on current systems. Each file is scanned and compared against a set of signatures. This approach has several problems:(i) all possible detectable malware must have a signature in the database and (ii) it might take a substantial amount of time between initial spread of the malware and the time anti-malware companies generate a signature to protect from the malware. On the other hand, the malware landscape is changing: there are only few malware families alive at a certain point in time. Each family evolves along a common software update and maintenance cycle. Individual malware instances are repacked or obfuscated whenever they are detected by a large set of anti-malware products, basically resulting in an arms race between malware authors and anti-malware products.Anti-malware products are not efficient if they follow this arms race and we show how it is possible to maximize the advantage for malware distributors. We present MalDiv, an automatic diversification mechanism that uses compilerbased transformations to generate an almost infinite amount of binaries with the same functionality but very low similarity, resulting in different signatures. Malware diversity builds on software diversity and uses open decisions in the compiler to reorder and change code and data. In addition, static data is encrypted using a set of transformations. Such a tool allows malware distributors to generate an almost unlimited amount of binaries that cannot be detected using signaturebased matching.", "num_citations": "7\n", "authors": ["343"]}
{"title": "Employing attack graphs for intrusion detection\n", "abstract": " Intrusion detection systems are a commonly deployed defense that examines network traffic, host operations, or both to detect attacks. However, more attacks bypass IDS defenses each year, and with the sophistication of attacks increasing as well, we must examine new perspectives for intrusion detection. Current intrusion detection systems focus on known attacks and/or vulnerabilities, limiting their ability to identify new attacks, and lack the visibility into all system components necessary to confirm attacks accurately, particularly programs. To change the landscape of intrusion detection, we propose that future IDSs track how attacks evolve across system layers by adapting the concept of attack graphs. Attack graphs were proposed to study how multi-stage attacks could be launched by exploiting known vulnerabilities. Instead of constructing attacks reactively, we propose to apply attack graphs proactively to detect\u00a0\u2026", "num_citations": "6\n", "authors": ["343"]}
{"title": "adaptSTM-an online fine-grained adaptive stm system\n", "abstract": " Transactional memory (TM) is an attractive platform for parallel programs, and several software transactional memory (STM) designs have been presented. Here we explore several optimization opportunities to adapt to the running program and to adapt parameters that are optimized for the average case. Depending on the program the transactional load can vary per thread (eg, client/server threads), or the program uses multiple phases of computation with different transactional loads. Therefore it is important that the STM adapts to the current situation, and that the adaptation process is short, efficient, and thread-local.We present adaptSTM, a competitive, word-based STM library that is based on a global clock and an array of combined global versions (timestamps) and locks. To keep track of transactional data adaptSTM implements a multi-level buffer and uses read-set extension to achieve competitive performance.", "num_citations": "6\n", "authors": ["343"]}
{"title": "Evading voltage-based intrusion detection on automotive CAN\n", "abstract": " The controller area network (CAN) is widely adopted in modern automobiles to enable communications among in-vehicle electronic control units (ECUs). Lacking mainstream network security capabilities due to resource constraints, the CAN is susceptible to the ECU masquerade attack in which a compromised (attacker) ECU impersonates an uncompromised (victim) ECU and spoofs the latter\u2019s CAN messages. A costeffective state-of-the-art defense against such attacks is the CAN bus voltage-based intrusion detection system (VIDS), which identifies the source of each message using its voltage fingerprint on the bus. Since the voltage fingerprint emanates from an ECU\u2019s hardware characteristics, an attacker ECU by itself cannot controllably modify it. As such, VIDS has been proved effective in detecting masquerade attacks that each involve a single attacker.In this paper, we discover a novel voltage corruption tactic that leverages the capabilities of two compromised ECUs (ie, an attacker ECU working in tandem with an accomplice ECU) to corrupt the bus voltages recorded by the VIDS. By exploiting this tactic along with the fundamental deficiencies of the CAN protocol, we propose a novel masquerade attack called DUET, which evades all existing VIDS irrespective of the features and classification algorithms employed in them. DUET follows a twostage attack strategy to first manipulate a victim ECU\u2019s voltage fingerprint during VIDS retraining mode, and then impersonate the manipulated fingerprint during VIDS operation mode. Our evaluation of DUET on real CAN buses (including three in two real cars) demonstrates an impersonation success\u00a0\u2026", "num_citations": "5\n", "authors": ["343"]}
{"title": "Blueshield: Detecting spoofing attacks in bluetooth low energy networks\n", "abstract": " Many IoT devices are equipped with Bluetooth Low Energy (BLE) to support communication in an energy-efficient manner. Unfortunately, BLE is prone to spoofing attacks where an attacker can impersonate a benign BLE device and feed malicious data to its users. Defending against spoofing attacks is extremely difficult as security patches to mitigate them may not be adopted across vendors promptly; not to mention the millions of legacy BLE devices with limited I/O capabilities that do not support firmware updates.", "num_citations": "5\n", "authors": ["343"]}
{"title": "Transformationaware symbolic execution for system test generation\n", "abstract": " A common development task is to take a behavior exercised in a single function (eg, a failing unit test), and to produce an input to the entire program (a system test) with the same behavior. In security, when the behavior is a potential vulnerability, this is constructing a proof-of-concept exploit. This task is challenging because it requires precise reasoning over an entire program. To automate instances of this task, our approach uses symbolic execution to generate program inputs that undergo transformations before they are used. Using information about the relationship of data structures and transformations in a program, our approach works backward, one transformation at a time, and applies optimized symbolic execution to search for transformation pre-images. Our techniques out-perform standard symbolic execution by several orders of magnitude, and construct exploits against two vulnerable document-processing applications without using source code.", "num_citations": "5\n", "authors": ["343"]}
{"title": "I control your code\n", "abstract": " Exploits are an interesting way to extend the functionality of programs. This paper presents and explains different attack vectors, namely stack-based and heap-based code injection, arc attacks on the heap as well as on the stack, format string attacks, arithmetic overflows, data attacks, and mixed ISA attacks. These attacks can be used (often in combination with other attacks) to execute arbitrary code.From a security perspective we want to analyze how the exploit is able to hijack and redirect the control flow and what kind of malicious system calls are executed. This paper presents an approach to software-based fault isolation (SFI) that verifies every single instruction that is executed. Guards guarantee that the threat of attacks that alter the control flow, eg, code injection, and arc attacks is removed. An additional system call authorization framework checks system calls and arguments and verifies that they conform to a strict user-defined policy. The combination of SFI and policy-based system call authorization enables an additional layer of protection for applications that runs completely in user-space.", "num_citations": "5\n", "authors": ["343"]}
{"title": "Benchiot: A security benchmark for the internet of things\n", "abstract": " Attacks against IoT systems are increasing at an alarming pace. Many IoT systems are and will be built using low-cost micro-controllers (IoT-uCs). Different security mechanisms have been proposed for IoT-uCs with different trade-offs. To guarantee a realistic and practical evaluation, the constrained resources of IoT-uCs require that defenses must be evaluated with respect to not only security, but performance, memory, and energy as well. Evaluating security mechanisms for IoT-uCs is limited by the lack of realistic benchmarks and evaluation frameworks. This burdens researchers with the task of developing not only the proposed defenses but applications on which to evaluate them. As a result, security evaluation for IoT-uCs is limited and ad-hoc. A sound benchmarking suite is essential to enable robust and comparable evaluations of security techniques on IoT-uCs. This paper introduces BenchIoT, a benchmark\u00a0\u2026", "num_citations": "4\n", "authors": ["343"]}
{"title": "The fuzzing hype-train: How random testing triggers thousands of crashes\n", "abstract": " Software contains bugs, and some bugs are exploitable. Mitigations protect our systems in the presence of these vulnerabilities, often stopping the program once a security violation has been detected. The alternative is to discover bugs during development and fix them in the code. The task of finding and reproducing bugs is difficult; however, fuzzing is an efficient way to find security-critical bugs by triggering exceptions, such as crashes, memory corruption, or assertion failures automatically (or with a little help). Furthermore, fuzzing comes with a witness (proof of the vulnerability) that enables developers to reproduce the bug and fix it.", "num_citations": "4\n", "authors": ["343"]}
{"title": "Control-flow hijacking: Are we making progress?\n", "abstract": " Memory corruption errors in C/C++ programs remain the most common source of security vulnerabilities in today's systems. Over the last 10+ years the security community developed several defenses [4]. Data Execution Prevention (DEP) protects against code injection--eradicating this attack vector. Yet, control-flow hijacking and code reuse remain challenging despite wide deployment of Address Space Layout Randomization (ASLR) and stack canaries. These defenses are probabilistic and rely on information hiding.", "num_citations": "4\n", "authors": ["343"]}
{"title": "Lldsal: A low-level domain-specific aspect language for dynamic code-generation and program modification\n", "abstract": " Dynamic binary translation frameworks enable late modifications of binary programs. The binary translator needs to generate dynamic code at runtime for trampolines, translated control flow instructions, additional runtime checks, and lookups. The code must be efficient, low-level, and cannot rely on any calling conventions.", "num_citations": "4\n", "authors": ["343"]}
{"title": "String Oriented Programming Circumventing ASLR, DEP, and Other Guards\n", "abstract": " The protection landscape is changing and exploits are getting more and more sophisticated. Exploit generation toolkits can be used to construct exploits for specific applications using well-defined algorithms. We present such an algorithm for leveraging format strings and introduce string oriented programming. String oriented programming takes format string exploits to the next level and turns an intrusion vector that needs hand-crafted exploits into arbitrary code execution. Similar to return oriented programming or jump oriented programming sting oriented programming does not rely on existing code but concatenates gadgets in the application using static program analysis. This paper presents an algorithm and a technique that takes a vulnerable application that contains a format string exploit as a parameter and constructs a format string exploit that can be used to inject a dynamic jump oriented programming dispatcher into the running application. String oriented programming circumvents ASLR, DEP, and ProPolice. 1.", "num_citations": "4\n", "authors": ["343"]}
{"title": "Blurtooth: Exploiting cross-transport key derivation in bluetooth classic and bluetooth low energy\n", "abstract": " The Bluetooth standard specifies two incompatible wireless transports: Bluetooth Classic (BT) for high-throughput services and Bluetooth Low Energy (BLE) for very low-power services. BT and BLE have different security architectures and threat models, but they use similar security mechanisms. In particular, pairing enables two devices to establish a long term key to secure the communication. Two devices have to pair over BT and BLE to use both transports securely. Since pairing the same devices two times is considered user-unfriendly, Bluetooth v4.2 introduced Cross-Transport Key Derivation (CTKD). CTKD allows two devices to pair once, either over BT or BLE, and generate both BT and BLE long term keys. Despite CTKD allowing traversal of the security boundary between BT and BLE, the security implications of CTKD have not yet been investigated. We present the first security analysis of CTKD and identify five cross-transport issues for BT and BLE. These issues enable, for the first time, exploitation of both BT and BLE by attacking either transport. Based on the identified issues, we demonstrate four novel cross-transport attacks resulting in device impersonation, traffic manipulation, and malicious session establishment. We refer to them as BLUR attacks, as they blur the security boundary between BT and BLE. The BLUR attacks are standard-compliant and therefore apply to all devices supporting CTKD, regardless of implementation details. We successfully demonstrate the BLUR attacks on 13 devices with 10 unique Bluetooth chips, and discuss effective countermeasures. We disclosed our findings and countermeasures to the Bluetooth\u00a0\u2026", "num_citations": "3\n", "authors": ["343"]}
{"title": "Butterfly attack: Adversarial manipulation of temporal properties of cyber-physical systems\n", "abstract": " Increasing internet connectivity poses an existential threat for cyber-physical systems. Securing these safety-critical systems becomes an important challenge. Cyber-physical systems often comprise several control applications that are implemented on shared platforms where both high and low criticality tasks execute together (to reduce cost). Such resource sharing may lead to complex timing behaviors and, in turn, counter-intuitive timing anomalies that can be exploited by adversaries to destabilize a critical control system, resulting in irreversible consequences. We introduce the butterfly attack, a new attack scenario against cyber-physical systems that carefully exploits the sensitivity of control applications with respect to the implementation on the underlying execution platforms. We illustrate the possibility of such attacks using two case-studies from the automotive and avionic domains.", "num_citations": "3\n", "authors": ["343"]}
{"title": "Retrowrite: Statically instrumenting cots binaries for fuzzing and sanitization\n", "abstract": " Software is often large and complex and therefore prone to exploitable vulnerabilities. While mitigations such as ASLR [1], DEP [2], Stack Canaries [3], or CFI [4, 5] protect the software against the active exploitation of some vulnerabilities they cannot protect software against the exploitation of all vulnerabilities and they are of limited use in discovering the locations of vulnerabilities. Best practices in software testing leverage coverage-guided fuzzing and sanitizers to discover bugs while producing concrete test cases to reproduce the bugs in a testing environment. Both coverage-guided fuzzing as well as sanitization requires additional instrumentation of the code. Current standard tools such as AFL [6], a coverage-guided fuzzer or Address Sanitizer (ASan)[7] require a recompilation of the source code to (i) get high level information about where to place the instrumentation and (ii) actually weave the instrumentation into the compiled code.Unfortunately, code is frequently only available in binary form. For example, many libraries or binaries such as the Google Hangouts plugin, Skype, or Zoom are not available as source code to protect the intellectual property of the vendors. Without access to source code, testing the security of such programs is challenging. Existing approaches either give up and rely on, eg, blackbox fuzzing [8] which often results in shallow coverage or rely on dynamic binary translation to add coverage tracking [9] or memory checks [10] to the executed binary at prohibitively high runtime cost of 100x and more (running AFL in QEMU mode on the LAVA-M [11] test suite results in 10x to 100x slowdown).", "num_citations": "3\n", "authors": ["343"]}
{"title": "Milkomeda: Safeguarding the mobile gpu interface using webgl security checks\n", "abstract": " GPU-accelerated graphics is commonly used in mobile applications. Unfortunately, the graphics interface exposes a large amount of potentially vulnerable kernel code (ie, the GPU device driver) to untrusted applications. This broad attack surface has resulted in numerous reported vulnerabilities that are exploitable from unprivileged mobile apps. We observe that web browsers have faced and addressed the exact same problem in WebGL, a framework used by web apps for graphics acceleration. Web browser vendors have developed and deployed a plethora of security checks for the WebGL interface. We introduce Milkomeda, a system solution for automatically repurposing WebGL security checks to safeguard the mobile graphics interface. We show that these checks can be used with minimal modifications (which we have automated using a tool called CheckGen), significantly reducing the engineering effort\u00a0\u2026", "num_citations": "3\n", "authors": ["343"]}
{"title": "Simple pluggable binary translator library in userspace\n", "abstract": " In the last few years, products using dynamic binary translation have become popular in the areas of virtualization, instrumentation and emulation. However, those binary translators that are freely available either have an unflexible high-level interface or are slow because they are primarily intended for instrumentation. As the result of this semester thesis, we present a lightweight, pluggable dynamic binary translation library with a very low-level interface. The binary translator works in a just-in-time fashion by translating the machine code that is just about to be executed, such that the translated version is executed instead. In order not to translate the same code several times, all translated fragments of code are stored in a translation cache, so they can be reused.The translator has to ensure that the flow of control stays within the translation cache at all times. This means that for any tranformation, every control flow\u00a0\u2026", "num_citations": "3\n", "authors": ["343"]}
{"title": "Seed selection for successful fuzzing\n", "abstract": " Mutation-based greybox fuzzing---unquestionably the most widely-used fuzzing technique---relies on a set of non-crashing seed inputs (a corpus) to bootstrap the bug-finding process. When evaluating a fuzzer, common approaches for constructing this corpus include:(i) using an empty file;(ii) using a single seed representative of the target's input format; or (iii) collecting a large number of seeds (eg, by crawling the Internet). Little thought is given to how this seed choice affects the fuzzing process, and there is no consensus on which approach is best (or even if a best approach exists).", "num_citations": "2\n", "authors": ["343"]}
{"title": "Rebooting virtual memory with midgard\n", "abstract": " Computer systems designers are building cache hierarchies with higher capacity to capture the ever-increasing working sets of modern workloads. Cache hierarchies with higher capacity improve system performance but shift the performance bottleneck to address translation. We propose Midgard, an intermediate address space between the virtual and the physical address spaces, to mitigate address translation overheads without program-level changes.Midgard leverages the operating system concept of virtual memory areas (VMAs) to realize a single Midgard address space where VMAs of all processes can be uniquely mapped. The Midgard address space serves as the namespace for all data in a coherence domain and the cache hierarchy. Because real-world workloads use far fewer VMAs than pages to represent their virtual address space, virtual to Midgard translation is achieved with hardware structures\u00a0\u2026", "num_citations": "2\n", "authors": ["343"]}
{"title": "{LIGHTBLUE}: Automatic Profile-Aware Debloating of Bluetooth Stacks\n", "abstract": " The Bluetooth standard is ubiquitously supported by computers, smartphones, and IoT devices. Due to its complexity, implementations require large codebases, which are prone to security vulnerabilities, such as the recently discovered BlueBorne and BadBluetooth attacks. While defined by the standard, most of the Bluetooth functionality, as defined by different Bluetooth profiles, is not required in the common usage scenarios.", "num_citations": "2\n", "authors": ["343"]}
{"title": "Too Quiet in the Library: A Study of Native Third-Party Libraries in Android\n", "abstract": " Android applications (\" apps\") make avid use of third-party native libraries to increase performance and to reuse already implemented functionality. Native code can be directly executed from apps through the Java Native Interface or the Android Native Development Kit. Android developers drop precompiled native libraries into their projects, enabling their use. Unfortunately, developers are often not aware that these libraries (or their dependencies) must be updated. This results in the continuous use of outdated native libraries with unpatched security vulnerabilities years after patches are available. To assess the severity of the use of outdated and vulnerable libraries in the Android ecosystem, we study the prevalence of native libraries in the top applications of the Google Play market over time, correlating the time when native libraries are updated with the availability of security patches. A core difficulty we have to\u00a0\u2026", "num_citations": "2\n", "authors": ["343"]}
{"title": "Polper: Process-aware restriction of over-privileged setuid calls in legacy applications\n", "abstract": " Setuid system calls enable critical functions such as user authentications and modular privileged components. Such operations must only be executed after careful validation. However, current systems do not perform rigorous checks, allowing exploitation of privileges through memory corruption vulnerabilities in privileged programs. As a solution, understanding which setuid system calls can be invoked in what context of a process allows precise enforcement of least privileges. We propose a novel comprehensive method to systematically extract and enforce least privilege of setuid system calls to prevent misuse. Our approach learns the required process contexts of setuid system calls along multiple dimensions: process hierarchy, call stack, and parameter in a process-aware way. Every setuid system call is then restricted to the per-process context by our kernel-level context enforcer. Previous approaches without\u00a0\u2026", "num_citations": "2\n", "authors": ["343"]}
{"title": "secuBT: Hacking the hackers with user-space virtualization\n", "abstract": " In the age of coordinated malware distribution and zero-day exploits security becomes ever more important. This paper presents secuBT, a safe execution framework for the execution of untrusted binary code based on the fastBT dynamic binary translator. secuBT implements user-space virtualization using dynamic binary translation and adds a system call interposition framework to limit and guard the interoperability of binary code with the kernel. Fast binary translation is a key component to user-space virtualization. secuBT uses and extends fastBT, a generator for low-overhead, tablebased dynamic (just-in-time) binary translators. We discuss the most challenging sources of overhead and propose optimizations to further reduce these penalties. We argue for hardening techniques to ensure that the translated program cannot escape out of the user-space virtualization. An important feature of secuBT is that only translated code is executed. This ensures code validity and makes it possible to rewrite individual instructions. The system call interposition framework validates every system call and offers the choice to (i) allow it,(ii) abort the program,(iii) redirect to an user-space emulation.", "num_citations": "2\n", "authors": ["343"]}
{"title": "Code Specialization through Dynamic Feature Observation\n", "abstract": " Modern software (both programs and libraries) provides large amounts of functionality, vastly exceeding what is needed for a single given task. This additional functionality results in an increased attack surface: first, an attacker can use bugs in the unnecessary functionality to compromise the software, and second, defenses such as control-flow integrity (CFI) rely on conservative analyses that gradually lose precision with growing code size.", "num_citations": "1\n", "authors": ["343"]}
{"title": "How memory safety violations enable exploitation of programs\n", "abstract": " Our programs, runtime systems, operating systems, and hypervisors are, to a large extent, written in low-level languages like C or C++. These systems languages were initially designed more than 30 years ago when performance was the key metric and security was, at best, a side note. Our systems languages do not enforce memory safety and force the programmer to include necessary safety checks. Coding guidelines and code quality continuously improved over time due to an increased awareness of security. Along with this awareness, language standards and compilers evolved as well and became more powerful, especially compilers that now offer (optional) safety checks. Yet, despite these improvements some attack surface remains. Adversaries can abuse bugs that cause memory safety violations to change the semantics of the program, executing the adversary\u2019s desired behavior. Memory safety issues are\u00a0\u2026", "num_citations": "1\n", "authors": ["343"]}
{"title": "libdetox: A Framework for Online Program Transformation\n", "abstract": " Software is commonly available in binary form. Yet, the consumer would often like to gather information about the application, eg, what functionality is available and needed or what security mechanisms are active. In secure environments, the code must also be hardened against attacks. So far, existing binary analysis and translation mechanisms are often ad-hoc and only target one aspect of the problem. We propose libdetox, a principled framework for continuous binary analysis and instrumentation. Our framework builds on an efficient binary translator and a trusted program loader to enable the collection of vast information which is later used for binary hardening. We present several runtime monitors such as a shadow stack, control-flow integrity, system call monitor, or on-the-fly patch application.", "num_citations": "1\n", "authors": ["343"]}
{"title": "Safe loading and efficient runtime confinement: A foundation for secure execution\n", "abstract": " Protecting running applications is a hard problem. Many applications are written in a low-level language and are prone to exploits. Bugs can be used to exploit the application and to run malicious code. A rigorous code review is often not possible due to the size and the complexity of the applications. Even a detailed code review does not guarantee that all bugs in the application are found.This thesis presents a model for the secure execution of untrusted code. The model assumes that the application code contains bugs but that the application is not malicious (ie, malware). The application is safe if the model protects from all attack vectors through code-based or data-based exploits in the untrusted code. The model verifies all code prior to execution and ensures that no unchecked control flow transfers are possible. An important design decision is to use a dynamic approach for the implementation with minimal impact on the original applications. Binary only applications are executed without static recompilation or changes to the compiler toolchain (eg, no recompilation is needed and features like dynamically loaded libraries, lazy binding, or hand written assembly code are still usable). A dynamic, transparent sandbox in user-space loads and verifies code using binary translation. A secure loader starts the sandbox and bootstraps the application and all needed libraries in the sandbox. The sandbox checks the application code before it is executed and adds security guards during the translation. The combination of the secure loader and the sandbox protects from code-oriented exploits. System calls are redirected by the sandbox to a policy-based\u00a0\u2026", "num_citations": "1\n", "authors": ["343"]}
{"title": "Implementation of a Bluetooth Stack for BTnodes and Nut/OS Version 0.9\n", "abstract": " The target of this semester thesis was to develop a modular Bluetooth stack for BTnodes. BTnodes are microcontrollers with very low computing power and memory and have a Bluetooth controller attached. The main target of the stack is to ensure communication between different BTnodes. This leads to the implementation of some specific layers of the Bluetooth specification.", "num_citations": "1\n", "authors": ["343"]}