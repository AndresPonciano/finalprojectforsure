{"title": "Code smells as system-level indicators of maintainability: An empirical study\n", "abstract": " ContextCode smells are manifestations of design flaws that can degrade code maintainability. So far, no research has investigated if these indicators are useful for conducting system-level maintainability evaluations.AimThe research in this paper investigates the potential of code smells to reflect system-level indicators of maintainability.MethodWe evaluated four medium-sized Java systems using code smells and compared the results against previous evaluations on the same systems based on expert judgment and the Chidamber and Kemerer suite of metrics. The systems were maintained over a period of up to 4 weeks. During maintenance, effort (person-hours) and number of defects were measured to validate the different evaluation approaches.ResultsMost code smells are strongly influenced by size; consequently code smells are not good indicators for comparing the maintainability of systems differing greatly\u00a0\u2026", "num_citations": "76\n", "authors": ["137"]}
{"title": "Assessing the capability of code smells to explain maintenance problems: an empirical study combining quantitative and qualitative data\n", "abstract": " Code smells are indicators of deeper design problems that may cause difficulties in the evolution of a software system. This paper investigates the capability of twelve code smells to reflect actual maintenance problems. Four medium-sized systems with equivalent functionality but dissimilar design were examined for code smells. Three change requests were implemented on the systems by six software developers, each of them working for up to four weeks. During that period, we recorded problems faced by developers and the associated Java files on a daily basis. We developed a binary logistic regression model, with \u201cproblematic file\u201d as the dependent variable. Twelve code smells, file size, and churn constituted the independent variables. We found that violation of the Interface Segregation Principle (a.k.a. ISP violation) displayed the strongest connection with maintenance problems. Analysis of\u00a0\u2026", "num_citations": "75\n", "authors": ["137"]}
{"title": "Assessing the capability of code smells to support software maintainability assessments: Empirical inquiry and methodological approach\n", "abstract": " Code smells are indicators of software design shortcomings that can decrease software maintainability. An advantage of code smells over traditional software measures is that the former are associated with an explicit set of refactoring strategies to improve the existing design. As such, code smell analysis is a promising approach to address both the assessment and the improvement of maintainability. An important challenge in code smell analysis is understanding the interplay between code smells and different aspects of maintenance. Research on code smells conducted in the past decade has emphasized the formalization and automated detection of code smells. Much less research has been conducted to empirically investigate how comprehensive and informative code smells are for the assessment of software maintainability. If we are to use code smells to assess maintainability, we need to understand their potential in explaining and predicting different maintenance outcomes and their usefulness in industrial settings. Relevant questions in using code smells as maintainability indicators include: \u201cWhat and how much can code smells tell me about the maintainability of a system as a whole?\u201d and \u201cHow suitable are code smells in identifying code segments (i.e., files) with low software maintainability?\u201d The main goal of this thesis is to empirically investigate, from different perspectives and in a realistic setting, the strengths and limitations of code smells in supporting software maintainability assessments. The secondary goal is to suggest approaches to address the limitations of code smells and the assessments based on them. Both goals are\u00a0\u2026", "num_citations": "27\n", "authors": ["137"]}
{"title": "Can you tell me if it smells? a study on how developers discuss code smells and anti-patterns in stack overflow\n", "abstract": " This paper investigates how developers discuss code smells and anti-patterns over Stack Overflow to understand better their perceptions and understanding of these two concepts. Understanding developers' perceptions of these issues are important in order to inform and align future research efforts and direct tools vendors in the area of code smells and anti-patterns. In addition, such insights could lead the creation of solutions to code smells and anti-patterns that are better fit to the realities developers face in practice. We applied both quantitative and qualitative techniques to analyse discussions containing terms associated with code smells and anti-patterns. Our findings show that developers widely use Stack Overflow to ask for general assessments of code smells or anti-patterns, instead of asking for particular refactoring solutions. An interesting finding is that developers very often ask their peers' to smell their\u00a0\u2026", "num_citations": "24\n", "authors": ["137"]}
{"title": "yExploring Potential Usability Gaps when Switching Mobile Phones: An Empirical Study\n", "abstract": " The present study explores potential usability gaps when users switch from a familiar to an unfamiliar mobile phone interface. A within-subject experiment was performed in which nine users familiar with Sony-Ericsson T630 and nine familiar with Nokia 7250 performed tasks on both phones. On average, test subjects spent more time on finishing tasks with an unfamiliar phone than with a familiar one. For two of the four tasks, there was a significant difference in completion time between the first-time Nokia users and the first-time Sony-Ericsson users. The tasks of adding a contact to the address book and sending an SMS to a contact in the address book were performed more quickly by new Nokia users than by new Sony-Ericsson users. The subjective difficulty ranking also showed that first-time Nokia users found the new phone easier to use than first-time Sony- Ericsson users did. Hierarchical Task Analysis is used as a potential explanation, and three other theories that relate to these findings are presented: mental models, habit errors, and emotional attachment.", "num_citations": "16\n", "authors": ["137"]}
{"title": "How good are code smells for evaluating software maintainability? Results from a comparative case study\n", "abstract": " An advantage of code smells over traditional software measures is that the former are associated with an explicit set of refactorings to improve the existing design. Past research on code smells has emphasized the formalization and automated detection of code smells, but much less has been done to empirically investigate how good are code smells for evaluating software maintainability. This paper presents a summary of the findings in the thesis by Yamashita, which aimed at investigating the strengths and limitations of code smells for evaluating software maintainability. The study conducted comprised an outsourced maintenance project involving four Java web systems with equivalent functionality but dissimilar implementation, six software professionals, and two software companies. A main result from the study is that the usefulness of code smells differs according to the granularity level (e.g., whether the\u00a0\u2026", "num_citations": "15\n", "authors": ["137"]}
{"title": "A large scale study on how developers discuss code smells and anti-pattern in stack exchange sites\n", "abstract": " Context: In this paper, we investigate how developers discuss code smells and anti-patterns across three technical Stack Exchange sites. Understanding developers perceptions of these issues is important to inform and align future research efforts and direct tools vendors to design tailored tools that best suit developers. Method: we mined three Stack Exchange sites and used quantitative and qualitative methods to analyse more than 4000 posts that discuss code smells and anti-patterns.Results: results showed that developers often asked their peers to smell their code, thus utilising those sites as an informal, crowd-based code smell/anti-pattern detector. The majority of questions (556) asked were focused on smells like Duplicated Code, Spaghetti Code, God and Data Classes. In terms of languages, most of discussions centred around popular languages such as C# (772 posts), JavaScript (720) and Java (699\u00a0\u2026", "num_citations": "14\n", "authors": ["137"]}
{"title": "Harnessing Twitter to support serendipitous learning of developers\n", "abstract": " Developers often rely on various online resources, such as blogs, to keep themselves up-to-date with the fast pace at which software technologies are evolving. Singer et al. found that developers tend to use channels such as Twitter to keep themselves updated and support learning, often in an undirected or serendipitous way, coming across things that they may not apply presently, but which should be helpful in supporting their developer activities in future. However, identifying relevant and useful articles among the millions of pieces of information shared on Twitter is a non-trivial task. In this work to support serendipitous discovery of relevant and informative resources to support developer learning, we propose an unsupervised and a supervised approach to find and rank URLs (which point to web resources) harvested from Twitter based on their informativeness and relevance to a domain of interest. We propose\u00a0\u2026", "num_citations": "13\n", "authors": ["137"]}
{"title": "Integration of SE Research and Industry: Reflections, Theories and Illustrative Example\n", "abstract": " Currently, there is limited literature in Software Engineering (SE) that sheds light on the success factors and challenges for knowledge transfer between SE scientists and practitioners. Upon reflections on personal experiences from both academia and industry, this paper attempts to underpin some of the challenges for a successful collaboration, and relate them back to existing theories in the fields of Management, Medicine and Social Sciences. Furthermore, strategies for overcoming some of the challenges are provided and illustrated via a simplified example within the topic of Software Evolution. The intention of this paper is to establish a dialogue for an overall strategy within our field, by providing an illustrative example, and to promote a deeper reflection on the term 'knowledge transfer', which has predominantly focused on an unidirectional knowledge flow from academia to industry.", "num_citations": "10\n", "authors": ["137"]}
{"title": "Experiences from Performing Software Quality Evaluations via Combining Benchmark-Based Metrics Analysis, Software Visualization, and Expert Assessment\n", "abstract": " Software quality assessments are critical in organizations where the software has been produced by external vendors, or when the development and maintenance of a software product has been outsourced to external parties. These assessments are typically challenging because is not always possible to access the original developers (or sometimes is not even allowed), and in rare cases suppliers keep an account of the costs associated to code changes or defect fixes. In those situations, one is left with the artifacts (e.g., database, source code, and documentation) as the only sources of evidence for performing such evaluations. A major challenge is also to provide fact-based conclusions for supporting decision-making, instead of subjective interpretations based on expert assessments (an approach still very predominant in mainstream industrial practice). This paper describes an instance of a software quality\u00a0\u2026", "num_citations": "9\n", "authors": ["137"]}
{"title": "Preliminary catalogue of anti-pattern and code smell false positives\n", "abstract": " Anti-\u2010patterns and code smells are archetypes used for describing software design shortcomings that can negatively affect software quality, in particular maintainability. Tools, metrics and methodologies have been developed to identify these structural archetypes, based on the assumption that they can point at problematic code. However, recent empirical studies have shown that some of these archetypes are ubiquitous in real world programs, and many of them are found to not be as detrimental to quality as previously conjectured. We are therefore interested to revisit common smells and anti-\u2010patterns, and build a catalogue of cases that constitute candidates for\u201cfalse positives\u201d. A Meta-\u2010synthesis was conducted on: a) the last 10 years of empirical studies conducted on code smells and anti-\u2010patterns, b) practical examples from grey literature (eg, blogs), and c) case studies from industry and open source projects. We furthermore propose a preliminary classification to improve the current conceptual framework for understanding better the effects of code smells and anti-\u2010patterns in practice. We hope that the development and further refinement of such classification can support researchers and tool vendors in their endeavor for developing more pragmatic, context-\u2010relevant detection and analysis tools for anti-\u2010patterns and code smells.", "num_citations": "7\n", "authors": ["137"]}
{"title": "Expert habits vs. ui improvements: re-design of a room booking system\n", "abstract": " This paper presents the results of a case study examining prototyping as a method in re-designing a user interface (UI). In the case presented, a web-based room booking was re-designed. Running on a university web site, the existing system has caused much critique amongst its users. Their expectations for a new UI were increased ease of use, less effort required, and less time consumed. We prototyped a new UI using Visio and tested it with a small number of experienced and novice users. Our results partly favor the existing system and partly the new one. To our surprise, experienced users performed relatively poorer with the new UI considering their critique of the existing one. We found paper prototyping to be an efficient method to gain user feedback on usability issues and that a low-fidelity prototype does not automatically mean low-effort testing. We observed that visible-state UI elements can be demanding to test through paper prototyping.", "num_citations": "6\n", "authors": ["137"]}
{"title": "Cultural Characteristics and Their Connection to Increased Risk of\u00a0\u2026\n", "abstract": " Offshoring software projects have been documented to increase the risk of project failure. In particular, the cultural differences between software client and provider countries are believed to increase the risk of project failure. We analyze a large data set of small software projects with providers and clients from various countries. For each provider and client country, and each combination of provider and client country, we calculate the project failure rate. We use Hofstede\u2019s culture dimensions power distance, individualism, masculinity and uncertainty avoidance together with Hall\u2019s communication style to measure cultural characteristics and differences. We found a statistically significant increase in failure rate with increased difference in the provider and client country\u2019s communication style, but no connection between cultural differences and project failure rate using Hofstede\u2019s cultural characteristics. Provider countries, and in particular, client countries with a low-context communication culture had lower proportions of project failures than countries with high-context cultures. A decrease in power distance and increase in individualism were both connected with a decrease in project failure rate. In total, the cultural differences between countries seem to matter less than cultural characteristics of the countries. In particular, some of the cultural characteristics of the client country were strongly connected with project failure rates. Software offshoring clients may benefit from an awareness of the importance of their role in avoiding project failures and consider adopting the cultural characteristics of the most successful client offshoring countries. They may\u00a0\u2026", "num_citations": "5\n", "authors": ["137"]}
{"title": "Experiences from testing a radiotherapy support system with quickcheck\n", "abstract": " We present a case study on the use of lightweight formal methods for testing part of a real-time organ position tracking system used in radiotherapy. Several properties were modeled and verified through automated test cases generated by QuickCheck. QuickCheck was found useful in reducing the complexity inherent to testing medical devices by detecting faults at system level, and assisting in the exploration of atypical errors that could later be analyzed and fixed in the system. We suggest that a combination of lightweight formal methods and random test generation, supported by automated simplification of test cases may represent a feasible option in the medical domain; particularly for those projects with high-pace development, a need for proof-based techniques/tools for certification processes, and when the non-deterministic nature of real-time devices demands the exploration/identification of heterogeneous fault sources.", "num_citations": "2\n", "authors": ["137"]}
{"title": "A multi-method approach for evaluating software maintainability and comprehensibility\n", "abstract": " The maintainability of software is a critical determinant of software costs, yet a very difficult attribute to evaluate. Insofar, no unified theory is available regarding how to use design attributes of a software system (represented either by structural measures1, structural symptoms2 or a combination of both) to evaluate accurately the maintainability of a system. Construct validity of software measures, as well as realistic maintainability models/evaluation techniques, are still subject of a latent discussion in the software engineering community.The diversity of contexts and situations makes it difficult to generalize findings from individual studies, and the inherent complexity of software maintenance (encompassing technological, human dynamics and cognition aspects) make the assessment of maintainability a difficult task. In those regards, we have a similar viewpoint as Pizka & Dei\u00dfenb\u00f6ck [7] as they state:\u201cmaintainability is not solely a property of a system but touches three different dimensions: a) The skills of the organization performing software maintenance, b) Technical properties of the system under consideration and c) Requirements engineering\u201d.", "num_citations": "2\n", "authors": ["137"]}
{"title": "How Good Are Code Smells for Evaluating Software Maintainability?\n", "abstract": " How Good are Code Smells for Evaluating Software Maintainability? Page 1 How Good are Code Smells for Evaluating Software Maintainability? Aiko Yamashita Simula Research Laboratory Mesan AS Results from a Comparative Case Study Page 2 Outline 2 Background and Motivation Research Objective Research Methodology Results and Lessons The Future! Page 3 Software Maintainability \u2026but also because we rely on the proper functioning of the systems that we utilize on a daily basis\u2026 Maintainability has been of paramount importance, not only due to extensive costs entailed by maintenance activities\u2026 [Harrison & Cook, 1990] [Abran and Nguyenkim, 1991] [Pigoski, 1996] W. Harrison, C. Cook, \"Insights on improving the maintenance process through software measurement,\u201d, Conference on Software Maintenance, 1990. pp.37-45,Nov 1990. Abran, A. and H. Nguyenkim. Analysis of maintenance work . in [\u2026", "num_citations": "1\n", "authors": ["137"]}
{"title": "Measuring the outcomes of a maintenance project: Technical details and protocols\n", "abstract": " This report describes the procedures used in order to extract and measure different maintenance outcomes resulting from the maintenance project conducted by Simula Research Laboratories on the Database of Empirical Studies (DES) Systems. The description covers maintenance variables definition, data collection, extraction, and summarization. The purpose of this document is to provide enough details on the protocol followed during the project, that can serve as guidelines to observe, measure and report different factors/variables in studies investigating software maintenance.", "num_citations": "1\n", "authors": ["137"]}