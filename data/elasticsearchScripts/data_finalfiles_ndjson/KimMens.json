{"title": "Reuse contracts: Managing the evolution of reusable assets\n", "abstract": " A critical concern in the reuse of software is the propagation of changes made to reusable artifacts. Without techniques to manage these changes, multiple versions of these artifacts will propagate through different systems and reusers will not be able to benefit from improvements to the original artifact. We propose to codify the management of change in a software system by means of reuse contracts that record the protocol between managers and users of a reusable asset. Just as real world contracts can be extended, amended and customised, reuse contracts are subject to parallel changes encoded by formal reuse operators: extension, refinement and concretisation. Reuse contracts and their operators serve as structured documentation and facilitate the propagation of changes to reusable assets by indicating how much work is needed to update previously built applications, where and how to test and how to\u00a0\u2026", "num_citations": "283\n", "authors": ["982"]}
{"title": "Mining aspectual views using formal concept analysis\n", "abstract": " We report upon an initial experiment using the technique of formal concept analysis for mining aspectual views from the source code. An aspectual view is a set of source code entities, such as class hierarchies, classes and methods that are structurally related in some way, and often crosscut a particular application. Initially, we follow a lightweight approach, where we only consider the names of classes and methods. This simplistic technique already results in the discovery of interesting and meaningful aspectual views, leaving us confident that more complex approaches will perform even better, and merit to be studied in the future.", "num_citations": "161\n", "authors": ["982"]}
{"title": "Supporting software development through declaratively codified programming patterns\n", "abstract": " In current-day software development, programmers often use programming patterns to clarify their intents and to increase the understandability of their programs. Unfortunately, most software development environments do not adequately support the declaration and use of such patterns. To explicitly codify these patterns, we adopt a declarative meta programming approach. In this approach, we reify the structure of a (object-oriented) program in terms of logic clauses. We declare programming patterns as logic rules on top of these clauses. By querying the logic system, these rules allow us to check, enforce and search for occurrences of certain patterns in the software. As such, the programming patterns become an active part of the software development and maintenance environment.", "num_citations": "124\n", "authors": ["982"]}
{"title": "Subjective-C: Bringing context to mobile platform programming\n", "abstract": " Thanks to steady advances in hardware, mobile computing platforms are nowadays much more connected to their physical and logical environment than ever before. To ease the construction of adaptable applications that are smarter with respect to their execution environment, the context-oriented programming paradigm has emerged. However, up until now there has been no proof that this emerging paradigm can be implemented and used effectively on mobile devices, probably the kind of platform which is most subject to dynamically changing contexts. In this paper we study how to effectively realise core context-oriented abstractions on top of Objective-C, a mainstream language for mobile device programming. The result is Subjective-C, a language which goes beyond existing context-oriented languages by providing a rich encoding of context interdependencies. Our initial validation cases and\u00a0\u2026", "num_citations": "96\n", "authors": ["982"]}
{"title": "Declaratively codifying software architectures using virtual software classifications\n", "abstract": " Most current day software engineering tools and environments do not sufficiently support software engineers to declare or to enforce the intended software architecture. Architectures are typically described at a too low level, inhibiting their evolution and understanding. Furthermore, most tools provide little support to verify automatically whether the source code conforms to the architecture. Therefore, a formalism is needed in which architectures can be expressed at a sufficiently abstract level, without losing the ability to perform conformance checking automatically. We propose to codify declaratively software architectures using virtual software classifications and relationships among these classifications. We illustrate how software architectures can be expressed elegantly in terms of these virtual classifications and how to keep them synchronized with the source code.", "num_citations": "70\n", "authors": ["982"]}
{"title": "Building composable aspect-specific languages with logic metaprogramming\n", "abstract": " The goal of aspect-oriented programming is to modularize crosscutting concerns (or aspects) at the code level. These aspects can be defined in either a general-purpose language or in a language that is fine-tuned to a specific aspect in consideration. Aspect-specific languages provide more concise and more readable aspect declarations but are limited to a specific domain. Moreover, multiple aspects may be needed in a single application and composing aspects written in different aspect languages is not an easy task.               To solve this composition problem, we represent both aspects and aspect languages as modularized logic metaprograms. These logic modules can be composed in flexible ways to achieve combinations of aspects written in different aspect-specific languages. As such, the advantages of both general-purpose and aspect-specific languages are combined.", "num_citations": "68\n", "authors": ["982"]}
{"title": "Context-oriented programming with the ambient object system.\n", "abstract": " In this paper we present AmOS, the Ambient Object System that underlies the Ambience programming language. AmOS implements a computation model that supports highly dynamic behaviour adaptation to changing contexts. Apart from being purely object-based, AmOS features first-class closures, multimethods and contexts. Dynamic method scoping through a subjective dispatch mechanism is at the heart of our approach. These features make of AmOS a very simple and elegant paradigm for context-oriented programming.", "num_citations": "65\n", "authors": ["982"]}
{"title": "Co-evolution of object-oriented software design and implementation\n", "abstract": " Modern-day software development shows a number of feedback loops between various phases in its life cycle; object-oriented software is particularly prone to this. Whereas descending through the different levels of abstraction is relatively straightforward and well supported by methods and tools, the synthesis of design information from an evolving implementation is far from obvious. This is why in many instances, analysis and design is used to initiate software development while evolution is directly applied to the implementation. Keeping design information synchronized is often reduced to a token activity, the first to be sacrificed in the face of time constraints. In this light, architectural styles are particularly difficult to enforce, since they can, by their very nature, be seen to crosscut an implementation. This contribution reports on a number of experiments to use logic meta-programming (LMP) to augment an\u00a0\u2026", "num_citations": "64\n", "authors": ["982"]}
{"title": "Automating architectural conformance checking by means of logic meta programming\n", "abstract": " Automating Architectural Conformance Checking by means of Logic Meta Programming \u2014 Vrije Universiteit Brussel Skip to main navigation Skip to search Skip to main content Vrije Universiteit Brussel Home Vrije Universiteit Brussel Logo Help & FAQ English Nederlands Home Research Units Profiles Projects Research output Activities Equipment Prizes Press / Media Student theses Impacts Search by expertise, name or affiliation Automating Architectural Conformance Checking by means of Logic Meta Programming Kim Mens Vrije Universiteit Brussel Research output: Thesis \u203a PhD Thesis Overview Original language English Awarding Institution Vrije Universiteit Brussel Supervisors/Advisors D'Hondt, Theo, Supervisor Place of Publication Brussels Publication status Unpublished - 2000 Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Mens, K. (2000). Automating Architectural Conformance \u2026", "num_citations": "63\n", "authors": ["982"]}
{"title": "Aspect-oriented programming workshop report\n", "abstract": " Whereas it is generally acknowledged that code tangling reduces the quality of software and that aspect-oriented programming (AOP) is a means of addressing this problem, there is \u2014 as yet \u2014 no clear definition or characterisation of AOP. Therefore, the main goal of the ECOOP\u201997 AOP workshop was to identify the \u201cgood questions\u201d for exploring the idea of AOP.", "num_citations": "57\n", "authors": ["982"]}
{"title": "Delving source code with formal concept analysis\n", "abstract": " Getting an initial understanding of the structure of a software system, whether it is for software maintenance, evolution or reengineering purposes, is a nontrivial task. We propose a lightweight approach to delve a system's source code automatically and efficiently for relevant concepts of interest: what concerns are addressed in the code, what patterns, coding idioms and conventions have been adopted, and where and how are they implemented. We use formal concept analysis to do the actual source-code mining, and then filter, classify and combine the results to present them in a format that is more convenient to a software engineer. We applied a prototype tool that implements this approach to several small to medium-sized Smalltalk applications. For each of these, the tool uncovered several design pattern instances, coding and naming conventions, refactoring opportunities and important domain concepts\u00a0\u2026", "num_citations": "56\n", "authors": ["982"]}
{"title": "Context traits: dynamic behaviour adaptation through run-time trait recomposition\n", "abstract": " Context-oriented programming emerged as a new paradigm to support fine-grained dynamic adaptation of software behaviour according to the context of execution. Though existing context-oriented approaches permit the adaptation of individual methods, in practice behavioural adaptations to specific contexts often require the modification of groups of interrelated methods. Furthermore, existing approaches impose a composition semantics that cannot be adjusted on a domain-specific basis. The mechanism of traits seems to provide a more appropriate level of granularity for defining adaptations, and brings along a flexible composition mechanism that can be exploited in a dynamic setting. This paper explores how to achieve context-oriented programming by using traits as units of adaptation, and trait composition as a mechanism to introduce behavioural adaptations at run time. First-class contexts reify relevant\u00a0\u2026", "num_citations": "44\n", "authors": ["982"]}
{"title": "Using intentional source-code views to aid software maintenance\n", "abstract": " The conceptual structure of existing software systems is often implicit or non-existing in the source code. We propose the lightweight abstraction of intentional source-code views as a means of making these conceptual structures more explicit. Based on the experience gained with two case studies, we illustrate how intentional source-code views can simplify and improve software understanding, maintenance and evolution in various ways. We present the results as a catalog of usage scenarios in a pattern-like format.", "num_citations": "34\n", "authors": ["982"]}
{"title": "Predicated Generic Functions: Enabling Context-Dependent Method Dispatch\n", "abstract": " This paper presents predicated generic functions, a novel programming language abstraction that allows the expression of context-dependent behaviour in a declarative and modular manner, providing fine-grained control of method applicability and method specificity. Methods are guarded by predicates with user-defined orderings, thereby increasing the expressiveness of existing method dispatching approaches. We have prototyped our proposal in Lambic, an extension of the standard Common Lisp Object System. We illustrate and motivate our approach by discussing the implementation of a collaborative graphical editor.", "num_citations": "26\n", "authors": ["982"]}
{"title": "Source code-based recommendation systems\n", "abstract": " Although today\u2019s software systems are composed of a diversity of software artifacts, source code remains the most up-to-date artifact and therefore the most reliable data source. It provides a rich and structured source of information upon which recommendation systems can rely to provide useful recommendations to software developers. Source code-based recommendation systems provide support for tasks such as how to use a given API or framework, provide hints on things missing from the code, suggest how to reuse or correct an existing code, or help novices learn a new project, programming paradigm, language, or style. This chapter highlights relevant decisions involved in developing source code-based recommendation systems. An in-depth presentation of a particular system we developed serves as a concrete illustration of some of the issues that can be encountered and of the development\u00a0\u2026", "num_citations": "25\n", "authors": ["982"]}
{"title": "Modeling and analyzing self-adaptive systems with context Petri nets\n", "abstract": " The development of self-adaptive systems requires the definition of the parts of the system that will be adapted, when such adaptations will take place, and how these adaptations will interact with each other. However, foreseeing all possible adaptations and their interactions is a difficult task, opening the possibility to inconsistencies or erroneous system behavior. To avoid inconsistencies, self adaptive systems require a sound programming model that allows to reason about the correctness of the system in spite of its dynamic reconfigurations. This paper presents context Petri nets, a Petri net-based programming model for self-adaptive systems. This model provides a formal definition of adaptations and their interaction, as well as a consistent process for their inclusion in the system. Besides serving as an underlying run-time model to ensure that adaptations and their constraints remain consistent, context Petri nets\u00a0\u2026", "num_citations": "25\n", "authors": ["982"]}
{"title": "Managing software evolution through reuse contracts\n", "abstract": " Assessing the impact of changes in one part of a software system on other parts remains one of the most compelling problems in software maintenance. This problem can be relieved by making implicit dependencies between different system parts explicit. We propose to explicitly document interactions between different system parts by means of reuse contracts that can only be manipulated by formal reuse operators. Reuse contracts and their operators facilitate managing the evolution of a software system by indicating how much work is needed to update the system, by pointing out when and which problems might occur and where and how to test and adjust the system.", "num_citations": "23\n", "authors": ["982"]}
{"title": "Open unification for program query languages\n", "abstract": " Logic-based programming languages are increasingly applied as program query languages which allow developers to reason about the structure and behaviour of programs. To achieve this, the queried programs are reified as logic values such that logic quantification and unification can be used effectively. However, in many cases, standard logic unification is inappropriate for program entities, forcing developers to resort to overly complex queries. In this paper, we argue that such incidental complexity can be reduced significantly by customizing the unification algorithm. We present a practical implementation approach through inter-language reflection and open unification. These techniques are at the core of the logic program query language SOUL, through which we demonstrate custom unification schemes for reasoning over Smalltalk and Java programs. Queries written in this tailored version of SOUL can\u00a0\u2026", "num_citations": "20\n", "authors": ["982"]}
{"title": "Semantics for Consistent Activation in Context-Oriented Systems\n", "abstract": " ContextContext-oriented programming languages provide dedicated programming abstractions to define behavioral adaptations and means to combine those adaptations dynamically according to sensed context changes. Some of these languages feature programming abstractions to explicitly define interaction dependencies among contexts. However, the semantics of context activation and the meaning of dependency relations have been described only informally, which in some cases has led to incorrect specifications, faulty implementations and inconsistent system behavior.ObjectiveWith the aim of avoiding faulty implementations and inconsistencies during system execution, this paper proposes both a formal and run-time model of contexts, context activation and context interaction.MethodAs a formal and computational basis, we introduce context Petri nets, a model based on Petri nets, which we found to\u00a0\u2026", "num_citations": "19\n", "authors": ["982"]}
{"title": "Research topics in composability\n", "abstract": " While composability is a much desired quality for software artefacts, there is no consensus whatsoever on what composability really is, nor on how it can be achieved. In this position paper we discuss three inhibitors of composability and hint at possible solutions. It is our conjecture that tackling these three problems is crucial to achieve true composability.", "num_citations": "18\n", "authors": ["982"]}
{"title": "Context Petri Nets: Enabling Consistent Composition of Context-dependent Behavior.\n", "abstract": " Nicol\u00e1s Cardozo, Jorge Vallejos, Sebasti\u00e1n Gonz\u00e1lez, Kim Mens, Theo D\u2019Hondt2 Page 1 Universit\u00e9 catholique de Louvain Vrije Universiteit Brussel 2 1 Context Petri Nets: Enabling consistent composition of context-dependent behavior 1 25-VI-2012 6th Workshop on Petri Nets and Software Engineering (PNSE) 2012 Nicol\u00e1s Cardozo, Jorge Vallejos, Sebasti\u00e1n Gonz\u00e1lez, Kim Mens, Theo D\u2019Hondt2 1,2 1 1 2 Monday 25 June 12 Page 2 2 Monday 25 June 12 Page 3 2 Context-oriented programming context-oriented programming context-aware systems contexts definition Monday 25 June 12 Page 4 2 Context-oriented programming Behavior consistency context-oriented programming consistency requirements context-aware systems contexts definition sources of inconsistency Monday 25 June 12 Page 5 2 Context-oriented programming Behavior consistency Context Petri Nets context-oriented programming \u2026", "num_citations": "17\n", "authors": ["982"]}
{"title": "Analyzing code evolution to uncover relations\n", "abstract": " This paper reports on evidence found of five possible relations (Plain Support, Mutual Support, Rejection, Common Refactoring, and Inclusion) among four bad smells (God Class, Long Method, Feature Envy, and Type Checking). We analyzed several releases of three open-source applications (16 for Log4j, 34 for Jmol, and 45 for JFreeChart) using four direct and two indirect metrics. This analysis uncovered correlations between three of these bad smells, namely, Feature Envy, Long Method, and God Class. The strongest correlation discovered was between Feature Envy and Long Method, followed by a mild correlation between Long Method and God Class, and between Feature Envy and God Class. These findings seem to provide initial evidence of the co-existence of bad smells and therefore, the need for bad smell removal plans to take into account these correlations in order to minimize code improvement\u00a0\u2026", "num_citations": "15\n", "authors": ["982"]}
{"title": "Feature-oriented programming and context-oriented programming: Comparing paradigm characteristics by example implementations\n", "abstract": " Software variability can be supported by providing adaptations on top of a program\u2019s core behavior. For defining and composing adaptations in a program, different paradigms have been proposed. Two of them are feature-oriented programming and context-oriented programming. This paper compares an exemplar implementation of each paradigm. For the comparison, a common case study is used in which we detail how adaptations are defined, expressed, and composed in each paradigm. Based on the case study, we uncover similarities and differences of each implementation, and derive a set of characteristics that identify each of them. The experiment shows several overlapping similarities between the two implementations, which is an indicator that there is a similar core set of characteristics for each paradigm. This finding brings the two seemingly disjoint research directions together, and can stimulate future research both in the direction of merging features and context as well as to improve the characteristic strengths of each paradigm.", "num_citations": "15\n", "authors": ["982"]}
{"title": "A context-oriented software architecture\n", "abstract": " Context-aware systems must manage the dynamic selection, activation, and execution of feature variants according to changing contexts, detected from data gathered from their surrounding execution environment. Many context-oriented programming languages focus only on the implementation level by providing appropriate language abstractions for implementing behavioural variations that can adapt dynamically to changing contexts. They often ignore or presuppose the existence of mechanisms to deal with earlier aspects such as the gathering of sensory input and context discovery. In this paper we propose a layered software architecture that reconciles all these aspects in a single implementation framework, which can be customized by application programmers into actual context-aware applications. This framework is currently being implemented in Ruby on top of a reimplementation of the Phenomenal Gem\u00a0\u2026", "num_citations": "14\n", "authors": ["982"]}
{"title": "Parsing Expression Grammars Made Practical\n", "abstract": " Parsing Expression Grammars (PEGs) define languages by specifying a recursive-descent parser that recognises them. The PEG formalism exhibits desirable properties, such as closure under composition, built-in disambiguation, unification of syntactic and lexical concerns, and closely matching programmer intuition. Unfortunately, state of the art PEG parsers struggle with left-recursive grammar rules, which are not supported by the original definition of the formalism and can lead to infinite recursion under naive implementations. Likewise, support for associativity and explicit precedence is spotty. To remedy these issues, we introduce Autumn, a general purpose PEG library that supports left-recursion, left and right associativity and precedence rules, and does so efficiently. Furthermore, we identify infix and postfix operators as a major source of inefficiency in left-recursive PEG parsers and show how to tackle this\u00a0\u2026", "num_citations": "14\n", "authors": ["982"]}
{"title": "Features on demand\n", "abstract": " This paper presents our vision of applications as feature clouds, providing software services that are composed dynamically from a set of available fine-grained features. Our feature cloud programming model realizing this vision, relies on context-oriented programming technology, enabling new or adapted features to be added to or removed from running applications on demand, according to contextual information, and taking into account feature dependencies. As a proof of concept, we implemented a prototype of an on-board car system running on a mobile device, using an instantiation of our feature clouds programming model for JavaScript.", "num_citations": "14\n", "authors": ["982"]}
{"title": "Orchestrating context-aware systems: A design perspective\n", "abstract": " The notion of context is becoming increasingly important for the development of applications that can adapt dynamically to their changing environment of use. The demand for dynamic behaviour variability and behaviour interoperation affects the whole engineering process of such applications, and it is yet unclear how different existing solutions fit in the process and what unsolved questions remain. In this paper we present our view on the design of context-aware applications, identifying some of the main aspects that need to be addressed from a software design perspective, and how existing approaches fit this global picture.", "num_citations": "13\n", "authors": ["982"]}
{"title": "Automated derivation of translators from annotated grammars\n", "abstract": " In this paper we propose a technique to automate the process of building translators between operations languages, a family of DSLs used to program satellite operations procedures. We exploit the similarities between those languages to semi-automatically build a transformation schema between them, through the use of annotated grammars. To improve the overall translation process even more, reducing its complexity, we also propose an intermediate representation common to all operations languages. We validate our approach by semi-automatically deriving translators between some operations languages, using a prototype tool which we implemented for that purpose.", "num_citations": "13\n", "authors": ["982"]}
{"title": "Correct, efficient, and tailored: The future of build systems\n", "abstract": " Build systems are used in every nontrivial software project. They contain knowledge of how software is built and provide tools to get it built as fast as possible. While being central to day-to-day productivity, they sometimes fail to deliver their promise of being correct, efficient, and tailored. This situation gets aggravated with huge code bases and fast-paced continuous-integration pipelines. This article surveys state-of-the-art techniques and algorithms that relegate the occasional inconsistent build, slow execution times, and boilerplate makefiles to another age. This article is part of a special issue on release engineering.", "num_citations": "12\n", "authors": ["982"]}
{"title": "Taming context-sensitive languages with principled stateful parsing\n", "abstract": " Historically, true context-sensitive parsing has seldom been applied to programming languages, due to its inherent complexity. However, many mainstream programming and markup languages (C, Haskell, Python, XML, and more) possess context-sensitive features. These features are traditionally handled with ad-hoc code (eg, custom lexers), outside of the scope of parsing theory.", "num_citations": "12\n", "authors": ["982"]}
{"title": "LogicObjects: enabling logic programming in Java through linguistic symbiosis\n", "abstract": " While object-oriented programming languages are good at modelling real-world concepts and benefit from rich libraries and developer tools, logic programming languages are well suited for declaratively solving computational problems that require knowledge reasoning. Non-trivial declarative applications could take advantage of the modelling features of object-oriented programming and of the rich software ecosystems surrounding them. Linguistic symbiosis is a common approach to enable complementary use of languages of different paradigms. However, the problem of concepts leaking from one paradigm to another often hinders the applicability of such approaches. This issue has mainly been reported for object-oriented languages participating in a symbiotic relation with a logic language. To address this issue, we present LogicObjects, a linguistic symbiosis framework for transparently and (semi\u00a0\u2026", "num_citations": "10\n", "authors": ["982"]}
{"title": "Using Annotated Grammars for the Automated Generation of Program Transformers\n", "abstract": " When confronted with a family of different domain-specific programming languages, each with their own particular syntax but providing essentially the same semantic constructs, often the need arises to transform programs between any of these languages. This is for example the case for the domain of satellite operation languages, where every vendor or mission control centre uses its own proprietary language. In previous work, we proposed a generic technique to automatically generate program transformers between given source and target languages. Our transformer generator tool takes as input a specification of the grammar of both source and target language, tagged with specific annotations that specify the corresponding language constructs in both languages. In this paper we further validate that approach by generating program transformers between two industrial satellite operations languages. We observe that the approach falls short for more complex mappings, where a single construct in one language does not correspond directly to a single construct in the other language. To address that problem, we propose using a dedicated pre-and post-processing library and language, in which a language engineer can define how to handle such more complex mappings.", "num_citations": "10\n", "authors": ["982"]}
{"title": "Uniting global and local context behavior with context petri nets\n", "abstract": " Context-oriented programming enables adaptation of systems to their execution environment. Behavioral adaptations are defined in the system and then associated to a context. Such adaptations are made available at runtime when their context is deemed more appropriate by the execution environment. Context activation is reified using two techniques. Global to all running threads in the system, or local to a particular thread of execution. Providing one technique or the other may hinder the adaptable capabilities of the system. This paper extends the context Petri nets model to unify global and local context behavior. Global and local context behavior are represented as multicolored tokens in context Petri nets, by assigning a color to each thread in the system. By means of context Petri nets, context-oriented systems can unambiguously adapt their behavior globally, or to a particular thread of execution.", "num_citations": "9\n", "authors": ["982"]}
{"title": "Safer context (de) activation: through the prompt-loyal strategy\n", "abstract": " Context-oriented programming languages provide language abstractions for the dynamic activation and deactivation of behavioral adaptations, based on the system's context of execution. As contexts are freely activated and deactivated, their associated behavior adaptations are added and removed to and from the system, which may break its consistency with respect to other available adaptations. To manage consistency between adaptations this paper introduces a model for the safe activation and deactivation of contexts. The model consists of two approaches, prompt-loyal for a delayed context (de) activation, and prompt for an immediate context (de) activation.", "num_citations": "9\n", "authors": ["982"]}
{"title": "Automated generation of program translation and verification tools using annotated grammars\n", "abstract": " Automatically generating program translators from source and target language specifications is a non-trivial problem. In this paper we focus on the problem of automating the process of building translators between operations languages, a family of DSLs used to program satellite operations procedures. We exploit their similarities to semi-automatically build transformation tools between these DSLs. The input to our method is a collection of annotated context-free grammars. To simplify the overall translation process even more, we also propose an intermediate representation common to all operations languages. Finally, we discuss how to enrich our annotated grammars model with more advanced semantic annotations to provide a verification system for the translation process. We validate our approach by semi-automatically deriving translators between some real world operations languages, using the prototype\u00a0\u2026", "num_citations": "9\n", "authors": ["982"]}
{"title": "Feature visualiser: An inspection tool for context-oriented programmers\n", "abstract": " As part of our ongoing research on context-oriented software technology, we propose a feature-oriented programming approach to context-oriented programming. Behavioural variations are implemented as fine-grained features that can be installed and activated dynamically, upon changing contexts. Given the highly dynamic nature of such a programming approach, and to cope with the complexity of many behavioural variations, that can depend on many varying contexts, developers could benefit from visual inspection tools to analyse what contexts and features are currently active, in which order they have been activated, and what code they adapt. We present a prototype of such a visualisation tool, and discuss potential improvements to that tool.", "num_citations": "8\n", "authors": ["982"]}
{"title": "Architectural aspects\n", "abstract": " We make a case for the relevance of the ideas of aspect-oriented programming at the architectural level. Traditional approaches to software architecture often assume that a software system exhibits a single architecture, of which the elements map more or less directly to implementation-level components. We claim that multiple architectural views, that may crosscut the implementation structure, can provide a better insight in the overall structure, organization and functionality of a software system than one single architecture which is often strongly biased towards the implementation structure of the system. The elements in such a crosscutting architectural view can be regarded as a kind of architectural aspects that describe how the element crosscuts the implementation structure.", "num_citations": "8\n", "authors": ["982"]}
{"title": "Multiple cross-cutting architectural views\n", "abstract": " With this position paper we want to make a case for the relevance of the ideas of multidimensional separation of concerns at the architectural level. Traditional approaches towards software architecture seem to take for granted that a software system exhibits a single software architecture, of which the elements map more or less directly to design or implementation-level components. We claim that multiple, potentially overlapping, cross-cutting architectural views can provide a much better insight in the overall structure, organization and functionality of a software system than one single architecture which is often strongly biased to the implementation structure of the system.", "num_citations": "8\n", "authors": ["982"]}
{"title": "Reuse Contracts: Managing Evolution in Adaptable Systems\n", "abstract": " Adaptable systems are often described as being composed of a persistent part that remains more or less stable throughout the evolution of the system and of more transient parts which are derived from the persistent part. Current research on adaptability seems to be biased towards adaptable systems of which the persistent part does not evolve at all. We argue that the issue of managing the evolution of the persistent part itself is not only a central issue in the practical application of adaptability, but is a key question in the understanding of adaptability: although changes to the persistent part occur only occasionally, most often these changes have a very large impact on the rest of the system; only very controlled changes guarantee that the rest of the system will remain more or less consistent. We propose to manage these changes by means of reuse contracts and reuse operators. Rather than having a template rigidly enforced by the builder of the adaptable system, with reuse contracts a reuser declares on which parts of the adaptable system he relies, what parts of the design he respects and what parts he violates. This enables evolution of the adaptable system, reuse of adaptations to different adaptable systems, and a more layered approach to adaptation.", "num_citations": "8\n", "authors": ["982"]}
{"title": "Implementation of a feature-based context-oriented programming language\n", "abstract": " We implemented a feature-based context-oriented programming language, which clearly separates the notion of contexts from the notion of features. Contexts reify particular situations occurring in the surrounding environment, to which a software system can adapt. Features reify the system's behaviour; they are the language components that describe the system's functionality at a fine-grained level. Contexts are mapped to features, such that, when certain contexts become active at run-time, the corresponding features get selected and activated, thus adapting the system's functionality to those particular contexts. In this paper we show the object-oriented architecture, design and implementation issues of such a feature-based context-oriented programming language, which we implemented on top of the Ruby programming language as an application framework for context-oriented programmers. An important part of\u00a0\u2026", "num_citations": "7\n", "authors": ["982"]}
{"title": "Managing the context interaction problem: A classification and design space of conflict resolution techniques in dynamically adaptive software systems\n", "abstract": " The context interaction problem occurs in dynamically adaptive software systems whenever adaptations to different contexts provide incompatible behaviour, as they were not foreseen to occur simultaneously. Several strategies have been proposed to resolve such conflicts when they occur. This paper surveys a number of such conflict resolution strategies, and proposes a design space in which to classify, compare, and explain the differences between them.", "num_citations": "6\n", "authors": ["982"]}
{"title": "Logicobjects: A linguistic symbiosis approach to bring the declarative power of prolog to java\n", "abstract": " Logic programming is well suited for declaratively solving computational problems that require knowledge representation and reasoning. Object-oriented languages, on the other hand, are well suited for modeling real-world concepts and profit from rich ecosystems developed around them, which are often missing from logic languages. For applications that require both the declarative power of logic programming and the rich modeling expressiveness and development environments offered by object-oriented languages, there is a need for reconciling both worlds. LogicObjects is our linguistic symbiosis framework for integrating Prolog within the Java language. It extends Java with annotations that allow Java programs to interact transparently and automatically with Prolog programs.", "num_citations": "6\n", "authors": ["982"]}
{"title": "Diagnosis and semi-automatic correction of detected design inconsistencies in source code\n", "abstract": " In order to alleviate design decay, different program design documentation techniques are used for the specification and detection of design inconsistencies in code. However, these design documentation techniques do not always provide support for the diagnosis and (semi-) automatic correction of such inconsistencies. In case they do, corrective solutions are typically targeted to a reduced set of pre-defined inconsistency problems, and they are not easily customizable to new kinds of consistency checks defined by a user. In particular, they cannot infer possible corrective actions to solve new user-defined inconsistency problems. In this paper, we present a technique for the diagnosis and (semi-) automatic correction of inconsistencies in the context of an existing tool for inconsistency management: IntensiVE. Our technique uses logic abductive reasoning to infer solutions to detected user-defined inconsistencies\u00a0\u2026", "num_citations": "6\n", "authors": ["982"]}
{"title": "Tool building on the shoulders of others\n", "abstract": " At the first International Workshop on Advanced Software Development Tools and Techniques, four emerging trends in academic tool building were evident. First, tools are increasingly constructed on the basis of external code, reusing, for instance, existing frameworks and integrated development environments. Second, researchers often choose dynamic languages such as Smalltalk to implement prototype tools. Third, Web-based tools are starting to incorporate Web 2.0 technologies to improve user interaction. Finally, increasing computational resources allow tools to tackle larger, real-world code bases.", "num_citations": "6\n", "authors": ["982"]}
{"title": "Appareil: a tool for building automated program translators using annotated grammars\n", "abstract": " Operations languages are used to write spacecraft operations procedures. The APPAREIL tool automates the process of generating program translators between operations languages, from a specification of their language grammar annotated with extra information. From these annotated grammars the tool automatically produces a partial translator that covers most of the translation. This translator needs to be augmented manually with specific transformations, to deal with the more complicated cases. To get more confidence on the correctness of the translation, the tool offers a control-flow equivalence verification module.", "num_citations": "6\n", "authors": ["982"]}
{"title": "Academic software development tools and techniques\n", "abstract": " The objective of the 1st International Workshop on Advanced Software Development Tools and Techniques (WASDeTT-1) was to provide interested researchers with a forum to share their tool building experiences and to explore how tools can be built more effectively and efficiently. The theme for this workshop did focus on tools that target object-oriented languages and that are implemented with object-oriented languages.               This workshop report provides a brief overview of the presented tools and of the discussions that took place. The presented tools, 15 in total, covered a broad range of functionalities, among them: refactoring, modeling, behavioral specification, static and dynamic program checking, user interface composition, and program understanding. The discussion during the workshop centered around the following topics: language independent tools, tool building in an industrial context\u00a0\u2026", "num_citations": "6\n", "authors": ["982"]}
{"title": "Building composable aspect-specific languages\n", "abstract": " Building composable aspect-specific languages \u2014 Vrije Universiteit Brussel Skip to main navigation Skip to search Skip to main content Vrije Universiteit Brussel Logo Help & FAQ English Nederlands Home Research Units Profiles Projects Research output Activities Equipment Prizes Press / Media Student theses Impacts Search by expertise, name or affiliation Building composable aspect-specific languages Johan Brichau, Kim Mens, Kris De Volder Vrije Universiteit Brussel Research output: Chapter in Book/Report/Conference proceeding \u203a Conference paper 16 Citations (Scopus) Overview Original language English Title of host publication Proc. Int'l Conf. Generative Programming and Component Engineering, Lecture Notes in Computer Science 2487: 110-127, Springer-Verlag, 2002 Publication status Published - 2002 Event Unknown - Duration: 1 Jan 2002 \u2192 \u2026 Conference Conference Unknown Period 1/01/\u2026", "num_citations": "6\n", "authors": ["982"]}
{"title": "Reuse contracts: making systematic reuse a standard practice\n", "abstract": " While object-orientation has had a large impact on the popularisation of reuse, reuse in OO is mostly ad hoc and thus lessons can be learned from the work on systematic reuse. On the other hand, the emphasis of object-orientation on iterative development can help in reducing the large up-front investments that are typically associated with systematic reuse. We claim that systematic reuse needs to be reconciled with iterative development in order to make reuse a standard practice. Such a reuse methodology must emphasise the co-operation between asset providers and asset reusers to control how assets reused, how assets reused and how changes propagate from assets to applications during iterative development. We propose reuse contracts as the basis for such a methodology.", "num_citations": "6\n", "authors": ["982"]}
{"title": "Clones and Macro co-changes\n", "abstract": " Ideally, any change that modifies the similar parts of a cloned code snippet should be propagated to all its duplicates. In practice however, consistent propagation of changes in clones does not always happen. Current evidence indicates that clone families have a 50% chance of having consistent changes. This paper measures cloning and co-changes at file level as a proxy to assess the frequency of consistent changes. Given that changes to a clone group are not necessarily propagated in the same commit transaction (ie, late propagations), our analysis uses macro co-changes instead of the traditional definition of co-changes. Macro changes group bursts of changes that are closer among themselves than to other changes, regardless of author or message. Then, macro co-changes are sets of files that change in the same macro changes. Each cloned file is tagged depending on whether any of the files with which it macro co-changes is cloned with it (during the macro change) or not. Contrary to previous results, we discovered that most of the cloned files macro co-change only with files with which they share clones. Thus providing evidence that macro changes are appropriate to study the conjecture of clones requiring co-changes, and indicating that consistent changes might be the norm in cloned code.", "num_citations": "5\n", "authors": ["982"]}
{"title": "JPC: A Library for Modularising Inter-Language Conversion Concerns between Java and Prolog\n", "abstract": " The number of approaches existing to enable a smooth interaction between Java and Prolog programs testifies the growing interest in solutions that take advantage of the strengths of both languages. Most of these approaches provide limited support to allow programmers to customise how a Prolog artefact should be reified in the Java world, or how to reason about Java objects on the Prolog side. The burden of creating a convenient mapping between inter-language artefacts is left, however, to the user of the library. This is an error-prone task since the appropriate mapping often depends on the particular context of usage. Although some libraries alleviate this problem by providing higher-level abstractions to deal with the complexity of converting programming artefacts between the two languages, these libraries themselves are difficult to implement and evolve. This is caused by the lack of appropriate underlying building blocks for modularising and managing Java-Prolog conversion constructs. We therefore introduce a library intending to serve as a portable development tool both for programmers willing to modularise context-dependent conversion constructs in their Java-Prolog systems, and for architects implementing frameworks providing higherlevel abstractions for better interoperability between these two languages.", "num_citations": "5\n", "authors": ["982"]}
{"title": "Transactional contexts: Harnessing the power of context-oriented reflection\n", "abstract": " The emerging field of context-oriented programming gives a predominant role to the execution context of applications, and advocates the use of dedicated mechanisms to allow the elegant expression of behavioural adaptations to such context. With suitable reflective facilities, language semantics can be adapted to context by reusing the same context-oriented mechanisms that allow base-level adaptability. This kind of meta-level adaptability, in which the computation model itself becomes adaptable to context, gives rise to context-oriented computational reflection. To explore this idea, we set out to implement a simple software transactional memory system that exploits meta-level adaptability by regarding transactions as contexts, and adapting fundamental system behaviour to such transactional contexts. The implementation is succinct and non-intrusive, giving us an indication of the power lying at the crossroads of\u00a0\u2026", "num_citations": "5\n", "authors": ["982"]}
{"title": "PALTA: Peer-to-peer AdaptabLe Topology for Ambient intelligence\n", "abstract": " Many ambient intelligence (AmI) scenarios fit perfectly for auto-generated distributed networks, but they assume the existence of good enough network topology organizing the connected devices. AmI scenarios need to handle an unanticipated number of participants and inappropriate distributed network topologies can affect the network's efficiency by making it unstable and hard to manage. This paper introduces PALTA, a self-adapting hybrid topology capable of dynamically adjusting its configuration by using a combination of existing topologies. PALTA allows the incremental construction of self-maintained distributed networks which take advantage of the current network state.", "num_citations": "5\n", "authors": ["982"]}
{"title": "Issues and problems in tests and operations languages translation\n", "abstract": " Satellite operators perform their satellite operations through the use of operations languages, which encapsulate their experience (often referred to as operations knowledge). These languages are dependent on the underlying control system, and in many cases there are multiple variants of any given language for a particular mission or satellite type.Many operators are interested in decoupling this operations knowledge from a particular control system and its corresponding language. There are various reasons for this. Either they wish to migrate from a given control system supporting a given language, to another control system supporting another language. Or a satellite manufacturer may deliver operational (or test) procedures in a language that is supported by the manufacturing test system or EGSE, but which does not support the operator's control system. In either of these cases, a translation of the procedures to another language is required. For these reasons, the problem of translating procedures to either transfer operations knowledge or to migrate to different systems is a relevant and important problem in space industry. Rhea has been studying this problem for a number of years and has developed specific solutions for specific languages. However, the ability to automatically translate between or analyse programs written in different operations languages is the end goal for such a problem. Unfortunately, building such advanced generic program analysis and translation tools, is a non-trivial task for various reasons. This paper highlights some of the issues, problems and pitfalls we have encountered with building such tools and their\u00a0\u2026", "num_citations": "5\n", "authors": ["982"]}
{"title": "Explicit support for software development styles throughout the complete life cycle\n", "abstract": " Throughout its entire life cycle software development is subject to many rules constraining and guiding construction of software systems. Examples are best-practice patterns, idioms, coding conventions, design guidelines, architectural patterns, etc. Although such regulations are widely used, their usage is currently implicit or ad-hoc, and most software development environments do not explicitly support them. We present an approach to declare explicitly software development styles in an open declarative system that allows querying, conformance checking and enforcement of these declarations on the source code. We validate the approach by expressing and supporting several software development styles in a real-world case.", "num_citations": "5\n", "authors": ["982"]}
{"title": "Declarative meta programming\n", "abstract": " The software development process deals with many phases, such as: analysis, design, coding, maintenance, evolution, etc... Adopting the classic approach to software engineering (eg, the waterfall model), all these phases are performed separately, where the results of one phase serve as a basis for the start of another phase (eg, designs are used to start the implementation). But in most cases, phases that occur at a later time in the software development process will require to make changes to the results of earlier phases (feedback). For example, problems that only become apparant during the implementation phase, may require changes to the design. Or even worse: software programmers can deviate from the original design without notifying the designers or maybe even without knowing that they do so. But even if programmers are aware about the impact of their change to the design, updating the design may be a time-consuming process and therefore, they might not do it. All these factors lead to enormeous problems in the long run because the entire design documentation of a software artifact is no longer up-to-date with the actual implementation.Our research on declarative meta-programming (DMP) investigates how this technique can be used to build state-of-the-art software development support tools that help overcome these problems. The aim is to try to capture and formally express the interaction between the higher phases of software development (design, analysis, etc...) and the actual implementation level. To express this interaction between the program code and the (higher-level) documentation of a software system, we believe\u00a0\u2026", "num_citations": "5\n", "authors": ["982"]}
{"title": "Customisable Handling of Java References in Prolog Programs\n", "abstract": " Integration techniques for combining programs written in distinct language paradigms facilitate the implementation of specialised modules in the best language for their task. In the case of Java-Prolog integration, a known problem is the proper representation of references to Java objects on the Prolog side. To solve it adequately, multiple dimensions should be considered, including reference representation, opacity of the representation, identity preservation, reference life span, and scope of the inter-language conversion policies. This paper presents an approach that addresses all these dimensions, generalising and building on existing representation patterns of foreign references in Prolog, and taking inspiration from similar inter-language representation techniques found in other domains. Our approach maximises portability by making few assumptions about the Prolog engine interacting with Java (e.g., embedded or executed as an external process). We validate our work by extending JPC, an open-source integration library, with features supporting our approach. Our JPC library is currently compatible with three different open source Prolog engines (SWI, YAP} and XSB) by means of drivers. To appear in Theory and Practice of Logic Programming (TPLP).", "num_citations": "4\n", "authors": ["982"]}
{"title": "Typing dynamic inheritance\n", "abstract": " Recent developments in subjectivity, composition technology and novel prototype-based languages demonstrate that dynamic object extension is an essential feature in modern objectorientation. But the total absence of static type systems for dynamic object extension is a major obstacle for its adoption. The key principle of type-safe dynamic object extension is a trade-off between possible assignments and possible extensions. We describe a static type system using specialisation interfaces to refine the notion of subtyping and to limit dynamic extension. We furthermore argue that the introduction of specialisation interfaces in the system opens up a lot of new perspectives in software engineering in general. The type system is proven to be consistent and complete.", "num_citations": "4\n", "authors": ["982"]}
{"title": "Static Typing of Dynamic Inheritance\n", "abstract": " Recent developments in subjectivity, composition technology and novel prototype-based languages demonstrate that dynamic object extension is an essential feature in modern object-orientation. The total absence of static type systems for dynamic object extension is a major obstacle for its adoption. We describe a static type system using specialisation interfaces with a trade-off between possible assignments and possible extensions as key principle. We furthermore argue that the introduction of specialisation interfaces in the system opens up a lot of new perspectives in software engineering in general.", "num_citations": "4\n", "authors": ["982"]}
{"title": "Enjeux dans la cr\u00e9ation d'une communaut\u00e9 d'enseignants engag\u00e9s dans l'apprentissage de l'informatique\n", "abstract": " L\u2019accompagnement des enseignants du primaire et du secondaire en charge de l\u2019enseignement de l\u2019informatique est un enjeu majeur dans l\u2019int\u00e9gration effective de l\u2019enseignement de l\u2019informatique \u00e0 l\u2019\u00e9cole. La formation initiale et continue doit pouvoir permettre d\u2019accompagner les enseignants dans leur propre apprentissage de l\u2019informatique et les aider \u00e0 d\u00e9velopper leurs connaissances et leurs strat\u00e9gies p\u00e9dagogiques pour cet enseignement de l\u2019informatique. Dans ce contexte, l\u2019entraide et le d\u00e9veloppement d\u2019un sentiment d\u2019auto-efficacit\u00e9 doit permettre de s\u00e9curiser les enseignants int\u00e9grants des activit\u00e9s d\u2019apprentissage de l\u2019informatique \u00e0 l\u2019\u00e9cole. \u00c0 cette fin, dans le cadre du projet Erasmus+ Communaut\u00e9 d\u2019Apprentissage de l\u2019Informatique (CAI), nous visons \u00e0 d\u00e9velopper une Communaut\u00e9 de Pratique (CoP) qui puissent permettre le partage, mais aussi le d\u00e9veloppement, de pratiques et de ressources p\u00e9dagogiques co-construites autour de l\u2019enseignement de l\u2019informatique \u00e0 l\u2019\u00e9cole. Nous d\u00e9crivons ici les enjeux de la cr\u00e9ation de cette CoP et les enjeux pour son d\u00e9veloppement et son \u00e9valuation.", "num_citations": "3\n", "authors": ["982"]}
{"title": "Dynamic visualisation of features and contexts for context-oriented programmers\n", "abstract": " Context-oriented programming languages allow programmers to develop context-aware systems that can adapt their behaviour dynamically upon changing contexts. Due to the highly dynamic nature of such systems and the many possible combinations of contexts to which such systems may adapt, developing such systems is hard. Feature-based context-oriented programming helps tackle part of this complexity by modelling the possible contexts, and the different behavioural adaptations they can trigger, as separate feature models. Tools can also help developers address the underlying complexity of this approach. This paper presents a visualisation tool that is intricately related to the underlying architecture of a feature-based context-oriented programming language, and the context and feature models it uses. The visualisation confronts two hierarchical models (a context model and a feature model) and\u00a0\u2026", "num_citations": "3\n", "authors": ["982"]}
{"title": "Reconciling context-oriented programming and feature modeling\n", "abstract": " The advent of connected devices, such as smart-phones, enabled the con-ception of several of software applications that are yet more intelligent. At the moment, the information in these applications is mainly encoded by individuals, but we can imagine in the near future that sensors may produce and provide it without any human intervention. With nowadays tools, it is very complicated to design smart software applications that are aware of their surrounding environment: program-mers must handle all existing combinations of the contextual information at once, which increases the complexity of the program exponentially with the amount of information that is considered by these applications. Some software engineering domains aim to ease the development of such applications, such as Feature-Oriented Software Development and Context-Oriented Programming. Although they have been studied in isolation and use different approaches, they seem to solve similar problems. Still, few work has been performed to reconcile ideas from both these domains. The goal of this thesis is to reconcile these two domains, in order to ease the development of applications with highly dynamic behavioural changes. To do so, a new formalism is introduced, so as to design a framework to build these applications. The framework is tested with a self-assembled context-aware application, an Emergency Response System that helps users in case of emergency.", "num_citations": "3\n", "authors": ["982"]}
{"title": "Bringing incremental builds to continuous integration\n", "abstract": " Incremental builds are commonly used to speed up the editcompile-test loop during program development. By updating only the required parts of a system, build systems can shorten the compilation phase by orders of magnitude. While this technique is commonly used for local builds, it is seldom enabled during continuous integration. Current build system do not offer strong correctness properties on incremental builds. In continuous integration setups, it is therefore difficult to achieve both correctness and efficiency simultaneously. Facing this choice, release engineers tend to favor correct builds over optimized builds. In this article, we show that it is possible to obtain both incremental and correct builds. We start by showing that incremental builds are a desirable optimization in continuous integration environments. Different reasons that prevent release engineers to enable incremental builds in practice are discussed. From these, we derive requirements to be met by future build systems to support incremental continuous integration. Whenever possible, we illustrate shortcomings of build systems with insights from current research and industry efforts in new build systems. We also list existing projects that could be combined into a complete tool supporting efficient and correct incremental compilation in continuous integration environments. Ultimately, this paper defines a new research direction at the intersection of build systems and continuous integration.", "num_citations": "3\n", "authors": ["982"]}
{"title": "Guest editors\u2019 introduction to the 4th issue of Experimental Software and Toolkits (EST-4)\n", "abstract": " Experimental software and toolkits play a crucial role in computer science. Elsevier\u2019s Science of Computer Programming special issues on Experimental Software and Toolkits (EST) provide a means for academic tool builders to get more visibility and credit for their work, by publishing a paper along with the corresponding system in a peer-reviewed journal. Typically, tools are presented from both a user and a developer perspective, addressing tool-building issues such as architecture and design, requirements, methodologies and process aspects. This is already the fourth edition of EST with no less than 17 published systems covering application areas ranging from software analysis and visualization to teaching and software development support.", "num_citations": "3\n", "authors": ["982"]}
{"title": "Towards a Unifying Conceptual Framework for Inconsistency Management Approaches\n", "abstract": " The problem of managing inconsistencies within and between models is omnipresent in software engineering. Over the years many different inconsistency management approaches have been proposed by the research community. Because of their large diversity of backgrounds and the diversity of models being considered, it is difficult to pinpoint what these approaches have in common and what not. As a result, researchers encounter difficulties when positioning and comparing their work with existing state-of-the-art, or when collaborating on or combining different approaches. Also, end-users have a hard time making informed decisions to select the most appropriate approach. To address these problems, we present a unifying conceptual framework of definitions and terminology, independent of any concrete inconsistency management approach or (modelling) language. The contribution is a formal framework providing a common understanding of what (in) consistency means, what inconsistency management involves and what assumptions are commonly made by existing approaches. The formalisation is also illustrated with four instantiations taken from different research fields.", "num_citations": "3\n", "authors": ["982"]}
{"title": "A Self-Adaptable Network Topology for Ambient Intelligence\n", "abstract": " Ambient Intelligence scenarios can be deployed even when the environment lacks of a underlying network infrastructure. This can be done using distributed ad-hoc networks. Ambient Intelligence applications can be highly variable and networks can have an unanticipated number of members. Inappropriate distributed network topologies can lead to unstable and inefficient communication. We propose PALTA, a decentralized and self-adaptable network topology. We use feedback loops to model its self-adaptable behaviour and we evaluate its performance using different simulations and measurements. PALTA allows the construction of distributed networks using self-management techniques and maintaining a good overall performance on the network communication.", "num_citations": "3\n", "authors": ["982"]}
{"title": "Evolutionary Problems in Aspect-Oriented Software Development\n", "abstract": " INGI2252 : Mesures et maintenance Page 1 Evolutionary Problems in Aspect-Oriented Software Development Pr. Kim Mens Dr. Tom Tourw\u00e9 Inspired by and based on: K. MENS & T. TOURWE. Evolution Issues in Aspect-Oriented Programming. Chapter in book on \"Software Evolution\", edited by T. Mens & S. Demeyer, pp. 197\u2013224. In press. Springer, 2008. 1 Page 2 Goal \u25a0 Identify some \u201cevolution issues\u201d in AOSD \u2013 challenges that adopters of AO technology may face \u2013 research problems remaining to be explored \u25a0 Three main categories: \u2013 aspect exploration : discovering potential aspects \u2013 aspect extraction : migrating to AO solution \u2013 aspect evolution : maintaining and evolution of AO system LEGACY system LEGACY system BASE system AspectAspect Aspect Aspect Exploration Aspect Extraction Aspect Evolution 2 2 Page 3 3 Aspect Weaver woven output code The AOP Idea core application functionality \u2026", "num_citations": "3\n", "authors": ["982"]}
{"title": "Conceptual code mining-mining for sourcecode regularities with formal concept analysis\n", "abstract": " Understanding the conceptual structure of large software systems, whether it is for software understanding or reengineering purposes, is a nontrivial task. In particular, knowing where to start the comprehension process is more difficult than it seems, especially when a system is large and complex and time is scarce. We propose an approach to mine a system\u2019s source code automatically and efficiently for relevant concepts of interest, which we refer to as source-code regularities: what concerns are addressed in the code, what patterns, programming idioms and conventions have been adopted, and where and how they are implemented. We use formal concept analysis to do the actual source-code mining, and then filter, classify and combine the results to present them in a format that is more convenient to a software engineer. We applied a prototype tool that implements this approach to several small to medium-sized Smalltalk applications. For each of these, the tool discovered several interesting source-code regularities. Although the tool and approach can still be improved in many ways, the tool does already provide useful results when having a first contact with a system. The obtained results also illustrate the relevance and feasibility of using formal concept analysis as a technique for source code mining.", "num_citations": "3\n", "authors": ["982"]}
{"title": "Formalising Operations on ACIDs and Their Interactions\n", "abstract": " Formalising Operations on ACIDs and Their Interactions \u2014 Vrije Universiteit Brussel Skip to main navigation Skip to search Skip to main content Vrije Universiteit Brussel Logo Help & FAQ English Nederlands Home Research Units Profiles Projects Research output Activities Equipment Prizes Press / Media Student theses Impacts Search by expertise, name or affiliation Formalising Operations on ACIDs and Their Interactions Kim Mens, Carine Lucas, Patrick Steyaert Vrije Universiteit Brussel Research output: Book/Report \u203a Other report \u203a Research Overview Original language English Publisher Tech. Report vub-prog-tr-96-03 Publication status Published - 1996 Bibliographical note Tech. Report vub-prog-tr-96-03 Access to Document ftp://prog.vub.ac.be/tech_report/1996/vub-prog-tr-96-03.pdf Cite this APA Author BIBTEX Harvard Standard RIS Vancouver Mens, K., Lucas, C., & Steyaert, P. (1996). Formalising \u2026", "num_citations": "3\n", "authors": ["982"]}
{"title": "Tutors\u2019 Experiences in Using Explicit Strategies in a Problem-Based Learning Introductory Programming Course\n", "abstract": " In programming education, explicit strategies are gaining traction. The reason for this study was to improve an introductory programming course based on a problem-based methodology, by using more explicit programming strategies. After analysing a previous run of this course for first year undergraduate students, we concluded that such strategies could improve learning transfer for students across the different weeks of the semester. We introduced four instructional strategies to tutors with close to no pedagogical background: explicit tracing, subgoal labeled worked examples, Parsons problems and explicit problem solving. These explicit programming strategies aim to decrease cognitive load. Tutors tested these four strategies in the course. Our goal was to explore how tutors could benefit in their tutoring from explicit strategies. Interviews with the tutors show that the easiest and most effective of the tested strategies were best used. For the more elaborate strategies, more time should be devoted to explain and model them or they can be misunderstood and misapplied. We conclude that four criteria are key to successfully using an explicit strategy: easy to understand, straightforward to apply, useful on the long term and supported by literature.", "num_citations": "2\n", "authors": ["982"]}
{"title": "Improving a Software Modernisation Process by Differencing Migration Logs\n", "abstract": " Software written in legacy programming languages is notoriously ubiquitous and often comprises business-critical portions of codebases and portfolios. Some of these languages, like COBOL, mature, grow, and acquire modern tooling that makes maintenance activities more bearable. Others, like many fourth generation languages (4GLs), stagnate and become obsolete and unmaintained, which first urges and eventually forces migrating to other languages, if the software needs to be kept in production. In this paper, we dissect a software modernisation process endorsed by Raincode Labs, utilised in particular to migrate software from a 4GL called PACBASE, to pure COBOL. Having migrated upwards of 500 MLOC of production code to COBOL using this process, the company has ample experience with this process. Nevertheless, we identify some improvement points and explain the technical side of a\u00a0\u2026", "num_citations": "2\n", "authors": ["982"]}
{"title": "JPC: A library for categorising and applying inter-language conversions between Java and Prolog\n", "abstract": " The number of approaches existing to enable a smooth interaction between Java and Prolog programs testifies the growing interest in solutions that combine the strengths of both languages. Most of these approaches provide limited support to allow programmers to customise how Prolog artefacts should be reified in the Java world, or how to reason about Java objects on the Prolog side. This is an error-prone task since often a considerable amount of mappings must be developed and organised. Furthermore, appropriate mappings may depend on the particular context in which a conversion is accomplished. Although some libraries alleviate this problem by providing higher-level abstractions to deal with the complexity of custom conversions between artefacts of the two languages, such libraries are difficult to implement and evolve, because of a lack of appropriate underlying building blocks for encapsulating\u00a0\u2026", "num_citations": "2\n", "authors": ["982"]}
{"title": "Software Maintenance and Evolution\n", "abstract": " This set of slides, covering the topics of Software Maintenance and Evolution, are the course lectures of a course \u2028LINGI2252 \u201cSoftware Maintenance and Evolution\u201d, given by Prof. Kim Mens at UCLouvain, Belgium", "num_citations": "2\n", "authors": ["982"]}
{"title": "Models for the consistent interaction of adaptations in self-adaptive systems\n", "abstract": " Self-adaptive systems enable the run-time modification, or dynamic adaptation, of a software system in order to offer the most appropriate behavior of the system according to its context of execution and the situations of its surrounding environment. Depending on the situations currently at hand, multiple and varied adaptations may affect the original behavior of a software system simultaneously. This may lead to accidental behavioral inconsistencies if not all possible interactions with other adaptations were anticipated. The behavioral inconsistencies problem becomes even more acute if adaptations are unknown beforehand, for example, when new adaptations are incorporated to the system on the fly. Self-adaptive systems must therefore provide a means to arbitrate interactions between adaptions at run time, to ensure that there will be no inconsistencies in the system\u2019s behavior as adaptations are\u00a0\u2026", "num_citations": "2\n", "authors": ["982"]}
{"title": "Automatic Integration of Hybrid Java-Prolog Entities with LogicObjects\n", "abstract": " 2. Pre-Defined Conversions 3. Type-Guided Conversions 4. Custom Conversions 3. Automatic Integration of Hybrid Entities with LogicObjects 1. Integration from the Java Perspective 2. Integration from the Prolog Perspective 4. Conclusions", "num_citations": "2\n", "authors": ["982"]}
{"title": "Co-occurring code critics\n", "abstract": " Code critics are controversial implementation choices (such as bad smells or code smells) but at a higher level of detail. Code critics are a recommendation facility of the Smalltalk-Pharo IDE. They aim to achieve standard idioms which allow for a better performance or for a better use of object-oriented building mechanisms. Code critics can be identified at the method-or class-level. We are analyzing in several applications which code critics tend to occur in the same source code entity to see to what extent it is possible to identify controversial implementation choices at a higher level of abstraction.", "num_citations": "2\n", "authors": ["982"]}
{"title": "Context Petri Nets Definition and Manipulation\n", "abstract": " Context-oriented programming languages provide dedicated programming abstractions to define behavioral adaptations and means to recompose them dynamically according to sensed context changes. Additionally, some of these languages have proposed abstractions to explicitly define dependency relations between adaptations. Such dependency relations enable programmers to specify allowed and disallowed interactions between behavioral adaptations at a high abstraction level. In this paper, we explore Petri nets as an underlying formalism to model contextdependent adaptations and their dependencies. Petri nets offer a precise notation and semantics for behavioral adaptations and the dependency relations between them. Even more, Petri nets can be used as an underlying representation to manage dependency relations, and activations and deactivations of behavioral adaptations at runtime. We illustrate the ideas through the context-oriented programming language Subjective-C. 1", "num_citations": "2\n", "authors": ["982"]}
{"title": "Language engineering for mobile software\n", "abstract": " Mobile systems offer the possibility of delivering software services that tightly match user needs, thanks to their availability right at the moment and place where they are needed, and their ability to take advantage of local resources and self-adapt to their environment of use. Alas, writing software for mobile systems is not an easy endeavour. Mobile software construction imposes a number challenges that render existing programming technology insufficient to write such software conveniently. To improve this situation, the authors have taken a language engineering approach. In this chapter they identify the main challenges encountered in mobile software construction and the requirements that rise in the design of programming languages. By way of illustration, the authors present the result of their language engineering experiments\u2014four programming models to ease the construction of software that can cope\u00a0\u2026", "num_citations": "2\n", "authors": ["982"]}
{"title": "Guest editors' introduction to the 3rd issue of Experimental Software and Toolkits (EST): A special issue on Academic Software Development Tools and Techniques (WASDeTT 2008)\n", "abstract": " Introduction. This is already the third special issue on Experimental Software and Toolkits (EST) of Elsevier's Science of Computer Programming. As such it has truly become a forum where academic software engineers can share their systems with fellow researchers, so that others can build on their research and tools, and reproduce similar or conduct other experiments. EST not only offers a means to authors to publish their systems and get the academic credits, it also offers a way of archiving the developed systems for the future. This is an improvement over conference and workshop tool demonstrations, where the system can be seen in action but typically not downloaded, tested or used by others. It differs from publishing the system in the open source community, because independent referees from the academic community has performed a quality review on the published systems and papers.", "num_citations": "2\n", "authors": ["982"]}
{"title": "Codifying structural regularities of object-oriented programs\n", "abstract": " Well-written object-oriented programs exhibit many structural regularities ranging from naming and coding conventions, through design patterns, to architectural constraints. Tools and environments that aid a software developer in constructing, understanding or modifying object-oriented programs should be able to reason about and manipulate such regularities. We codify structural regularities of object-oriented programs as predicates in a logic meta language on top of Smalltalk. These predicates can be used not only to enforce regularities in the software, but also to search the source code, detect violations against certain regularities and to generate code fragments that exhibit a certain regularity. On the basis of two case studies we illustrate how the use of such predicates supports a developer in various activities throughout the software development life-cycle.", "num_citations": "2\n", "authors": ["982"]}
{"title": "Reverse engineering aspectual views using formal concept analysis\n", "abstract": " In this position paper, we report on an initial experiment using the technique of formal concept analysis for reverse engineering aspectual views from object-oriented source code. An aspectual view is a set of source code entities, such as class hierarchies, classes and methods, that are structurally related in some way, and often crosscut a particular application. Initially, we follow a lightweight approach, where we only consider the names of classes and methods. This simplistic technique already results in the discovery of interesting and meaningful aspectual views, leaving us confident that more complex approaches will perform even better, and should be studied in the future.", "num_citations": "2\n", "authors": ["982"]}
{"title": "Supporting Software Maintenance and Evolution with Intentional source-code Views1\n", "abstract": " We propose the abstraction of intentional source-code views to codify essential information, about the architecture and implementation of a software system, that an engineer needs to better understand, maintain and evolve the system. We report on some experiments that investigate the usefulness of intentional source-code views in a variety of software maintenance, evolution and reengineering tasks, and present the results of these experiments in a pattern-like format.", "num_citations": "2\n", "authors": ["982"]}
{"title": "Towards an Explicit Intentional Semantics for Evolving Software\n", "abstract": " The subject of my PhD work is the study of software engineers\u2019 intentions and the importance of using the information provided by such intentions during the software engineering (SE) process. More specifically, we will study how automated reasoning about explicit software intentions can facilitate many software engineering activities, and software evolution in particular.", "num_citations": "2\n", "authors": ["982"]}
{"title": "Open Source RFID race timing system\n", "abstract": " This dissertation explains all the steps we went through to model and develop a race timing system for Game of Trails, a non-profit organization. Game of Trails organizes each year two races, which have the particularities of being muddy and having several obstacles scattered along the course. In fact, Game of Trails already had an arrangement with a company for a race timing system but it had a few drawbacks such as being expensive and giving the final results a few days after the race instead of the same day. Given those drawbacks, they wanted to change and have their own race timing system. One important requirement of this new system is the display of the results in real-time. More precisely, they wanted that anyone could see the results of the race, updated in real-time, on a website. To build this new race timing system, we first had to decide how the system would detect the runners at the finish line. Multiple technologies could be used for this and we present in this dissertation what we believe are the most interesting ones. To name them, those are QR Code, GPS, NFC and RFID. After comparing them, we decided to use UHF RFID (Ultra High Frequency-Radio Frequency IDentification). It consists of radio waves of frequency 860Mhz to 865Mhz and allows to detect tags at a distance of maximum 12 meters with the help of antennas. Moreover, the tags are waterproof. However, it is quite expensive. Afterwards, we did the requirements and modeled the race timing system. We show what are the different use cases and what are the expected data models, but also how the real-time...", "num_citations": "2\n", "authors": ["982"]}
{"title": "Source Code: un catalogue open source d\u2019exercices informatiques\n", "abstract": " De nos jours, l\u2019informatique se r\u00e9v\u00e8le \u00eatre une discipline prometteuse enseign\u00e9e par un nombre grandissant d\u2019institutions p\u00e9dagogiques. Toutefois, l\u2019obtention d\u2019exercices de programmation qualitatifs et vari\u00e9s constitue un probl\u00e8me majeur, car cela implique l\u2019existence d\u2019une plateforme fiable m\u00ealant confort de recherche et r\u00e9f\u00e9rencement coh\u00e9rent des ressources informatiques. Contrairement \u00e0 d\u2019autres domaines, il ne semble pas exister un consensus suffisamment partag\u00e9 sur ce type de ressource. En effet, une grande partie de la probl\u00e9matique est occult\u00e9e par des plateformes existantes: comment r\u00e9f\u00e9rencer/partager/rechercher des ressources informatiques provenant de diverses sources? Dans ce m\u00e9moire, nous allons pr\u00e9senter notre solution pour pallier ce probl\u00e8me gr\u00e2ce \u00e0 une plateforme bas\u00e9e sur un format novateur et ouvert. Ce travail consiste en 3 \u00e9tapes importantes: une phase de recherche et d\u2019inventaire constituant les besoins cl\u00e9s de l\u2019application, suivi du d\u00e9veloppement de celle-ci et une phase d\u2019analyse critique impliquant aussi bien une validation interne qu\u2019externe afin d\u2019en attester sa coh\u00e9rence et son utilit\u00e9. \u00c0 d\u00e9faut d\u2019\u00eatre reprise par une communaut\u00e9 pour en continuer le d\u00e9veloppement, nous esp\u00e9rons que notre approche open source puisse nourrir des r\u00e9flexions ult\u00e9rieures autour de cette probl\u00e9matique.", "num_citations": "1\n", "authors": ["982"]}
{"title": "A new syntax for Oz\n", "abstract": " The premise of this thesis is to\" create, elaborate and motivate a new syntax for an education-oriented programming system named\" Oz\"\". So from the conception/researches, passing by multiple debates and analysis over various programming languages, to the implemention/realisation and usage of the new syntax, nothing will shall left aside.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Exploration d\u2019une application adaptative pour \u00e9valuer les comp\u00e9tences en informatique\n", "abstract": " (fre) L\u2019informatique est devenu un domaine omnipr\u00e9sent dans notre monde et ses m\u00e9thodes d\u2019apprentissage sont multiples, diverses et vari\u00e9es. De nombreux cours en ligne sont propos\u00e9s en libre acc\u00e8s et tout un chacun peut en suivre afin d\u2019acqu\u00e9rir de nouvelles connaissances. Lorsque l\u2019on suit un cours en ligne, on peut se retrouver livr\u00e9 \u00e0 soi-m\u00eame et perdu. La mati\u00e8re et les exercices pouvant \u00eatre tous accessibles, on ne sait pas forc\u00e9ment par quel chapitre commencer ou l\u2019on ne conna\u00eet pas les liens qui existent entre les diff\u00e9rents chapitres. Ceci peut \u00eatre un probl\u00e8me: le programme du cours est lin\u00e9aire et ne s\u2019 adapte pas aux sp\u00e9cificit\u00e9s de l\u2019\u00e9tudiant qui le suit. L\u2019ordre des exercices a \u00e9t\u00e9 pr\u00e9d\u00e9fini par le concepteur du cours. M\u00eame s\u2019 il laisse libre acc\u00e8s aux diff\u00e9rents concepts \u00e9tudi\u00e9s, aucune recommandation n\u2019est faite afin de s\u2019 assurer que l\u2019\u00e9tudiant ma\u00eetrise ces concepts avant de lui laisser acc\u00e9der \u00e0 une mati\u00e8re consid\u00e9r\u00e9e comme plus avanc\u00e9e. C\u2019est pourquoi ce travail de fin d\u2019\u00e9tudes propose une nouvelle extension \u00e0 la plateforme de cours en ligne INGInious, d\u00e9velopp\u00e9e \u00e0 l\u2019UCLouvain, afin de proposer un parcours sp\u00e9cifique de la mati\u00e8re \u00e0 chaque \u00e9tudiant. Celle-ci s\u2019 adapte au niveau de ma\u00eetrise de la mati\u00e8re et aux succ\u00e8s et \u00e9checs de l\u2019\u00e9tudiant aux diff\u00e9rentes t\u00e2ches qui lui sont propos\u00e9es. Cela permet au parcours d\u2019exercices d\u2019\u00eatre unique pour chacun et d\u2019accompagner l\u2019\u00e9l\u00e8ve dans son apprentissage des sciences informatiques.(eng) Computing has become a ubiquitous field in our world and its learning methods are multiple, diverse and varied. Numerous courses online are available for free access and anyone can\u00a0\u2026", "num_citations": "1\n", "authors": ["982"]}
{"title": "A Context and Feature Visualisation Tool for a Feature-Based Context-Oriented Programming Language.\n", "abstract": " In this paper we present a visualisation tool that is intricately related to a featurebased context-oriented programming language. Context-oriented programming languages allow programmers to develop software systems of which the behaviour evolves dynamically upon changing contexts. In our language, the software behaviour as well as the contexts to which the behaviour adapts, are encoded in terms of separate feature models. Due to the highly dynamic nature of such software systems and the many possible combinations of contexts to which they may adapt, developing such systems is hard. To help programmers manage the complexity of developing such software systems, we created a tool to help them visualise the contexts and features, even at runtime. The visualisation tool confronts two hierarchical models: the context model and the feature model, and highlights the dependencies between them. We conduct an initial user study of the visualisation tool to assess its usefulness and usability.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Clone Detection vs. Pattern Mining: The Battle.\n", "abstract": " In this paper we compare two approaches to discover recurrent fragments in source code: clone detection and frequent subtree mining. We apply both approaches to a mediumsized Java case and compare qualitatively and quantitatively their results in terms of what types of code fragments are detected, as well as their size, relevance, coverage, and level of detail. We conclude that both approaches are complementary, while existing overlap may be used for cross-validation of the approaches.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Lessons and Pitfalls in Building Firefox with Tup.\n", "abstract": " Build system implementations are surprisingly numerous for the single common purpose of assembling software. With this variety, picking the right one is a complex task. And even more difficult is the migration to a new build system, with uncertain benefits at the end. Software maintainers and release engineers need better comparisons of build systems and precise catagorisation on which to base an informed decision. As a first step toward that goal, we experimented building Firefox with Tup in replacement of Make. We report here our experience at migrating and comparing the build systems. We also describe interesting features of Tup and we discus Mozilla\u2019s Firefox usage as a benchmark for build systems.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Context-sensitive parsing through stateful parsing\n", "abstract": " Context-sensitive parsing remains a problematic area within parsing research. Many mainstream programming and markup languages (C, C++, Haskell, Python, XML,...) possess context-sensitive features. These features are traditionally handled with ad-hoc code (eg, custom lexers). Some approaches (data-dependent grammars, monadic parsing, attribute grammars, definite clause grammars,...) are able to express context-sensitive features. However, none of these approaches, with the exception of backtracking semantic actions [2], feature context-transparent constructs (grammar rules, parsers in a parser-combinator approach,...). A grammatical construct is context-transparent if it is unaware of the context shared between its ancestors and its descendants. Consider three non-terminals A, B and C such that A\u2019s right-hand side contains B and B\u2019s right-hand side contains C. If A and C must share some data, a contexttransparent system will not require B to ferry over the data between A and C, nor to know anything about the data. This lack of context transparency makes grammars hard to write, maintain and compose, as each change to a construct may require changing each construct through which it is accessed.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Fragility of evolving software\n", "abstract": " Software systems are fragile with respect to evolution. They consist of many software artefacts that make implicit assumptions about one another. When such artefacts get replaced by newer versions, some of these assumptions may get invalidated, thus causing subtle evolution conflicts. We refer to this phenomenon as fragility of evolving software. A particular instance of fragility in class-based object-oriented programming languages is the fragile base class problem [5, 7]. It occurs when a base class (a class from which other classes are derived through inheritance) gets replaced by a newer version. When the derived classes make certain assumptions about the base class that the evolved base class no longer provides, this can cause subtle conflicts. Eg, suppose that a base class B implements a method m in terms of an auxiliary method n. Now suppose that a derived class D of B overrides the implementation of n, with the intention not only of adapting the behaviour of n, but also that of m which is defined in terms of n. Independently, however, the base class B evolves into a newer version B\u2019where m no longer depends on n for performance reasons. After this evolution, D\u2019s assumption that m depends on n is no longer valid, and D\u2019s overridden implementation of n no longer affects m, thus causing an unexpected behavioural conflict.Another instance of fragility is the fragile pointcut problem in aspect-oriented programming [2, 6]. It may occur upon evolution of an aspect-oriented program, which contains pointcuts expressed over a base program. Pointcut expressions express execution points, called join points, in the base program where the\u00a0\u2026", "num_citations": "1\n", "authors": ["982"]}
{"title": "Dynamicschema: a lightweight persistency framework for context-oriented data management\n", "abstract": " While context-oriented programming technology so far has focused mostly on behavioral adaptation, context-oriented data management has received much less attention. In this paper we make a case for the problem of context-oriented data management, using a concrete example of a mobile application. We illustrate some of the issues involved and propose a lightweight persistency framework, called DynamicSchema, that resolves some of these issues. The solution consists in a flexible reification of the database schema, as a convenient dynamic data structure that can be adapted at execution time, according to sensed context changes. Implementing our mobile application using this framework enabled us to reduce the complexity of the domain modeling layer, to facilitate the production of code with low memory footprint, and to simplify the implementation of certain scenarios related to context-dependent security\u00a0\u2026", "num_citations": "1\n", "authors": ["982"]}
{"title": "Towards a taxonomy of tools for documenting code design\n", "abstract": " Numerous tools for documenting code design exist. Each of these proposes different techniques and attempts to deal with different aspects regarding code design documentation. Though this abundance of tools and techniques is a clear sign of the importance of such kind of tools in real life software implementation, it also creates confusion when trying to decide which one best suites the specific needs of a project. Adding to this confusion is the fact that different tools often use a different terminology for similar problems. Furthermore, the support offered by most of these tools is limited, since it is often based either on verifiable documentation that is not highly customizable, or customizable documentation that cannot easily be verified. This paper takes initial steps in the direction of establishing a common vocabulary for describing code design documentation tools, and highlights the features that a verifiable and highly customizable tool should provide in order to satisfy most of the code design documentation requirements present in the implementation of complex software systems.", "num_citations": "1\n", "authors": ["982"]}
{"title": "A Unified Mechanism for Improving Advanced Transaction Management in Web Services\n", "abstract": " Current web-service composition languages, such as BPEL, provide inferior support for transaction management. Consequently, specifications written in these languages are needlessly complex and hard to reuse. Furthermore, the languages themselves are not transactionally extensible, making them hard to adapt to support new forms of web service composition. Using a unified mechanism for dealing with transaction management we are able to simplify BPEL specifications, making them more reusable, and also allowing for easy evolution of the language, addressing new forms of composition. In this paper we present DBCF, a framework that implements this unified mechanism. Moreover, we show how DBCF can be used as a basis for defining a BPEL extension that successfully addresses the above problems.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Supporting software maintenance and reengineering with intentional source-code views\n", "abstract": " We propose the abstraction of intentional source-code views to codify essential information, about the architecture and implementation of a software system, that an engineer needs to better understand and maintain the system. We report on some experiments that investigate the usefulness of intentional source-code views in a variety of software maintenance, evolution and reengineering tasks, and present the results of these experiments in a pattern-like style.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Knowledge-Based Object-Oriented Software Engineering\n", "abstract": " The complexity of software domains \u2013 such as the financial industry, television and radio broadcasting, hospital management and rental business ~ is steadily increasing and knowledge management of businesses is becoming more important witht he demand for capturing business processes. On the other hand the volatility of software development expertise needs to be reduced. These are symptoms of a very significant tendency towards making knowledge of different kinds explicit: knowledge about the domain or the business, knowledge about developing software, and even meta-knowledge about these kinds of knowledge. Examples of approaches that are directly related to this tendency or could contribute to it are knowledge engineering, ontologies, conceptual modeling, domain analysis and domain engineering, business rules, work- flow management and researchp resented at conferences and\u00a0\u2026", "num_citations": "1\n", "authors": ["982"]}
{"title": "Report from the ECOOP2002 workshop on knowledge-based object-oriented software engineering\n", "abstract": " Report from the ECOOP2002 Workshop on Knowledge-Based Object-Oriented Software Engineering \u2014 Vrije Universiteit Brussel Skip to main navigation Skip to search Skip to main content Vrije Universiteit Brussel Logo Help & FAQ English Nederlands Home Research Units Profiles Projects Research output Activities Equipment Prizes Press / Media Student theses Impacts Search by expertise, name or affiliation Report from the ECOOP2002 Workshop on Knowledge-Based Object-Oriented Software Engineering Maja D'Hondt, Kim Mens, Ellen Van Paesschen Vrije Universiteit Brussel Research output: Chapter in Book/Report/Conference proceeding \u203a Chapter \u203a Research \u203a peer-review Overview Original language English Title of host publication Juan Hern\u00e1ndez and Ana Moreira (Eds.), Workshop Reader of the 16th European Conference on Object-Oriented Programming (ECOOP'02). M\u00e1laga, Spain, June 2002. \u2026", "num_citations": "1\n", "authors": ["982"]}
{"title": "Etude de l'interop\u00e9rabilit\u00e9 de deux langages de programmation bas\u00e9e sur la machine virtuelle de Java\n", "abstract": " Dans cette introduction, je vais d\u00e9finir la notion d\u2019interop\u00e9rabilit\u00e9 entre deux langages de programmation et donner les motivations pour sa r\u00e9alisation. Je pr\u00e9senterai ensuite quelques m\u00e9canismes d\u2019interop\u00e9rabilit\u00e9 et je d\u00e9crirai celui que nous allons d\u00e9velopper dans ce m\u00e9moire. Mais dans un premier temps, je vais indiquer l\u2019organisation du reste de ce texte.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Workshop Report\u2014ECOOP\u201998 Workshop 7 Tools and Environments for Business Rules\n", "abstract": " This workshop focussed on the requirements for tools and environments that support business rules in an object-oriented setting and attempted to provide an overview of possible techniques and tools for the handling, definition and checking of these rules and the constraints expressed by them during analysis, design and development of object-oriented software.", "num_citations": "1\n", "authors": ["982"]}
{"title": "An Introduction to Polymorphic Lambda Calculus with Subtyping.\n", "abstract": " In this paper, an elaborate overview is presented of several extensions of standard lambda calculus. We start out with a description of untyped lambda calculus. Then we add explicit types and show how polymorphism can be introduced. Next we give a description of a higher order polymorphic typed lambda calculus. In this system (called F\u03c9) types, type constructors, constructors of type constructors and so on can all be considered as first class values. The system can still be augmented with a notion of subtyping, yielding system F\u03c9", "num_citations": "1\n", "authors": ["982"]}
{"title": "On the use of knowledge representation techniques for modeling software architectures\n", "abstract": " We take the position that it could prove worth to reconcile ideas of the knowledge representation and software architecture research communities. Many existing knowledge representation techniques and formalisms seem to exhibit a lot of potential for representing different aspects of software architectures. To illustrate our case, we show how the theory of conceptual graphs could be a useful candidate to describe software architectures, to model architectural styles and patterns, and to serve as a formal foundation for compliance checking of architectures to architectural styles, as well as for checking conformance of the implementation of a software system to its architecture.", "num_citations": "1\n", "authors": ["982"]}
{"title": "Conception of a market garden management application in partnership with Lauzelle farm\n", "abstract": " Even though market gardening is attracting increased attention from consumers and researchers, it is not always easy for gardeners to make ends meet. For the practitioners, not only is gardening a tough task by the huge work labour it imposes, but it also requires important efforts for its planning and organisation. The study of different gardening techniques and the associated profitability of vegetables draws much attention among some researchers from UCLouvain. To support these studies, the university has recently started a project on a farm in Louvain-la-Neuve. In this context, this master thesis aims to provide a software tool which could support both gardeners and researchers. The first step of our work consisted in meeting some gardeners in order to better identify the main daily challenges they face in their planning and crop management. Meanwhile, it was emphasized that a key issue hampering research was the difficulty to gather reliable data sets. Following these observations, this dissertation builds a web application offering, on the one hand, a planning tool for gardeners and, on the other, a data gathering platform for researchers. Our solution allows a gardener to create a virtual representation of his garden and to divide his land into parcels and beds. He can either create or use existing identity cards of vegetables. Each of these cards contains a roadmap of successive cultivation operations for the cropping of the concerned vegetables. Our tool provides reminders of these cultivation operations throughout the year and helps the gardener keeping track of...", "num_citations": "1\n", "authors": ["982"]}