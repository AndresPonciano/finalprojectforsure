{"title": "Symbolic execution for software testing: three decades later\n", "abstract": " The challenges---and great promise---of modern symbolic execution techniques, and the tools to help implement them.", "num_citations": "820\n", "authors": ["257"]}
{"title": "Heuristics for scalable dynamic test generation\n", "abstract": " Recently there has been great success in using symbolic execution to automatically generate test inputs for small software systems. A primary challenge in scaling such approaches to larger programs is the combinatorial explosion of the path space. It is likely that sophisticated strategies for searching this path space are needed to generate inputs that effectively test large programs (by, e.g., achieving significant branch coverage). We present several such heuristic search strategies, including a novel strategy guided by the control flow graph of the program under test. We have implemented these strategies in CREST, our open source concolic testing tool for C, and evaluated them on two widely-used software tools, grep 2.2 (15 K lines of code) and Vim 5.7 (150 K lines). On these benchmarks, the presented heuristics achieve significantly greater branch coverage on the same testing budget than concolic testing with\u00a0\u2026", "num_citations": "547\n", "authors": ["257"]}
{"title": "Race directed random testing of concurrent programs\n", "abstract": " Bugs in multi-threaded programs often arise due to data races. Numerous static and dynamic program analysis techniques have been proposed to detect data races. We propose a novel randomized dynamic analysis technique that utilizes potential data race information obtained from an existing analysis tool to separate real races from false races without any need for manual inspection. Specifically, we use potential data race information obtained from an existing dynamic analysis technique to control a random scheduler of threads so that real race conditions get created with very high probability and those races get resolved randomly at runtime. Our approach has several advantages over existing dynamic analysis tools. First, we can create a real race condition and resolve the race randomly to see if an error can occur due to the race. Second, we can replay a race revealing execution efficiently by simply using\u00a0\u2026", "num_citations": "426\n", "authors": ["257"]}
{"title": "Guided gui testing of android apps with minimal restart and approximate learning\n", "abstract": " Smartphones and tablets with rich graphical user interfaces (GUI) are becoming increasingly popular. Hundreds of thousands of specialized applications, called apps, are available for such mobile platforms. Manual testing is the most popular technique for testing graphical user interfaces of such apps. Manual testing is often tedious and error-prone. In this paper, we propose an automated technique, called Swift-Hand, for generating sequences of test inputs for Android apps. The technique uses machine learning to learn a model of the app during testing, uses the learned model to generate user inputs that visit unexplored states of the app, and uses the execution of the app on the generated inputs to refine the model. A key feature of the testing algorithm is that it avoids restarting the app, which is a significantly more expensive operation than executing the app on a sequence of inputs. An important insight behind\u00a0\u2026", "num_citations": "415\n", "authors": ["257"]}
{"title": "Precimonious: Tuning assistant for floating-point precision\n", "abstract": " Given the variety of numerical errors that can occur, floating-point programs are difficult to write, test and debug. One common practice employed by developers without an advanced background in numerical analysis is using the highest available precision. While more robust, this can degrade program performance significantly. In this paper we present Precimonious, a dynamic program analysis tool to assist developers in tuning the precision of floating-point programs. Precimonious performs a search on the types of the floating-point program variables trying to lower their precision subject to accuracy constraints and performance goals. Our tool recommends a type instantiation that uses lower precision while producing an accurate enough answer without causing exceptions. We evaluate Precimonious on several widely used functions from the GNU Scientific Library, two NAS Parallel Benchmarks, and three other\u00a0\u2026", "num_citations": "293\n", "authors": ["257"]}
{"title": "Jalangi: A selective record-replay and dynamic analysis framework for JavaScript\n", "abstract": " JavaScript is widely used for writing client-side web applications and is getting increasingly popular for writing mobile applications. However, unlike C, C++, and Java, there are not that many tools available for analysis and testing of JavaScript applications. In this paper, we present a simple yet powerful framework, called Jalangi, for writing heavy-weight dynamic analyses. Our framework incorporates two key techniques: 1) selective record-replay, a technique which enables to record and to faithfully replay a user-selected part of the program, and 2) shadow values and shadow execution, which enables easy implementation of heavy-weight dynamic analyses. Our implementation makes no special assumption about JavaScript, which makes it applicable to real-world JavaScript programs running on multiple platforms. We have implemented concolic testing, an analysis to track origins of nulls and undefined, a simple\u00a0\u2026", "num_citations": "276\n", "authors": ["257"]}
{"title": "Concolic testing\n", "abstract": " Concolic testing automates test input generation by combining the concrete and symbolic (concolic) execution of the code under test. Traditional test input generation techniques use either (1) concrete execution or (2) symbolic execution that builds constraints and is followed by a generation of concrete test inputs from these constraints. In contrast, concolic testing tightly couples both concrete and symbolic executions: they run simultaneously, and each gets feedback from the other.", "num_citations": "233\n", "authors": ["257"]}
{"title": "A randomized dynamic program analysis technique for detecting real deadlocks\n", "abstract": " We present a novel dynamic analysis technique that finds real deadlocks in multi-threaded programs. Our technique runs in two stages. In the first stage, we use an imprecise dynamic analysis technique to find potential deadlocks in a multi-threaded program by observing an execution of the program. In the second stage, we control a random thread scheduler to create the potential deadlocks with high probability. Unlike other dynamic analysis techniques, our approach has the advantage that it does not give any false warnings. We have implemented the technique in a prototype tool for Java, and have experimented on a number of large multi-threaded Java programs. We report a number of previously known and unknown real deadlocks that were found in these benchmarks.", "num_citations": "224\n", "authors": ["257"]}
{"title": "Effective static deadlock detection\n", "abstract": " We present an effective static deadlock detection algorithm for Java. Our algorithm uses a novel combination of static analyses each of which approximates a different necessary condition for a deadlock. We have implemented the algorithm and report upon our experience applying it to a suite of multi-threaded Java programs. While neither sound nor complete, our approach is effective in practice, finding all known deadlocks as well as discovering previously unknown ones in our benchmarks with few false alarms.", "num_citations": "219\n", "authors": ["257"]}
{"title": "Randomized active atomicity violation detection in concurrent programs\n", "abstract": " Atomicity is an important specification that enables programmers to understand atomic blocks of code in a multi-threaded program as if they are sequential. This significantly simplifies the programmer's job to reason about correctness. Several modern multithreaded programming languages provide no built-in support to ensure atomicity; instead they rely on the fact that programmers would use locks properly in order to guarantee that atomic code blocks are indeed atomic. However, improper use of locks can sometimes fail to ensure atomicity. Therefore, we need tools that can check atomicity properties of lock-based code automatically.", "num_citations": "195\n", "authors": ["257"]}
{"title": "Sniff: A search engine for java using free-form queries\n", "abstract": " Reuse of existing libraries simplifies software development efforts. However, these libraries are often complex and reusing the APIs in the libraries involves a steep learning curve. A programmer often uses a search engine such as Google to discover code snippets involving library usage to perform a common task. A problem with search engines is that they return many pages that a programmer has to manually mine to discover the desired code. Recent research efforts have tried to address this problem by automating the generation of code snippets from user queries. However, these queries need to have type information and therefore require the user to have a partial knowledge of the APIs.               We propose a novel code search technique, called SNIFF, which retains the flexibility of performing code search in plain English, while obtaining a small set of relevant code snippets to perform the desired task\u00a0\u2026", "num_citations": "183\n", "authors": ["257"]}
{"title": "Fairfuzz: A targeted mutation strategy for increasing greybox fuzz testing coverage\n", "abstract": " In recent years, fuzz testing has proven itself to be one of the most effective techniques for finding correctness bugs and security vulnerabilities in practice. One particular fuzz testing tool, American Fuzzy Lop (AFL), has become popular thanks to its ease-of-use and bug-finding power. However, AFL remains limited in the bugs it can find since it simply does not cover large regions of code. If it does not cover parts of the code, it will not find bugs there. We propose a two-pronged approach to increase the coverage achieved by AFL. First, the approach automatically identifies branches exercised by few AFL-produced inputs (rare branches), which often guard code that is empirically hard to cover by naively mutating inputs. The second part of the approach is a novel mutation mask creation algorithm, which allows mutations to be biased towards producing inputs hitting a given rare branch. This mask is dynamically\u00a0\u2026", "num_citations": "160\n", "authors": ["257"]}
{"title": "Deepbugs: A learning approach to name-based bug detection\n", "abstract": " Natural language elements in source code, e.g., the names of variables and functions, convey useful information. However, most existing bug detection tools ignore this information and therefore miss some classes of bugs. The few existing name-based bug detection approaches reason about names on a syntactic level and rely on manually designed and tuned algorithms to detect bugs. This paper presents DeepBugs, a learning approach to name-based bug detection, which reasons about names based on a semantic representation and which automatically learns bug detectors instead of manually writing them. We formulate bug detection as a binary classification problem and train a classifier that distinguishes correct from incorrect code. To address the challenge that effectively learning a bug detector requires examples of both correct and incorrect code, we create likely incorrect code examples from an existing\u00a0\u2026", "num_citations": "157\n", "authors": ["257"]}
{"title": "CalFuzzer: An Extensible Active Testing Framework for Concurrent Programs\n", "abstract": " Active testing has recently been introduced to effectively test concurrent programs. Active testing works in two phases. It first uses predictive off-the-shelf static or dynamic program analyses to identify potential concurrency bugs, such as data races, deadlocks, and atomicity violations. In the second phase, active testing uses the reports from these predictive analyses to explicitly control the underlying scheduler of the concurrent program to accurately and quickly discover real concurrency bugs, if any, with very high probability and little overhead. In this paper, we present an extensible framework for active testing of Java programs. The framework currently implements three active testers based on data races, atomic blocks, and deadlocks.", "num_citations": "145\n", "authors": ["257"]}
{"title": "WISE: Automated test generation for worst-case complexity\n", "abstract": " Program analysis and automated test generation have primarily been used to find correctness bugs. We present complexity testing, a novel automated test generation technique to find performance bugs. Our complexity testing algorithm, which we call WISE (worst-case inputs from symbolic execution), operates on a program accepting inputs of arbitrary size. For each input size, WISE attempts to construct an input which exhibits the worst-case computational complexity of the program. WISE uses exhaustive test generation for small input sizes and generalizes the result of executing the program on those inputs into an ldquoinput generator.rdquo The generator is subsequently used to efficiently generate worst-case inputs for larger input sizes. We have performed experiments to demonstrate the utility of our approach on a set of standard data structures and algorithms. Our results show that WISE can effectively\u00a0\u2026", "num_citations": "145\n", "authors": ["257"]}
{"title": "Effective random testing of concurrent programs\n", "abstract": " Multithreaded concurrent programs often exhibit wrong behaviors due to unintended interferences among the concurrent threads. Such errors are often hard to find because they typically manifest under very specific thread schedules. Traditional testing, which pays no attention to thread schedules and non-deterministically exercises a few arbitrary schedules, often misses such bugs. Traditional model checking techniques, which try to systematically explore all thread schedules, give very high confidence in the correctness of the system, but, unfortunately, they suffer from the state explosion problem. Recently, dynamic partial order techniques have been proposed to alleviate the problem. However, such techniques fail for large programs because the state space remains large in spite of reduction. An inexpensive and a simple alternative approach is to perform random testing by choosing thread schedules at random\u00a0\u2026", "num_citations": "124\n", "authors": ["257"]}
{"title": "MultiSE: Multi-path symbolic execution using value summaries\n", "abstract": " Dynamic symbolic execution (DSE) has been proposed to effectively generate test inputs for real-world programs. Unfortunately, DSE techniques do not scale well for large realistic programs, because often the number of feasible execution paths of a program increases exponentially with the increase in the length of an execution path. In this paper, we propose MultiSE, a new technique for merging states incrementally during symbolic execution, without using auxiliary variables. The key idea of MultiSE is based on an alternative representation of the state, where we map each variable, including the program counter, to a set of guarded symbolic expressions called a value summary. MultiSE has several advantages over conventional DSE and conventional state merging techniques: value summaries enable sharing of symbolic expressions and path constraints along multiple paths and thus avoid redundant\u00a0\u2026", "num_citations": "118\n", "authors": ["257"]}
{"title": "PREFAIL: A programmable tool for multiple-failure injection\n", "abstract": " As hardware failures are no longer rare in the era of cloud computing, cloud software systems must\" prevail\" against multiple, diverse failures that are likely to occur. Testing software against multiple failures poses the problem of combinatorial explosion of multiple failures. To address this problem, we present PreFail, a programmable failure-injection tool that enables testers to write a wide range of policies to prune down the large space of multiple failures. We integrate PreFail to three cloud software systems (HDFS, Cassandra, and ZooKeeper), show a wide variety of useful pruning policies that we can write for them, and evaluate the speed-ups in testing time that we obtain by using the policies. In our experiments, our testing approach with appropriate policies found all the bugs that one can find using exhaustive testing while spending 10X--200X less time than exhaustive testing.", "num_citations": "114\n", "authors": ["257"]}
{"title": "An effective dynamic analysis for detecting generalized deadlocks\n", "abstract": " We present an effective dynamic analysis for finding a broad class of deadlocks, including the well-studied lock-only deadlocks as well as the less-studied, but no less widespread or insidious, deadlocks involving condition variables. Our analysis consists of two stages. In the first stage, our analysis observes a multi-threaded program execution and generates a simple multi-threaded program, called a trace program, that only records operations observed during the execution that are deemed relevant to finding deadlocks. Such operations include lock acquire and release, wait and notify, thread start and join, and change of values of user-identified synchronization predicates associated with condition variables. In the second stage, our analysis uses an off-the-shelf model checker to explore all possible thread interleavings of the trace program and check if any of them deadlocks. A key advantage of our technique is\u00a0\u2026", "num_citations": "107\n", "authors": ["257"]}
{"title": "FATE and DESTINI: A framework for cloud recovery testing\n", "abstract": " As the cloud era begins and failures become commonplace, failure recovery becomes a critical factor in the availability, reliability and performance of cloud services. Unfortunately, recovery problems still take place, causing downtimes, data loss, and many other problems. We propose a new testing framework for cloud recovery: FATE (Failure Testing Service) and DESTINI (Declarative Testing Specifications). With FATE, recovery is systematically tested in the face of multiple failures. With DESTINI, correct recovery is specified clearly, concisely, and precisely. We have integrated our framework to several cloud systems (eg, HDFS [33]), explored over 40,000 failure scenarios, wrote 74 specifications, found 16 new bugs, and reproduced 51 old bugs.", "num_citations": "104\n", "authors": ["257"]}
{"title": "Model-Checking \u03c9-Regular Properties of Interval Markov Chains\n", "abstract": " We study the problem of model checking Interval-valued Discrete-time Markov Chains (IDTMC). IDTMCs are discrete-time finite Markov Chains for which the exact transition probabilities are not known. Instead in IDTMCs, each transition is associated with an interval in which the actual transition probability must lie. We consider two semantic interpretations for the uncertainty in the transition probabilities of an IDTMC. In the first interpretation, we think of an IDTMC as representing a (possibly uncountable) family of (classical) discrete-time Markov Chains, where each member of the family is a Markov Chain whose transition probabilities lie within the interval range given in the IDTMC. We call this semantic interpretation Uncertain Markov Chains (UMC). In the second semantics for an IDTMC, which we call Interval Markov Decision Process (IMDP), we view the uncertainty as being resolved through non\u00a0\u2026", "num_citations": "102\n", "authors": ["257"]}
{"title": "Perffuzz: Automatically generating pathological inputs\n", "abstract": " Performance problems in software can arise unexpectedly when programs are provided with inputs that exhibit worst-case behavior. A large body of work has focused on diagnosing such problems via statistical profiling techniques. But how does one find these inputs in the first place? We present PerfFuzz, a method to automatically generate inputs that exercise pathological behavior across program locations, without any domain knowledge. PerfFuzz generates inputs via feedback-directed mutational fuzzing. Unlike previous approaches that attempt to maximize only a scalar characteristic such as the total execution path length, PerfFuzz uses multi-dimensional feedback and independently maximizes execution counts for all program locations. This enables PerfFuzz to (1) find a variety of inputs that exercise distinct hot spots in a program and (2) generate inputs with higher total execution path length than previous\u00a0\u2026", "num_citations": "90\n", "authors": ["257"]}
{"title": "Asserting and checking determinism for multithreaded programs\n", "abstract": " The trend towards processors with more and more parallel cores is increasing the need for software that can take advantage of parallelism. The most widespread method for writing parallel software is to use explicit threads. Writing correct multithreaded programs, however, has proven to be quite challenging in practice. The key difficulty is non-determinism. The threads of a parallel application may be interleaved non-deterministically during execution. In a buggy program, non-deterministic scheduling will lead to non-deterministic results-some interleavings will produce the correct result while others will not.", "num_citations": "90\n", "authors": ["257"]}
{"title": "Program monitoring with LTL in EAGLE\n", "abstract": " Summary form only given. We briefly present a rule-based framework, called EAGLE, shown to be capable of defining and implementing finite trace monitoring logics, including future and past time temporal logic, extended regular expressions, real-time and metric temporal logics (MTL), interval logics, forms of quantified temporal logics, and so on. In this paper we focus on a linear temporal logic (LTL) specialisation of EAGLE. For an initial formula of size m, we establish upper bounds of O(m/sup 2/2/sup m/logm) and O(m/sup 4/2/sup 2m/log/sup 2/m) for the space and time complexity, respectively, of single step evaluation over an input trace. EAGLE has been successfully used, in both LTL and metric LTL forms, to test a real-time controller of an experimental NASA planetary rover.", "num_citations": "84\n", "authors": ["257"]}
{"title": "Sound and complete monitoring of sequential consistency for relaxed memory models\n", "abstract": " We present a technique for verifying that a program has no executions violating sequential consistency (SC) when run under the relaxed memory models Total Store Order (TSO) and Partial Store Order (PSO). The technique works by monitoring sequentially consistent executions of a program to detect if similar program executions could fail to be sequentially consistent under TSO or PSO. We propose novel monitoring algorithms that are sound and complete for TSO and PSO\u2014if a program can exhibit an SC violation under TSO or PSO, then the corresponding monitor can detect this on some SC execution. The monitoring algorithms arise naturally from the operational definitions of these relaxed memory models, highlighting an advantage of viewing relaxed memory models operationally rather than axiomatically. We apply our technique to several concurrent data structures and synchronization primitives\u00a0\u2026", "num_citations": "77\n", "authors": ["257"]}
{"title": "Jitprof: Pinpointing jit-unfriendly javascript code\n", "abstract": " Most modern JavaScript engines use just-in-time (JIT) compilation to translate parts of JavaScript code into efficient machine code at runtime. Despite the overall success of JIT compilers, programmers may still write code that uses the dynamic features of JavaScript in a way that prohibits profitable optimizations. Unfortunately, there currently is no way to measure how prevalent such JIT-unfriendly code is and to help developers detect such code locations. This paper presents JITProf, a profiling framework to dynamically identify code locations that prohibit profitable JIT optimizations. The key idea is to associate meta-information with JavaScript objects and code locations, to update this information whenever particular runtime events occur, and to use the meta-information to identify JIT-unfriendly operations. We use JITProf to analyze widely used JavaScript web applications and show that JIT-unfriendly code is\u00a0\u2026", "num_citations": "75\n", "authors": ["257"]}
{"title": "Floating-point precision tuning using blame analysis\n", "abstract": " While tremendously useful, automated techniques for tuning the precision of floating-point programs face important scalability challenges. We present Blame Analysis, a novel dynamic approach that speeds up precision tuning. Blame Analysis performs floating-point instructions using different levels of accuracy for their operands. The analysis determines the precision of all operands such that a given precision is achieved in the final result of the program. Our evaluation on ten scientific programs shows that Blame Analysis is successful in lowering operand precision. As it executes the program only once, the analysis is particularly useful when targeting reductions in execution time. In such case, the analysis needs to be combined with search-based tools such as Precimonious. Our experiments show that combining Blame Analysis with Precimonious leads to obtaining better results with significant reduction in\u00a0\u2026", "num_citations": "74\n", "authors": ["257"]}
{"title": "DLint: Dynamically checking bad coding practices in JavaScript\n", "abstract": " JavaScript has become one of the most popular programming languages, yet it is known for its suboptimal design. To effectively use JavaScript despite its design flaws, developers try to follow informal code quality rules that help avoid correctness, maintainability, performance, and security problems. Lightweight static analyses, implemented in\" lint-like\" tools, are widely used to find violations of these rules, but are of limited use because of the language's dynamic nature. This paper presents DLint, a dynamic analysis approach to check code quality rules in JavaScript. DLint consists of a generic framework and an extensible set of checkers that each addresses a particular rule. We formally describe and implement 28 checkers that address problems missed by state-of-the-art static approaches. Applying the approach in a comprehensive empirical study on over 200 popular web sites shows that static and dynamic\u00a0\u2026", "num_citations": "72\n", "authors": ["257"]}
{"title": "Testing concurrent programs on relaxed memory models\n", "abstract": " High-performance concurrent libraries, such as lock-free data structures and custom synchronization primitives, are notoriously difficult to write correctly. Such code is often implemented without locks, instead using plain loads and stores and low-level operations like atomic compare-and-swaps and explicit memory fences. Such code must run correctly despite the relaxed memory model of the underlying compiler, virtual machine, and/or hardware. These memory models may reorder the reads and writes issued by a thread, greatly complicating parallel reasoning.", "num_citations": "72\n", "authors": ["257"]}
{"title": "Magnetic fabric, shape preferred orientation and regional strain in granitic rocks\n", "abstract": " Since granites do not preserve easily mappable foliations, lineations, and strain markers, determining the degree of shape preferred orientation (SPO) in them is challenging. The aim of this paper is to present a methodology for determining variation in the degree of SPO in granites and to test the feasibility of correlating the same with regional strain. The case of the Godhra Granite located in the southern parts of Aravalli Mountain Belt (India) is taken as an example. Degree of SPO is determined using two different techniques (a) anisotropy of magnetic susceptibility (AMS) and (b) strength of mineral lineation determined by calculating the concentration parameter (\u03ba) of von Mises distribution by digital image analysis of biotite (\u03babi) and feldspar (\u03baf) in thin sections prepared parallel to the magnetic foliation plane. SPO data obtained using the above two techniques from 20 samples distributed across the entire granite\u00a0\u2026", "num_citations": "72\n", "authors": ["257"]}
{"title": "TypeDevil: Dynamic type inconsistency analysis for JavaScript\n", "abstract": " Dynamic languages, such as JavaScript, give programmers the freedom to ignore types, and enable them to write concise code in short time. Despite this freedom, many programs follow implicit type rules, for example, that a function has a particular signature or that a property has a particular type. Violations of such implicit type rules often correlate with problems in the program. This paper presents Type Devil, a mostly dynamic analysis that warns developers about inconsistent types. The key idea is to assign a set of observed types to each variable, property, and function, to merge types based in their structure, and to warn developers about variables, properties, and functions that have inconsistent types. To deal with the pervasiveness of polymorphic behavior in real-world JavaScript programs, we present a set of techniques to remove spurious warnings and to merge related warnings. Applying Type Devil to\u00a0\u2026", "num_citations": "71\n", "authors": ["257"]}
{"title": "A temporal logic based framework for intrusion detection\n", "abstract": " We propose a\u00a0framework for intrusion detection that is based on runtime monitoring of temporal logic specifications. We specify intrusion patterns as formulas in an expressively rich and efficiently monitorable logic called Eagle. Eagle supports data-values and parameterized recursive equations, and allows us to succinctly express security attacks with complex temporal event patterns, as well as attacks whose signatures are inherently statistical in nature. We use an online monitoring algorithm that matches specifications of the absence of an attack, with system execution traces, and raises an alarm whenever the specification is violated. We present our implementation of this approach in a prototype tool, called Monid and report our results obtained by applying it to detect a\u00a0variety of security attacks in log-files provided by DARPA.", "num_citations": "71\n", "authors": ["257"]}
{"title": "A trace simplification technique for effective debugging of concurrent programs\n", "abstract": " Concurrent programs are notoriously difficult to debug. We see two main reasons for this: 1) concurrency bugs are often difficult to reproduce, 2) traces of buggy concurrent executions can be complicated by fine-grained thread interleavings. Recently, a number of efficient techniques have tried to address the former reproducibility problem; however, there is no effective solution for the latter trace simplification problem. In this paper, we formalize and prove the trace simplification problem is NP-hard. We then propose a heuristic algorithm, Tinertia, that transforms a buggy execution trace into an easier-to-understand simplified trace. Tinertia works by automatically and iteratively increasing the granularity of the thread interleavings in the buggy trace. Tinertia cannot guarantee optimal simplification; however, we empirically show that our algorithm often generates optimally simplified traces. Moreover, we show that in the\u00a0\u2026", "num_citations": "68\n", "authors": ["257"]}
{"title": "Looper: Lightweight detection of infinite loops at runtime\n", "abstract": " When a running program becomes unresponsive, it is often impossible for a user to determine if the program is performing some useful computation or if it has entered an infinite loop. We present LOOPER, an automated technique for dynamically analyzing a running program to prove that it is non-terminating. LOOPER uses symbolic execution to produce simple non-termination arguments for infinite loops dependent on both program values and the shape of heap. The constructed arguments are verified with an off-the-shelf SMT solver. We have implemented our technique in a prototype tool for Java applications, and we demonstrate our technique's effectiveness on several non-terminating benchmarks, including a reported infinite loop bug in open-source text editor jEdit. Our tool is able to dynamically detect infinite loops deep in the execution of large Java programs with no false warnings, producing symbolic\u00a0\u2026", "num_citations": "68\n", "authors": ["257"]}
{"title": "An executable specification of asynchronous Pi-Calculus semantics and may testing in Maude 2.0\n", "abstract": " We describe an executable specification of the operational semantics of an asynchronous version of the \u03c0-calculus in Maude by means of conditional rewrite rules with rewrites in the conditions. We also present an executable specification of the may testing equivalence on non-recursive asynchronous \u03c0-calculus processes, using the Maude metalevel. Specifically, we describe our use of the metaSearch operation to both calculate the set of all finite traces of a non-recursive process, and to compare the trace sets of two processes according to a preorder relation that characterizes may testing in asynchronous \u03c0-calculus. Thus, in both the specification of the operational semantics and the may testing, we make heavy use of new features introduced in version 2.0 of the Maude language and system.", "num_citations": "66\n", "authors": ["257"]}
{"title": "Fairfuzz: Targeting rare branches to rapidly increase greybox fuzz testing coverage\n", "abstract": " In recent years, fuzz testing has proven itself to be one of the most effective techniques for finding correctness bugs and security vulnerabilities in practice. One particular fuzz testing tool, American Fuzzy Lop or AFL, has become popular thanks to its ease-of-use and bug-finding power. However, AFL remains limited in the depth of program coverage it achieves, in particular because it does not consider which parts of program inputs should not be mutated in order to maintain deep program coverage. We propose an approach, FairFuzz, that helps alleviate this limitation in two key steps. First, FairFuzz automatically prioritizes inputs exercising rare parts of the program under test. Second, it automatically adjusts the mutation of inputs so that the mutated inputs are more likely to exercise these same rare parts of the program. We conduct evaluation on real-world programs against state-of-the-art versions of AFL, thoroughly repeating experiments to get good measures of variability. We find that on certain benchmarks FairFuzz shows significant coverage increases after 24 hours compared to state-of-the-art versions of AFL, while on others it achieves high program coverage at a significantly faster rate.", "num_citations": "56\n", "authors": ["257"]}
{"title": "EventBreak: Analyzing the responsiveness of user interfaces through performance-guided test generation\n", "abstract": " Event-driven user interface applications typically have a single thread of execution that processes event handlers in response to input events triggered by the user, the network, or other applications. Programmers must ensure that event handlers terminate after a short amount of time because otherwise, the application may become unresponsive. This paper presents EventBreak, a performance-guided test generation technique to identify and analyze event handlers whose execution time may gradually increase while using the application. The key idea is to systematically search for pairs of events where triggering one event increases the execution time of the other event. For example, this situation may happen because one event accumulates data that is processed by the other event. We implement the approach for JavaScript-based web applications and apply it to three real-world applications. EventBreak\u00a0\u2026", "num_citations": "56\n", "authors": ["257"]}
{"title": "Efficient data race detection for distributed memory parallel programs\n", "abstract": " In this paper we present a precise data race detection technique for distributed memory parallel programs. Our technique, which we call Active Testing, builds on our previous work on race detection for shared memory Java and C programs and it handles programs written using shared memory approaches as well as bulk communication. Active testing works in two phases: in the first phase, it performs an imprecise dynamic analysis of an execution of the program and finds potential data races that could happen if the program is executed with a different thread schedule. In the second phase, active testing re-executes the program by actively controlling the thread schedule so that the data races reported in the first phase can be confirmed. A key highlight of our technique is that it can scalably handle distributed programs with bulk communication and single-and splitphase barriers. Another key feature of our technique\u00a0\u2026", "num_citations": "53\n", "authors": ["257"]}
{"title": "Efficient sampling of SAT solutions for testing\n", "abstract": " In software and hardware testing, generating multiple inputs which satisfy a given set of constraints is an important problem with applications in fuzz testing and stimulus generation. However, it is a challenge to perform the sampling efficiently, while generating a diverse set of inputs which satisfy the constraints. We developed a new algorithm QuickSampler which requires a small number of solver calls to produce millions of samples which satisfy the constraints with high probability. We evaluate QuickSampler on large real-world benchmarks and show that it can produce unique valid solutions orders of magnitude faster than other state-of-the-art sampling tools, with a distribution which is reasonably close to uniform in practice.", "num_citations": "52\n", "authors": ["257"]}
{"title": "Ansor: Generating high-performance tensor programs for deep learning\n", "abstract": " High-performance tensor programs are crucial to guarantee efficient execution of deep neural networks. However, obtaining performant tensor programs for different operators on various hardware platforms is notoriously challenging. Currently, deep learning systems rely on vendor-provided kernel libraries or various search strategies to get performant tensor programs. These approaches either require significant engineering effort to develop platform-specific optimization code or fall short of finding high-performance programs due to restricted search space and ineffective exploration strategy.", "num_citations": "44\n", "authors": ["257"]}
{"title": "Degree of magnetic anisotropy as a strain intensity gauge in ferromagnetic granites\n", "abstract": " Anisotropy of magnetic susceptibility data for a ferromagnetic granite (Godhra Granite, NW India) are presented and it is shown that the degree of magnetic anisotropy (P\u2032) is not controlled by the mean susceptibility (Km). Analyses carried out across a high-strain zone lying between granite and adjacent gneiss show that P\u2032 values are highest in samples that lie close to the contact and decrease away from it. Based on these results it is concluded that if P\u2032 is not controlled by Km, then the former can be used to gauge strain-intensity variations in ferromagnetic granites.", "num_citations": "43\n", "authors": ["257"]}
{"title": "Context2Name: A deep learning-based approach to infer natural variable names from usage contexts\n", "abstract": " Most of the JavaScript code deployed in the wild has been minified, a process in which identifier names are replaced with short, arbitrary and meaningless names. Minified code occupies less space, but also makes the code extremely difficult to manually inspect and understand. This paper presents Context2Name, a deep learningbased technique that partially reverses the effect of minification by predicting natural identifier names for minified names. The core idea is to predict from the usage context of a variable a name that captures the meaning of the variable. The approach combines a lightweight, token-based static analysis with an auto-encoder neural network that summarizes usage contexts and a recurrent neural network that predict natural names for a given usage context. We evaluate Context2Name with a large corpus of real-world JavaScript code and show that it successfully predicts 47.5% of all minified identifiers while taking only 2.9 milliseconds on average to predict a name. A comparison with the state-of-the-art tools JSNice and JSNaughty shows that our approach performs comparably in terms of accuracy while improving in terms of efficiency. Moreover, Context2Name complements the state-of-the-art by predicting 5.3% additional identifiers that are missed by both existing tools.", "num_citations": "40\n", "authors": ["257"]}
{"title": "CONCURRIT: A domain specific language for reproducing concurrency bugs\n", "abstract": " We present CONCURRIT, a domain-specific language (DSL) for reproducing concurrency bugs. Given some partial information about the nature of a bug in an application, a programmer can write a CONCURRIT script to formally and concisely specify a set of thread schedules to explore in order to find a schedule exhibiting the bug. Further, the programmer can specify how these thread schedules should be searched to find a schedule that reproduces the bug. We implemented CONCURRIT as an embedded DSL in C++, which uses manual or automatic source instrumentation to partially control the scheduling of the software under test. Using CONCURRIT, we were able to write concise tests to reproduce concurrency bugs in a variety of benchmarks, including the Mozilla's SpiderMonkey JavaScript engine, Memcached, Apache's HTTP server, and MySQL.", "num_citations": "38\n", "authors": ["257"]}
{"title": "The good, the bad, and the ugly: An empirical study of implicit type conversions in JavaScript\n", "abstract": " Most popular programming languages support situations where a value of one type is converted into a value of another type without any explicit cast. Such implicit type conversions, or type coercions, are a highly controversial language feature. Proponents argue that type coercions enable writing concise code. Opponents argue that type coercions are error-prone and that they reduce the understandability of programs. This paper studies the use of type coercions in JavaScript, a language notorious for its widespread use of coercions. We dynamically analyze hundreds of programs, including real-world web applications and popular benchmark programs. We find that coercions are widely used (in 80.42% of all function executions) and that most coercions are likely to be harmless (98.85%). Furthermore, we identify a set of rarely occurring and potentially harmful coercions that safer subsets of JavaScript or future language designs may want to disallow. Our results suggest that type coercions are significantly less evil than commonly assumed and that analyses targeted at real-world JavaScript programs must consider coercions.", "num_citations": "34\n", "authors": ["257"]}
{"title": "RADBench: A Concurrency Bug Benchmark Suite.\n", "abstract": " Testing and debugging tools for concurrent programs are often validated on known bugs. To aid the development of these tools, we present the Race, Atomicity, and Deadlock Benchmark (RADBench) suite. The RADBench suite contains the full source of 10 real concurrency bugs found in large open-source software projects including Mozilla SpiderMonkey, Mozilla NSPR, Memcached, Apache Web Server, and Google Chromium Web Browser. We discuss the difficulties we have found in reproducing these bugs that must be accounted for when building testing and debugging tools. Finally, we propose an approach to reproducibility that has a number of benefits over standard deterministic replay for debugging. RADBench is open source and publicly available.", "num_citations": "34\n", "authors": ["257"]}
{"title": "Predictive typestate checking of multithreaded java programs\n", "abstract": " Writing correct multithreaded programs is difficult. Existing tools for finding bugs in multithreaded programs primarily focus on finding generic concurrency problems such as data races, atomicity violations, and deadlocks. However, these generic bugs may sometimes be benign and may not help to catch other functional errors in multithreaded programs. In this paper, we focus on a high-level programming error, called typestate error, which happens when a program does not follow the correct usage protocol of an object. We present a novel technique that finds typestate errors in multithreaded programs by looking at a successful execution. An appealing aspect of our technique is that it not only finds typestate errors that occur during a program execution, but also many other typestate errors that could have occurred in a different execution. We have implemented this technique in a prototype tool for Java and have\u00a0\u2026", "num_citations": "34\n", "authors": ["257"]}
{"title": "Predictive testing: amplifying the effectiveness of software testing\n", "abstract": " Testing with manually generated test cases often results in poor coverage and fails to discover many corner case bugs and security vulnerabilities. Automated test generation techniques based on static or symbolic analysis usually do not scale beyond small program units. We propose predictive testing, a new method for amplifying the effectiveness of existing test cases using symbolic analysis. We assume that a software system has an associated test suite consisting of a set of test inputs and a set of program invariants, in the form of a set of assert statements that the software must always satisfy. Predictive testing uses a combination of concrete and symbolic execution, similar to concolic execution, on the provided test inputs to discover if any of the assertions encountered along a test execution path could be violated for some closely related inputs. We extend predictive testing to catch bugs related to memory-safety\u00a0\u2026", "num_citations": "32\n", "authors": ["257"]}
{"title": "TesMa and CATG: automated test generation tools for models of enterprise applications\n", "abstract": " We present CATG, an open-source concolic test generation tool for Java and its integration with TesMa, a model-based testing tool which automatically generates test cases from formal design documents. TesMa takes as input a set of design documents of an application under test. The design documents are provided in the form of database table definitions, process-flow diagrams, and screen definitions. From these design documents, TesMa creates Java programs for the feasible execution scenarios of the application. CATG performs concolic testing on these Java programs to generate suitable databases and test inputs required to test the application under test. A demo video of the tool is available at https://www.youtube.com/watch?v=9lEvPwR7g-Q.", "num_citations": "29\n", "authors": ["257"]}
{"title": "Modification of fabric in pre-Himalayan granitic rocks by post-emplacement ductile deformation: insights from microstructures, AMS, and U\u2013Pb geochronology of the Paleozoic\u00a0\u2026\n", "abstract": " The present day South Tibetan Detachment (STD) of Higher Himalaya is a system of low-angle normal faults. In the Himachal High Himalaya, the STD hanging wall is characterized by the presence of S-type per-aluminous Paleozoic (~475\u00a0Ma) granite called the Kinnaur Kailash Granite (KKG). This granite is later intruded by Cenozoic leucogranites (~18\u00a0Ma) in vicinity of the STD zone. In this work, microstructures, anisotropy of magnetic susceptibility (AMS), and U\u2013Pb geochronology were carried out on the KKG and the leucogranites with an aim to (a) understand the conditions of fabric development and (b) decipher the tectonic relationship between deformation along the STD and the evolution of these granites. Microstructural features and magnetic anisotropy indicate that the granites are intensely deformed in vicinity of the STD and preserve their emplacement-related fabric in the interior parts. It is\u00a0\u2026", "num_citations": "29\n", "authors": ["257"]}
{"title": "Eagle does space efficient ltl monitoring\n", "abstract": " We briefly present a rule-based framework, called EAGLE, that has been shown to be capable of defining and implementing finite trace monitoring logics, including future and past time temporal logic, extended regular expressions, real-time and metric temporal logics (MTL), interval logics, forms of quantified temporal logics, and so on. In this paper we show how EAGLE can perform linear temporal logic (LTL) monitoring in an efficient way. For an initial formula of size m, we establish upper bounds of O (m22m logm) and O (m422m log2 m) for the space and time complexity, respectively, of single step evaluation over an input trace. EAGLE has been successfully used, in both LTL and metric LTL forms, to test a real-time controller of an experimental NASA planetary rover.", "num_citations": "28\n", "authors": ["257"]}
{"title": "Specifying and checking semantic atomicity for multithreaded programs\n", "abstract": " In practice, it is quite difficult to write correct multithreaded programs due to the potential for unintended and nondeterministic interference between parallel threads. A fundamental correctness property for such programs is atomicity---a block of code in a program is atomic if, for any parallel execution of the program, there is an execution with the same overall program behavior in which the block is executed serially. We propose semantic atomicity, a generalization of atomicity with respect to a programmer-defined notion of equivalent behavior. We propose an assertion framework in which a programmer can use bridge predicates to specify noninterference properties at the level of abstraction of their application. Further, we propose a novel algorithm for systematically testing atomicity specifications on parallel executions with a bounded number of interruptions---i.e. atomic blocks whose execution is interleaved with\u00a0\u2026", "num_citations": "27\n", "authors": ["257"]}
{"title": "AutoPandas: neural-backed generators for program synthesis\n", "abstract": " Developers nowadays have to contend with a growing number of APIs. While in the long-term they are very useful to developers, many modern APIs have an incredibly steep learning curve, due to their hundreds of functions handling many arguments, obscure documentation, and frequently changing semantics. For APIs that perform data transformations, novices can often provide an I/O example demonstrating the desired transformation, but may be stuck on how to translate it to the API. A programming-by-example synthesis engine that takes such I/O examples and directly produces programs in the target API could help such novices. Such an engine presents unique challenges due to the breadth of real-world APIs, and the often-complex constraints over function arguments. We present a generator-based synthesis approach to contend with these problems. This approach uses a program candidate generator\u00a0\u2026", "num_citations": "25\n", "authors": ["257"]}
{"title": "RFUZZ: Coverage-directed fuzz testing of RTL on FPGAs\n", "abstract": " Dynamic verification is widely used to increase confidence in the correctness of RTL circuits during the pre-silicon design phase. Despite numerous attempts over the last decades to automate the stimuli generation based on coverage feedback, Coverage Directed Test Generation (CDG) has not found the widespread adoption that one would expect. Based on new ideas from the software testing community around coverage-guided mutational fuzz testing, we propose a new approach to the CDG problem which requires minimal setup and takes advantage of FPGA-accelerated simulation for rapid testing. We provide test input and coverage definitions that allow fuzz testing to be applied to RTL circuit verification. In addition we propose and implement a series of transformation passes that make it feasible to reset arbitrary RTL designs quickly, a requirement for deterministic test execution. Alongside this paper we\u00a0\u2026", "num_citations": "25\n", "authors": ["257"]}
{"title": "Platform-independent dynamic taint analysis for javascript\n", "abstract": " Previous approaches to dynamic taint analysis for JavaScript are implemented directly in a browser or JavaScript engine, limiting their applicability to a single platform and requiring ongoing maintenance as platforms evolve, or they require nontrivial program transformations. We present an approach that relies on instrumentation to encode taint propagation as instructions for an abstract machine. Our approach has two key advantages: it is  platform-independent  and can be used with any existing JavaScript engine, and it can track taint on primitive values without requiring the introduction of wrapper objects. Furthermore, our technique enables multiple deployment scenarios by varying when and where the generated instructions are executed and it supports  indirect taint sources , i.e., situations where taint enters an application via arguments passed to dynamically registered event-listener functions. We\u00a0\u2026", "num_citations": "25\n", "authors": ["257"]}
{"title": "NDSeq: Runtime checking for nondeterministic sequential specifications of parallel correctness\n", "abstract": " We propose to specify the correctness of a program's parallelism using a sequential version of the program with controlled nondeterminism. Such a nondeterministic sequential specification allows (1) the correctness of parallel interference to be verified independently of the program's functional correctness, and (2) the functional correctness of a program to be understood and verified on a sequential version of the program, one with controlled nondeterminism but no interleaving of parallel threads. We identify a number of common patterns for writing nondeterministic sequential specifications. We apply these patterns to specify the parallelism correctness for a variety of parallel Java benchmarks, even in cases when the functional correctness is far too complex to feasibly specify. We describe a sound runtime checking technique to validate that an execution of a parallel program conforms to its nondeterministic\u00a0\u2026", "num_citations": "25\n", "authors": ["257"]}
{"title": "DETERMIN: Inferring likely deterministic specifications of multithreaded programs\n", "abstract": " The trend towards multicore processors and graphic processing units is increasing the need for software that can take advantage of parallelism. Writing correct parallel programs using threads, however, has proven to be quite challenging due to nondeterminism. The threads of a parallel application may be interleaved nondeterministically during execution, which can lead to nondeterministic results---some interleavings may produce the correct result while others may not. We have previously proposed an assertion framework for specifying that regions of a parallel program behave deterministically despite nondeterministic thread interleaving. The framework allows programmers to write assertions involving pairs of program states arising from different parallel schedules.", "num_citations": "25\n", "authors": ["257"]}
{"title": "JQF: coverage-guided property-based testing in Java\n", "abstract": " We present JQF, a platform for performing coverage-guided fuzz testing in Java. JQF is designed both for practitioners, who wish to find bugs in Java programs, as well as for researchers, who wish to implement new fuzzing algorithms.", "num_citations": "24\n", "authors": ["257"]}
{"title": "Universal symbolic execution and its application to likely data structure invariant generation\n", "abstract": " Local data structure invariants are asserted over a bounded fragment of a data structure around a distinguished node M of the data structure. An example of such an invariant for a sorted doubly linked list is\" for all nodes M of the list, if M\u2260 null and M. next\u2260 null, then M. next. prev= M and M. value\u2264 M. next. value.\" It has been shown that such local invariants are both natural and sufficient for describing a large class of data structures. This paper explores a novel technique, called Krystal, to infer likely local data structure invariants using a variant of symbolic execution, called universal symbolic execution. Universal symbolic execution is like traditional symbolic execution except the fact that we create a fresh symbolic variable for every read of a lvalue that has no mapping in the symbolic state rather than creating a symbolic variable only for inputs. This helps universal symbolic execution to symbolically track data flow\u00a0\u2026", "num_citations": "24\n", "authors": ["257"]}
{"title": "Deep learning to find bugs\n", "abstract": " Automated bug detection, eg, through pattern-based static analysis, is an increasingly popular technique to find programming errors and other code quality issues. Traditionally, bug detectors are program analyses that are manually written and carefully tuned by an analysis expert. Unfortunately, the huge amount of possible bug patterns makes it difficult to cover more than a small fraction of all bugs. This paper presents a new approach toward creating bug detectors. The basic idea is to replace manually writing a program analysis with training a machine learning model that distinguishes buggy from non-buggy code. To address the challenge that effective learning requires both positive and negative training examples, we use simple code transformations that create likely incorrect code from existing code examples. We present a general framework, called DeepBugs, that extracts positive training examples from a code corpus, leverages simple program transformations to create negative training examples, trains a model to distinguish these two, and then uses the trained model for identifying programming mistakes in previously unseen code. As a proof of concept, we create four bug detectors for JavaScript that find a diverse set of programming mistakes, eg, accidentally swapped function arguments, incorrect assignments, and incorrect binary operations. To find bugs, the trained models use information that is usually discarded by program analyses, such as identifier names of variables and functions. Applying the approach to a corpus of 150,000 JavaScript files shows that learned bug detectors have a high accuracy, are very efficient, and reveal\u00a0\u2026", "num_citations": "23\n", "authors": ["257"]}
{"title": "Fuzzfactory: domain-specific fuzzing with waypoints\n", "abstract": " Coverage-guided fuzz testing has gained prominence as a highly effective method of finding security vulnerabilities such as buffer overflows in programs that parse binary data. Recently, researchers have introduced various specializations to the coverage-guided fuzzing algorithm for different domain-specific testing goals, such as finding performance bottlenecks, generating valid inputs, handling magic-byte comparisons, etc. Each such solution can require non-trivial implementation effort and produces a distinct variant of a fuzzing tool. We observe that many of these domain-specific solutions follow a common solution pattern.   In this paper, we present FuzzFactory, a framework for developing domain-specific fuzzing applications without requiring changes to mutation and search heuristics. FuzzFactory allows users to specify the collection of dynamic domain-specific feedback during test execution, as well as how\u00a0\u2026", "num_citations": "21\n", "authors": ["257"]}
{"title": "Jalangi: a tool framework for concolic testing, selective record-replay, and dynamic analysis of JavaScript\n", "abstract": " We describe a tool framework, called Jalangi, for dynamic analysis and concolic testing of JavaScript programs. The framework is written in JavaScript and allows implementation of various heavy-weight dynamic analyses for JavaScript. Jalangi incorporates two key techniques: 1) selective record-replay, a technique which enables to record and to faithfully replay a user-selected part of the program, and 2) shadow values and shadow execution, which enables easy implementation of heavy-weight dynamic analyses such as concolic testing and taint tracking. Jalangi works through source-code instrumentation which makes it portable across platforms. Jalangi is available at https://github. com/SRA-SiliconValley/jalangi under Apache 2.0 license. Our evaluation of Jalangi on the SunSpider benchmark suite and on five web applications shows that Jalangi has an average slowdown of 26X during recording and 30X\u00a0\u2026", "num_citations": "21\n", "authors": ["257"]}
{"title": "DART: Directed Automated Random Testing.\n", "abstract": " DART: Directed Automated Random Testing Page 1 DART: Directed Automated Random Testing Koushik Sen University of Illinois Urbana-Champaign Joint work with Patrice Godefroid and Nils Klarlund Page 2 2 Software Testing \u220e Testing accounts for 50% of software development cost \u220e Software failure costs USA $60 billion annually \u2751 Improvement in software testing infrastructure can save one-third of this cost \u201cThe economic impacts of inadequate infrastructure for software testing\u201d, NIST, May, 2002 \u220e Currently, software testing is mostly done manually Page 3 3 Simple C code int double(int x) { return 2 * x; } void test_me(int x, int y){ int z = double(x); if(z==y){ if(x != y+10){ printf(\u201cI am fine here\u201d); } else { printf(\u201cI should not reach here\u201d); abort(); } } Page 4 4 Automatic Extraction of Interface \u220e Automatically determine (code parsing) \u2751 inputs to the program \u220e arguments to the entry function \u2751 variables: whose value on : \u2026", "num_citations": "21\n", "authors": ["257"]}
{"title": "{PARTEMU}: Enabling Dynamic Analysis of Real-World TrustZone Software Using Emulation\n", "abstract": " ARM's TrustZone technology is the basis for security of billions of devices worldwide, including Android smartphones and IoT devices. Because TrustZone has access to sensitive information such as cryptographic keys, access to TrustZone has been locked down on real-world devices: only code that is authenticated by a trusted party can run in TrustZone. A side-effect is that TrustZone software cannot be instrumented or monitored. Thus, recent advances in dynamic analysis techniques such as feedback-driven fuzz testing have not been applied to TrustZone software. To address the above problem, this work builds an emulator that runs four widely-used, real-world TrustZone operating systems (TZOSes)-Qualcomm's QSEE, Trustonic's Kinibi, Samsung's TEEGRIS, and Linaro's OP-TEE-and the trusted applications (TAs) that run on them. The traditional challenge for this approach is that the emulation effort required is often impractical. However, we find that TZOSes depend only on a limited subset of hardware and software components. By carefully choosing a subset of components to emulate, we find we are able to make the effort practical. We implement our emulation on PARTEMU, a modular framework we develop on QEMU and PANDA. We show the utility of PARTEMU by integrating feedback-driven fuzz-testing using AFL and use it to perform a large-scale study of 194 unique TAs from 12 different Android smartphone vendors and a leading IoT vendor, finding previously unknown vulnerabilities in 48 TAs, several of which are exploitable. We identify patterns of developer mistakes unique to TrustZone development that cause some of these\u00a0\u2026", "num_citations": "20\n", "authors": ["257"]}
{"title": "U-Pb geochronology and geochemistry from the Kumaun Himalaya, NW India, reveal Paleoproterozoic arc magmatism related to formation of the Columbia supercontinent\n", "abstract": " Columbia was a Proterozoic supercontinent that formed \u223c2.0 b.y. ago by amalgamation of almost all the present-day continental blocks. One major controversy regarding the formation of this supercontinent is the position and tectonic setting of the north Indian continental margin during this amalgamation. One school of thought suggests that this margin remained passive throughout the continental accretion process, and another school contradicts that by suggesting subduction and an active continental arc setting. The Paleoproterozoic basement rocks of the Himalaya consist of granitic gneisses from the Lesser Himalayan Sequence that belonged to the north Indian continental margin during the formation of Columbia. In this work, we present bulk-rock geochemistry and U-Pb geochronology of zircon from augen gneisses of the Lesser Himalayan Munsiari Formation and granite gneisses of the Chiplakot\u00a0\u2026", "num_citations": "20\n", "authors": ["257"]}
{"title": "40Ar\u201339Ar age constraint on deformation and brittle\u2013ductile transition of the Main Central Thrust and the South Tibetan Detachment zone from Dhauliganga valley, Garhwal\u00a0\u2026\n", "abstract": " 40Ar\u201339Ar data from two sets of mylonitic two-mica granites present in the Main Central Thrust (MCT) and one leucogranite from the South Tibetan Detachment (STD) of Dhauliganga valley, Garhwal Himalaya are presented. The MCT and the STD bound the High Himalayan Crystallines (HHC) and are believed to facilitate its extrusion. Field evidence of ductile deformation in the form of tight isoclinal folding and brittle deformation in the form of back thrusts and transverse fractures are observed. The STD zone shows evidence of pervasive migration of leucogranitic melt through north dipping extensional shear zones. The \u223c19.5\u00a0Ma old Malari Leucogranite, present adjacent to the STD zone, experienced ductile and brittle deformation related to the tectonics of the STD. Muscovite analysis from the Malari leucogranite gives a cooling age of \u223c15.2\u00a0Ma suggesting that ductile deformation in the STD zone may have\u00a0\u2026", "num_citations": "20\n", "authors": ["257"]}
{"title": "Interplay of deformation and magmatism in the Pangong Transpression Zone, eastern Ladakh, India: Implications for remobilization of the trans-Himalayan magmatic arc and\u00a0\u2026\n", "abstract": " In the eastern part of Ladakh, the right-lateral Karakoram Fault Zone (KFZ) bifurcates into two strands called the Pangong Strand and the Tangtse Strand. These two strands bound a region called the Pangong Transpression Zone (PTZ), which consists of migmatitic dioritic gneiss, calc-silicates and the Durbuk Pluton; a pluton of two-mica leucogranite. Outcrop scale observations suggest pervasive migration of leucogranitic melt through the existing tectonic structures of the gneiss. Magnetic fabric from both the tectonized and undeformed parts of the Durbuk Pluton show parallelism with the tectonic fabric of the host gneiss, which, along with pervasive melt migration, indicates syn-kinematic relationship between deformation along the KFZ, leucogranite magmatism and emplacement of the Durbuk Pluton. U\u2013Pb geochronology of zircons from the dioritic gneiss yields a crystallization age of 63.6\u00a0\u00b1\u00a01.5\u00a0Ma and also shows\u00a0\u2026", "num_citations": "20\n", "authors": ["257"]}
{"title": "Travioli: A dynamic analysis for detecting data-structure traversals\n", "abstract": " Traversal is one of the most fundamental operations on data structures, in which an algorithm systematically visits some or all of the data items of a data structure. We propose a dynamic analysis technique, called Travioli, for detecting data-structure traversals. We introduce the concept of acyclic execution contexts, which enables precise detection of traversals of arrays and linked data structures such as lists and trees in the presence of both loops and recursion. We describe how the information reported by Travioli can be used for visualizing data-structure traversals, manually generating performance regression tests, and for discovering performance bugs caused by redundant traversals. We evaluate Travioli on five real-world JavaScript programs. In our experiments, Travioli produced fewer than 4% false positives. We were able to construct performance tests for 93.75% of the reported true traversals. Travioli also\u00a0\u2026", "num_citations": "19\n", "authors": ["257"]}
{"title": "Dextral transpression and late Eocene magmatism in the trans-Himalayan Ladakh Batholith (North India): implications for tectono-magmatic evolution of the Indo-Eurasian\u00a0\u2026\n", "abstract": " The trans-Himalayan Ladakh batholith is a result of arc magmatism caused by the northward subduction of the Tethyan oceanic lithosphere below the edge of the Eurasian plate. The batholith dominantly consists of calc-alkaline I-type granitoids which are ferromagnetic in nature with the presence of magnetite as the principal carrier of magnetic susceptibility. The mesoscopic and magnetic fabric are concordant and generally vary from WNW\u2013ESE to ENE\u2013WSW for different intrusions of ferromagnetic granites in different parts of the batholith. Strike of magnetic fabric is roughly parallel with the regional trend of the Ladakh batholith in the present study area and is orthogonal to the direction of India-Eurasia collision. In Khardungla and Changla section, the magnetic fabric is distributed in a sigmoidal manner. It is inferred that this sigmoidal pattern is caused by shearing due to transpression induced by oblique\u00a0\u2026", "num_citations": "19\n", "authors": ["257"]}
{"title": "Characterizing the intracrustal low velocity zone beneath northwest India\u2013Asia collision zone\n", "abstract": " Teleseismic data recorded at 13 broad-band seismological stations across northwest part of the Tethyan Himalaya and eastern Ladakh are analysed to determine the seismic characteristics of the crust and upper mantle beneath the northwest India\u2013Asia collision zone. The receiver functions computed from teleseismic P-waveform for a wide range of backazimuth show strong azimuthal variation in the Indus suture zone (ISZ), the zone which marks the collision and subsequent subduction of both the Tethyan oceanic plate and Indian continental plate beneath Eurasia. The teleseismic waves piercing the ISZ do not show clear P-to-S (Ps) converted phase at the depth of Moho. In contrast, the waves piercing the Karakoram zone, Ladakh batholith and the Tethyan Himalayan region south of the ISZ clearly show the Moho converted Ps phase and corresponding inverted models reveal variation of crustal thickness\u00a0\u2026", "num_citations": "18\n", "authors": ["257"]}
{"title": "DetReduce: minimizing Android GUI test suites for regression testing\n", "abstract": " In recent years, several automated GUI testing techniques for Android apps have been proposed. These tools have been shown to be effective in achieving good test coverage and in finding bugs without human intervention. Being automated, these tools typically run for a long time (say, for several hours), either until they saturate test coverage or until a testing time budget expires. Thus, these automated tools are not good at generating concise regression test suites that could be used for testing in incremental development of the apps and in regression testing. We propose a heuristic technique that helps create a small regression test suite for an Android app from a large test suite generated by an automated Android GUI testing tool. The key insight behind our technique is that if we can identify and remove some common forms of redundancies introduced by existing automated GUI testing tools, then we can\u00a0\u2026", "num_citations": "17\n", "authors": ["257"]}
{"title": "Concurrent breakpoints\n", "abstract": " In program debugging, reproducibility of bugs is a key requirement. Unfortunately, bugs in concurrent programs are notoriously difficult to reproduce because bugs due to concurrency happen under very specific thread schedules and the likelihood of taking such corner-case schedules during regular testing is very low. We propose concurrent breakpoints, a light-weight and programmatic way to make a concurrency bug reproducible. We describe a mechanism that helps to hit a concurrent breakpoint in a concurrent execution with high probability. We have implemented concurrent breakpoints as a light-weight library for Java and C/C++ programs. We have used the implementation to deterministically reproduce several known non-deterministic bugs in real-world concurrent Java and C/C++ programs with almost 100% probability.", "num_citations": "17\n", "authors": ["257"]}
{"title": "Eagle monitors by collecting facts and generating obligations\n", "abstract": " We present a rule-based framework, called EAGLE, that has been shown to be capable of defining and implementing a range of finite trace monitoring logics, including future and past time temporal logic, extended regular expressions, real-time and metric temporal logics, interval logics, forms of quantified temporal logics, and so on. A monitor for an EAGLE formula checks if a finite trace of states satisfies the given formula. We present, in details, an algorithm for the synthesis of monitors for EAGLE. The algorithm is implemented as a Java application and involves novel techniques for rule definition, manipulation and execution. Monitoring is achieved on a state-by-state basis avoiding any need to store the input trace of states. Our initial experiments have been successful as EAGLE detected a previously unknown bug while testing a planetary rover controller.", "num_citations": "17\n", "authors": ["257"]}
{"title": "{CONCURRIT}: Testing Concurrent Programs with Programmable State-Space Exploration\n", "abstract": " Testing is the most widely-used methodology for software validation. However, due to the nondeterministic interleavings of threads, traditional testing for concurrent programs is not as effective as for sequential programs. To attack the nondeterminism problem, software model checking techniques have been used to systematically enumerate all possible thread schedules of a test program. But such systematic and exhaustive exploration is typically too time-consuming for many test programs. We believe that the programmer\u2019s help to guide the model checker towards interesting executions is critical to circumvent this problem.", "num_citations": "16\n", "authors": ["257"]}
{"title": "Optimal test input sequence generation for finite state models and pushdown systems\n", "abstract": " Finite state machines and pushdown systems are frequently used in model based testing. In such testing, the system under test is abstractly modeled as a finite state machine having a finite set of states and a labeled transition relation between the states. A pushdown system, additionally, has an unbounded stack. Test inputs are then generated by enumerating a set of sequences of transitions labels from the model. There has been a lot of research that focussed on generation of test input sequences satisfying various coverage criteria. In this paper, we consider the problem of generating a set of test input sequences that satisfy certain coverage criteria-cover all transition labels or cover all length-n transition label sequences at least once-while minimizing the sum of the length of the sequences in the set. We show that these optimal test input generation problems can be reduced to integer linear programming (ILP\u00a0\u2026", "num_citations": "16\n", "authors": ["257"]}
{"title": "Composite mesoscopic and magnetic fabrics of the Paleo-Proterozoic Wangtu Gneissic Complex, Himachal Himalaya, India: implications for ductile deformation and superposed\u00a0\u2026\n", "abstract": " The present study demonstrates how the Paleo-Proterozoic Wangtu Gneissic Complex (WGC) of the Lesser Himalayan Crystalline sequence experienced superposed folding and doming prior to its exhumation, with the help of integrated field, microstructural, magnetic fabric anisotropy and geochronological studies. The WGC forms the basement of the Lesser Himalaya and is bounded by Vaikrita Thrust (VT) to the northeast and Munsiari Thrust (MT) to the southwest. The regional structure consists of upright large scale early folds (D1) trending NW\u2013SE. The mesoscopic fabric is related to axial plane foliation of the D1 folds and, to a lesser extent, late D2 folds. The axis of maximum compression for D1 and D2 folds are mutually orthogonal. The D1 folds have formed simultaneously with the major Himalayan thrusts whereas the D2 folds have developed during a later deformation event. The magnetic lineation at the\u00a0\u2026", "num_citations": "14\n", "authors": ["257"]}
{"title": "Scaling data race detection for partitioned global address space programs\n", "abstract": " Contemporary and future programming languages for HPC promote hybrid parallelism and shared memory abstractions using a global address space. In this programming style, data races occur easily and are notoriously hard to find. Existing state-of-the-art data race detectors exhibit 10X-100X performance degradation and do not handle hybrid parallelism. In this paper we present the first complete implementation of data race detection at scale for UPC programs. Our implementation tracks local and global memory references in the program and it uses two techniques to reduce the overhead: 1) hierarchical function and instruction level sampling; and 2) exploiting the runtime persistence of aliasing and locality specific to Partitioned Global Address Space applications. The results indicate that both techniques are required in practice: well optimized instruction sampling introduces overheads as high as 6500%(65X\u00a0\u2026", "num_citations": "13\n", "authors": ["257"]}
{"title": "Structural and magnetic fabric studies of recess structures in the western Himalaya: Implications for 1905 Kangra earthquake\n", "abstract": " Kinematic information from deformation structures and magnetic fabrics are used to infer recent tectonics around Kangra and Dehradun recesses, western Himalaya. Three types of magnetic fabrics (Type I & II, III, and IV) are identified based on the angle between K3 axis and bedding pole. It was observed that Kangra recess shows more mature fabric type IV as compared to Dehradun recess, where orientation of K3 axes and tectonic fabric reveals dominance of superposed deformation. In the vicinity of Dehradun recess, normal faults occur in un-indurated Quaternary fan deposits confirming their recent formation. The observations are in conformity with earlier studies that during the 1905 Kangra earthquake, the Main Boundary Thrust (MBT) (or one of its subsidiary thrusts) near Kangra showed thrusting whereas the MBT near Dehradun underwent either normal faulting or post seismic adjustments\u00a0\u2026", "num_citations": "13\n", "authors": ["257"]}
{"title": "Qfast: Quantum synthesis using a hierarchical continuous circuit space\n", "abstract": " We present QFAST, a quantum synthesis tool designed to produce short circuits and to scale well in practice. Our contributions are: 1) a novel representation of circuits able to encode placement and topology; 2) a hierarchical approach with an iterative refinement formulation that combines \"coarse-grained\" fast optimization during circuit structure search with a good, but slower, optimization stage only in the final circuit instantiation stage. When compared against state-of-the-art techniques, although not optimal, QFAST can generate much shorter circuits for \"time dependent evolution\" algorithms used by domain scientists. We also show the composability and tunability of our formulation in terms of circuit depth and running time. For example, we show how to generate shorter circuits by plugging in the best available third party synthesis algorithm at a given hierarchy level. Composability enables portability across chip architectures, which is missing from the available approaches.", "num_citations": "12\n", "authors": ["257"]}
{"title": "Exhumation history of the Karakoram fault zone mylonites: New constraints from microstructures, fluid inclusions, and 40Ar-39Ar analyses\n", "abstract": " The Karakoram fault zone is a dextral strike-slip fault bounded by the Pangong and Tangtse strands on its NE and SW flanks, respectively. In the Tangtse shear zone, the microstructures of mylonitic leucogranite exhibit superposition of high-temperature deformation followed by low-temperature deformation. The mylonites show fluid immiscibility, containing brine and carbonic inclusions. The occurrence of carbonic- and brine-rich inclusions in the oscillatory-zoned plagioclase indicates that they were trapped during the formation of the leucogranite. Eventually, these fluids recorded a near-isobaric drop in temperature down to <450 \u00b0C at the amphibolite-greenschist facies transition, when the zone of fluid mixing was established. The 40Ar-39Ar biotite ages indicate that the area cooled down to 400\u2013350 \u00b0C over 10.34\u20139.48 Ma, and this period also coincides with a major phase of fluid infiltration and trapping of\u00a0\u2026", "num_citations": "12\n", "authors": ["257"]}
{"title": "Mesoscopic and magnetic fabrics in arcuate igneous bodies: an example from the Mandi-Karsog pluton, Himachal Lesser Himalaya\n", "abstract": " Field, microstructural and anisotropy of magnetic susceptibility (AMS) data from the Palaeozoic Mandi-Karsog pluton in the Lesser Himalayan region reveal a concordant relationship between fabric of the Proterozoic host rock and the granite. The pluton displays a prominent arcuate shape on the geological map. The margin-parallel mesoscopic and magnetic fabrics of the granite and warping of the host rock fabric around the pluton indicate that this regional curvature is either synchronous or pre-dates the emplacement of the granite body. Mesoscopic fabric, magnetic fabric and microstructures indicate that the northern part of the pluton preserves its pre-Himalayan magmatic fabric while the central and southern part shows tectonic fabric related to the Tertiary Himalayan orogeny. The presence of NW\u2013SE-trending aplitic veins within the granite indicates a post-emplacement stretching in the NE\u2013SW direction. Shear\u00a0\u2026", "num_citations": "12\n", "authors": ["257"]}
{"title": "Heuristics for quantum compiling with a continuous gate set\n", "abstract": " We present an algorithm for compiling arbitrary unitaries into a sequence of gates native to a quantum processor. As accurate CNOT gates are hard for the foreseeable Noisy- Intermediate-Scale Quantum devices era, our A* inspired algorithm attempts to minimize their count, while accounting for connectivity. We discuss the search strategy together with metrics to expand the solution frontier. For a workload of circuits with complexity appropriate for the NISQ era, we produce solutions well within the best upper bounds published in literature and match or exceed hand tuned implementations, as well as other existing synthesis alternatives. In particular, when comparing against state-of-the-art available synthesis packages we show 2.4x average (up to 5.3x) reduction in CNOT count. We also show how to re-target the algorithm for a different chip topology and native gate set, while obtaining similar quality results. We believe that empirical tools like ours can facilitate algorithmic exploration, gate set discovery for quantum processor designers, as well as providing useful optimization blocks within the quantum compilation tool-chain.", "num_citations": "11\n", "authors": ["257"]}
{"title": "Barrier elision for production parallel programs\n", "abstract": " Large scientific code bases are often composed of several layers of runtime libraries, implemented in multiple programming languages. In such situation, programmers often choose conservative synchronization patterns leading to suboptimal performance. In this paper, we present context-sensitive dynamic optimizations that elide barriers redundant during the program execution. In our technique, we perform data race detection alongside the program to identify redundant barriers in their calling contexts; after an initial learning, we start eliding all future instances of barriers occurring in the same calling context. We present an automatic on-the-fly optimization and a multi-pass guided optimization. We apply our techniques to NWChem--a 6 million line computational chemistry code written in C/C++/Fortran that uses several runtime libraries such as Global Arrays, ComEx, DMAPP, and MPI. Our technique elides a\u00a0\u2026", "num_citations": "11\n", "authors": ["257"]}
{"title": "Field and microstructural analysis of the Pangong Granodiorite, Ladakh (NW India): implications for tectonics along the Karakoram Fault Zone\n", "abstract": " The Pangong Migmatite\u2013Granodiorite (PMG) constitutes an important component of the Karakoram Fault Zone (KFZ). Field investigations reveal that the granodiorites were emplaced as the leucosome part of the migmatite escaped from the system due to noncoaxial deformation. Later on they were intruded by felsic veins, which subsequently suffered brittle deformation. Microstructures show the presence of microfracturing of plagioclase phenocrysts and bulging recrystallization of quartz. Backscattered electron images reveal that the area reduction of plagioclase had taken place by fracturing and replacement of Na by K in its rim and fractures. These indicate a solid state deformation under Greenschist facies. Based on these findings, it has been inferred that the PMG was emplaced during simple shear regime and later, along with the felsic veins that intruded it, was subjected to low-temperature near-surface\u00a0\u2026", "num_citations": "11\n", "authors": ["257"]}
{"title": "Age and geochemistry of the Paleoproterozoic Bhatwari Gneiss of Garhwal Lesser Himalaya, NW India: implications for the pre-Himalayan magmatic history of the Lesser Himalayan\u00a0\u2026\n", "abstract": " The Bhatwari Gneiss of Bhagirathi Valley in the Garhwal Himalaya is a Paleoproterozoic crystalline rock from the Inner Lesser Himalayan Sequence. On the basis of field and petrographic analyses, we have classified the Bhatwari Gneiss into two parts: the Lower Bhatwari Gneiss (LBG) and the Upper Bhatwari Gneiss (UBG). The geochemical signatures of these rocks suggest a monzonitic protolith for the LBG and a granitic protolith for the UBG. The UBG has a calc-alkaline S-type granitoid protolith, whereas the LBG has an alkaline I-type granitoid protolith; the UBG is more fractionated. The trace element concentrations suggest a volcanic arc setting for the LBG and a within-plate setting for the UBG. The U\u2013Pb geochronology of one sample from the LBG gives an upper intercept age of 1988 \u00b1 12 Ma (n = 10, MSWD = 2.5). One sample from the UBG gives an upper intercept age of 1895 \u00b1 22 Ma (n = 15, MSWD = 0\u00a0\u2026", "num_citations": "10\n", "authors": ["257"]}
{"title": "Migmatization and intrusion of \u201cS\u2010type\u201d granites in the trans\u2010H imalayan L adakh Magmatic Arc of north I ndia and their bearing on I ndo\u2010E urasian collisional tectonics\n", "abstract": " The Ladakh Magmatic Arc (LMA) of trans\u2010Himalaya was formed due to subduction of the Tethyan Ocean beneath the Eurasian continental plate. This was followed by the Indo\u2010Eurasian continental collision that gave rise to the Himalayan orogen. In this work, we present results from U\u2013Pb geochronology of zircon of 2 samples from a previously unknown migmatite body within the LMA and one two\u2010mica granite body that lies adjacent to this migmatite and intrudes the LMA. One sample of mesosome from this migmatite gives a crystallization age of 66.9\u00a0\u00b1\u00a01.5\u00a0Ma (n\u00a0=\u00a011 zircon) along with a younger population of zircon (n\u00a0=\u00a024) giving an age of 62.1\u00a0\u00b1\u00a01.3\u00a0Ma. This sample also shows the presence of a younger cluster of zircon (n\u00a0=\u00a07) giving a concordant age of 50.0\u00a0\u00b1\u00a02.9\u00a0Ma. The other sample of one leucosome contains a cluster of inherited zircon (n\u00a0=\u00a05) giving a concordant age of 72.86\u00a0\u00b1\u00a00.83\u00a0Ma. However, the\u00a0\u2026", "num_citations": "10\n", "authors": ["257"]}
{"title": "Seismotectonics of the Trans-Himalaya, Eastern Ladakh, India: Constraints from moment tensor solutions of local earthquake data\n", "abstract": " The seismotectonic scenario of the northwest part of the India-Asia collision zone is studied by analyzing the local earthquake data (M\u00a0~\u00a01.4\u20134.3) recorded by a broadband seismological network consisting of 14 stations. Focal Mechanism Solutions (FMSs) of 13 selected earthquakes were computed through waveform inversion of three-component broadband records. Depth distribution of the earthquakes and FMSs of local earthquakes obtained by waveform inversion reveal kinematics of the major fault zones present in eastern Ladakh. A most pronounced cluster of seismicity is observed in the Karakoram Fault (KF) zone down to a depth of ~\u00a065\u00a0km. The FMSs reveal a transpressive environment with an inferred strike slip fault plane parallel to the KF. It is argued that the KF penetrates down to the lower crust and is a manifestation of active underthrusting of Indian lower crust beneath Tibet. Two clusters of\u00a0\u2026", "num_citations": "10\n", "authors": ["257"]}
{"title": "Mosquito vector management knowledge, attitude, practices and future of user & environment friendly new generation botanical mosquitocide formulations: A review\n", "abstract": " Mosquitoes are among the most disturbing blood sucking insects afflicting human beings. Several mosquito species belonging to genera Anopheles, Culex and Aedes are vectors for the pathogens of various diseases like Dengue fever, Malaria, Yellow fever, Japanese Encephalitis and several other infections. Mosquitoes alone transmit diseases to more than 700 million people and over one million deaths are reported annually across the globe. Malaria which is caused by Plasmodium parasites transmitted through the bites of female Anopheles mosquitoes continues to impart a major disease burden on infants and young children in endemic regions [1]. The Aedes aegypti mosquito which spreads Dengue fever is responsible for more than 100 million infections worldwide every year, leading to thousands of deaths and more than 2.5 billion people or over 40% of the world\u2019s population are now at risk of Dengue. Having a mosquito infestation in close proximity to you and your family is an extremely dangerous situation and can be fatal. The risk of mosquito-borne diseases is especially high in humid areas. In the more arid regions of India, mosquito infestation commonly peak during and after the annual monsoon rainfalls. In the more tropic and humid regions, the peak of mosquito activity normally falls into the summers, when high temperatures fasten the reproductive cycle of mosquitoes. Therefore, the control of mosquitoes is an important public health concern around the world.The use of synthetic adulticides for mosquito control is not advisable owing to environmental hazards and prohibitive cost. Personal protection measures such as using\u00a0\u2026", "num_citations": "10\n", "authors": ["257"]}
{"title": "Towards Automatically Checking Thousands of Failures with Micro-specifications.\n", "abstract": " Recent data-loss incidents have shown that existing large distributed systems are still vulnerable to failures. To improve the situation, we propose two new testing approaches: failure testing service (FTS) and declarative testing specification (DTS). FTS enables us to systematically push a system into thousands of failure scenarios, leading us to many critical recovery bugs. With DTS, we introduce \u201cmicro-specifications\u201d, clear and concise specifications written in Datalog style, which enables developers to easily write, refine, and manage potentially hundreds of specifications.", "num_citations": "10\n", "authors": ["257"]}
{"title": "Towards optimal topology aware quantum circuit synthesis\n", "abstract": " We present an algorithm for compiling arbitrary unitaries into a sequence of gates native to a quantum processor. As CNOT gates are error-prone for the foreseeable Noisy-Intermediate-Scale Quantum devices era, our A* inspired algorithm minimizes their count while accounting for connectivity. We discuss the formulation of synthesis as a search problem as well as an algorithm to find solutions. For a workload of circuits with complexity appropriate for the NISQ era, we produce solutions well within the best upper bounds published in literature and match or exceed hand tuned implementations, as well as other existing synthesis alternatives. In particular, when comparing against state-of-the-art available synthesis packages we show 2.4\u00d7 average (up to 5.3\u00d7) reduction in CNOT count. We also show how to re-target the algorithm for a different chip topology and native gate set while obtaining similar quality results\u00a0\u2026", "num_citations": "9\n", "authors": ["257"]}
{"title": "SMTsampler: efficient stimulus generation from complex SMT constraints\n", "abstract": " Stimulus generation is an essential part of hardware verification, being at the core of widely applied constrained-random verification techniques. However, as verification problems get more and more complex, so do the constraints which must be satisfied. In this context, it is a challenge to efficiently generate random stimuli which can achieve a good coverage of the design space. We developed a new technique SMTSAMPLER which can sample random solutions from Satisfiability Modulo Theories (SMT) formulas with bit-vectors, arrays, and uninterpreted functions. The technique uses a small number of calls to a constraint solver in order to generate up to millions of stimuli. Our evaluation on a large set of complex industrial SMT benchmarks shows that SMTSAMPLER can handle a larger class of SMT problems, outperforming state-of-the-art constraint sampling techniques in the number of samples produced and\u00a0\u2026", "num_citations": "9\n", "authors": ["257"]}
{"title": "GuideSE: Annotations for guiding concolic testing\n", "abstract": " Dynamic symbolic execution or concolic testing has been proposed recently to effectively generate test inputs for real-world programs. Unfortunately, dynamic symbolic execution techniques do not scale well for large realistic programs, because often the number of feasible execution paths of a program increases exponentially with the increase in the length of an execution path. We believe that programmers usually have a good understanding of programs they write and could help concolic testing to guide path exploration effectively so that concolic testing can achieve the desired testing goal quickly. In this paper, we propose a simple annotation mechanism, called Guide SE, that enables a programmer to guide concolic testing by annotating the program under test. We have currently identified three mechanisms for providing these annotations: control annotations, equivalence annotations, and data annotations\u00a0\u2026", "num_citations": "9\n", "authors": ["257"]}
{"title": "Bimodal stable isotope signatures of Zildat Ophiolitic M\u00e9lange, Indus Suture Zone, Himalaya: implications for emplacement of an ophiolitic m\u00e9lange in a convergent setup\n", "abstract": " Zildat Ophiolitic M\u00e9lange (ZOM) of the Indus Suture Zone, Himalaya, represents tectonic blocks of the fragmented oceanic metasediments and ophiolite remnants. The ZOM is sandwiched between the Zildat fault adjacent to a gneissic dome known as Tso Morari Crystalline (TMC) and thin sliver of an ophiolite called as the Nidar Ophiolitic Complex. The ZOM contain chaotic low-density lithologies of metamorphosed oceanic sediments and hydrated mantle rocks, in which carbonates are present as mega-clasts ranging from 100 meters to few centimeters in size. In this work, calcite microstructures, fluid inclusion petrography and stable isotope analyses of carbonates were carried out to envisage the emplacement history of the ZOM. Calcite microstructure varies with decreasing temperature and increasing intensity of deformation. Intense shearing is seen at the marginal part of the m\u00e9lange near Zildat fault\u00a0\u2026", "num_citations": "9\n", "authors": ["257"]}
{"title": "A survey on analysis of selected cryptographic primitives and security protocols in symbolic model and computational model\n", "abstract": " Security protocols and cryptographic primitive play a very important role in information security world. People have paid a serious attention to the methods to verify security properties in security protocols and cryptographic primitives. From 1980's two distinct approaches: Symbolic approach and computational approach have been proposedd for it. Recently, significant advances have been made in verification on security properties in security protocols and cryptographic primitives and these two approaches. In this study we survey the existing results on the fields including symmetric encryption, public key encryption, digital signature, hush function, secrecy, key cycles, information flow, secrecy, automatic proof, deniable authentication protocol, electronic payment protocol and internet voting protocol in symbolic model and computational model. The survey processes in two lines: One line follows the trace of\u00a0\u2026", "num_citations": "9\n", "authors": ["257"]}
{"title": "Quickly generating diverse valid test inputs with reinforcement learning\n", "abstract": " Property-based testing is a popular approach for validating the logic of a program. An effective property-based test quickly generates many diverse valid test inputs and runs them through a parameterized test driver. However, when the test driver requires strict validity constraints on the inputs, completely random input generation fails to generate enough valid inputs. Existing approaches to solving this problem rely on whitebox or greybox information collected by instrumenting the input generator and/or test driver. However, collecting such information reduces the speed at which tests can be executed. In this paper, we propose and study a black-box approach for generating valid test inputs. We first formalize the problem of guiding random input generators towards producing a diverse set of valid inputs. This formalization highlights the role of a guide which governs the space of choices within a random input\u00a0\u2026", "num_citations": "8\n", "authors": ["257"]}
{"title": "Zest: Validity fuzzing and parametric generators for effective random testing\n", "abstract": " Programs expecting structured inputs often consist of both a syntactic analysis stage in which raw input is parsed into an internal data structure and a semantic analysis stage which conducts checks on this data structure and executes the core logic of the program. Existing random testing methodologies, like coverage-guided fuzzing (CGF) and generator-based fuzzing, tend to produce inputs that are rejected early in one of these two stages. We propose Zest, a random testing methodology that effectively explores the semantic analysis stages of such programs. Zest combines two key innovations to achieve this. First, we introduce validity fuzzing, which biases CGF towards generating semantically valid inputs. Second, we introduce parametric generators, which convert input from a simple parameter domain, such as a sequence of numbers, into a more structured domain, such as syntactically valid XML. These generators enable parameter-level mutations to map to structural mutations in syntactically valid test inputs. We implement Zest in Java and evaluate it against AFL and QuickCheck, popular CGF and generator-based fuzzing tools, on six real-world benchmarks: Apache Maven, Ant, and BCEL, ScalaChess, the Google Closure compiler, and Mozilla Rhino. We find that Zest achieves the highest coverage of the semantic analysis stage for five of these benchmarks. Further, we find 18 new bugs across the benchmarks, including 7 bugs that are uniquely found by Zest.", "num_citations": "8\n", "authors": ["257"]}
{"title": "Application of anisotropy of magnetic susceptibility (AMS) in understanding regional deformation, fabric development and granite emplacement: examples from Indian cratons\n", "abstract": " In this paper the authors review various applications of analysing fabric in granites from Indian cratons using anisotropy of magnetic susceptibility (AMS). First the general importance of AMS in identifying the internal fabric in massive granitoids devoid of visible foliations/lineations is highlighted. Subsequently, three important applications of AMS in granitoids are discussed. (a) The case of Godhra Granite (southern parts of the Aravalli Mountain Belt) is presented as an example of the robustness of AMS in working out the time relationship between emplacement/fabric development and regional deformation by integrating field, microstructural and magnetic data. (b) AMS orientation data from Chakradharpur Granitoid (eastern India) are compared with field-based information from the vicinity of the Singhbhum Shear Zone to highlight the use of AMS in kinematic analysis and vorticity quantification of syntectonic\u00a0\u2026", "num_citations": "7\n", "authors": ["257"]}
{"title": "Incidence study of yellow mite and thrips and their natural enemies in relation to weather parameters on chilli\n", "abstract": " The present field experiment was conducted to study the incidence of yellow mite and thrips and their natural enemies and their interaction with the abiotic factors during 2012-13 at District Seed Farm (AB Block) of BCKV, West Bengal. The results revealed that the maximum mean mite population/leaf (7.25) was recorded on 02/05/2013 and the minimum population (3.54 mites/leaf) was registered on 17/04/2013. Highest mean thrips population (6.15/leaf) was recorded during 11/04/13 and 02/05/13 whereas the minimum population of thrips (1.85/leaf) was recorded on 17/04/13. The mean population of coccinellids maintained throughout the observation dates in variable number ranging from 0.25 to 2.05/plant whereas the mean spider population ranges from 0.58 to 1.40/plant respectively. Population fluctuation of yellow mite, thrips and spiders was found positively correlated with mean temperature and negatively correlated with total rainfall. Other abiotic factors (mean relative humidity, wind speed and bright sunshine) were found non-significant with the incidence of yellow mite, thrips and spider population. In case of coccinellids, none of the abiotic factors exerted influence on the population builds up in chilli ecosystem.", "num_citations": "7\n", "authors": ["257"]}
{"title": "Is the North Indian continental margin a Palaeo-Proterozoic magmatic arc? Insights from magnetomineralogy and geochemistry of the Wangtu Gneissic Complex, Himachal Lesser Himalaya\n", "abstract": " Magnetomineralogical, petrographic and whole-rock geochemical studies on the Palaeo-proterozoic Wangtu Gneissic Complex (WGC) of the Himachal Lesser Himalaya have been carried out to understand the tectonic setting of the northern Indian continental margin during the Palaeo-proterozoic. Petrography and magnetomineralogy suggest that, although the WGC is dominantly composed of S-type/two-mica granitoids having low magnetic susceptibility (<500 \u00d7 10\u22126 SI units), part of the complex consists of hornblende\u2013magnetite and biotite\u2013magnetite-bearing I-type granitoids having susceptibility greater than 500 \u00d7 10\u22126 SI units. Comparison of magnetic susceptibility with major element concentration reveals that the high susceptibility (>500 \u00d7 10\u22126 SI units) granites are low in silica content and enriched in ferro-magnesian content. Tectonic discrimination based on trace element concentration shows that both I\u00a0\u2026", "num_citations": "7\n", "authors": ["257"]}
{"title": "Zircon U\u2013Pb geochronology, mineral and whole\u2010rock geochemistry of the Khardung volcanics, Ladakh Himalaya, India: Implications for Late Cretaceous to Palaeogene continental arc\u00a0\u2026\n", "abstract": " In this study, we present new mineral and whole\u2010rock geochemical data with zircon U\u2013Pb ages of the Khardung volcanics (KV) from the western Himalaya and discuss their tectono\u2010magmatic evolution. These volcanics are sandwiched between the Ladakh batholith and Karakoram batholith and classified as intermediate volcanics (basaltic andesite\u2010andesite) and felsic volcanics (dacite\u2010rhyolite). The intermediate volcanics are marked by low SiO2 (52.80\u201361.31\u00a0wt.%), enriched LREEs, and depleted HFSEs (Nb, Ti, Zr), whereas more evolved felsic volcanics exhibit quartz, K\u2010feldspar, and plagioclase as dominant mineral phases and felsic compositions are characterized by high SiO2 (64.52\u201379.19\u00a0wt.%) content with pronounced negative Eu anomalies, enriched LREEs, and depleted HREEs and HFSEs (Nb, Ti). New zircon U\u2013Pb ages of intermediate volcanics (andesite) yield 69.71\u00a0Ma, whereas felsic volcanics\u00a0\u2026", "num_citations": "6\n", "authors": ["257"]}
{"title": "Detection of a weak late-stage deformation event in granitic gneiss through anisotropy of magnetic susceptibility: implications for tectonic evolution of the Bomdila Gneiss in\u00a0\u2026\n", "abstract": " Outcrop-scale structures and magnetic fabric anisotropy of the Bomdila Gneiss (BG) that intruded the Lesser Himalayan Crystallines (LHC) of the Arunachal Lesser Himalaya are studied to understand the BG deformation history and tectonic evolution. Detailed analysis of structures reveals that the LHC have undergone three phases of deformation, D1, D2 and D3. The S2 foliation developed during the second phase of deformation (D2) is the most penetrative planar fabric in the studied rock, which shows a general ENE\u2013WSW strike with moderate NW dip. Mesoscopic evidence of a later phase of deformation (D3) in the BG is lacking. Evidence of D3 deformation in the form of F3 folds is only observed in the adjacent metasedimentary rocks of the LHC. The magnetic foliations recorded from anisotropy of magnetic susceptibility (AMS) analysis of the BG are mostly striking NW\u2013SE with a moderate dip towards the NE or\u00a0\u2026", "num_citations": "6\n", "authors": ["257"]}
{"title": "Automated test generation using concolic testing\n", "abstract": " In this talk, I will talk about the recent advances and challenges in concolic testing and symbolic execution. Concolic testing, also known as directed automated random testing (DART) or dynamic symbolic execution, is an efficient way to automatically and systematically generate test inputs for programs. Concolic testing uses a combination of runtime symbolic execution and automated theorem proving techniques to generate automatically non-redundant and exhaustive test inputs. Concolic testing has inspired the development of several industrial and academic automated testing and security tools such as PEX, SAGE, and YOGI at Microsoft, Apollo at IBM, Conbol at Samsung, and CUTE, jCUTE, CATG, Jalangi, SPLAT, BitBlaze, jFuzz, Oasis, and SmartFuzz in academia. A central reason behind the wide adoption of concolic testing is that, while concolic testing uses program analysis and automated theorem proving\u00a0\u2026", "num_citations": "6\n", "authors": ["257"]}
{"title": "Ndetermin: inferring nondeterministic sequential specifications for parallelism correctness\n", "abstract": " Nondeterministic Sequential (NDSeq) specifications have been proposed as a means for separating the testing, debugging, and verifying of a program's parallelism correctness and its sequential functional correctness. In this work, we present a technique that, given a few representative executions of a parallel program, combines dynamic data flow analysis and Minimum-Cost Boolean Satisfiability (MinCostSAT) solving for automatically inferring a likely NDSeq specification for the parallel program. For a number of Java benchmarks, our tool NDetermin infers equivalent or stronger NDSeq specifications than those previously written manually.", "num_citations": "6\n", "authors": ["257"]}
{"title": "Prefail: A programmable failure-injection framework\n", "abstract": " As hardware failures are no longer rare in the era of cloud computing, cloud software systems must \u201cprevail\u201d against multiple, diverse failures that are likely to occur. Testing software against multiple failures poses the problem of combinatorial explosion of multiple failures. To address this, a tester can write diverse policies that prune down the space of multiple failures while meeting her testing objective. In this paper, we present PREFAIL, a programmable failureinjection framework that enables testers to write a wide range of pruning policies. Using the principle of separation of mechanism and policy, we decouple a failure-injection framework into two components: failure-injection engine and driver. The policies written in the driver decide which failures should be injected by the engine. We define clear abstractions on which the two components interact. We integrate PREFAIL to three cloud software systems, show a wide variety of pruning policies that we can write for them and the speed-ups that we obtain with those policies.", "num_citations": "6\n", "authors": ["257"]}
{"title": "EIGER: automated IOC generation for accurate and interpretable endpoint malware detection\n", "abstract": " A malware signature including behavioral artifacts, namely Indicator of Compromise (IOC) plays an important role in security operations, such as endpoint detection and incident response. While building IOC enables us to detect malware efficiently and perform the incident analysis in a timely manner, it has not been fully-automated yet. To address this issue, there are two lines of promising approaches: regular expression-based signature generation and machine learning. However, each approach has a limitation in accuracy or interpretability, respectively.", "num_citations": "5\n", "authors": ["257"]}
{"title": "OPR: Deterministic group replay for one-sided communication\n", "abstract": " The ability to reproduce a parallel execution is desirable for debugging and program reliability purposes. In debugging (13), the programmer needs to manually step back in time, while for resilience (6) this is automatically performed by the the application upon failure. To be useful, replay has to faithfully reproduce the original execution. For parallel programs the main challenge is inferring and maintaining the order of conflicting operations (data races). Deterministic record and replay (R&R) techniques have been developed for multithreaded shared memory programs (5), as well as distributed memory programs (14). Our main interest is techniques for large scale scientific (3; 4) programming models.", "num_citations": "5\n", "authors": ["257"]}
{"title": "Separating functional and parallel correctness using nondeterministic sequential specifications\n", "abstract": " Writing correct explicitly-parallel programs can be very challenging. While the functional correctness of a program can often be understood largely sequentially, a software engineer must simultaneously reason about the nondeterministic parallel interleavings of the program\u2019s threads of execution. This complication is similarly a challenge to automated verification efforts. Thus, we argue that it is desirable to decompose a program\u2019s correctness into its sequential functional correctness and the correctness of its parallelization. We propose achieving this decomposition by specifying the parallel correctness of a program with a nondeterministic but sequential version of the program. In particular, if a software engineer annotates the intended algorithmic nondeterminism in a program, then the program can act as its own specification in verifying the correctness of its parallelism. We can interpret the annotated program as sequential but nondeterministic, and then verify the correctness of the parallelism by showing that it introduces no additional nondeterminism.", "num_citations": "5\n", "authors": ["257"]}
{"title": "A Perspective on Rishiganga-Dhauliganga Flash Flood in the Nanda Devi Biosphere Reserve, Garhwal Himalaya, India\n", "abstract": " A ground-based and heliborne survey was conducted immediately after the disaster that took place on 7 th February, 2021 in the Chamoli district of Uttarakhand. Based on these observations and freely available Google Earth imagery, we have arrived at plausible causes of this catastrophe as detachment of a sizeable rock mass and overlying hanging glacier in the Raunthi catchment that dammed the Rishiganga River and led to the devastation of roads, bridges and hydropower projects in downstream.", "num_citations": "4\n", "authors": ["257"]}
{"title": "Evidence for late Quaternary brittle deformation and back thrusting within the Indus Suture Zone, Ladakh Himalaya\n", "abstract": " Although the tectonic evolution of the southern Himalaya has been extensively studied, relatively few studies have focused on potential neotectonic activity in the most hinterland part of Himalaya, north of the region that separates the southern edge of the Tibetan plateau from the peaks of the Higher Himalayan Range. Here we use a combination of new structural and geomorphic field data, Optically Stimulated Luminescence (OSL) chronology, as well as previously published seismicity and denudation rate dataset, to suggest that the Trans-Himalaya within the region of the Indus Suture Zone (ISZ) is neotectonically active. Based on fault gouge, tilted paleolake deposits, and the chronology of deformed fluvial gravels constrained by OSL dating, the present study provides evidence for the tectonic activity along the ISZ between 78 and 58\u00a0ka. The occurrence of two earthquakes of Mw\u00a0\u2265\u00a04.0 and the focal mechanism\u00a0\u2026", "num_citations": "4\n", "authors": ["257"]}
{"title": "Petrology, geochemistry and geochronology of granites and granite gneisses in the SE Karakoram, India: Record of subduction-related and pre-to syn-kinematic magmatism in the\u00a0\u2026\n", "abstract": " The granites and granite gneisses from a tectono-metamorphic complex exposed along the Shyok Valley in the Karakoram region, India, forms the southern margin of Asian plate in the India-Asia collision zone. These rocks have been subjected to mineralogical, geochemical, and U-Pb zircon geochronological investigations to constrain the petrogenetic and geodynamic evolution of the Karakoram terrane. Outcrop-scale observations reveal the presence of pre- and syn-kinematic leucogranite bodies intruded within the granites and granite gneisses. The foliation-parallel deformed leucogranite sill shows the dextral shear sense in an extensive metamorphic complex that is in concordance with the Karakoram Fault (KF) in the Ladakh region, NW India. Whole-rock elemental and biotite chemistry equivocally suggest subduction-related metaluminous (I-type) calc-alkaline nature for most of the host granites and\u00a0\u2026", "num_citations": "4\n", "authors": ["257"]}
{"title": "Application of AMS in understanding regional deformation fabric development and granite emplacement: examples from Indian cratons\n", "abstract": " In this paper the authors review various applications of analysing fabric in granites from Indian cratons using anisotropy of magnetic susceptibility (AMS). First the general importance of AMS in identifying the internal fabric in massive granitoids devoid of visible foliations/lineations is highlighted. Subsequently, three important applications of AMS in granitoids are discussed.(a) The case of Godhra Granite (southern parts of Aravalli Mountain Belt) is presented as an example of the robustness of AMS in working out the time-relationship between emplacement/fabric development and regional deformation by integrating field, microstructural and magnetic data.(b) AMS orientation data from Chakradharpur Granitoid (eastern India) are compared with field-based information from vicinity of the Singhbhum Shear Zone to highlight the use of AMS in kinematic analysis and vorticity quantification of syntectonic granitoids.(c\u00a0\u2026", "num_citations": "4\n", "authors": ["257"]}
{"title": "Maximizing communication overlap with dynamic program analysis\n", "abstract": " We present a dynamic program analysis approach to optimize communication overlap in scientific applications. Our tool instruments the code to generate a trace of the application's memory and synchronization behavior. An offline analysis determines the program optimal points for maximal overlap when considering several programming constructs: nonblocking one-sided communication operations, non-blocking collectives and bespoke synchronization patterns and operations. Feedback about possible transformations is presented to the user and the tool can perform the directed transformations, which are supported by a lightweight runtime. The value of our approach comes from: 1) the ability to optimize across boundaries of software modules or libraries, while specializing for the intrinsics of the underlying communication runtime; and 2) providing upper bounds on the expected performance improvements after\u00a0\u2026", "num_citations": "4\n", "authors": ["257"]}
{"title": "Evaluation of insecticides and acaricides against yellow mite and thrips infesting chilli (Capsicum annum L.)\n", "abstract": " Field experiment was conducted at District Seed Farm (AB Block) of BCKV, Kalyani, Nadia, West Bengal during Mid January to May, 2013 to evaluate the efficacy of different acaricidal and insecticidal molecules against thrips and yellow mite infestation on chilli. Among the treatments, spiromesifen 24SC@ 120 g ai ha-1, fenpyroximate 5 SC@ 25 g ai ha-1 and diafenthiuron 50 WP@ 375 g ai ha-1 were observed to be very much effective against yellow mite. Whereas, chlorfenapyr 10 SC@ 75 g ai ha-1, diafenthiuron 50 WP@ 375 g ai ha-1 and spiromesifen 24 SC@ 120 g ai ha-1 were adjudged as the effective insecticides against thrips. None of the chemicals was found harmful against predatory coccinelids and spiders. Highest fruit yield was obtained with diafenthiuron 50 WP@ 375 g ai ha-1 (17.64 q ha-1) followed by spiromesifen 24 SC@ 120 g ai ha-1 (16.05 q ha-1). Thus, spiromesifen 24 SC, chlorfenapyr 10 SC, fenpyroximate 5 SC and difenthiuron 50 WP may be recommended to control yellow mite and thrips infestation in chilli.", "num_citations": "4\n", "authors": ["257"]}
{"title": "SReplay: Deterministic sub-group replay for one-sided communication\n", "abstract": " Replay of parallel execution is required by HPC debuggers and resilience mechanisms. Up-to-date, there is no existing deterministic replay solution for one-sided communication. The essential problem is that the readers of updated data do not have any information on which remote threads produced the updates, the conventional happens-before based ordering tracking techniques are challenging to work at scale. This paper presents SReplay, the first software tool for sub-group deterministic record and replay for one-sided communication. SReplay allows the user to specify and record the execution of a set of threads of interest (sub-group), and then deterministically replays the execution of the sub-group on a local machine without starting the remaining threads. SReplay ensures sub-group determinism using a hybrid data-and order-replay technique. SReplay maintains scalability by a combination of local\u00a0\u2026", "num_citations": "4\n", "authors": ["257"]}
{"title": "Concolic testing: a decade later (keynote)\n", "abstract": " Symbolic execution for software testing has witnessed renewed interest in the recent years due to its ability to generate high-coverage test suites and find deep errors in software systems. In this talk, I will give an overview of a modern symbolic execution technique, called concolic testing, discuss its key challenges in terms of path exploration, and introduce MultiSE, a new technique for tackling the path exploration challenge.", "num_citations": "4\n", "authors": ["257"]}
{"title": "Scalable data race detection for partitioned global address space programs\n", "abstract": " Contemporary and future programming languages for HPC promote hybrid parallelism and shared memory abstractions using a global address space. In this programming style, data races occur easily and are notoriously hard to find. Previous work on data race detection for shared memory programs reports 10X-100X slowdowns for non-scientific programs. Previous work on distributed memory programs instruments only communication operations. In this paper we present the first complete implementation of data race detection at scale for UPC programs. Our implementation tracks local and global memory references in the program and it uses two techniques to reduce the overhead: 1) hierarchical function and instruction level sampling; and 2) exploiting the runtime persistence of aliasing and locality specific to Partitioned Global Address Space applications. The results indicate that both techniques are required\u00a0\u2026", "num_citations": "4\n", "authors": ["257"]}
{"title": "Concolic testing and constraint satisfaction\n", "abstract": " Software testing is the most common technique used in industry to improve reliability and quality of software. Unfortunately, testing is mostly a manual process that reportedly accounts for over half of the typical cost of software development and maintenance. Symbolic execution [6,2,3,9,5] was proposed in the 70s to automate software testing by generating test inputs.", "num_citations": "4\n", "authors": ["257"]}
{"title": "Path slicing per object for better testing, debugging, and usage discovery\n", "abstract": " Given an execution trace of an object-oriented program and an object created during the execution, a path slice per object with respect to the object, or PSPO, is a part of the trace such that (1) the sequence of public methods invoked on the object in the trace is same as the sequence of public methods invoked on the object in the slice, and (2) given a method invocation in the slice, the state of all objects accessed by the method is same in both the trace and slice. A generator for a PSPO (or GPSPO in short) is a program such that its only execution trace is the PSPO. We argue that GPSPOs can be useful for debugging, creating test harnesses, creating regression test suites, discovering usage and construction patterns of a class. We present an algorithm to create GPSPOs given an execution trace and an object. We have implemented the algorithm in a prototype tool for Java, and we present several examples that demonstrate the effectiveness of our algorithm and the utility of GPSPOs.", "num_citations": "4\n", "authors": ["257"]}
{"title": "Sedimentology and magnetic fabric studies of Mio\u2013Pliocene fluvial succession in the NW Himalayan Foreland Basin\n", "abstract": " Magnetic fabric studies based on anisotropy of magnetic susceptibility (AMS) over mudstone facies from a 1700 m thick Mio\u2013Pliocene Siwalik fluvial sequence infer a dominant control of tectonic fabrics as against the depositional fabrics of the associated channel sandstones. This study integrated with lithofacies variations indicates the prevalence of overall prolateness with high 'T, q and L/F' values after 1100 m. Superimposition of the tectonic fabrics vis-\u00e0-vis up-section increase in frequency and thickness of the conglomerates infers greater magnitude of the tectonic signatures. The low prolateness of the fabrics between 1000 and 1100 m is inferred as the syn-tectonic lag deposits and reflects some important basin dynamic changes. The AMS approach over mudstone facies thus shows a greater scope of recording and quantifying the basin tectonic impulses in the Himalayan Foreland Basin.", "num_citations": "4\n", "authors": ["257"]}
{"title": "QFAST: Conflating Search and Numerical Optimization for Scalable Quantum Circuit Synthesis\n", "abstract": " We present a quantum synthesis algorithm designed to produce short circuits and to scale well in practice. The main contribution is a novel representation of circuits able to encode placement and topology using generic \"gates\", which allows the QFAST algorithm to replace expensive searches over circuit structures with few steps of numerical optimization. When compared against optimal depth, search based state-of-the-art techniques, QFAST produces comparable results: 1.19x longer circuits up to four qubits, with an increase in compilation speed of 3.6x. In addition, QFAST scales up to seven qubits. When compared with the state-of-the-art \"rule\" based decomposition techniques in Qiskit, QFAST produces circuits shorter by up to two orders of magnitude (331x), albeit 5.6x slower. We also demonstrate the composability with other techniques and the tunability of our formulation in terms of circuit depth and running time.", "num_citations": "3\n", "authors": ["257"]}
{"title": "FairFuzz-TC: a fuzzer targeting rare branches\n", "abstract": " FairFuzz is a coverage-guided mutational fuzzing tool based on AFL, which targets its mutation strategy towards rare branches in the program. FairFuzz was built to run on command-line CC++ programs which accept a single file as input. We introduce the modifications to FairFuzz which enable it to run on Test-Comp benchmarks; we refer to this altered version as FairFuzz-TC. FairFuzz-TC placed in the middle of the testing competition. FairFuzz-TC had better performance on the error-finding benchmarks than on the branch coverage benchmarks. We analyze the results and find that the benchmarks on which FairFuzz-TC has the most difficulties are those where (a) most functionality is under hard comparisons (requiring precise input values), (b) getting a seed input on which the program does not crash or time out is difficult, or (c) the program takes too much time to execute.", "num_citations": "3\n", "authors": ["257"]}
{"title": "Field screening of different genotypes of bitter gourd for infestation with the melon fruit fly, Bactrocera cucurbitae (Coquillett) in two agro-climatic zones of West Bengal, India\n", "abstract": " Bitter gourd (Momordica charantia L.) also known as bitter melon being rich in folate and vitamin C is one of the most popular cucurbitaceous vegetables grown extensively in the tropics and subtropics especially in India. Besides its numerous culinary preparations, it has immense medicinal properties as well as ornamental uses. The fast growing vines and creepers of bitter gourd attract a number of insect pests of which fruit fly (Bactrocera cucurbitae Coq.) is the most destructive due to difficulties associated with its chemical control as the maggots remain and feed inside the fruits, protected from direct contact with insecticides. Therefore, exploration of alternative control measures for this pest is crucial and identification of promising resistance genotypes could be the effective option. Considering the above aspects in view, twenty five genotypes of bitter gourd (M. charantia L.) were preliminary screened under field\u00a0\u2026", "num_citations": "3\n", "authors": ["257"]}
{"title": "Chocopy: A programming language for compilers courses\n", "abstract": " ChocoPy is a programming language designed for teaching an undergraduate course on programming languages and compilers. ChocoPy is a restricted subset of Python 3.6, using static type annotations to enforce compile-time type safety. ChocoPy is fully specified using formal grammar, typing rules, and operational semantics. Valid ChocoPy programs can be executed in a standard Python interpreter, producing results consistent with ChocoPy semantics. A major component of CS164 at UC Berkeley is the project: students develop a full compiler for ChocoPy, targeting RISC-V, in about twelve weeks. In other exercises, students extend the syntax, type system, and formal semantics to support additional features of Python. In this paper, we outline (1) the motivations for creating the ChocoPy project,(2) salient features of the language,(3) the resources provided to students to develop their compiler,(4) some insights\u00a0\u2026", "num_citations": "3\n", "authors": ["257"]}
{"title": "GUIDEDSAMPLER: Coverage-guided Sampling of SMT Solutions\n", "abstract": " The problem of sampling a large number of random solutions to SAT and SMT constraints is essential for constrained-random verification and testing. However, most current sampling techniques lack a problem-specific notion of coverage, considering only general goals such as uniform distribution. We have developed a new technique for coverage-guided sampling that allows the user to specify the desired coverage points in order to shape the distribution of solutions. Our tool GUIDEDSAMPLER can efficiently generate high-quality stimuli for constrained-random verification, by sampling solutions to a SMT constraint that also cover a large number of user-defined coverage classes.", "num_citations": "3\n", "authors": ["257"]}
{"title": "Screening of some chilli germplasm against yellow mite and thrips in the gangetic plains of West Bengal\n", "abstract": " Field experiments on screening of twenty nine chilli germplasm against yellow mite and thrips damage was conducted during rabi seasons of 2012-13 and 2013-14 at Kalyani \u2018C\u2019Block Farm, BCKV, West Bengal. The results on the basis of percent of plant showing visible symptoms revealed that hybrids like 2012/CHYB-11 (15.96%), 2011/CHYB-4 (16.60%), 2013/CHYB-1 (17.60%) and 2012/CHYB-5 (18.00%) were found field tolerant to yellow mite whereas BSS-453 (21.38%), 2011/CHYB-3 (22.53%) and 2012/CHYB-3 (23.54%) were found most moderately field tolerant. The hybrids BSS-453 (18.41%), 2012/CHYB-5 (19.06%) and 2013/CHYB-1 (19.46%) were identified as field tolerant to thrips whereas 2012/CHYB-11 (21.59%), 2013/CHYB-4 (22.37%) and 2011/CHYB-4 (22.85%) were recorded as mostly moderately tolerant. The most susceptible hybrid to yellow mite recorded was 2011/CHYB-8 (38.60%) whereas for thrips was 2012/CHYB-10 (37.26%). Chilli hybrid lines 2013/CHYB-1 and 2012/CHYB-5 were found less affected or tolerant against both mites and thrips and could be exploited in the resistance breeding programme.", "num_citations": "3\n", "authors": ["257"]}
{"title": "Field Evaluation of a New Ready Mix Formulation Ampligo 150 ZC (Chlorantraniliprole 9.3%+ Lambda Cyhalothrin 4.6% ZC) against Shoot and Fruit Borer (Leucinodes orbonalis Guen\u00a0\u2026\n", "abstract": " Brinjal or eggplant (Solanum melongena L.) is one of the most popular and principal solanaceous vegetable crops grown in India and other parts of the world. Brinjal is being cultivated throughout the year during kharif, rabi and summer season. It is a good source of minerals and contains vitamins A, B and C, rich in total water soluble sugars, free reducing sugars, amide proteins among other nutrients and also has ayurvedic medical properties, the fruit being good for diabetic patients [8, 11]. In India, brinjal occupies an area of 663 thousand ha with a production of 12515 thousand MT during 2015-16 [12]. As it is cultivated round the year the crop is proned to attack by a number of insect pests right from its seedling stage in the nursery to its harvesting in the main field [18]. Among them, brinjal shoot and fruit borer, Leucinodes orbonalis Guen.(Lepidoptera: Pyralidae) is the most destructive noxious pest responsible for one of the limiting factor in quantitative as well as qualitative yield of brinjal fruits [4, 6, 10, 20]. In young plants, larvae bores into the young tender shoots resulting in drooping, withering and drying of the affected shoots. Later, caterpillars bore into the flower buds and fruits resulting shedding and the bored holes are invariably plugged with excreta [14]. The infested fruits become unfit for consumption due to loss of quality which ultimately reduces the market value. The yield losses due to this pest may vary from 70-92% in India [4, 7, 13, 17]. To combat this notorious pest farmers tend to apply highly toxic chemicals with higher doses twice a week and hence increases the cost of cultivation. This leads a serious health hazards as brinjal\u00a0\u2026", "num_citations": "3\n", "authors": ["257"]}
{"title": "Seismic properties of naturally deformed quartzites of the Alaknanda valley, Garhwal Himalaya, India\n", "abstract": " The present contribution summarizes the results of a study focusing on the influence of quartz microstructures on the seismic wave velocities in the quartzites of the Garhwal Himalaya. Quartzites being monomineralic were chosen for the present study so as to nullify the effect of other mineral constituents on the seismic velocity. Samples were collected from different tectonic settings of the Higher and Lesser Himalayas which are separated from one another by the major tectonic zone \u2018Main Central Thrust\u2019 (MCT). These are mainly Pandukeshwar quartzite, Tapovan quartzite and Berinag quartzite. The samples of Berinag quartzite were collected from near the klippen and the thrust, termed as Alaknanda Thrust. The vast differences in microstructures and associated seismic wave velocities have been noted in different quartzites. It has also been observed that quartzites of the MCT zone and Alaknanda Thrust\u00a0\u2026", "num_citations": "3\n", "authors": ["257"]}
{"title": "Essays on sub-national value added tax of India and tax incidence\n", "abstract": " The three essays of this dissertation inform tax policy design. It is a compilation of empirical and experimental research work. The first and the second essays explore the performance of a recent tax policy reform at the sub-national level in India in terms of revenue efficiency as well as economic efficiency. India is among the only three countries in the world to have adopted a sub-national VAT. Therefore, empirically examining its performance not only improves the understanding of this important tax policy reform but also informs tax policy decision-making at the sub-national level in other developing countries.", "num_citations": "3\n", "authors": ["257"]}
{"title": "Analysis of Deformation Fabric in the Godhra Granite, Aravalli Mountain Belt (India): an Integratedfield, Microstructural and AMS Investigation\n", "abstract": " Over the past few decades considerable research has been done on \u201cGranite Tectonics\u201d and it is now widely accepted that extraction of granitic melts, their ascent and emplacement are closely linked with regional tectonics. The analysis of deformation fabric in granites is challenging because they do not always develop mesoscopically mappable structures. Therefore, field, microstructural and anisotropy of magnetic susceptibility (AMS) studies have been used in the past to identify deformation fabric in granites. The present thesis is based on such an integrated approach that was adopted to analyse the deformation fabric in the Godhra Granite, a 5000 km\" pluton located in the southern parts of Aravalli Mountain Belt (AMB), northwestern India.The regional tectonic setting of the Godhra Granite and its age is unique. It lies in the southernmost tip of the AMB and to its south lies the Central Indian Tectonic Zone (CITZ\u00a0\u2026", "num_citations": "3\n", "authors": ["257"]}
{"title": "Hindsight logging for model training\n", "abstract": " In modern Machine Learning, model training is an iterative, experimental process that can consume enormous computation resources and developer time. To aid in that process, experienced model developers log and visualize program variables during training runs. Exhaustive logging of all variables is infeasible. Optimistic logging can be accompanied by program checkpoints; this allows developers to add log statements post-hoc, and \"replay\" desired log statements from checkpoint -- a process we refer to as hindsight logging. Unfortunately, hindsight logging raises tricky problems in data management and software engineering. Done poorly, hindsight logging can waste resources and generate technical debt embodied in multiple variants of training code. In this paper, we present methodologies for efficient and effective logging practices for model training, with a focus on techniques for hindsight logging. Our goal is for experienced model developers to learn and adopt these practices. To make this easier, we provide an open-source suite of tools for Fast Low-Overhead Recovery (flor) that embodies our design across three tasks: (i) efficient background logging in Python, (ii) adaptable periodic checkpointing, and (iii) an instrumentation library that codifies hindsight logging for efficient and automatic record-replay of model-training. Model developers can use each flor tool separately as they see fit, or they can use flor in hands-free mode, entrusting it to instrument their code end-to-end for efficient record-replay. Our solutions leverage techniques from physiological transaction logs and recovery in database systems. Evaluations on modern ML\u00a0\u2026", "num_citations": "2\n", "authors": ["257"]}
{"title": "Characterizing anatexis in the Greater Himalayan Sequence (Kumaun, NW India) in terms of pressure, temperature, time and deformation\n", "abstract": " We applied field observations combined with P-T pseudosection modelling, zircon U-Pb geochronology and bulk rock geochemistry along the Kali River Valley, Kumaun Himalaya to understand conditions of peak metamorphism and partial melting of the Greater Himalayan Sequence (GHS) along with spatiotemporal relationship between anatexis and fault activation. The southern tectonic boundary of GHS or the Main Central Thrust (MCT) is marked on the basis of structural, metamorphic and chronological evidences. Outcrop-scale observations suggest generation of partial melt at the base of the MCT. This partial melt migrated to higher structural levels and finally emplaced as tourmaline bearing leucogranite in the northern tectonic boundary of the GHS, which is marked by the South Tibetan Detachment Zone (STDZ). P-T pseudosection modelling shows that GHS have experienced muscovite dehydration\u00a0\u2026", "num_citations": "2\n", "authors": ["257"]}
{"title": "Bio-pesticidal management of brinjal shoot and fruit borer, Leucinodes orbonalis (Guen.)\n", "abstract": " Field investigation was conducted to evaluate the efficacy of some biopesticides against shoot and fruit borer (Leucinodes orbonalis Guen.) on brinjal during Rabi season in 2015-2016. Among the treatments, Azadirachtin 1% EC@ 2ml/L was found superior than other treatments with 10.92% mean shoot infestation and 10.04% mean fruit infestation, respectively followed by Karanjin 2% EC@ 2ml/L (13.42% shoot and 12.83% fruit infestation). Azadirachtin 1% EC@ 2ml/L also registered as highest marketable fruit yield (38.75 q/ha). It can be concluded that Azadirachtin could be proved effective in the management of brinjal shoot and fruit borer under organic farming and IPM programmes.", "num_citations": "2\n", "authors": ["257"]}
{"title": "Neural Inference of API Functions from Input\u2013Output Examples\n", "abstract": " Neural Inference of API Functions from Input-Output Examples Page 1 Neural Inference of API Functions from Input-Output Examples Rohan Bavishi, Caroline Lemieux, Neel Kant, Roy Fox, Koushik Sen, Ion Stoica Workshop on ML for Systems @ NeurIPS 2018 Page 2 \u00a92018 RISELab API Explosion! 1 Page 3 \u00a92018 RISELab API Explosion! 2 Page 4 \u00a92018 RISELab API Explosion! 3 Page 5 \u00a92018 RISELab API Explosion! 4 Page 6 \u00a92018 RISELab How to cope? StackOverflow 5 weight kg lbs cat 1 2 dog 2 4 weight cat kg 1 lbs 2 dog kg 2 lbs 4 How do I turn this: into this: in pandas? Just use the stack function! Page 7 \u00a92018 RISELab StackOverflow problems: Inefficient Solutions 6 weight kg lbs cat 1 2 dog 2 4 weight cat kg 1 lbs 2 dog kg 2 lbs 4 How do I turn this: into this: in pandas? Well, you need to start by building the index pd.MultiIndex(... Page 8 \u00a92018 RISELab StackOverflow problems: Slow Response\u2026 7 1 \u2026", "num_citations": "2\n", "authors": ["257"]}
{"title": "Bioefficacy of Fipronil 5% SC against early shoot borer (Chilo infuscatellus Snellen) and root borer (Emmalocera depressella Swinhoe) in sugarcane\n", "abstract": " Field evaluation on efficacy of fipronil 5% SC against early shoot borer (Chilo infuscatellus Snellen) and root borer (Emmalocera depressella Swinhoe) in sugarcane was conducted during 2013. Among the treatments, fipronil 5% SC@ 150 g ai/ha was found most effective against early shoot borer and root borer where minimum dead hearts (4.29, 3.20 and 2.23%) were recorded after first, second and third spraying, respectively. Fipronil 5% SC@ 100 g ai/ha was registered the next best treatment in reducing dead hearts after first (4.66%), second (3.74%) and third (2.59%) application followed by fipronil 5% SC@ 90 g ai/ha (5.05, 3.93 and 2.76%) and fipronil 5% SC@ 75 g ai/ha (5.18, 4.08 and 3.11%), respectively. Fipronil 5% SC@ 150 g ai/ha recorded the highest reduction of dead hearts over control (48.75, 65.81 and 78.22%) after three sprays with maximum yield (81.21 t/ha). Thus, fipronil 5% SC@ 150 g ai/ha may be useful in the control of early shoot borer and root borer in sugarcane.", "num_citations": "2\n", "authors": ["257"]}
{"title": "Symbolic execution and constraint solving (Dagstuhl seminar 14442)\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 14442\" Symbolic Execution and Constraint Solving\", whose main goals were to bring together leading researchers in the fields of symbolic execution and constraint solving, foster greater communication between these two communities and exchange ideas about new research directions in these fields. There has been a veritable revolution over the last decade in the symbiotic fields of constraint solving and symbolic execution. Even though key ideas behind symbolic execution were introduced more than three decades ago, it was only recently that these techniques became practical as a result of significant advances in constraint satisfiability and scalable combinations of concrete and symbolic execution. Thanks to these advances, testing and analysis techniques based on symbolic execution are having a major impact on many sub-fields of software engineering, computer systems, security, and others. New applications such as program and document repair are being enabled, while older applications such as model checking are being super-charged. Additionally, significant and fast-paced advances are being made in research at the intersection of traditional program analysis, symbolic execution and constraint solving. Therefore, this seminar brought together researchers in these varied fields in order to further facilitate collaborations that take advantage of this unique and fruitful confluence of ideas from the fields of symbolic execution and constraint solving.", "num_citations": "2\n", "authors": ["257"]}
{"title": "Anomalous Magnetic Fabric in Apparently Undeformed Lacustrine Deposits: A Case Study from NW Trans-Himalaya, Ladakh, India\n", "abstract": " In the present study, an integrated approach of field observations and magnetic analysis has been used to study the Khalsar palaeolake deposits of the Trans-Himalayan region with the objectives of correlating its magnetic fabric with the mesoscopic features. Any signature of deformation in a lake deposit can be deciphered by visible strain markers like the seismites, micro folds and faults; however, in areas where this visible deformation is absent, it is challenging to carry out strain quantification. Thus a proxy like low-field magnetic susceptibility can be useful for fabric quantification in these sediments. The fluvio-lacustrine deposit at Khalsar is characterized by seismites in its middle part while the upper part is devoid of any such features. The magnetic anisotropy indicates presence of tectonic fabric and EW trending vertical to subvertical foliation in the entire section with magnetite being the major magnetic mineral contributing to laboratory-induced isothermal remanence in these sediments. This vertical to subvertical magnetic fabric is anomalous with respect to the horizontal bedding planes present within this lake deposit. It is envisaged that the vertical magnetic foliation has developed due to migration and deposition of magnetic minerals along the vertical cracks present within the Khalsar lake deposits. This mechanism is similar to formation of \u2018pressure solution cleavage\u2019in mudrocks, in which re-orientation and/or authigenic growth of magnetite can take place leading to the development of an anomalous magnetic fabric.", "num_citations": "2\n", "authors": ["257"]}
{"title": "Prefail: Programmable and efficient failure testing framework\n", "abstract": " With the arrival of the cloud computing era, largescale distributed systems are increasingly in use. These systems are built out of tens of thousands of commodity machines that are not fully reliable and can fail from time to time [1, 2, 7, 10, 14, 15]. Thus, the software that runs on these systems has a great responsibility to correctly recover from frequent, diverse hardware failures. Even if distributed systems are built with reliability and fault tolerance as primary goals [6, 7, 8], their recovery protocols are often buggy. For example, the developers of Hadoop File System (HDFS)[16] have dealt with 91 recovery issues over its four years of development [9]. There are many reasons for this. Sometimes developers fail to anticipate the kind of failures that a system can face in a real setting (eg, tolerate crashes but not corruption). Even if all kinds of failures are anticipated, the recovery implementation might be incorrect. There have been many serious consequences (eg, data loss, unavailability) of the presence of recovery bugs in real deployed systems [3, 4, 5, 9].To improve the reliability of large-scale distributed systems, failure testing has become a mainstream technique to test software reliability. One major challenge is that the number of combinations of failures to explore is potentially large [9, 12]. One direct way to explore this failure space is via randomness. For example, random injection of failures is employed by the developers at Google [4], Yahoo![17], Microsoft [18], Amazon [10], and others [11]. Random fault-injection is relatively simple to implement, but the downside is that it could easily miss corner-case failure scenarios. Thus, there is a need for\u00a0\u2026", "num_citations": "2\n", "authors": ["257"]}
{"title": "Forsterite reprecipitation and carbon dioxide entrapment in the lithospheric mantle during its interaction with carbonatitic melt: a case study from the Sung Valley ultramafic\u00a0\u2026\n", "abstract": " Carbonatite melts derived from the mantle are enriched in CO2- and H2O-bearing fluids. This melt can metasomatize the peridotitic lithosphere and liberate a considerable amount of CO2. Experimental studies have also shown that a CO2\u2013H2O-rich fluid can form Fe- and Mg-rich carbonate by reacting with olivine. The Sung Valley carbonatite of NE India is related to the Kerguelen plume and is characterized by rare occurrences of olivine. Our study shows that this olivine is resorbed forsterite of xenocrystic nature. This olivine bears inclusions of Fe-rich magnesite. Accessory apatite in the host carbonatite contains CO2\u2013H2O fluid inclusions. Carbon and oxygen isotopic analyses indicate that the carbonatites are primary igneous carbonatites and are devoid of any alteration or fractionation. We envisage that the forsterite is a part of the lithospheric mantle that was reprecipitated in a carbonatite reservoir through\u00a0\u2026", "num_citations": "1\n", "authors": ["257"]}
{"title": "Is stateful packrat parsing really linear in practice? A counter-example, an improved grammar, and its parsing algorithms\n", "abstract": " Stateful packrat parsing is an algorithm for parsing syntaxes that have context-sensitive features. It is a well-known knowledge among researchers that the running time of stateful packrat parsing is linear for real-world grammars, as demonstrated in existing studies. However, we have found the cases in real-world grammars and tools that lead its running time to become exponential.", "num_citations": "1\n", "authors": ["257"]}
{"title": "Efficient fail-fast dynamic subtype checking\n", "abstract": " We address the problem of dynamically checking if an instance of class S is also an instance of class T. Researchers have designed various strategies to perform constant-time subtype tests. Yet, well-known production implementations degrade to linear search in the worst case, in order to achieve other goals such as constant space and/or efficient dynamic class loading. The fast path is usually optimized for subtype tests that succeed. However, in workloads where dynamic type tests are common, such as Scala's pattern matching and LLVM compiler passes, we observe that 74%--93% of dynamic subtype tests return a negative result. We thus propose a scheme for fail-fast dynamic subtype checking. We assign each type a randomly generated type identifier with fixed size and fixed parity. In the compiled version of each class, we store a fixed-width bloom filter, which combines the type identifiers of all its transitive\u00a0\u2026", "num_citations": "1\n", "authors": ["257"]}
{"title": "Variation in mechanism of dynamic recrystallization and differential stress across the Chiplakot Crystalline Belt, Kali River Valley, Kumaun Himalaya: Implications for\u00a0\u2026\n", "abstract": " In this study, we carried out mesoscopic and magnetic fabric analysis along with differential flow stress based on quartz piezometer and fractal dimension (D) of quartz grain boundaries from area-perimeter method to understand variation in fabric and deformation intensity across the Chiplakot Crystalline Belt (CCB) from the Kumaun Lesser Himalaya of Kali River Valley, to understand strain variation in relation syn-Himalayan deformation and the mechanism of exhumation of the CCB. The CCB is separated from the low grade metasedimentary rocks that include siliciclastics and carbonates of the Lesser Himalaya by binding thrust zones. The northern and southern contacts of the CCB are demarcated by North Chiplakot Thrust (NCT) and South Chiplakot Thrust (SCT) and the core part of the CCB is also demarcated by a thrust called the Central Chiplakot Thrust (CCT). Both mesoscopic and magnetic fabrics are\u00a0\u2026", "num_citations": "1\n", "authors": ["257"]}
{"title": "The Revenue Efficiency of India\u2019s Sub-National VAT\n", "abstract": " The rise of the value-added tax (VAT) has undoubtedly been one of the most significant tax developments since its inception in 1954 in France. The main reason for the popularity of the VAT is its efficiency over other types of indirect taxes. Not only does it eliminate production inefficiencies associated with the turnover tax, it also is generally thought to be superior to retail sales taxes as they are more vulnerable to evasion and avoidance and they may lack a \u201cself-policing\u201d aspect of administration. The self-policing of the VAT has a higher probability of exposing forged accounts and an informal economy than the retail sales tax (Bird 2005 and Agha et al 1996). Primarily for the same reason, a VAT is generally regarded as a more promising consumption tax for developing countries where the size of the informal sector is large. However, opponents of the VAT do not quite agree. Some studies argue that the opposite is true. For example, Emran and Stiglitz (2005) show that in the presence of a substantial \u2018informal\u2019 sector, the VAT that falls on the formal sector acts to deter the growth and development of the economy as a whole. Also, the retail sales tax may be cheaper to administer since there are fewer taxpayers and thus it is less complicated. Despite these contradictory views, the VAT has replaced some version of a retail sales tax regime in many developing countries and it continues to do so.", "num_citations": "1\n", "authors": ["257"]}
{"title": "Bioefficacy and economics of some insecticides against mustard aphid, Lipaphis erysimi (Kalt.) infesting mustard\n", "abstract": " A field experiment was conducted to evaluate the bioefficacy and economics of certain insecticides against mustard aphid, Lipaphis erysimi (Kalt.) infestation on mustard during rabi season of 2014-15. Among the treatments, imidacloprid 17.8 SL@ 20 g ai ha-1, thiamethoxam 25 WG@ 25 g ai ha-1 and diafenthiuron 50 WP@ 50 g ai ha-1 were proved to be effective against mustard aphid. Highest seed yield was obtained with imidacloprid 17.8 SL (17.41 q ha-1) followed by thiamethoxam 25 WG (16.96 q ha-1). Thus, imidaclopird 17.8 SL, thiamethoxam 25 WG and diafenthiuron 50 WP may be recommended to control mustard aphid. Additionally, the incremental cost-benefit ratio was found highest in imidacloprid being, 1: 14.62 followed by 1: 14.35 in thiamethoxam.", "num_citations": "1\n", "authors": ["257"]}
{"title": "Reply to comment on \u201cDextral transpression and late-Eocene magmatism in the trans-Himalayan Ladakh Batholith (North India): implications for tectono-magmatic evolution of the\u00a0\u2026\n", "abstract": " We thank White et al. for their interest in our work (Sen and Collins 2012) and also for giving us the opportunity to discuss and clarify our findings further. In our paper, we have inferred that the Ladakh Batholith preserves its pristine igneous fabric to a large extent and its magnetic fabric indicates dextral transpression and changing angle of convergence during arc magmatism and formation of the Indo-Eurasian collisional arc. We have presented U\u2013Pb geochronology of zircons from a two-mica (\u2018S\u2019-type) granite in the central part of the batholith. The age of this two-mica granite is 35.5\u00b10.5 Ma, and we have suggested that this \u2018S\u2019-type magmatism is caused by accretion of the Indian continental lithosphere with its Eurasian counterpart, after the subduction of the Tethyan Oceanic Lithosphere.White et al. have put forward three main points regarding our findings which are (1) the age of the aforementioned two-mica\u00a0\u2026", "num_citations": "1\n", "authors": ["257"]}
{"title": "A Hint in the Right Direction: Interactive Synthesis with Partial Dynamic Specifications\n", "abstract": " Most programs contain conceptually simple statements that are difficult to write. We propose a new methodology that allows programmers to give partial dynamic specifications of the results of statements in a particular program state, and which uses them to synthesize candidate statements. Building on previous work, these specifications can consist of information about the type or value of a desired expression or can be arbitrary predicates relating the input and output states. We implemented our methodology in a tool named CodeHint and ran a user study where we found that programmers used it when given the choice.", "num_citations": "1\n", "authors": ["257"]}
{"title": "Multi-level Debugging for Multi-stage, Parallelizing Compilers\n", "abstract": " A multi-stage compilation framework transforms portions of programs written in a productivity-level language into an efficiency-level language, such as C, with explicit hardwarespecific optimizations. It is challenging for compiler programmers to debug errors in the compilation because they must perform complicated end-to-end reasoning, relating the programs across the multiple stages of compilation. To simplify this debugging effort, we present multi-level debugging, a novel combination of error-checking algorithms in a multi-stage compilation environment. Our method particularly aims to model and check sequential and parallel notions of nondeterminism and related bugs introduced by the compilation. Using our method, the programmer can systematically eliminate potential sources of the bug in the compilation process and focus only on the real source. We demonstrated on two real multi-stage compilers the effectiveness of multi-stage debugging in simplifying the diagnosis of manually-injected bugs as well as in an actual bug encountered during compiler development.", "num_citations": "1\n", "authors": ["257"]}
{"title": "TAX INCIDENCE: DO INSTITUTIONS MATTER?\n", "abstract": " There is perhaps no more important question in public finance than who ultimately bears the burden of a tax. According to tax incidence theory, the long-run incidence of a tax in competitive markets is independent of the assignment of the liability to pay tax. Moreover, the theory is silent on the possible effects of market institutions on tax incidence. We report data from an experiment designed to address two questions:(A) Is tax incidence independent of the assignment of the liability to pay tax in experimental markets?(B) Is tax incidence independent of the market institution in experimental markets? We conduct laboratory experiments with two market institutions: double auction and posted offer markets. Based on the results of Kolmogorov-Smirnov tests of experimental market prices, we conclude that the answer to both question A and question B is \u201cno.\u201d", "num_citations": "1\n", "authors": ["257"]}
{"title": "Influence of magnetic fabric anisotropy on seismic wave velocity in paramagnetic granites from NW Himalaya: Results from preliminary investigations\n", "abstract": " Anisotropy of Magnetic Susceptibility (AMS) and seismic wave velocity studies of some paramagnetic Himalayan granitoids show good correlation between magnetic fabric anisotropy and P wave velocity (Vp). Vp shows strong positive correlation with magnetic lineation (L) and degree of magnetic anisotropy (P\u2032) having correlation coefficient (r) values of 0.93 and 0.89 respectively. Both Vp and Vs show positive correlation with the SiO2 content of Proterozoic and Paleozoic granitoids. Velocity of S wave (Vs) shows negative correlation with mean magnetic susceptibility (Km) having \u2018r\u2019 value of 0.86. The correlation between Vs-Km, Vp-P\u2032, Vp-L also shows >95% probability in Spearman\u2019s rank correlation. Based on the results from the present sample size it is suggested that, in paramagnetic granites, Vp is proportional to intensity of deformation and preferred orientation of minerals as well as the mineralogy\u00a0\u2026", "num_citations": "1\n", "authors": ["257"]}
{"title": "Predictive Safety Analysis of Concurrent Programs\n", "abstract": " The work is supported in part by the Defense Advanced Research Projects Agency (the DARPA IPTO TASK Program, contract number F30602-00-2-0586 and the DARPA IXO NEST Program, contract number F33615-01-C-1907) and ONR Grant N00014-02-1-0715. I would like to thank my advisor, Prof. Gul Agha, for his advice, support and intellectual guidance. He has always been available and willing to discuss anything. A special thanks to Prof. Grigore Rosu for getting me started in this new research area and discussing the details of the technique.", "num_citations": "1\n", "authors": ["257"]}
{"title": "Probabilistic rewrite theories\n", "abstract": " We propose probabilistic rewrite theories as a general semantic framework supporting highlevel specification of probabilistic systems that can be massively concurrent. We give the definition and semantics of probabilistic rewrite theories and discuss the mappings between different classes of theories and models. We then define the semantics of probabilistic temporal formulae for a given probabilistic rewrite theory. We explain how real-time probabilistic systems whose time is discrete can be expressed as probabilistic rewrite theories without any extension. Finally we give our design ideas for PMaude, an implementation of probabilistic rewrite theories on top of Maude 2.0. We shall report a running prototype of PMaude in the final version of the paper.", "num_citations": "1\n", "authors": ["257"]}
{"title": "Techniques for the automatic debugging of scientific floating-point programs\n", "abstract": " David H. Bailey1, James Demmel2, William Kahan2, Guillaume Revy2, and Koushik Sen2 Page 1 Techniques for the automatic debugging of scientific floating-point programs David H. Bailey1, James Demmel2, William Kahan2, Guillaume Revy2, and Koushik Sen2 1Berkeley Lab Computing Sciences, Computational Research Division, Lawrence Berkeley National Laboratory 2Parallel Computing Laboratory, EECS Department, University of California at Berkeley 1. Context and purpose of our work \u25a0 Tool for automatically detecting and remedying anomalies in scientific floating-point programs \u25b6 large-scale scientific single/multi-threaded applications has been growing rapidly \u25b6 anomalies may cause rare but critical bugs that are hard for nonexperts to find or fix [1] \u21a9\u2192 detection and remedy either at C code level or at run-time \u25a0 What are the usual anomalies? \u25b6 rounding error accumulations \u25b6 conditional -point -\u2026", "num_citations": "1\n", "authors": ["257"]}