{"title": "Dissection of a bug dataset: Anatomy of 395 patches from defects4j\n", "abstract": " Well-designed and publicly available datasets of bugs are an invaluable asset to advance research fields such as fault localization and program repair as they allow directly and fairly comparison between competing techniques and also the replication of experiments. These datasets need to be deeply understood by researchers: the answer for questions like \"which bugs can my technique handle?\" and \"for which bugs is my technique effective?\" depends on the comprehension of properties related to bugs and their patches. However, such properties are usually not included in the datasets, and there is still no widely adopted methodology for characterizing bugs and patches. In this work, we deeply study 395 patches of the Defects4J dataset. Quantitative properties (patch size and spreading) were automatically extracted, whereas qualitative ones (repair actions and patterns) were manually extracted using a\u00a0\u2026", "num_citations": "86\n", "authors": ["94"]}
{"title": "Ranking crowd knowledge to assist software development\n", "abstract": " StackOverflow. com (SO) is a Question and Answer service oriented to support collaboration among developers in order to help them solving their issues related to software development. In SO, developers post questions related to a programming topic and other members of the site can provide answers to help them. The information available on this type of service is also known as\" crowd knowledge\" and currently is one important trend in supporting activities related to software development and maintenance.", "num_citations": "63\n", "authors": ["94"]}
{"title": "Bears: An extensible java bug benchmark for automatic program repair studies\n", "abstract": " Benchmarks of bugs are essential to empirically evaluate automatic program repair tools. In this paper, we present BEARS, a project for collecting and storing bugs into an extensible bug benchmark for automatic repair studies in Java. The collection of bugs relies on commit building state from Continuous Integration (CI) to find potential pairs of buggy and patched program versions from open-source projects hosted on GitHub. Each pair of program versions passes through a pipeline where an attempt of reproducing a bug and its patch is performed. The core step of the reproduction pipeline is the execution of the test suite of the program on both program versions. If a test failure is found in the buggy program version candidate and no test failure is found in its patched program version candidate, a bug and its patch were successfully reproduced. The uniqueness of Bears is the usage of CI (builds) to identify buggy\u00a0\u2026", "num_citations": "48\n", "authors": ["94"]}
{"title": "Do software categories impact coupling metrics?\n", "abstract": " Software metrics is a valuable mechanism to assess the quality of software systems. Metrics can help the automated analysis of the growing data available in software repositories. Coupling metrics is a kind of software metrics that have been extensively used since the seventies to evaluate several software properties related to maintenance, evolution and reuse tasks. For example, several works have shown that we can use coupling metrics to assess the reusability of software artifacts available in repositories. However, thresholds for software metrics to indicate adequate coupling levels are still a matter of discussion. In this paper, we investigate the impact of software categories on the coupling level of software systems. We have found that different categories may have different levels of coupling, suggesting that we need special attention when comparing software systems in different categories and when using\u00a0\u2026", "num_citations": "35\n", "authors": ["94"]}
{"title": "Searching crowd knowledge to recommend solutions for API usage tasks\n", "abstract": " Stack Overflow (SO) is a question and answer service directed to issues related to software development. In SO, developers post questions related to a programming topic and other members of the site can provide answers to help them. The information available on this type of service is also known as \u2018crowd knowledge\u2019 and currently is one important trend in supporting activities related to software development. We present an approach that makes use of \u2018crowd knowledge\u2019 in SO to recommend information that can assist developer activities. This strategy recommends a ranked list of question\u2010answer pairs from SO based on a query. The criteria for ranking are based on three main aspects: the textual similarity of the pairs with respect to the query related to the developer's problem, the quality of the pairs, and a filtering mechanism that considers only \u2018how\u2010to\u2019 posts. We conducted an experiment considering\u00a0\u2026", "num_citations": "28\n", "authors": ["94"]}
{"title": "Understanding the popularity of reporters and assignees in the Github.\n", "abstract": " Github has evolved from traditional version control systems to incorporate the wave of the Web 2.0. Intensive collaboration among developers is one of the main goals of Github beyond traditional version control. Understanding how those developers collaborate is a key issue to enhance the outcomes of individuals and of the ecosystem as a whole, as well. Developers activity during the collaboration may be partially registered in the Github database. The analysis of this database can help to answer important questions about different facets of collaboration. In this work, our interest is to understand which factors can influence developers\u2019 popularity and provide insights for individuals to enhance their own popularity. We measure popularity with the number of developer followers. We have analyzed a subset of the Github database in order to explain the high popularity phenomenon. Although, we have found that commit activity is an important factor for high popularity, we also have observed developers with low activity (reports and assigns) but with a high number of followers. We present external factors that can explain this dichotomy and they should be considered as key factors in the ecosystem of open-source development.", "num_citations": "21\n", "authors": ["94"]}
{"title": "Assessing modularity using co-change clusters\n", "abstract": " The traditional modular structure defined by the package hierarchy suffers from the dominant decomposition problem and it is widely accepted that alternative forms of modularization are necessary to increase developer's productivity. In this paper, we propose an alternative form to understand and assess package modularity based on co-change clusters, which are highly inter-related classes considering co-change relations. We evaluate how co-change clusters relate to the package decomposition of three real-world systems. The results show that the projection of co-change clusters to packages follow different patterns in each system. Therefore, we claim that modular views based on co-change clusters can improve developers' understanding on how well-modularized are their systems, considering that modularity is the ability to confine changes and evolve components in parallel.", "num_citations": "18\n", "authors": ["94"]}
{"title": "Common bug-fix patterns: A large-scale observational study\n", "abstract": " [Background]: There are more bugs in real-world programs than human programmers can realistically address. Several approaches have been proposed to aid debugging. A recent research direction that has been increasingly gaining interest to address the reduction of costs associated with defect repair is automatic program repair. Recent work has shown that some kind of bugs are more suitable for automatic repair techniques. [Aim]: The detection and characterization of common bug-fix patterns in software repositories play an important role in advancing the field of automatic program repair. In this paper, we aim to characterize the occurrence of known bug-fix patterns in Java repositories at an unprecedented large scale. [Method]: The study was conducted for Java GitHub projects organized in two distinct data sets: the first one (i.e., Boa data set) contains more than 4 million bug-fix commits from 101,471\u00a0\u2026", "num_citations": "17\n", "authors": ["94"]}
{"title": "MetaJ: An Extensible Environment for Metaprogramming in Java.\n", "abstract": " MetaJ is a programming environment that supports metaprogramming in the Java language. The environment is designed to allow extensions via plug-ins which permit the user to manipulate programs written in different languages. This facilities concern only syntactic aspects. Semantics aspects are language-dependent and are not addressed here, but could be tackled with other tools, which could even be layered on the top of MetaJ. Accessing patterns by example inside ordinary Java programs is a major feature of MetaJ programming. This paper presents a conceptual description of the environment, implementation details and three applications on analysis, restructuring and generation of programs.", "num_citations": "16\n", "authors": ["94"]}
{"title": "INDIAM\u2014an e-learning system for the interpretation of mammograms\n", "abstract": " We propose the design of a teaching system named Interpretation and Diagnosis of Mammograms (INDIAM) for training students in the interpretation of mammograms and diagnosis of breast cancer. The proposed system integrates an illustrated tutorial on radiology of the breast, that is, mammography, which uses education techniques to guide the user (doctors, students, or researchers) through various concepts related to the diagnosis of breast cancer. The user can obtain informative text about specific subjects, access a library of bibliographic references, and retrieve cases from a mammographic database that are similar to a query case on hand. The information of each case stored in the mammographic database includes the radiological findings, the clinical history, the lifestyle of the patient, and complementary exams. The breast cancer tutorial is linked to a module that simulates the analysis and\u00a0\u2026", "num_citations": "15\n", "authors": ["94"]}
{"title": "Redocumenting APIs with crowd knowledge: a coverage analysis based on question types\n", "abstract": " Software libraries and frameworks play an important role in software system development. The appropriate usage of their functionalities/components through their APIs, however, is a challenge for developers. Usually, API documentation, when it exists, is insufficient to assist them in their programming tasks. There are few API documentation writers for the many potential readers, resulting in the lack of explanations and examples concerning different scenarios and perspectives. The interaction of developers on the Web, on the other hand, generates content concerning APIs from different perspectives, which can be used to document APIs, also known as crowd documentation. In this paper, we present a study regarding the knowledge generated by the crowd on the Stack Overflow question-and-answer website. Our main goal is to understand how the crowd can contribute for API documentation on two programming\u00a0\u2026", "num_citations": "14\n", "authors": ["94"]}
{"title": "A visual trace analysis tool for understanding feature scattering\n", "abstract": " This work proposes a tool for understanding feature scattering through the graphical visualization of the intersection between features and source code. The tool collects trace events of multi-threaded programs for selected features and shows matrices that help analyzing where those features are implemented. Our claim is that the tool reduces the effort to identify where features are implemented and which source code is specific to a feature.", "num_citations": "14\n", "authors": ["94"]}
{"title": "On the interplay between non-functional requirements and builds on continuous integration\n", "abstract": " Continuous Integration (CI) implies that a whole developer team works together on the mainline of a software project. CI systems automate the builds of a software. Sometimes a developer checks in code, which breaks the build. A broken build might not be a problem by itself, but it has the potential to disrupt co-workers, hence it affects the performance of the team. In this study, we investigate the interplay between non-functional requirements (NFRs) and builds statuses from 1,283 software projects. We found significant differences among NFRs related-builds statuses. Thus, tools can be proposed to improve CI with focus on new ways to prevent failures into CI, specially for efficiency and usability related builds. Also, the time required to put a broken build back on track indicates a bimodal distribution along all NFRs, with higher peaks within a day and lower peaks in six weeks. Our results suggest that more planned\u00a0\u2026", "num_citations": "13\n", "authors": ["94"]}
{"title": "On the extraction of cookbooks for APIs from the crowd knowledge\n", "abstract": " Developers of reusable software elements, such as libraries, usually have the responsibility to provide comprehensive and high quality documentation to enable effective software reuse. The effective reuse of libraries depends upon the quality of the API (Application Program Interface) documentation. Well established libraries typically have comprehensive API documentation, for example in Javadocs. However, they typically lack examples and explanations, which makes the effective reuse of the library difficult. StackOverflow.com (SO) is a Question and Answer service directed to issues related to software development. On SO, developers post questions related to a programming topic and other members of the SO community can provide answers to help them solving their problems. Despite the increasing adoption of SO, the information related to a particular topic is spread across the website. Thus, SO still lacks\u00a0\u2026", "num_citations": "13\n", "authors": ["94"]}
{"title": "Searching stack overflow for API-usage-related bug fixes using snippet-based queries\n", "abstract": " Project-specific bugs are related to the misunderstanding or incomplete implementation of functional requirements. API-usage-related bugs are independent of the functional requirements. Usually they cause an unexpected and wrong output or behavior because of an incorrect usage of an API (Application Programming Interface). We propose an approach to find fixes for API-usage-related bugs, which is based on matching snippets being debugged against related snippets in a Q&A website (Stack Overflow). We analyzed real code excerpts from OHLOH Code Search containing API method calls that may lead to API-usage-related bugs depending on how they are used by developers. We conducted a study with these excerpts to verify to what extent the proposed approach provides proper information from Stack Overflow to fix these potential API-usage-related bugs. The results are encouraging: 66.67% of Java excerpts with potential API-usage-related bugs had their fixes found in the top-10 query results. Considering JavaScript excerpts, fixes were found in the top-10 results for 40% of them. These results indicate that our approaches (ie, lsab-java and lsab-js combined with the keyword filter) outperform Google and Stack Overflow in searching for API-usage-related bug fixes.", "num_citations": "11\n", "authors": ["94"]}
{"title": "Co-change clusters: Extraction and application on assessing software modularity\n", "abstract": " The traditional modular structure defined by the package hierarchy suffers from the dominant decomposition problem and it is widely accepted that alternative forms of modularization are necessary to increase developer\u2019s productivity. In this paper, we propose an alternative form to understand and assess package modularity based on co-change clusters, which are highly inter-related classes considering co-change relations. We evaluate how co-change clusters relate to the package decomposition of four real-world systems. The results show that the projection of co-change clusters to packages follows different patterns in each system. Therefore, we claim that modular views based on co-change clusters can improve developers\u2019 understanding on how well-modularized are their systems, considering that modularity is the ability to confine changes and evolve components in parallel.", "num_citations": "11\n", "authors": ["94"]}
{"title": "Bootstrapping cookbooks for APIs from crowd knowledge on Stack Overflow\n", "abstract": " ContextWell established libraries typically have API documentation. However, they frequently lack examples and explanations, possibly making difficult their effective reuse. Stack Overflow is a question-and-answer website oriented to issues related to software development. Despite the increasing adoption of Stack Overflow, the information related to a particular topic (e.g., an API) is spread across the website. Thus, Stack Overflow still lacks organization of the crowd knowledge available on it.ObjectiveOur target goal is to address the problem of the poor quality documentation for APIs by providing an alternative artifact to document them based on the crowd knowledge available on Stack Overflow, called crowd cookbook. A cookbook is a recipe-oriented book, and we refer to our cookbook as crowd cookbook since it contains content generated by a crowd. The cookbooks are meant to be used through an exploration\u00a0\u2026", "num_citations": "10\n", "authors": ["94"]}
{"title": "Automatic categorization of questions from Q&A sites\n", "abstract": " Q&A sites are attracting growing interest of software developers. The categorization of questions in terms of user concerns would open new opportunities to extract valuable information from millions of posts.", "num_citations": "10\n", "authors": ["94"]}
{"title": "Towards an automated approach for bug fix pattern detection\n", "abstract": " The characterization of bug datasets is essential to support the evaluation of automatic program repair tools. In a previous work, we manually studied almost 400 human-written patches (bug fixes) from the Defects4J dataset and annotated them with properties, such as repair patterns. However, manually finding these patterns in different datasets is tedious and time-consuming. To address this activity, we designed and implemented PPD, a detector of repair patterns in patches, which performs source code change analysis at abstract-syntax tree level. In this paper, we report on PPD and its evaluation on Defects4J, where we compare the results from the automated detection with the results from the previous manual analysis. We found that PPD has overall precision of 91% and overall recall of 92%, and we conclude that PPD has the potential to detect as many repair patterns as human manual analysis.", "num_citations": "9\n", "authors": ["94"]}
{"title": "On the use of execution trace alignment for driving perfective changes\n", "abstract": " Perfective changes in well-established software systems are easier to perform when the development team has a solid understanding of the internals. However, it is reasonable to assume that the use of an open source system to incorporate new features and obtain a new software product is an appealing approach instead of coding a new product from scratch. Considering this scenario, and considering that it is not uncommon that systems are poorly documented, there is no widely accepted approach to guide the perfective maintenance for developers with low understanding of the system. This work proposes a new method based on the analysis of execution traces for locating evolution points in the source code where changes should be performed. The proposed method was evaluated with three open source systems and the conclusion suggests a significant impact on effort reduction.", "num_citations": "9\n", "authors": ["94"]}
{"title": "Using a sequence alignment algorithm to identify specific and common code from execution traces\n", "abstract": " Software product lines are an important strategy to improve software reuse. However, the migration of a single product to a product line is a challenging task, even when considering only the reengineering task of the source code, not mentioning other management challenges. The reengineering challenges are partially due to effort of identifying common code of similar features, even when we know those features in advance. This work proposes the alignment of execution traces in order to discover similar code of similar features, facilitating the reengineering task. We present the architecture of our approach and preliminary results that shows a promising direction.", "num_citations": "9\n", "authors": ["94"]}
{"title": "Interacting Abstract State Machines.\n", "abstract": " In this work we propose an extension to the original model of Abstract State Machines. We focus on the modularization support and on the explicit interaction abstraction between the modules units of specification. We provide the new language syntax and semantics, and also the specification of the Alternating Bit Protocol using the proposed method.", "num_citations": "8\n", "authors": ["94"]}
{"title": "Automated API documentation with tutorials generated from Stack Overflow\n", "abstract": " Software reuse provides benefits during the software development and maintenance processes. The use of APIs is one of the most common ways to reuse. However, obtaining an easy-to-understand documentation is a challenge faced by developers. Several papers have proposed alternatives to make API documentation more understandable, or even more detailed. However, these studies have not taken into account the complexity of examples in order to make documentation adaptable to different levels of developer experience. In this work, we developed and evaluated four different methodologies to generate tutorials for APIs from the contents of Stack Overflow and organize them according to the complexity of understanding. The methodologies were evaluated through tutorials generated for the Swing API. A survey was conducted to evaluate eight different features of the generated tutorials. The overall\u00a0\u2026", "num_citations": "7\n", "authors": ["94"]}
{"title": "On the impact of trace-based feature location in the performance of software maintainers\n", "abstract": " Software maintainers frequently strive to locate source code related to specific software features. This situation is mostly observable when features are scattered in the code. Considering this problem, several approaches for feature location using execution traces have been developed. Nonetheless, the practice of post-mortem analysis based on execution traces is not fully incorporated in the daily practice of software maintainers. Empirical studies that reveal strengths and weaknesses on the use of execution traces in maintenance activities could better explain the role of execution traces in software maintenance. This study reports on a controlled experiment conducted with maintainers performing actual maintenance activities on systems of different sizes unknown to them. There are benefits from systematic use of execution traces: the reduction of the maintenance activity time and greater accuracy of the activity\u00a0\u2026", "num_citations": "7\n", "authors": ["94"]}
{"title": "M\u00e1quinas de estado abstratas\n", "abstract": " Abstract State Machines (ASM) are the basis of a powerful and elegant formal method for specification and verification of systems, which has already been successfully applied on design and analysis of several discrete dynamic systems. Differently from several formal specification methods, eg, Denotational Semantics, ASM methodology uses simple and well-known concepts, which eases reading and writing. The methodology has rigorous mathematical basis, which allows formal demonstration of properties of a system. ASM also allows specification execution in order to verify by testing its correctness with respect to the real specified system. In this tutorial, we present the ASM methodology for systems specification, and show its application on specification of Programming Languages Semantics.", "num_citations": "7\n", "authors": ["94"]}
{"title": "Is there agreement between evaluators that used two scoring systems to measure acute radiation dermatitis?\n", "abstract": " To analyze the agreement between the nurses evaluating radiodermatitis that used the Radiation Therapy Oncology Group (RTOG) and the World Health Organization (WHO) scales.", "num_citations": "6\n", "authors": ["94"]}
{"title": "Keecle: Mining key architecturally relevant classes using dynamic analysis\n", "abstract": " Reconstructing architectural components from existing software applications is an important task during the software maintenance cycle because either those elements do not exist or are outdated. Reverse engineering techniques are used to reduce the effort demanded during the reconstruction. Unfortunately, there is no widely accepted technique to retrieve software components from source code. Moreover, in several architectural descriptions of systems, a set of architecturally relevant classes are used to represent the set of architectural components. Based on this fact, we propose Keecle, a novel dynamic analysis approach for the detection of such classes from execution traces in a semi-automatic manner. Several mechanisms are applied to reduce the size of traces, and finally the reduced set of key classes is identified using Na\u00efve Bayes classification. We evaluated the approach with two open source systems\u00a0\u2026", "num_citations": "6\n", "authors": ["94"]}
{"title": "Framework instantiation using cookbooks constructed with static and dynamic analysis\n", "abstract": " Software reuse is one of the major goals in software engineering. Frameworks promote the reuse of not only individual building blocks, but also of system design. However, framework instantiation requires a substantial understanding effort. High quality documentation is essential to minimize this effort. However, in most cases, appropriate documentation does not exist or is not updated. Our hypothesis is that the framework code itself and existing instantiations can serve as a guide for new instantiations. The challenge is that users still have to read large portions of code, which hinders the understanding process, thus our goal is to provide relevant information for framework instantiation with static and dynamic analysis of the framework and pre-existing instantiations. The final documentation is presented in a cookbook style, where recipes are composed of programming tasks and information about hotspots related to\u00a0\u2026", "num_citations": "6\n", "authors": ["94"]}
{"title": "Nuggets miner: Assisting developers by harnessing the Stack Overflow crowd knowledge and the github traceability\n", "abstract": " StackOverflow. com (SOF) is a Question and Answer service oriented to support collaboration among developers. The information available on this type of service is also known as \u201ccrowd knowledge\u201d and currently is one important trend in supporting activities related to software development. GitHub. com (GitHub) is a successful social site for developers that makes unique information about users and their activities visible within and across open source software projects. The traceability of GitHub\u2019s issue tracker can be harnessed in the Integrated Development Environment (IDE) to assist software maintenance. We give a form to our approach by implementing Nuggets Miner, an Eclipse plugin, that recommends a ranked and interactive list of results to system\u2019s user. Video Demo URL: https://www. youtube. com/watch? v= AjsbgUJl-nY", "num_citations": "6\n", "authors": ["94"]}
{"title": "A Self-Applicable Partial Evaluator for ASM\n", "abstract": " This paper presents an o ine partial evaluator for Abstract State Machines. In order to allow specialization of ASM programs containing user-de ned functions (derived functions), the implementation combines techniques from partial evaluation of imperative and functional languages. Self-application of the partial evaluator is possible by means of a simpli ed version written in ASM itself. Using self-application, we have generated compilers for small languages from their interpreter de nitions. We also present techniques for describing the semantics of programming languages in a way suitable for partial evaluation.", "num_citations": "6\n", "authors": ["94"]}
{"title": "Discovering common bug\u2010fix patterns: A large\u2010scale observational study\n", "abstract": " Background: Automatic program repair aims to reduce costs associated with defect repair. The detection and characterization of common bug\u2010fix patterns in software repositories play an important role in advancing this field. Aim: In this paper, we characterize the occurrence of known bug\u2010fix patterns in Java repositories at an unprecedented large scale. Furthermore, we propose a novel automatic technique for unveiling frequent and isolated repair actions corresponding to realistic bug fixes in Java. Method: The study was conducted for Java GitHub projects organized in two distinct data sets. The first data set (Boa) contains more than 4 million bug\u2010fix commits from 101\u00a0471 projects. The second data set (Defects4J) contains 369 real bug fixes from five open\u2010source projects. Results: We characterized the prevalence of the five most common bug\u2010fix patterns (identified in the work of Pan et al) in those bug fixes. The\u00a0\u2026", "num_citations": "5\n", "authors": ["94"]}
{"title": "ModularityCheck: A tool for assessing modularity using co-change clusters\n", "abstract": " It is widely accepted that traditional modular structures suffer from the dominant decomposition problem. Therefore, to improve current modularity views, it is important to investigate the impact of design decisions concerning modularity in other dimensions, as the evolutionary view. In this paper, we propose the ModularityCheck tool to assess package modularity using co-change clusters, which are sets of classes that usually changed together in the past. Our tool extracts information from version control platforms and issue reports, retrieves co-change clusters, generates metrics related to co-change clusters, and provides visualizations for assessing modularity. We also provide a case study to evaluate the tool. http://youtu.be/7eBYa2dfIS8", "num_citations": "5\n", "authors": ["94"]}
{"title": "Software evolution aided by execution trace alignment\n", "abstract": " Several attempts to facilitate understanding the behavior of software systems have been proposed. Nonetheless, there is no widely accepted approach to facilitate understanding software systems with poor documentation with the goal that new developers could contribute with the evolution of these systems. The effort to understand complex systems may be a prohibitive factor in program comprehension tasks for many developers. This work proposes a new method based on the analysis of execution traces for locating points in the source code where changes that introduce new functionality should be performed. The proposed method was evaluated with a real world system, where new functionality were inserted with low effort.", "num_citations": "5\n", "authors": ["94"]}
{"title": "Abstractions for mobile computation in ASM\n", "abstract": " In this paper we present a formal method for the specification of mobile systems using Abstract State Machines (ASM). The method is based on the Ambient Calculus, a process calculus developed to express mobility. In the work we show that the fundamental abstractions of the Ambient Calculus can be expressed in ASM without difficulty. In order to exhibit the feasibility of the proposed method, we also show as a case study an ASM specification of a mobile system for electronic commerce.", "num_citations": "5\n", "authors": ["94"]}
{"title": "Key classes in object-oriented systems: Detection and assessment\n", "abstract": " Inadequate documentation of software design has been known to be a barrier for developers. Interestingly, several relevant object-oriented systems have their design documented using key classes, which are meant to represent key concepts of the systems. In order to fill the gap of under-documented design, we present Keecle, an approach for detecting a predefined number of key classes in a semi-automatic way. The main challenge is to reduce the space of potentially thousands of classes to just a few representatives of the main concepts of a system, while maintaining high precision. The approach is evaluated with 13 systems in order to assess its correctness. The ground-truth is obtained either from the original documentation, or from third-party, or from the respective developers. The results were analyzed in terms of precision and recall, and have shown to be superior compared to the state-of-the-art approach\u00a0\u2026", "num_citations": "4\n", "authors": ["94"]}
{"title": "Temporal influence of endocrine therapy with tamoxifen and chemotherapy on nutritional risk and obesity in breast cancer patients\n", "abstract": " The effect of endocrine therapy with tamoxifen (TMX) on weight gain has been reported in the literature, but the outcomes are still controversial. Moreover, previous treatment options, such as chemotherapy (CT), also include body changes. The focus of this study was to verify the temporal influence of endocrine therapy with TMX on nutritional risk and obesity and its association with CT in breast cancer patients. In this cross-sectional study, 84 breast cancer surviving women were evaluated during endocrine therapy with TMX. Anthropometric, biochemical and body composition parameters were measured. A generalized estimating equation (GEE) was used to examine the association between CT and groups of women using TMX categorized by the duration of the treatment (group 1, women using TMX for the first 3\u00a0years; group 2, women using TMX between 3 and 4\u00a0years and group 3, women using TMX for more than 4\u00a0years). The interaction of CT with duration of TMX use showed a significant effect on Body Mass Index (BMI), waist circumference (WC) and body fat percentage (BFP) (GEE p-value\u00a0=\u00a00.002, 0.000, 0.000, respectively). Women from group 1 who underwent CT presented higher values of body variables compared to those women from group 2 who also underwent CT (BMI\u00a0=\u00a029.14\u00a0\u00b1\u00a00.93, 26.76\u00a0\u00b1\u00a00.85\u00a0kg/m2; WC\u00a0=\u00a094.45\u00a0\u00b1\u00a01.96, 91.07\u00a0\u00b1\u00a02.44\u00a0cm; BFP\u00a0=\u00a036.36\u00a0\u00b1\u00a01.50, 33.43\u00a0\u00b1\u00a01.66%, respectively). On the other hand, women from group 1 who did not undergo CT presented lower values of body variables compared to those women from group 2 who also did not undergo CT (BMI\u00a0=\u00a025.29\u00a0\u00b1\u00a00.46, 28.40\u00a0\u00b1\u00a00.95\u00a0kg/m2; WC\u00a0=\u00a085.84\u00a0\u00b1\u00a00.90, 97\u00a0\u2026", "num_citations": "4\n", "authors": ["94"]}
{"title": "INDIAM um sistema de ensino para auxiliar estudantes na interpreta\u00e7\u00e3o de mamografias e diagn\u00f3sticos de c\u00e2ncer de mama via Web\n", "abstract": " Este projeto apresenta uma vis\u00e3o geral sobre o INDIAM\u2014INterpreta\u00e7\u00e3o e DIAgn\u00f3stico de Mamografias\u2014um sistema de educa\u00e7\u00e3o \u00e0 dist\u00e2ncia, orientado a problema, para auxiliar estudantes de medicina na interpreta\u00e7\u00e3o de mamogramas e no diagn\u00f3stico de c\u00e2ncer de mama. A base de conhecimento do INDIAM \u00e9 composta por uma base de dados mamogr\u00e1ficos que inclui as quatro vistas mamogr\u00e1ficas, os achados radiol\u00f3gicos global e local, o diagn\u00f3stico comprovado por biopsia, o hist\u00f3rico cl\u00ednico e informa\u00e7\u00f5es sobre o estilo de vida da paciente; por uma ontologia denominada BreastCancerOnto, que incorpora sem\u00e2ntica aos servi\u00e7os Web integrados ao sistema; e por um tutorial hipertexto que orienta os usu\u00e1rios (m\u00e9dicos, estudantes, ou pesquisadores) na navega\u00e7\u00e3o pelos conceitos relacionados com o diagn\u00f3stico de c\u00e2ncer de mama. O sistema de ensino sendo proposto \u00e9 composto por quatro servi\u00e7os Web: 1) que orienta o estudante iniciante, passo a passo, para an\u00e1lise correta de um dado mamograma; 2) que simula o diagn\u00f3stico de c\u00e2ncer de mama dada uma mamograma recuperada a partir da base de dados mamogr\u00e1ficos; 3) que responde \u00e0s quest\u00f5es dos usu\u00e1rios de acordo com a BreastCancerOnto; 4) e finalmente, que disponibiliza um tutorial sobre diagn\u00f3stico de c\u00e2ncer de mama usando t\u00e9cnicas de educa\u00e7\u00e3o. O sistema de ensino INDIAM ser\u00e1 integrado a um atlas indexado de mamografias digitais acessado via Web.", "num_citations": "4\n", "authors": ["94"]}
{"title": "Mach na: A Linguagem de Especifica c\u00e3o de ASM\n", "abstract": " Este texto cont em a defini c\u00e3o da Linguagem de Programa c\u00e3o Mach na, que e uma linguagem baseada no paradigma de Programa c\u00e3o Alg ebrica, derivado do modelo de M aquinas de Estado Abstratas (ASM). Nesta defini c\u00e3o, apresentamos a sem^ antica informal de Mach na, descrevendo os aspectos sem^ anticos da linguagem por meio de linguagem natural e exemplos de utiliza c\u00e3o das constru c\u00f5es da linguagem. Ao final, apresentamos v arios exemplos de programas escritos em Mach na.", "num_citations": "4\n", "authors": ["94"]}
{"title": "Co-change patterns: A large scale empirical study\n", "abstract": " Co-Change Clustering is a modularity assessment technique that reveals how often changes are localized in modules and whether a change propagation represents design problems. This technique is centered on co-change clusters, which are highly inter-related source code files considering co-change relations. In this paper, we conduct a series of empirical analysis in a large corpus of 133 popular software projects on GitHub. We describe six co-change patterns by projecting them over the directory structure. We mine 1802 co-change clusters and 1719 co-change clusters (95%) are covered by the six co-change patterns. In this study, we aim to answer two central questions: (i) Are co-change patterns detected in different programming languages? (ii) How do different co-change patterns relate to rippling, activity density, ownership, and team diversity on clusters? We conclude that Encapsulated and Well\u00a0\u2026", "num_citations": "3\n", "authors": ["94"]}
{"title": "Improving feature location accuracy via paragraph vector tuning\n", "abstract": " Improving feature location accuracy via paragraph vector tuning - Dialnet Ir al contenido Dialnet Buscar Revistas Tesis Congresos Ayuda Improving feature location accuracy via paragraph vector tuning Allysson Costa e Silva [2] ; Marcelo de Almeida Maia [1] 1.[1] Federal University of Uberl\u00e2ndia Federal University of Uberl\u00e2ndia Brasil 2.[2] State University of Montes Claros Localizaci\u00f3n: Information and software technology, ISSN 0950-5849, N\u00ba 116, 2019, p\u00e1gs. 1-4 Idioma: ingl\u00e9s Enlaces Texto completo Fundaci\u00f3n Dialnet Acceso de usuarios registrados Imagen de identificaci\u00f3n Identificarse \u00bfOlvid\u00f3 su contrase\u00f1a? \u00bfEs nuevo? Reg\u00edstrese Ventajas de registrarse Dialnet Plus M\u00e1s informaci\u00f3n sobre Dialnet Plus Opciones de compartir Facebook Twitter Opciones de entorno Sugerencia / Errata \u00a9 2001-2020 Fundaci\u00f3n Dialnet \u00b7 Todos los derechos reservados Dialnet Plus Accesibilidad Aviso Legal Coordinado por: IB\u2026", "num_citations": "2\n", "authors": ["94"]}
{"title": "Automated Computation of Use Cases Similarity can Aid the Assessment of Cohesion and Complexity of Classes (S).\n", "abstract": " Use cases are widely used in early software development phases such as requirements analysis. In this paper, we investigate how use case similarity can impact the classes that implement them. We studied whether the similarity of use cases can have impact on the lines of code shared between them and on metrics of classes that implement them, such as coupling, cohesion and method complexity. We have also successfully applied an automated approach to assess the similarity of use case names. We found that there is a statistically significant correlation, although not strong, between use case similarity and sharing of lines of code. Interestingly, we have also found that classes that are shared between different use cases tend to have lower cohesion. Moreover, classes that are shared between similar use cases tend to have higher method complexity in classes. We found no relation between use case similarity and coupling.", "num_citations": "2\n", "authors": ["94"]}
{"title": "On the actual use of inheritance and interface in Java projects: evolution and implications\n", "abstract": " Background: Inheritance is one of the main features in the objectoriented paradigm (OOP). Nonetheless, previous work recommend carefully using it, suggesting alternatives such as the adoption of composition with implementation of interfaces. Despite of being a well-studied theme, there is still li le knowledge if such recommendations have been widely adopted by developers in general. Aims: is work aims at evaluating how the inheritance and composition with interfaces have been used in Java, comparing new projects with older ones (transversal), and also the di erent releases of the same projects (longitudinal). Method: A total of 1,656 open-source projects built between 1997 and 2013, hosted in the repositories GitHub and SourceForge, were analyzed. e likelihood of more recent projects using inheritance and interfaces di erently from older ones was analyzed considering indicators, such as, the prevalence of corrective changes, instanceof operations, and code smells. Regression analysis, chi-squared test of proportions and descriptive statistics were used to analyze the data. In addition, a thematic analysis based method was used to verify how o en and why inheritance and interface are added or removed from classes. Results: We observed that developers still use inheritance primarily for code reuse, motivated by the need to avoid duplicity of source code. In newer projects, classes in inheritance had fewer corrective changes and subclasses had fewer use of the instanceof operator. However, as they evolve, classes in inheritance tend to become complex as changes occur. Classes implementing interfaces have shown li le relation to\u00a0\u2026", "num_citations": "1\n", "authors": ["94"]}
{"title": "On the properties of design-relevant classes for design anomaly assessment\n", "abstract": " Several object-oriented systems have their respective designs documented by using only a few design-relevant classes, which we will refer to as key classes. In this paper, we automatically detect key classes, and investigate some of their properties, and evaluate their role for assessing design. We propose focusing on such classes to make design decisions during maintenance tasks as those classes of this type are, by definition, more relevant than non-key classes. First, we show that key classes are more prone to bad smells than non-key classes. Although, structural metrics of key classes tend to be, in general, higher than non-key classes, there are still a significant set of non-key classes with poor structural metrics, suggesting that prioritizing design anomaly assessment using key classes would likely to be more effective.", "num_citations": "1\n", "authors": ["94"]}
{"title": "Uma an\u00e1lise da associa\u00e7 ao de co-ocorr\u00eancia de anomalias de c\u00f3digo com m\u00e9tricas estruturais\n", "abstract": " Source code anomalies (code bad smells) were characterized as symptoms of poor programming practices that should be either avoided or eliminated by refactoring. Several recent studies have recognized that the impact caused by these source code anomalies does not have the same severity. Although these studies have been conducted in order to understand the dynamics of the life cycle of the source code anomalies, there is little knowledge about how the source code anomalies evolve in the affected entities, especially regarding the question of how a code anomaly in an entity may induce the co-occurrence of other code anomaly during its evolution. This work studied the evolution of 5 systems, analyzing 12 types of anomalies that were introduced during the life cycle of their respective developments. We observed that 6 inter-relations anomalies between the anomalies analyzed were more prominent, and Long Method has great influence in all founded anomalies. With this anomaly, classes have highter coupling and lower cohesion, besides being more likely to introduce new types of anomalies.Resumo. Anomalias de c\u00f3digo (code bad smells) foram caracterizadas como sintomas de m\u00e1s pr\u00e1ticas de programa\u00e7ao que deveriam ser evitadas ou entao eliminadas por meio de refatora\u00e7ao. V\u00e1rios estudos recentes j\u00e1 reconhecem que os danos causados pelas anomalias de c\u00f3digo nao t\u00eam a mesma severidade. Apesar de esses estudos terem sido conduzidos com o intuito de entender a din\u00e2mica do ciclo de vida das anomalias de c\u00f3digo, ainda existe pouco conhecimento a respeito de como tais anomalias evoluem nas entidades\u00a0\u2026", "num_citations": "1\n", "authors": ["94"]}
{"title": "Developers\u2019 importance from the leader perspective\n", "abstract": " Several companies use the amount of deliveries as a metric of performance evaluation of the developer. However, the productivity of a developer and his importance for the company is not only related to the amount of lines of code produced. There are a variety of factors that can contribute to the relevance of a developer for a team. This paper aims at mapping some of these factors, measuring those that are more important for companies and propose an evaluation model of developer importance that considers more than just deliveries. We have found that some factors are more important than others and that there are minor differences for different companies. We have also developed a high accuracy classifier that can indicate the importance of the developer based on a set of attributes.", "num_citations": "1\n", "authors": ["94"]}
{"title": "An Empirical Assessment of the Use of Execution Traces in Software Maintenance\n", "abstract": " One of the most frequent problems faced by software maintainers is to find the location of the code related with specific features. This is a costly task because features tend to be scattered in the code. Considering this problem, several approaches for locating features using dynamic analysis have been developed. Nonetheless, the use of dynamic analysis is not fully incorporated in the daily practice of software maintainers. Empirical studies that reveal strengths and weaknesses of the use dynamic analysis in maintenance tasks can bring better understanding of this problem. This study contributes with an empirical assessment of the use of execution traces on software maintenance. We report on a controlled experiment performed with developers when they were performing actual maintenance activities on systems of different sizes. There are benefits related with a systematic use of execution traces by reducing the\u00a0\u2026", "num_citations": "1\n", "authors": ["94"]}
{"title": "O impacto do uso de rastros de execu\u00e7\u00e3o em atividades de localiza\u00e7\u00e3o de caracter\u00edsticas de software: um experimento controlado\n", "abstract": " Um dos problemas mais frequentes enfrentados em manuten\u00e7\u00e3o de software \u00e9 a localiza\u00e7\u00e3o do c\u00f3digo para caracter\u00edsticas espec\u00edficas, as quais s\u00e3o importantes para a compreens\u00e3o de requisitos de software. Descobrir onde uma caracter\u00edstica est\u00e1 localizada \u00e9 uma tarefa custosa porque, em geral, estas tendem a estar espalhadas ou entrela\u00e7adas pelo c\u00f3digo. Considerando este problema, foi desenvolvida uma abordagem para localiza\u00e7\u00e3o de caracter\u00edsticas utilizando an\u00e1lise din\u00e2mica, que apresenta vis\u00f5es geradas a partir dos rastros de execu\u00e7\u00e3o. O objetivo desta abordagem \u00e9 auxiliar na compreens\u00e3o das caracter\u00edsticas, ao tornar mais r\u00e1pida a sua localiza\u00e7\u00e3o, com informa\u00e7\u00f5es que direcionam a compreens\u00e3o e propiciam maior taxa de acerto nas atividades de manuten\u00e7\u00e3o. Para avalia\u00e7\u00e3o desta abordagem e verificar se o objetivo \u00e9 alcan\u00e7ado, foi realizado um estudo controlado com sujeitos humanos, executando atividades reais de manuten\u00e7\u00e3o em sistemas de diferentes portes. O estudo pretende contribuir com a avalia\u00e7\u00e3o do impacto do uso de informa\u00e7\u00f5es de rastros de execu\u00e7\u00e3o em atividades de manuten\u00e7\u00e3o de software. Este estudo mostrou os benef\u00edcios do uso sistem\u00e1tico de informa\u00e7\u00e3o de rastros de execu\u00e7\u00e3o na diminui\u00e7\u00e3o do tempo de execu\u00e7\u00e3o e no aumento da taxa de acerto em atividades de manuten\u00e7\u00e3o de software para o problema apresentado. As vis\u00f5es da abordagem proposta foram \u00fateis atrav\u00e9s da localiza\u00e7\u00e3o das caracter\u00edsticas de interesse e redu\u00e7\u00e3o do espa\u00e7o de busca inicial, levando ao direcionamento na busca pelas informa\u00e7\u00f5es, acarretando em um menor n\u00edvel de dificuldade percebida pelos participantes\u00a0\u2026", "num_citations": "1\n", "authors": ["94"]}
{"title": "An\u00e1lise do Espalhamento de Caracter\u00edsticas pela Interpreta\u00e7\u00e3o Visual de Rastros de Execu\u00e7\u00e3o\n", "abstract": " Feature location in the source code still is a challenge, specially when the source-code is not modularized in a feature-fashioned way, causing feature scattering. This work proposes a method for understanding feature scattering through the graphical interpretation of relationships between feature elements and source code elements. The proposed tool collects and represents trace events of multithreaded programs and shows some graphics that help in feature scattering analysis. The proposed method and tool are validated with the analysis of some features of the ArgoUML CASE tool. The conclusion is that interesting information about feature location can be straightforwardly found.Resumo. A localiza\u00e7\u00e3o de caracter\u00edsticas no c\u00f3digo-fonte ainda \u00e9 um desafio, especialmente quando o c\u00f3digo n\u00e3o foi modularizado com base em caracter\u00edsticas, causando assim o espalhamento. Este trabalho prop\u00f5e um m\u00e9todo para o entendimento do espalhamento de caracter\u00edsticas pela interpreta\u00e7\u00e3o visual de relacionamentos entre caracter\u00edsticas e elementos do c\u00f3digo fonte. A ferramenta proposta coleta e representa rastros de execu\u00e7\u00e3o de programas multi-thread e mostra alguns gr\u00e1ficos que auxiliam na an\u00e1lise do espalhamento. O m\u00e9todo proposto e a ferramenta s\u00e3o validados com a an\u00e1lise de algumas caracter\u00edsticas da ferramenta CASE ArgoUML. A conclus\u00e3o \u00e9 que informa\u00e7\u00f5es interessantes sobre a localiza\u00e7\u00e3o das caracter\u00edsticas podem ser encontradas de forma simples.", "num_citations": "1\n", "authors": ["94"]}
{"title": "A utiliza\u00e7\u00e3o de curativos no tratamento de eviscera\u00e7\u00e3o: relato de caso\n", "abstract": " A eviscera\u00e7\u00e3o \u00e9 caracterizada como proje\u00e7\u00e3o das v\u00edsceras para fora da cavidade abdominal ocorrendo simultaneamente \u00e0 deisc\u00eancia de sutura ou durante sua evolu\u00e7\u00e3o. O objetivo deste trabalho \u00e9 relatar a utiliza\u00e7\u00e3o de curativo com gaze n\u00e3o aderente embebida em petrolatum associada ao hidrogel e posteriormente o uso de \u00c1cidos Graxos Essenciais (AGE), no tratamento de um paciente com deisc\u00eancia abdominal e eviscera\u00e7\u00e3o. Trata-se de um estudo de caso na modalidade qualitativa que foi realizado no Hospital de Base de S\u00e3o Jos\u00e9 do Rio Preto. Concluiu-se que os produtos utilizados apresentaram resultado satisfat\u00f3rio, pois a cicatriza\u00e7\u00e3o completa da les\u00e3o ocorreu em aproximadamente tr\u00eas meses.", "num_citations": "1\n", "authors": ["94"]}
{"title": "Assessing Program Comprehension Tools With The Communicability Evaluation Method\n", "abstract": " Most program comprehension tools present information extracted from the source code in a visual way. The user interface of a comprehension tool may support or hinder the strategy used by the programmer. Furthermore, which and how information is presented to the programmer may influence the effectiveness of the comprehension process. Within this context, this paper shows theassessment of the user interface of selected program comprehension tools which support different comprehension strategies. A communicability evaluation method is conducted with users executing typical comprehension tasks using SHriMP and Understand for Java c. The communicability evaluation method captures communicative breakdowns during the user-system interaction, ie, it identifies difficulties experimented by users in understanding the comprehension tool during the interaction. Our goal is to collect indicators on the quality of user-system interaction based on relevant breakdowns that took place during the evaluation. We show some findings that may help designing better tools.", "num_citations": "1\n", "authors": ["94"]}
{"title": "Formal semantics for interacting abstract state machines\n", "abstract": " In this work we propose an extension to the original model of Abstract State Machines. We focus on the modularization support and on the explicit interaction abstraction between the modules (units of speci cation). We provide the new language syntax and formal semantics, and also some examples showing its use.", "num_citations": "1\n", "authors": ["94"]}