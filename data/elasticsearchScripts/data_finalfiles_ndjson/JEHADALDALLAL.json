{"title": "A precise method-method interaction-based cohesion metric for object-oriented classes\n", "abstract": " The building of highly cohesive classes is an important objective in object-oriented design. Class cohesion refers to the relatedness of the class members, and it indicates one important aspect of the class design quality. A meaningful class cohesion metric helps object-oriented software developers detect class design weaknesses and refactor classes accordingly. Several class cohesion metrics have been proposed in the literature. Most of these metrics are applicable based on low-level design information such as attribute references in methods. Some of these metrics capture class cohesion by counting the number of method pairs that share common attributes. A few metrics measure cohesion more precisely by considering the degree of interaction, through attribute references, between each pair of methods. However, the formulas applied by these metrics to measure the degree of interaction cause the metrics to\u00a0\u2026", "num_citations": "136\n", "authors": ["84"]}
{"title": "An object-oriented high-level design-based class cohesion metric\n", "abstract": " ContextClass cohesion is an important object-oriented software quality attribute. Assessing class cohesion during the object-oriented design phase is one important way to obtain more comprehensible and maintainable software. In practice, assessing and controlling cohesion in large systems implies measuring it automatically. One issue with the few existing cohesion metrics targeted at the high-level design phase is that they are not based on realistic assumptions and do not fulfill expected mathematical properties.ObjectiveThis paper proposes a High-Level Design (HLD) class cohesion metric, which is based on realistic assumptions, complies with expected mathematical properties, and can be used to automatically assess design quality at early stages using UML diagrams.MethodThe notion of similarity between pairs of methods and pairs of attribute types in a class is introduced and used as a basis to\u00a0\u2026", "num_citations": "136\n", "authors": ["84"]}
{"title": "Object-oriented class maintainability prediction using internal quality attributes\n", "abstract": " ContextClass maintainability is the likelihood that a class can be easily modified. Before releasing an object-oriented software system, it is impossible to know with certainty when, where, how, and how often a class will be modified. At that stage, this likelihood can be estimated using the internal quality attributes of a class, which include cohesion, coupling, and size. To reduce the future class maintenance efforts and cost, developers are encouraged to carefully test and well document low maintainability classes before releasing the object-oriented system.ObjectiveWe empirically study the relationship between internal class quality attributes (size, cohesion, and coupling) and an external quality attribute (class maintainability). Using statistical techniques, we also construct models based on the selected internal attributes to predict class maintainability.MethodWe consider classes of three open-source systems. For\u00a0\u2026", "num_citations": "94\n", "authors": ["84"]}
{"title": "Identifying refactoring opportunities in object-oriented code: A systematic literature review\n", "abstract": " ContextIdentifying refactoring opportunities in object-oriented code is an important stage that precedes the actual refactoring process. Several techniques have been proposed in the literature to identify opportunities for various refactoring activities.ObjectiveThis paper provides a systematic literature review of existing studies identifying opportunities for code refactoring activities.MethodWe performed an automatic search of the relevant digital libraries for potentially relevant studies published through the end of 2013, performed pilot and author-based searches, and selected 47 primary studies (PSs) based on inclusion and exclusion criteria. The PSs were analyzed based on a number of criteria, including the refactoring activities, the approaches to refactoring opportunity identification, the empirical evaluation approaches, and the data sets used.ResultsThe results indicate that research in the area of identifying\u00a0\u2026", "num_citations": "83\n", "authors": ["84"]}
{"title": "Measuring the discriminative power of object-oriented class cohesion metrics\n", "abstract": " Several object-oriented cohesion metrics have been proposed in the literature. These metrics aim to measure the relationship between class members, namely, methods and attributes. Different metrics use different models to represent the connectivity pattern of cohesive interactions (CPCI) between class members. Most of these metrics are normalized to allow for easy comparison of the cohesion of different classes. However, in some cases, these metrics obtain the same cohesion values for different classes that have the same number of methods and attributes but different CPCIs. This leads to incorrectly considering the classes to be the same in terms of cohesion, even though their CPCIs clearly indicate that the degrees of cohesion are different. We refer to this as a lack of discrimination anomaly (LDA) problem. In this paper, we list and discuss cases in which the LDA problem exists, as expressed through the\u00a0\u2026", "num_citations": "82\n", "authors": ["84"]}
{"title": "Constructing models for predicting extract subclass refactoring opportunities using object-oriented quality metrics\n", "abstract": " ContextRefactoring is a maintenance task that refers to the process of restructuring software source code to enhance its quality without affecting its external behavior. Inspecting and analyzing the source code of the system under consideration to identify the classes in need of extract subclass refactoring (ESR) is a time consuming and costly process.ObjectiveThis paper explores the abilities of several quality metrics considered individually and in combination to predict the classes in need of ESR.MethodFor a given a class, this paper empirically investigates, using univariate logistic regression analysis, the abilities of 25 existing size, cohesion, and coupling metrics to predict whether the class is in need of restructuring by extracting a subclass from it. In addition, models of combined metrics based on multivariate logistic regression analysis were constructed and validated to predict the classes in need of ESR, and the\u00a0\u2026", "num_citations": "60\n", "authors": ["84"]}
{"title": "Mathematical validation of object-oriented class cohesion metrics\n", "abstract": " Class cohesion is an object-oriented software quality attribute and refers to the extent to which the members of a class are related. Software developers use class cohesion measures to assess the quality of their products and to guide the restructuring of poorly designed classes. Several class cohesion metrics are proposed in the literature, and a few of them are mathematically validated against the necessary properties of class cohesion. Metrics that violate class cohesion properties are not well defined, and their utility as indictors of the relatedness of class members is questionable. The purpose of this paper is to mathematically validate sixteen class cohesion metrics using class cohesion properties. Results show that metrics differ considerably in satisfying the cohesion properties; some of them satisfy all properties, while others satisfy none.", "num_citations": "58\n", "authors": ["84"]}
{"title": "Empirical evaluation of the impact of object-oriented code refactoring on quality attributes: A systematic literature review\n", "abstract": " Software refactoring is a maintenance task that addresses code restructuring to improve its quality. Many studies have addressed the impact of different refactoring scenarios on software quality. This study presents a systematic literature review that aggregates, summarizes, and discusses the results of 76 relevant primary studies (PSs) concerning the impact of refactoring on several internal and external quality attributes. The included PSs were selected using inclusion and exclusion criteria applied to relevant articles published before the end of 2015. We analyzed the PSs based on a set of classification criteria, including software quality attributes and measures, refactoring scenarios, evaluation approaches, datasets, and impact results. We followed the vote-counting approach to determine the level of consistency among the PS reported results concerning the relationship between refactoring and software quality\u00a0\u2026", "num_citations": "54\n", "authors": ["84"]}
{"title": "Fault prediction and the discriminative powers of connectivity-based object-oriented class cohesion metrics\n", "abstract": " ContextSeveral metrics have been proposed to measure the extent to which class members are related. Connectivity-based class cohesion metrics measure the degree of connectivity among the class members.ObjectiveWe propose a new class cohesion metric that has higher discriminative power than any of the existing cohesion metrics. In addition, we empirically compare the connectivity and non-connectivity-based cohesion metrics.MethodThe proposed class cohesion metric is based on counting the number of possible paths in a graph that represents the connectivity pattern of the class members. We theoretically and empirically validate this path connectivity class cohesion (PCCC) metric. The empirical validation compares seven connectivity-based metrics, including PCCC, and 11 non-connectivity-based metrics in terms of discriminative and fault detection powers. The discriminative-power study explores\u00a0\u2026", "num_citations": "53\n", "authors": ["84"]}
{"title": "A design-based cohesion metric for object-oriented classes\n", "abstract": " Class cohesion is an important object-oriented software quality attribute. It indicates how much the members in a class are related. Assessing the class cohesion and improving the class quality accordingly during the object-oriented design phase allows for cheaper management of the later phases. In this paper, the notion of distance between pairs of methods and pairs of attribute types in a class is introduced and used as a basis for introducing a novel class cohesion metric. The metric considers the methodmethod, attribute-attribute, and attribute-method direct interactions. It is shown that the metric gives more sensitive values than other well-known design-based class cohesion metrics.", "num_citations": "49\n", "authors": ["84"]}
{"title": "The impact of accounting for special methods in the measurement of object-oriented class cohesion on refactoring and fault prediction activities\n", "abstract": " Class cohesion is a key attribute that is used to assess the design quality of a class, and it refers to the extent to which the attributes and methods of the class are related. Typically, classes contain special types of methods, such as constructors, destructors, and access methods. Each of these special methods has its own characteristics, which can artificially affect the class cohesion measurement. Several metrics have been proposed in the literature to indicate class cohesion during high- or low-level design phases. The impact of accounting for special methods in cohesion measurement has not been addressed for most of these metrics. This paper empirically explores the impact of including or excluding special methods on cohesion measurements that were performed using 20 existing class cohesion metrics. The empirical study applies the metrics that were considered to five open-source systems under four\u00a0\u2026", "num_citations": "47\n", "authors": ["84"]}
{"title": "Improving the applicability of object-oriented class cohesion metrics\n", "abstract": " ContextClass cohesion is an important object-oriented quality attribute. It refers to the degree of relatedness between the methods and attributes of a class. Several metrics have been proposed to measure the extent to which the class members are related. Most of these metrics have undefined values for a relatively high percentage of classes, which limits their applicability. The classes that have undefined values lack methods, attributes, or parameter types, or they include only a single method.ObjectiveWe improve the applicability of the class cohesion metrics by defining their values for such special classes. In addition, we theoretically and empirically validate the improved metrics.MethodWe theoretically examine whether the defined values satisfy the key cohesion properties. In addition, we empirically validate the metrics before and after the improvements to test whether the defined values improve the ability of\u00a0\u2026", "num_citations": "43\n", "authors": ["84"]}
{"title": "Predicting object-oriented class reuse-proneness using internal quality attributes\n", "abstract": " Class reuse-proneness is the likelihood that a class can be reused and is a key quality characteristic in object-oriented design. Because it is clearly impossible to know with certainty when, where, how, and how often a class will be reused, this likelihood can only be estimated when a class is developed. At that stage, the internal quality attributes of a class such as cohesion, coupling, and size can be measured. In this paper, we empirically study the ability of 29 internal class quality measures, individually and in combination, to estimate class reuse-proneness. Specifically, we take into account both class inheritance and class instantiation, which are two ways in which a class can be reused. Our results show that most of the considered measures are predictors for the considered reuse-proneness attributes to some degree. The capability of the considered internal quality measures to predict class reuse\u00a0\u2026", "num_citations": "40\n", "authors": ["84"]}
{"title": "Software similarity-based functional cohesion metric\n", "abstract": " Cohesion is an important factor used in evaluating software design quality and modularity. The cohesion of a module refers to the relatedness of the module components. In software engineering, highly cohesive modules are highly desirable because of their high reusability and maintainability. Cohesion is classified according to levels. Functional cohesion, the strongest level, refers to how closely the module parts that contribute to different outputs are related. Here, a similarity-based functional cohesion (SBFC) metric is introduced to measure the functional cohesion of a module in a procedural or object-oriented program. The metric uses the degree of similarity between the data slices of the module as a basis to measure functional cohesion. The appropriateness of the metric is evaluated both theoretically and empirically. The evaluation results show that the metric does as well as some earlier metrics in indicating\u00a0\u2026", "num_citations": "37\n", "authors": ["84"]}
{"title": "Reusing class\u2010based test cases for testing object\u2010oriented framework interface classes\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. Frameworks are introduced to reduce the cost of a product line (i.e., family of products that share the common features) and to increase the maintainability of software products through the deployment of reliable large\u2010scale reusable components. A key challenge with frameworks is the development, evolution and maintenance of test cases to ensure the framework operates appropriately in a given application or product. Reusable test cases increase the maintainability of the software products because an entirely new set of test cases does not have to be generated each time the framework is deployed. At the framework deployment stage, the application developers (i.e., framework users) may need the flexibility to ignore or modify part of the specification used to generate the reusable class\u2010based test cases\u00a0\u2026", "num_citations": "31\n", "authors": ["84"]}
{"title": "Incorporating transitive relations in low\u2010level design\u2010based class cohesion measurement\n", "abstract": " Class cohesion metrics apply different approaches to quantify the relatedness of the attributes and methods in a class. These relations can be direct or transitive. Method invocations are among the key sources of potential transitive attribute\u2013method relations. That is, a method is not only related to the attributes that it references, but it may also be transitively related to the attributes referenced by the methods that it invokes. A few of the existing class cohesion metrics capture this potential transitive cohesion aspect. In this paper, we classify the method invocations as direct or transitive. The definitions of the class representative models used by 16 existing low\u2010level design (LLD) metrics are extended to incorporate the cohesion caused by the two types of method invocations. The impact of incorporating the transitive relations because of the two types of method invocations on the cohesion values and on the ability of the\u00a0\u2026", "num_citations": "25\n", "authors": ["84"]}
{"title": "Dynamic data flow analysis for Java programs\n", "abstract": " A large portion of high-level computer programs consists of data declaration. Thus, an increased focus on testing the data flow aspects of programs should be considered. In this paper, we consider testing the data flow in Java programs dynamically. Data flow analysis has been applied for testing procedural and some object-oriented programs. We have extended the dynamic data flow analysis technique to test Java programs and show how it can be applied to detect data flow anomalies.", "num_citations": "25\n", "authors": ["84"]}
{"title": "Transitive-based object-oriented lack-of-cohesion metric\n", "abstract": " Classes are the basic units in object-oriented programs. Therefore, the quality of a class has a great impact on the overall quality of the software. Class cohesion is one of the important quality factors and it refers to the degree of relatedness of the class attributes and methods. Several class cohesion metrics are proposed in the literature, and a few of them empirically address the effect of considering transitive relations between class attributes and methods caused by method invocations. In this paper, we address this issue for one of the most popular class cohesion metrics, referenced as Lack of Cohesion (LCOM). Our empirical study involves applying the metric with and without considering transitive relations on classes of two open source Java applications and statistically analyzing the results. The empirical study results show that the ability of LCOM in indicating class quality improves when considering both direct\u00a0\u2026", "num_citations": "24\n", "authors": ["84"]}
{"title": "Testing Software Assets of Framework-Based Product Families During Application Engineering Stage.\n", "abstract": " An application framework provides reusable design and implementation for a family of software systems. At the application engineering stage, application developers extend framework assets to build their particular framework instantiations. Typically, framework software assets are tested before being used. However, achieving complete coverage of a system under test is impossible or at least impractical. Therefore, framework software assets can have undiscovered errors that appear in some instantiations. During the application engineering stage, it is important to identify the framework use cases that are used in the instantiation but not covered during the framework testing stage.In this paper, a testing model that considers retesting framework assets during the application engineering stage is proposed. In addition, a test-case-reusing technique is introduced to identify uncovered framework use cases and cover them by reusing the test cases already built during the framework domain engineering stage. Empirical studies are reported to show the adequacy of the proposed framework test-case-reusing technique in terms of reducing testing time and effort, and a supporting tool that automates the proposed test-case-reusing technique is developed and introduced.", "num_citations": "21\n", "authors": ["84"]}
{"title": "Predicting move method refactoring opportunities in object-oriented code\n", "abstract": " ContextRefactoring is the maintenance process of restructuring software source code to improve its quality without changing its external behavior. Move Method Refactoring (MMR) refers to moving a method from one class to the class in which the method is used the most often. Manually inspecting and analyzing the source code of the system under consideration to determine the methods in need of MMR is a costly and time-consuming process. Existing techniques for identifying MMR opportunities have several limitations, such as scalability problems and being inapplicable in early development stages. Most of these techniques do not consider semantic relationships.ObjectiveWe introduce a measure and a corresponding model to precisely predict whether a class includes methods in need of MMR. The measure is applicable once a class has entered the early development stages without waiting for other classes\u00a0\u2026", "num_citations": "16\n", "authors": ["84"]}
{"title": "Estimating the coverage of the framework application reusable cluster-based test cases\n", "abstract": " Object-oriented frameworks support both software code and design reusability. In addition, it is found that providing class-based tests with the framework reduces considerably the class-based testing time and effort of the applications developed using the frameworks. Similarly, reusable cluster-based test cases can be generated using the framework hooks, and they, too, can be provided with the framework to reduce the cluster testing time and effort of the framework applications.In this paper, we introduce a methodology to estimate the possible coverage of the cluster-based reusable test cases for framework applications prior to suggesting and applying a specific technique to produce the test cases. An experimental case study is conducted to demonstrate the practical issues in applying the introduced methodology and to give insights on the possible coverage of the framework reusable cluster-based test cases\u00a0\u2026", "num_citations": "16\n", "authors": ["84"]}
{"title": "Generating class based test cases for interface classes of object-oriented black box frameworks\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. Application developers extend the framework to build their particular applications using hooks. Hooks are the places identified to show how to use and customize the framework. Hooks define the Framework Interface Classes (FICs) and their possible specifications, which helps in building reusable test cases for the implementations of these classes. This paper introduces a novel technique called all paths-state to generate state-based test cases to test the FICs at class level. The technique is experimentally evaluated. The empirical evaluation shows that all paths-state technique produces test cases with a high degree of coverage for the specifications of the implemented FICs comparing to test cases generated using round-trip path and all-transition techniques.", "num_citations": "16\n", "authors": ["84"]}
{"title": "System testing for object-oriented frameworks using hook technology\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. If the framework contains defects, the defects will be passed on to the applications developed from the framework. Framework defects are hard to discover at the time the framework is instantiated. Therefore, it is important to remove all defects before instantiating the framework. The problem addressed in this paper is developing an automated state-based test suite generator technique that uses hook technology to produce test suites to test frameworks at the system level. A case study is reported and its results show that the proposed technique is reasonably effective at detecting faults. A supporting tool that automatically produces framework test cases, executes them, and evaluates the results is presented.", "num_citations": "16\n", "authors": ["84"]}
{"title": "Anomaly detection in concurrent Java programs using dynamic data flow analysis\n", "abstract": " Concurrency constructs are widely used when developing complex software such as real-time, networking and multithreaded client\u2013server applications. Consequently, testing a program, which includes concurrency constructs is a very elaborate and complex process. In this work, we first identify the different classes of synchronization anomalies that may occur in concurrent Java programs. We then consider testing concurrent Java programs against synchronization anomalies using dynamic data flow analysis techniques. Moreover, we show how the data flow analysis technique can be extended to detect such anomalies.", "num_citations": "16\n", "authors": ["84"]}
{"title": "Testing syntax and semantic coverage of Java language compilers\n", "abstract": " Software testing is a critical and important stage of the application software development life-cycle. Testing is a verification activity that affects the overall software quality. The verification of critical and dependable computer software such as real-time safety-critical software systems consumes about 50% of the project time. In this work, we consider testing compilers. Since a compiler is a highly usable software, an increased emphasis on reliability requires a careful testing before releasing the compiler. In compiler testing, the compiler implementation is verified to conform to the specified language syntax and semantic available in the standard language documentation. In this work, an algorithm is designed and a tool is developed to automate the generation of test cases to check the language syntax. In addition, we propose a heuristic approach to cover language semantics. Since Java is a relatively new programming\u00a0\u2026", "num_citations": "16\n", "authors": ["84"]}
{"title": "The impact of inheritance on the internal quality attributes of Java classes\n", "abstract": " Inheritance is a key concept in object-oriented programming. Designing and implementing the inheritance relations in a software system properly is expected to improve the quality of the system. This paper uses the class flattening approach to empirically investigate the impact of inheritance on three internal quality attributes: size, cohesion, and coupling. This paper explains how to flatten Java classes and reports the application of the process on classes of five Java open-source systems. The size, cohesion, and coupling of the original and flattened classes were measured using 28 existing metrics, and the results are compared to empirically explore the relationship between inheritance and class quality. The results show that considering inheritance relations in software development significantly improves the class quality. In addition, the results of the study demonstrate that class flattening improves some cohesion metrics that indicate class quality. Finally, this paper discusses the relationship between class flattening and some applications of interest to software practitioners, such as refactoring and indicating external quality attributes.", "num_citations": "15\n", "authors": ["84"]}
{"title": "Efficient program slicing algorithms for measuring functional cohesion and parallelism\n", "abstract": " Program slicing is the task of finding all statements in a program that directly or indirectly influence the value of a variable occurrence. The set of statements that can affect the value of a variable at some point in a program is called a program slice. In several software engineering applications, such as program debugging and measuring program cohesion and parallelism, several slices are computed at different program points. In this paper, algorithms are introduced to compute all backward and forward static slices of a computer program by traversing the program representation graph once. The program representation graph used in this paper is called Program Dependence Graph (PDG). We have conducted an experimental comparison study using 25 software modules to show the effectiveness of the introduced algorithm for computing all backward static slices over single-point slicing approaches in computing the parallelism and functional cohesion of program modules. The effectiveness of the algorithm is measured in terms of time execution and number of traversed PDG edges. The comparison study results indicate that using the introduced algorithm considerably saves the slicing time and effort required to measure module parallelism and functional cohesion.", "num_citations": "12\n", "authors": ["84"]}
{"title": "Investigating the impact of fault data completeness over time on predicting class fault-proneness\n", "abstract": " ContextThe adequacy of fault-proneness prediction models in representing the relationship between the internal quality of classes and their fault-proneness relies on several factors. One of these factors is the completeness of the fault data. A fault-proneness prediction model that is built using fault data collected during testing or after a relatively short period of time after release may be inadequate and may not be reliable enough in predicting faulty classes.ObjectiveWe empirically study the relationship between the time interval since a system is released and the performance of the fault-proneness prediction models constructed based on the fault data reported within the time interval.MethodWe construct prediction models using fault data collected at several time intervals since a system has been released and study the performance of the models in representing the relationship between the internal quality of\u00a0\u2026", "num_citations": "11\n", "authors": ["84"]}
{"title": "Improving object-oriented lack-of-cohesion metric by excluding special methods\n", "abstract": " Classes are the basic units in object-oriented programs, and therefore, their quality has impact on the overall quality of the software. Class cohesion is a key quality factor, and it refers to the degree of relatedness of class attributes and methods. Software developers use class cohesion measure to assess the quality of their products and to guide the restructuring of poorly designed classes. Several class cohesion metrics are proposed in the literature, and the impact of considering the special methods (ie, constructors, destructors, and access methods) in cohesion calculation is not empirically studied for most of them. In this paper, we address this issue for one of the most popular class cohesion metrics, referenced as Lack of Cohesion (LCOM). Our empirical study involves applying the metric with and without considering special methods on classes of two open source Java applications and statistically analyzing the results. The empirical study results show that the ability of LCOM in indicating class quality slightly improves when excluding special methods from the LCOM computation.", "num_citations": "11\n", "authors": ["84"]}
{"title": "Testing object-oriented framework hook methods\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. The framework itself is not complete and users of the framework are expected to complete or extend the framework to build their particular instantiations. Places where users can add their own classes are called hooks. Hook descriptions specify how to build the methods that use the framework. These methods are called hook methods. When testing the framework, it is important to verify that the hook methods are speci \u5bb9 d correctly in the hook description. Otherwise, the generated implementations of the hook methods will not function properly. This paper introduces a technique to build a test suite for the hook methods. In addition, the paper introduces a tool that automates the testing process. The tool is applied to test several hook methods of a Client-Server Framework.", "num_citations": "11\n", "authors": ["84"]}
{"title": "Qualitative Analysis for the Impact of Accounting for Special Methods in Object-Oriented Class Cohesion Measurement.\n", "abstract": " Class cohesion is a key object-oriented software quality attribute. It refers to the degree of relatedness of class attributes and methods. Several class cohesion metrics are proposed in the literature. However, the impact of considering the special methods (ie, constructors, destructors, and access and delegation methods) in cohesion calculation is not thoroughly theoretically studied for most of the existing cohesion metrics. An incorrect determination of whether to include or exclude the special methods in cohesion measurement can lead to improper refactoring decisions according to the misleading class cohesion values that are obtained. In this paper, we qualitatively analyze the impact of including or excluding the special methods in cohesion measurement on the values that are obtained by applying 19 popular class cohesion metrics. The study is based on analyzing the definitions and formulas that are proposed for the metrics. The results show that including/excluding special methods has a considerable effect on the cohesion values that are obtained and that this effect varies from one metric to another. The study shows the importance of considering the types of methods that must be accounted for when proposing a cohesion metric.", "num_citations": "10\n", "authors": ["84"]}
{"title": "Automation of object-oriented framework application testing\n", "abstract": " Automation is a vital issue in software testing. Typically, many test cases have to be built and evaluated, which makes manual testing impractical for medium to large sized software systems. Object-oriented frameworks provide reusable design, implementation, and testing for a family of software systems. The classes that directly use or inherit the framework classes are called Framework Interface Classes (FICs). This paper addresses the automation issues related to the generation and use of the FIC reusable test cases. For this purpose, a tool called Framework Interface State Transition Tester (FIST2) is introduced and its prototype is developed. The tool generates reusable test cases for Java framework FICs at the framework development stage. The tool also deploys, executes, and evaluates the test cases at the application development stage.", "num_citations": "10\n", "authors": ["84"]}
{"title": "Class-based testing of object-oriented framework interface classes.\n", "abstract": " Degree: Ph. D.DegreeYear: 2003Institute: University of Alberta (Canada)Adviser: Paul Sorenson.An application framework provides a reusable design and implementation for a family of software systems. Frameworks are introduced to reduce the cost of a product line (ie, family of products that share common features). Software testing is a time-consuming, costly, and ongoing activity during the application software development process. Generating reusable test cases for the framework applications at the framework development stage and using the test cases to test part of the framework application whenever the framework is used can reduce the application development time and cost considerably.", "num_citations": "10\n", "authors": ["84"]}
{"title": "Accounting for data encapsulation in the measurement of object\u2010oriented class cohesion\n", "abstract": " Intuitively, in a certain class, a pair of methods that share an attribute of an object type is potentially more cohesive than those that share an attribute of a primitive type because the attribute of a reference type could implicitly refer to multiple data. Existing class cohesion measures ignore the implicit access to or sharing of attributes due to the encapsulation feature. As a result, the obtained cohesion values can be inaccurate and could lead to incorrect quality indications. This paper aims at demonstrating how to account for data encapsulation (DE) in cohesion measurement and reports empirical studies that investigate the impact of considering DE in cohesion measurement on cohesion values and the abilities of cohesion measures to predict class fault proneness. To differentiate between attributes and parameters of different types, we propose a weight assignment algorithm. The weight that is assigned to an\u00a0\u2026", "num_citations": "9\n", "authors": ["84"]}
{"title": "Automatic synthesis of timed protocol specifications from service specifications\n", "abstract": " Several methods have been proposed for synthesizing computer communication protocol specifications from service specifications. In real time applications, the time required to execute the events can be crucial and has to be considered. Some of the protocol synthesis methods do not consider timing constraints and, therefore, cannot be used in real time applications. In this paper, the assignment of the timing constraints to the service specification is discussed. In addition, an automatic method for synthesizing protocol specifications is extended to consider timing constraints given in the service specification. Both the service and protocol specifications are modeled using Timed Finite State Machines (TFSMs). The resulting synthesized protocol is guaranteed to conform to the timing constraints given in the service specification.", "num_citations": "9\n", "authors": ["84"]}
{"title": "Predicting fault-proneness of reused object-oriented classes in software post-releases\n", "abstract": " The performance and applicability of a fault-proneness prediction model built based on internal quality measures computed on classes of one or more software systems and applied to classes from a different software system may be heavily influenced by several factors. These factors are related to the specific characteristics of the software system and its development environment. The issues related to these factors may be alleviated by building a model on a release of a software system and then applying it to following releases, in which product and process characteristics are close to the initial release. In this paper, we investigate the ability of the fault-proneness prediction models built by using fault data available up to a release of a system to predict faulty classes among those that are potentially reusable and those that are actually reused in the subsequent releases. We adapt an approach to building\u00a0\u2026", "num_citations": "8\n", "authors": ["84"]}
{"title": "Efficient routing for wireless mesh networks using a backup path\n", "abstract": " Wireless mesh networks (WMNs) have a proven record in providing viable solutions for some of the fundamental issues in wireless networks such as capacity and range limitations. WMN infrastructure includes clusters of mobile ad\u2010hoc networks connected through a fixed backbone of mesh routers. The mesh network can be constrained severely because of various reasons, which could result in performance degradation such as a drop in throughput or long delays. Solutions to this problem often focus on multipath or multichannel extensions to the existing ad\u2010hoc routing protocols. In this paper, we propose a novel solution by introducing an alternative path to the mesh backbone that traverses the mobile ad\u2010hoc networks part of the WMN. The new routing solution allows the mobile nodes (MNs) to establish direct communication among peers without going through the backbone. The proposed alternative ad\u2010hoc\u00a0\u2026", "num_citations": "8\n", "authors": ["84"]}
{"title": "Validating object-oriented class cohesion metrics mathematically\n", "abstract": " Class cohesion refers to the extent to which the members of a class are related. Several class cohesion metrics are proposed in the literature to indicate class cohesion and a few of them are mathematically validated against the necessary properties of class cohesion. Metrics that violate class cohesion properties are not well defined, and their utility as indictors of the relatedness of class members is questionable. The purpose of this paper is to mathematically validate nine class cohesion metrics using class cohesion properties. Results show that the metrics differ considerably in satisfying the cohesion properties; some of them satisfy all properties and others satisfy none.", "num_citations": "8\n", "authors": ["84"]}
{"title": "Synthesizing distributed protocol specifications from a UML state machine modeled service specification\n", "abstract": " The object-oriented paradigm is widely applied in designing and implementing communication systems. Unified Modeling Language (UML) is a standard language used to model the design of object-oriented systems. A protocol state machine is a UML adopted diagram that is widely used in designing communication protocols. It has two key attractive advantages over traditional finite state machines: modeling concurrency and modeling nested hierarchical states. In a distributed communication system, each entity of the system has its own protocol that defines when and how the entity exchanges messages with other communicating entities in the system. The order of the exchanged messages must conform to the overall service specifications of the system. In object-oriented systems, both the service and the protocol specifications are modeled in UML protocol state machines. Protocol specification synthesis\u00a0\u2026", "num_citations": "7\n", "authors": ["84"]}
{"title": "Theoretical analysis for the impact of including special methods in lack-of-cohesion computation\n", "abstract": " Classes are the basic units in object-oriented programs, and therefore, their quality has impact on the overall quality of the software. Class cohesion is an object-oriented software internal key quality attribute, and it refers to the degree of relatedness of class members. Software developers use class cohesion measure to guide the restructuring of poorly designed classes and assess the quality of the software products. Several class cohesion metrics are proposed in the literature, and the impact of considering the special methods (i.e., constructors, destructors, and access and delegation methods) in cohesion calculation is not thoroughly theoretically studied for most of them. In this paper, we address this issue for five popular class lack-of-cohesion metrics. For each of the considered metrics we theoretically study the impact of including or excluding special methods on the values that are obtained by applying the\u00a0\u2026", "num_citations": "7\n", "authors": ["84"]}
{"title": "Theoretical validation of object-oriented lack-of-cohesion metrics\n", "abstract": " Class cohesion refers to the degree of relatedness of class attributes and methods. Software developers use class cohesion measure to assess the quality of their products and to guide the restructuring of poorly designed classes. Several class cohesion metrics are proposed in the literature, and a few of them are theoretically validated against the class cohesion necessary properties. Metrics that violate class cohesion properties are not well defined, and their utility as indictors of the relatedness of class members is questionable. The purpose of this paper is to theoretically validate six lack-of-cohesion based metrics. Results show that most of the metrics considered satisfy the majority of the class cohesion necessary properties.", "num_citations": "7\n", "authors": ["84"]}
{"title": "Service-oriented synthesis of distributed and concurrent protocol specifications\n", "abstract": " Several methods have been proposed for synthesizing computer communication protocol specifications from service specifications. Some protocol synthesis methods based on the finite state machine (FSM) model assume that primitives in the service specifications cannot be executed simultaneously. Others either handle only controlled primitive concurrency or have tight restrictions on the applicable FSM topologies. As a result, these synthesis methods are not applicable to an interesting variety of inherently concurrent applications, such as the Internet and mobile communication systems. This paper proposes a concurrent-based protocol synthesis method that eliminates the restrictions imposed by the earlier methods. The proposed method uses a synthesis method to obtain a sequential protocol specification (P-SPEC) from a given service specification (S-SPEC). The resulting P-SPEC is then remodeled to consider the concurrency behavior specified in the S-SPEC, while guaranteeing that P-SPEC provides the specified service.", "num_citations": "7\n", "authors": ["84"]}
{"title": "Testing object-oriented framework applications using FIST2 tool: a case study\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. Frameworks are introduced to reduce the cost of a product line (ie, a family of products that shares the common features). Software testing is a timeconsuming and costly ongoing activity during the application software development process. Generating reusable test cases for the framework applications during the framework development stage, and providing and using the test cases to test part of the framework application whenever the framework is used reduces the application development time and cost considerably. This paper introduces the Framework Interface State Transition Tester (FIST2), a tool for automated unit testing of Java framework applications. During the framework development stage, given the formal descriptions of the framework hooks, the specifications of the methods of the framework\u2019s extensible classes, and the illegal behavior description of the Framework Interface Classes (FICs), FIST2 generates unitlevel test cases for the classes. At the framework application development stage, given the customized method specifications of the implemented FICs, FIST2 automates the use, execution, and evaluation of the already generated test cases to test the implemented FICs. The paper illustrates the use of the FIST2 tool for testing several applications that use the SalesPoint framework.", "num_citations": "7\n", "authors": ["84"]}
{"title": "An overview of the world current and future assessment of novel COVID-19 trajectory, impact, and potential preventive strategies at healthcare settings\n", "abstract": " This study is an overview of the current and future trajectory, as well as the impact of the novel Coronavirus (COVID-19) in the world and selected countries including the state of Kuwait. The selected countries were divided into two groups: Group A (China, Switzerland, and Ireland) and Group B (USA, Brazil, and India) based on their outbreak containment of this virus. Then, the actual data for each country were fitted to a regression model utilizing the excel solver software to assess the current and future trajectory of novel COVID-19 and its impact. In addition, the data were fitted using the Susceptible\u2013Infected\u2013Recovered (SIR) Model. The Group A trajectory showed an \u201cS\u201d shape trend that suited a logistic function with r 2> 0.97, which is an indication of the outbreak control. The SIR models for the countries in this group showed that they passed the expected 99% end of pandemic dates. Group B, however, exhibited a continuous increase of the total COVID-19 new cases, that best suited an exponential growth model with r 2> 0.97, which meant that the outbreak is still uncontrolled. The SIR models for the countries in this group showed that they are still relatively far away from reaching the expected 97% end of pandemic dates. The maximum death percentage varied from 3.3%(India) to 7.2% with USA recording the highest death percentage, which is virtually equal to the maximum death percentage of the world (7.3%). The power of the exponential model determines the severity of the country\u2019s trajectory that ranged from 11 to 19 with the USA and Brazil having the highest values. The maximum impact of this COVID-19 pandemic occurred during the\u00a0\u2026", "num_citations": "6\n", "authors": ["84"]}
{"title": "Effects of incorporating special methods into cohesion measurement on class instantiation reuse-proneness prediction\n", "abstract": " The previously proposed class cohesion measures employ different approaches to assess the strength of the relations between the attributes and methods in a class. Access methods, constructors and destructors are special types of methods with special characteristics that can falsely alter the class cohesion measurement. In this study, the authors empirically explored the impact of considering special methods (SPs) on the cohesion measures' abilities to predict the classes that can be intensively reused via instantiation (IRI). They considered classes in the JHotDraw and Eclipse systems. For each class, they obtained cohesion results using 17 measures in four different scenarios of considering or ignoring SPs. They collected the instantiation reusability data and applied a statistical technique to build a prediction model using each measure in each considered scenario. They investigated the significance of the\u00a0\u2026", "num_citations": "6\n", "authors": ["84"]}
{"title": "The coverage of the object-oriented framework application class-based test cases\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. Frameworks are introduced to reduce the cost of a product line (ie, family of products that share the common features). Software testing is a time consuming and costly ongoing activity during the application software development process. Generating reusable test cases for the framework applications at the framework development stage, and providing and using the test cases to test part of the framework application whenever the framework is used reduces the application development time and cost considerably. Framework Interface Classes (FICs) are classes introduced by the framework hooks to be implemented at the application development stage. They can have reusable test cases generated at the framework development stage and provided with the framework to test the implementations of the FICs at the application development stage. In this paper, we conduct a case study using thirteen applications developed using three frameworks; one domain oriented and two application oriented. The results show that, in general, the percentage of the number of FICs in the applications developed using domain frameworks is, on average, greater than the percentage of the number of FICs in the applications developed using application frameworks. Consequently, the reduction of the application unit testing time using the reusable test cases generated for domain frameworks is, in general, greater than the reduction of the application unit testing time using the reusable test cases generated for application frameworks.", "num_citations": "6\n", "authors": ["84"]}
{"title": "Generating State-Based Testing Models for Object-Oriented Framework Interface Classes\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. Application developers extend the framework to build their particular applications using hooks. Hooks are the places identified to show how to use and customize the framework. Hooks define the Framework Interface Classes (FICs) and the specifications of their methods. As part of the development life cycle, it is required to test the implementations of the FICs. Building a testing model to express the behavior of a class is an essential step for the generation of the class-based test cases. The testing model has to be consistent with the specifications provided for the hooks. State-based models consisting of states and transitions are testing models well suited to objectoriented software. Typically, hand-construction of a state-based model of a class behavior is expensive, error-prone, and may result in constructing an inconsistent model with the specifications of the class methods, which misleads verification results. In this paper, a technique is introduced to automatically synthesize a state-based testing model for FICs using the specifications provided for the hooks. A tool that supports the proposed technique is introduced.", "num_citations": "6\n", "authors": ["84"]}
{"title": "Generating class based test cases for interface classes of object-oriented gray-box frameworks\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. Application developers extend the framework to build their particular applications using hooks. Hooks are the places identified to show how to use and customize the framework. Hooks define Framework Interface Classes (FICs) and their possible specifications, which helps in building reusable test cases for the implementations of these classes. In applications developed using gray-box frameworks, FICs inherit framework classes or use them without inheritance. In this paper, a test-case generation technique is extended to build test cases for FICs built for gray-box frameworks. A tool is developed to automate the introduced technique.", "num_citations": "5\n", "authors": ["84"]}
{"title": "Evaluating quality of primary studies on determining object-oriented code refactoring candidates\n", "abstract": " Refactoring is a maintenance task that aims at improving the quality of a software source code by restructuring it without altering its external behavior. Identifying refactoring opportunities by manually inspecting and analyzing the source code of the system under consideration is a time consuming and costly process. Researchers, in this area, typically introduce fully or semi-automated techniques to determine or predict refactoring candidates and they report related evaluation studies. The quality of the performed studies has a great impact on the accuracy of the obtained results. In this paper, we demonstrate an application for a proposed framework that evaluates published primary studies (PSs) on refactoring prediction/identification techniques. The framework is applied on 47 selected PSs to evaluate the quality of the studies based on their design, conduct, analysis, and conclusion. We used the results to comment\u00a0\u2026", "num_citations": "4\n", "authors": ["84"]}
{"title": "State\u2010expansion\u2010based techniques for synthesizing concurrent protocol specifications in distributed systems\n", "abstract": " Several methods have been proposed for synthesizing communication protocol specifications starting from given service specifications. Because of the inherently sequential nature of a finite state machine (FSM), some FSM\u2010based protocol synthesis methods assume that primitives in the service specifications cannot be executed simultaneously. However, other synthesis methods were introduced to handle controlled primitive concurrency by imposing restrictions on the applicable FSM topologies. This paper proposes two alternative FSM\u2010based protocol synthesis methods that eliminate the restrictions on concurrency imposed by earlier methods. The first method applies a sequential\u2010based synthesis method to derive a sequential protocol specification (P\u2010SPEC) from a service specification (S\u2010SPEC) and then applies several state\u2010expansion rules to remodel the resulting P\u2010SPEC to consider the concurrency\u00a0\u2026", "num_citations": "4\n", "authors": ["84"]}
{"title": "Empirical analysis of the relation between object-oriented class lack-of-cohesion and coupling\n", "abstract": " Classes are the basic units in object-oriented programs, and their quality affects the overall quality of the software. Class cohesion and coupling are two important internal quality attributes. Class cohesion refers to the degree of relatedness of the class attributes and methods, whereas class coupling refers to the degree to which a class is related to other classes. Classes of high quality are expected to feature high cohesion and low coupling values. In this paper, using classes of three open-source Java systems, we empirically explore the relation between class cohesion and coupling. Five lack-of-cohesion metrics and eight coupling metrics are considered in the empirical study. The empirical study results show that class cohesion and coupling internal quality attributes are inversely correlated. The strength of the correlation depends highly on the cohesion and coupling measurement approaches.", "num_citations": "4\n", "authors": ["84"]}
{"title": "Adequacy of object-oriented framework system-based testing techniques\n", "abstract": " An application framework provides a reusable design and implementation for a family of software systems. If the framework contains defects, the defects will be passed on to the applications developed from the framework. Framework defects are hard to discover at the time the framework is instantiated. Therefore, it is important to remove all defects before instantiating the framework. In this paper, two measures for the adequacy of an object-oriented system-based testing technique are introduced. The measures assess the usefulness and uniqueness of the testing technique. The two measures are applied to experimentally compare the adequacy of two testing techniques introduced to test objectoriented frameworks at the system level. The two considered testing techniques are the New Framework Test Approach and Testing Frameworks Through Hooks (TFTH). The techniques are also compared analytically in terms of their coverage power of objectoriented aspects. The comparison study results show that the TFTH technique is better than the New Framework Test Approach in terms of usefulness degree, uniqueness degree, and coverage power.", "num_citations": "4\n", "authors": ["84"]}
{"title": "An Efficient Algorithm for Computing all Program Forward Static Slices\n", "abstract": " Program slicing is the task of finding all statements in a program that directly or indirectly influence the value of a variable occurrence. The set of statements that can affect the value of a variable at some point in a program is called a program backward slice. In several software engineering applications, such as program debugging and measuring program cohesion and parallelism, several slices are computed at different program points. The existing algorithms for computing program slices are introduced to compute a slice at a program point. In these algorithms, the program, or the model that represents the program, is traversed completely or partially once. To compute more than one slice, the same algorithm is applied for every point of interest in the program. Thus, the same program, or program representation, is traversed several times. In this paper, an algorithm is introduced to compute all forward static slices of a computer program by traversing the program representation graph once. Therefore, the introduced algorithm is useful for software engineering applications that require computing program slices at different points of a program. The program representation graph used in this paper is called Program Dependence Graph (PDG).", "num_citations": "4\n", "authors": ["84"]}
{"title": "Testing Java programs using dynamic data flow analysis\n", "abstract": " A large part of computer programs consists of data declarations. Thus, an increased focus on data flow testing should be considered. In this work, we consider testing the data flow in Java programs, dynamically. Data flow analysis has been applied in testing procedural and some of object-oriented programs. However, it has not been used yet to test programs that have machine independent byte-code representations, such as Java programs. We have extended the data flow analysis technique to test Java programs and show how it can be applied to detect data flow anomalies.", "num_citations": "4\n", "authors": ["84"]}
{"title": "Trajectory analysis of the coronavirus pandemic and the impact of precautionary measures in the Kingdom of Bahrain\n", "abstract": " The Kingdom of Bahrain announced its first case of COVID-19 infection on February 24, 2020. Since that time, the government has imposed several restrictions such as closures, banning gatherings, and closing border crossings to limit the spread of the pandemic and relieve pressure on the healthcare system. This article provides an overview of the current trajectory of the pandemic in the Kingdom of Bahrain. In addition, the article introduces and applies a methodology to analyze the impact of the interventions and precautionary measures enforced by the government to limit the COVID-19 disease propagation. The results show that most of the enforced precautionary measures were effective in reducing the spread of the disease by a percentage ranging from 20.2% to 41.8%. A religious occasion in Bahrain\u2014involving large gatherings\u2014had increased the spread of the disease by 28.7%. Not enough evidence is\u00a0\u2026", "num_citations": "2\n", "authors": ["84"]}
{"title": "Predicting Object-Oriented Class Fault-Proneness: A Replication Study.\n", "abstract": " Fault-proneness is a software quality attribute. It refers to the extent to which a software module is prone to faults. In object-oriented software development, the class is the basic design unit, and its quality affects the software\u2019s overall quality. Fault-proneness cannot be measured during early software development phases before the faults are detected and fixed. Several studies empirically explored the ability of statistical-based models that use other software artifacts known at early software development phases to predict fault-proneness. In this paper, we report a replication study that empirically investigated models\u2019 ability based on six well-known and commonly applied design quality measures to predict class fault-proneness using five Java open-source systems. The results indicated that in most cases, the models based on the considered quality measures were found to be statistically significant class fault-proneness predictors. In addition, considering the measures in combination allows for building prediction models with acceptable classification performance.", "num_citations": "2\n", "authors": ["84"]}
{"title": "Empirical exploration for the correlation between class object-oriented connectivity-based cohesion and coupling\n", "abstract": " Attributes and methods are the basic contents of an object-oriented class. The connectivity among these class members and the relationship between the class and other classes play an important role in determining the quality of an object-oriented system. Class cohesion evaluates the degree of relatedness of class attributes and methods, whereas class coupling refers to the degree to which a class is related to other classes. Researchers have proposed several class cohesion and class coupling measures. However, the correlation between class coupling and class cohesion measures has not been thoroughly studied. In this paper, using classes of three open-source Java systems, we empirically investigate the correlation between several measures of connectivity-based class cohesion and coupling. Four connectivity-based cohesion measures and eight coupling measures are considered in the empirical study\u00a0\u2026", "num_citations": "2\n", "authors": ["84"]}
{"title": "Integrating hook-based object-oriented framework testing techniques\n", "abstract": " Object-oriented frameworks provide reusable design, implementation, and testing for a family of software systems that share common features. They are implemented at the framework domain engineering stage and extended at the application engineering stage to build the particular required applications. Places at which the framework is extended are called hooks. These hooks are useful in testing both the framework and its applications. Several non-integrated hook-based testing techniques are introduced to test the frameworks and their applications at different engineering stages and testing levels. This paper discusses the integration of four framework-based testing techniques such that the testing redundancy is minimized and the testing reusability is maximized. The testing techniques are originally introduced to test the framework and hooks during the domain engineering stage, and to re-test the framework and test the framework interface classes during the application engineering stage. Finally, the paper illustrates the design of the tools that support the automation of the integrated techniques.", "num_citations": "2\n", "authors": ["84"]}
{"title": "An efficient algorithm for computing all program static slices\n", "abstract": " Program slicing is the task of finding all statements in a program that directly, or indirectly, influence the value of a variable occurrence. The set of statements that can affect the value of a variable at some point in a program is called a program backward slice. In several software engineering applications, such as program debugging and measuring the program cohesion and parallelism, several slices are computed at different program points. The existing algorithms for computing program slices are introduced to compute a slice at a program point. In these algorithms, the program, or the model that represents the program, is traversed completely or partially once. To compute more than one slice, the same algorithm is applied for every point of interest in the program. Thus, the same program, or program representation, is traversed several times.In this paper, an algorithm is introduced to compute all static slices of a computer program by traversing the program representation graph once. Therefore, the introduced algorithm is useful for software engineering applications that require computing program slices at different points of a program. The program representation graph used in this paper is called Program Dependence Graph (PDG).", "num_citations": "2\n", "authors": ["84"]}
{"title": "Fault-proneness prediction of object-oriented classes using reusability measures\n", "abstract": " Fault-proneness is a key external software-quality attribute of interest for software developers and practitioners. The fault-proneness of an object-oriented class indicates the extent to which the class is prone to faults. Because software engineers cannot measure fault-proneness before they release the software, they apply prediction models to estimate the fault-proneness of the software classes. These models are based on measures that require data that are extracted from design or code artifacts, and therefore, the models are applicable before the software's release date. In this paper, we report an empirical study that explores the ability of models that are based on reusability measures to predict fault-proneness. We considered three reusability measures that account for two reusability aspects: class inheritance and class instantiation. The study involves four open-source Java systems.", "num_citations": "1\n", "authors": ["84"]}
{"title": "Assessment of non-functional properties for e-services\n", "abstract": " Non-functional properties (NFPs) for an e-service consist of qualities and features that are desirable by the service users. Unlike functional properties, which are tangible functionalities provided by the e-service, NFPs are often hidden or transparent to service users. These properties are formally or semi-formally expressed to service developers by the service user and are then", "num_citations": "1\n", "authors": ["84"]}
{"title": "Flattening Java classes: methodology and applications\n", "abstract": " Inheritance and encapsulation are key concepts in object-oriented programming. Implementing these concepts is expected to enhance the code quality. Class flattening, which refers to the process of representing the class as it really is, helps in exploring the impact of inheritance on improving code quality. This paper explains how to flatten Java classes and discusses the relationship between class flattening and some applications of interest to software practitioners, such as refactoring and indicating external quality attributes.", "num_citations": "1\n", "authors": ["84"]}
{"title": "Time assignment for distributed service and protocol UML-based specifications\n", "abstract": " In real time applications, the time required to execute the events can be crucial and must be considered. However, the existing technique for synthesizing computer communication protocol specifications from UML-based service specification does not account for timing constraints and, therefore, cannot be used in real time applications. In this paper, we address the problem of time assignment to the events defined in the service specification. In addition, we show how to extend a technique that automatically synthesizes protocol specifications from a service specification to consider the timing constraints given in the service specification. Both the service and protocol specifications are modeled using a UML state machine.", "num_citations": "1\n", "authors": ["84"]}
{"title": "UPSS: a tool for synthesizing UML concurrent communication protocol entities\n", "abstract": " Unless automated, synthesizing specifications for concurrent and distributed communication protocol entities from a service specification, which is modeled in the UML state machine with composite states, is a time-consuming and labor-intensive task. In this paper, we introduce a tool, called the UML protocol specification synthesizer (UPSS), to automate an existing synthesis method that derives a protocol specification from a service specification, where both specifications are modeled in the UML state machine. The tool is developed in Java as an extension for a well known tool, Eclipse, and it supports drawing the UML state machine of the service specification. The tool stores the drawn diagram in XML format, parses the XML files, applies the synthesis rules to derive the corresponding protocol specification, stores the protocol specification in XML format, and allows for displaying and manipulating the protocol specification using the Eclipse diagram editor.", "num_citations": "1\n", "authors": ["84"]}
{"title": "A novel technique for synthesizing distributed and concurrent protocol specifications\n", "abstract": " Several methods have been proposed for synthesizing computer communication protocol specifications starting from service specifications. Some protocol synthesis methods based on the Finite State Machine (FSM) model assume that primitives in the service specifications cannot be executed simultaneously. Others either handle only controlled primitive concurrency or have tight restrictions on the applicable FSM topologies. This paper proposes a concurrent-based protocol synthesis method that eliminates the restrictions imposed by the earlier methods. The synthesis method uses a sequential-based synthesis method to derive a sequential protocol specification (P-SPEC) from a service specification (S-SPEC) and then applies several transformation rules to re-model the resulting P-SPEC to consider the concurrency behavior specified in the SSPEC.", "num_citations": "1\n", "authors": ["84"]}
{"title": "Using computing-all-slices algorithm in measuring functional cohesion\n", "abstract": " USING COMPUTING-ALL-SLICES ALGORITHM IN MEASURING FUNCTIONAL COHESION Jehad Al Dallal Department of Information Sciences Kuwait University PO Box 5969, Safat 13060, Kuwait jehad@cfw.kuniv.edu ABSTRACT Program slicing is the task of finding all statements in a program that directly, or indirectly, influence the value of a variable occurrence. The set of statements that can affect the value of a variable at some point in a program is called a program backward slice. In several software engineering applications, such as program debugging and measuring the program cohesion and parallelism, several slices are computed at different program points. Computing-All- Slices algorithm computes all static slices of a program function by traversing the program representation graph once. The program representation graph used in this paper is called Program Dependence Graph (PDG). In this paper, to \u2026", "num_citations": "1\n", "authors": ["84"]}
{"title": "Automatic construction of class state-based testing model using method specifications\n", "abstract": " AUTOMATIC CONSTRUCTION OF A CLASS STATE-BASED TESTING MODEL USING METHOD SPECIFICATIONS Jehad Al Dallal Department of Computing Science University of Alberta Edmonton, AB. T6G 2H1, Canada jehad@cs.ualberta.ca Paul Sorenson Department of Computing Science University of Alberta Edmonton, AB. T6G 2H1, Canada sorenson@cs.ualberta.ca Abstract Object-oriented software is well suited to state-based testing. A class behavior can be expressed in a state- transition model. State transition model consists of states and transitions and can be represented using State Transition Diagrams (STD) or UML statecharts. State- transition model can be easily understood and is widely used in specification-based testing techniques. Method specifications include the preconditions and postconditions of class methods. Despite the fact that method specifications determine the specifications for the -\u2026", "num_citations": "1\n", "authors": ["84"]}