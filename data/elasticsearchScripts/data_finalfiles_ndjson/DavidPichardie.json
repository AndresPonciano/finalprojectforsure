{"title": "System-level non-interference for constant-time cryptography\n", "abstract": " Cache-based attacks are a class of side-channel attacks that are particularly effective in virtualized or cloud-based environments, where they have been used to recover secret keys from cryptographic implementations. One common approach to thwart cache-based attacks is to use constant-time implementations, ie, which do not branch on secrets and do not perform memory accesses that depend on secrets. However, there is no rigorous proof that constant-time implementations are protected against concurrent cache-attacks in virtualization platforms with shared cache; moreover, many prominent implementations are not constant-time. An alternative approach is to rely on system-level mechanisms. One recent such mechanism is stealth memory, which provisions a small amount of private cache for programs to carry potentially leaking computations securely. Stealth memory induces a weak form of constant-time\u00a0\u2026", "num_citations": "119\n", "authors": ["1763"]}
{"title": "A certified lightweight non-interference java bytecode verifier\n", "abstract": " Non-interference is a semantical condition on programs that guarantees the absence of illicit information flow throughout their execution, and that can be enforced by appropriate information flow type systems. Much of previous work on type systems for non-interference has focused on calculi or high-level programming languages, and existing type systems for low-level languages typically omit objects, exceptions, and method calls, and/or do not prove formally the soundness of the type system. We define an information flow type system for a sequential JVM-like language that includes classes, objects, arrays, exceptions and method calls, and prove that it guarantees non-interference. For increased confidence, we have formalized the proof in the proof assistant Coq; an additional benefit of the formalization is that we have extracted from our proof a certified lightweight bytecode verifier for information flow\u00a0\u2026", "num_citations": "108\n", "authors": ["1763"]}
{"title": "Extracting a data flow analyser in constructive logic\n", "abstract": " A constraint-based data flow analysis is formalised in the specification language of the Coq proof assistant. This involves defining a dependent type of lattices together with a library of lattice functors for modular construction of complex abstract domains. Constraints are represented in a way that allows for both efficient constraint resolution and correctness proof of the analysis with respect to an operational semantics. The proof of existence of a solution to the constraints is constructive which means that the extraction mechanism of Coq provides a provably correct data flow analyser in Ocaml from the proof. The library of lattices and the representation of constraints are defined in an analysis-independent fashion that provides a basis for a generic framework for proving and extracting static analysers in Coq.", "num_citations": "106\n", "authors": ["1763"]}
{"title": "A verified information-flow architecture\n", "abstract": " SAFE is a clean-slate design for a highly secure computer system, with pervasive mechanisms for tracking and limiting information flows. At the lowest level, the SAFE hardware supports fine-grained programmable tags, with efficient and flexible propagation and combination of tags as instructions are executed. The operating system virtualizes these generic facilities to present an information-flow abstract machine that allows user programs to label sensitive data with rich confidentiality policies. We present a formal, machine-checked model of the key hardware and software mechanisms used to control information flow in SAFE and an end-to-end proof of noninterference for this model.", "num_citations": "102\n", "authors": ["1763"]}
{"title": "Proof-carrying code from certified abstract interpretation and fixpoint compression\n", "abstract": " Proof-carrying code (PCC) is a technique for downloading mobile code on a host machine while ensuring that the code adheres to the host's safety policy. We show how certified abstract interpretation can be used to build a PCC architecture where the code producer can produce program certificates automatically. Code consumers use proof checkers derived from certified analysers to check certificates. Proof checkers carry their own correctness proofs and accepting a new proof checker amounts to type checking the checker in Coq. Certificates take the form of strategies for reconstructing a fixpoint and are kept small due to a technique for fixpoint compression. The PCC architecture has been implemented and evaluated experimentally on a byte code language for which we have designed an interval analysis that allows to generate certificates ascertaining that no array-out-of-bounds accesses will occur.", "num_citations": "76\n", "authors": ["1763"]}
{"title": "A formally verified SSA-based middle-end\n", "abstract": " CompCert is a formally verified compiler that generates compact and efficient PowerPC, ARM and x86 code for a large and realistic subset of the C language. However, CompCert foregoes using Static Single Assignment (SSA), an intermediate representation that allows for writing simpler and faster optimizers, and is used by many compilers. In fact, it has remained an open problem to verify formally a SSA-based compiler middle-end. We report on a formally verified, SSA-based, middle-end for CompCert. Our middle-end performs conversion from CompCert intermediate form to SSA form, optimization of SSA programs, including Global Value Numbering, and transforming out of SSA to intermediate form. In addition to provide the first formally verified SSA-based middle-end, we address two problems raised by Leroy [13]: giving a simple and intuitive formal semantics to SSA, and leveraging the global\u00a0\u2026", "num_citations": "74\n", "authors": ["1763"]}
{"title": "Defining and reasoning about recursive functions: a practical tool for the Coq proof assistant\n", "abstract": " We present a practical tool for defining and proving properties of recursive functions in the Coq proof assistant. The tool generates from pseudo-code the graph of the intended function as an inductive relation. Then it proves that the relation actually represents a function, which is by construction the function that we are trying to define. Then, we generate induction and inversion principles, and a fixpoint equation for proving other properties of the function. Our tool builds upon state-of-the-art techniques for defining recursive functions, and can also be used to generate executable functions from inductive descriptions of their graph. We illustrate the benefits of our tool on two case studies.", "num_citations": "71\n", "authors": ["1763"]}
{"title": "Semantic foundations and inference of non-null annotations\n", "abstract": " This paper proposes a semantics-based automatic null pointer analysis for inferring non-null annotations of fields in object-oriented programs. The analysis is formulated for a minimalistic OO language and is expressed as a constraint-based abstract interpretation of the program which for each field of a class infers whether the field is definitely non-null or possibly null after object initialization. The analysis is proved correct with respect to an operational semantics of the minimalistic OO language. This correctness proof has been machine checked using the Coq proof assistant. We also prove the analysis complete with respect to the non-null type system proposed by F\u00e4hndrich and Leino, in the sense that for every typable program the analysis is able to prove the absence of null dereferences without any hand-written annotations. Experiments with a prototype implementation of the analysis show that the\u00a0\u2026", "num_citations": "65\n", "authors": ["1763"]}
{"title": "Interpr\u00e9tation abstraite en logique intuitionniste: extraction d'analyseurs Java certifi\u00e9s\n", "abstract": " Nous nous int\u00e9ressons dans cette th\u00e8se \u00e0 la preuve formelle de correction des analyses statiques. Nous nous basons sur la th\u00e9orie de l'interpr\u00e9tation abstraite qui pr\u00e9sente une analyse statique comme une s\u00e9mantique approch\u00e9e d'un programme. Nous utilisons l'assistant de preuve Coq qui permet d'extraire le contenu calculatoire d'une preuve constructive. L'impl\u00e9mentation Caml certifi\u00e9e d'une analyse peut ainsi \u00eatre extraite de la preuve d'existence, pour tout programme, d'une approximation correcte de la s\u00e9mantique concr\u00e8te de ce programme. Nous pr\u00e9sentons un cadre th\u00e9orique fond\u00e9 sur l'interpr\u00e9tation abstraite et permettant le d\u00e9veloppement formel d'une large gamme d'analyses statiques. Une biblioth\u00e8que Coq de construction modulaire de treillis est ensuite propos\u00e9e. Des preuves complexes de terminaison de calcul it\u00e9ratif de point fixe peuvent ainsi \u00cdtre construites par simple composition de foncteurs. Plusieurs cas d'\u00e9tudes pour l'analyse de programme en bytecode Java sont pr\u00e9sent\u00e9s.", "num_citations": "55\n", "authors": ["1763"]}
{"title": "Formalizing convex hull algorithms\n", "abstract": " We study the development of formally proved algorithms for computational geometry. The result of this work is a formal description of the basic principles that make convex hull algorithms work and two programs that implement convex hull computation and have been automatically obtained from formally verified mathematical proofs. A special attention has been given to handling degenerate cases that are often overlooked by conventional algorithm presentations.", "num_citations": "53\n", "authors": ["1763"]}
{"title": "The MOBIUS proof carrying code infrastructure\n", "abstract": " The goal of the MOBIUS project is to develop a Proof Carrying Code architecture to secure global computers that consist of Java-enabled mobile devices. In this overview, we present the consumer side of the MOBIUS Proof Carrying Code infrastructure, for which we have developed formally certified, executable checkers. We consider wholesale Proof Carrying Code scenarios, in which a trusted authority verifies the certificate before cryptographically signing the application. We also discuss retail Proof Carrying Code, where the verification is performed on the consumer device.", "num_citations": "44\n", "authors": ["1763"]}
{"title": "A certified denotational abstract interpreter\n", "abstract": " Abstract Interpretation proposes advanced techniques for static analysis of programs that raise specific challenges for machine-checked soundness proofs. Most classical dataflow analysis techniques iterate operators on lattices without infinite ascending chains. In contrast, abstract interpreters are looking for fixpoints in infinite lattices where widening and narrowing are used for accelerating the convergence. Smart iteration strategies are crucial when using such accelerating operators because they directly impact the precision of the analysis diagnostic. In this paper, we show how we manage to program and prove correct in Coq an abstract interpreter that uses iteration strategies based on program syntax. A key component of the formalization is the introduction of an intermediate semantics based on a generic least-fixpoint operator on complete lattices and allows us to decompose the soundness proof in\u00a0\u2026", "num_citations": "42\n", "authors": ["1763"]}
{"title": "Sawja: Static analysis workshop for java\n", "abstract": " Static analysis is a powerful technique for automatic verification of programs but raises major engineering challenges when developing a full-fledged analyzer for a realistic language such as Java. Efficiency and precision of such a tool rely partly on low level components which only depend on the syntactic structure of the language and therefore should not be redesigned for each implementation of a new static analysis. This paper describes the Sawja library: a static analysis workshop fully compliant with Java 6 which provides OCaml modules for efficiently manipulating Java bytecode programs. We present the main features of the library, including i) efficient functional data-structures for representing a program with implicit sharing and lazy parsing, ii) an intermediate stack-less representation, and iii) fast computation and manipulation of complete programs. We provide experimental evaluations of the\u00a0\u2026", "num_citations": "41\n", "authors": ["1763"]}
{"title": "Certified result checking for polyhedral analysis of bytecode programs\n", "abstract": " Static analysers are becoming so complex that it is crucial to ascertain the soundness of their results in a provable way. In this paper we develop a certified checker in Coq that is able to certify the results of a polyhedral array-bound analysis for an imperative, stack-oriented bytecode language with procedures, arrays and global variables. The checker uses, in addition to the analysis result, certificates which at the same time improve efficiency and make correctness proofs much easier. In particular, our result certifier avoids complex polyhedral computations such as convex hulls and is using easily checkable inclusion certificates based on Farkas lemma. Benchmarks demonstrate that our approach is effective and produces certificates that can be efficiently checked not only by an extracted Caml checker but also directly in Coq.", "num_citations": "33\n", "authors": ["1763"]}
{"title": "A certified lightweight non-interference java bytecode verifier\n", "abstract": " Non-interference guarantees the absence of illicit information flow throughout program execution. It can be enforced by appropriate information flow type systems. Much of the previous work on type systems for non-interference has focused on calculi or high-level programming languages, and existing type systems for low-level languages typically omit objects, exceptions and method calls. We define an information flow type system for a sequential JVM-like language that includes all these programming features, and we prove, in the Coq proof assistant, that it guarantees non-interference. An additional benefit of the formalisation is that we have extracted from our proof a certified lightweight bytecode verifier for information flow. Our work provides, to the best of our knowledge, the first sound and certified information flow type system for such an expressive fragment of the JVM.", "num_citations": "32\n", "authors": ["1763"]}
{"title": "Modular SMT proofs for fast reflexive checking inside Coq\n", "abstract": " We present a new methodology for exchanging unsatisfiability proofs between an untrusted SMT solver and a sceptical proof assistant with computation capabilities like Coq. We advocate modular SMT proofs that separate boolean reasoning and theory reasoning; and structure the communication between theories using Nelson-Oppen combination scheme. We present the design and implementation of a Coq reflexive verifier that is modular and allows for fine-tuned theory-specific verifiers. The current verifier is able to verify proofs for quantifier-free formulae mixing linear arithmetic and uninterpreted functions. Our proof generation scheme benefits from the efficiency of state-of-the-art SMT solvers while being independent from a specific SMT solver proof format. Our only requirement for the SMT solver is the ability to extract unsat cores and generate boolean models. In practice, unsat cores are relatively\u00a0\u2026", "num_citations": "32\n", "authors": ["1763"]}
{"title": "A provably correct stackless intermediate representation for Java bytecode\n", "abstract": " The Java virtual machine executes stack-based bytecode. The intensive use of an operand stack has been identified as a major obstacle for static analysis and it is now common for static analysis tools to manipulate a stackless intermediate representation (IR) of bytecode programs. This paper provides such a bytecode transformation, describes its semantic correctness and evaluates its performance. We provide the semantic foundations for proving that an initial program and its IR behave similarly, in particular with respect to object creation and throwing of exceptions. The correctness of this transformation is proved with respect to a relation on execution traces taking into account that the object allocation order is not preserved by the transformation.", "num_citations": "27\n", "authors": ["1763"]}
{"title": "Certified static analysis by abstract interpretation\n", "abstract": " A certified static analysis is an analysis whose semantic validity has been formally proved correct with a proof assistant. We propose a tutorial on building a certified static analysis in Coq. We study a simple bytecode language for which we propose an interval analysis that allows to verify statically that no array-out-of-bounds accesses will occur.", "num_citations": "27\n", "authors": ["1763"]}
{"title": "Building certified static analysers by modular construction of well-founded lattices\n", "abstract": " This paper presents fixpoint calculations on lattice structures as example of highly modular programming in a dependently typed functional language. We propose a library of Coq module functors for constructing complex lattices using efficient data structures. The lattice signature contains a well-foundedness proof obligation which ensures termination of generic fixpoint iteration algorithms. With this library, complex well-foundedness proofs can hence be constructed in a functorial fashion. This paper demonstrates the ability of the recent Coq module system in manipulating algebraic structures and extracting efficient Ocaml implementations from them. The second contribution of this work is a generic result, based on the constructive notion of accessibility predicate, about preservation of accessibility properties when combining relations.", "num_citations": "23\n", "authors": ["1763"]}
{"title": "Result certification for relational program analysis\n", "abstract": " We define a generic relational program analysis for an imperative, stack-oriented byte code language with procedures, arrays and global variables and instantiate it with an abstract domain of polyhedra. The analysis has automatic inference of loop invariants and method pre-/post-conditions, and efficient checking of analysis results by a simple checker. Invariants, which can be large, can be specialized for proving a safety policy using an automatic pruning technique which reduces their size. The result of the analysis can be checked efficiently by annotating the program with parts of the invariant together with certificates of polyhedral inclusions, which allow to avoid certain complex polyhedral computation such as the convex hull of two polyhedra. Small, easily checkable inclusion certificates are obtained using Farkas lemma for proving the absence of solutions to systems of linear inequalities. The resulting checker is sufficiently simple to be entirely certified within the Coq proof assistant.", "num_citations": "22\n", "authors": ["1763"]}
{"title": "Enforcing secure object initialization in Java\n", "abstract": " Sun and the CERT recommend for secure Java development to not allow partially initialized objects to be accessed. The CERT considers the severity of the risks taken by not following this recommendation as high. The solution currently used to enforce object initialization is to implement a coding pattern proposed by Sun, which is not formally checked. We propose a modular type system to formally specify the initialization policy of libraries or programs and a type checker to statically check at load time that all loaded classes respect the policy. This allows to prove the absence of bugs which have allowed some famous privilege escalations in Java. Our experimental results show that our safe default policy allows to prove 91% of classes of java.lang, java.security and javax.security safe without any annotation and by adding 57 simple annotations we proved all classes but four safe. The type system and its\u00a0\u2026", "num_citations": "17\n", "authors": ["1763"]}
{"title": "Secure the Clones\n", "abstract": " Exchanging mutable data objects with untrusted code is a delicate matter because of the risk of creating a data space that is accessible by an attacker. Consequently, secure programming guidelines for Java stress the importance of using defensive copying before accepting or handing out references to an internal mutable object. However, implementation of a copy method (like clone()) is entirely left to the programmer. It may not provide a sufficiently deep copy of an object and is subject to overriding by a malicious sub-class. Currently no language-based mechanism supports secure object cloning. This paper proposes a type-based annotation system for defining modular copy policies for class-based object-oriented programs. A copy policy specifies the maximally allowed sharing between an object and its clone. We present a static enforcement mechanism that will guarantee that all classes fulfill their copy\u00a0\u2026", "num_citations": "15\n", "authors": ["1763"]}
{"title": "A certified data race analysis for a Java-like language\n", "abstract": " A fundamental issue in multithreaded programming is detecting data races. A program is said to be well synchronised if it does not contain data races w.r.t. an interleaving semantics. Formally ensuring this property is central, because the java Memory Model then guarantees that one can safely reason on the interleaved semantics of the program. In this work we formalise in the coq proof assistant a java bytecode data race analyser based on the conditional must-not alias analysis of Naik and Aiken. The formalisation includes a context-sensitive points-to analysis and an instrumented semantics that counts method calls and loop iterations. Our java-like language handles objects, virtual method calls, thread spawning and lock and unlock operations for threads synchronisation.", "num_citations": "14\n", "authors": ["1763"]}
{"title": "Verifying fast and sparse SSA-based optimizations in Coq\n", "abstract": " The Static Single Assignment (SSA) form is a predominant technology in modern compilers, enabling powerful and fast program optimizations. Despite its great success in the implementation of production compilers, it is only very recently that this technique has been introduced in verified compilers. As of today, few evidence exist on that, in this context, it also allows faster and simpler optimizations. This work builds on the CompCertSSA verified compiler (an SSA branch of the verified CompCert C compiler). We implement and verify two prevailing SSA optimizations: Sparse Conditional Constant Propagation and Global Value Numbering. For both transformations, we mechanically prove their soundness in the Coq proof assistant. Both optimization proofs are embedded in a single sparse optimization framework, factoring out many of the dominance-based reasoning steps required in proofs of SSA-based\u00a0\u2026", "num_citations": "13\n", "authors": ["1763"]}
{"title": "Preservation of proof pbligations for hybrid verification methods\n", "abstract": " Program verification environments increasingly rely on hybrid methods that combine static analyses and verification condition generation. While such verification environments operate on source programs, it is often preferable to achieve guarantees about executable code. We show that, for a hybrid verification method based on numerical static analysis and verification condition generation, compilation preserves proof obligations and therefore it is possible to transfer evidence from source to compiled programs. Our result relies on the preservation of the solutions of analysis by compilation; this is achieved by relying on a byte code analysis that performs symbolic execution of stack expressions in order to overcome the loss of precision incurred by performing static analyses on compiled (rather than source) code. Finally, we show that hybrid verification methods are sound by proving that every program provable by\u00a0\u2026", "num_citations": "11\n", "authors": ["1763"]}
{"title": "A PCC architecture based on certified abstract interpretation\n", "abstract": " Proof-Carrying Code (PCC) is a technique for downloading mobile code on a host machine while ensuring that the code adheres to the host's security policy. We show how certified abstract interpretation can be used to build a PCC architecture where the code producer can produce program certificates automatically. Code consumers use proof checkers derived from certified analysers to check certificates. Proof checkers carry their own correctness proofs and accepting a new proof checker amounts to type checking the checker in Coq. Fixpoint compression techniques are used to obtain compact certificates. The PCC architecture has been evaluated experimentally on a byte code language for which we have designed an interval analysis that allows to generate certificates ascertaining that no array-out-of-bounds accesses will occur.", "num_citations": "10\n", "authors": ["1763"]}
{"title": "A java card cap converter in pvs\n", "abstract": " The Java Card language is a trimmed down dialect of Java aimed at programming smart cards. Java Card specifies its own class file format (the Java Card Converted APplet (CAP) format) that is optimised with respect to the limited space resources of smart cards. This paper deals with the certified development of algorithms necessary for the conversion of ordinary Java class files into the CAP format. More precisely, these algorithms are concerned with constructing and compressing method tables and constant pools. The main contribution of this paper is to specify and prove the correctness of these algorithms using the theorem prover PVS.", "num_citations": "9\n", "authors": ["1763"]}
{"title": "Semantic reasoning about the sea of nodes\n", "abstract": " The Sea of Nodes intermediate representation was introduced by Cliff Click in the mid 90s as an enhanced Static Single Assignment (SSA) form. It improves on the initial SSA form by relaxing the total order on instructions in basic blocks into explicit data and control dependencies. This makes programs more flexible to optimize. This graph-based representation is now used in many industrial-strength compilers, such as HotSpot or Graal. While the SSA form is now well understood from a semantic perspective--even formally verified optimizing compilers use it in their middle-end--very few semantic studies have been conducted about the Sea of Nodes.", "num_citations": "8\n", "authors": ["1763"]}
{"title": "Embedding of systems of affine recurrence equations in Coq\n", "abstract": " Systems of affine recurrence equations (SAREs) over polyhedral domains are widely used to model computation-intensive algorithms and to derive parallel code or hardware implementations. The development of complex SAREs for real-sized applications calls for the elaboration of formal verification techniques. As the systems we consider are generic, i.e., depend on parameters whose value are not statically known, we considered using theorem provers, and have implemented a translation from SAREs into the Coq system. We take advantage of the regularity of our model to automatically generate an inductive type adapted to each particular system. This allows us to automatically prove that the functional translation of equations respects the wanted fixpoint properties, and to systematically derive mutual induction schemes.", "num_citations": "7\n", "authors": ["1763"]}
{"title": "Programmation d'un interpr\u00e9teur abstrait certifi\u00e9 en logique constructive\n", "abstract": " Un analyseur statique permet de d\u00e9duire automatiquement des propri\u00e9t\u00e9s d\u2019un programme \u00e0 partir de son code. La preuve de correction d\u2019un analyseur repose sur des propri\u00e9t\u00e9s s\u00e9mantiques, et devient difficile \u00e0 assurer lorsque l\u2019analyse met en \u0153uvre des techniques symboliques complexes. Nous proposons une adaptation de la th\u00e9orie g\u00e9n\u00e9rale de l\u2019analyse statique par interpr\u00e9tation abstraite au cadre de la logique constructive. L\u2019impl\u00e9mentation de ce formalisme dans l\u2019assistant de preuve Coq permet alors d\u2019extraire automatiquement des analyseurs certifi\u00e9s. Nous nous int\u00e9ressons plus particuli\u00e8rement \u00e0 un langage imp\u00e9ratif simple, et pr\u00e9sentons en d\u00e9tail le calcul de point fixe par \u00e9largissement/r\u00e9tr\u00e9cissement et it\u00e9ration dirig\u00e9e par la syntaxe.ABSTRACT. A static analyzer aims at automatically deducing program properties by examining its source code. Proving the correctness of an analyzer is based on semantic properties, and becomes difficult to ensure when complex analysis techniques are involved. We propose to adapt the general theory of static analysis by abstract interpretation to the framework of constructive logic. Implementing this formalism into the Coq proof assistant then allows for automatic extraction of certified analyzers. We focus here on a simple imperative language and present the computation of fixpoints by widening/narrowing and syntax-directed iteration techniques.", "num_citations": "4\n", "authors": ["1763"]}
{"title": "Soundly handling static fields: Issues, semantics and analysis\n", "abstract": " Although in most cases class initialization works as expected, some static fields may be read before being initialized, despite being initialized in their corresponding class initializer. We propose an analysis which compute, for each program point, the set of static fields that must have been initialized and discuss its soundness. We show that such an analysis can be directly applied to identify the static fields that may be read before being initialized and to improve the precision while preserving the soundness of a null-pointer analysis.", "num_citations": "4\n", "authors": ["1763"]}
{"title": "Comparing techniques for certified static analysis\n", "abstract": " A certified static analysis is an analysis whose semantic validity has been formally proved correct with a proof assistant. The recent increasing interest in using proof assistants for mechanizing programming language metatheory has given rise to several approaches for certification of static analysis. We propose a panorama of these techniques and compare their respective strengths and weaknesses.", "num_citations": "4\n", "authors": ["1763"]}
{"title": "Representations\n", "abstract": " \u00abInt\u00e9r\u00eats d'\u00eatre b\u00e9n\u00e9vole... et lien social\u00bb ans une pr\u00e9c\u00e9dente \u00e9tude, nous avions montr\u00e9 comment du devoir, voire de la mission sous couvert d'altruisme, l'engagement b\u00e9n\u00e9vole est pass\u00e9 \u00e0 une forme privil\u00e9gi\u00e9e de la r\u00e9alisation de soi avec l'av\u00e8nement d'un \u00abindividu relationnel\u00bb, o\u00f9 les notions de plaisir et d'acquisition de comp\u00e9tences deviennent plus importantes.\u00abSe conna\u00eetre\u00bb,\u00abSe produire\u00bb,\u00abSe r\u00e9aliser\u00bb, tels sont les termes qui revenaient souvent dans les \u00abr\u00e9cits\u00bb de b\u00e9n\u00e9voles. A la fin de cette \u00e9tude, nous soulignions la difficult\u00e9 de cerner plus pr\u00e9cis\u00e9ment ce qui liait les b\u00e9n\u00e9voles au collectif et le besoin d'affiliation \u00e0 un r\u00e9seau, dans ce que nous pourrions appeler une reliance. Ce premier rapport est consultable sur le site du CNRS:", "num_citations": "4\n", "authors": ["1763"]}
{"title": "Adaptable static analysis of executables for proving the absence of vulnerabilities\n", "abstract": " In a world where vulnerabilities in software pose an inherent threat for the networked society, analyzing third-party software, in form of executable programs, becomes increasingly important. While program verification at the source code level has received much attention in the last decades, this thesis focuses on providing a sound and precise analysis framework for binaries, thereby enabling the understanding, auditing, and verification of executable programs.", "num_citations": "3\n", "authors": ["1763"]}
{"title": "Verifying resource access control on mobile interactive devices\n", "abstract": " A model of resource access control is presented in which the access control to resources can employ user interaction to obtain the necessary permissions. This model is inspired by and improves on the Java security architecture used in Java-enabled mobile telephones. We extend the Java model to include access control permissions with multiplicities in order to allow to use a permission a certain number of times. We define a program model based on control flow graphs together with its operational semantics and provide a formal definition of the basic security policy to enforce viz that an application will always ask for a permission before using it to access a resource. A static analysis which enforces the security policy is defined and proved correct. A constraint solving algorithm implementing the analysis is presented.", "num_citations": "3\n", "authors": ["1763"]}
{"title": "Modular proof principles for parameterised concretizations\n", "abstract": " Abstract interpretation is a particularly well-suited methodology to build modular correctness proof of static analysers. Proof modularity becomes essential when correctness proof is machine checked for realistic languages To deal with complex concrete and abstract domains, the notion of parameterised concretization has been proposed to allow a structural decomposition of the abstract domain and its concretization. In this paper we develop proof principles for such concretizations, based on the theoretical notion of concretization functor, with the aim of obtaining modular correctness proofs. Our technique has been tested on a machine-checked correctness proof of a static analysis for a Java-like bytecode language.", "num_citations": "3\n", "authors": ["1763"]}
{"title": "A nelson-oppen based proof system using theory specific proof systems\n", "abstract": " SMT solvers are nowadays pervasive in verification tools. When the verification is about a critical system, the result of the SMT solver is also critical and cannot be trusted. The SMT-LIB 2.0 is a standard interface for SMT solvers but does not specify the output of the get-proof command. We present a proof system that is geared towards SMT solvers and follows their conceptually modular architecture. Our proof system makes a clear distinction between propositional and theory reasoning. Moreover, individual theories provide specific proof systems that are combined using the Nelson-Oppen proof scheme. We propose specific proof systems for linear real arithmetic (LRA) and uninterpreted functions (EUF) and discuss proof generation and proof checking. We have evaluated the cost of generating proofs in our proof system. Our experiments on benchmarks taken from the SMT-LIB library show that the simple mechanisms used in our approach suffice for a large majority of the selected benchmarks.", "num_citations": "2\n", "authors": ["1763"]}
{"title": "Defining and reasoning about general recursive functions in type theory: a practical method\n", "abstract": " \u00a2\u00a1\u00a4\u00a3\u00a6\u00a5 \u00a7 \u00a9\u00a5\u00a5\u00a1!#\"!\u00a5 \u00a7 \u00a9\u00a5% $'& (\") 103 24\u00a1\u00a5\u00a1\u00a4 56! 78'\u00a1 9@) 56A \u00a7 CB!\u00a1 ED)\u00a5 9F0G \u00a7 \u00a9\"!\u00a5 H \u00a7 \u00a9\u00a5 IQPSR\u00a1 IUT\u00a1\" V5PXWYa56! 9b0# \u00a7 \u00a9 9c! 7e df\u00a1 c0T\" g h\u00a6 iqpArtsv u! rxw yi s6rt i 6s is 1 6 ed f\u00a9 g\u00a9 hjilk f! fCd inm6oqprqtsvuwk fy x ed fCg\u00a9 hjilk fz oqiXinu|{| qtz}{vg\u00a9 f o Ckjg\u00a9 f! b}{w| k}{wkg\u00a9 kzf u| m| prqtz} gCqtoq {e qr {eg\u00a9 k {wk1 {F qx \u00f5 kji mGk S x\u00a6} kf (@~| k| oof\u00a9 kl}|} qzjgCqtz} p ilkjgC wo\u00a1\u00a2 o| k\u00a3 w {| qr {|\u00a4}{w| \u00f5 qr {|| ok gCqtk fn o\u00a5 kj {wk} p \u00a7 \u00a6 tq\u00a9 \u00aak r \u00ab{woqgV {wk zkf\u00a9 f\u00ac} qrprd fCg uwzjgCu} px\u00ae k zju f\u00a9 qr kS tu|{wzjgCqtoq {wf! qr {| oeo} qf\u00a9 fCqtfCg\u00ac}{eg\u00a9 fV mA} qf\u00a9 k oq {gd kS gC wk od\u00b1wkS qt| k} qtf g\u00a9 o\u00a6| k\u00a3 w {wk gC wk} 8 o b gC wk \u00a7 qr {vg\u00a9 kj {w| k tu|{wzjgCqtoq {8} qfV}{(qr {w \u00b2uwzjgCqr k kjp\u00b3} gCqtoq {F \u00abw}{w g\u00a9 o| \u00f5 kS gC A} g\u00b1gC wk kjp\u00b3} gCqtoq {} qzjgCuA} prprd k| kf\u00a9 kj {vg\u00a9 fn} \u00b5 u|{wzjgCqtoq {F \u00ab\u00b6 V| qtz\u00a9 qtf \u00a7 med\u00a4 z oq {wf\u00a9 g uwzjgCqtoq {gC wk tu|{wzjgCqtoq {gC A} gg\u00b6\u00a5 k\u00a6} k\u00a6 gd qr {| g\u00a9 o| k\u00a3 w {wk\u00b1wkj {F \u00ab|\u00b6\u00a5 kg kj {wk} g\u00a9 k1 qr {w \u00b2uwzjgCqtoq {| qr {wzjq ptk fV\u00a2 o V| \u00f5 qr {|(oqgC wk} m| qrg} d| ok gCqtk fo\u00a4 gC wk tu|{wzjgCqtoq {F\u00b1wk}|| o} qz\u00ac \u00b5 A} qf m6k kj {lk\u00b7 k qrilkj {eg\u00a9 kl qr {l gC wk\u00a5 os| oo F} qf\u00a9 fCqtfCg\u00ac}{eg \u00abm| u| g\u00b9 fC woqu| pt X\u00b6\u00a5 o C\u00ba qr {X prq\u00bak\u00bb\u00a9 iXqr {w| k| oo!} qf\u00a9 qtfCg\u00ac}{vg\u00a9 f} qf1\u00b6 \u00bckjprp\u00a9 \u00bd\u00beg} prpt\u00f5\u00b6! fn\u00a2 o tu|{wzjgCqtoq {wf\u00b6 VqrgC Q iu| gCuA} pk zju fCqr k (z} prptf \u00ab@{wk fCg\u00a9 kk zju fCqr k (z} prptf \u00ab}{w X\u00b6\u00a5 o C\u00baf\u00b1} ptf\u00a9 oS\u00a2 o gC wk fCg\u00ac}{ww} \u00b5 kj {wz oe \u00b2qr {| o} gCq\u00b3} pA tu|{wzjgCqtoq {wf\u00b9 uwfCqr {| 1 g\u00a9 oqg\u00ac} pA tu|{wzjgCqtoq {wf\u00bc \u00f5 k} 1| k kj {w| kj {eg gd kS gC A} gk fCg qtzjg\u00a9 f! gC wkn o qr qr {A} p tu|{wzjgCqtoq {F\u00bf \u00aaf \u00a7 | oqi\u00b5} qr {F k| kf\u00a9 kj {eg1 fCqri ptkX k\u00b7 w} i ptk fn}{wko g1 oq {}(p\u00b3} kz} qf\u00a9 k\u00a6 fCgCuw \u00b2dU\u00a0\u2026", "num_citations": "2\n", "authors": ["1763"]}
{"title": "Verified functional programming of an abstract interpreter\n", "abstract": " Abstract interpreters are complex pieces of software: even if the abstract interpretation theory and companion algorithms are well understood, their implementations are subject to bugs, that might question the soundness of their computations.               While some formally verified abstract interpreters have been written in the past, writing and understanding them requires expertise in the use of proof assistants, and requires a non-trivial amount of interactive proofs. This paper presents a formally verified abstract interpreter fully programmed and proved correct in the F* verified programming environment. Thanks to F* refinement types and SMT prover capabilities we demonstrate a substantial saving in proof effort compared to previous works based on interactive proof assistants. Almost all the code of our implementation, proofs included, written in a functional style, are presented directly in the paper.", "num_citations": "1\n", "authors": ["1763"]}
{"title": "Verified compilation of linearizable data structures: mechanizing rely guarantee for semantic refinement\n", "abstract": " Compiling concurrent and managed languages involves implementing sophisticated interactions between client code and the runtime system. An emblematic runtime service, whose implementation is particularly error-prone, is concurrent garbage collection. In a recent work [31], we implement an on-the-fly concurrent garbage collector, and formally prove its functional correctness in the Coq proof assistant. The garbage collector is implemented in a compiler intermediate representation featuring abstract concurrent data structures.", "num_citations": "1\n", "authors": ["1763"]}
{"title": "Kharon: D\u00e9couvrir, comprendre et reconna\u00eetre des malware Android par suivi de flux d'information\n", "abstract": " L'av\u00e8nement des t\u00e9l\u00e9phones et tablettes ces derni\u00e8res ann\u00e9es a favoris\u00e9 le d\u00e9-veloppement d'un nouveau mod\u00e8le \u00e9conomique qui repose sur la livraison d'un t\u00e9l\u00e9phone nu sur lequel l'utilisateur peut installer des applications via des maga-sins d'applications ou march\u00e9s. Ces march\u00e9s sont aussi bien officiels car approu-v\u00e9s par les entreprises d\u00e9veloppant les syst\u00e8mes d'exploitations de ces t\u00e9l\u00e9phones comme Google Play ou AppStore ou non officiels. Dans ce qui suit, nous nous consacrons aux t\u00e9l\u00e9phones et tablettes utilisant le syst\u00e8me d'exploitation Android sur lesquelles un utilisateur peut installer des applications via Google Play. Sur ce march\u00e9, nous trouvons beaucoup d'applications (plus de un million d'applica-tions) t\u00e9l\u00e9charg\u00e9es par beaucoup d'utilisateurs. Une m\u00eame application peut \u00eatre t\u00e9l\u00e9charg\u00e9e plus de 100 millions de fois. Les d\u00e9veloppeurs de ces applications sont d'origines tr\u00e8s vari\u00e9es puisque pour la modique somme de 25 USD n'importe qui peut cr\u00e9er un compte d\u00e9veloppeur pour ce march\u00e9 et distribuer sa propre application. Il est aussi possible d'installer des applications sans passer par Google Play. Android est ainsi devenu rapidement une cible de choix pour les d\u00e9veloppeurs mal-veillants et le nombre de malware n'a cess\u00e9 d'augmenter pour atteindre 10 millions d'applications malveillantes en 2012-2013 selon Kaspersky [1]. Ces malware essaient principalement de soutirer de l'argent \u00e0 un utilisateur. Par exemple, le malware Simplelocker [2] chiffre sur le t\u00e9l\u00e9phone les donn\u00e9es de l'utilisateur comme ses photos, ses documents les rendant ainsi inutilisables et de-mande ensuite une ran\u00e7on pour d\u00e9chiffrer ces\u00a0\u2026", "num_citations": "1\n", "authors": ["1763"]}
{"title": "Programming languages and systems\n", "abstract": " This volume contains the papers presented at ESOP 2011, the 20th European Symposium on Programming held March 30-April 1, 2011, in Saarbr\u00fccken, Germany.ESOP is an annual conference devoted to fundamental issues in the specification, design, analysis, and implementation of programming languages and systems. ESOP 2011 was the 20th edition in the series. The Programme Committee (PC) invited papers on all aspects of programming language research including: programming paradigms and styles, methods and tools to write and specify programs and languages, methods and tools for reasoning about programs, methods and tools for implementation, and concurrency and distribution. Following previous editions, we maintained the page limit to 20 pages, and a rebuttal process of 72 hours during which the authors could respond to the reviews of their submission. This year, PC submissions were not\u00a0\u2026", "num_citations": "1\n", "authors": ["1763"]}
{"title": "Constructive construction of lattices for wellfounded fixpoint iteration\n", "abstract": " \u82d1\u7b25\u6e6f\u76c3% p \u54c1 2  \u540f\u84ee dhu \u63f4   e \u30e6 fg  p9 \u30e4 yx \uff66 \u30c6  psu \u636e  5 \u4e99 hk jl \u540f  m \u6e21 OP5 hp m \u8ced S  hp9\u2252 ut s# y  ui9isucf p9 \u30e4 yxbvRwx \u51c9! z@ \u6b04 {Vci| i} cg 4\u2234 y \u5204 k \u0435  z \u8a0a cisug  pt \u88f8  \u96db\u51b2 vugs# y  u    zbu \u708a  \u814e  \u30c6 {E \u9662\u5d16 zby \u5204 e  pt fc \u6b04\u2267 f%\u32a7\u2267  p9 \u30e4 yx@ i  yxl \u2018\u6b04 pqp9 \u30c6 fgu  iqp \u7761@ f /nobr> p9\u2252 ucicw $ \u6643 \u2018\u30e4 x \u96db\u8eab vy \u5b95 $ \u8a8c yh  v tvyhdh\u32a7\u2018u   @ \u84ee f p9y \u9032  \u30e6 i# z \u7b25\u51db byJsucdv    fgy \u528d@ iqp \u7761@ f% ps \u30c6 {F fgy \u51b2 vz  eu% \u754c \u2018\u6b04 pqp9 \u30c6 fguci# \u2460is \u30e4 {ug \u71e5 f% \u30c6 ug  p  d  4p \u98a8  iqp \u7761@ f% ps\u2252 ucicw  \u6575\u9f3b u \u2018\u6b04 pqps \u30e6 f% u  is \u30e4 {x@  p9\u2252 u fgy \u528d wp9 \u540f\u30e4\u84ee iv \u5d50 s# ug \u2018@ \u8888   \u5227  dhucdh \u84ee uci9iv z \u7b25 Ry \u520e  y \u51c5  e \u30c6 {w4 /nobr> p9 \u30e4 yx  s2 \u9f3b\u30c6 f \u5c01  ug \u84ee is\u2252 uci  psu \u814e v \u30c6\u84ee  p9 \u30e4 yx  y \u520e {\u51b0 c  u \u5e25  f! \u6cbf\u64b9 zby \u5204 e  p1 \u30e4 psu \u96db\u83df s \u30c6 y \u528d  \u6b04 \u2018{\u51c9\u5e25 \u0430s \u8b5c tEicw \u0441\u0430s \u8461 ps \u8b5c\u30e6 i1 \u2018\u30e4 x \u96db\u8eab\u5271 fgy \u51b2 vz  eu% \u6822 s# ug \u2018> \u62f3   g @ dhu \u67a6 h  uci9iv z \u7b25 Ry \u5b95\u6b83  fc \u6b04  \u8b5c ug \u84ee fgu  xu  f% y \u528d i \u5ec3\u7761@ f% psu \u67a6  \u30c6\u4e10 \u5d50   @ f p9y \u5e25 e \u540f;  \u6cd3\u5193 s \u8b5c\u30c6 y \u528d\uff68 w. \u6575\u9f3b\u30c6 i z \u6b04 zbu  f% y \u528d wp \u98a8\u5854 e \u84ee i5 p \u6557# y  dh \u30e6 i \u5ec3 9 \u30e4  f pE f% y \u528d wp \u5e25 ex  hp9 \u30e4 yx@ igw \u0435 \uff66 \u8276 i \u5ec3 v dhugtvyx@ i \u5ec3\u96db\u83df suE p9 \u8b5c uP \u6b04 x  e> \u30e4 p \u6ce2 [y \u5b95 2 p9 \u8b5c u \u8a0a cfgug \u9df2 /nobr> p  \u8a8c yh   t  yhdh\u2460> ui isghi \u5ec3 9ugt] \u30e4\u4e2a tE \u6b04  \u30c6 z     p9 \u30e4\u84ee {l \u6b04 \u2018{\u51b0 gx \u96db\u5204 efv iqp \u7761@ f p9\u2252 u \u67b4 5 \u6b04\u84ee d  ug \u5b66 p \u96db G p9 \u30e4 {P ug \u85a6 fg \u30e4 uc  pv, tfg \u540f t  /nobr> \u30c6 tvz  eugtvug  p9 \u6b04 ps \u30c6 y \u528d P  \u7b25\u51b2\uff65 ps \u9f3b ugtPw  \u6575\u8b5c uF iqu \u6785% y \u528d d  f% y \u528d wp \u5e25 ex  hp9 \u30e4 yx  \u30c6 it \u52c7 {\u51b0 c  u \u5e25  f \u8a0a\u67b4 q\u2460@ p \u6926 x@ \u7fcc iqu \u67a6 P y \u528d  p9 \u8b5c uF fgy \u528d h /nobr> iqp \u7761@ f% ps \u30c6\uff66\u51b0 \u84ee y \u83df s \u30c6 y \u528d, y\u00a0\u2026", "num_citations": "1\n", "authors": ["1763"]}
{"title": "A PCC Architecture based on Certified Abstract Interpretation\n", "abstract": " Proof Carrying Code (PCC) is a technique for downloading mobile code on a host machine while ensuring that the code adheres to the host's security policy. We show how certified abstract interpretation can be used to build a PCC architecture where the code producer can produce program certificates automatically. Code consumers use proof checkers derived from certified analysers to check certificates. Proof checkers carry their own correctness proofs and accepting a new proof checker amounts to type checking the checker in Coq. The checking of certificates is accelerated by a technique for (post-)fixpoint compression. The PCC architecture has been evaluated experimentally on a byte code language for which we have designed an interval analysis that allows to generate certificates ascertaining that no array-out-of-bounds accesses will occur.", "num_citations": "1\n", "authors": ["1763"]}
{"title": "An idealized model of virtualization with stealth memory: complete action semantics and non-interference\n", "abstract": " We present the complete formal semantics of an idealized model of virtualization which incorporates management of stealth memory (StealthCert). The paper provides a detailed account of the basic components of the idealized model focusing on the memory model and the notion of state that has been formalized as well as a formal axiomatic and executable semantics of an idealized hypervisor. An isolation theorem for StealthCert is discussed and a sketch of its proof, which has been developed using Coq, presented.", "num_citations": "1\n", "authors": ["1763"]}