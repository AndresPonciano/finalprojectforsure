{"title": "Is duplicate code more frequently modified than non-duplicate code in software evolution? An empirical study on open source software\n", "abstract": " Various kinds of research efforts have been performed on the basis that the presence of duplicate code has a negative impact on software evolution. A typical example is that, if we modify a code fragment that has been duplicated to other code fragments, it is necessary to consider whether the other code fragments have to be modified simultaneously or not. In this research, in order to investigate how much the presence of duplicate code is related to software evolution, we defined a new indicator, modification frequency. The indicator is a quantitative measure, and it allows us to objectively compare the maintainability of duplicate code and non-duplicate code. We conducted an experiment on 15 open source software systems, and the result showed that the presence of duplicate code does not have a negative impact on software evolution.", "num_citations": "120\n", "authors": ["804"]}
{"title": "Efficient Code Clone Management based on Historical Analysis and Refactoring Support\n", "abstract": " Code clones have recieved great interests in recent years from many researchers, engineers, and practitioners in the field of software engineering. A code clone is defined as a group of code fragments that are identical or similar to one another. Code clones are introduced into source code of software systems by various reasons, and the most typical one is code cloning by copy-and-paste operations for reusing existing features. Typical software systems contain a certain amount of code clones because code cloning is a common practice for software developers. The existence of code clones has been regarded as a bad smell for software evolution over a period of time because code clones require much attention to be maintained. Once code clones are introduced into source code, most of them should be consistently maintained. Unintended inconsistencies among code clones have a high risk for introducing bugs\u00a0\u2026", "num_citations": "2\n", "authors": ["804"]}
{"title": "Osaka Univsesity\n", "abstract": " This paper presents an adaptation of the CEGAR loop approach based on the reduction of the number of clocks in timed automata. In the presented method, an abstraction of the timed automata in which some of the clocks are removed is used to search for a counter-example for a given temporal logic statement. If the counter-example produced by the abstracted timed automaton is not a counter-example of the original timed automaton, the abstracted model is refined by restoring some of the clocks so that the process can be repeated for the new abstracted model. Reducing the number of the clock may result in a substantial reduction in the amount of the computation required for the model checking as the number states is exponential in the number of clocks. I.", "num_citations": "2\n", "authors": ["804"]}