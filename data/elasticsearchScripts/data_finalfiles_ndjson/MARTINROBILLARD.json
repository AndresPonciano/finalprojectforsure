{"title": "Concern graphs: finding and describing concerns using structural program dependencies\n", "abstract": " Many maintenance tasks address concerns, or features, that are not well modularized in the source code comprising a system. Existing approaches available to help software developers locate and manage scattered concerns use a representation based on lines of source code, complicating the analysis of the concerns. In this paper, we introduce the Concern Graph representation that abstracts the implementation details of a concern and makes explicit the relationships between different parts of the concern. The abstraction used in a Concern Graph has been designed to allow an obvious and inexpensive mapping back to the corresponding source code. To investigate the practical tradeoffs related to this approach, we have built the Feature Exploration and Analysis tool (FEAT) that allows a developer to manipulate a concern representation extracted from a Java system, and to analyze the relationships of that\u00a0\u2026", "num_citations": "487\n", "authors": ["108"]}
{"title": "What makes APIs hard to learn? answers from developers\n", "abstract": " The paper discusses the application program interface (API). Most software projects reuse components exposed through APIs. In fact, current-day software development technologies are becoming inseparable from the large APIs they provide. An API is the interface to implemented functionality that developers can access to perform various tasks. APIs support code reuse, provide high-level abstractions that facilitate programming tasks, and help unify the programming experience. A study of obstacles that professional Microsoft developers faced when learning to use APIs uncovered challenges and resulting implications for API users and designers. The article focuses on the obstacles to learning an API. Although learnability is only one dimension of usability, there's a clear relationship between the two, in that difficult-to-use APIs are likely to be difficult to learn as well. Many API usability studies focus on situations\u00a0\u2026", "num_citations": "397\n", "authors": ["108"]}
{"title": "A field study of API learning obstacles\n", "abstract": " Large APIs can be hard to learn, and this can lead to decreased programmer productivity. But what makes APIs hard to learn? We conducted a mixed approach, multi-phased study of the obstacles faced by Microsoft developers learning a wide variety of new APIs. The study involved a combination of surveys and in-person interviews, and collected the opinions and experiences of over 440 professional developers. We found that some of the most severe obstacles faced by developers learning new APIs pertained to the documentation and other learning resources. We report on the obstacles developers face when learning new APIs, with a special focus on obstacles related to API documentation. Our qualitative analysis elicited five important factors to consider when designing API documentation: documentation of intent; code examples; matching APIs with scenarios; penetrability of the API; and format and\u00a0\u2026", "num_citations": "348\n", "authors": ["108"]}
{"title": "How effective developers investigate source code: An exploratory study\n", "abstract": " Prior to performing a software change task, developers must discover and understand the subset of the system relevant to the task. Since the behavior exhibited by individual developers when investigating a software system is influenced by intuition, experience, and skill, there is often significant variability in developer effectiveness. To understand the factors that contribute to effective program investigation behavior, we conducted a study of five developers performing a change task on a medium-size open source system. We isolated the factors related to effective program investigation behavior by performing a detailed qualitative analysis of the program investigation behavior of successful and unsuccessful developers. We report on these factors as a set of detailed observations, such as evidence of the phenomenon of inattention blindness by developers skimming source code. In general, our results support the\u00a0\u2026", "num_citations": "331\n", "authors": ["108"]}
{"title": "Representing concerns in source code\n", "abstract": " A software modification task often addresses several concerns. A concern is anything a stakeholder may want to consider as a conceptual unit, including features, nonfunctional requirements, and design idioms. In many cases, the source code implementing a concern is not encapsulated in a single programming language module, and is instead scattered and tangled throughout a system. Inadequate separation of concerns increases the difficulty of evolving software in a correct and cost-effective manner. To make it easier to modify concerns that are not well modularized, we propose an approach in which the implementation of concerns is documented in artifacts, called concern graphs. Concern graphs are abstract models that describe which parts of the source code are relevant to different concerns. We present a formal model for concern graphs and the tool support we developed to enable software developers to\u00a0\u2026", "num_citations": "303\n", "authors": ["108"]}
{"title": "Tracking code clones in evolving software\n", "abstract": " Code clones are generally considered harmful in software development, and the predominant approach is to try to eliminate them through refactoring. However, recent research has provided evidence that it may not always be practical, feasible, or cost-effective to eliminate certain clone groups. We propose a technique for tracking clones in evolving software. Our technique relies on the concept of abstract clone region descriptors (CRD), which describe clone regions within methods in a robust way that is independent from the exact text of the clone region or its location in a file. We present our definition of CRDs, and describe a complete clone tracking system capable of producing CRDs from the output of a clone detection tool, notify developers of modifications to clone regions, and support the simultaneous editing of clone regions. We report on two experiments and a case study conducted to assess the\u00a0\u2026", "num_citations": "284\n", "authors": ["108"]}
{"title": "Recommending adaptive changes for framework evolution\n", "abstract": " In the course of a framework\u2019s evolution, changes ranging from a simple refactoring to a complete rearchitecture can break client programs. Finding suitable replacements for framework elements that were accessed by a client program and deleted as part of the framework\u2019s evolution can be a challenging task. We present a recommendation system, SemDiff, that suggests adaptations to client programs by analyzing how a framework was adapted to its own changes. In a study of the evolution of one open source framework and three client programs, our approach recommended relevant adaptive changes with a high level of precision. In a second study of the evolution of two frameworks, we found that related change detection approaches were better at discovering systematic changes and that SemDiff was complementary to these approaches by detecting non-trivial changes such as when a functionality is imported\u00a0\u2026", "num_citations": "283\n", "authors": ["108"]}
{"title": "Static analysis to support the evolution of exception structure in object-oriented systems\n", "abstract": " Exception-handling mechanisms in modern programming languages provide a means to help software developers build robust applications by separating the normal control flow of a program from the control flow of the program under exceptional situations. Separating the exceptional structure from the code associated with normal operations bears some consequences. One consequence is that developers wishing to improve the robustness of a program must figure out which exceptions, if any, can flow to a point in the program. Unfortunately, in large programs, this exceptional control flow can be difficult, if not impossible, to determine.In this article, we present a model that encapsulates the minimal concepts necessary for a developer to determine exception flow for object-oriented languages that define exceptions as objects. Using these concepts, we describe why exception-flow information is needed to build and\u00a0\u2026", "num_citations": "206\n", "authors": ["108"]}
{"title": "Non-essential changes in version histories\n", "abstract": " Numerous techniques involve mining change data captured in software archives to assist engineering efforts, for example to identify components that tend to evolve together. We observed that important changes to software artifacts are sometimes accompanied by numerous non-essential modifications, such as local variable refactorings, or textual differences induced as part of a rename refactoring. We developed a tool-supported technique for detecting non-essential code differences in the revision histories of software systems. We used our technique to investigate code changes in over 24,000 change sets gathered from the change histories of seven long-lived open-source systems. We found that up to 15.5% of a system's method updates were due solely to non-essential differences. We also report on numerous observations on the distribution of non-essential differences in change history and their potential\u00a0\u2026", "num_citations": "200\n", "authors": ["108"]}
{"title": "Automatic generation of suggestions for program investigation\n", "abstract": " Before performing a modification task, a developer usually has to investigate the source code of a system to understand how to carry out the task. Discovering the code relevant to a change task is costly because it is an inherently human activity whose success depends on a large number of unpredictable factors, such as intuition and luck. Although studies have shown that effective developers tend to explore a program by following structural dependencies, no methodology is available to guide their navigation through the typically hundreds of dependency paths found in a non-trivial program. In this paper, we propose a technique to automatically propose and rank program elements that are potentially interesting to a developer investigating source code. Our technique is based on an analysis of the topology of structural dependencies in a program. It takes as input a set of program elements of interest to a developer\u00a0\u2026", "num_citations": "197\n", "authors": ["108"]}
{"title": "Recovering traceability links between an API and its learning resources\n", "abstract": " Large frameworks and libraries require extensive developer learning resources, such as documentation and mailing lists, to be useful. Maintaining these learning resources is challenging partly because they are not explicitly linked to the frameworks' API, and changes in the API are not reflected in the learning resources. Automatically recovering traceability links between an API and learning resources is notoriously difficult due to the inherent ambiguity of unstructured natural language. Code elements mentioned in documents are rarely fully qualified, so readers need to understand the context in which a code element is mentioned. We propose a technique that identifies code-like terms in documents and links these terms to specific code elements in an API, such as methods. In an evaluation study with four open source systems, we found that our technique had an average recall and precision of 96%.", "num_citations": "176\n", "authors": ["108"]}
{"title": "Discovering essential code elements in informal documentation\n", "abstract": " To access the knowledge contained in developer communication, such as forum posts, it is useful to determine automatically the code elements referred to in the discussions. We propose a novel traceability recovery approach to extract the code elements contained in various documents. As opposed to previous work, our approach does not require an index of code elements to find links, which makes it particularly well-suited for the analysis of informal documentation. When evaluated on 188 StackOverflow answer posts containing 993 code elements, the technique performs with average 0.92 precision and 0.90 recall. As a major refinement on traditional traceability approaches, we also propose to detect which of the code elements in a document are salient, or germane, to the topic of the post. To this end we developed a three-feature decision tree classifier that performs with a precision of 0.65-0.74 and recall of 0\u00a0\u2026", "num_citations": "174\n", "authors": ["108"]}
{"title": "Moving into a new software project landscape\n", "abstract": " When developers join a software development project, they find themselves in a project landscape, and they must become familiar with the various landscape features. To better understand the nature of project landscapes and the integration process, with a view to improving the experience of both newcomers and the people responsible for orienting them, we performed a grounded theory study with 18 newcomers across 18 projects. We identified the main features that characterize a project landscape, together with key orientation aids and obstacles, and we theorize that there are three primary factors that impact the integration experience of newcomers: early experimentation, internalizing structures and cultures, and progress validation.", "num_citations": "163\n", "authors": ["108"]}
{"title": "Separating features in source code: An exploratory study\n", "abstract": " Most software systems are inflexible. Reconfiguring a system's modules to add or to delete a feature requires substantial effort. This inflexibility increases the costs of building variants of a system, amongst other problems. New languages and tools that are being developed to provide additional support for separating concerns show promise to help address this problem. However applying these mechanisms requires determining how to enable a feature to be separated from the codebase. We investigate this problem through an exploratory study conducted in the context of two existing systems: gnu.regexp and jFTPd. The study consisted of applying three different separation of concern mechanisms: Hyper/J/sup TM/ AspectJ/sup TM/ and a lightweight, lexically-based approach, to separate features in the two packages. We report on the study, providing contributions in two areas. First, we characterize the effect\u00a0\u2026", "num_citations": "146\n", "authors": ["108"]}
{"title": "Topology analysis of software dependencies\n", "abstract": " Before performing a modification task, a developer usually has to investigate the source code of a system to understand how to carry out the task. Discovering the code relevant to a change task is costly because it is a human activity whose success depends on a large number of unpredictable factors, such as intuition and luck. Although studies have shown that effective developers tend to explore a program by following structural dependencies, no methodology is available to guide their navigation through the thousands of dependency paths found in a nontrivial program. We describe a technique to automatically propose and rank program elements that are potentially interesting to a developer investigating source code. Our technique is based on an analysis of the topology of structural dependencies in a program. It takes as input a set of program elements of interest to a developer and produces a fuzzy set\u00a0\u2026", "num_citations": "145\n", "authors": ["108"]}
{"title": "Creating and evolving developer documentation: understanding the decisions of open source contributors\n", "abstract": " Developer documentation helps developers learn frameworks and libraries. To better understand how documentation in open source projects is created and maintained, we performed a qualitative study in which we interviewed core contributors who wrote developer documentation and developers who read documentation. In addition, we studied the evolution of 19 documents by analyzing more than 1500 document revisions. We identified the decisions that contributors make, the factors influencing these decisions and the consequences for the project. Among many findings, we observed how working on the documentation could improve the code quality and how constant interaction with the projects' community positively impacted the documentation.", "num_citations": "131\n", "authors": ["108"]}
{"title": "ConcernMapper: simple view-based separation of scattered concerns\n", "abstract": " We introduce ConcernMapper, an Eclipse plug-in for experimenting with techniques for advanced separation of concerns. ConcernMapper supports development and maintenance tasks involving scattered concerns by allowing developers to organize and view the code of a project in terms of high-level abstractions called concerns. ConcernMapper is also designed as an extensible platform intended to provide a simple way to store and query concern models created through a variety of approaches. This paper describes the user interface and internal architecture of ConcernMapper, and demonstrates how to write extensions for it.", "num_citations": "125\n", "authors": ["108"]}
{"title": "Clonetracker: tool support for code clone management\n", "abstract": " Code clones are generally considered to be an obstacle to software maintenance. Research has provided evidence that it may not always be practical, feasible, or cost-effective to eliminate certain clone groups through refactoring. This paper describes CloneTracker, an Eclipse plug-in that provides support for tracking code clones in evolving software. With CloneTracker, developers can specify clone groups they wish to track, and the tool will automatically generate a clone model that is robust to changes to the source code, and can be shared with other collaborators of the project. When future modifications intersect with tracked clones, CloneTracker will notify the developer, provide support to consistently apply changes to a corresponding clone region, and provide support for updating the clone model. CloneTracker complements existing techniques by providing support for reusing knowledge about the location of\u00a0\u2026", "num_citations": "123\n", "authors": ["108"]}
{"title": "Asking and answering questions about unfamiliar APIs: An exploratory study\n", "abstract": " The increasing size of APIs and the increase in the number of APIs available imply developers must frequently learn how to use unfamiliar APIs. To identify the types of questions developers want answered when working with unfamiliar APIs and to understand the difficulty they may encounter answering those questions, we conducted a study involving twenty programmers working on different programming tasks, using unfamiliar APIs. Based on the screen captured videos and the verbalization of the participants, we identified twenty different types of questions programmers ask when working with unfamiliar APIs, and provide new insights to the cause of the difficulties programmers encounter when answering questions about the use of APIs. The questions we have identified and the difficulties we observed can be used for evaluating tools aimed at improving API learning, and in identifying areas of the API learning\u00a0\u2026", "num_citations": "122\n", "authors": ["108"]}
{"title": "Designing robust Java programs with exceptions\n", "abstract": " Exception handling mechanisms are intended to help developers build robust systems. Although an exception handling mechanism provides a basis for structuring source code dealing with unusual situations, little information is available to help guide a developer in the appropriate application of the mechanism. In our experience, this lack of guidance leads to complex exception structures. In this paper, we reflect upon our experiences using the Java exception handling mechanism. Based on these experiences, we discuss two issues we believe underlie the difficulties encountered: exceptions are a global design problem, and exception sources are often difficult to predict in advance. We then describe a design approach, based on work by Litke for Ada programs, which we have used to simplify exception structure in existing Java programs.", "num_citations": "121\n", "authors": ["108"]}
{"title": "Clone region descriptors: Representing and tracking duplication in source code\n", "abstract": " Source code duplication, commonly known as code cloning, is considered an obstacle to software maintenance because changes to a cloned region often require consistent changes to other regions of the source code. Research has provided evidence that the elimination of clones may not always be practical, feasible, or cost-effective. We present a clone management approach that describes clone regions in a robust way that is independent from the exact text of clone regions or their location in a file, and that provides support for tracking clones in evolving software. Our technique relies on the concept of abstract clone region descriptors (CRDs), which describe clone regions using a combination of their syntactic, structural, and lexical information. We present our definition of CRDs, and describe a clone tracking system capable of producing CRDs from the output of different clone detection tools, notifying\u00a0\u2026", "num_citations": "105\n", "authors": ["108"]}
{"title": "FEAT a tool for locating, describing, and analyzing concerns in source code\n", "abstract": " Developers working on existing programs repeatedly have to address concerns, or aspects, that are not well modularized in the source code comprising a system. In such cases, a developer has to first locate the implementation of the concern in the source code comprising the system, and then document the concern sufficiently to be able to understand it and perform the actual change task.", "num_citations": "104\n", "authors": ["108"]}
{"title": "The emergent structure of development tasks\n", "abstract": " Integrated development environments have been designed and engineered to display structural information about the source code of large systems. When a development task lines up with the structure of the system, the tools in these environments do a great job of supporting developers in their work. Unfortunately, many development tasks do not have this characteristic. Instead, they involve changes that are scattered across the source code and various other kinds of artifacts, including bug reports and documentation. Today\u2019s development environments provide little support for working with scattered pieces of a system, and as a result, are not adequately supporting the ways in which developers work on the system. Fortunately, many development tasks do have a structure. This structure emerges from a developer\u2019s actions when changing the system. In this paper, we describe how the structure of many\u00a0\u2026", "num_citations": "101\n", "authors": ["108"]}
{"title": "Analyzing Exception Flow in Java\u2122 Programs\n", "abstract": " Exception handling mechanisms provided by programming languages are intended to ease the difficulty of developing robust software systems. Using these mechanisms, a software developer can describe the exceptional conditions a module might raise, and the response of the module to exceptional conditions that may occur as it is executing. Creating a robust system from such a localized view requires a developer to reason about the flow of exceptions across modules. The use of unchecked exceptions, and in object-oriented languages, subsumption, makes it difficult for a software developer to perform this reasoning manually. In this paper, we describe a tool called Jex that analyzes the flow of exceptions in Java code to produce views of the exception structure. We demonstrate how Jex can help a developer identify program points where exceptions are caught accidentally, where there is an opportunity\u00a0\u2026", "num_citations": "95\n", "authors": ["108"]}
{"title": "Does aspect-oriented programming work?\n", "abstract": " 76 October 2001/Vol. 44, No. 10 COMMUNICATIONS OF THE ACM number of studies have been conducted to assess the usefulness of AOP and similar technologies. There are two basic techniques for assessing a programming technology: experiments and case studies. Experiments provide an opportunity for direct comparison, allowing researchers to investigate how the technology performs in detailed ways. Case studies take many forms, from small-scale comparisons to longitudinal studies of the technology in action. Case studies tend to provide broader knowledge about the use of a technology.Experiments: Debugging and Change", "num_citations": "94\n", "authors": ["108"]}
{"title": "Discovering information explaining API types using text classification\n", "abstract": " Many software development tasks require developers to quickly learn a subset of an Application Programming Interface (API). API learning resources are crucial for helping developers learn an API, but the knowledge relevant to a particular topic of interest may easily be scattered across different documents, which makes finding the necessary information more challenging. This paper proposes an approach to discovering tutorial sections that explain a given API type. At the core of our approach, we classify fragmented tutorial sections using supervised text classification based on linguistic and structural features. Experiments conducted on five tutorials show that our approach is able to discover sections explaining an API type with precision between 0.69 and 0.87 (depending on the tutorial) when trained and tested on the same tutorial. When trained and tested across tutorials, we obtained a precision between 0.74\u00a0\u2026", "num_citations": "91\n", "authors": ["108"]}
{"title": "Automatically inferring concern code from program investigation activities\n", "abstract": " When performing a program evolution task, developers typically spend a significant amount of effort investigating and reinvestigating source code. To reduce this effort, we propose a technique to automatically infer the essence of program investigation activities as a set of concern descriptions. The concern descriptions produced by our technique list methods and fields of importance in the context of the investigation of an object-oriented system. A developer can rely on this information to perform the change task at hand, or at a later stage for a change that involves the same concerns. The technique involves applying an algorithm to a transcript of a program investigation session. The transcript lists which pieces of source code were accessed by a developer when investigating a program and how the different pieces of code were accessed. We applied the technique to data obtained from program investigation\u00a0\u2026", "num_citations": "91\n", "authors": ["108"]}
{"title": "Types of collaborative work in software engineering\n", "abstract": " This paper is an account on work distribution analyzed from the collaboration point of view. It presents a new classification of the collaborative work in software engineering project. Four types of collaborative work are defined derived from empirical measurements of activities. Mandatory collaborative works are formal scheduled meetings. Called collaborative work is defined when team members call a meeting to solve a problem, which is most often technical. Ad hoc collaborative work is defined when team members work on the same task at the same time and individual work occurs when a team member works on its own on a task related to the project. Data are extracted from the logbook filled out by four team members working on an industrial project that lasts 19 weeks. The characteristics of each type of collaborative activity are described and a quantitative breakdown of how people spend their time in\u00a0\u2026", "num_citations": "90\n", "authors": ["108"]}
{"title": "Code fragment summarization\n", "abstract": " Current research in software engineering has mostly focused on the retrieval accuracy aspect but little on the presentation aspect of code examples, eg, how code examples are presented in a result page. We investigate the feasibility of summarizing code examples for better presenting a code example. Our algorithm based on machine learning could approximate summaries in an oracle manually generated by humans with a precision of 0.71. This result is promising as summaries with this level of precision achieved the same level of agreement as human annotators with each other.", "num_citations": "70\n", "authors": ["108"]}
{"title": "Recommending reference API documentation\n", "abstract": " Reference documentation is an important source of information on API usage. However, information useful to programmers can be buried in irrelevant text, or attached to a non-intuitive API element, making it difficult to discover. We propose to detect and recommend fragments of API documentation potentially important to a programmer who has already decided to use a certain API element. We categorize text fragments in API documentation based on whether they contain information that is indispensable, valuable, or neither. From the fragments that contain knowledge worthy of recommendation, we extract word patterns, and use these patterns to automatically find new fragments that contain similar knowledge in unseen documentation. We implemented our technique in a tool, Krec, that supports both information filtering and discovery. In an evaluation study with randomly-sampled method definitions from\u00a0\u2026", "num_citations": "68\n", "authors": ["108"]}
{"title": "Using structure-based recommendations to facilitate discoverability in APIs\n", "abstract": " Empirical evidence indicates that developers face significant hurdles when the API elements necessary to implement a task are not accessible from the types they are working with. We propose an approach that leverages the structural relationships between API elements to make API methods or types not accessible from a given API type more discoverable. We implemented our approach as an extension to the content assist feature of the Eclipse IDE, in a tool called API Explorer. API Explorer facilitates discoverability in APIs by recommending methods or types, which although not directly reachable from the type a developer is currently working with, may be relevant to solving a programming task. In a case study evaluation, participants experienced little difficulty selecting relevant API elements from the recommendations made by API Explorer, and found the assistance provided by API Explorer helpful in\u00a0\u2026", "num_citations": "68\n", "authors": ["108"]}
{"title": "Improving API usage through automatic detection of redundant code\n", "abstract": " Software projects often rely on third-party libraries made accessible through Application Programming Interfaces (APIs). We have observed many cases where APIs are used in ways that are not the most effective. We developed a technique and tool support to automatically detect such patterns of API usage in software projects. The main hypothesis underlying our technique is that client code imitating the behavior of an API method without calling it may not be using the API effectively because it could instead call the method it imitates. Our technique involves analyzing software systems to detect cases of API method imitations. In addition to warning developers of potentially re-implemented API methods, we also indicate how to improve the use of the API. Applying our approach on 10 Java systems revealed over 400 actual cases of potentially suboptimal API usage, leading to many improvements to the quality of the\u00a0\u2026", "num_citations": "65\n", "authors": ["108"]}
{"title": "SemDiff: Analysis and recommendation support for API evolution\n", "abstract": " As a framework evolves, changes in its application programming interface (API) can break client programs that extend the framework. Repairing a client program can be a challenging task because developers need to understand the context surrounding the API change. This paper describes SemDiff, a tool that recommends replacements for framework methods that were accessed by a client program and deleted during the evolution of the framework. SemDiff recommends replacements for non-trivial changes undiscovered by other change-detection techniques and also enables developers to look at the context of the changes that led to the deletion of a framework method.", "num_citations": "64\n", "authors": ["108"]}
{"title": "Drive-by analysis of running programs\n", "abstract": " Understanding the behavior of complex Java programs requires a balance of detail and volume. For example, a transaction server may perform poorly because it is not always precompiling a database query. Establishing this piece of information requires a relatively fine level of detail: eg, the sequence, context, and duration of individual method invocations. To collect this detail, we could generate a detailed trace of the program. Unfortunately, recording detailed execution traces quickly becomes infeasible, due to both time perturbations and space overheads\u2014infeasible for even reasonably complex programs. As a quick example, tracing IBM\u2019s Jinsight visualizer from the outset consumes 37MB by the time the main window has appeared; this figure does not even include the tracing of any values, such as argument or return values. For a highly multithreaded server, such as IBM\u2019s WebSphere Application Server, traces of similar time frames can easily grow to ten times this size. Yet, the other extreme, tracing only aggregate statistics (such as heap consumption, method invocation counts, each methods\u2019 average invocation time, or an aggregate call graph [1, 2, 3]) often will not discover the root problem: why are these transactions slow, while those others are fast? Why does the program fail on some calls to one method, but not other calls to that same method? We propose that it is not just any details that will help, but rather details associated with a particular task. In our transaction server example, at any point in time the server will be processing transactions in many threads, and doing administrative work in others; Figure 1 shows such a case. Many\u00a0\u2026", "num_citations": "59\n", "authors": ["108"]}
{"title": "The influence of the task on programmer behaviour\n", "abstract": " Programmers performing a change task must understand the existing software in addition to performing the actual change. This process is likely to be affected by characteristics of the task. We investigated whether the nature of a task has any relationship with when a programmer edits code during a programming session. We characterized differences in editing behaviour with three types of editing styles: edit-first, edit-last, and edit-throughout. We based our analysis on the interaction history of over 4000 programming sessions collected as part of the development history of open source projects. Our results showed that an enhancement task (as opposed to a bug fix) was less likely to be associated with a high fraction of source code edit events at the beginning of the programming session. To our surprise, we also found that the presence of a stack trace in a bug report did not significantly effect the editing style of the\u00a0\u2026", "num_citations": "53\n", "authors": ["108"]}
{"title": "Suade: Topology-based searches for software investigation\n", "abstract": " The investigation of a software system prior to a modification task often constitutes an important fraction of the overall effort associated with the task. We present Suade, an Eclipse plug-in to automatically generate suggestions for software investigation. The goal of Suade is to increase the efficiency with which developers explore the source code by recommending locations that are likely to be relevant to the task. Based on a context of software elements (fields and methods) explicitly specified by a developer, Suade automatically generates other elements that are likely to be relevant given the context, by analyzing the topology of structural dependencies in a software system.", "num_citations": "53\n", "authors": ["108"]}
{"title": "A comparative study of three program exploration tools\n", "abstract": " Programmers need tools to help explore large software systems when performing software evolution tasks. A variety of tools have been created to improve the effectiveness of such exploration. The usefulness of these tools has been argued largely on the basis of case studies, small narrowly-focussed experiments, or non-human-based experiments. In this paper, we report on a more rigorously controlled study of three specialized software exploration tools in which professional programmers used the tools to plan complex change tasks to a medium-sized code base. We found that the tools had little apparent effect; the effects observed instead appear to be dominated by individual styles and strategies of the programmers and characteristics of the tasks. In addition to presenting the results of the study, this paper introduces the use of two experimental evaluation aids: the NASA task load index (TLX) for assessing task\u00a0\u2026", "num_citations": "48\n", "authors": ["108"]}
{"title": "Efficient mapping of software system traces to architectural views.\n", "abstract": " Information about a software system\u2019s execution can help a developer with many tasks, including software testing, performance tuning, and program understanding. In almost all cases, this dynamic information is reported in terms of source-level constructs, such as procedures and methods. For some software engineering tasks, source-level information is not optimal because there is a wide gap between the information presented (ie, procedures) and the concepts of interest to the software developer (ie, subsystems). One way to close this gap is to allow developers to investigate the execution information in terms of a higher-level, typically architectural, view. In this paper, we present a straightforward encoding technique for dynamic trace information that makes it tractable and efficient to manipulate a trace from a variety of different architecture-level viewpoints. We also describe how this encoding technique has been used to support the development of two tools: a visualization tool and a path query tool. We present this technique to enable the development of additional tools that manipulate dynamic information at a higherlevel than source.", "num_citations": "47\n", "authors": ["108"]}
{"title": "Selection and presentation practices for code example summarization\n", "abstract": " Code examples are an important source for answering questions about software libraries and applications. Many usage contexts for code examples require them to be distilled to their essence: eg, when serving as cues to longer documents, or for reminding developers of a previously known idiom. We conducted a study to discover how code can be summarized and why. As part of the study, we collected 156 pairs of code examples and their summaries from 16 participants, along with over 26 hours of think-aloud verbalizations detailing the decisions of the participants during their summarization activities. Based on a qualitative analysis of this data we elicited a list of practices followed by the participants to summarize code examples and propose empirically-supported hypotheses justifying the use of specific practices. One main finding was that none of the participants exclusively extracted code verbatim for the\u00a0\u2026", "num_citations": "40\n", "authors": ["108"]}
{"title": "Inferring structural patterns for concern traceability in evolving software\n", "abstract": " As part of the evolution of software systems, effort is often invested to discover in what parts of the source code a feature (or other concern) is implemented. Unfortunately, knowledge about a concern's implementation can become invalid as the system evolves. We propose to mitigate this problem by automatically inferring structural patterns among the elements identified as relevant to a concern's implementation. We then document the inferred patterns as rules that can be checked as the source code evolves. Checking whether structural patterns hold across different versions of a system enables the automatic identification of new elements related to a documented concern. We implemented our technique for JAVA in an Eclipse plug-in called ISIS and applied it to a number of concerns. With a case study spanning 34 versions of the development history of an open-source system, we show how our approach supports\u00a0\u2026", "num_citations": "40\n", "authors": ["108"]}
{"title": "Detecting fragile comments\n", "abstract": " Refactoring is a common software development practice and many simple refactorings can be performed automatically by tools. Identifier renaming is a widely performed refactoring activity. With tool support, rename refactorings can rely on the program structure to ensure correctness of the code transformation. Unfortunately, the textual references to the renamed identifier present in the unstructured comment text cannot be formally detected through the syntax of the language, and are thus fragile with respect to identifier renaming. We designed a new rule-based approach to detect fragile comments. Our approach, called Fraco, takes into account the type of identifier, its morphology, the scope of the identifier and the location of comments. We evaluated the approach by comparing its precision and recall against hand-annotated benchmarks created for six target Java systems, and compared the results against the\u00a0\u2026", "num_citations": "33\n", "authors": ["108"]}
{"title": "A study of the effectiveness of usage examples in REST API documentation\n", "abstract": " Generating and maintaining REST API documentation with usage examples can be a time consuming and expensive process for evolving APIs. Most REST API documentation tools focus on automating the documentation of the API objects, but require manual effort for capturing usage examples. Consequently, REST API developers need to know the cost vs. benefit of providing usage examples in the documentation to prioritize the documentation efforts. To this end, we have performed a controlled study with 26 experienced software engineers to understand problems that REST API client developers face while using an API without usage examples. We found that REST API client developers face productivity problems with using correct data types, data formats, required HTTP headers and request body when documentation lacks usage examples. By following the REST API documentation suggestions from this\u00a0\u2026", "num_citations": "32\n", "authors": ["108"]}
{"title": "Recommending change clusters to support software investigation: an empirical study\n", "abstract": " During software maintenance tasks, developers often spend a valuable amount of effort investigating source code. This effort can be reduced if tools are available to help developers navigate the source code effectively. We studied to what extent developers can benefit from information contained in clusters of change sets to guide their investigation of a software system. We defined change clusters as groups of change sets that have a certain amount of elements in common. Our analysis of 4200 change sets for seven different systems and covering a cumulative time span of over 17 years of development showed that less than one in five tasks overlapped with change clusters. Furthermore, a detailed qualitative analysis of the results revealed that only 13% of the clusters associated with applicable change tasks were likely to be useful. We conclude that change clusters can only support a minority of change tasks\u00a0\u2026", "num_citations": "30\n", "authors": ["108"]}
{"title": "Method and apparatus for tracing details of a program task\n", "abstract": " A method and apparatus are disclosed for analyzing one or more program tasks associated with a software system. A program task-oriented tracing and analysis technique allows detailed information to be gathered and analyzed for one or more specified program tasks. A user can iteratively vary the level of detail or the selected program task (s) of interest, or both, until the source of a problem is identified. For each program task under analysis, the user can define what commences a task and what concludes a task. A software program is monitored until the user-specified criteria for commencing a task is identified and continues to trace the execution of the software program until the user-specified criteria for concluding a task is identified.", "num_citations": "26\n", "authors": ["108"]}
{"title": "Using traceability links to recommend adaptive changes for documentation evolution\n", "abstract": " Developer documentation helps developers learn frameworks and libraries, yet developing and maintaining accurate documentation requires considerable effort and resources. Contributors who work on developer documentation often need to manually track all changes in the code, determine which changes are significant enough to document, and then, adapt the documentation. We propose AdDoc, a technique that automatically discovers documentation patterns, i.e., coherent sets of code elements that are documented together, and that reports violations of these patterns as the code and the documentation evolves. We evaluated our approach in a retrospective analysis of four Java open source projects and found that at least 50 percent of all the changes in the documentation were related to existing documentation patterns. Our technique allows contributors to quickly adapt existing documentation, so that they\u00a0\u2026", "num_citations": "25\n", "authors": ["108"]}
{"title": "Automatically recommending triage decisions for pragmatic reuse tasks\n", "abstract": " Planning a complex software modification task imposes a high cognitive burden on developers, who must juggle navigating the software, understanding what they see with respect to their task, and deciding how their task should be performed given what they have discovered. Pragmatic reuse tasks, where source code is reused in a white-box fashion, is an example of a complex and error-prone modification task: the developer must plan out which portions of a system to reuse, extract the code, and integrate it into their own system. In this paper we present a recommendation system that automates some aspects of the planning process undertaken by developers during pragmatic reuse tasks. In a retroactive evaluation, we demonstrate that our technique was able to provide the correct recommendation 64% of the time and was incorrect 25% of the time. Our case study suggests that developer investigative behaviour\u00a0\u2026", "num_citations": "24\n", "authors": ["108"]}
{"title": "Revisiting turnover-induced knowledge loss in software projects\n", "abstract": " In large software projects, tacit knowledge of the system is threatened by developer turnover. When a developer leaves the project, their knowledge may be lost if the other developers do not understand the design decisions made by the leaving developer. Understanding the source code written by leaving developers thus becomes a burden for their successors. In a previous paper, Rigby et al. reported on a case study of turnover-induced knowledge loss in two large projects, Chromium and a project at Avaya, using risk evaluation methods usually applied to financial systems. They found that the two projects were susceptible to large knowledge losses that are more than three times the average loss. We report on a replication of their study on the Chromium project, as well as seven other large and medium-sized open source projects. We also extended theirwork by studying two variations of the knowledge loss\u00a0\u2026", "num_citations": "23\n", "authors": ["108"]}
{"title": "Improving academic software engineering projects: A comparative study of academic and industry projects\n", "abstract": " A project course in software engineering is often part of the curriculum in computer engineering or computer science. This paper studies the relationship between academic and industrial projects in software engineering. The purpose is to compare the practices followed in a project-course approach with the practices of professional software engineers. The approach is to compare the measurements obtained from academic and industrial projects. The critical factors regarding the process, the people and the project are discussed. The structure of the software processes and the measurement tools are presented. The data analyses show that the academic projects are found to be strongly dominated by programming activities. Based on the data from the industrial projects, we formulate seven recommendations to improve the software engineering practices in academic projects. They are related to\u00a0\u2026", "num_citations": "23\n", "authors": ["108"]}
{"title": "Enforcing exception handling policies with a domain-specific language\n", "abstract": " Current software projects deal with exceptions in implementation and maintenance phases without a clear definition of exception handling policies. We call an exception handling policy the set of design decisions that govern the use of exceptions in a software project. Without an explicit exception handling policy, developers can remain unaware of the originally intended use of exceptions. In this paper, we present Exception Handling Policies Language (EPL), a domain-specific language to specify and verify exception handling policies. The evaluation of EPL was based on a user-centric observational study and case studies. The user-centric study was performed to observe how potential users of the language actually use it. With this study, we could better understand the trade-offs related to different language design decisions based on concrete and well-documented observations and experiences reported by\u00a0\u2026", "num_citations": "20\n", "authors": ["108"]}
{"title": "NaCIN: an Eclipse plug-in for program navigation-based concern inference\n", "abstract": " In this paper we describe NaCIN, an Eclipse plug-in that records a developer's code navigation activity and produces sets of elements potentially implementing different concerns relevant to the current task. It performs an analysis of the navigation paths and structural dependencies of the recorded elements and clusters the results in groups potentially associated with high level concepts. NaCIN partially automates the process of relating source code with high-level abstractions and enables knowledge about the implementation of different concerns to be reused in future investigations. We present the architecture and a preliminary assessment of NaCIN.", "num_citations": "19\n", "authors": ["108"]}
{"title": "Regaining control of exception handling\n", "abstract": " Just as the structure of the normal operations of a system tends to degrade as the system evolves, the structure of exception handling also degrades. In this paper, we draw on our experience building and analyzing the exception structure of Java programs to describe why and how exception structure degrades. Fortunately, we need not let our exception structure languish. We also relate our experience at regaining control of exception structure in several existing programs using a technique based on software containment. KeywordsException Handling, Program Structure, Software Structure, Error Handling, Design. 1 INTRODUCTION To help manage complexity, software developers use various types of structure to organize the source code for a system. Programming language constructs, such as procedures and procedure calls, provide a means of expressing ne-grained structure. Architectural styles 14], such as layers or pipes and lters, provide a means of describing coarse-grained structure. Selecting and implementing appropriate structures for a system can provide many bene ts; for example, the source may be more modi able or reusable as a result.", "num_citations": "18\n", "authors": ["108"]}
{"title": "Bridging the gap between aspect mining and refactoring\n", "abstract": " Aspect-mining techniques help to identify crosscutting structure that could potentially be modularized through object-oriented (OO) or aspect-oriented refactoring (AO). This paper describes a case study in which we used aspect-mining techniques to identify and refactor crosscutting concerns using aspect-oriented programming. We observed that, in our case, there were many subtle variations in the implementation of the concerns that made them non-trivial to modularize with AO refactoring. In the end, we solved our modularization problem using traditional OO refactoring. We conclude that there exists an important gap between the identification of crosscutting concerns and the technologies available to mitigate the problem.", "num_citations": "17\n", "authors": ["108"]}
{"title": "Detecting increases in feature coupling using regression tests\n", "abstract": " Repeated changes to a software system can introduce small weaknesses such as unplanned dependencies between different parts of the system. While such problems usually go undetected, their cumulative effect can result in a noticeable decrease in the quality of a system. We present an approach to warn developers about increased coupling between the (potentially scattered) implementation of different features. Our automated approach can detect sections of the source code contributing to the increased coupling as soon as software changes are tested. Developers can then inspect the results to assess whether the quality of their changes is adequate. We have implemented our approach for C++ and integrated it with the development process of a proprietary 3D graphics software. We report on our evaluation of the approach in the field, and on a study showing that, for files in the target system, causing\u00a0\u2026", "num_citations": "16\n", "authors": ["108"]}
{"title": "Capturing concern descriptions during program navigation\n", "abstract": " On Monday morning, Pat gets assigned the task of restructuring the data model of the company\u2019s SuperTool\u00a2\u00a4\u00a3 software, to optimize performance for speed. Pat opens the software development environment, checks out the 1357 source files of SuperTool, and confidently begins the task. Although not familiar with SuperTool\u2019s code base, Pat infallibly knows which file to open, in which order, and what change to apply to each file. At the end of the day, the change, spanning parts of 23 different files, passes the regression tests without a glitch. Pat is hailed as a hero and promoted on the spot.Although this scenario describes a highly desirable situation, its realism may be challenged. Knowledge of technical implementation details of emergent concerns in software usually exists neither in programmers\u2019 heads, nor in technical manuals. Instead, it has to be obtained prior to performing a change to a program. This is usually done by navigating source code, possibly through the use of tools, such as grep [1], or through the cross-reference functionalities of integrated development environments. Unfortunately, the task of program navigation cannot be equated with a search for the mystical \u201ccore\u201d of a concern, around which dependent changes radiate. Because, in part, concerns in software are usually scattered and tangled [6], the search is more likely to take the form of a puzzle-solving activity, where different elements in a program are pieced together to form a sufficient understanding of a subset of the program\u2019s operations.", "num_citations": "16\n", "authors": ["108"]}
{"title": "Safe aspect composition\n", "abstract": " When di erent aspects 4] are composed, one must ensure that the resulting composition does not cause con icts. This problem appeared to be central to the work of the authors. The corresponding discussions that took place during the workshop led to a categorization of con icts relating to the composition of aspects.We thus present three general classes of con icts associated with aspect composition, and consider possible remedies. The rst kind of con icts, discussed in Sec. 2, is inherent, ie, it is the kind of con icts where a given combination of aspects should be rejected by the translation system. Section 3 deals with the situation where certain aspects should be combined but cannot| because of accidentally con icting characteristics of the implementation. Finally, as described in Sec. 4, aspect combinations may give rise to spurious con icts, where the combination is intended to work| and it would actually work at run-time| but the type check fails. In these cases we may have to choose between loss of reuse opportunities or loss of type-safety, or we must use a more powerful type analysis.", "num_citations": "16\n", "authors": ["108"]}
{"title": "Retrieving task-related clusters from change history\n", "abstract": " During software maintenance tasks, developers often spend an important amount of effort investigating source code. This effort can be reduced if tools are available to help developers navigate the source code effectively. For this purpose, we propose to search the change history of a software system to identify clusters of program elements related to a task. We evaluated the feasibility of this idea with an extensive historical analysis of change data. Our study evaluated to what extent change sets approximating tasks could have benefited from knowledge about clusters of past changes. A study of 3500 change sets for seven different systems and covering a cumulative time span of close to 12 years of development shows that less than 12% of the changes could have benefited from change clusters. We report on our observations on the factors that influence how we can use change clusters to guide program navigation.", "num_citations": "15\n", "authors": ["108"]}
{"title": "Managing concern interfaces\n", "abstract": " Programming languages provide various mechanisms to support information hiding. One problem with information hiding, however, is that providing a stable interface behind which to hide implementation details involves fixing in advance the services offered through the interface. We introduce a flexible approach to define and manage interfaces to achieve separation of concerns in evolving software. Our approach involves explicitly specifying interface and implementation classes for individual concerns, and automatically classifying implementation classes based on their relation to the interface. Our approach is supported by JMantlet, a tool that provides advanced interface management within an integrated development environment. We report on a case study of a large system that provides evidence that flexible interface management is desirable and adequately supported by our approach", "num_citations": "14\n", "authors": ["108"]}
{"title": "Tracking concerns in evolving source code: An empirical study\n", "abstract": " The association between the description of a concern (e.g., a feature) and the code that implements it is valuable information that can degrade as the code of a system evolves. We present a study of the evolution of the implementation of a concern in 33 versions of an open-source text editor. We represented the implementation of the concern using concern graphs, a model that was designed to be resilient to source code evolution. The study showed how the concern graph model supports tracking a concern's implementation in an evolving system, as well as inferring high-level past changes and assessing the stability of the concern's implementation", "num_citations": "14\n", "authors": ["108"]}
{"title": "Detecting inefficient API usage\n", "abstract": " Large software projects often rely on third-party libraries, made accessible through application programming interfaces (APIs). We have observed many cases where APIs are used in ways that are not efficient. We developed a technique to automatically detect inefficient API usage in software projects. The main hypothesis underlying the technique is that client code that imitates the behavior of a library method without calling it is likely not to use the library as efficiently as possible. In addition to warning developers of potentially inefficient API usage, our technique also indicates how to improve the use of the API. Application of the technique on Java open-source systems revealed many cases of inefficient API usage, and corresponding recommendations that led to code improvements.", "num_citations": "13\n", "authors": ["108"]}
{"title": "Program navigation analysis to support task-aware software development environments\n", "abstract": " Performing a software modification requires a developer to investigate a program to find and understand the code relevant to the modification task. Although standard program investigation tools can help developers in this activity, developers often get lost in the complex web of information available about a program. To address this problem we propose to use program navigation analysis, a technique to record and analyze the actions of a developer using a software development environment in order to infer the current task and the subset of a program relevant to this task. Our hypothesis is that we can use the results of program navigation analysis to dynamically configure the interface of a software development environment in a way that alleviates the problems of disorientation experienced by developers. In this paper, we define program navigation analysis and present an overview of its underpinnings, summarize\u00a0\u2026", "num_citations": "13\n", "authors": ["108"]}
{"title": "Sustainable software design\n", "abstract": " Although design plays a central role in software development, the information produced in this activity is often left to progressively evaporate as the result of software evolution, loss of artifacts, or the fading of related knowledge held by the development team. This paper introduces the concept of sustainability for software design, and calls for its integration into the existing catalog of design quality attributes. Applied to software design, sustainability conveys the idea that a particular set of design decisions and their rationale can be succinctly reflected in the host technology and/or described in documentation in a way that is checkable for conformance with the code and generally resistant to evaporation. The paper discusses the relation between sustainability and existing research areas in software engineering, and highlights future research challenges related to sustainable software design.", "num_citations": "12\n", "authors": ["108"]}
{"title": "Developer profiles for recommendation systems\n", "abstract": " Developer profiles are representations that capture the characteristics of a software developer, including software development knowledge, organizational information, and communication networks. In recommendation systems in software engineering, developer profiles can be used for personalizing recommendations and for recommending developers who can assist with a task. This chapter describes techniques for capturing, representing, storing, and using developer profiles.", "num_citations": "12\n", "authors": ["108"]}
{"title": "Reusing program investigation knowledge for code understanding\n", "abstract": " Software maintenance tasks typically involve an important amount of program investigation effort on the part of software developers. To what extent can we benefit from prior program investigation activities to decrease this effort? To investigate this question, we studied the revision history of two systems to determine how knowledge derived from prior investigation activities could have been reused to support other change tasks. Our initial investigation used a tool, ConcernDetector, that can recommend sets of program elements associated with a high-level concern when elements in the set overlap with elements currently being modified. We discovered that simple overlap-based techniques for retrieving prior investigation knowledge have important limitations, and that effective reuse of prior program investigation knowledge requires analyses that can partially infer the nature and intent of a task.", "num_citations": "9\n", "authors": ["108"]}
{"title": "Analyzing concerns using class member dependencies\n", "abstract": " Basic programming language elements, such as classes and methods, cannot always faithfully modularize all the concerns programmers might wish to express in a program [6]. Often, some concerns end up scattered amongst the various classes, and tangled within a particular class.Various mechanisms have been proposed to help developers modularize concerns that cannot readily be encapsulated within classes (eg, AspectJ\u00a2\u00a4\u00a3[1], and Hyper/J\u00a2\u00a4\u00a3[2]). These technologies typically allow concern modules to be integrated with a system at the declaration or use sites of class members. For instance, aspects in AspectJ can specify the introduction of a new field to a class (declaration site), or the addition of behavior before or after the body of a method gets executed (use site).", "num_citations": "8\n", "authors": ["108"]}
{"title": "An exploration of a lightweight means of concern separation\n", "abstract": " Different concerns which arise when developing a system, such as different features, often end up scattered and tangled in code bases. The scattering and tangling of concerns complicates the performance of many software engineering tasks. For example, the scattering of a feature across a set of source files complicates the task of making any change to that feature. To help reduce the scattering and tangling problems, several separation of concerns mechanisms have been proposed eg, Composition Filters 1, Aspect-oriented Programming 4, Hyperspaces 7.Separation of concerns mechanisms allow a developer to describe how a concern integrates composes with other concerns and other code. Different mechanisms provide different means of describing the composition, including different means of describing the join points of the composition| the points in the code where a concern is to be integrated. Since existing separation of concerns mechanisms are limited in the kinds of join points which can be specified ie, submethod join points are not possible, applying a separation of concerns mechanism to an existing system", "num_citations": "8\n", "authors": ["108"]}
{"title": "Evolving descriptions of scattered concerns\n", "abstract": " When performing a program evolution task, developers often encounter concerns whose implementations are scattered across multiple modules. When the use of aspect-oriented programming mechanisms is either not possible or is too costly, one way to alleviate the difficulties of locating and managing scattered concerns is by capturing knowledge about the code implementing the concerns in a descriptive artifact. Unfortunately, artifacts referring to source code quickly become obsolete as the source code changes. In this paper, we describe how we support the evolution of artifacts that refer to the implementation of concerns in a system by combining the ideas of low-level program abstractions, tolerance to inconsistencies, and specialized tool support for inconsistency management. We show how this approach allows a description of concerns in one version of a code base to be reused on a different version of the same code base.", "num_citations": "6\n", "authors": ["108"]}
{"title": "Lessons learned while migrating from Swing to JavaFX\n", "abstract": " We describe a case study of the migration of an interactive diagramming tool written in Java from the Swing graphical user interface framework to JavaFX. The outcome is presented as five lessons about the search for information when migrating software between major frameworks.", "num_citations": "5\n", "authors": ["108"]}
{"title": "The information gathering strategies of API learners\n", "abstract": " API users experience significant difficulties when learning how to use APIs, but little is known about the strategies used to overcome these difficulties, the motivation for each strategy, or the trade-offs between the strategies. To better understand the information seeking strategies of API users, we conducted a study in which 20 participants were asked to complete programming tasks using unfamiliar APIs, with the documentation of the APIs and the Web as learning resources. We observed that participants used one of three different strategies when seeking for information on how to use APIs: some were more inclined to using the Web, others preferred the documentation of the APIs, and others combined both the Web and the documentation. We present the characteristics, motivation, and trade-offs between these strategies, and suggests new ideas for documentation and tools to facilitate the information-seeking process of API learners.", "num_citations": "5\n", "authors": ["108"]}
{"title": "A qualitative study on project landscapes\n", "abstract": " When developers join a project, they find themselves in a new project landscape and must orient themselves quickly. To investigate the nature of this project landscape, and how we could help newcomers orient themselves, we have started an exploratory study using grounded theory. We primarily collect our data by interviewing experienced developers who recently joined ongoing projects. We are already seeing some patterns emerge. For example, it seems that newcomers find it more important to be able to experiment with the system early on than to have up-to-date and complete documentation.", "num_citations": "5\n", "authors": ["108"]}
{"title": "A study of program evolution involving scattered concerns\n", "abstract": " Before making a change to a system, software developers typically explore the source code to find and understand the subset relevant to their task. Software changes often involve code addressing different conceptually-related segments of the implementation (concerns), which can be scattered across multiple modules. These scattered concerns make it difficult to reason about the code relevant to a change. We carried out a study to investigate how developers discover and manage scattered concerns during a software evolution task, and the role that structural queries play during the investigation. The task we studied consists of a developer adding a feature to a 65kloc Java code base. The study involved eight subjects: four who were not briefed about scattered concerns, and four who were trained to use a concern-oriented investigation tool. Analysis of the navigation among the different program elements examined by the subjects during the task shows evidence that, independent of whether concernoriented tool support was available, the most successful subjects focused on specific concerns when planning their task, and used a high proportion of structural queries to investigate the code. In addition to the study results, this paper introduces two novel analyses: navigation graphs, which support the analysis of a subject\u2019s behavior when investigating source code, and variant analysis, which is used for evaluating the results of a program evolution task.", "num_citations": "5\n", "authors": ["108"]}
{"title": "Workshop on the Modeling and Analysis of Concerns in Software (MACS 2005)\n", "abstract": " This report is a summary of the Workshop on the Modeling and Analysis of Concerns in Software (MACS 2005) held at the 27th International Conference on Software Engineering (ICSE 2005). The main goal of the workshop was to bring together researchers and practitioners with interest in techniques for modeling and analyzing the realization of concerns in software systems to support software development and evolution. The workshop consisted of an interactive combination of presentations and discussions. The presentations and discussions were based on a collection of 16 short papers covering a wide range of approaches.", "num_citations": "4\n", "authors": ["108"]}
{"title": "Just-in-time concern modeling\n", "abstract": " In this position paper, we propose the notion of just-in-time concern modeling. As some concerns emerge late in the software life cycle and can be ephemeral, we argue that mechanisms should be available to capture descriptions of concerns as they emerge or become relevant. Based on our experience with the FEAT concern modeling and analysis tool, we highlight the essential characteristics, benefits, and pitfalls of just-in-time concern modeling at the source code level.", "num_citations": "3\n", "authors": ["108"]}
{"title": "Migrating a Static Analysis Tool to AspectJTM\n", "abstract": " Software design and programming techniques that provide explicit support for separating concerns are intended to help developers more easily express and evolve software systems. The degree to which these techniques can aid a software developer is dependent on the di culty of determining what the separable concerns are within a system.To gain a sense of the kinds of concerns which might be useful to separate in a system, we examined the source for the Jex static analysis tool, which extracts exception information from Java les 5]. To gain a sense of the process involved in actually separating a concern from an existing code base, we migrated Jex's Java code base to AspectJTM 7]. AspectJ provides aspect-oriented programming 3] support for Java.", "num_citations": "3\n", "authors": ["108"]}
{"title": "A detailed examination of the correlation between imports and failure-proneness of software components\n", "abstract": " Research has provided evidence that type usage in source files is correlated with the risk of failure of software components. Previous studies that investigated the correlation between type usage and component failure assigned equal blame to all the types imported by a component with a failure history, regardless of whether a type is used in the component, or associated to its failures. A failure-prone component may use a type, but it is not always the case that the use of this type has been responsible for any of its failures. To gain more insight about the correlation between type usage and component failure, we introduce the concept of a failure-associated type to represent the imported types referenced within methods fixed due to failures. We conducted two studies to investigate the tradeoffs between the equal-blame approach and the failure-associated type approach. Our results indicate that few of the types or\u00a0\u2026", "num_citations": "2\n", "authors": ["108"]}
{"title": "Context-sensitive ranking of dependencies for software navigation\n", "abstract": " Software navigation during change tasks requires developers to perform numerous search cycles to discover new elements related to their task. In a typical search cycle a developer selects an element of interest, triggers a search for its dependencies, inspects the list of results, and selects a result that appears to be relevant. We are interested in improving the efficiency of developers engaged in program navigation by automatically searching for all dependencies to or from elements already discovered, and continually providing the list of dependencies, ranked in decreasing order of likelihood to be related to the task. In this paper, we present a framework for the systematic evaluation of ranking algorithms based on multi-element contexts, and report on a preliminary experiment to assess the value of three ranking strategies for dependencies: using the topology of the dependency graph, textual similarity, or combination of both. Our results show that all three strategies significantly improve the probability of recommending relevant elements in many situations, but that no ranking strategy appears to be universally optimal.", "num_citations": "2\n", "authors": ["108"]}
{"title": "Tracking and assessing the evolution of scattered concerns\n", "abstract": " In this position paper, we describe how we document the implementation of scattered concerns by combining intensional descriptions of relations between program elements and their corresponding extensions for a specific version of a program. We show that this strategy allows us to automatically track the source code implementing a concern as it evolves and to assess the stability of a concern\u2019s implementation. We illustrate these benefits with results obtained from ongoing empirical studies of the evolution of scattered concerns.", "num_citations": "2\n", "authors": ["108"]}
{"title": "Separation of concerns and software components\n", "abstract": " Separation of concerns has always been at the core of modern software engineering. Recently, it was realized that some concerns do not always align with the traditional decomposition mechanisms, such as functions, classes, or components. Various mechanisms have been proposed to support alternative means for the modularization of concerns. After presenting a review of separation of concerns and the latest developments in the mechanisms supporting it, this report discusses the problems related to integrating separation of concerns technology into component-based software engineering.", "num_citations": "2\n", "authors": ["108"]}
{"title": "Generating Unit Tests for Documentation\n", "abstract": " Software projects capture redundant information in various kinds of artifacts, as specifications from the source code are also tested and documented. Such redundancy provides an opportunity to reduce development effort by supporting the joint generation of different types of artifact. We introduce a tool-supported technique, called DScribe, that allows developers to combine unit tests and documentation templates, and to invoke those templates to generate documentation and unit tests. DScribe supports the detection and replacement of outdated documentation, and the use of templates can encourage extensive test suites with a consistent style. Our evaluation of 835 specifications revealed that 85% were not tested or correctly documented, and DScribe could be used to automatically generate 97% of the tests and documentation. An additional study revealed that tests generated by DScribe are more focused and\u00a0\u2026", "num_citations": "1\n", "authors": ["108"]}
{"title": "Constructural software documentation\n", "abstract": " Software projects capture information in artifacts that include production code, test suites, and documentation. Because different artifacts serve different purposes, some artifacts can include redundant information, encoded in different formats. To mitigate this redundancy, we propose an approach to explicitly encode in unit tests information that will be automatically extracted and added to the documentation of the software. We implemented this approach in the form of an Eclipse plug-in that binds unit tests written with JUnit to the header comments of the tested methods.", "num_citations": "1\n", "authors": ["108"]}
{"title": "Eclipse technology exchange workshop (ETX2007)\n", "abstract": " The Eclipse platform is designed for building integrated development environments for object-oriented applications. The goal of the ETX workshop is to bring together researchers and practitioners to exchange ideas about potential new uses of Eclipse and how the core Eclipse technology can be leveraged, improved and/or extended for research and teaching projects.", "num_citations": "1\n", "authors": ["108"]}
{"title": "First international workshop on the modeling and analysis of concerns in software (MACS 2005)\n", "abstract": " Many software engineering activities are organized around the idea of concerns. Separation of concerns is a basic tenet of software engineering intended to facilitate the development and evolution of software systems. Unfortunately, separation of concerns is not always possible in practice, and concerns often end up scattered and tangled. The goal of the MACS workshop is to bring together researchers and practitioners with interest and experience in techniques for modeling and analyzing the realization of concerns in software systems.", "num_citations": "1\n", "authors": ["108"]}
{"title": "A representation for describing and analyzing concerns in source code\n", "abstract": " Existing approaches that are available to help software developers locate and manage the scattered implementation of concerns use a representation based on lines of source code. Because they do not explicitly express program structure, concern representations based on source code have inherent limitations when finding, describing and analyzing concerns. To address these problems, we are trying to find a concern representation that captures as close as possible the amount and precision level of information that software developers need to efficiently plan a change, and that supports queries that can provide this information. As a proposed solution, we introduced the Concern Graph representation that abstracts the implementation details of a concern and makes explicit the relationships between different parts of the concern. The Concern Graph abstraction has also been designed to allow an obvious and\u00a0\u2026", "num_citations": "1\n", "authors": ["108"]}