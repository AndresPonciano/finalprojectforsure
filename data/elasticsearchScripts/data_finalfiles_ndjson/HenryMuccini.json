{"title": "Software testing of mobile applications: Challenges and future research directions\n", "abstract": " While mobile applications are becoming so extraordinarily adopted, it is still unclear if they deserve any specific testing approach for their verification and validation. This paper wants to investigate new research directions on mobile applications testing automation, by answering three research questions: (RQ1) are mobile applications (so) different from traditional ones, so to require different and specialized new testing techniques?, (RQ2) what are the new challenges and research directions on testing mobile applications?, and (RQ3) which is the role automation may play in testing mobile applications?. We answer those questions by analyzing the current state of the art in mobile applications development and testing, and by proposing our view on the topic.", "num_citations": "279\n", "authors": ["1397"]}
{"title": "Towards testing product line architectures\n", "abstract": " A product line architecture is a single specification capturing the overall architecture of a series of closely related products. Its structure consists of a set of mandatory elements and a set of variation points. Whereas mandatory elements are part of the architecture of every product in the product line architecture, variation points precisely define the dimensions along which the architectures of individual products differ from each other.The increased use of product line architectures in today's software development projects poses several challenges for existing testing techniques. In this paper we discuss those challenges and discuss what we believe are opportunities for addressing them.", "num_citations": "116\n", "authors": ["1397"]}
{"title": "Charmy: A framework for designing and verifying architectural specifications\n", "abstract": " Introduced in the early stages of software development, the Charmy framework assists the software architect in making and evaluating architectural choices. Rarely, the software architecture of a system can be established once and forever. Most likely poorly defined and understood architectural constraints and requirements force the software architect to accept ambiguities and move forward to the construction of a suboptimal software architecture. Charmy aims to provide an easy and practical tool for supporting the iterative modeling and evaluation of software architectures. From an UML-based architectural design, an executable prototype is automatically created. Charmy simulation and model checking features help in understanding the functioning of the system and discovering potential inconsistencies of the design. When a satisfactory and stable software architecture is reached, Java code conforming to\u00a0\u2026", "num_citations": "79\n", "authors": ["1397"]}
{"title": "A model-driven engineering framework for architecting and analysing wireless sensor networks\n", "abstract": " A Wireless Sensor Network (WSN) is composed of distributed sensors with limited processing capabilities and energy restrictions. These unique attributes pose new challenges amongst which prolonging the WSN lifetime is one of the most important. Challenges are often tackled by a code-and-fix process that relies on low-level hardware and software information. Recently, the need of abstracting an implementation view into an architectural design is getting more realized. A clear separation of concerns is needed since hardware and software aspects are locked and tied down to specific types of nodes, hampering the possibility of reuse across projects and organizations. This means that exploiting the right level of abstraction, and keeping explicit (and separated) software and hardware architectural details will surely ease developers' job. In this paper we propose a modeling framework that allows developers to\u00a0\u2026", "num_citations": "67\n", "authors": ["1397"]}
{"title": "Software architecture-based regression testing\n", "abstract": " Software architectures are becoming centric to the development of quality software systems, being the first concrete model of the software system and the base to guide the implementation of software systems. When architecting dependable systems, in addition to improving system dependability by means of construction (fault-tolerant and redundant mechanisms, for instance), it is also important to evaluate, and thereby confirm, system dependability. There are many different approaches for evaluating system dependability, and testing has been always an important one, being fault removal one of the means to achieve dependable systems.Previous work on software architecture-based testing has shown it is possible to apply conformance testing techniques to yield some confidence on the implemented system conformance to expected, architecture-level, behaviors.This work explores how regression testing can be\u00a0\u2026", "num_citations": "66\n", "authors": ["1397"]}
{"title": "Automated check of architectural models consistency using SPIN\n", "abstract": " In recent years the necessity for handling different aspects of the system separately has introduced the need to represent SA (software architectures) from different viewpoints. In particular, behavioral views are recognized to be one of the most attractive features in the SA description, and in practical contexts, state diagrams and scenarios are the most widely used tools to model this view. Although very expressive, this approach has two drawbacks: system specification incompleteness and view consistency. Our work can be put in this context with the aim of managing incompleteness and checking view conformance: we propose the use of state diagrams and scenario models for representing system dynamics at the architectural level; they can be incomplete and we want to prove that they describe, from different viewpoints, the same system behavior. To reach this goal, we use the SPIN model checker and we\u00a0\u2026", "num_citations": "63\n", "authors": ["1397"]}
{"title": "Towards software architecture-based regression testing\n", "abstract": " When architecting dependable systems, in addition to improving system dependability by means of construction (fault-tolerant and redundant mechanisms, for instance), it is also important to evaluate, and thereby confirm, system dependability. There are many different approaches for evaluating system dependability, and testing always has been an important one.Previous work on software architecture testing has shown it is possible to apply conformance-testing techniques to yield confidence that the behavior of an implemented system conforms to the expected behavior of the software architecture, specified with Architecture Description Languages.In this work, we explore how regression testing can be systematically applied at the software architecture level in order to reduce the cost of retesting modified systems, and also to assess the regression testability of the evolved system. We consider assessing both \"top\u00a0\u2026", "num_citations": "62\n", "authors": ["1397"]}
{"title": "Collaborative model-driven software engineering: a classification framework and a research map\n", "abstract": " Context: Collaborative Model-Driven Software Engineering (MDSE) consists of methods and techniques where multiple stakeholders manage, collaborate, and are aware of each others' work on shared models. Objective: Collaborative MDSE is attracting research efforts from different areas, resulting in a variegated scientific body of knowledge. This study aims at identifying, classifying, and understanding existing collaborative MDSE approaches. Method: We designed and conducted a systematic mapping study. Starting from over 3,000 potentially relevant studies, we applied a rigorous selection procedure resulting in 106 selected papers, further clustered into 48 primary studies along a time span of 19 years. We rigorously defined and applied a classification framework and extracted key information from each selected study for subsequent analysis. Results: Our analysis revealed the following main fidings: (i\u00a0\u2026", "num_citations": "60\n", "authors": ["1397"]}
{"title": "Detecting implied scenarios analyzing non-local branching choices\n", "abstract": " Scenarios are powerful tools to model and analyze software systems. However, since they do not provide a complete description of the system, but just some possible execution paths, they are usually integrated with state machines. State machines may be extracted from scenarios using a synthesis process. We could expect that the synthesized state machine model is \u201cequivalent\u201d to the original scenario specification. Instead, it has been proven that it does not always hold, and state machines may introduce unexpected behaviors, called implied scenarios. This paper proves that there is a strict correlation between implied scenarios and non-local branching choices. Based on this result, we propose an approach to identify implied scenarios in High-Level Message Sequence Chart specifications and its application to some specifications. We finally highlight advantages with respect to existent approaches.", "num_citations": "58\n", "authors": ["1397"]}
{"title": "Developing next generation ADLs through MDE techniques\n", "abstract": " Despite the flourishing of languages to describe software architectures, existing Architecture Description Languages (ADLs) are still far away from what it is actually needed. In fact, while they support a traditional perception of a Software Architecture (SA) as a set of constituting elements (such as components, connectors and interfaces), they mostly fail to capture multiple stakeholders concerns and their design decisions that represent a broader view of SA being accepted today. Next generation ADLs must cope with various and ever evolving stakeholder concerns by employing semantic extension mechanisms. In this paper we present a framework, called byADL - Build Your ADL, for developing a new generation of ADLs. byADL exploits model-driven techniques that provide the needed technologies to allow a software architect, starting from existing ADLs, to define its own new generation ADL by: i) adding domain\u00a0\u2026", "num_citations": "55\n", "authors": ["1397"]}
{"title": "Iot architectural styles\n", "abstract": " IoT components are becoming more and more ubiquitous. Thus, the necessity of architecting IoT applications is bringing a substantial attention towards software engineering community. On this occasion, different styles and patterns can facilitate shaping the IoT architectural characteristics. This study aims at defining, identifying, classifying, and re-designing a class of IoT styles and patterns at the architectural level. Conforming a systematic mapping study (SMS) selection procedure, we picked out 63 papers among over 2,300 candidate studies. To this end, we applied a rigorous classification and extraction framework to select and analyze the most influential domain-related information. Our analysis revealed the following main findings: (i) facing by various architectural styles that attempted to address various aspects of IoT systems, cloud and fog are discerned as their most important components. (ii\u00a0\u2026", "num_citations": "51\n", "authors": ["1397"]}
{"title": "A model-driven approach to automate the propagation of changes among Architecture Description Languages\n", "abstract": " As it is widely recognized, a universal notation accepted by any software architect cannot exist. This caused a proliferation of architecture description languages (ADLs) each focussing on a specific application domain, analysis type, or modelling environment, and with its own specific notations and tools. Therefore, the production of a software architecture description often requires the use of multiple ADLs, each satisfying some stakeholder\u2019s concerns. When dealing with multiple notations, suitable techniques are required in order to keep models in a consistent state. Several solutions have been proposed so far but they lack in convergence and scalability. In this paper, we propose a convergent change propagation approach between multiple architectural languages. The approach is generic since it depends neither on the notations to synchronize nor on their corresponding models. It is implemented within\u00a0\u2026", "num_citations": "51\n", "authors": ["1397"]}
{"title": "Caps: Architecture description of situational aware cyber physical systems\n", "abstract": " This paper proposes CAPS, an architecture-driven modeling framework for the development of Situational Aware Cyber-Physical Systems. Situational Awareness involves being aware of what ishappening in the surroundings, and using this information to decide and act. It has been recognized as a critical, yet often elusive, foundation for successful decision-making in complex systems. With the advent of cyber-physical systems (CPS), situational awareness is playing an increasingly important role especially in crowd and fleets management, infrastructure monitoring, and smart city applications. While specializing cyber physical systems, Situational Aware CPS requires the continuous monitoring of environmental conditions and events with respect to time and space. New architectural concerns arise, especially related to the sense, compute & communication paradigm, the use of domain-specific hardware\u00a0\u2026", "num_citations": "47\n", "authors": ["1397"]}
{"title": "Charmy: an extensible tool for architectural analysis\n", "abstract": " CHARMY is a framework for designing and validating architectural specifications. In the early stages of the software development process, the CHARMY framework assists the software architect in the design and validation phases. To increase its usability in an industrial context, the tool allows the use of UML-like notations to graphically design the system. Once the design is done, a formal prototype is automatically created for simulation and analysis purposes. The framework provides extensibility mechanisms to enable the introduction of new design and analysis features.", "num_citations": "45\n", "authors": ["1397"]}
{"title": "Systematic Testing of Software Architectures in the C2 style\n", "abstract": " The topic of software architecture (SA) based testing has recently raised some interest. Recent work on the topic has used the SA as a reference model for code conformance testing, to check if an implementation fulfills (conforms to) its specification at the SA level. In this context, on previous papers, we have analyzed: i) how suitable test cases can be \u201dselected\u201d from the SA specification and ii) how they may be \u201drefined\u201d into concrete tests executable at the code level. While the selection stage has been done systematically, the refinement step has been left to be done manually, based on the software engineer knowl- edge on how to map \u201dabstract values of the specification to the concrete values of the implementation\u201d. In this paper, we extend previous approaches, by pro- viding a systematic way to perform the refinement step. We show how choos- ing a specific architectural style, which supports\u00a0\u2026", "num_citations": "42\n", "authors": ["1397"]}
{"title": "TeStor: Deriving Test Sequences from Model-Based Specifications\n", "abstract": " The dependability analysis of a component-based system may be driven by the components/system implementation or by the model-based specification provided prior to or together with the implementation. In particular, model-based specifications of a component-based system allows to explicitly model the structure and behavior of components and their integration, while model-based testing allows to derive test sequences which can be successively refined into test cases and then run onto the system implementation.               Several techniques have been proposed so far to allow model-based testing. However, very few of them show certain characteristics which are peculiar for use in industrial contexts. We here describe TeStor, a TEst Sequence generaTOR algorithm which allows to extract test sequences from both state machine and scenario diagrams. We detail the algorithm, we apply it to a system\u00a0\u2026", "num_citations": "39\n", "authors": ["1397"]}
{"title": "Towards a collaborative framework for the design and development of data-intensive mobile applications\n", "abstract": " Guidelines and best practices on how to design and develop mobile applications are being periodically released by mobile OS vendors, mobile developers, and researchers. Still, a framework that collects and integrates them in a simple, holistic, and automated approach is missing.", "num_citations": "36\n", "authors": ["1397"]}
{"title": "On the composition and reuse of viewpoints across architecture frameworks\n", "abstract": " A central aspect of architecting is architecture description. Architecture descriptions take many forms and serve many purposes throughout the life cycle of development, operation and maintenance activities. The use of multiple views -- diverse representations for distinct audiences and uses -- has been a major tenet of architecture description since the earliest work in software architecture. This tenet has been codified in various ways. Most practising software architects must operate within the confines of a prescribed architecture framework (AF) or architecture description language (ADL) as dictated by their organization or client. Current AFs and ADLs are defined with varying degrees of rigour and offer varying levels of tool support, furthermore, these resources are often closed, making it difficult for the architect to tailor a representational solution to the specific challenges of the project at hand. In this paper we\u00a0\u2026", "num_citations": "35\n", "authors": ["1397"]}
{"title": "Self-adaptive IoT architectures: An emergency handling case study\n", "abstract": " Along with the rapid growth of IoT technologies and devices, their solutions are currently being applied on various domains such as health-care, transportation and agriculture, but mainly on crowd monitoring and emergency handling. The latter is a safety critical IoT system based on collecting and analyzing the real-time data to perform proper actuation. In order to engineer such a high quality IoT application, a proper software architecture should be designed. In order for the software architecture to be able to optimize critical requirements such as fault-tolerance, performance and energy consumption, it ought to: i) adapt itself to real-time environment transformation, ii) be designed in a proper level of elements distribution. In this paper, we critically analyze a set of IoT distribution and self-adaptation patterns to identify their suitable architectural combinations. Further, we use our IoT modeling framework (CAPS) to\u00a0\u2026", "num_citations": "34\n", "authors": ["1397"]}
{"title": "A study on MDE approaches for engineering wireless sensor networks\n", "abstract": " Model-Driven Engineering (MDE) can be considered as the right tool to reduce the complexity of Wireless Sensor Network (WSN) development through its principles of abstraction, separation of concerns, reuse and automation. In this paper we present the results of a systematic mapping study we performed for providing an organized view of existing MDE approaches for designing WSNs. A total number of 780 studies were analysed, among them, we selected 16 papers as primary studies relevant for review. We setup a comparison framework for these studies, and classified them based on a set of common parameters. The main objective of our research is to give an overview about the state-of-the-art of MDE approaches dedicated to WSN design, and finally, discuss emerging challenges that have to be considered in future MDE approaches for engineering WSNs.", "num_citations": "33\n", "authors": ["1397"]}
{"title": "Realizing architecture frameworks through megamodelling techniques\n", "abstract": " Most practising software architects operate within an architecture framework which is a coordinated set of viewpoints, models and notations prescribed for them. Whereas architecture frameworks are defined to varying degrees of rigour and offer varying levels of tool support, they tend to be closed: constituent elements are defined in different non-standard ways, they are not re-usable, and the creation of other frameworks requires a complete rework.", "num_citations": "33\n", "authors": ["1397"]}
{"title": "Model-checking plus testing: from software architecture analysis to code testing\n", "abstract": " Software Model-Checking and Testing are some of the most used techniques to analyze software systems and identify hidden faults. While software model-checking allows for an exhaustive and automatic analysis of the system expressed through a\u00a0model, software testing is based on a\u00a0clever selection of \u201crelevant\u201d test cases, which may be manually or automatically run over the system.               In this paper we analyze how those two analysis techniques may be integrated in a\u00a0specific context, where a\u00a0Software Architecture (SA) specification of the system is available, model-checking techniques are used to validate the SA model conformance with respect to selected properties, while testing techniques are used to validate the implementation conformance to the SA model.               The results of this research are applied to an SDH Telecommunication system architecture designed by Siemens CNX.", "num_citations": "31\n", "authors": ["1397"]}
{"title": "A study on group decision-making in software architecture\n", "abstract": " When architecting software systems, architects (with the contribution of other stakeholders) make several design decisions. These decisions could be related to the selection of the right components and connectors, the architectural style to be used, the distribution of various components, the deployment of software components into hardware devices, etc. Many methods have been proposed by the research community to help documenting several aspects of architectural design decisions including design alternatives, stakeholder concerns, decisions and the rationale for making such decisions and enhancing the decision-making process. Still, very little has been done to truly understand how architectural design decisions are made by group of practitioners, what information is documented, the tools used for helping documenting and how conflicts are managed. This study, by looking at principles and techniques for\u00a0\u2026", "num_citations": "29\n", "authors": ["1397"]}
{"title": "Architecting Fault-tolerant Component-based Systems: from requirements to testing\n", "abstract": " Fault tolerance is one of the most important means to avoid service failure in the presence of faults, so to guarantee they will not interrupt the service delivery. Software testing, instead, is one of the major fault removal techniques, realized in order to detect and remove software faults during software development so that they will not be present in the final product.This paper shows how fault tolerance and testing can be used to validate component-based systems. Fault tolerance requirements guide the construction of a fault-tolerant architecture, which is successively validated with respect to requirements and submitted to testing. The theory is applied over a mining control system running example.", "num_citations": "28\n", "authors": ["1397"]}
{"title": "Path loss effect on energy consumption in a wsn\n", "abstract": " Energy consumption of nodes is a crucial factor that constrains the networks life time for Wireless Sensor Networks (WSNs). WSNs are composed of small sensors equipped with low-power devices, and have limited battery power supply. The main concern in existing architectural and optimisation studies is to prolong the network lifetime. The lifetime of the sensor nodes is affected by different components such as the microprocessor, the sensing module and the wireless transmitter/receiver. The existing works mainly consider these components to decide on best deployment, topology, protocols and so on. Recent studies have also considered the monitoring and evaluation of the path loss caused by environmental factors. Path loss is always considered in isolation from the higher layers such as application and network. It is necessary to combine path loss computations used in physical layer, with information from\u00a0\u2026", "num_citations": "27\n", "authors": ["1397"]}
{"title": "A preliminary study on architecting cyber-physical systems\n", "abstract": " Cyber-physical systems (CPSs) are deemed as the key enablers of next generation applications. Needless to say, the design, verification and validation of cyber-physical systems reaches unprecedented levels of complexity, specially due to their sensibility to safety issues. Under this perspective, leveraging architectural descriptions to reason on a CPS seems to be the obvious way to manage its inherent complexity.", "num_citations": "26\n", "authors": ["1397"]}
{"title": "Crowd and laboratory testing, can they co-exist? An exploratory study\n", "abstract": " Crowd testing has gained a great attention in recent years, for its cost-effectiveness, impartiality, diversity, and high device and configuration coverage. Still, a number of challenges hamper its full success, such as lack of standards, limited information on critical features coverage, duplicate defect management, inappropriate reword mechanisms. Our intuition is that combining crowd testing with (a more traditional) laboratory testing, may compensate each other limitations. In order to explore how practitioners look at this possibility, we run a survey with crowd testers to understand their perception on this matter. Preliminary results are illustrated in this work.", "num_citations": "23\n", "authors": ["1397"]}
{"title": "Supporting architectural design decisions evolution through model driven engineering\n", "abstract": " Architectural design decisions (i.e., those decisions made when architecting software systems) are considered an essential piece of knowledge to be carefully documented and maintained. As any other artifact, architectural design decisions may evolve, having an impact on other design decisions, or on related artifacts (like requirements and architectural elements). It is therefore important to document and analyze the impact of an evolving decision on other related decisions or artifacts. In this work we propose an approach based on a notation-independent metamodel that becomes a means for systematically defining traceability links, enabling inter-decision and extra-decision evolution impact analysis. The purpose of such an analysis is to check the presence of inconsistencies that may occur during evolution. An Eclipse plugin has been realized to implement the approach.", "num_citations": "23\n", "authors": ["1397"]}
{"title": "Reasoning about software architecture-based regression testing through a case study\n", "abstract": " Two main issues need to be covered when dealing with the dependability of component-based systems: quality assurance of reusable software components and quality assurance of the assembled component-based system. By focussing on the assembly, a software architecture specification of a component-based system allows to explicitly model the structure and required system behavior by specifying how components and connectors are intended to interact. Software architecture-based conformance testing techniques can yield confidence on the implementation conformance to expected structural and behavioral properties as specified in the architectural models. In this paper we explore software architecture-based regression testing methods that enable reuse of earlier saved results to test if a different assembly of components conforms to the evolved software architecture. The approach is presented through a\u00a0\u2026", "num_citations": "23\n", "authors": ["1397"]}
{"title": "An architecture framework for modelling and simulation of situational-aware cyber-physical systems\n", "abstract": " Situational Aware (SiA) Cyber-physical systems (CPS) harmoniously integrate computational and physical components to being aware of what is happening in the surroundings and using this information to decide and act. Architecture description of SiA-CPS can be a valuable tool to reason about the selected solutions, and to enable code generation and simulation. This paper presents an architecture framework that automatically generates from a SiA-CPS architecture description, an executable code used to simulate the architecture model and evaluate it in terms of data traffic load, battery level and energy consumptions. The framework makes use of a model transformation approach where, three SiA-CPS domain-specific modeling views are automatically transformed into the input language of CupCarbon, an open source tool supporting the simulation of sensor network architectures.", "num_citations": "22\n", "authors": ["1397"]}
{"title": "Model-driven techniques to enhance architectural languages interoperability\n", "abstract": " The current practice of software architecture modeling and analysis would benefit of using different architectural languages, each specialized on a particular view and each enabling specific analysis. Thus, it is fundamental to pursue architectural language interoperability. An approach for enabling interoperability consists in defining a transformation from each single notation to a pivot language, and vice versa. When the pivot assumes the form of a small and abstract kernel, extension mechanisms are required to compensate the loss of information. The aim of this paper is to enhance architectural languages interoperability by means of hierarchies of pivot languages obtained by systematically extending a root pivot language. Model-driven techniques are employed to support the creation and the management of such hierarchies and to realize the interoperability by means of model transformations. Even\u00a0\u2026", "num_citations": "22\n", "authors": ["1397"]}
{"title": "A data-modelling approach to web application synthesis\n", "abstract": " Most web applications are data-intensive, i.e. they rely heavily on dynamic contents usually stored in databases. Website design and maintenance can greatly benefit from conceptual descriptions of both data and hypermedia aspects, i.e. those design dimensions which distinguish this application class: the data upon which the content is based, the way dynamic contents are composed together to form pages, and how pages are linked together in order to move across the application content. The paper proposes Webile, a visual Domain-Specific Language based on UML, which enables a model-driven approach to high-level specification of web applications. In contrast with other approaches, Webile exploits the UML meta-model architecture by serialising the specifications in the XMI interchange format. This representation provides interoperability amongst different operative platforms and enables an XSL\u00a0\u2026", "num_citations": "20\n", "authors": ["1397"]}
{"title": "Caps: a tool for architecting situational-aware cyber-physical systems\n", "abstract": " Situational Aware (SiA) Cyber-physical systems(CPS) harmoniously integrate computational and physical components to being aware of what is happening in the surroundings, and using this information to decide and act. In this tool demo, we present our architecture-driven modeling tool named CAPS. This tool enables architects, system engineers, and cyber-physical space designers to describe the software architecture, hardware configuration, and physical space views for a situational aware CPS, respectively.", "num_citations": "19\n", "authors": ["1397"]}
{"title": "Suitability of software architecture decision making methods for group decisions\n", "abstract": " Software architecture design decisions are central to the architecting process. Hence, the software architecture community has been constantly striving towards making the decision-making process robust and reliable to create high-quality architectures. Surveys of practitioners has demonstrated that most decisions made by them are group decisions. Hence, for any tool or method to be useful to them, it must include provision for making group decisions.               In this paper we analyse if and how current software architecture decision-making techniques support Group Decision Making (GDM). We use an evaluation framework with eight criteria, identified by the GDM community, to evaluate selected SA decision-making techniques in order to check their adequacy and suitability to support group decisions. As per our analysis, most of the selected methods in their current form are not yet fully suitable for group\u00a0\u2026", "num_citations": "19\n", "authors": ["1397"]}
{"title": "Using model differencing for architecture-level regression testing\n", "abstract": " Regression testing can be systematically applied at the software architecture level in order to reduce the cost of retesting modified systems, and also to assess the regression testability of the evolved system. With the advent of model-based specification and analysis of software architectures, regression testing at the architectural level can be handled by analyzing how the architectural model evolves when moving from an initial to a subsequent version. This paper analyzes how model differencing, a recent research topic in the model-based community, can be employed for implementing model-based architecture-level regression testing.", "num_citations": "19\n", "authors": ["1397"]}
{"title": "Fault-tolerant iot\n", "abstract": " A failure may occur at all architectural levels of the Internet of Things (IoT) applications: sensor and actuator nodes can be missed, network links can be down, and processing and storage components can fail to perform properly. That is the reason for which fault-tolerance (FT) has become a crucial concern for IoT systems.                 Our study aims at identifying and classifying the existing FT mechanisms that can tolerate the IoT systems failure. In line with a systematic mapping study selection procedure, we picked out 60 papers among over 2300 candidate studies. To this end, we applied a rigorous classification and extraction framework to select and analyze the most influential domain-related information. Our analysis revealed the following main findings: (i) whilst researchers tend to study fault-tolerant IoT (FT-IoT) in cloud level only, several studies extend the application to fog and edge computing; (ii\u00a0\u2026", "num_citations": "18\n", "authors": ["1397"]}
{"title": "Group decision-making in software architecture: A study on industrial practices\n", "abstract": " ContextA Software Architecture results from a comprehensive process in which several stakeholders deliberate upon the key requirements, issues, solutions and make architectural design decisions. Literature shows that most architectural decisions, in practice, are made in groups. Still, there is a limited understanding of industrial group decision-making practices in software architecture and the challenges that software architecture groups face.ObjectiveOur study, by drawing inspiration from group decision-making theories and models, aims at understanding (i) Existing decision-making practices in software architecture groups (ii) the comparison between practice and theory, (iii) the challenges that the groups face, and (iv) the satisfaction of group members with various aspects of Group Decision Making.MethodThe study has been conducted through a questionnaire-based survey. 35 practitioners participated in\u00a0\u2026", "num_citations": "18\n", "authors": ["1397"]}
{"title": "Envisioning the future of collaborative model-driven software engineering\n", "abstract": " The adoption of Model-driven Software Engineering (MDSE) to develop complex software systems in application domains like automotive and aerospace is being supported by the maturation of model-driven platforms and tools. However, empirical studies show that a wider adoption of MDSE technologies is still an issue. One limiting factor is related to the limited support for collaborative MDSE. This paper reflects on research directions, challenges, and opportunities of collaborative MDSE.", "num_citations": "16\n", "authors": ["1397"]}
{"title": "Checking consistency between architectural models using SPIN\n", "abstract": " Requirements and Software Architectures are strictly related but only a little attention has been paid to their integration. What we propose in this paper is an approach to i) trace coordination requirements from their definition to the low level specification and ii) validate the architectural dynamic model with respect to these coordination requirements.", "num_citations": "16\n", "authors": ["1397"]}
{"title": "Coordination models and software architectures in a unified software development process\n", "abstract": " Coordination models and Software Architectures (SAs) have been recognized as valid tools to manage complex distributed systems. Coordination models and languages provide a specification level description of processes interaction, separating control issues from the computational oncerns. Software Architectures provide a high level description of software components interactions designing applications as sets of autonomous, decoupled components. In this work we are going to present how Coordination models and SA can be linked together and how they can be integrated in a UML-based software development process...", "num_citations": "16\n", "authors": ["1397"]}
{"title": "CAPSim: Simulation and Code Generation based on the CAPS\n", "abstract": " Situational Aware (SiA) Cyber-Physical Systems (CPS) harmoniously integrate computational and physical parts for being aware of what is happening in the surroundings, and utilizing this data to decide and act accordingly. In this tool demo, we present our architecture-driven simulating tool named CAPSim. This tool enables cyber-physical systems designers and architects to simulate the software architecture, hardware conffiguration, and physical space views for a situational aware CPS, for being able to evaluate the energy consumption and data traffic under different conditions.", "num_citations": "15\n", "authors": ["1397"]}
{"title": "Applying a network flow model to quick and safe evacuation of people from a building: a real case.\n", "abstract": " We present a computational component that allows to evaluate the minimum time necessary to evacuate people from a place (eg, a public building). The space and time dimension are discretized according to metrics and models in literature. The component formulates and solves a linearized, time-indexed flow problem [3] on a network that represents feasible movements of people monitored at a suitable frequency. This computational component is the core part of an IoT infrastructure aimed at monitoring crowds in public spaces for planning evacuation paths. The CPU time to solve the model is compliant with real-time use. An application of the algorithm to a real location with real data is described, and diverse uses of the methodology are presented.", "num_citations": "14\n", "authors": ["1397"]}
{"title": "Dually: Putting in synergy UML 2.0 and ADLs\n", "abstract": " Many formal languages have been proposed so far to describe software architectures (SA), but only very few of them are still supported and used in practical contexts. Many UML profiles and extensions have been provided when UML became a standard, in order to model as much as possible architectural concepts. They allow for an easy integration in industrial processes, however, different analysis techniques and domains still require different notations. In fact, since different communities require different information to be put into a diagram, depending on which architectural design aspects should be represented and analyzed, the idea of an unified UML language for SA is not adequate. Building on these considerations, we propose DUALLY, a core set of UML concepts, well suited for SA modeling, together with a framework which provides extensibility mechanisms to adapt the initial notation, in order to meet\u00a0\u2026", "num_citations": "14\n", "authors": ["1397"]}
{"title": "Protocol for a systematic mapping study on collaborative model-driven software engineering\n", "abstract": " Nowadays, collaborative modeling performed by multiple stakeholders is gaining a growing interest in both academia and practice. However, it poses a set of research challenges, such as large and complex models management, support for multi-user modeling environments, and synchronization mechanisms like models migration and merging, conflicts management, models versioning and rollback support. A body of knowledge in the scientific literature about collaborative model-driven software engineering (MDSE) exists. Still, those studies are scattered across different independent research areas, such as software engineering, model-driven engineering languages and systems, model integrated computing, etc., and a study classifying and comparing the various approaches and methods for collaborative MDSE is still missing. Under this perspective, a systematic mapping study (SMS) can help researchers and practitioners in (i) having a complete, comprehensive and valid picture of the state of the art about collaborative MDSE, and (ii) identifying potential gaps in current research and future research directions.", "num_citations": "13\n", "authors": ["1397"]}
{"title": "Dually: A framework for architectural languages and tools interoperability\n", "abstract": " Nowadays different notations for architectural modeling have been proposed, each one focussing on a specific application domain, analysis type, or modeling environment. No effective interoperability is possible to date. DUALLY is an automated framework that aims to offer an answer to this need allowing architectural languages and tools interoperability. DUALLY has been implemented as an Eclipse plugin and it is based on model transformation techniques. This demonstration paper shows DUALLY by applying its approach to two outstanding architectural description languages.", "num_citations": "13\n", "authors": ["1397"]}
{"title": "A machine learning-driven approach for proactive decision making in adaptive architectures\n", "abstract": " Self-adaptation is nowadays considered to be the best solution to dynamically reconfigure a system in the occurrence of deviations from the expected quality of service (QoS) parameters. However, data- and event-driven systems, such as IoT applications, impose new heterogeneity, interoperability, and distribution issues, that make uncertainty on the QoS stability even harder. Typical adaption techniques make use of reactive approaches, an after-the-fact adaptation that starts when the system deviates from the expected QoS parameters. What we envision is instead a proactive approach to anticipate the changes before the event of a QoS deviation. More specifically, we propose IoTArchML, a machine learning-driven approach for decision making in aiding proactive architectural adaptation of IoT system. The approach i) continuously monitors the QoS parameters; ii) predicts, based on historical data, possible\u00a0\u2026", "num_citations": "12\n", "authors": ["1397"]}
{"title": "A model-based method for seamless web and mobile experience\n", "abstract": " Consumer-centered software applications nowadays are required to be available both as mobile and desktop versions. However, the app design is frequently made only for one of the two (ie, mobile first or web first) while missing an appropriate design for the other (which, in turn, simply mimics the interaction of the first one). This results into poor quality of the interaction on one or the other platform. Current solutions would require different designs, to be realized through different design methods and tools, and that may require to double development and maintenance costs.", "num_citations": "12\n", "authors": ["1397"]}
{"title": "Software architectures and coordination models\n", "abstract": " Coordination models and Software Architectures are strictly related but only a little attention has been paid to their integration. What we propose in this paper is an approach to trace coordination requirements from their definition to the low level specification. The UML Unified Process is extended to gain this objective and the theory is applied to a case study.", "num_citations": "12\n", "authors": ["1397"]}
{"title": "An iot software architecture for an evacuable building architecture\n", "abstract": " This paper presents a computational component designed to improve and evaluate emergency handling plans. In real-time, the component operates as the core of an Internet of Things (IoT) infrastructure aimed at crowd monitoring and optimum evacuation paths planning. In this case, a software architecture facilitates achieving the minimum time necessary to evacuate people from a building. In design-time, the component helps discovering the optimal building dimensions for a safe emergency evacuation, even before (re-) construction of a building. The space and time dimension are discretized according to metrics and models in literature. The component formulates and solves a linearized, time-indexed flow problem on a network that represents feasible movements of people at a suitable frequency. The CPU time to solve the model is compliant with real-time use. The application of the model to a real location with real data testifies the model capability to optimize the safety standards by small changes in the building dimensions, and guarantees an optimal emergency evacuation performance.", "num_citations": "11\n", "authors": ["1397"]}
{"title": "Adaptation for situational-aware cyber-physical systems driven by energy consumption and human safety\n", "abstract": " Situational Aware cyber-physical systems must be aware of its surroundings and use this information to decide and act accordingly. Architectural decisions will be appreciated if they can preserve architecture qualities along with human satisfaction under different situations. The CAPS environment has valuable frameworks to reason about the possible architecture adaptations, and to enable code generation and simulation for these adaptations as well. This paper aims to evaluate the architecture developed using CAPS environment, in terms of both the architecture quality, represented by computing the energy consumption, and human satisfaction, represented by computing the human safety. This paper will use an approach that helps in determining the architecture adaptation to be applied at a given situation, preserving energy consumption and human safety. The architecture evaluation and adaptation strategies\u00a0\u2026", "num_citations": "11\n", "authors": ["1397"]}
{"title": "Enhancing architecture design decisions evolution with group decision making principles\n", "abstract": " In order to build resilient systems, robust architectures are needed. The software architecture community clearly recognizes that robust architectures come from a robust decision-making process. The community also acknowledges that software architecture decision making is not an individual activity but a group process where architectural design decisions are made by groups of heterogeneous and dispersed stakeholders. The decision-making process is not just data driven, but also people driven, and group decision making methodologies have been studied from multiple perspectives (e.g., psychology, organizational behavior, economics) with the clear understanding that a poor-quality decision making process is more likely than a high-quality process leading to undesirable outcomes (including disastrous fiascoes).               In this work, we propose to explicitly include group decision making strategies\u00a0\u2026", "num_citations": "11\n", "authors": ["1397"]}
{"title": "Scenario-based and State Machine-based Testing: An evaluation of automated approaches\n", "abstract": " Practitioners regard software testing as the central means for ensuring that a system behaves as expected. Recently, with the widespread adoption of modeling notations for OO systems, academia and industry are looking at model-based testing as a possible way to complement existing testing techniques.As a result of this effort, many model-based testing approaches have been proposed. However, the suitability of such approaches for industrial projects is unclear, and their level of adoption is still limited. To better understand their suitability for industrial projects, this paper summarizes a survey that studies automated model-based testing approaches from two perspectives: level of automation (of each testing activity) and ability to track information among test-related artifacts (eg from models to code and vice-versa).", "num_citations": "11\n", "authors": ["1397"]}
{"title": "Towards weaving software architecture models\n", "abstract": " Increasingly, UML metamodels and profiles are adopted to specify software architectures from different angles in order to cope with analysis specific modeling needs. In particular, whenever two or more analysis techniques are required over the same architectural model, different modeling tools and notations are required, and feedback from one model to the other is not propagated since integration is not universally established. Model-driven architecture offers a conceptual framework for defining a set of standards in support of model-driven development, where models are first class entities and play a central role in software development. In this paper, the coexistence and integration of different analysis techniques at the architectural level is reduced to the problem of enriching multi-view descriptions with proper UML elements by means of directed weaving operations", "num_citations": "11\n", "authors": ["1397"]}
{"title": "IoT flows: a network flow model application to building evacuation\n", "abstract": " This chapter presents a real-time emergency evacuation handling system based on internet of things (IoT) technologies. The IoT infrastructure has a core computational component that is in charge of minimizing the time necessary to evacuate people from a building. The space and time dimension are discretized according to metrics and models in literature, as well as original methods. The component formulates and solves a linearized, time-indexed flow problem on a network that represents feasible movements of people at a suitable frequency. Accurate parameter setting makes the computational time to solve the model compliant with real-time use. An application of the proposed IoT system and its core algorithm to handle safe evacuation test in Palazzo Camponeschi\u2014a building in L\u2019Aquila (Italy) now and then used for exhibitions\u2014is described, and diverse uses of the methodology are presented.", "num_citations": "10\n", "authors": ["1397"]}
{"title": "Cassandra: An online failure prediction strategy for dynamically evolving systems\n", "abstract": " Dynamically evolving systems are characterized by components that can be inserted or removed while the system is being operated leading to unsafe run-time changes that may compromise a correct execution. To mitigate the effects of such a failure we propose an online analysis technique that admit an integration \u201ca-priori\u201d and a monitoring of the run-time behaviour to provide information about possible errors when these can happen. Our Cassandra technique proposes a novel run-time monitoring and verification algorithm with the ability to predict potential failures that can happens in future states of the systems. Cassandra combines design-time and run-time information. Both are used to identify the current execution state, and to drive the construction of predictions that look to a number k of steps ahead of the current execution state. This paper provides a detailed formalization of the technique then it\u00a0\u2026", "num_citations": "10\n", "authors": ["1397"]}
{"title": "An approach for detecting implied scenarios\n", "abstract": " Implied scenarios are unexpected behaviors that may be derived by behavioral models when they are synthesized from scenarios. These scenarios are \u201cimplied\u201d since they are not described in the scenario specification but each synthesized model of them will present, allowing system executions that are unacceptable (or at least unexpected) with respect to the original specification.The work we are going to propose builds over an existing work and proposes an algorithm to identify implied scenarios avoiding the construction of the Labelled Transition System (LTS) model. The main advantage of this approach is that we can discover implied scenarios without building the synthesized model, and, much more important, we do not need to put in parallel the synthesized components LTS, saving time and preventing the possibility of state explosion problems. We will also show the ability of this algorithm in discovering implied scenarios going through an example.", "num_citations": "10\n", "authors": ["1397"]}
{"title": "Data-driven adaptation in microservice-based iot architectures\n", "abstract": " Architecting self-adaptive Internet of Things (IoT) systems pose a lot of challenges due to heterogeneity, resource constraints, interoperability, etc. Although microservice architectures (MSA) emerged as a popular solution for developing next generation IoT systems, they further increase these challenges. This can be attributed to the complexity involved in managing adaptation concerns arising at different levels: i) IoT devices level, due to open and changing contexts, resource constraints, etc; ii) microservices level, due to dynamic resource demands; iii) application level itself, due to the changing user goals. In fact, recent studies have shown that traditional self-adaptation techniques are not flexible enough to be applied to MSA based systems. Moreover, what proposed in the literature handles adaptation either at the architectural level or at the application level. Towards this direction, we propose a self-adaptive\u00a0\u2026", "num_citations": "9\n", "authors": ["1397"]}
{"title": "Towards a framework for distributed and collaborative modeling\n", "abstract": " Increasingly, models are becoming first class core assets, and model-driven engineering requires novel techniques, tools, and practices to face the globalization of software development in the (always more) pervasive IT world. This paper proposes a framework for synchronous and asynchronous concurrent and collaborative modeling. Synchronous collaborative modeling offers services for sharing the modeling space, models, documentation, and configuration, while asynchronous collaborative modeling offers services for supporting merging of models modified and edited separately by different software engineers. Our approach is based on the observation that it is in general more convenient to store differences between subsequent versions of a system than the whole models of each stage.", "num_citations": "9\n", "authors": ["1397"]}
{"title": "Integrating AADL within a multi-domain modeling framework\n", "abstract": " DUALLY is a framework that allows architectural languages interoperability through automated model transformation techniques. Any transformation among ADLs is defined in DUALLY by passing through A 0  that is an extensible semantic core set of modeling elements. In this paper we describe the integration of AADL and the corresponding OSATE tool-set in DUALLY. Once AADL is hooked to A 0 , it is automatically integrated with the network of languages already integrated in DUALLY. In particular, we show how it is possible, in an easy way, to obtain a UML specification and to model check AADL and behavioral annex specifications through LTSA.", "num_citations": "9\n", "authors": ["1397"]}
{"title": "Software Architecture for ML-based Systems: What Exists and What Lies Ahead\n", "abstract": " The increasing usage of machine learning (ML) coupled with the software architectural challenges of the modern era has resulted in two broad research areas: i) software architecture for ML-based systems, which focuses on developing architectural techniques for better developing ML-based software systems, and ii) ML for software architectures, which focuses on developing ML techniques to better architect traditional software systems. In this work, we focus on the former side of the spectrum with a goal to highlight the different architecting practices that exist in the current scenario for architecting ML-based software systems. We identify four key areas of software architecture that need the attention of both the ML and software practitioners to better define a standard set of practices for architecting ML-based software systems. We base these areas in light of our experience in architecting an ML-based software system for solving queuing challenges in one of the largest museums in Italy.", "num_citations": "8\n", "authors": ["1397"]}
{"title": "Quantitative verification-aided machine learning: A tandem approach for architecting self-adaptive iot systems\n", "abstract": " Architecting IoT systems able to guarantee Quality of Service (QoS) levels can be a challenging task due to the inherent uncertainties (induced by changes in e.g., energy availability, network traffic) that they are subject to. Existing work has shown that machine learning (ML) techniques can be effectively used at run time for selecting self-adaptation patterns that can help maintain adequate QoS levels. However, this class of approach suffers from learning bias, which induces accuracy problems that might lead to sub-optimal (or even unfeasible) adaptations in some situations. To overcome this limitation, we propose an approach for proactive self-adaptation which combines ML and formal quantitative verification (probabilistic model checking). In our approach, ML is tasked with selecting the best adaptation pattern for a given scenario, and quantitative verification checks the feasibility of the adaptation decision\u00a0\u2026", "num_citations": "8\n", "authors": ["1397"]}
{"title": "Automatically bridging UML profiles to MOF metamodels\n", "abstract": " In Model-Driven Engineering, UML profiles and MOF-based Domain Specific Modeling Languages (DSMLs) are the most used approaches for describing domain specific applications. The choice of the right approach depends on several aspects, such as tool support, expressivity, complexity of models, company policies. In general, profiled UML models are very much used since they are intuitive for designers and model editors already exist, however they are intrinsically complex for model manipulation (e.g., Transformation, analysis), conversely, domain specific models are more concise and easy to be manipulated, but they require an initial effort in terms of designers training and model editors development. In this paper we propose an approach that allows getting the best of the two worlds: on one side designers can use UML profiles familiar to them, on the other side DSML models (automatically generated from\u00a0\u2026", "num_citations": "8\n", "authors": ["1397"]}
{"title": "A survey on the specification of the physical environment of wireless sensor networks\n", "abstract": " A wireless Sensor Network (WSN) consists of spatially distributed sensor nodes that cooperate in order to accomplish a specific task. What really sets WSNs apart from all the other kinds of distributed systems is the limited processing capabilities of the nodes, contingent energy restrictions, and their strict dependence to physical phenomena like attenuation, reflection, etc. Under this perspective, the physical environment in which WSN nodes are deployed strongly affects the overall quality of the system. Under this perspective, how WSN engineers currently specify the physical environment and how they would like to do it? This paper presents a survey we run by interviewing WSN engineers with a special focus on their practical needs and activities. By analyzing the collected data, we can conclude that: a) a good number of practitioners describing the physical environment do it by GIS software or informally, b\u00a0\u2026", "num_citations": "8\n", "authors": ["1397"]}
{"title": "Rapid system development via product line architecture implementation\n", "abstract": " Software Product Line (SPL) engineering allows designers to reason about an entire family of software applications, instead of a single product, with a strategic importance for the rapid development of new applications. While much effort has been spent so far in understanding and modeling SPLs and their architectures, very little attention has been given on how to systematically enforce SPL architectural decisions into the implementation step.             In this paper we propose a methodological approach and an implementation framework, based on a plugin component-based development, which allows us to move from an architectural specification of the SPL to its implementation in a systematic way. We show the suitability of this framework through its application to the TOOL one case study SPL.", "num_citations": "8\n", "authors": ["1397"]}
{"title": "Human behaviour centered design: developing a software system for cultural heritage\n", "abstract": " This paper introduces an integrated framework for sustainability and urban security socio-technical systems. The focus is to design and develop a hardware/software system based on human expected and real behaviour.", "num_citations": "7\n", "authors": ["1397"]}
{"title": "A4WSN: an architecture-driven modelling platform for analysing and developing WSNs\n", "abstract": " This paper proposes A4WSN, an architecture-driven modelling platform for the development and the analysis of wireless sensor networks (WSNs). A WSN consists of spatially distributed sensor nodes that cooperate in order to accomplish a specific task. Sensor nodes are cheap, small, and battery-powered devices with limited processing capabilities and memory. WSNs are mostly developed directly on the top of the operating system. They are tied to the hardware configuration of the sensor nodes, and their design and implementation can require cooperation with a myriad of system stakeholders with different backgrounds. The peculiarities of WSNs and current development practices bring a number of challenges, ranging from hardware and software coupling, limited reuse, and the late assessment of WSN quality properties. As a way to overcome a number of existing limitations, this study presents a multi\u00a0\u2026", "num_citations": "7\n", "authors": ["1397"]}
{"title": "ByADL: an MDE framework for building extensible architecture description languages\n", "abstract": " In order to deal with evolving needs and stakeholder concerns, next generation ADLs should support incremental extension and customization. In this direction we proposed byADL (Build Your ADL), a framework which allows software architects to (i) extend existent ADLs with domain specificities, new architectural views, or analysis aspects, (ii) integrate an ADL with development processes and methodologies, and (iii) customize an ADL. This paper presents the byADL tool and its features.", "num_citations": "7\n", "authors": ["1397"]}
{"title": "Modeling and code generation framework for iot\n", "abstract": " In the Internet of Things (IoT) every physical device has an embedded technology that interacts with internal and external states. The heterogeneity of devices and networks complicates the mission of implementing and integrating the objects in IoT systems. In this paper, we present our model driven code generation framework, called CAPSml. The framework enables IoT designers and architects who are using CAPS environment to transform CAPS software model into ThingML model. CAPS is an architecture-driven modeling framework for the development of IoT Systems. ThingML includes modeling language and framework designed for IoT systems to support code generation for multi-platform targets.", "num_citations": "6\n", "authors": ["1397"]}
{"title": "Simulating architectures of situational-aware cyber-physical space\n", "abstract": " Situational aware cyber-physical space seamlessly incorporates computational and physical parts to monitor what is going on in the environment and utilize this data to choose and act. Graphical Modeling, Code generation and simulation help in diminishing the cost of building a situational aware cyber-physical space application since the architects can automatically get an executable application from the architectural model by applying the automatic transformation. In this paper, we present CAPS environment in which an architect can make diverse models to catch distinctive concerns in cyber-physical spaces, simulate and get an energy consumption and data traffic evaluation for their architectures.", "num_citations": "6\n", "authors": ["1397"]}
{"title": "Stakeholders, viewpoints and languages of a modelling framework for the design and development of data-intensive mobile apps\n", "abstract": " Today millions of mobile apps are downloaded and used all over the world. Guidelines and best practices on how to design and develop mobile apps are being periodically released, mainly by mobile platform vendors and researchers. They cover different concerns, and refer to different technical and non-technical stakeholders. Still, mobile applications are developed with ad-hoc development processes, and on-paper best practices. In this paper we discuss a multi-view modelling framework supporting the collaborative design and development of mobile apps. The proposed framework embraces the Model-Driven Engineering methodology. This paper provides an overall view of the modelling framework in terms of its main stakeholders, viewpoints, and modelling languages.", "num_citations": "6\n", "authors": ["1397"]}
{"title": "Architecture description leveraging model driven engineering and semantic wikis\n", "abstract": " A previous study, run by some of the authors in collaboration with practitioners, has emphasized the need to improve architectural languages in order to (i) make them simple and intuitive enough to communicate effectively with project stakeholders, and (ii) enable formality and rigour to allow analysis and other automated tasks. Although a multitude of languages have been created by researchers and practitioners, they rarely address both of these needs. In order to reconcile these divergent needs, this paper presents an approach that (i) combines the rigorous foundations of model-driven engineering with the usability of semantic wikis, and (ii) enables continuous syncronization between them, this allows software architects to simultaneously use wiki pages for communication and models for model-based analysis and manipulation. In this paper we explain how we applied the approach to an industry-inspired case\u00a0\u2026", "num_citations": "6\n", "authors": ["1397"]}
{"title": "DUALLY: Putting in Synergy UML 2.0 and ADLs\n", "abstract": " Many formal languages to describe software architectures (SA) have been proposed so far, but only very few of them are still supported and used in practical contexts. Many UML profiles and extensions have been provided when UML became a standard, in order to model as much as possible architectural concepts. They allow to specify specific needs, but the effort in creating a sort of unified UML-based language for architectures is still not paying. In fact, since different communities require different information to be put into a diagram, depending on which architectural design aspects should be represented and analyzed, the idea of an unified UML language for SA seems to be not adequate. Building on these considerations, we propose DUALLY, a core set of UML concepts, well suited for SA modeling, together with a framework which provides extensibility mechanisms to adapt the initial notation, in order to meet different needs.", "num_citations": "6\n", "authors": ["1397"]}
{"title": "Agent-based simulation for IoT facilitated building evacuation\n", "abstract": " The Internet of Things (IoT) has changed our approach to safety systems by connecting sensors and providing real-time data to endangered people in emergency fire situations. In an emergency, evacuating a building in the shortest time possible is essential. Although optimisation methods give a best case scenario, they do not reflect the realism of actual evacuations. We combine a network flow optimisation algorithm with agent based social simulation to provide more realistic evacuation scenarios. Individual occupants are modelled as computational agents in the simulator. Agents are heterogenous and exhibit social attachment to others and vary their speed of movement. A Belief-Desire-Intention (BDI) agent architecture is used to model the cognitive reasoning of individual agents. The work is applied to a real building, equipped with IoT sensors whose data feed into the network flow model. The results show that\u00a0\u2026", "num_citations": "5\n", "authors": ["1397"]}
{"title": "A practical architecture-centric analysis process\n", "abstract": " When engineering complex and distributed software and hardware systems (increasingly used in many sectors, such as manufacturing, aerospace, transportation, communication, energy and health-care), dependability has became a must, since failures can have economics consequences and can also endanger human life.               Software Architectures (SA) can help improving the overall system dependability, providing a system blueprint that can be validated and that can guide all phases of the system development. Even if much work has been done on this direction, three important topics require major investigation: how different analysis techniques can be integrated together, how results obtained with SA-based analysis can be related to requirements and coding, and how to integrate new methodologies in the industrial software development life-cycle.               In this paper we propose an architecture\u00a0\u2026", "num_citations": "5\n", "authors": ["1397"]}
{"title": "A Coordination Process Based on UML and a Software Architectural Description.\n", "abstract": " Coordination models and SA descriptions work in different domains, but there are (at least) two strict relationship between them: i) SAs represent an high level description of the system while coordination models (languages) are closer to specification level; ii) coordination models are specialized to describe process interaction in a concurrent environment, SA descriptions contain intercomponents communication descriptions. In this work, we are going to describe how SA description and UML can be integrated in a UML software development process with the aim to define a coordination process able to describe, analyze and validate system coordination properties that might be then specified with a suitable coordination language. A real-world case study will be used to discuss, in detail, the approach previously introduced.", "num_citations": "5\n", "authors": ["1397"]}
{"title": "A cyber-physical space operational approach for crowd evacuation handling\n", "abstract": " Crowded public venues are significantly under risks and uncertainties caused by fire and overcrowding hazards. For this purpose, Situational Awareness (SiA) -that is a mechanism to know what is going on around- can facilitate the automatic (or human involved) critical decision making and executing processes.\u00a0Considering the dynamic and uncertain essence of crowd and hazard behavior in an emergency, executing the optimum evacuation plan is highly complex and needs strong models. In this paper, taking in input a model of the Cyber-Physical Space under SiA monitoring, we define an architectural-map-based Dynamic Bayesian Network (DBN) to describe and predict crowd and hazard behavior. Then,\u00a0in order to minimize the total evacuation time, the authors present a quickest flow model for consecutive time intervals.\u00a0Overall, the paper shows the importance of hazard quiddity, and crowd\u00a0\u2026", "num_citations": "4\n", "authors": ["1397"]}
{"title": "Testing run-time evolving systems\n", "abstract": " This document summarizes the results of the Working Group 4-``Testing''-at the Dagstuhl Seminar 09201``Self-Healing and Self-Adaptive Systems''(organized by A. Andrzejak, K. Geihs, O. Shehory and J. Wilkes). The seminar was held from May 10th 2009 to May 15th 2009 in Schloss Dagstuhl~--~ Leibniz Center for Informatics.", "num_citations": "4\n", "authors": ["1397"]}
{"title": "Formal behavioral specification of a product line architecture\n", "abstract": " Formal specification languages have been successfully used in the last few years to model (and successively analyze) Software Architectures (SAs). Many analysis techniques and tools have been proposed, based on such formal languages.Moving from SAs to Product Line Architectures (PLAs)(which specify the common architecture for a set of related systems), one of the most interesting challenges is how to adapt existing architectural specification formalisms. Languages have been proposed to specify the structure/topology of a PLA. However, since a behavioral specification is still missing, different functional analysis techniques, successfully used at the SA level, cannot be applied at the PLA level yet. In this paper, we show how an existing formal language may be easily extended in order to suitably describe how a PLA functionally behaves. We finally model the PLA topology and behavior of a case study.", "num_citations": "4\n", "authors": ["1397"]}
{"title": "Leveraging machine learning techniques for architecting self-adaptive iot systems\n", "abstract": " The use of IoT systems is increasing day by day. However, these systems due to their heterogeneity and inherently dynamic nature, face different uncertainties from the context, environment, etc. Such uncertainties can have a big impact on the overall system QoS, especially on energy efficiency and data traffic. This calls for better ways of architecting IoT systems that may self-adapt to keep the desired QoS. This paper presents an approach that leverages the use of machine learning (ML) techniques to perform a proactive adaptation of IoT architectures using self-adaptation patterns. It i) continuously monitors the QoS parameters; ii) forecasts possible deviations from the acceptable QoS parameters; iii) selects the best adaptation pattern based on forecasts using reinforcement learning (RL) techniques; iv) checks the quality of the selected decision using feedback mechanisms; and v) continuously performs the loop\u00a0\u2026", "num_citations": "3\n", "authors": ["1397"]}
{"title": "Reducing the effort for systematic reviews in software engineering\n", "abstract": " Background. Systematic Reviews (SRs) are means to collect and synthesize evidence from the identification, analysis, and interpretation of multiple sources, or {\\em primary studies}. To this aim, they use a well-defined methodology that should mitigate the risks of biases and ensure repeatability for later updates. SRs, however, involve significant effort. Goal. The goal of this paper is to introduce a novel expert-driven automatic methodology (EDAM) that, among other benefits, while taking advantage of the value provided by human expertise, reduces the number of manual tedious tasks involved in SRs. Method. Starting from current methodologies for SRs, we replaced the steps of keywording and data extraction with an automatic methodology for generating a domain ontology and classifying the primary studies. This methodology has been then applied in the software engineering sub-area of software architecture, %and software quality, and evaluated with human annotators. Results. The result is a novel expert-driven automatic methodology for performing SRs. This combines ontology-learning techniques and semantic technologies with the human-in-the-loop. The first (thanks to automation) fosters scalability, objectivity, reproducibility and granularity of the studies; the second allows tailoring to the specific focus of the study at hand, as well as knowledge reuse from domain experts. We evaluated EDAM on the field of Software Architecture and found that its performance in classifying papers were not statistically significant different from the ones of six senior researchers (p=0.77). Conclusions. Thanks to automation of the less creative steps in SRs\u00a0\u2026", "num_citations": "3\n", "authors": ["1397"]}
{"title": "A combined netflow-driven and agent-based social modeling approach for building evacuation\n", "abstract": " In an emergency, finding safe egress pathways in a short period of time is crucial. In this paper we use a network flow (netflow) algorithm that acts as the core of a real-time recommender system to be used by building occupants and decision-making bodies. However, a purely optimization approach can lack realism since building occupants may not evacuate immediately, stopping to look for their friends or trying to assess if the alert is for real or just a drill, etc. Furthermore, they may not always follow the recommended optimal paths. Thus, in order to assess the egress in a physical space and to test our evacuation algorithms, we use a simulation-optimization (S/O) approach. The model allows us to test more realistic evacuation scenarios and compare them with an optimal approach. The S/O uses both a netflow algorithm and an agent-based approach to model and simulate individual human behaviours\u00a0\u2026", "num_citations": "3\n", "authors": ["1397"]}
{"title": "ArchLearner: leveraging machine-learning techniques for proactive architectural adaptation\n", "abstract": " Self-adaptation is nowadays considered as one of the possible solutions to handle the uncertainties faced by software at run-time. This is especially true in the case of IoT systems. These uncertainties can, in turn, affect the system QoS (Quality Of Service). In this tool demo, we present a machine learning driven proactive decision-making tool named ArchLearner, for aiding architectural adaptation. The tool enables the given IoT system to i) automatically identify the need for adaptation at an early stage; ii) perform automated decision making for generating the best adaptation strategy; iii) gather the feedback of the selected decision for continuous improvement. It also enables the architects/developers to i) visualize the adaptation process in near real-time; ii) specify the required configurations; iii) visualize the real-time QoS data.", "num_citations": "3\n", "authors": ["1397"]}
{"title": "Arduino realization of CAPS IoT architecture descriptions\n", "abstract": " Situational aware IoT (SAIoT) seamlessly integrate computational and physical parts to monitor what is going on in the environment and utilize this data to choose and act. Graphical Modeling, Code generation and arduino realization help in diminishing the cost of building a situational aware IoT application since the architects can automatically get an executable application from the architectural model by applying the automatic transformation. In this paper, we present CAPS environment in which an architect can make diverse models to catch distinctive concerns in IoT Then, propose the realization of SAIoT applications by automatically generating Arduino code that can be deployed and run on Arduino components. The generated Arduino code can be executed and data traffic load, battery level and energy consumptions of the selected architecture can be evaluated on the concrete implementation.", "num_citations": "3\n", "authors": ["1397"]}
{"title": "What industry needs from architectural languages: An industrial survey\n", "abstract": " Many times we have faced the proliferation of definitions, concepts, languages and tools in certain (research) topics. In all cases, there is a gap between what provided by existing technologies, and what needed by their users. In most cases, it is not clear enough what users perceive as the strengths, limitations and needs associated to the available technologies. The same applies to software architectures, and specifically to languages designed to capture architectural knowledge. Tens of different architectural languages have been introduced by the research and industrial communities in the last two decades. However, it is unclear if they fulfil the user\u2019s perceived needs in architectural description. As a way to plan for next generation languages for architectural description, this study analyzes practitioners\u2019 perceived strengths, limitations and needs associated to existing languages for software architecture modeling\u00a0\u2026", "num_citations": "3\n", "authors": ["1397"]}
{"title": "From requirements to code: an architecture-centric approach for producing quality systems\n", "abstract": " When engineering complex and distributed software and hardware systems (increasingly used in many sectors, such as manufacturing, aerospace, transportation, communication, energy, and health-care), quality has become a big issue, since failures can have economics consequences and can also endanger human life. Model-based specifications of a component-based system permit to explicitly model the structure and behaviour of components and their integration. In particular Software Architectures (SA) has been advocated as an effective means to produce quality systems. In this chapter by combining different technologies and tools for analysis and development, we propose an architecture-centric model-driven approach to validate required properties and to generate the system code. Functional requirements are elicited and used for identifying expected properties the architecture shall express. The architectural compliance to the properties is formally demonstrated, and the produced architectural model is used to automatically generate the Java code. Suitable transformations assure that the code is conforming to both structural and behavioural SA constraints. This chapter describes the process and discusses how some existing tools and languages can be exploited to support the approach.", "num_citations": "3\n", "authors": ["1397"]}
{"title": "From requirements to Java code: An architecture-centric approach for producing quality systems\n", "abstract": " When engineering complex and distributed software and hardware systems (increasingly used in many sectors, such as manufacturing, aerospace, transportation, communication, energy, and health-care), quality has become a big issue, since failures can have economic consequences and can also endanger human life. Model-based specifications of component-based systems permit to explicitly model the structure and behaviour of components and their integration. In particular Software Architectures (SA) have been advocated as an effective means to produce quality systems. In this chapter by combining different technologies and tools for analysis and development, we propose an architecture-centric model-driven approach to validate required properties and to generate the system code. Functional requirements are elicited and used for identifying expected properties the architecture shall express. The\u00a0\u2026", "num_citations": "3\n", "authors": ["1397"]}
{"title": "Software testing: Testing new software paradigms and new artifacts\n", "abstract": " Software testing research is continuously moving toward different challenges and obstacles driven by different forces. What we believe are two main forces that drive software testing evolution are the progress in software development paradigms and languages, and the artefacts along the software development process to be used for testing purposes. Based on this specific perspective, this work provides an ample presentation of issues and assessments related to testing software. Ongoing and (expected) future research directions on software testing are also outlined.", "num_citations": "3\n", "authors": ["1397"]}
{"title": "An Archi-tecture-driven Methodology for Developing Fault-Tolerant Sys-tems\n", "abstract": " Software Architectures are becoming centric to the development of software systems, being the first concrete model of requirements and the base to guide the implementation of software systems: once the architectural model is verified, generative techniques may be utilized to produce skeletal code of the system implementation. However, when dealing with software systems with fault tolerance requirements, SA-based developments are still inadequate for producing fault tolerant implementations.This paper proposes an architecture-driven methodology for developing faulttolerance systems, where a traditional architectural specification is verified and enhanced with fault tolerance information, and utilized to produce a fault tolerant design model and the implementation of the software system. The methodology is instantiated to well established technologies and applied to a system study.", "num_citations": "3\n", "authors": ["1397"]}
{"title": "Eliciting coordination policies from requirements\n", "abstract": " Software coordination models and languages describe how agents, resources and processes work together to implement a software system. One of their limitations is that they are used late in the software development and they are not integrated in a typical software development process. What we claim, with our research, is that if coordination becomes explicit and formalized as soon as possible in the life cycle, then it is possible to create coordinated-aware software systems. Moreover, it is possible to verify the adequacy of a Software Architecture model (or of the code itself) with respect to these dynamic constraints as well as refine or disambiguate coordination requirements themselves. In previous work, we presented a UML-based development process to elicit, describe, analyze and validate system coordination properties that might be then specified with a suitable coordination language. In this general picture\u00a0\u2026", "num_citations": "3\n", "authors": ["1397"]}
{"title": "An Experience in Architectural Extensions: Active Objects in J2EE\n", "abstract": " In this paper we present an experience in architectural extension. The goal of our project was to provide Active Objects in the Java 2 Enterprise Edition (J2EE) reference architecture by suitable extensions that should not violate the architectural J2EE principles. Our approach to the problem was rather formal. We first formalized the notion of Active Object, the basic characteristics of the J2EE model and its component model Enterprise JavaBeans (EJB). Then, driven by the peculiar characteristics of an Active Object, we investigated several possible architectural extensions. The solutions were formalized as well and their consistency with the J2EE model was validated by using model checking techniques. In this way we discovered that only one of them was acceptable. The whole formalization and validation has been carried out by using the Charmy environment, where the architectural formalization makes\u00a0\u2026", "num_citations": "3\n", "authors": ["1397"]}
{"title": "Architecture description language for climate smart agriculture systems\n", "abstract": " Smart agriculture is a new concern in IoT systems. IoT technologies can provide information about the agriculture field and its surroundings and act accordingly. Architecting smart agriculture systems can benefit from architecting methods available for IoT systems. In this paper, we introduce CSA-CAPS, a Climate Smart Agriculture modeling framework designed based on CAPS. CAPS is an architecture-driven modeling framework for developing IoT Systems. CSA-CAPS includes a modified meta model for the software architecture of CAPS. It adds special sensors and functionalities for climate concerns of building smart agriculture systems. This paper shows the capability of CSA-CAPS by applying motivating scenarios.", "num_citations": "2\n", "authors": ["1397"]}
{"title": "An approach for developing context-aware mobile application\n", "abstract": " Mobile applications run in dynamic environments characterized by huge contexts variability due to user mobility and limited device resources. Context awareness requires context monitoring and system adaptation, these two tasks are very expensive especially in mobile applications. is paper aims at developing a methodology that enables context-awareness techniques for mobile applications that allows adaptations to context changes so that the desired system quality is preserved.", "num_citations": "2\n", "authors": ["1397"]}
{"title": "A comparative analysis of self-adaptive patterns in cyber-physical systems\n", "abstract": " Architecting Cyber-Physical Systems (CPS) is cumbersome, as these systems must handle changes during operations. One of the possible solution to deal with the changes in these systems is using patterns. Three patterns for self-adaptive cyber-physical systems (CPS) have been presented in previous work: Synthesis Utilize Pattern, Synthesis Command Pattern, and Collect Organize Pattern. To determine the energy efficiency and data traffic generated by those CPS patterns, we run a simulation of the three CPS patterns where results are collected, discussed, and generalized. The result shows that the Synthesis Command Pattern requires less energy consumption when compared to the other two patterns. The Collect Organize Pattern, instead, results to be the most efficient in terms of distributing logic. The architecture reveals about the accuracy in the solution drawn from the Synthesis Utilize Pattern which is\u00a0\u2026", "num_citations": "2\n", "authors": ["1397"]}
{"title": "ArIA: arduino code generation based on the caps\n", "abstract": " Situational Aware (SA) Internet of things (IoT) utilize IoT devices for being aware of what is happening in the surroundings, and use this data to decide and act accordingly. In this tool demo paper, we present our architecture-driven arduino code generation tool named ArAI. To develop this tool, we had first of all to learn how to program an Arduino board, that comprises steps such as the writing, verification, compiling and uploading of the code to an Arduino board. Then, we had to realize the transformation (CAPS models to Arduino code) process comprising three different steps: parsing, analyzing, and code generation. The output of this transformation is a fully functional code that can be run on Arduino boards and reflecting the architecture decisions.", "num_citations": "2\n", "authors": ["1397"]}
{"title": "How do you Feel Today? Buggy!\n", "abstract": " It is well-known that moods and emotions strongly affect our performances. Clearly, this holds also for software developers. Thus, modern managers, trainers, and coaches should be aware of moods and emotions of software developers in their teams. In this context, mining software repositories and social networks in combination can be an invaluable instrument for understanding how the moods and emotions of software developers impact their performance, even in real-time. In this paper, we propose our first steps in mining software repositories for (i) getting information about developers' moods and emotion throughout the development process, and (ii) investigating on the existence of the correlation between software developers' performance (in terms of their commits bugginess) and mood. For what concerns data sources, we use publicly-available information on GitHub for getting insights about the\u00a0\u2026", "num_citations": "2\n", "authors": ["1397"]}
{"title": "10111 executive summary--practical software testing: Tool automation and human factors\n", "abstract": " The main goal of the seminar``Practical Software Testing: Tool Automation and Human Factors''was to bring together academics working on algorithms, methods, and techniques for practical software testing, with practitioners, interested in developing more soundly-based and well-understood testing processes and practices. The seminar's purpose was to make researchers aware of industry's problems, and practitioners aware of research approaches. The seminar focused in particular on testing automation and human factors. In the week of March 14-19, 2010, 40 researchers from 11 countries (Canada, France, Germany, Italy, Luxembourg, the Netherlands, Sweden, Switzerland, South Africa, United Kingdom, United States) discussed their recent work, and recent and future trends in software testing. The seminar consisted of five main types of presentations or activities: topic-oriented presentations, research-oriented presentations, short self-introduction presentations, tool demos, and working group meetings and presentations.", "num_citations": "2\n", "authors": ["1397"]}
{"title": "What makes software architecture-based testing distinguishable\n", "abstract": " Has software architecture-based testing any characteristic which makes it unique with respect to other testing techniques? This recurrent question will be analyzed in this short paper, providing some initial solution, while leaving ample space for discussion.", "num_citations": "2\n", "authors": ["1397"]}
{"title": "Software Architecture-driven System Testing through Model-Checking\n", "abstract": " Many analysis techniques have been proposed so far to improve the dependability of a Software Architecture (SA). Formal languages and tools have been proposed to help software engineers in this task. Even if much work has been done on this direction, two important topics require major attention: i) how different analysis techniques can be integrated, and ii) how results obtained by SA-based analysis can be related with requirements and coding.We here show how Model-Checking and Testing techniques can be jointly applied in an SA-based automatic analysis framework, where an SA specification of the system is available, model-checking validates the SA model conformance with respect to selected properties, while testing techniques validate the implementation conformance to the SA model.", "num_citations": "2\n", "authors": ["1397"]}
{"title": "Model-based Automation of Test Script Generation Across Product Variants: a Railway Perspective\n", "abstract": " In this work, we report on our experience in defining and applying a model-based approach for the automatic generation of test scripts for product variants in software product lines. The proposed approach is the result of an effort leveraging the experiences and results from the technology transfer activities with our industrial partner Bombardier Transportation. The proposed approach employs metamodelling and model transformations for representing different testing artefacts and making their generation automatic. We demonstrate the industrial applicability and efficiency of the proposed approach using the Bombardier Transportation Aventra software product line. We observe that the proposed approach mitigates the development effort, time consumption and consistency drawbacks typical of traditional strategies.", "num_citations": "1\n", "authors": ["1397"]}
{"title": "Data-Driven Self-Adaptive Architecting Using Machine Learning\n", "abstract": " The last decade has seen a significant evolution in software architecting practices as the process of managing and developing software is becoming more and more complex. This is especially true due to the heterogeneous composition of modern software systems coupled with the run-time uncertainties. These include application downtime due to high CPU utilization, server outages, resource constraints, dynamic resource demands, etc. These can have a big impact on the Quality of Service (QoS) offered by the system, thereby impacting the experience of the end-user.Self-adaptation is nowadays considered to be one of the best solutions to dynamically reconfigure a system in the occurrence of deviations from the expected QoS. However, one of the issues with the existing solutions is that most of them are reactive in nature, where adaptation is carried out in the event of uncertainties. Moreover, current adaptation methods: i) do not provide the systems the ability to proactively identify the need for adaptation with good accuracy; ii) may temporally overcome an impending failure, while not preventing the system from the state in the future. In essence, they do not exploit the knowledge gained from every adaptation performed. The use of machine learning techniques to aid self-adaptation has been proposed in the literature as a way to mitigate this problem based on the concept of self-adaptation through achieving, but not much work has been done in this area. Moreover, the challenges associated with learning bias and less accurate predictions also need to be handled while using machine learning techniques, which otherwise leads to sub\u00a0\u2026", "num_citations": "1\n", "authors": ["1397"]}
{"title": "A novel paradigm for rapid yet robust continuous delivery of software for disaster management scenarios\n", "abstract": " There are situations when you need to accelerate the software development lifecycle (SDLC). When the state of Kerala in India was devastated by severe flooding in 2018, we faced such a situation while we were building applications for managing rescue and relief operations during floods. We present a variant of DevOps called Rapid-DevOps, the release methodology for rapid continuous delivery adopted by us, to meet the challenge of the need for accelerated release cycles while maintaining the required quality and stability. This methodology is suitable for human-critical applications with the potential to save lives especially when the deployment is backed by strong operational support. We describe the cost-benefit analysis to justify its use and the factors in our development process that enabled its successful adoption.", "num_citations": "1\n", "authors": ["1397"]}
{"title": "Software Architecture: 14th European Conference, ECSA 2020, L'Aquila, Italy, September 14-18, 2020, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 14th International Conference on Software Architecture, ECSA 2020, held in A'quila, Italy, in September 2020. In the Research Track, 12 full papers presented together with 5 short papers were carefully reviewed and selected from 103 submissions. They are organized in topical sections as follows: microservices; uncertainty, self-adaptive, and open systems; model-based approaches; performance and security engineering; architectural smells and source code analysis; education and training; experiences and learnings from industrial case studies; and architecting contemporary distributed systems. In the Industrial Track, 11 submissions were received and 6 were accepted to form part of these proceedings. In addition the book contains 3 keynote talks. Due to the Corona pandemic ECSA 2020 was held as an virtual event.", "num_citations": "1\n", "authors": ["1397"]}
{"title": "Generating Heterogeneous Codes for IoT Systems Based on CAPS\n", "abstract": " Nowadays most systems are relying in their development and evolution on reusing and customizing opensource components, services and frameworks. In this poster, we present our architecture driven code generation methodology that benefits from CAPS and ThingML frameworks. CAPS is an architecture-driven modeling framework for the development of IoT Systems. ThingML includes a modeling language and tool designed for supporting code generation for heterogeneous platforms. The suggested methodology enables IoT designers and architects who are using CAPS environment to generate ThingML models and produce executable codes.", "num_citations": "1\n", "authors": ["1397"]}
{"title": "On the use of security principles and practices for architecting cyber-physical systems\n", "abstract": " Context: Security has become a major concern for modern Cyber-Physical Systems (CPS), due to their distributed, sensing, actuating, and always connected nature. A considerable number of security principles and practices have been defined by the security communities and are being implemented in architecting secure CPS.Objective: The main question we are looking for an answer in this work is on how security principles have been used while architecting secure CPS.Method: We conducted a systematic literature review by searching four major scientific databases, resulting in 1591 candidate studies and eventually retaining 32 primary studies included for data collection after applying inclusion and exclusion criteria.Results: 81% of the studies use architectural patterns in designing systems. Among the security principles used integrity is an attribute that is implemented in systems most frequently (53\u00a0\u2026", "num_citations": "1\n", "authors": ["1397"]}
{"title": "Software architecture tool demonstrations\n", "abstract": " In this paper, we describe the short summary of the tool demonstrations session at WICSA/ECSA 2012. The session aimed to attract both tools in practice and research tools. We describe the targeted topics for the tool support, and report on the program.", "num_citations": "1\n", "authors": ["1397"]}
{"title": "A software engineering approach for coordination policies elicitation\n", "abstract": " In a software system, software processes can be concurrently run by system actors (e.g. agents, components), by making use of shared or dedicated software resources. Coordination is a research area oriented to understand, explicitly model and analyze how activities can depend on each other, in a concurrent system. Many coordination models and languages have been presented in the last few years in order to make coordination a first class entity in the development of a software system. However, what usually happens, is that coordination is described late in the software development and it is not integrated in a typical software process. What we claim, with our research, is that if coordination becomes explicit and formalized as soon as possible in the software life cycle, then it is possible to create coordination-aware software systems, which are easily maintained and developed. What we present, in the following\u00a0\u2026", "num_citations": "1\n", "authors": ["1397"]}
{"title": "Formal and Semi-formal descriptions of a Cross-Connector Software Architecture\n", "abstract": " Software Architectures (SAs) represent the overall system structure by modeling individual components and their interactions. SA descriptions capture both the statics and the dynamics, at an appropriately high level of abstraction and can be used to analyze complex software systems relevant properties. In this work we show our experience on a real, complex telecommunication software system trying to understand how formal and coherent software architectural description can be specified to make architectural level quantitative analysis possible.", "num_citations": "1\n", "authors": ["1397"]}