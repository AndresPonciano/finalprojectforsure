{"title": "Understanding Complex Multithreaded Software Systems by Using Trace Visualization\n", "abstract": " Understanding multithreaded software systems is typically a tedious task: Due to parallel execution and interactions between multiple threads, such a system's runtime behavior is often much more complex than the behavior of a single-threaded system. For many maintenance activities, system understanding is a prerequisite. Hence, tasks such as bug fixing or performance optimization are highly demanding in the case of multithreaded systems. Unfortunately, state-of-the-art tools for system understanding and debuggers provide only limited support for these systems. We present a dynamic analysis and visualization technique that helps developers in understanding multithreaded software systems in general and in identifying performance bottlenecks in particular. The technique first performs method boundary tracing. Second, developers perform a post-mortem analysis of a system's behavior using visualization\u00a0\u2026", "num_citations": "63\n", "authors": ["949"]}
{"title": "Multiscale Visual Comparison of Execution Traces\n", "abstract": " Understanding the execution of programs by means of program traces is a key strategy in software comprehension. An important task in this context is comparing two traces in order to find similarities and differences in terms of executed code, execution order, and execution duration. For large and complex program traces, this is a difficult task due to the cardinality of the trace data. In this paper, we propose a new visualization method based on icicle plots and edge bundles. We address visual scalability by several multiscale visualization metaphors, which help users navigating from the main differences between two traces to intermediate structural-difference levels, and, finally fine-grained function call levels. We show how our approach, implemented in a tool called TRACEDIFF, is applicable in several scenarios for trace difference comprehension on real-world trace datasets.", "num_citations": "40\n", "authors": ["949"]}
{"title": "SyncTrace: Visual Thread-Interplay Analysis\n", "abstract": " In software comprehension, program traces are important to gain insight into certain aspects of concurrent runtime behavior, e.g., thread-interplay. Here, key tasks are finding usages of blocking operations, such as synchronization and I/O operations, assessing temporal order of such operations, and analyzing their effects. This is a hard task for large and complex program traces due to their size and number of threads involved. In this paper, we present SYNCTRACE a new visualization technique based on (bended) activity diagrams and edge bundles that allows for parallel analysis of multiple threads and their inter-thread correspondences. We demonstrate how the technique, implemented as a tool, can be applied on real-world trace datasets to support understanding concurrent behavior.", "num_citations": "36\n", "authors": ["949"]}
{"title": "Interactive Software Maps for Web-Based Source Code Analysis\n", "abstract": " Software maps--linking rectangular 3D-Treemaps, software system structure, and performance indicators--are commonly used to support informed decision making in software-engineering processes. A key aspect for this decision making is that software maps provide the structural context required for correct interpretation of these performance indicators. In parallel, source code repositories and collaboration platforms are an integral part of today's software-engineering tool set, but cannot properly incorporate software maps since implementations are only available as stand-alone applications. Hence, software maps are'disconnected'from the main body of this tool set, rendering their use and provisioning overly complicated, which is one of the main reasons against regular use. We thus present a web-based rendering system for software maps that achieves both fast client-side page load time and interactive frame\u00a0\u2026", "num_citations": "15\n", "authors": ["949"]}
{"title": "ViewFusion: Correlating Structure and Activity Views for Execution Traces\n", "abstract": " Visualization of data on structure and related temporal activity supports the analysis of correlations between the two types of data. This is typically done by linked views. This has shortcomings with respect to efficient space usage and makes mapping the effect of user input into one view into the other view difficult. We propose here a novel, space-efficient technique that \u2018fuses\u2019 the two information spaces\u2013structure and activity\u2013in one view. We base our technique on the idea that user interaction should be simple, yet easy to understand and follow. We apply our technique, implemented in a prototype tool, for the understanding of software engineering datasets, namely static structure and execution traces of the Chromium web browser.", "num_citations": "15\n", "authors": ["949"]}
{"title": "Maintenance of Embedded Systems: Supporting Program Comprehension Using Dynamic Analysis\n", "abstract": " Maintenance of embedded software systems is faced with multiple challenges, including the exploration and analysis of the actual system's runtime behavior. As a fundamental technique, tracing can be used to capture data about runtime behavior as a whole, and represents one of the few methods to observe and record data about embedded systems within their production environments. In this paper we present a software-based, function-boundary tracing approach for embedded software systems. It uses static binary instrumentation, which implies only lightweight memory and performance overheads. To further reduce these overheads, instrumentation can be configured per trace, i.e., activated only for a specified group of functions without having to recompile the system. The technique can be characterized by its robust implementation and its versatile usage. It is complemented by a visualization framework that\u00a0\u2026", "num_citations": "13\n", "authors": ["949"]}
{"title": "A Visual Analysis and Design Tool for Planning Software Reengineerings\n", "abstract": " Reengineering complex software systems represents a non-trivial process. As a fundamental technique in software engineering, reengineering includes (a) reverse engineering the as-is system design, (b) identifying a set of transformations to the design, and (c) applying these transformations. While methods a) and c) are widely supported by existing tools, identifying possible transformations to improve architectural quality is not well supported and, therefore, becomes increasingly complex in aged and large software systems. In this paper we present a novel visual analysis and design tool to support software architects during reengineering tasks in identifying a given software's design and in visually planning quality-improving changes to its design. The tool eases estimating effort and change impact of a planned reengineering. A prototype implementation shows the proposed technique's feasibility. Three case\u00a0\u2026", "num_citations": "9\n", "authors": ["949"]}
{"title": "A Visual Analysis Approach to Support Perfective Software Maintenance\n", "abstract": " Ensuring code quality represents an essential task in \"perfective software maintenance\", which aims at keeping future maintenance costs low by facilitating adaptations of complex software systems. For this purpose, changes and related efforts have to be identified that imply high positive impact on future maintainability. In this paper, we propose a novel assessment method that applies visual analysis techniques to combine multiple indicators for low maintainability, including code complexity and entanglement with other parts of the system, and recent changes applied to the code. The approach generally helps to identify modules that impose a high risk by causing increased future maintenance efforts. Consequently, it allows for exploration, analysis, and planning of different preventive measures that, e.g., most likely will have a high return on investment. In our tool implementation, we use circular bundle views\u00a0\u2026", "num_citations": "7\n", "authors": ["949"]}
{"title": "Extending Recommendation Systems with Software Maps\n", "abstract": " In practice, recommendation systems have evolved as helpful tools to facilitate and optimize software engineering processes. Serving both developers and managers, specific recommendation systems address their individual problems. Yet, in a number of cases complementing them with other techniques can enhance their use and extend their scope. In this paper, we first discuss different perspectives on software-engineering processes and examples of recommendation systems that support representatives of these perspectives. We then identify how select software-map techniques can extend recommendation systems to facilitate decision making by addressing the perspectives' information and communication needs.", "num_citations": "7\n", "authors": ["949"]}
{"title": "Visualization techniques for the analysis of software behavior and related structures\n", "abstract": " Software maintenance encompasses any changes made to a software system after its initial deployment and is thereby one of the key phases in the typical software-engineering lifecycle. In software maintenance, we primarily need to understand structural and behavioral aspects, which are difficult to obtain, e.g., by code reading. Software analysis is therefore a vital tool for maintaining these systems: It provides - the preferably automated - means to extract and evaluate information from their artifacts such as software structure, runtime behavior, and related processes. However, such analysis typically results in massive raw data, so that even experienced engineers face difficulties directly examining, assessing, and understanding these data. Among other things, they require tools with which to explore the data if no clear question can be formulated beforehand. For this, software analysis and visualization provide its\u00a0\u2026", "num_citations": "2\n", "authors": ["949"]}
{"title": "Visualization of Multithreaded Behavior to Facilitate Maintenance of Complex Software Systems\n", "abstract": " Maintenance accounts for the major part of a software system's total costs. Therein, program comprehension is an important, but complex activity: Typically, up-to-date documentation is not available, so the main reliable source of information on the implementation represent the artifacts of the system's implementation. Understanding software systems is difficult, in particular, if multithreading concepts are involved because state-of-the art development tools provide only limited support for maintenance activities. In addition, concurrency is often not directly reflected by the source code, i.e., there is only a non-obvious correlation between control structures in the source code and a system's runtime behavior. We present a program comprehension technique that helps to analyze and understand runtime behavior of multithreaded software systems and, thereby, facilitates software maintenance tasks. Our approach contains\u00a0\u2026", "num_citations": "2\n", "authors": ["949"]}
{"title": "Interactive Areal Annotations for 3D Treemaps of Large-Scale Software Systems\n", "abstract": " Exploration of large-scale software systems typically poses a challenge to human mind and perception. Among other approaches to this challenge, visualizing such tree-structured data using treemaps is a common solution. Especially three-dimensional treemaps enable intuitive exploration through a large-scale software system using the landscape metaphor for navigation. Annotations of treemap nodes contribute essential semantic information, eg, class or method names. However, textual annotations in three-dimensional environments typically suffer from ambiguousness, illegibility and instability. In this paper, we propose an interactive labeling algorithm suitable for 3D areal annotation of large-scale software systems that are visualized using three-dimensional treemaps. We demonstrate how the algorithm generates an unambiguous and stable layout with respect to legibility using 3D treemaps of a software visualization tool that visualizes the hierarchical structure of a large software system, eg, Google Chromium.", "num_citations": "1\n", "authors": ["949"]}