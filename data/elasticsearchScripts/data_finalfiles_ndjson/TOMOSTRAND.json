{"title": "Experiments on the effectiveness of dataflow-and control-flow-based test adequacy criteria\n", "abstract": " This paper reports an experimental study investigating the effectiveness of two code-based test adequacy criteria for identifying sets of test cases that detect faults. The all-edges and all-DUs (modified all-uses) coverage criteria were applied to 130 faulty program versions derived from seven moderate size base programs by seeding realistic faults. We generated several thousand test sets for each faulty program and examined the relationship between fault detection and coverage. Within the limited domain of our experiments, test sets achieving coverage levels over 90% usually showed significantly better fault detection than randomly chosen test sets of the same size. In addition, significant improvements in the effectiveness of coverage-based tests usually occurred as coverage increased from 90% to 100%. However the results also indicate that 100% code coverage alone is not a reliable indicator of the\u00a0\u2026", "num_citations": "1170\n", "authors": ["326"]}
{"title": "The category-partition method for specifying and generating fuctional tests\n", "abstract": " A method for creating functional test suites has been developed in which a test engineer analyzes the system specification, writes a series of formal test specifications, and then uses a generator tool to produce test descriptions from which test scripts are written. The advantages of this method are that the tester can easily modify the test specification when necessary, and can control the complexity and number of the tests by annotating the tests specification with constraints.", "num_citations": "1150\n", "authors": ["326"]}
{"title": "The PROMISE repository of empirical software engineering data\n", "abstract": " CiNii \u8ad6\u6587 - The PROMISE Repository of Empirical Software Engineering Data CiNii \u56fd\u7acb\u60c5\u5831\u5b66 \u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092 \u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 The PROMISE Repository of Empirical Software Engineering Data BOETTICHER G. \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 BOETTICHER G. \u53ce\u9332\u520a\u884c\u7269 http://promisedata.org/repository http://promisedata.org/repository, 2007 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 Active Learning for Software Defect Prediction LUO Guangchun , MA Ying , QIN Ke IEICE transactions on information and systems 95(6), 1680-1683, 2012-06-01 \u53c2\u8003\u6587\u732e15\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 10031023821 \u8cc7\u6599\u7a2e\u5225 \u305d\u306e\u4ed6 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u66f8\u304d\u51fa\u3057 EndNote\u306b\u306b/\u3067(\u2026", "num_citations": "220\n", "authors": ["326"]}
{"title": "Automatic generation of test scripts from formal test specifications\n", "abstract": " TSL is a language for writing formal test specifications of the functions of a software system. The test specifications are compiled into executable test scripts that establish test environments, assign values to input variables, perform necessary setup and cleanup operations, run the test cases, and check the correctness of test results. TSL is a working system that has been used to test commercial software in a production environment.", "num_citations": "179\n", "authors": ["326"]}
{"title": "A visual test development environment for GUI systems\n", "abstract": " We have implemented an experimental test development environment (TDE) intended to raise the effectiveness of tests produced for GUI systems, and raise the productivity of the GUI system tester.The environment links a test designer, a test design library, and a test generation engine with a standard commercial capture/replay tool. These components provide a human tester the capabilities to capture sequences of interactions with the system under test (SUT), to visually manipulate and modify the sequences, and to create test designs that represent multiple individual test sequences. Test development is done using a high-level model of the SUT's GUI, and graphical representations of test designs. TDE performs certain test maintenance tasks automatically, permitting previously written test scripts to run on a revised version of the SUT.", "num_citations": "101\n", "authors": ["326"]}
{"title": "White\u2010Box Testing\n", "abstract": " White\u2010box testing refers to test methods that rely on the internal structure of the software. White\u2010box methods are based on executing or \u201ccovering\u201d specific elements of the code. The essential rationale for these methods is that it is impossible to detect a fault in some piece of code by testing if that code is never executed. The ideal would be to test every part of the code in every way that it could be executed during actual operation of the system. Since this ideal is achievable only for very simple programs with finite input domains, each white\u2010box method identifies some specific code characteristic or type of code element that should be tested. A white\u2010box approach can be used either to generate test cases or to measure the extent to which a given set of test cases covers all the code elements identified by the approach. When a method is used to measure coverage, it is called an adequacy criterion. In practice, the\u00a0\u2026", "num_citations": "34\n", "authors": ["326"]}
{"title": "Pattern reproduction in tessellation automata of arbitrary dimension\n", "abstract": " Amoroso and Cooper have shown that for an arbitrary state alphabet A, one- and two-dimensional tessellation automata are definable which have the ability to reproduce any finite pattern contained in the tessellation space. This note shows that the same construction may be applied to tessellation spaces of any finite dimension.", "num_citations": "22\n", "authors": ["326"]}
{"title": "Black\u2010Box Testing\n", "abstract": " Black\u2010box testing of software is any method of generating testcases that is independent of the software's internal structure. Since black\u2010box testing is always based, either directly or indirectly, on the software's specification, it is also called specification\u2010based testing. The simplest concept of black\u2010box testing is that the tester examines the program's specification and chooses test cases that exercise all its externally visible functions. In selecting these black\u2010box tests, the tester considers the program's purpose, the sets of possible inputs and expected outputs, possible ways in which the program might fail, and possible uses of the program. The art of testing consists of approaching each of these sources of tests in an organized way, and in using whichever sources are most appropriate for the particular software and its intended use. Various specific types of black\u2010box testing are model\u2010based testing, scenario\u2010based\u00a0\u2026", "num_citations": "12\n", "authors": ["326"]}
{"title": "Property preservation by tessellation automata\n", "abstract": " The tesse 11ation automaton is a specific model of an infinite ce1\u2013lul ar array of uniform, interconnected finite state machines. A TA is specified as a four component system, M=(A, Zd, X, I). A is the finite set of states assumable by each individual nachine in the array. The tesse 11ation space or array is zd, the set of 1attice points of d-dimensional Euc1idean space. Each lattice point is called a cell of the space, and each cei 1 is occupied by a single finite state machine.", "num_citations": "7\n", "authors": ["326"]}
{"title": "Experiences with Academic-Industrial Collaboration on Empirical Studies of Software Systems\n", "abstract": " The authors have held both academic and industrial research positions, and have designed and carried out many empirical studies of large software systems that were built and maintained in industrial environments. Their experiences show that the most crucial component of a successful study is the participation of at least one industrial collaborator who is committed to the study's goals and is able to provide advice and assistance throughout the course of the study. This paper describes studies carried out in three different industrial environments, discusses obstacles that arise, and how the authors have been able to overcome some of those obstacles.", "num_citations": "1\n", "authors": ["326"]}