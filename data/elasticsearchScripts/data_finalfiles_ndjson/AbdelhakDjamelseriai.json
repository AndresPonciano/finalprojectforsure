{"title": "Quality-centric approach for software component identification from object-oriented code\n", "abstract": " Components and connectors are the main building blocks for software architectures. In the design phase of a software system, components can either be created from scratch or reused. When reused, they can either exist on component shelves or identified from existing software systems. Thus, software component identification is one of the primary challenges in component based software engineering. Typically, the identification is done by analyzing existing software artifacts. When considering object-oriented systems, many approaches have been proposed to deal with this issue by identifying a component as a high cohesive and loose coupled set of classes. However, this assumption leads to two main limitations: in one hand, the focus on simple metrics like high cohesion and loose coupling will not necessarily lead to the identification of good quality components. On the other hand, the identified components\u00a0\u2026", "num_citations": "48\n", "authors": ["2190"]}
{"title": "Extraction of component-based architecture from object-oriented systems\n", "abstract": " Software architecture modeling and representation became a main phase of the development process of complex systems. In fact, software architecture representation provides many advantages during all phases of software life cycle. Nevertheless, for many systems, like legacy or eroded ones, there is no available representation of their architectures. In order to benefit from this representation, we propose, in this paper, an approach called ROMANTIC which focuses on extracting a component-based architecture of an existing object-oriented system. The main idea of this approach is to propose a quasi-automatic process of architecture recovery based on semantic and structural characteristics of software architecture concepts.", "num_citations": "48\n", "authors": ["2190"]}
{"title": "Evolution shelf: reusing evolution expertise within component-based software architectures\n", "abstract": " Despite that reuse libraries are now well adopted during software development step, software evolution step is not yet covered by this kind of beneficial approach. In this paper we present the \"evolution shelf\", a generic infrastructure to achieve for-reuse and by-reuse techniques within the field of software evolution. The basic idea behind that is to propose and encourage the reuse of recurring and reliable evolution expertises to achieve the structural evolution of a software system at the architectural level. For that purpose, the shelf assists architects in classifying, storing and selecting reusable architectural evolution operations. The underlying concept that we propose to capitalize the expertises is called \"evolution style\" and it mixes a syntactic and a semantic description format. These ideas form a core for a long-term vision in which it is possible to build a business model of evolution-of-the-shelf (EOTS) with the\u00a0\u2026", "num_citations": "29\n", "authors": ["2190"]}
{"title": "Service identification based on quality metrics object-oriented legacy system migration towards soa\n", "abstract": " Migrating towards Service Oriented Architecture SOA has become a major topic of interest during the recent years. Since emerging service technologies have forced non-service based software systems to become legacy, many efforts and researches have been carried out to enable these legacy systems to survive. In this context, several service identification solutions have been proposed. These approaches are either manual, thus considered expensive, or rely on ad-hoc criteria that fail to identify relevant services. In this paper, within the big picture of migrating object-oriented legacy systems towards SOA, we address automatic service identification from source code based on service quality characteristics. To achieve this, we propose a quality measurement model where characteristics of services are refined to measurable metrics.", "num_citations": "26\n", "authors": ["2190"]}
{"title": "Feature location in a collection of product variants: Combining information retrieval and hierarchical clustering\n", "abstract": " Locating source code elements relevant to a given fea- ture is an important step in the process of re-engineering software variants, developed by an ad-hoc reuse technique, into a Software Product Line (SPL) for systematic reuse. Existing works on using Information Retrieval (IR) tech- niques do not consider the abstraction gap between feature and source code levels. In our recent work, we have im- proved the effectiveness of IR-based feature location by in- troducing an intermediate level between feature and source code levels, called \u201ccode-topics\u201d. We used Formal Con- cept Analysis (FCA) to identify such \u201ccode-topics\u201d. In this paper, we investigate the results of using Agglomerative Hierarchical Clustering (AHC) algorithm to identify code- topics. In our experimental evaluation, we show that AHC significantly increases the recall of feature location with a minor decrease of precision compared to FCA.", "num_citations": "25\n", "authors": ["2190"]}
{"title": "Evolution styles to the rescue of architectural evolution knowledge\n", "abstract": " The core idea is to consider software-architecture evolution tasks as a knowledge that must be clearly modeled and properly managed. The main expected benefit is the reuse of existing and already available evolution expertise rather than reinventing it, sometimes awkwardly and thus avoid time-consuming redundant evolution activities. For this purpose, we propose to use the evolution style concept as a neutral interchange format to capitalize and transfer knowledge about domain-specific evolution tasks. In this paper we put the focus on how it is possible to reason on evolution-styles description libraries through a classification scheme. Specifically, we present the\" evolution shelf\", an infrastructure to perform (a) incremental acquisition of new evolution descriptions and (b) retrieval of evolution descriptions matching with a given context. Our shelf, dedicated to software architects, relies on well-known repository\u00a0\u2026", "num_citations": "24\n", "authors": ["2190"]}
{"title": "Mining reusable software components from object-oriented source code of a set of similar software\n", "abstract": " One of the most important approaches that support software reuse is Component Based Software Engineering (CBSE). Nevertheless the lack of component libraries is one of the major obstacles to widely use CBSE in the industry. To help filling this need, many approaches have been proposed to identify components from existing object-oriented software. These approaches identify components from singular software. Therefore the reusability of these components may be limited. In this paper, we propose an approach to mine reusable components from a set of similar object-oriented software, which were developed in the same domain, ideally by the same developers. Our goal is to enhance the reusability of mined components compared to those mined from single software. In order to validate our approach, we have applied it onto two open source Java applications of different sizes; small and large-scale ones\u00a0\u2026", "num_citations": "21\n", "authors": ["2190"]}
{"title": "Quality-driven extraction of a component-based architecture from an object-oriented system\n", "abstract": " Software architecture modeling and representation became a main phase of the development process of complex systems. In fact, software architecture representation provides many advantages during all phases of software life cycle. Nevertheless, for many systems, like legacy or eroded ones, there is no available representation of their architectures. In order to benefit from this representation, we propose, in this paper, an approach called ROMANTIC which focuses on extracting the architecture of an object-oriented system. The main idea of this approach is to propose a quasi-automatic process of architecture recovery based on the quality characteristics of an architecture by formulating it as a search-based problem. This last acts on the space composed of all possible architectures abstracting the object-oriented system.", "num_citations": "20\n", "authors": ["2190"]}
{"title": "Comparing and combining genetic and clustering algorithms for software component identification from object-oriented code\n", "abstract": " Software component identification is one of the primary challenges in component based software engineering. Typically, the identification is done by analyzing existing software artifacts. When considering object-oriented systems, many approaches have been proposed to deal with this issue by identifying a component as a strongly related set of classes. We propose in this paper a comparison between the formulations and the results of two algorithms for the identification of software components: clustering and genetic. Our goal is to show that each of them has advantages and disadvantages. Thus, the solution we adopted is to combine them to enhance the results.", "num_citations": "18\n", "authors": ["2190"]}
{"title": "Component-based architecture recovery from object oriented systems via relational concept analysis\n", "abstract": " Software architecture modelling and representation has become an important phase of the development process of complex software systems. Using software architecture representation as a high level view provides many advantages during all phases of the software life cycle. Nevertheless, for many systems, such architecture representation is not available. To deal with this problem, we propose in this paper an approach of architecture recovery which aims to extract component-based architecture from an object-oriented (OO) system, by a semi-automatic exploration process. To this end, we use relational concept analysis in order to identify the architectural components. The RCA-based approach comes as a complementary method to relieve some limits of the existing implementation of ROMANTIC based on simulated annealing algorithm. In the RCA approach, architectural components are identified from concepts derived by exploiting all existing dependency relations between classes of the OO system. We evaluated the feasibility of our approach on a Java software.", "num_citations": "17\n", "authors": ["2190"]}
{"title": "Software architecture recovery process based on object-oriented source code and documentation\n", "abstract": " Architecture recovery aims at providing a high level abstraction of a system using the architectural elements to represent functionalities and interactions. This architecture makes easier the program comprehension and then provides many advantages during all the phases of software life cycle. Nevertheless, most architecture recovery approaches fail to combine the human expertise on the system with a high automation level. In order to solve this issue, we propose to use the intentional architecture of a system, which represent the system as imagined by its designers, to improve the adequation between the resulting software architecture and the architect\u2019s expectations without requiring more human expertise. Thus, we present in this paper a semi-automatic process to recover intentional architecture from the available documentation and the expert recommendations. This process is an extension of\u00a0\u2026", "num_citations": "17\n", "authors": ["2190"]}
{"title": "Concept lattices: A representation space to structure software variability\n", "abstract": " Formal Concept Analysis is a theoretical framework which structures a set of objects described by properties. Formal Concept Analysis is a classification technique that takes data sets of objects and their attributes, and extracts relations between these objects according to the attributes they share. This structure reveals and categorizes commonalities and variability in a canonical form. From this canonical form, other structures can be derived, that can be more or less complex. In this paper, we revisit two papers from the literature of the software product line domain. We point to key contributions and limits of the representation of variability by concept lattices, with illustrative examples. We present tools to implement the approach and open a discussion.", "num_citations": "16\n", "authors": ["2190"]}
{"title": "Updating Software Architectures: A Style-Based Approach.\n", "abstract": " Our paper deals with the update of componentbased software architectures, ie all the modifications which can be performed on the architecture\u2019s elements to satisfy various requirements. Current researches on the component-based software engineering propose various mechanisms to adapt, evolve, customize, or reconfigure such architectures. We are convince that these mechanisms, even powerful, still require the architects\u2019 expertises. Moreover, it is noticed that these expertises conform to a style, ie a way of update which privileges certain concerns rather than others. It is what explains why a solution is selected instead of another, for the same main update issue. Our goal is to define updating styles, to represent and reuse update expertises. We wish to use this work to build an environment based on an updating style library in order to assist architects in modifying their componentbased architectures.", "num_citations": "16\n", "authors": ["2190"]}
{"title": "Towards unified aspect-oriented programming\n", "abstract": " Aspect-Oriented Programming (AOP) is a paradigm that aims at improving software modularization. Indeed, aspects are yet another dimension for structuring applications. The notion of aspect refers to any crosscutting property. Such crosscutting can be either dynamic or static. Dynamic crosscutting refers to applications execution flow. While, static crosscutting refers to applications structure. Although many AOP approaches does enable these two kinds of crosscutting, this support is not always satisfactory. Aspects code is complex and often requires different constructs for expressing static and dynamic crosscutting. We present in this paper the foundation for an AOP platform that unifies the description of both kinds of crosscuttings. This solution relies on reflection and mixin-based inheritance. Key words: aspect-oriented programming, static crosscutting, dynamic crosscutting, reflection, mixin-based inheritance 1", "num_citations": "15\n", "authors": ["2190"]}
{"title": "Re-architecting oo software into microservices\n", "abstract": " Due to its tremendous advantages, microservice architectural style has become an essential element for the development of applications deployed on the cloud and for those adopting the DevOps practices. Migrating existing applications to microservices allow them to benefit from these advantages. Thus, in this paper, we propose an approach to automatically identify microservices from OO source code. The approach is based on a quality function that measures both the structural and behavioral validity of microservices and their data autonomy. Unlike existing works, ours is based on a well-defined function measuring the quality of microservices and use the source code as the main source of information.", "num_citations": "14\n", "authors": ["2190"]}
{"title": "Adapting software components by structure fragmentation\n", "abstract": " We present in this paper an approach aiming at adapting software components. It focuses on adapting component structures instead of adapting component services. Among the motivations of this kind of adaptation, we note its possible application to permit flexible deployment of software components and flexible loading of component code according to the available resources (CPU, memory). Our adaptation process is based on the analysis and the instrumentation of component codes. It respects the black-box property when it is implemented as a service provided by the component to be adapted. To support this structural adaptation technique, we developed an adaptation process which we have experimented using the Java framework of the Fractal component model.", "num_citations": "14\n", "authors": ["2190"]}
{"title": "Search-based extraction of component-based architecture from object-oriented systems\n", "abstract": " Software architecture modeling and representation are a main phase of the development process of complex systems. In fact, software architecture representation provides many advantages during all phases of software life cycle. Nevertheless, for many systems, like legacy or eroded ones, there is no available representation of their architectures. In order to benefit from this representation, we propose an approach called ROMANTIC which focuses on extracting a component-based architecture of an existing object-oriented system. This approach considers this problem as a balancing problem of competing constraints which aims to select the best solution among all the possible architectures. Consequently, we present in this paper the identified constraints of this problem and its formulation as a search-based problem.", "num_citations": "13\n", "authors": ["2190"]}
{"title": "From monolithic architecture style to microservice one based on a semi-automatic approach\n", "abstract": " Due to its tremendous advantages, microservice architectural style has become an essential element for the development of applications deployed on the cloud and for those adopting the DevOps practices. Nevertheless, while microservices can be used to develop new applications, there are monolithic ones, that are not well adapted neither to the cloud nor to DevOps. Migrating these applications towards microservices appears as a solution to adapt them to both. In this context, we propose an approach aiming to achieve this objective by focusing on the step of microservices identification. The proposed identification, in this paper, is based on an analysis of the relationships between source code elements, their relationships with the persistent data manipulated in this code and finally the knowledge, often partial, of the architect concerning the system to migrate. A function that measures the quality of a microservice\u00a0\u2026", "num_citations": "11\n", "authors": ["2190"]}
{"title": "Adaptation of monolithic software components by their transformation into composite configurations based on refactoring\n", "abstract": " We present in this paper an approach aiming at adapting component structures instead of adapting component services. It focuses on transforming a software component from a monolithic configuration to a composite one. Among the motivations of this kind of adaptation, we note its possible application to permit flexible deployment of software components and flexible loading of component service-code according to the available resources (CPU, memory). This adaptation is based on the analysis and the instrumentation of component codes.", "num_citations": "10\n", "authors": ["2190"]}
{"title": "Separation of concerns in software architecture via a multiviews description\n", "abstract": " During this last decade, several architecture description languages (ADLs) have been proposed. These ADLs provide an adequate framework for the specification of software systems in terms of components and connectors. In this paper, we deal with an advanced facet of software architecture description. Our aim is to describe at the architectural level the separation of concerns. This is done in a formal way. Thus, we propose a model for architecture description based on the view concept.", "num_citations": "9\n", "authors": ["2190"]}
{"title": "Feature Model Extraction from Product Source Codes based on the Semantic Aspect.\n", "abstract": " Software Product Lines can be constructed through either a top-down or bottom-up process. A top-down process begins by a domain analysis where variabilities are specified then it derives the product line. It is especially interesting for the creation of new product lines. However, in practice, SPL are often set up after several similar product variants have been in use. This practice prompted the search for bottom-up processes that start from an analysis of existing product variants to identify the product line. The proposed bottom-up processes rely on two hypotheses: the product variants use the same vocabulary to name elements in their source code, and the product variants have very similar/identical structures. However, while the names represent the application domain of the products, when different developers were involved in the development of the product variants, the naming assumption becomes too restrictive. Furthermore, the variants\u2019 code structures are often different when developed separately and even when one variant is derived from another through several modifications. To loosen these two hypotheses, this paper proposes a bottom-up approach that integrates the semantic aspect of the product variants when extracting the SPL feature model. In addition, a second contribution of our approach is its capability to identify automatically the constraints among the identified features.", "num_citations": "8\n", "authors": ["2190"]}
{"title": "Exploration de la redistribution des classes d'un package par des techniques d'Analyse Formelle de Concepts\n", "abstract": " Du fait de l'\u00e9volution in\u00e9vitable des logiciels, leur structure, qui se compose principalement d'abstractions modulaires telles que les packages s'\u00e9rode plus ou moins lentement. Lutter contre cette \u00e9rosion et remodulariser le logiciel est une question qui se d\u00e9cline sous plusieurs formes. Dans cet article nous nous int\u00e9ressons \u00e0 l'exploration de la redistribution des classes d'un package vers d'autres packages. Nous utilisons une approche bas\u00e9e sur des techniques d'Analyse Formelle de Concepts pour d\u00e9terminer les packages receveurs des classes redistribu\u00e9es.", "num_citations": "8\n", "authors": ["2190"]}
{"title": "Evolution approaches towards a Service oriented architecture\n", "abstract": " Over a decade, Service-oriented architectures (SOA) have seen an increasing interest of both academia and industry communities. This interest is associated with an enthusiasm of companies in different sectors and sizes for the adoption of this new paradigm due to its economic and technological benefits. SOA is a very effective response to the problems faced by companies in terms of reusability, interoperability and reduce coupling between systems that implement their information systems. To exploit these advantages many organizations have decided to evolve their legacy systems (LS) towards this architecture. Migration to SOA has become one of the most important modernizations technic of LS. It helps organizations, on the one hand, to reuse their existing LS by giving them a new life, and also to enjoy the benefits of service-based systems. In the literature, several approaches exist for evolving LS towards\u00a0\u2026", "num_citations": "8\n", "authors": ["2190"]}
{"title": "Dynamic adaptation of software component structures\n", "abstract": " We present in this paper an approach aiming at dynamically adapting a component structure while preserving its behavior and its services. Among the motivations of this kind of adaptation, we note its possible application to allow a dynamic redeployment of component services according to the available resources (e.g. CPU, memory). The run-time software component structural adaptation process is based on two phases. The first one consists in transforming this component by generating a dynamically adaptable component structure. This transformation is based on the analysis and the instrumentation of component code. The second phase of the adaptation process allows us to adapt the component dynamically by the reconfiguration of its internal structure", "num_citations": "8\n", "authors": ["2190"]}
{"title": "Reconfigurable service-based architecture based on variability description\n", "abstract": " Self-adaptive systems evolve during system's execution against changes in operating environment. Such evolution and reconfiguration can be specified at architecture level using a syntactical expressive language such as Architecture Description Languages (ADLs). Variability modeling is an excellent instrument to model variations of software artifacts and their behavior within a self-adaptive system. However, existing ADLs that support dynamic reconfiguration do not explicitly model variation points on which the reconfiguration is based. This constitutes a barrier for a flexible management of reconfiguration at architecture level as well as traceability issues between a dynamic description given at architectural level and its counterpart at other abstraction levels. In this paper, we propose a variant-rich service-oriented ADL that enables system to reconfigure itself at runtime in response to a context change. To this end\u00a0\u2026", "num_citations": "7\n", "authors": ["2190"]}
{"title": "An architecture description language for dynamic service-oriented product lines\n", "abstract": " Reconciling Software Product Lines (SPL) and Service Oriented Architecture (SOA) allows modeling and implementing systems that systematically adapt their behavior in respond to surrounding context changes. Both approaches are complementary with regard to the variability and the dynamicity properties. Architecture Description Language (ADL), on the other hand, is recognized as an important element in the description and analysis of software properties. Different ADLs have been proposed in SOA or in SPL domains. Nevertheless, none of these ADLs allows describing variability and dynamicity features together in the context of service-oriented dynamic product lines. In this sense, our work attempts to describe the changing architecture of Dynamic Service-Oriented Product Lines (DSOPL). We propose an ADL that allows describing three types of information: architecture's structural elements, variability elements and system\u2019s configuration. Furthermore, we introduce context elements on which service reconfiguration is based.", "num_citations": "7\n", "authors": ["2190"]}
{"title": "Software component re-engineering for their runtime structural adaptation\n", "abstract": " Adapting software components to be used in a particular application is a crucial issue in software component-based technology. In fact, software components can be used in contexts with characteristics different from those envisaged when designing the component. To deal with this issue, we propose in this paper an approach aiming at adapting a software component structure in order to preserve service continuity. This adaptation, achieved by component fragmentation, allows its structure reconfiguration and its redeployment while preserving its behavior and its services. The structural adaptation process is based on two phases. The first one consists of the component re-engineering in order to introduce runtime adaptation facilities. The second phase, achieved since runtime, aims at reconfiguring the component structure according to the user needs.", "num_citations": "7\n", "authors": ["2190"]}
{"title": "Comparative analysis of object-oriented software maintainability prediction models\n", "abstract": " Software maintainability is one of the most important aspects when evaluating the quality of a software product. It is defined as the ease with which the existing software can be modified. In the literature, several researchers have proposed a large number of models to measure and predict maintainability throughout different phases of the Software Development Life Cycle. However, only a few attempts have been made for conducting a comparative study of the existent proposed prediction models. In this paper, we present a detailed classification and conduct a comparative analysis of Object-Oriented software maintainability prediction models. Furthermore, we considered the aforementioned proposed models from three perspectives, which are architecture, design and code levels. To the best of our knowledge, such an analysis that comprises the three levels has not been conducted in previous research. Moreover, this study hints at certain fundamental basics concerning the way of how measure the maintainability knowing that at each level the maintainability will be measured differently. In addition, we will focus on the strengths and weaknesses of these models. Consequently, the comparative study yields that several statistical and machine learning techniques have been employed for software maintainability prediction at code level during the last decade, and each technique possesses its specific characteristic to develop an accurate prediction model. At the design level, the majority of the prediction models measured maintainability according to the characteristics of the quality models. Whereas at the architectural level, the techniques adopted\u00a0\u2026", "num_citations": "6\n", "authors": ["2190"]}
{"title": "A self-adaptation of software component structures in ubiquitous environments\n", "abstract": " The creation of applications able to be executed in ubiquitous environments, involves a better consideration of the execution context in order to ensure service continuity. In component-based software engineering, applications are built by assembling existing components. For deploying such applications in ubiquitous environments, its components must be able to adapt themselves to the current context. To deal with this issue, we propose in this paper an approach aiming at reconfiguring the component structure to allow a flexible deployment of its services according to its use context. This adaptation focusing on the service continuity, consists of determining a structure adapted to the execution context. Then, the current structure is automatically reconfigured and the generated components are redeployed.", "num_citations": "6\n", "authors": ["2190"]}
{"title": "Transformation of centralized software components into distributed ones by code refactoring\n", "abstract": " Adapting software components to be used in a particular application is a crucial issue in software component based technology. In fact, software components can be used in contexts with characteristics different from those envisaged when designing the component. Centralized or distributed deployment infrastructure can be one of these assumptions. Thus, a component can be designed as a monolithic unit to be deployed on a centralized infrastructure, nevertheless the used infrastructure needs the component to be distributed. In this paper, we propose an approach allowing to transform a centralized software component into a distributed one. Our technique is based on refactoring and fragmentation of component source code.", "num_citations": "6\n", "authors": ["2190"]}
{"title": "Query reification based approach for object-oriented query formulation aid\n", "abstract": " We propose an approach facilitating query formulation for users sharing a common database. Our approach is based on two considerations. On the one hand, query formulation can be considered as a skill which can be shared entirely or partly between users. Accordingly we propose a model for storing and making available this skill to help users formulate their new queries. On the other hand we base our design on custom construction of a database adapted to each business group of users in question. In using it, the users of a given business cooperate transparently through their queries to design databases specific to their business. Thus, they take part co-operatively if indirectly in reducing the difficulty of query formulation.", "num_citations": "6\n", "authors": ["2190"]}
{"title": "Genetic Algorithms as a Recovering Traceability Links Method between Feature Models and Source Code of Product Variants\n", "abstract": " \u2212 In our case chromosome is a partition as shown.\u2212 Partition is a set of clusters.\u2212 Each cluster is composed of a set of classes that correspond to some feature.\u2212 Any cluster represents a gene (in GAs terminology)\u2212 Number of clusters in each partition refers to number of all product variants features.", "num_citations": "5\n", "authors": ["2190"]}
{"title": "A reuse-driven approach to update component-based software architectures\n", "abstract": " As the maintenance of software architectures emerges as a discipline within software engineering, it becomes increasingly important to propose new approaches to manage and facilitate it. In this paper we propose and describe the updating style as a reusable unit filling the gap between full-reusable solution and full-usable ones. Our updating styles aims at capitalizing update expertise, or know-hows, within component-based architectures for use and re-use purposes. An updating style is a family of update procedures dedicated to a business domain, sharing common tasks that have to be performed in the quite same order, to update a software architecture in a proven and safe way. The primary ideas of this research are: (a) an updating style is a building block to create increasingly complex update procedures by reuse; (b) an updating style is expressed on an architectural family, whose specific update\u00a0\u2026", "num_citations": "5\n", "authors": ["2190"]}
{"title": "Proposition pour la mod\u00e9lisation d'applications ubiquitaires\n", "abstract": " Archive ouverte HAL - Proposition pour la mod\u00e9lisation d'applications ubiquitaires Acc\u00e9der directement au contenu Acc\u00e9der directement \u00e0 la navigation Toggle navigation CCSD HAL HAL HALSHS TEL M\u00e9diHAL Liste des portails AUR\u00e9HAL API Data Documentation Episciences.org Episciences.org Revues Documentation Sciencesconf.org Support hal Accueil D\u00e9p\u00f4t Consultation Les derniers d\u00e9p\u00f4ts Par type de publication Par discipline Par ann\u00e9e de publication Par structure de recherche Les portails de l'archive Recherche Documentation hal-00714177, version 1 Communication dans un congr\u00e8s Proposition pour la mod\u00e9lisation d'applications ubiquitaires Olivier Caron 1 Bernard Carr\u00e9 1, 2 Christophe Gransart Xavier Le Pallec 2 Sylvain Lecomte 3 Rapha\u00ebl Marvie 1, 2 Mirabelle Nebut 4 Abdelhak-Djamel Seriai 5 Gilles Vanwormhoudt 1, 2 D\u00e9tails 1 COCOA - Composition de mod\u00e8les pour l'ing\u00e9nierie logicielle \u2026", "num_citations": "5\n", "authors": ["2190"]}
{"title": "A Genetic Approach for Software Architecture Recovery from Object-Oriented Code.\n", "abstract": " Software architecture is recognized as a critical element in the successful development and evolution of softwareintensive systems. Despite the important role of architecture representation and modeling many existing systems like legacy or eroded ones do not have a reliable architecture representation. In this paper we present an approach for architecture recovery from object-oriented code. It\u2019s based on a genetic algorithm which uses a fitness function measuring the semantic-correctness of software components. Following our model, architecture which is a partition of classes is considered as a chromosome. A group of classes is a gene. This algorithm gives satisfactory results in terms of consistency and adequacy metrics.", "num_citations": "4\n", "authors": ["2190"]}
{"title": "Auto-adaptation de composants logiciels. M\u00e9canismes d'auto-adaptation de la structure de composants appliqu\u00e9s aux environnements ubiquitaires\n", "abstract": " The creation of information systems able to be executed in ubiquitous environments, involves a better taking into account of the runtime context in order to ensure service continuity. However, in component-based software engineering, information systems are built by assembling standalone components which must adapt themselves to the current context. To deal with this issue, we propose in this paper an approach aiming at generating a selfadaptive software component from a standalone component. This property allows the component to adapt its structure according its use context.", "num_citations": "4\n", "authors": ["2190"]}
{"title": "Reusing platform-specific models in model-driven architecture for software product lines\n", "abstract": " One of the main concerns of software engineering is the automation of reuse in order to produce high quality applications in a faster and cheaper manner. Model-Driven Software Product Line Engineering is an approach providing solutions to systematically and automatically reuse generic assets in software development. More specifically, some solutions improve the product line core assets reusability by designing them according to the Model-Driven Architecture approach. However, existing approaches provide limited reuse for platform-specific assets. In fact, platform-specific variability is either ignored or only partially managed. These issues interfere with gains in productivity provided by reuse. In this paper, we first provide a better understanding of platform-specific variability by identifying variation points in different aspects of a software based on the well-known \"4+1\" view model categorization. Then we propose to fully manage platform-specific variability by building the Pl atform-Specific-Model using two sub-models: the Cross-Cutting Model, which is obtained by transformation of the Platform-Independent Model, and the Application Structure Model, which is obtained by reuse of variable platform-specific assets. The approach has been experimented on two concrete applications. The obtained results confirm that our approach significantly improves the productivity of a product line.", "num_citations": "3\n", "authors": ["2190"]}
{"title": "Updating styles challenge updating needs within component-based software architectures\n", "abstract": " The modification of the elements of a component-based software architecture is necessary to meet new needs and new situations usually unpredictable. All these modifications are summarized as updates, and cover the usual notions of evolution, adaptation, customization or reconfiguration. There are several solutions to update architectures. A solution often requires a strong expertise and is stylized because it privileges a strategy rather than another. Since there are recurring problems and recurring solutions, we propose in this paper the updating styles as pseudo-formal entities, to specify the stylized expertises, to use and re-use them. Later, we aim to build an environment based on a library of updating styles, to assist architects\u00a0~in modifying their component-based architectures.", "num_citations": "3\n", "authors": ["2190"]}
{"title": "Framework for query formulation aid in a multi-user environment\n", "abstract": " Mourad Oussalah and Abdelhak Seriai Site EERIE/LGI2P de l'EMA Pare Scientifique G. BESSE 30035 Ntmes cedex 1 France Fax:+ 33 4 66 38 70 74 E-mail:(oussalah, seriai)@ eerie. fr", "num_citations": "3\n", "authors": ["2190"]}
{"title": "Refactoring monolithic object-oriented source code to materialize microservice-oriented architecture\n", "abstract": " The emergence of the microservice-oriented architecture (MSA) has led to increased maintainability, better readability, and better scalability. All these advantages make migrating a monolithic software towards an MSA an attractive prospect for organizations. The migration process is recognized to be complex and consequently risky and costly. This process is composed of two phases:(1) the microservice-based architecture recovery phase and (2) the transformation (ie materialization) phase. In this paper, we propose a systematic approach to transform an object-oriented monolithic application towards an MS-oriented one by applying a set of transformation pattern. To validate our approach we automated it with our tool MonoToMicro, and applied it on a set of monolithic Java applications to be migrated towards microservices-based ones.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "Evolution Shelf: Exploiting Evolution Styles within Software Architectures.\n", "abstract": " Despite that reuse libraries are now well adopted during software development step, software evolution step is not yet covered by this kind of beneficial approach. In this paper we present the \u201cevolution shelf\u201d, a generic infrastructure to achieve for-reuse and by-reuse techniques within the field of software evolution. The basic idea behind that is to propose and encourage the reuse of recurring and reliable expertises to achieve the structural evolution of a software system at the architectural level. For that purpose, the shelf assists architects in classifying, storing and selecting reusable architectural evolutions. The underlying concept that we propose to capitalize the expertises is called \u201cevolution style\u201d, mixing a syntactic and a semantic description format. These ideas form a core for a long-term vision in which it is possible to build a business model of evolutionoff-the-shelf (EOTS) with the special objective to decrease the efforts and the risks related to the evolution activities.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "Extraction d'Architecture \u00e0 Base de Composants d'un Syst\u00e8me Orient\u00e9 Objet.\n", "abstract": " Disposer d\u2019une repr\u00e9sentation de l\u2019architecture d\u2019un syst\u00e8me complexe est devenue essentiel pendant toutes les phases du cycle de vie du logiciel. Cependant pour beaucoup de syst\u00e8mes, aucune repr\u00e9sentation fiable de leurs architectures n\u2019est disponible. Afin de palier cette absence, source de nombreuses difficult\u00e9s, nous proposons, dans cet article une approche visant \u00e0 extraire une architecture \u00e0 base de composants \u00e0 partir d\u2019un syst\u00e8me orient\u00e9 objet existant. L\u2019id\u00e9e premi\u00e8re de cette approche est de proposer un processus semi-automatis\u00e9 d\u2019identification des composants d\u2019un syst\u00e8me en se basant sur leurs caract\u00e9ristiques s\u00e9mantiques et structurelles. Nous proposons une approche quantitative de ces caract\u00e9ristiques.ABSTRACT. Having a representation of the architecture of complex systems became predominant during all the software life cycle phases. However, for many systems, there is no reliable representation of their architectures available. In order to avoid this lack which causes many difficulties, we suggest, in this paper, an approach aiming at extracting component-based architectures from object-oriented systems. The main idea of this approach is to propose a semi-automated identification process of components based on their semantic and structural characteristics.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "Evolution dirig\u00e9e par les styles\n", "abstract": " Dans cet article nous re-examinons l'\u00e9volution comme une activit\u00e9 pouvant \u00eatre simplifi\u00e9e et acc\u00e9l\u00e9r\u00e9e par le respect d'arch\u00e9types pr\u00e9d\u00e9finis, appel\u00e9s styles d'\u00e9volution. Les styles d'\u00e9volution favorisent et encouragent la r\u00e9utilisation des savoir-faire et soutiennent ainsi une \"\u00e9volution de masse'' en les rendant imm\u00e9diatement disponibles. Cette \u00e9volution sur \u00e9tag\u00e8re se veut \u00eatre un \u00e9cho \u00e0 l'industrialisation de la production du logiciel. Nous travaux visent \u00e0 proposer un cadre conceptuel uniforme o\u00f9 les bonnes pratiques d'\u00e9volution peuvent \u00eatre captur\u00e9es dans des styles et par la suite appliqu\u00e9es \u00e0 des situations concr\u00e8tes.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "How To Generate Distributed Software Components From Centralized Ones?\n", "abstract": " Adapting software components to be used in a particular application is a crucial issue in software component based technology. In fact, software components can be used in contexts with characteristics different from those envisaged when designing the component. Centralized or distributed deployment infrastructure can be one of these assumptions. Thus, a component can be designed as a monolithic unit to be deployed on a centralized infrastructure, nevertheless the used infrastructure needs the component to be distributed. In this paper, we propose an approach allowing us to transform a centralized software component into a distributed one. Our technique is based on refactoring and fragmentation of component source-code.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "Commode: Un modele d\u2019adaptation structurelle pour les composants logiciels\n", "abstract": " Nous proposons dans cet article un nouveau type d\u2019adaptation appliqu\u00e9e aux composants logiciels: l\u2019adaptation structurelle. Au contraire des approches d\u2019adaptation existantes o\u00f9 l\u2019objectif est de mettre \u00e0 jour les services ou le comportement des composants, l\u2019adaptation structurelle vise plut\u00f4t \u00e0 mettre \u00e0 jour la structure de ces composants. Les applications de ce type d\u2019adaptation peuvent \u00eatre, par exemple, l\u2019adaptation du d\u00e9ploiement par rapport \u00e0 la configuration de l\u2019infrastructure sous-jacente ou l\u2019adaptation de l\u2019ex\u00e9cution par rapport aux ressources disponibles (CPU, m\u00e9moire). Nous avons d\u00e9velopp\u00e9 un processus et un mod\u00e8le de composants logiciels supportant l\u2019adaptation structurelle statique et pouvant \u00eatre \u00e9tendus pour supporter l\u2019adaptation dynamique. L\u2019\u00e9tude th\u00e9orique a \u00e9t\u00e9 r\u00e9alis\u00e9e en s\u2019 appuyant sur le mod\u00e8le UML2. Cette approche a \u00e9t\u00e9 transpos\u00e9e dans le mod\u00e8le de composant Fractal puis impl\u00e9ment\u00e9e en utilisant la plate-forme Julia.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "Code Generation from Architectural Multiviews Description.\n", "abstract": " The software architecture of a system defines its high-level structure, exposing its gross organization as a collection of interacting components. It typically plays a key role as a bridge between requirements and code. Practitioners have come to realize that having a good architectural design is a critical success factor for complex system development. To improve design at architectural level, we have proposed a description model based on the view notion. Through this model, it is possible to describe both components and connectors according to several views. In this paper, we deal with the code generation from architectural specification obtained via our multiviews description model.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "An object-oriented representation and reasoning model to rewriting queries using views\n", "abstract": " We propose in this article an object-oriented approach to rewriting queries using views. Our approach aims to mitigate certain limitations of existing query rewriting approaches. Among these limitations, the inconsideration of certain types of object-oriented complex queries or the lack of uniformity of this approaches compared to the object-oriented model.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "How to reuse former queries to facilitate the formulation of new ones\n", "abstract": " Query formulation remains obstinately difficult for large classes of users. Indeed, in face of the growth in query complexity due to development of new kind of application manipulating great size of data, we notice the absence of models taking charge of the user through from specification of needs to formulation of queries. We think that users can be given effective help in query formulation by means of re-using former queries. Indeed, the objective of this work is to propose a method of assisting users to formulate queries by accessing and re-using existing ones. It consists of making available to users query components plus a strategy for re-using them. The approach developed here lies within the scope of re-use development environments. The model developed incorporates knowledge defining query components and ways to select, adapt or combine them to meet particular requirements.", "num_citations": "2\n", "authors": ["2190"]}
{"title": "QUERYAID: a query formulation model for and by reuse\n", "abstract": " In database or knowledge-base systems, query formulation languages are the means offered to users for accessing data or knowledge. Queries allow selection of data under particular, either simple or complex constraints, resulting from one or several structures. However, query formulation remains obstinately difficult for large classes of users. Indeed, with the exception of approaches facilitating syntax problems, there is a noticeable absence of models taking charge of the user through specification of their needs to formulation of their queries. In the case of object-oriented database systems, whose data models and concepts are more complex than those of relational databases, database users need assistance with several kinds of formulation problems. In this respect, we consider that the storage and reuse of former queries constitutes a promising avenue of investigation. We take a novel look at object-oriented\u00a0\u2026", "num_citations": "2\n", "authors": ["2190"]}
{"title": "Combining Model-Driven Architecture and Software Product Line Engineering: Reuse of Platform-Specific Assets\n", "abstract": " Reuse automation is a main concern of software engineering to produce high quality applications in a faster and cheaper manner. Some approaches define cross-platform model-driven software product lines to systematically and automatically reuse generic assets in software development. They improve the product line assets reusability by designing them according to the Model-Driven Architecture specifications. However, their reuse of platform-specific assets is limited due to an inefficient platform-specific variability management. This issue interfere with gains in productivity provided by reuse.             In this paper, we define platform-specific variability by identifying variation points in different software concerns based on the well-known \u201c4+1\u201d view model categorization. Then, we fully manage platform-specific variability by structuring the Platform-Specific Model using two sub-models: the Cross-Cutting\u00a0\u2026", "num_citations": "1\n", "authors": ["2190"]}
{"title": "VASCO: Variability Specification in Business Process Models\n", "abstract": " Due to environmental factors influencing their business, information technology plays now a key role in competitiveness of enterprises. Software editors concerned by developing enterprise information systems are irreversibly affected with industrialization of reuse, in order to produce faster, better and cheaper. Software product line approach offers techniques to increase and automate reuse, by explicitly specifying and managing the common and variable features. Business processes constitute a key lever to accelerate strategic alignment and urbanization of enterprise information systems. Thus, variability should be expressed in business process models, with the aim of helping enterprises to overcome environmental fluctuations and editors to industrialize their production. Several models have been proposed to represent variable business processes, but they are far from being directly usable (operational\u00a0\u2026", "num_citations": "1\n", "authors": ["2190"]}
{"title": "QUEROM: An Object-Oriented Model to Rewriting Query Using Views.\n", "abstract": " We propose in this article an object-oriented approach to rewriting queries using views. Our approach aims to mitigate certain limitations of existing query rewriting approaches. Among these limitations, the inconsideration of certain types of object-oriented complex queries or the lack of uniformity of this approaches compared to the object-oriented model. The proposed approach is based, on one hand, on an object-oriented representation model of queries and, on other hand, on the object-oriented classification mechanism to determine queries containment. In fact, classes representing queries defining existing views are organized in an inheritance hierarchy. Then, classification in this inheritance hierarchy of a class representing a query is exploited to generate possible rewritings of this query.", "num_citations": "1\n", "authors": ["2190"]}
{"title": "A reuse based object-oriented framework towards flexible formulation of complex queries\n", "abstract": " Query formulation remains obstinately difficult for large classes of users. Indeed, with the exception of approaches facilitating syntax problems, there is a noticeable absence of models taking charge of the user through from specification of their needs to formulation of their queries. In this article, we take a novel look to object-oriented queries \u2014 reifying the ones which users formulate as components then reusing them, by means of strategies for selecting, assembling and adapting them to help in the formulation of new complex queries.", "num_citations": "1\n", "authors": ["2190"]}
{"title": "A reuse-based object-oriented framework towards easy formulation of complex queries\n", "abstract": " Corollary to the development of new kinds of application - like decision support ones - manipulating large quantities of data structured in new kinds of data supports -like data warehouses, queries formulated to access this data have been growing in their complexity. However, with the exception of approaches facilitating syntax problems, there is a noticeable absence of models taking charge of the user through from specification of their needs to formulation of their queries. In the case of object-oriented database systems, whose data models and concepts are more complex than those of relational databases, database users need assistance with several kind of formulation problems. In this article, we take a novel look at object-oriented queries - reifying the ones which users formulate as components then reusing them, by means of strategies for selecting, assembling and adapting them to help in the\u00a0\u2026", "num_citations": "1\n", "authors": ["2190"]}