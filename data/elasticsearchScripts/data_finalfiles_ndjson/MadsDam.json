{"title": "CTL\u2217 and ECTL\u2217 as fragments of the modal \u03bc-calculus\n", "abstract": " Direct embeddings of the full branching-time CTL\u2217 and its extension ECTL\u2217 into the modal \u03bc-calculus are presented. The embeddings use tableaux as intermediate representations of formulas, and use extremal fixed points to characterise those paths through tableaux that satisfy an admissibility criterion, guaranteeing eventualities to be eventually satisfied. The version of ECTL\u2217 considered replaces the entire linear-time fragment of CTL\u2217 by B\u00fcchi automata on infinite strings. As a consequence the embedding of ECTL\u2217 turns out to be computable in linear time, while the embedding of CTL\u2217 is doubly exponential in the worst case.", "num_citations": "267\n", "authors": ["1754"]}
{"title": "Model checking mobile processes\n", "abstract": " We introduce a temporal logic for the polyadic\u03c0-calculus based on fixed point extensions of Hennessy\u2013Milner logic. Features are added to account for parametrisation, generation, and passing of names, including the use, following Milner, of dependent sum and product to account for (unlocalised) input and output, and explicit parametrisation on names using\u03bb-abstraction and application. The latter provides a single name binding mechanism supporting all parametrisation needed. A proof system and decision procedure is developed based on Stirling and Walker's approach to model checking the modal\u03bc-calculus using constants. One difficulty, for both conceptual and efficiency-based reasons, is to avoid the explicit use of the\u03c9-rule for parametrised processes. A key idea, following Hennessy and Lin's approach to deciding bisimulation for certain types of value-passing processes, is the relativisation of correctness\u00a0\u2026", "num_citations": "133\n", "authors": ["1754"]}
{"title": "Constrained delegation\n", "abstract": " Sometimes it is useful to be able to separate management of a set of resources, and access to the resources themselves. However, current accounts of delegation do not allow such distinctions to be easily made. We introduce a new model for delegation to address this issue. The approach is based on the idea of controlling the possible shapes of delegation chains. We use constraints to restrict the capabilities at each step of delegation. Constraints may reflect e.g. group memberships, timing constraints, or dependencies on external data. Regular expressions are used to describe chained constraints. We present a number of example delegation structures, based on a scenario of collaborating organisations.", "num_citations": "129\n", "authors": ["1754"]}
{"title": "A generic protocol for network state aggregation\n", "abstract": " Aggregation functions, which compute global parameters, such as the sum, minimum or average of local device variables, are needed for many network monitoring and management tasks. As networks grow larger and become more dynamic, it is crucial to compute these functions in a scalable and robust manner. To this end, we have developed GAP (Generic Aggregation Protocol), a novel protocol that computes aggregates of device variables for network management purposes. GAP supports continuous estimation of aggregates in a network where local state variables and the network graph may change. Aggregates are computed in a decentralized way using an aggregation tree. We have performed a functional evaluation of GAP in a simulation environment and have identified configuration choices that potentially allow us to control the performance characteristics of the protocol.", "num_citations": "113\n", "authors": ["1754"]}
{"title": "On the Structure of Inductive Reasoning: Circular and Tree-Shaped Proofs in the \u03bcCalculus\n", "abstract": " In this paper we study induction in the context of the firstorder \u03bc-calculus with explicit approximations. We present and compare two Gentzen-style proof systems each using a different type of induction. The first is based on finite proof trees and uses a local well-founded induction rule, while the second is based on (finitely represented) \u03c9-regular proof trees and uses a global induction discharge condition to ensure externally that all inductive reasoning is well-founded. We give effective procedures for the translation of proofs between the two systems, thus establishing their equivalence.", "num_citations": "92\n", "authors": ["1754"]}
{"title": "Robust monitoring of network-wide aggregates through gossiping\n", "abstract": " We investigate the use of gossip protocols for continuous monitoring of network-wide aggregates under crash failures. Aggregates are computed from local management variables using functions such as SUM, MAX, or AVERAGE. For this type of aggregation, crash failures offer a particular challenge due to the problem of mass loss, namely, how to correctly account for contributions from nodes that have failed. In this paper we give a partial solution. We present G-GAP, a gossip protocol for continuous monitoring of aggregates, which is robust against failures that are discontiguous in the sense that neighboring nodes do not fail within a short period of each other. We give formal proofs of correctness and convergence, and we evaluate the protocol through simulation using real traces. The simulation results suggest that the design goals for this protocol have been met. For instance, the tradeoff between estimation\u00a0\u2026", "num_citations": "90\n", "authors": ["1754"]}
{"title": "Formal verification of information flow security for a simple ARM-based separation kernel\n", "abstract": " A separation kernel simulates a distributed environment using a single physical machine by executing partitions in isolation and appropriately controlling communication among them. We present a formal verification of information flow security for a simple separation kernel for ARMv7. Previous work on information flow kernel security leaves communication to be handled by model-external means, and cannot be used to draw conclusions when there is explicit interaction between partitions. We propose a different approach where communication between partitions is made explicit and the information flow is analyzed in the presence of such a channel. Limiting the kernel functionality as much as meaningfully possible, we accomplish a detailed analysis and verification of the system, proving its correctness at the level of the ARMv7 assembly. As a sanity check we show how the security condition is reduced to\u00a0\u2026", "num_citations": "89\n", "authors": ["1754"]}
{"title": "Model checking mobile processes\n", "abstract": " The propositional p-calculus has recently emerged as a powerful instrument for specifying temporal properties of processes (cf Stirling [16]), and model checkers for checking propositional p-calculus properties against finite-state (CCS) processes have been developed and implemented (cf [7, 17, 2]). For most practical applications, however, mechanisms for parameter passing and quantification are invaluable. Based on CCS the~ r-calculus of Milner, Parrow, and Walker [12] has recently been proposed as a way of formally describing mobility in process structures such as mobile telephone networks (Orava, Parrow [13]). In fact the~ r-calculus can well be viewed as a prototypical value passing calculus, a view being reinforced by the capacity of the~ r-calculus to encode data types [9], lambda calculus [10], and higher order processes [14]. As a temporal logic for the 7r-calculus, however, the propositional p-calculus is\u00a0\u2026", "num_citations": "81\n", "authors": ["1754"]}
{"title": "Cache storage channels: Alias-driven attacks and verified countermeasures\n", "abstract": " Caches pose a significant challenge to formal proofs of security for code executing on application processors, as the cache access pattern of security-critical services may leak secret information. This paper reveals a novel attack vector, exposing a low-noise cache storage channel that can be exploited by adapting well-known timing channel analysis techniques. The vector can also be used to attack various types of security-critical software such as hypervisors and application security monitors. The attack vector uses virtual aliases with mismatched memory attributes and self-modifying code to misconfigure the memory system, allowing an attacker to place incoherent copies of the same physical address into the caches and observe which addresses are stored in different levels of cache. We design and implement three different attacks using the new vector on trusted services and report on the discovery of an 128-bit\u00a0\u2026", "num_citations": "75\n", "authors": ["1754"]}
{"title": "On the decidability of process equivalences for the \u03c0-calculus\n", "abstract": " We present general results for showing process equivalences applied to the finite control fragment of the \u03c0-calculus decidable. Firstly, a Finite Reachability Theorem states that up to finite name spaces and up to a static normalisation procedure, the set of reachable agent expressions is finite. Secondly, a Boundedness Lemma shows that no potential computations are missed when name spaces are chosen large enough, but finite. We show how these results lead to decidability for a number of \u03c0-calculus equivalences such as strong or weak, late or early bismulation equivalence. Furthermore, for strong late equivalence we show how our techniques can be used to adapt the well-known Paige-Tarjan algorithm. Strikingly, this results in a single exponential running time not much worse than the running time for the case of for instance CCS. Our results considerably strengthens previous results on decidable\u00a0\u2026", "num_citations": "64\n", "authors": ["1754"]}
{"title": "Abstraction in model checking multi-agent systems.\n", "abstract": " We present an abstraction technique for multi-agent systems preserving temporal-epistemic specifications. We abstract a multi-agent system, defined in the interpreted systems framework, by collapsing the local states and actions of each agent in the system. We show that the resulting abstract system simulates the concrete system, from which we obtain a preservation theorem: If a temporal-epistemic specification holds on the abstract system, the specification also holds on the concrete one. In principle this permits us to model check the abstract system rather than the concrete one, thereby saving time and space in the verification step. We illustrate the abstraction technique with two examples. The first example, a card game, illustrates the potential savings in the cost of model checking a typical MAS scenario. In the second example, the abstraction technique is used to verify a communication protocol with an arbitrarily large data domain.", "num_citations": "59\n", "authors": ["1754"]}
{"title": "Toward parametric verification of open distributed systems\n", "abstract": " A logic and proof system is introduced for specifying and proving properties of open distributed systems. Key problems that are addressed include the verification of process networks with a changing interconnection structure, and where new processes can be continuously spawned. To demonstrate the results in a realistic setting we consider a core fragment of the Erlang programming language. Roughly this amounts to a first-order actor language with data types, buffered asynchronous communication, and dynamic process spawning. Our aim is to verify quite general properties of programs in this fragment. The specification logic extends the first-order \u03bc-calculus with Erlang-specific primitives. For verification we use an approach which combines local model checking with facilities for compositional verification. We give a specification and verification example based on a billing agent which controls and\u00a0\u2026", "num_citations": "59\n", "authors": ["1754"]}
{"title": "Epistemic temporal logic for information flow security\n", "abstract": " Temporal epistemic logic is a well-established framework for expressing agents knowledge and how it evolves over time. Within language-based security these are central issues, for instance in the context of declassification. We propose to bring these two areas together. The paper presents a computational model and an epistemic temporal logic used to reason about knowledge acquired by observing program outputs. This approach is shown to elegantly capture standard notions of noninterference and declassification in the literature as well as information flow properties where sensitive and public data intermingle in delicate ways.", "num_citations": "57\n", "authors": ["1754"]}
{"title": "Provably correct runtime monitoring\n", "abstract": " Runtime monitoring is an established technique for enforcing a wide range of program safety and security properties. We present a formalization of monitoring and monitor inlining, for the Java Virtual Machine. Monitors are security automata given in a special-purpose monitor specification language, ConSpec. The automata operate on finite or infinite strings of calls to a fixed API, allowing local dependencies on parameter values and heap content. We use a two-level class file annotation scheme to characterize two key properties: (i) that the program is correct with respect to the monitor as a constraint on allowed program behavior, and (ii) that the program has an instance of the given monitor embedded into it, which yields state changes at prescribed points according to the monitor\u2019s transition function. As our main application of these results we describe a concrete inliner, and use the annotation scheme to\u00a0\u2026", "num_citations": "52\n", "authors": ["1754"]}
{"title": "A verification tool for Erlang\n", "abstract": " This paper presents an overview of the main results of the project \u201cVerification of ERLANG Programs \u201d, which is funded by the Swedish Business Development Agency (NUTEK) and by Ericsson within the ASTEC (Advanced Software TEChnology) initiative. Its main outcome is the ERLANG Verification Tool (EVT), a theorem prover which assists in obtaining proofs that ERLANG applications satisfy their correctness requirements formulated as behavioural properties in a modal logic with recursion. We give a summary of the verification framework as supported by EVT, discuss reasoning principles essential for successful proofs such as inductive and compositional reasoning, and an efficient treatment of side-effect-free code. The experiences of applying the tool in an industrial case study are summarised, and an approach for supporting verification in the presence of program libraries is outlined.               EVT is\u00a0\u2026", "num_citations": "52\n", "authors": ["1754"]}
{"title": "Confidentiality for mobile code: The case of a simple payment protocol\n", "abstract": " We propose an approach to support confidentiality for mobile implementations of security-sensitive protocols using Java/JVM. An applet which receives and passes on confidential information onto a public network has a rich set of direct and indirect channels available to it. The problem is to constrain applet behaviour to prevent those leakages that are unintended while preserving those that are specified in the protocol. We use an approach based on the idea of correlating changes in observable behaviour with changes in input. In the special case where no changes in (low) behaviour are possible we retrieve a version of noninterference. Mapping our approach to JVM a number of particular concerns need to be addressed, including the use of object libraries for IO, the use of labelling to track input/output of secrets, and the choice of proof strategy. We use the bisimulation proof technique. To provide user feedback\u00a0\u2026", "num_citations": "51\n", "authors": ["1754"]}
{"title": "Relevance logic and concurrent composition\n", "abstract": " We show that the operation of relativising properties with respect to parallel environments often employed in obtaining compositionality in theories for concurrency corresponds to a notion of (contraction\u2014free) relevant deduction. We propose to consider program logics in which this notion of deduction is internalized by means of the corresponding implication. The idea is carried through for safety properties of a simple system of SCCS-type synchronuous processes with an internal choice operator. We present two completeness results; first for a modal extension of positive propositional linear logic wrt the equational class of algebras containing the safety testing quotient of our process system as its free member, and secondly for the free algebra itself.A central problem in successfully applying modal and temporal logics to the development and verification of concurrent programs is somehow to obtain compositionality. We must be able to compose and decompose properties in accordance with model structure [5, 22]. In the context of parallel composition this is often done by some form of \u201cenvironment relativization\u201d[cf. 1, 5, 12, 14, 19, 20] by appealing to potential computations rather than actual ones, and by indexing wrt properties of parallel environments.", "num_citations": "47\n", "authors": ["1754"]}
{"title": "A symmetry reduction technique for model checking temporal-epistemic logic\n", "abstract": " We introduce a symmetry reduction technique for model checking temporal-epistemic properties of multi-agent systems defined in the mainstream interpreted systems framework. The technique, based on counterpart semantics, aims to reduce the set of initial states that need to be considered in a model. We present theoretical results establishing that there are neither false positives nor false negatives in the reduced model. We evaluate the technique by presenting the results of an implementation tested against two well known applications of epistemic logic, the muddy children and the dining cryptographers. The experimental results obtained confirm that the reduction in model checking time can be dramatic, thereby allowing for the verification of hitherto intractable systems.", "num_citations": "45\n", "authors": ["1754"]}
{"title": "Verifying a distributed database lookup manager written in Erlang\n", "abstract": " We describe a case-study in which formal methods were used to verify an important responsiveness property of a distributed database system which is used heavily at Ericsson in a number of recent products. One of the aims of the project was to verify the actual running code which is written in the distributed functional language Erlang. In a joint project between SICS and Ericsson we have over the past few years been developing a tableau-based verification tool for Erlang of considerable scope. In particular, we are capable of addressing \u2014 on the level of running program code \u2014 systems with unbounded behaviour along the many dimensions in which this happens in \u201creal\u201d programs, involving datatypes, recursive control structures, error handling and recovery, initialisation, and dynamic process creation. The database lookup manager considered here contains most of these features, giving rise to infinite\u00a0\u2026", "num_citations": "43\n", "authors": ["1754"]}
{"title": "Proof systems for \u03c0-calculus logics\n", "abstract": " We study the problem of verifying general temporal and functional properties of mobile and dynamic process networks, cast in terms of the \u03c0-calculus, Much of the expressive power of this calculus derives from the combination of name generation and communication (to handle mobility) with dynamic process creation. In the paper we introduce the \u03c0-\u03bc-calculus an extension of the modal mu-calculus with name equality, inequality, first-order universal and existential quantification, and primitives for name input and output as an appropriate temporal logic for the \u03c0-calculus. A compositional proof system is given with the scope of verifying dynamic networks of \u03c0-calculus agents against properties specified in this logic. The proof system consists of a local part based, roughly, on the classical sequent calculus extended with data structures for private names, and rules to support process structure dependent\u00a0\u2026", "num_citations": "42\n", "authors": ["1754"]}
{"title": "Fixed points of B\u00fcchi automata\n", "abstract": " We give a new and direct proof of the equivalence between the linear time \u03bc-calculus \u03bdTL and B\u00fcchi automata. Constructions on automata are given which compute their least and greatest fixed points. Together with other well-known constructions corresponding to the remaining \u03bdTL connectives the result is a representation of \u03bdTL as B\u00fcchi automata which in contrast to previously known constructions is both elementary and compositional. Applications to the problem of completely axiomatising \u03bdTL are discussed.", "num_citations": "42\n", "authors": ["1754"]}
{"title": "Automating information flow analysis of low level code\n", "abstract": " Low level code is challenging: It lacks structure, it uses jumps and symbolic addresses, the control flow is often highly optimized, and registers and memory locations may be reused in ways that make typing extremely challenging. Information flow properties create additional complications: They are hyperproperties relating multiple executions, and the possibility of interrupts and concurrency, and use of devices and features like memory-mapped I/O requires a departure from the usual initial-state final-state account of noninterference. In this work we propose a novel approach to relational verification for machine code. Verification goals are expressed as equivalence of traces decorated with observation points. Relational verification conditions are propagated between observation points using symbolic execution, and discharged using first-order reasoning. We have implemented an automated tool that integrates with\u00a0\u2026", "num_citations": "41\n", "authors": ["1754"]}
{"title": "A complete axiomatization of knowledge and cryptography\n", "abstract": " The combination of first-order epistemic logic with formal cryptography offers a potentially powerful framework for security protocol verification. In this paper, cryptography is modelled using private constants and one-way computable operations, as in the applied Pi-calculus. To give the concept of knowledge a computational justification, we propose a generalized Kripke semantics that uses permutations on the underlying domain of cryptographic messages to reflect agents' limited resources. This interpretation links the logic tightly to static equivalence, another important concept of knowledge that has recently been examined in the security protocol literature, and for which there are strong computational soundness results. We exhibit an axiomatization which is sound and complete relative to the underlying theory of terms, and to an omega-rule for quantifiers. Besides standard axioms and rules, the axiomatization\u00a0\u2026", "num_citations": "41\n", "authors": ["1754"]}
{"title": "Reasoning about higher-order processes\n", "abstract": " We address the specification and verification problem for process calculi such as Chocs, CML and Facile where processes or functions are transmissible values. Our work takes place in the context of a static treatment of restriction and of a bisimulation-based semantics. As a paradigmatic and simple case we concentrate on (Plain) Chocs. We show that Chocs bisimulation can be characterized by an extension of Hennessy-Milner logic including a constructive implication, or function space constructor. This result is a non-trivial extension of the classical characterization result for labelled transition systems. In the second part of the paper we address the problem of developing a proof system for the verification of process specifications. Building on previous work for CCS we present a sound proof system for a Chocs sub-calculus not including restriction. We present two completeness results: one for the full\u00a0\u2026", "num_citations": "40\n", "authors": ["1754"]}
{"title": "Decentralized detection of global threshold crossings using aggregation trees\n", "abstract": " The timely detection that a monitored variable has crossed a given threshold is a fundamental requirement for many network management applications. A challenge is the detection of threshold crossing of network-wide variables, which are computed from device counters across the network, using aggregation functions such as SUM, MAX and AVERAGE. This paper contains a detailed description and a comprehensive evaluation of TCA\u2013GAP, a protocol for detecting threshold crossings of network-wide aggregates in a distributed way. Elements of its design include tree-based incremental aggregation for estimating the value of aggregates, a local hysteresis mechanism to reduce overhead and dynamic recomputation of local thresholds to ensure correctness. The protocol is evaluated through extensive simulation using real traces in scenarios with network sizes up to 5232 nodes. From the measurements, we\u00a0\u2026", "num_citations": "39\n", "authors": ["1754"]}
{"title": "Machine code verification of a tiny ARM hypervisor\n", "abstract": " Hypervisors are low level execution platforms that provide isolated partitions on shared resources, allowing to design secure systems without using dedicated hardware devices. A key requirement of this kind of solution is the formal verification of the software trusted computing base, preferably at the binary level. We accomplish a detailed verification of an ARMv7 tiny hypervisor, proving its correctness at the machine code level. We present our verification strategy, which mixes the usage of the theorem prover HOL4, the computation of weakest preconditions, and the use of SMT solvers to largely automate the verification process. The automation relies on an integration of HOL4 with BAP, the Binary Analysis Platform developed at CMU. To enable the adoption of the BAP back-ends to compute weakest preconditions and control flow graphs, a HOL4-based tool was implemented that transforms ARMv7 assembly\u00a0\u2026", "num_citations": "37\n", "authors": ["1754"]}
{"title": "Toward a modal theory of types for the \u03c0-calculus\n", "abstract": " We study the problem of specifying and verifying properties of \u03c0-calculus processes while relying on a bisimulation semantics. As our property specification language we use a version of the modal \u03bc-calculus adapted to the \u03c0-calculus. We show that the logical language is sufficiently expressive to characterize by means of a finite formula a process up to any approximation of the bisimulation relation. We consider the problem of checking that a process of the \u03c0-calculus satisfies a specification expressed in this modal \u03bc-calculus. We develop an algorithm which is sound in general, and complete for processes having a finite reachability property. Finally, we present a proof system which can be applied to prove non-recursive properties of arbitrary processes. We show that the system is complete on the non-recursive fragment of the logical language.", "num_citations": "37\n", "authors": ["1754"]}
{"title": "Encover: Symbolic exploration for information flow security\n", "abstract": " We address the problem of program verification for information flow policies by means of symbolic execution and model checking. Noninterference-like security policies are formalized using epistemic logic. We show how the policies can be accurately verified using a combination of concolic testing and SMT solving. As we demonstrate, many scenarios considered tricky in the literature can be solved precisely using the proposed approach. This is confirmed by experiments performed with ENCOVER, a tool based on Java Path Finder and Z3, which we have developed for epistemic noninterference concolic verification.", "num_citations": "34\n", "authors": ["1754"]}
{"title": "Compositional proof systems for model checking infinite state processes\n", "abstract": " We present the first compositional proof system for checking processes against formulas in the modal \u03bc-calculus which is capable of handling general infinite-state processes. The proof system is obtained in a systematic way from the operational semantics of the underlying process algebra. A non-trivial proof example is given, and the proof system is shown to be sound in general, and complete for finite-state processes.", "num_citations": "33\n", "authors": ["1754"]}
{"title": "Decidability and proof systems for language-based noninterference relations\n", "abstract": " Noninterference is the basic semantical condition used to account for confidentiality and integrity-related properties in programming languages. There appears to be an at least implicit belief in the programming languages community that partial approaches based on type systems or other static analysis techniques are necessary for noninterference analyses to be tractable. In this paper we show that this belief is not necessarily true. We focus on the notion of strong low bisimulation proposed by Sabelfeld and Sands. We show that, relative to a decidable expression theory, strong low bisimulation is decidable for a simple parallel while-language, and we give a sound and relatively complete proof system for deriving noninterference assertions. The completeness proof provides an effective proof search strategy. Moreover, we show that common alternative noninterference relations based on traces or input-output\u00a0\u2026", "num_citations": "32\n", "authors": ["1754"]}
{"title": "\u03bc\u2010Calculus with Explicit Points and Approximations\n", "abstract": " We present a Gentzen\u2010style sequent calculus for program verification which accommodates both model checking\u2010like verification based on global state space exploration, and compositional reasoning. To handle the complexities arising from the presence of fixed\u2010point formulas, programs with dynamically evolving architecture, and cut rules we use transition assertions, and introduce fixed\u2010point approximants explicitly into the assertion language. We address, in a game\u2010based manner, the semantical basis of this approach, as it applies to the entailment subproblem. Soundness and completeness results are obtained, and examples are shown illustrating some of the concepts.", "num_citations": "32\n", "authors": ["1754"]}
{"title": "Machine assisted proof of ARMv7 instruction level isolation properties\n", "abstract": " In this paper, we formally verify security properties of the ARMv7 Instruction Set Architecture (ISA) for user mode executions. To obtain guarantees that arbitrary (and unknown) user processes are able to run isolated from privileged software and other user processes, instruction level noninterference and integrity properties are provided, along with proofs that transitions to privileged modes can only occur in a controlled manner. This work establishes a main requirement for operating system and hypervisor verification, as demonstrated for the PROSPER separation kernel. The proof is performed in the HOL4 theorem prover, taking the Cambridge model of ARM as basis. To this end, a proof tool has been developed, which assists the verification of relational state predicates semi-automatically.", "num_citations": "31\n", "authors": ["1754"]}
{"title": "TreeDroid: a tree automaton based approach to enforcing data processing policies\n", "abstract": " Current approaches to security policy monitoring are based on linear control flow constraints such as' runQuery'may be evaluated only after'sanitize'. However, realistic security policies must be able to conveniently capture data flow constraints as well. An example is a policy stating that arguments to the function'runQuery'must be either constants, outputs of a function'sanitize', or concatenations of any such values.", "num_citations": "30\n", "authors": ["1754"]}
{"title": "Logical omniscience in the semantics of BAN logic\n", "abstract": " BAN logic is an epistemic logic for verification of cryptographic protocols. A number of semantics have been proposed for BAN logic, but none of them capture the intended meaning of the epistemic modality in a satisfactory way. This is due to the so-called logical omniscience problem: Agents are\u201d ideal reasoners\u201d in existing semantics, while agents in BAN logic have only limited cryptographic reasoning powers. Logical omniscience is unavoidable in Kripke semantics, the standard semantical framework in epistemic logic. Our proposal is to generalize the epistemic accessibility relation of Kripke semantics so that it changes not only the current execution point, but also the currently predicated message. When instantiated on message passing systems, the semantics validates BAN logic. It makes agents introspective (\u201d self-aware\u201d) of their own knowledge and of their own actions of sending, receiving and extracting.", "num_citations": "30\n", "authors": ["1754"]}
{"title": "Compositional verification of CCS processes\n", "abstract": " We present a proof system for verifying CCS processes in the modal \u00b5-calculus. Its novelty lies in the generality of the proof judgements allowing parametric and compositional reasoning in this complex setting. This is achieved, in part, by the use of explicit fixed point ordinal approximations, and in part by a complete separation, following an approach by Simpson, of rules concerning the logic from the rules encoding the operational semantics of the process language.", "num_citations": "29\n", "authors": ["1754"]}
{"title": "A completeness result for BAN logic\n", "abstract": " BAN logic is a propositional logic of knowledge for the verification of cryptographic protocols. While BAN logic has been successful from a practical point of view, the semantics of the epistemic (knowledge) modality is unclear. Several Kripke semantics have been proposed, but they do not attempt at anything beyond a soundness result. Completeness is prevented by the so called logical omniscience problem: Agents in BAN can draw only feasibly computable consequences of their knowledge, whereas agents in Kripke semantics are not so constrained. To circumvent this problem, we index the epistemic possibility relation of Kripke semantics with a message correlation, relating how cipher texts at the current state correspond to cipher texts at the epistemically possible state. An agent is said to know a property of a message if corresponding messages at epistemically possible states satisfy that property. We obtain completeness with respect to message passing systems, and decidability, by transferring canonical model and filtration constructions from Kripke semantics.", "num_citations": "26\n", "authors": ["1754"]}
{"title": "System description: Verification of distributed Erlang programs\n", "abstract": " Software written for telecommunication applications has to meet high quality demands. Correctness is one major concern; the activity of proving formally that a system is correct is called verification. Telecommunications software is highly concurrent, and testing is often not capable of guaranteeing correctness to a satisfactory degree. The software we are faced with consists of many, relatively small modules, written in the functional language Erlang [AVWW96]. These modules define the behaviour of a number of processes operating in parallel and communicating through asynchronous message-passing. New processes can be generated during execution. Because of the complexity of such software, our approach to verification is to prove that the software satisfies a set of properties formally specified in a suitable logic language. The specification language we use is based on Park's p-calculus [Par76, Koz83\u00a0\u2026", "num_citations": "26\n", "authors": ["1754"]}
{"title": "Inspectre: Breaking and fixing microarchitectural vulnerabilities by formal analysis\n", "abstract": " The recent Spectre attacks have demonstrated the fundamental insecurity of current computer microarchitecture. The attacks use features like pipelining, out-of-order and speculation to extract arbitrary information about the memory contents of a process. A comprehensive formal microarchitectural model capable of representing the forms of out-of-order and speculative behavior that can meaningfully be implemented in a high performance pipelined architecture has not yet emerged. Such a model would be very useful, as it would allow the existence and non-existence of vulnerabilities, and soundness of countermeasures to be formally established. This paper presents such a model targeting single core processors. The model is intentionally very general and provides an infrastructure to define models of real CPUs. It incorporates microarchitectural features that underpin all known Spectre vulnerabilities. We use the\u00a0\u2026", "num_citations": "24\n", "authors": ["1754"]}
{"title": "Trustworthy virtualization of the ARMv7 memory subsystem\n", "abstract": " In order to host a general purpose operating system, hypervisors need to virtualize the CPU memory subsystem. This entails dynami- cally changing MMU resources, in particular the page tables, to allow a hosted OS to reconfigure its own memory. In this paper we present the verification of the isolation properties of a hypervisor design that uses direct paging. This virtualization approach allows to host commodity OSs without requiring either shadow data structures or specialized hardware support. Our verification targets a system consisting of a commodity CPU for embedded devices (ARMv7), a hypervisor and an untrusted guest running Linux.The verification involves three steps: (i) Formalization of an ARMv7 CPU that includes the MMU, (ii) Formalization of a system behavior that includes the hypervisor and the untrusted guest (iii) Verification of the isolation properties. Formalization and proof are done in\u00a0\u2026", "num_citations": "24\n", "authors": ["1754"]}
{"title": "A gossiping protocol for detecting global threshold crossings\n", "abstract": " We investigate the use of gossip protocols for the detection of network-wide threshold crossings. Our design goals are low protocol overhead, small detection delay, low probability of false positives and negatives, scalability, robustness to node failures and controllability of the trade-off between overhead and detection delay. Based on push-synopses, a gossip protocol introduced by Kempe et al., we present a protocol that indicates whether a global aggregate of static local values is above or below a given threshold. For this protocol, we prove correctness and show that it converges to a state with no overhead when the aggregate is sufficiently far from the threshold. Then, we introduce an extension we call TG-GAP, a protocol that (1) executes in a dynamic network environment where local values change and (2) implements hysteresis behavior with upper and lower thresholds. Key elements of its design are the\u00a0\u2026", "num_citations": "24\n", "authors": ["1754"]}
{"title": "On the secure implementation of security protocols\n", "abstract": " We consider the problem of implementing a security protocol in such a manner that secrecy of sensitive data is not jeopardized. Implementation is assumed to take place in the context of an API that provides standard cryptography and communication services. Given a dependency specification, stating how API methods can produce and consume secret information, we propose an information flow property based on the idea of invariance under perturbation, relating observable changes in output to corresponding changes in input. Besides the information flowcondition itself, the main contributions of the paper are results relating the admissibility property to a direct flow property in the special case of programs which branch on secrets only in cases permitted by the dependency rules. These results are used to derive an unwinding-like theorem, reducing a behavioral correctness check (strong bisimulation) to\u00a0\u2026", "num_citations": "24\n", "authors": ["1754"]}
{"title": "Proving properties of dynamic process networks\n", "abstract": " We present the first compositional proof system for checking processes against formulas in the modal\u03bc-calculus which is capable of handling dynamic process networks. The proof system is obtained in a systematic way from the operational semantics of the underlying process algebra. A non-trivial proof example is given, and the proof system is shown to be sound in general, and complete for finite-state processes.", "num_citations": "21\n", "authors": ["1754"]}
{"title": "Decentralized computation of threshold crossing alerts\n", "abstract": " Threshold crossing alerts (TCAs) indicate to a management system that a management variable, associated with the state, performance or health of the network, has crossed a certain threshold. The timely detection of TCAs is essential to proactive management. This paper focuses on detecting TCAs for network-level variables, which are computed from device-level variables using aggregation functions, such as SUM, MAX, or AVERAGE. It introduces TCA-GAP, a novel protocol for producing network-wide TCAs in a scalable and robust manner. The protocol maintains a spanning tree and uses local thresholds, which adapt to changes in network state and topology, by allowing nodes to trade unused \u201cthreshold space\u201d. Scalability is achieved through computing the thresholds locally and through distributing the aggregation process across all nodes. Fault-tolerance is achieved by a mechanism that\u00a0\u2026", "num_citations": "20\n", "authors": ["1754"]}
{"title": "London, UK\n", "abstract": " We present an abstraction technique for multi-agent systems a multi-agent system, defined in the interpreted systems framework, by collapsing the local states and actions of each agent in the system. We show that the resulting abstract system simulates the concrete system, from which we obtain a preservation theorem: If a temporal-epistemic specification holds on the abstract system, the specification also holds on the concrete one. In principle this permits us to model check the abstract system rather than the concrete one, thereby saving time and space in the verification step. We illustrate the abstraction technique with two examples. The first example, a card game, illustrates the potential savings in the cost of model checking a typical MAS scenario. In the second example, the abstraction technique is used to verify a communication protocol with an arbitrarily large data domain.", "num_citations": "20\n", "authors": ["1754"]}
{"title": "Proving trust in systems of second-order processes\n", "abstract": " We consider the problem of proving correctness properties for concurrent systems with features such as higher-order communication and dynamic resource generation. As examples we consider operational models of security and authentication protocols based on the higher-order /spl pi/-calculus. Key features such as nonces/time stamps, encryption/decryption, and key generation are modelled using channel name generation and second-order process communication. A temporal logic based on the modal /spl mu/-calculus is used to express secrecy and authenticity. Extensions include function space constructions to deal with process input and output. Contravariant recursion can be dealt with in two different ways, of which one, an iterative solution, is discussed in the paper. We propose a predicate of trust in a monotonically increasing set of channels as an example, and establish structural decomposition\u00a0\u2026", "num_citations": "20\n", "authors": ["1754"]}
{"title": "A data symmetry reduction technique for temporal-epistemic logic\n", "abstract": " We present a data symmetry reduction approach for model checking temporal-epistemic logic. The technique abstracts the epistemic indistinguishably relation for the knowledge operators, and is shown to preserve temporal-epistemic formulae. We show a method for statically detecting data symmetry in an ISPL program, the input to the temporal-epistemic model checker MCMAS. The experiments we report show an exponential saving in verification time and space while verifying security properties of the NSPK protocol.", "num_citations": "19\n", "authors": ["1754"]}
{"title": "On global induction mechanisms in a \u03bc-calculus with explicit approximations\n", "abstract": " We investigate a Gentzen-style proof system for the first-order \u03bc-calculus       based on cyclic proofs, produced by unfolding fixed point formulas       and detecting repeated proof goals. Our system uses explicit ordinal       variables and approximations to support a simple semantic induction       discharge condition which ensures the well-foundedness of inductive       reasoning. As the main result of this paper we propose a new syntactic       discharge condition based on traces and establish its equivalence       with the semantic condition. We give an automata-theoretic reformulation       of this condition which is more suitable for practical proofs. For       a detailed comparison with previous work we consider two simpler syntactic       conditions and show that they are more restrictive than our new condition.", "num_citations": "19\n", "authors": ["1754"]}
{"title": "Decentralized real-time monitoring of network-wide aggregates\n", "abstract": " The traditional monitoring paradigm of network and systems management, characterized by a central entity polling individual devices, is not adequate for today's large-scale networked systems whose states and configurations are highly dynamic. We outline principles for monitoring such new systems and stress the need for protocols that continuously monitor network-wide aggregates. To keep the overhead at acceptable levels, such protocols must be tunable, eg, allow controlling the trade-off between accuracy and overhead. We describe and compare two of our efforts in developing protocols for decentralized monitoring of aggregates; one is based on spanning trees, the other on gossiping.", "num_citations": "18\n", "authors": ["1754"]}
{"title": "Translating Ctl* Into the Modal [Mu]-Calculus\n", "abstract": " Mads Dam, Translating Ctl* Into the Modal [Mu]-Calculus - PhilPapers Sign in | Create an account PhilPapers PhilPeople PhilArchive PhilEvents PhilJobs PhilPapers home Syntax Advanced Search Syntax Advanced Search Syntax Advanced Search Translating Ctl* Into the Modal [Mu]-Calculus Mads Dam LFCS, Department of Computer Science, University of Edinburgh (1990) Abstract This article has no associated abstract. (fix it) Keywords Modality Logic, Symbolic and mathematical Categories Areas of Mathematics in Philosophy of Mathematics (categorize this paper) Buy this book Find it on Amazon.com Options Edit this record Mark as duplicate Export citation Find it on Scholar Request removal from index Revision history Download options PhilArchive copy Upload a copy of this paper Check publisher's policy Papers currently archived: 59,243 External links This entry has no external links. Add one. Setup an \u2026", "num_citations": "18\n", "authors": ["1754"]}
{"title": "Formal verification of secure user mode device execution with DMA\n", "abstract": " Separation between processes on top of an operating system or between guests in a virtualized environment is essential for establishing security on modern platforms. A key requirement of the underlying hardware is the ability to support multiple partitions executing on the shared hardware without undue interference. For modern processor architectures - with hardware support for memory management, several modes of operation and I/O interfaces - this is a delicate issue requiring deep analysis at both instruction set and processor implementation level. In a first attempt to rigorously answer this type of questions we introduced in previous work an information flow analysis of user program execution on an ARMv7 platform with hardware supported memory protection, but without I/O. The analysis was performed as a semi-automatic proof search procedure on top of an ARMv7 ISA model implemented in the\u00a0\u2026", "num_citations": "16\n", "authors": ["1754"]}
{"title": "On the secure implementation of security protocols\n", "abstract": " We consider the problem of implementing a security protocol in such a manner that secrecy of sensitive data is not jeopardized. Implementation is assumed to take place in the context of an API that provides standard cryptography and communication services. Given a dependency specification, stating how API methods can produce and consume secret information, we propose an information flow property based on the idea of invariance under perturbation, relating observable changes in output to corresponding changes in input. Besides the information flow condition itself, the main contributions of the paper are results relating the admissibility property to a direct flow property in the special case of programs which branch on secrets only in cases permitted by the dependency rules. These results are used to derive an unwinding theorem, reducing a behavioural correctness check (strong bisimulation) to an invariant.", "num_citations": "16\n", "authors": ["1754"]}
{"title": "From higher-order \u03c0-calculus to \u03c0-calculus in the presence of static operators\n", "abstract": " Some applications of higher-order processes require better control of communication capabilities than what is provided by the \u03c0-calculus primitives. In particular we have found the dynamic restriction operator of CHOCS, here called blocking, useful. We investigate the consequences of adding static operators such as blocking to the first-and higher-order \u03c0-calculus. In the presence of the blocking operator (and static operators in general) the higher-order reduction of Sangiorgi, used to demonstrate the reducibility of higher-order communication features to first-order ones, breaks down. We show, as our main result, that the higher-order reduction can be regained, using an approach by which higher-order communications are replaced, roughly, by the transmission and dynamic interpretation of syntax trees. However, the reduction is very indirect, and not usable in practice. This throws new light on the position\u00a0\u2026", "num_citations": "15\n", "authors": ["1754"]}
{"title": "On the verification of open distributed systems\n", "abstract": " A logic and proof system is introduced for specifying and proving properties of open distributed systems. Key problems that are addressed include the verification of procees networks with a changing intercounection structure, and where new processes can be continuously spawned. To demonstrate the results in a realistic setting we consider a core fragment of the Erlang programming language. Roughly this amounts to a first-order actor language with data types, buffered asynchronous communication, and dynamic process spawning. Our aim is to verify quite general properties of program, in this fragment The specification logic extends the firstorder/J-calculus with Erlang-specific primitives. For verification we use an approach which combines local model checking with facilities for compositional verification. We give a specification and verification example based on a hilling agent which controls and charges for\u00a0\u2026", "num_citations": "15\n", "authors": ["1754"]}
{"title": "Provably secure memory isolation for Linux on ARM\n", "abstract": " The isolation of security critical components from an untrusted OS allows to both protect applications and to harden the OS itself. Virtualization of the memory subsystem is a key component to provide such isolation. We present the design, implementation and verification of a memory virtualization platform for ARMv7-A processors. The design is based on direct paging, an MMU virtualization mechanism previously introduced by Xen. It is shown that this mechanism can be implemented using a compact design, suitable for formal verification down to a low level of abstraction, without penalizing system performance. The verification is performed using the HOL4 theorem prover and uses a detailed model of the processor. We prove memory isolation along with information flow security for an abstract top-level model of the virtualization mechanism. The abstract model is refined down to a transition system closely\u00a0\u2026", "num_citations": "14\n", "authors": ["1754"]}
{"title": "Trustworthy prevention of code injection in linux on embedded devices\n", "abstract": " We present MProsper, a trustworthy system to prevent code injection in Linux on embedded devices. MProsper is a formally verified run-time monitor, which forces an untrusted Linux to obey the executable space protection policy; a memory area can be either executable or writable, but cannot be both. The executable space protection allows the MProsper\u2019s monitor to intercept every change to the executable code performed by a user application or by the Linux kernel. On top of this infrastructure, we use standard code signing to prevent code injection. MProsper is deployed on top of the Prosper hypervisor and is implemented as an isolated guest. Thus MProsper inherits the security property verified for the hypervisor: (i) Its code and data cannot be tampered by the untrusted Linux guest and (ii) all changes to the memory layout is intercepted, thus enabling MProsper to completely mediate every operation\u00a0\u2026", "num_citations": "14\n", "authors": ["1754"]}
{"title": "Provably correct runtime monitoring\n", "abstract": " Runtime monitoring is an established technique to enforce a wide range of program safety and security properties. We present a formalization of monitoring and monitor inlining, for the Java Virtual Machine. Monitors are security automata given in a special-purpose monitor specification language, ConSpec. The automata operate on finite or infinite strings of calls to a fixed API, allowing local dependencies on parameter values and heap content. We use a two-level class file annotation scheme to characterize two key properties: (i) that the program is correct with respect to the monitor as a constraint on allowed program behavior, and (ii) that the program has a copy of the given monitor embedded into it. As the main application of these results we sketch a simple inlining algorithm and show how the two-level annotations can be completed to produce a fully annotated program which is valid in the standard sense of\u00a0\u2026", "num_citations": "14\n", "authors": ["1754"]}
{"title": "A research agenda for distributed policy-based management\n", "abstract": " Policy-based management is based on defining a set of global rules, according to which a network or distributed system must operate. In the last few years, policy-based management has begun to emerge as the dominant paradigm for developing network and systems management functions, primarily, since it can reduce complexity in management applications. Although attempts are underway to standardize policy-based management, significant research challenges remain. At KTH and SICS, a joint activity has been started to focus on some of the key issues. The paper outlines the research agenda for this activity.", "num_citations": "14\n", "authors": ["1754"]}
{"title": "Practical private information aggregation in large networks\n", "abstract": " Emerging approaches to network monitoring involve large numbers of agents collaborating to produce performance or security related statistics on huge, partial mesh networks. The aggregation process often involves security or business-critical information which network providers are generally unwilling to share without strong privacy protection. We present efficient and scalable protocols for privately computing a large range of aggregation functions based on addition, disjunction, and max/min. For addition, we give a protocol that is information-theoretically secure against a passive adversary, and which requires only one additional round compared to non-private protocols for computing sums. For disjunctions, we present both a computationally secure, and an information-theoretically secure solution. The latter uses a general composition approach which executes the sum protocol together with a\u00a0\u2026", "num_citations": "13\n", "authors": ["1754"]}
{"title": "Process-algebraic interpretations of positive linear and relevant logics\n", "abstract": " We investigate the use of positive linear and relevant logics to provide logical accounts of static process structure, and combinations of relevance and modality to account also for dynamic behaviour. A general notion of model is introduced, based on which, three examples are given using Milner's synchronous process calculus SCCS. The structure of models is enriched by prefixing operators to cover also dynamic behaviour. Logically dynamic behaviour is captured by adding past and future modal operators. The resulting logic is given sound and complete axiomatizations and shown to conservatively extend the positive fragment of linear logic. Finally the induced interpretations of formulas on process terms are characterized, and axiomatisations are given which are sound and complete with respect to validity in the process-based interpretations. The completeness proofs are based on rewriting and provide\u00a0\u2026", "num_citations": "13\n", "authors": ["1754"]}
{"title": "Location-independent routing in process network overlays\n", "abstract": " In distributed computing, location transparency\u2014the decoupling of objects from their physical location\u2014is desirable in that it can simplify application development and enables efficient resource allocation. Many systems for location transparency are built on TCP/IP. We argue that addressing mobile objects in terms of temporary hosts may not be the best design decision. Object migration makes it necessary to use dedicated routing infrastructures, e.g., location servers, to deliver inter-object messages. This incurs high costs in terms of complexity, overhead, and latency. Here, we defer object overlay routing to a networking layer, by replacing TCP/IP with a location-independent routing scheme which directs messages to destinations determined by flat identifiers instead of IP addresses. Consequently, messages are delivered directly to objects, instead of possibly out-of-date locations. We explore the scheme\u00a0\u2026", "num_citations": "12\n", "authors": ["1754"]}
{"title": "Gossiping for threshold detection\n", "abstract": " We investigate the use of gossip protocols to detect threshold crossings of network-wide aggregates. Aggregates are computed from local device variables using functions such as SUM, AVERAGE, COUNT, MAX and MIN. The process of aggregation and detection is performed using a standard gossiping scheme. A key design element is to let nodes dynamically adjust their neighbor interaction rates according to the distance between the nodes' local estimate of the global aggregate and the threshold itself. We show that this allows considerable savings in communication overhead. In particular, the overhead becomes negligible when the aggregate is sufficiently far above or far below the threshold. We present evaluation results from simulation studies regarding protocol efficiency, quality of threshold detection, scalability, and controllability.", "num_citations": "12\n", "authors": ["1754"]}
{"title": "A note on SPKI's authorisation syntax\n", "abstract": " Tuple reduction is the basic mechanism used in SPKI to make authorisation decisions. A basic problem with the SPKI authorisation syntax is that straightforward implementations of tuple reduction are quadratic in both time and space. In the paper we introduce a restricted version of the SPKI authorisation syntax, which appears to conform well with practice, and for which authorisation decisions can be made in nearly linear time.", "num_citations": "12\n", "authors": ["1754"]}
{"title": "Model checking mobile processes (full version)\n", "abstract": " We introduce a temporal logic for the polyadic 7-calculus based on fixed point extensions of Hennessy-Milner logic. Features are added to account for parametrisation, generation, and passing of names, including the use, following Milner, of dependent sum and product to account for (unlocalised) input and output, and explicit parametrisation on names using lambda-abstraction and application. The latter provides a single name binding Inechanism supporting all parametrisation needed. A proof system and decision procedure is developed based on Stirling and Walker's approach to model checking the modal p-calculus using constants. One difficulty, for both conceptual and efficiency-based reasons, is to avoid the ex-plicit use of the a-rule for parametrised processes. A key idea, following Hennessy and Lin's approach to deciding bisimulation for certain types of value-passing processes, is the relativisation of correctness assertions to conditions on names. Based on this idea a proof system and decision procedure is obtained for arbitrary r-calculus processes with finite control, m-calculus correlates of CCS finite-state processes, avoiding the use of parallel composition in recursively defined processes.", "num_citations": "11\n", "authors": ["1754"]}
{"title": "Proof systems for pi-calculus logics\n", "abstract": " In this paper we study the problem of verifying general temporal and functional properties of mobile and dynamic process networks, cast in terms of the pi-calculus. Much of the expressive power of this calculus derives from the combination of name generation and communication (to handle mobility) with dynamic process creation. In the paper we introduce the--calculus, an extension of the modal mu-calculus with name equality, inequality, first-order universal and existential quantification, and primitives for name input and output as an appropriate temporal logic for the pi-calculus. A compositional proof system is given with the scope of verifying dynamic networks of pi-calculus agents against properties specified in this logic. The proof system consists of a local part based, roughly, on the classical sequent calculus extended with data structures for private names, and rules to support process structure dependent reasoning. In addition the proof system contains a rule of...", "num_citations": "9\n", "authors": ["1754"]}
{"title": "Proving trust in systems of second-order processes: Preliminary results\n", "abstract": " We consider the problem of proving correctness properties for concurrent systems with features such as higher-order communication and dynamic resource generation. Operational models of security and authentication protocols based on the higher-order-calculus are considered as examples. In this setting key features such as nonces/time stamps, encryption/decryption, and key generation can be modelled in a simple and abstract fashion using channel name generation and second-order process communication. A temporal logic is proposed as an appropriate logic for expressing correctness properties such as secrecy and authenticity. The logic is based on the modal-calculus with only greatest xed points and universal next-state quanti cation. Extensions include rst-order features to deal with names, and second-order features including function space constructions to deal with process input and output. One di culty is that formulas need recursion in both covariant and contravariant positions. We show how this problem can be overcome in two di erent, but equivalent, ways, rst using a standard semantical account based on intervals, and then by an iterative construction. We propose a predicate of trust in a monotonically increasing set of channels as an example, and establish structural decomposition principles for this predicate for concurrent composition and local channel declaration. On this basis a type system for trust inference can be derived quite easily, and we use this type system to establish trust of a very simple protocol example.", "num_citations": "9\n", "authors": ["1754"]}
{"title": "A proof carrying code framework for inlined reference monitors in Java bytecode\n", "abstract": " We propose a light-weight approach for certification of monitor inlining for sequential Java bytecode using proof-carrying code. The goal is to enable the use of monitoring for quality assurance at development time, while minimizing the need for post-shipping code rewrites as well as changes to the end-host TCB. Standard automaton-based security policies express constraints on allowed API call/return sequences. Proofs are represented as JML-style program annotations. This is adequate in our case as all proofs generated in our framework are recognized in time polynomial in the size of the program. Policy adherence is proved by comparing the transitions of an inlined monitor with those of a trusted \"ghost\" monitor represented using JML-style annotations. At time of receiving a program with proof annotations, it is sufficient for the receiver to plug in its own trusted ghost monitor and check the resulting verification conditions, to verify that inlining has been performed correctly, of the correct policy. We have proved correctness of the approach at the Java bytecode level and formalized the proof of soundness in Coq. An implementation, including an application loader running on a mobile device, is available, and we conclude by giving benchmarks for two sample applications.", "num_citations": "8\n", "authors": ["1754"]}
{"title": "Compiler generation from relational semantics\n", "abstract": " We consider the problem of automatically deriving correct compilers from relational semantic specifications of programming languages. A relational semantics is an assignment of initial-state final-state relations (defined by means of proof rules) to programs. Compilers are generated in three steps. First, the language definition is transformed into a stack semantics in which the storage of semantic values is made explicit. Next, stack rules are assembled into a socalled language scheme containing exactly one rule for each language construct. We consider languages for which non-deterministic branches may be replaced by deterministic ones. Finally, rules are expanded for the purpose of recursion detection, thus obtaining schemes which may be used for code generation in a syntax-directed compiler.", "num_citations": "8\n", "authors": ["1754"]}
{"title": "Scalable metadata-directed search in a network of information\n", "abstract": " The information-centric paradigm has been recently proposed for the design of future networking systems. A key requirement for realising such systems is having mechanisms that provide efficient, scalable and accurate information search. In this paper, we present solutions for both one-time and continuous searches. Our solution for one-time searches is scalable for its search completion time grows sublinearly with the system size. In addition, the overhead it introduces is evenly distributed. For our solution for continuous searches, we discuss its tradeoff between load (efficiency) and timeliness (accuracy).", "num_citations": "7\n", "authors": ["1754"]}
{"title": "Automatic derivation of platform noninterference properties\n", "abstract": " For the verification of system software, information flow properties of the instruction set architecture (ISA) are essential. They show how information propagates through the processor, including sometimes opaque control registers. Thus, they can be used to guarantee that user processes cannot infer the state of privileged system components, such as secure partitions. Formal ISA models - for example for the HOL4 theorem prover - have been available for a number of years. However, little work has been published on the formal analysis of these models. In this paper, we present a general framework for proving information flow properties of a number of ISAs automatically, for example for ARM. The analysis is represented in HOL4 using a direct semantical embedding of noninterference, and does not use an explicit type system, in order to (i) minimize the trusted computing base, and to (ii) support a large\u00a0\u2026", "num_citations": "6\n", "authors": ["1754"]}
{"title": "Compositional verification of security properties for embedded execution platforms\n", "abstract": " The security of embedded systems can be dramatically improved through the use of formally verified isolation mechanisms such as separation kernels, hypervisors, or microkernels. For trustworthiness, particularly for system level behavior, the verifications need precise models of the underlying hardware. Such models are hard to attain, highly complex, and proofs of their security properties may not easily apply to similar but different platforms. This may render verification economically infeasible. To address these issues, we propose a compositional top-down approach to embedded system specification and verification, where the system-on-chip is modeled as a network of distributed automata communicating via paired synchronous message passing. Using abstract specifications for each component allows to delay the development of detailed models for cores, devices, etc., while still being able to verify high level security properties like integrity and confidentiality, and soundly refine the result for different instantiations of the abstract components at a later stage. As a case study, we apply this methodology to the verification of information flow security for an industry scale security-oriented hypervisor on the ARMv8-A platform. The hypervisor statically assigns (multiple) cores to each guest system and implements a rudimentary, but usable, inter guest communication discipline. We have completed a pen-and-paper security proof for the hypervisor down to state transition level and report on a partially completed verification of guest mode security in the HOL4 theorem prover.", "num_citations": "5\n", "authors": ["1754"]}
{"title": "In-network monitoring\n", "abstract": " Monitoring, i.e., the process of acquiring state information from a network or networked system, is fundamental to system operation. In traditional network and systems management, monitoring is performed on a per-device basis, whereby a centralized management entity polls the devices in its domain for information, which is then analyzed and acted upon. In this chapter, we describe several monitoring algorithms that utilize a new monitoring paradigm called In-network Monitoring. This paradigm is designed to address the above shortcomings, and we demonstrate how it can be applied to managing highly dynamic networked systems. The main idea of In-network Monitoring is to introduce a small management entity inside each network device, which, in addition to monitoring local parameters, can also perform limited management functions and communicate with peering entities in its proximity. The\u00a0\u2026", "num_citations": "5\n", "authors": ["1754"]}
{"title": "Regular SPKI\n", "abstract": " SPKI is a certificate-based framework for authorisation in distributed systems. The SPKI framework is extended by an iteration construct, essentially Kleene star, to express constraints on delegation chains. Other possible applications, not explored in the paper, include multidomain network routing path constraints. The main decision problems for the extended language are shown to correspond to regular language membership and containment respectively. To support an efficient decision algorithm in both cases we give a sound and complete inference system for a fragment of the language which is decidable in polynomial time. We finally show how to use the extended syntax to represent constrained delegation in SPKI.", "num_citations": "5\n", "authors": ["1754"]}
{"title": "Efficient and fully abstract routing of futures in object network overlays\n", "abstract": " In distributed object systems, it is desirable to enable migration of objects between locations, eg, in order to support efficient resource allocation. Existing approaches build complex routing infrastructures to handle object-to-object communication, typically on top of IP, using, eg, message forwarding chains or centralized object location servers. These solutions are costly and problematic in terms of efficiency, overhead, and correctness. We show how location independent routing can be used to implement object overlays with complex messaging behavior in a sound, fully abstract, and efficient way, on top of an abstract network of processing nodes connected point-to-point by asynchronous channels. We consider a distributed object language with futures, essentially lazy return values. Futures are challenging in this context due to the global consistency requirements they impose. The key conclusion is that execution\u00a0\u2026", "num_citations": "4\n", "authors": ["1754"]}
{"title": "ABS-NET: Fully decentralized runtime adaptation for distributed objects\n", "abstract": " We present a formalized, fully decentralized runtime semantics for a core subset of ABS, a language and framework for modelling distributed object-oriented systems. The semantics incorporates an abstract graph representation of a network infrastructure, with network endpoints represented as graph nodes, and links as arcs with buffers, corresponding to OSI layer 2 interconnects. The key problem we wish to address is how to allocate computational tasks to nodes so that certain performance objectives are met. To this end, we use the semantics as a foundation for performing network-adaptive task execution via object migration between nodes. Adaptability is analyzed in terms of three Quality of Service objectives: node load, arc load and message latency. We have implemented the key parts of our semantics in a simulator and evaluated how well objectives are achieved for some application-relevant choices of network topology, migration procedure and ABS program. The evaluation suggests that it is feasible in a decentralized setting to continually meet both the objective of a node-balanced task allocation and make headway towards minimizing communication, and thus arc load and message latency.", "num_citations": "4\n", "authors": ["1754"]}
{"title": "R-generability, and definability in branching time logics\n", "abstract": " The full branching time logic CTL*[4] extends linear time temporal logic by universal and existential quantification over computation paths. It is often useful to think of computation paths as distinguished, or admissible, paths through a transition system. When the set of paths under consideration is the full set of paths through some transition system, models are said to be R-generable. This property is of considerable importance for practical implementations. It ensures that the current state carries all necessary information about possible future behaviour: Neither past behaviour nor fairness or scheduling criteria are necessary to determine the admissible computations. In [2], Emerson showed R-generability to be characterised by three closure conditions: suffix, fusion, and limit closure. Limit closure, in particular, is a continuity-like property characterising the absence of fairness criteria. In this note we investigate the\u00a0\u2026", "num_citations": "4\n", "authors": ["1754"]}
{"title": "Hoare-Style Logic for Unstructured Programs\n", "abstract": " Enabling Hoare-style reasoning for low-level code is attractive since it opens the way to regain structure and modularity in a domain where structure is essentially absent. The field, however, has not yet arrived at a fully satisfactory solution, in the sense of avoiding restrictions on control flow (important for compiler optimization), controlling access to intermediate program points (important for modularity), and supporting total correctness. Proposals in the literature support some of these properties, but a solution that meets them all is yet to be found. We introduce the novel Hoare-style program logic , which interprets postconditions relative to program points when these are first encountered. The logic can support both partial and total correctness, derive contracts for arbitrary control flow, and allows one to freely choose decomposition strategy during verification while avoiding step-indexed approximations and global\u00a0\u2026", "num_citations": "3\n", "authors": ["1754"]}
{"title": "On the verification of system-level information flow properties for virtualized execution platforms\n", "abstract": " The security of embedded systems can be dramatically improved through the use of formally verified isolation mechanisms such as separation kernels, hypervisors, or microkernels. For trustworthiness, particularly for system-level behavior, the verifications need precise models of the underlying hardware. Such models are hard to attain, highly complex, and proofs of their security properties may not easily apply to similar but different platforms. This may render verification economically infeasible. To address these issues, we propose a compositional top-down approach to embedded system specification and verification, where the system-on-chip is modeled as a network of distributed automata communicating via paired synchronous message passing. Using abstract specifications for each component allows to delay the development of detailed models for cores, devices, etc., while still being able to verify\u00a0\u2026", "num_citations": "3\n", "authors": ["1754"]}
{"title": "Verification of security domain separation\n", "abstract": " The disclosure concerns a security condition verification method for a system comprising first and second security domains relating to respective first and second functional modules, a security kernel and a shared hardware component. The functional modules are executed using the shared hardware component and the security condition comprises a condition that any information exchange between the functional modules is an authorized information exchange. The security kernel controls the execution of the first and second functional modules using the shared hardware component. The method comprises determining that the security condition is satisfied if, for each of the functional modules and for each initial state, a first observable parameter associated with execution of an instruction of the functional module using the shared hardware component equals a second observable parameter associated with\u00a0\u2026", "num_citations": "3\n", "authors": ["1754"]}
{"title": "Trustworthy memory isolation of Linux on embedded devices\n", "abstract": " The isolation of security critical components from an untrusted OS allows to both protect applications and to harden the OS itself, for instance by run-time monitoring. Virtualization of the memory subsystem is a key component to provide such isolation. We present the design, implementation and verification of a virtualization platform for the ARMv7-A processor family. Our design is based on direct paging, an MMU virtualization mechanism previously introduced by Xen for the x86 architecture, and used later with minor variants by the Secure Virtual Architecture, SVA. We show that the direct paging mechanism can be implemented using a compact design, suitable for formal verification down to a low level of abstraction, without penalizing system performance. The verification is performed using the HOL4 theorem prover and uses a detailed model of the ARMv7-A ISA, including the MMU. We prove memory\u00a0\u2026", "num_citations": "3\n", "authors": ["1754"]}
{"title": "A Tool for Verifying Software Written in Erlang\n", "abstract": " The present paper presents an overview of the main results of the ASTEC project Verication of Erlang Programs, focusing in particular on the Erlang verication tool. This is a theorem-proving tool which assists in obtaining proofs that Erlang applications satisfy their correctness requirements formulated in a specication logic. We give a summary of the verication framework as supported by the tool, discuss reasoning principles essential for successful verication such as inductive and compositional reasoning, and an ecient treatment of side-eect-free code. The experiences of applying the verication tool in an industrial case study are summarised, and an approach for supporting verication in the presence of program libraries is outlined. The verication tool is essentially a classical proof assistant, or theoremproving tool, requiring users to intervene in the proof process at crucial steps such as stating program invariants. However, the tool oers considerable su...", "num_citations": "3\n", "authors": ["1754"]}
{"title": "Temporal logic, automata and classical theories-an introduction\n", "abstract": " The area of intersection between temporal logic, automata on nite and in nite objects, and classical rst-or restricted second-order logics is one of considerable richness. All these areas have long and venerable traditions in mathematics, logic, and theoretical computer science, and their intimate relationships have been realised for quite some time. Indeed, automata of in nite objects were invented for the purpose of just answering decidability issues in classical rst-or restricted second-order logics. However, the area has remained open to new points-of-view and insights, and very fundamental questions have yet to be both asked and answered.The point of departure here is that of programs, the computations that programs give rise to, and logics expressing properties of programs in terms of their computations. These notions are far from well determined. Indeed it is one of our central aims to throw light on what are\\good\"(say,\\tractable\", or\\complete\") notions of computation or property. However, having this point of departure is helpful to cut down what are immense subject areas to more manageable sizes, and it should be kept in mind in the sequel that we raise and answer questions guided by our judgment of their relevance to our point of departure. The concepts of programs, computations, and their properties come in wide ranges of avours, dictated, to some extent, by the applications one has in mind. Typically programs are identi ed with some sort of state transition system that may be labelled in various ways to record interaction ports or types, primitive properties holding of states, or value assignments to identi ers. Computations then can be\u00a0\u2026", "num_citations": "3\n", "authors": ["1754"]}
{"title": "On Compositional Information Flow Aware Refinement\n", "abstract": " The concepts of information flow security and refinement are known to have had a troubled relationship ever since the seminal work of McLean. In this work we study refinements that support changes in data representation and semantics, including the addition of state variables that may induce new observational power or side channels. We propose a new epistemic approach to ignorance-preserving refinement where an abstract model is used as a specification of a system\u2019s permitted information flows, that may include the declassification of secret information. The core idea is to require that refinement steps must not induce observer knowledge that is not already available in the abstract model.  Our study is set in the context of a class of shared variable multi-agent models similar to interpreted systems in epistemic logic. We demonstrate the expressiveness of our framework through a series of small examples and compare our approach to existing, stricter notions of information-flow secure refinement based on bisimulations and noninterference preservation. Interestingly, noninterference preservation is not supported \u201cout of the box\u201d in our setting, because refinement steps may introduce new secrets that are independent of secrets already present at abstract level. To support verification, we first introduce a \u201ccube-shaped\u201d unwinding condition related to conditions recently studied in  the context of value-dependent noninterference, kernel verification, and secure compilation. A fundamental problem with ignorance-preserving refinement, caused by the support for general data and observation refinement, is that sequential composability is lost. We\u00a0\u2026", "num_citations": "2\n", "authors": ["1754"]}
{"title": "Analysis of the Client Puzzles protocol\n", "abstract": " This paper covers a certain proof of work protocol known as the client puzzles. The client puzzles is placed upon the protocol it is supposed to protect and is specifically designed to protect against connection depletion attacks. Our study is to determine how well the client puzzles protocol prevents connection depletion attacks and how it affects other parts of the system. To do this we choose to implement our own version of the client puzzles protocol and to see how it performs as well as read up on what other people has learned about its strengths and flaws. After implementing and trying with different sized puzzles we could determine that the client puzzles actually could provide some protection against connection depletion attacks though it also became clear that the protocol has some other issues. These flaws include increased vulnerability to distributed denial of service attacks by solving large amounts of puzzles on the clients, denial of service attacks by just requesting puzzles without solving them. Our conclusion of the client puzzles protocol is that while the protocol could solve the security issue it is supposed to, it provides with even more new problems. That combined with the fact that it needs software on all clients makes it a quite bad solution.", "num_citations": "2\n", "authors": ["1754"]}
{"title": "Brief announcement: the accuracy of tree-based counting in dynamic networks\n", "abstract": " We study a simple Bellman-Ford-like protocol which performs network size estimation over a tree-shaped overlay. A continuous time Markov model is constructed which allows key protocol characteristics to be estimated under churn, including the expected number of nodes at a given (perceived) distance to the root and, for each such node, the expected (perceived) size of the subnetwork rooted at that node. We validate the model by simulations, using a range of network sizes, node degrees, and churn-to-protocol rates, with convincing results.", "num_citations": "2\n", "authors": ["1754"]}
{"title": "The accuracy of tree-based counting in dynamic networks\n", "abstract": " Tree-based protocols are ubiquitous in distributed systems. They are flexible, they perform generally well, and, in static conditions, their analysis is mostly simple. Under churn, however, node joins and failures can have complex global effects on the tree overlays, making analysis surprisingly subtle. To our knowledge, few prior analytic results for performance estimation of tree based protocols under churn are currently known. We study a simple Bellman-Ford-like protocol which performs network size estimation over a tree-shaped overlay. A continuous time Markov model is constructed which allows key protocol characteristics to be estimated, including the expected number of nodes at a given (perceived) distance to the root and, for each such node, the expected (perceived) size of the subnetwork rooted at that node. We validate the model by simulation, using a range of network sizes, node degrees, and churn-to-protocol rates, with convincing results.", "num_citations": "2\n", "authors": ["1754"]}
{"title": "\u00b5-calculus with explicit points and approximations\n", "abstract": " We present a Gentzen-style sequent calculus for program verification which accomodates both model checking-like verification based on global state space exploration, and compositional reasoning. To handle the complexities arrising from the presence of fixed-point formulas, programs with dynamically evolving architecture, and cut rules we use transition assertions, and introduce fixed-point approximants explicitly into the assertion language. We address, in a game-based manner, the semantical basis of this approach, as it applies to the entailment subproblem. Soundness and completeness results are obtained, and examples are shown illustrating some of the concepts.", "num_citations": "2\n", "authors": ["1754"]}
{"title": "From Higher-Order 7r-Calculus to 7r-Calculus in the Presence of Static Operators\n", "abstract": " Some applications of higher-order processes require better control of communication capabilities than what is provided by the n-calculus primitives. In particular we have found the dynamic restriction operator of CHOCS, here called blocking, useful. We investigate the consequences of adding static operators such as blocking to the firstand higher-order 7r-calculus. In the presence of the blocking operator (and static operators in general) the higher-order reduction of Sangiorgi, used to demonstrate the reducibility of higher-order communication features to first-order ones, breaks down. We show, as our main result, that the higher-order reduction can be regained, using an approach by which higher-order communications are replaced, roughly, by the transmission and dynamic interpretation of syntax trees. However, the reduction is very indirect, and not usable in practice. This throws new light on the position that higher-order features in the 7r-calculus are superfluous and not needed in practice.", "num_citations": "2\n", "authors": ["1754"]}
{"title": "Analysis and Verification of Multiple-Agent Languages: 5th LOMAPS Workshop, Stockholm, Sweden, June 24-26, 1996, Selected Papers\n", "abstract": " This book originates from the 5th LOMAPS Workshop on Analysis and Verification of Multiple-Agent Languages, held in Stockholm, Sweden, in June 1996. LOMAPS is an ESPRIT project devoted to program analysis and verification techniques applicable to emerging multi-paradigm programming languages. The volume presents 14 revised full papers selected from the workshop submissions together with 4 invited contributions; also included is an introductory overview surveying the state of the art in the area and putting the contributions into this context.", "num_citations": "2\n", "authors": ["1754"]}
{"title": "Modalities in analysis and verification\n", "abstract": " Concurrent systems with program code-passing capabilities pose severe challenges to current technologies for program verification and analysis. We suggest higherorder modal and temporal logic as a tool for behavioral encapsulation of such systems. The difficulty is to provide usable and generally applicable tools for showing that a system satisfies the properties required of it. Compositional techniques have this potentiality and recent work appears to demonstrate that they may be more applicable than previously thought.", "num_citations": "2\n", "authors": ["1754"]}
{"title": "Formal verification of integrity-preserving countermeasures against cache storage side-channels\n", "abstract": " Formal verification of systems-level software such as hypervisors and operating systems can enhance system trustworthiness. However, without taking low level features like caches into account the verification may become unsound. While this is a well-known fact wrt timing leaks, few works have addressed latent cache storage side-channels, whose effects are not limited to information leakage. We present a verification methodology to analyse soundness of countermeasures used to neutralise these channels. We apply the proposed methodology to existing countermeasures, showing that they allow to restore integrity of the system. We decompose the proof effort into verification conditions that allow for an easy adaption of our strategy to various software and hardware platforms. As case study, we extend the verification of an existing hypervisor whose integrity can be tampered using cache storage channels. We used the HOL4 theorem prover to validate our security analysis, applying the verification methodology to a generic hardware model.", "num_citations": "1\n", "authors": ["1754"]}
{"title": "Private information aggregation in large incomplete networks\n", "abstract": " Emerging approaches to network monitoring involve large numbers of agents collaborating to produce performance or security related statistics on huge and generally incomplete networks. The aggregation process often involves security or business-critical information which network providers are generally unwilling to share without strong privacy protection. We present efficient and scalable protocols for privately computing a large range of aggregation functions based on addition, disjunction, and max/min. For addition, we give a protocol that is informationtheoretically secure against a passive adversary, and which requires only one additional round compared to non-private protocols for computing sums. For disjunctions, we present both a computationally secure, and an information-theoretically secure solution. The latter uses a general composition approach which executes the sum protocol together with a standard multi-party protocol for a complete subgraph of \u201ctrusted servers\u201d. This can be used, for instance, when a large network can be partitioned into a smaller number of provider domains.", "num_citations": "1\n", "authors": ["1754"]}
{"title": "Information flow control for cryptographic applets\n", "abstract": " We consider the problem of protecting confidentiality of critical data such as private keys, pin\u2019s, or application data in the implementation of cryptographic protocols. The predominant model for prevention of covert flows, multi-level security, is not applicable in these kinds of applications, since cryptographic operations cause direct flows of secret information to the public domain. It is a matter of protocol analysis to ensure that these flows are in fact, and do not reveal any useful information about the secrets. The question is how to amend the multi-level security model to permit such flows to be taken into account. Based on earlier work on admissible interference we propose an automaton-based framework for describing flows of sensitive data, involving dynamically changing security levels. We give two successive generalisations of Volpano-Smith type non-interferencein terms of bisimulationlike relations\u00a0\u2026", "num_citations": "1\n", "authors": ["1754"]}
{"title": "Verification of confidentiality properties for Java Card applets\n", "abstract": " This paper reports on a case study in the verification of confidentiality of smart card applications. The object of study is an elementary applet implementing a well-known mutual authentication protocol. Since this protocol builds on public-key cryptography, the applet poses important challenges to current automatic verification technology for confidentiality. The protocol implementation is first analyzed using Jif, a state-of-the art information flow analysis tool. Because it is based on (an enhanced version of) the multi-level security model, Jif was not designed to cope with the kind of information declassification inherent to cryptographic applications. To circumvent this difficulty, the analysis is complemented with a more standard functional verification using ESC/Java, an extended-static checker. It is then argued that this combination of approaches can be given a formal foundation using the notion of admissibility\u00a0\u2026", "num_citations": "1\n", "authors": ["1754"]}
{"title": "Compositional verification of mobile process networks\n", "abstract": " In this paper we study the problem of verifying general temporal and functional properties of mobile and dynamic process networks, cast in terms of the pi-calculus. Much of the expressive power of this calculus derives from the combination of name generation and communication (to handle mobility) with dynamic process creation. In the paper we introduce the--calculus, an extension of the modal mu-calculus with name equality, inequality, rst-order universal and existential quanti cation, and primitives for name input and output as an appropriate temporal logic for the picalculus. A compositional proof system is given with the scope of verifying dynamic networks of pi-calculus agents against properties speci ed in this logic. The proof system is shown to be sound in general and complete for the modal fragment of the speci cation logic. Milner's encoding of data types into the pi-calculus provide an interesting application study, since the encodings make essential use of all the distinguishing features of the pi-calculus, including dynamic process creation. As an example we suggest an encoding of the type of natural numbers and demonstrate how the proof system can be used to formally establish type correctness properties. As a ssecond example we show how the proof system can be used to uniformly prove properties of chained bu ers.", "num_citations": "1\n", "authors": ["1754"]}
{"title": "``On the Decidability of Process Equivalences for the\n", "abstract": " We present general results for showing process equivalences applied to the finite control fragment of the r-calculus decidable. Firstly a Finite Reachability Theorem states that up to finite name spaces and up to a static normalisation procedure, the set of reachable agent expressions is finite. Secondly a Boundedness Lemma shows that no potential computations are missed when name spaces are chosen large enough, but finite. We show how these results lead to decidability for a number of i-calculus equivalences such as strong or weak, late or early bismulation equivalence. Furthermore, for strong late equivalence we show how our techniques can be used to adapt the well-known Paige-Tarjan algorithm. Strikingly this results in a single exponential running time not much worse than the running time for the case of for instance CCS. Our results considerably strengthens previous results on decidable equivalences for parameter-passing process calculi.", "num_citations": "1\n", "authors": ["1754"]}
{"title": "On adaptable support for cooperative work\n", "abstract": " A critical dimension in the handling of change in computer-based systems for cooperative work is whether mechanisms for change should be explicitly embedded into systems, or whether change should be handled in a global and uniform manner, for instance by a process of editing and recompiling programs or scripts on the fly. We argue that to reflect the structure of organisations, powers of change must be local, structured, and dynamic. Thus a global and uniform handling of change is in general insufficient. We propose a formal basis for the description of dynamically modifiable objects, and explore its applicability in the field of CSCW by exposing it to three examples of increasing complexity: A system for dynamic communication channel creation; an adaptable conversation manager; and a rudimentary, yet quite general, awareness model.", "num_citations": "1\n", "authors": ["1754"]}