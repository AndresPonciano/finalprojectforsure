{"title": "Modularizing design patterns with aspects: a quantitative study\n", "abstract": " Design patterns offer flexible solutions to common problems in software development. Recent studies have shown that several design patterns involve crosscutting concerns. Unfortunately, object-oriented (OO) abstractions are often not able to modularize those crosscutting concerns, which in turn compromise the system reusability and maintainability. Hence, it is important verifying whether aspect-oriented approaches support improved modularization of crosscutting concerns relative to design patterns. Ideally, quantitative studies should be performed to compare OO and aspect-oriented implementations of classical patterns with respect to fundamental software engineering attributes, such as coupling and cohesion. This paper presents a quantitative study that compares Java and AspectJ solutions for the 23 Gang-of-Four patterns. We have used stringent software attributes as the assessment criteria. We\u00a0\u2026", "num_citations": "437\n", "authors": ["1209"]}
{"title": "Composing design patterns: a scalability study of aspect-oriented programming\n", "abstract": " Pattern composition has been shown as a challenge to applying design patterns in real software systems. One of the main problems is that multiple design patterns in a system are not limited to affect only the application concerns. They also crosscut each other in multiple heterogeneous ways so that their separation and composition are far from being trivial. In this context, it is of paramount importance to systematically verify whether aspect-oriented programming (AOP) supports improved composability of design patterns. This paper presents a systematic investigation on how AOP scales up to deal with modularization of pattern-specific concerns in the presence of pattern interactions. We have made both qualitative and quantitative assessments of 62 pairwise compositions taken from 3 medium-sized systems implemented in Java and AspectJ programming languages. Our analysis has also included the evaluation\u00a0\u2026", "num_citations": "146\n", "authors": ["1209"]}
{"title": "Extracting software product lines: A case study using conditional compilation\n", "abstract": " Software Product Line (SPL) is a development paradigm that targets the creation of variable software systems. Despite the increasing interest in product lines, research in the area usually relies on small systems implemented in the laboratories of the authors involved in the investigative work. This characteristic hampers broader conclusions about industry-strength product lines. Therefore, in order to address the unavailability of public and realistic product lines, this paper describes an experiment involving the extraction of a SPL for ArgoUML, an open source tool widely used for designing systems in UML. Using conditional compilation we have extracted eight complex and relevant features from ArgoUML, resulting in a product line called ArgoUML-SPL. By making the extracted SPL publicly available, we hope it can be used to evaluate the various flavors of techniques, tools, and languages that have been proposed\u00a0\u2026", "num_citations": "136\n", "authors": ["1209"]}
{"title": "Understanding the longevity of code smells: preliminary results of an explanatory survey\n", "abstract": " There is growing empirical evidence that some (patterns of) code smells seem to be, either deliberately or not, ignored. More importantly, there is little knowledge about the factors that are likely to influence the longevity of smell occurrences in software projects. Some of them might be related to limitations of tool support, while others might be not. This paper presents the preliminary results of an explanatory survey aimed at better understanding the longevity of code smells in software projects. A questionnaire was elaborated and distributed to developers, and 33 answers were collected up to now. Our preliminary observations reveal, for instance, that smell removal with refactoring tools is often avoided when maintaining frameworks or product lines.", "num_citations": "97\n", "authors": ["1209"]}
{"title": "On the maintainability of aspect-oriented software: A concern-oriented measurement framework\n", "abstract": " Aspect-oriented design needs to be systematically assessed with respect to modularity flaws caused by the realization of driving system concerns, such as tangling, scattering, and excessive concern dependencies. As a result, innovative concern metrics have been defined to support quantitative analyses of concern's properties. However, the vast majority of these measures have not yet being theoretically validated and managed to get accepted in the academic or industrial settings. The core reason for this problem is the fact that they have not been built by using a clearly-defined terminology and criteria. This paper defines a concern-oriented framework that supports the instantiation and comparison of concern measures. The framework subsumes the definition of a core terminology and criteria in order to lay down a rigorous process to foster the definition of meaningful and well-founded concern measures. In order\u00a0\u2026", "num_citations": "96\n", "authors": ["1209"]}
{"title": "On the modularity of software architectures: A concern-driven measurement framework\n", "abstract": " Much of the complexity of software architecture design is derived from the inadequate modularization of key broadly-scoped concerns, such as exception handling, distribution, and persistence. However, conventional architecture metrics are not sensitive to the driving architectural concerns, thereby leading a number of false positives and false negatives in the design assessment process. Therefore, there is a need for assessment techniques that support a more effective identification of early design modularity anomalies relative to crosscutting concerns. In this context, this paper proposes a concern-driven measurement framework for assessing architecture modularity. It encompasses a mechanism for documenting architectural concerns, and a suite of concern-oriented architecture metrics. We evaluated the usefulness of the proposed framework while comparing the modularity of architecture design\u00a0\u2026", "num_citations": "92\n", "authors": ["1209"]}
{"title": "Exceptions and aspects: The devil is in the details\n", "abstract": " It is usually assumed that the implementation of exception handling can be better modularized by the use of aspect-oriented programming (AOP). However, the trade-offs involved in using AOP with this goal are not well-understood. This paper presents an in-depth study of the adequacy of the AspectJ language for modularizing exception handling code. The study consisted in refactoring existing applications so that the code responsible for implementing heterogeneous error handling strategies was moved to separate aspects. We have performed quantitative assessments of four systems-three object-oriented and one aspect-oriented-based on four quality attributes, namely separation of concerns, coupling, cohesion, and conciseness. Our investigation also included a multi-perspective analysis of the refactored systems, including (i) the reusability of the aspectized error handling code,(ii) the beneficial and harmful\u00a0\u2026", "num_citations": "92\n", "authors": ["1209"]}
{"title": "A systematic mapping study on game-related methods for software engineering education\n", "abstract": " ContextThe use of games in software engineering education is not new. However, recent technologies have provided new opportunities for using games and their elements to enhance learning and student engagement.ObjectiveThe goal of this paper is twofold. First, we discuss how game-related methods have been used in the context of software engineering education by means of a systematic mapping study. Second, we investigate how these game-related methods support specific knowledge areas from software engineering. By achieving these goals, we aim not only to characterize the state of the art on the use of game-related methods on software engineering education, but also to identify gaps and opportunities for further research.MethodWe carried out a systematic mapping study to identify primary studies which address the use, proposal or evaluation of games and their elements on software engineering\u00a0\u2026", "num_citations": "83\n", "authors": ["1209"]}
{"title": "Ejflow: taming exceptional control flows in aspect-oriented programming\n", "abstract": " Many of the problems that stem from the use of exception handling are caused by the local way in which exceptions are handled. It demands that developers understand the source of an exception, the place where it is handled, and everything in between. As a consequence, exceptions easily get\" out of control\" and, as system development progresses, exceptional control flows become less well-understood, with potentially negative consequences for the program maintainability and reliability. This paper presents an innovative aspect-oriented model for exception handling implementation. In contrast to other exception handling mechanisms, our model provides abstractions to explicitly describe global views of exceptional control flows. As a result, this new model makes it possible to understand exception flows from an end-to-end perspective by looking at a single part of the program. Also, it leverages existing\u00a0\u2026", "num_citations": "78\n", "authors": ["1209"]}
{"title": "A systematic literature review of software product line management tools\n", "abstract": " Software Product Line (SPL) management is a key activity for software product line engineering. The idea behind SPL management is to focus on artifacts that are shared in order to support software reuse and adaptation. Gains are expected in terms of time to market, consistency across products, costs reduction, better flexibility, and better management of change requirements. In this context, there are many available options of SPL variability management tools. This paper presents and discusses the findings from a Systematic Literature Review (SLR) of SPL management tools. Our research method aimed at analyzing the available literature on SPL management tools and the involved experts in the field. This review provides insights (i) to support companies interested to choose a tool for SPL variability management that best fits their needs; (ii) to point out attributes and requirements relevant to those\u00a0\u2026", "num_citations": "72\n", "authors": ["1209"]}
{"title": "Crosscutting patterns and design stability: An exploratory analysis\n", "abstract": " It is often claimed that inaccurate modularisation of crosscutting concerns hinders program comprehension and, as a consequence, leads to harmful software instabilities. However, recent studies have pointed out that crosscutting concerns are not always harmful to design stability. Hence, software maintainers would benefit from well documented patterns of crosscutting concerns and a better understanding about their actual impact on design stability. This paper presents a catalogue of crosscutting concern patterns recurrently observed in software systems. These patterns are described and classified based on an intuitive vocabulary that facilitates their recognition by software engineers. We analysed instances of the crosscutting patterns in object-oriented and aspect-oriented versions of three evolving programs. The outcomes of our exploratory evaluation indicated that: (i) a certain category of crosscutting patterns\u00a0\u2026", "num_citations": "50\n", "authors": ["1209"]}
{"title": "Towards a unified coupling framework for measuring aspect-oriented programs\n", "abstract": " There is nowadays a wide recognition that low coupling is a main tenet in the measurement of high-quality modular software. In fact, coupling is one of the few internal software attributes that has been both theoretically and empirically shown to have a large impact on a variety of external software qualities, such as reusability, maintainability, evolvability and testability. Aspect-oriented programming (AOP) is an emerging technique that advocates enhanced modularization of certain widely-scoped system properties, the so-called crosscutting concerns. However, there is a poor common understanding of coupling in the context of AOP. Most of the existing metrics and assessment frameworks concentrate on the coupling evaluation of the AspectJ programming language. In addition, they took their own particular view of what coupling means in this particular language. This paper presents the definition of a generic\u00a0\u2026", "num_citations": "49\n", "authors": ["1209"]}
{"title": "On the evaluation of code smells and detection tools\n", "abstract": " Code smells refer to any symptom in the source code of a program that possibly indicates a deeper problem, hindering software maintenance and evolution. Detection of code smells is challenging for developers and their informal definition leads to the implementation of multiple detection techniques and tools. This paper evaluates and compares four code smell detection tools, namely inFusion, JDeodorant, PMD, and JSpIRIT. These tools were applied to different versions of the same software systems, namely MobileMedia and Health Watcher, to calculate the accuracy and agreement of code smell detection tools. We calculated the accuracy of each tool in the detection of three code smells: God Class, God Method, and Feature Envy. Agreement was calculated among tools and between pairs of tools. One of our main findings is that the evaluated tools present different levels of accuracy in different contexts. For MobileMedia, for instance, the average recall varies from 0 to 58% and the average precision from 0 to 100%, while for Health Watcher the variations are 0 to 100% and 0 to 85%, respectively. Regarding the agreement, we found that the overall agreement between tools varies from 83 to 98% among all tools and from 67 to 100% between pairs of tools. We also conducted a secondary study of the evolution of code smells in both target systems and found that, in general, code smells are present from the moment of creation of a class or method in 74.4% of the cases of MobileMedia and 87.5% of Health Watcher.", "num_citations": "48\n", "authors": ["1209"]}
{"title": "Early crosscutting metrics as predictors of software instability\n", "abstract": " Many researchers claim that crosscutting concerns, which emerge in early software development stages, are harmful to software stability. On the other hand, there is a lack of effective metrics that allow software developers to understand and predict the characteristics of \u201cearly\u201d crosscutting concerns that lead to software instabilities. In general, existing crosscutting metrics are defined for specific programming languages and have been evaluated only against source-code analysis, when major design decisions have already been made. This paper presents a generic suite of metrics to objectively quantify key crosscutting properties, such as scattering and tangling. The definition of the metrics is agnostic to particular language intricacies and can be applied to all early software development artifacts, such as usecases and scenarios. We have performed a first stability study of crosscutting on requirements\u00a0\u2026", "num_citations": "44\n", "authors": ["1209"]}
{"title": "Assessing aspect-oriented artifacts: Towards a tool-supported quantitative method\n", "abstract": " Aspect-oriented (AO) software development is an emerging paradigm that provides new abstractions and mechanisms to support the modularization of crosscutting concerns through the software development. However, the achievement of high-quality AO software is not trivial. The inappropriate use of aspect-oriented abstractions and mechanisms potentially leads to the violation of important design principles, such as low coupling, high cohesion, incomplete modularization of crosscutting concerns into aspects, and so forth. These problems are not easily detectable and an ad hoc analysis of large designs and implementations is often expensive and time-consuming. Hence there is a need for an assessment method that assists software engineers in the analysis of their AO designs and implementations. This paper reports our efforts in the ongoing development of a systematic approach to support the quantitative assessment of aspect-oriented artifacts generated through the system design and implementation. The approach is organized in a stepwise fashion and is founded on a metrics suite and a comprehensive set of complementary rules. Our proposal is supported by a prototype measurement tool and has been applied to four medium-sized software systems in different domains and with distinct degrees of complexity.", "num_citations": "44\n", "authors": ["1209"]}
{"title": "Applying and evaluating concern-sensitive design heuristics\n", "abstract": " Manifestation of crosscutting concerns in software systems is often an indicative of design modularity flaws and further design instabilities as those systems evolve. Without proper design evaluation mechanisms, the identification of harmful crosscutting concerns can become counter-productive and impractical. Nowadays, metrics and heuristics are the basic mechanisms to support their identification and classification either in object-oriented or aspect-oriented programs. However, conventional mechanisms have a number of limitations to support an effective identification and classification of crosscutting concerns in a software system. In this paper, we claim that those limitations are mostly caused by the fact that existing metrics and heuristics are not sensitive to primitive concern properties, such as either their degree of tangling and scattering or their specific structural shapes. This means that modularity assessment\u00a0\u2026", "num_citations": "43\n", "authors": ["1209"]}
{"title": "Gamification in software engineering education: An empirical study\n", "abstract": " Gamification is the application of game-design elements and game principles in non-game contexts. Gamification is a relatively new trend that has been applied in various domains, including Software Engineering. However, few studies have explored the potential of gamification in the context of Software Engineering education. In this paper, we describe an experience of introducing two game elements, namely badges and leaderboards, in an introductory Software Engineering course. Our goal is to evaluate the students' perception on the impact of these elements in their motivation towards the course. We conducted a survey with 18 participants for quantitative results, and a series of interviews with 6 participants for a qualitative perspective on the results. We observed that students received badges positively, while there were mixed results about the use of leaderboards in our strategy. The main benefits on the use\u00a0\u2026", "num_citations": "39\n", "authors": ["1209"]}
{"title": "Detecting Code Smells in Software Product Lines--An Exploratory Study\n", "abstract": " Code smells are symptoms that something is wrong in the source code. They have been catalogued and investigated in several programming techniques. These techniques can be used to develop Software Product Lines (SPL). However, feature-oriented programming (FOP) is a specific technique to deal with the modularization of features in SPL. One of the most popular FOP languages is AHEAD and, as far as we are concerned, we still lack systematic studies on the categorization and detection of code smells in AHEADFOP languages-based SPL. To fill this gap, this paper extends the definitions of three traditional code smells, namely God Method, God Class, and Shotgun Surgery, to take into account FOP abstractions. We then proposed 8 new FOP measures to quantify specific characteristics of compositional approaches like AHEAD. Finally, we combine the proposed and existing measures to define 3\u00a0\u2026", "num_citations": "38\n", "authors": ["1209"]}
{"title": "On the relationship of concern metrics and requirements maintainability\n", "abstract": " ContextMaintainability has become one of the most essential attributes of software quality, as software maintenance has shown to be one of the most costly and time-consuming tasks of software development. Many studies reveal that maintainability is not often a major consideration in requirements and design stages, and software maintenance costs may be reduced by a more controlled design early in the software life cycle. Several problem factors have been identified as harmful for software maintainability, such as lack of upfront consideration of proper modularity choices. In that sense, the presence of crosscutting concerns is one of such modularity anomalies that possibly exert negative effects on software maintainability. However, to the date there is little or no knowledge about how characteristics of crosscutting concerns, observable in early artefacts, are correlated with maintainability.ObjectiveIn this setting\u00a0\u2026", "num_citations": "36\n", "authors": ["1209"]}
{"title": "On the Modularity Assessment of Software Architectures: Do my architectural concerns count\n", "abstract": " Much of the complexity of software architecture design is derived from the inadequate modularization of key broadly-scoped concerns, such as exception handling and persistence. However, conventional architecture metrics are not sensitive to the driving architectural concerns, thereby leading a number of false positives and false negatives in the design assessment process. Hence, there is a need for assessment techniques that support a more effective identification of early design modularity anomalies relative to crosscutting concerns. In this context, this paper proposes a concern-driven measurement framework for assessing architecture modularity. It encompasses a mechanism for documenting architectural concerns, and a suite of concern-driven architecture metrics. We evaluated the usefulness of the proposed framework while comparing the modularity of aspect-oriented (AO) and non-AO architecture design alternatives in three different case studies.", "num_citations": "36\n", "authors": ["1209"]}
{"title": "Games for learning: Bridging game-related education methods to software engineering knowledge areas\n", "abstract": " The use of games in software engineering education is not new. However, recent technologies have provided new opportunities for using games and their elements to enhance learning and student engagement. The goal of this paper is twofold. First, we discuss how game related methods have been used in the context of software engineering education by means of a systematic mapping study. Second, we investigate how these game related methods support specific knowledge areas from software engineering. The systematic mapping study identified 106 primary studies describing the use of serious games, gamification and game development in software engineering education. Based on this mapping, we aimed to track the learning goals of each primary study to the knowledge areas defined in ACM/IEEE curricular recommendations. As a result, we observed that \"Software Process\", \"Software Design\" and\u00a0\u2026", "num_citations": "32\n", "authors": ["1209"]}
{"title": "Microservices in practice: A survey study\n", "abstract": " Microservices architectures have become largely popular in the last years. However, we still lack empirical evidence about the use of microservices and the practices followed by practitioners. Thereupon, in this paper, we report the results of a survey with 122 professionals who work with microservices. We report how the industry is using this architectural style and whether the perception of practitioners regarding the advantages and challenges of microservices is according to the literature.", "num_citations": "29\n", "authors": ["1209"]}
{"title": "AJATO: An AspectJ assessment tool\n", "abstract": " Aspect-oriented software development [3] is an emerging paradigm that provides new mechanisms to support the modularization of concerns, which otherwise would crosscut the OO system decomposition. However, the accurate identification of concerns to be aspectized is far from being trivial [2, 4], and it requires a systematic design assessment and reasoning about multiple modularity principles [2]. Even the aspectization of certain tangled and scattered concerns can negatively affect fundamental software attributes, such as coupling, cohesion, and conciseness [2, 4]. In this context, this paper presents an assessment tool, called AJATO [5], to support the quantitative assessment of AO software artefacts. The goals of the tool are:(i) to compute existing AO metrics, and (ii) to support the application of a heuristics suite. Most of the AO metrics available in our tool are based on traditional metrics, such as lines of code, and on extensions of those widely used with object-oriented design, such as the Chidamber and Kemerer metrics. Besides, the metrics suite also encompasses new metrics for measuring separation of concerns [4]. Some of the metrics available in AJATO are Concern Diffusion over Components (CDC), Number of Attributes per Concern (NOAconcern), Number of Operations per Concern (NOOconcern), Vocabulary Size (VS), Number of Attributes (NOA), and Number of Operations (NOO).In addition to the metrics, our assessment tool also implements some heuristics rules in order to automate some modularity analysis about the numbers. For example, the set of heuristics provides contextual information on how the realization of a given\u00a0\u2026", "num_citations": "28\n", "authors": ["1209"]}
{"title": "Co-occurrence of design patterns and bad smells in software systems: An exploratory study\n", "abstract": " A design pattern is a general reusable solution to a recurring problem in software design. Bad smells are symptoms that may indicate something wrong in the system design or code. Therefore, design patterns and bad smells represent antagonistic structures. They are subject of recurring research and typically appear in software systems. Although design patterns represent good design, their use is often inadequate because their implementation is not always trivial or they may be unnecessarily employed. The inadequate use of design patterns may lead to a bad smell. Therefore, this paper performs an exploratory study in order to identify instances of co-occurrences of design patterns and bad smells. This study is performed over five systems and discovers some co-occurrences between design patterns and bad smells. For instance, we observed the co-occurrences of Command with God Class and Template Method with Duplicated Code. The results of this study make it possible to understand in which situations design patterns are misused or overused and establish guidelines for their better use.", "num_citations": "23\n", "authors": ["1209"]}
{"title": "On the modularization and reuse of exception handling with aspects\n", "abstract": " This paper presents an in\u2010depth study of the adequacy of the AspectJ language for modularizing and reusing exception\u2010handling code. The study consisted of refactoring existing applications so that the code responsible for implementing error\u2010handling strategies was moved to newly created exception handler aspects. We have performed quantitative assessments of five systems\u2014four object\u2010oriented and one aspect\u2010oriented\u2014based on four key quality attributes, namely separation of concerns, coupling, cohesion, and conciseness. Our investigation also included a multi\u2010perspective analysis of the refactored systems, including (i) the extent to which error\u2010handling aspects can be reused, (ii) the beneficial and harmful aspectization scenarios for exception handling, and (iii) the scalability of AOP to support the modularization of exception handling in the presence of other aspects. Copyright \u00a9 2009 John Wiley &\u00a0\u2026", "num_citations": "23\n", "authors": ["1209"]}
{"title": "Splconfig: Product configuration in software product line\n", "abstract": " Software product line (SPL) is a set of software systems that share a common set of features satisfying the specific needs of a particular market segment. A feature represents an increment in functionality relevant to some stakeholders. SPLs commonly use a feature model to capture and document common and varying features. The key challenge of using feature models is to derive a product configuration that satisfies all business and customer requirements. To address this challenge, this paper presents a tool, called SPLConfig, to support business during product configuration in SPL. Based on feature models, SPLConfig automatically finds an optimal product configuration that maximizes the customer satisfaction.", "num_citations": "22\n", "authors": ["1209"]}
{"title": "ConcernMorph: metrics-based detection of crosscutting patterns\n", "abstract": " Crosscutting concerns can hinder maintainability of a design because they do not adhere to a system's underlying modular structure. Developers, therefore, may wish to refactor designs to improve modularisation or to implement crosscutting concerns as aspects. However, few tools currently exist that assist developers in detecting and classifying crosscutting concerns in their code. Classification is important because, as recent studies have shown, crosscutting concerns are not always harmful. This paper describes a tool, ConcernMorph, for identifying crosscutting concerns and classifying them into one of a number of predefined crosscutting patterns.", "num_citations": "22\n", "authors": ["1209"]}
{"title": "How do programmers use optional typing? An empirical study\n", "abstract": " The recent popularization of dynamically typed languages, such as Ruby and JavaScript, has brought more attention to the discussion about the impact of typing strategies on development. Types allow the compiler to find type errors earlier and potentially improve the readability and maintainability of code. On the other hand,\" untyped\" code may be easier to change and require less work from programmers. This paper tries to identify the programmers' point of view about these tradeoffs. An analysis of the source code of 6638 projects written in Groovy, a programming language which features optional typing, shows in which scenarios programmers prefer to type or not to type their declarations. Our results show that types are popular in the definition of module interfaces, but are less used in scripts, test classes and frequently changed code. There is no correlation between the size and age of projects and how their\u00a0\u2026", "num_citations": "18\n", "authors": ["1209"]}
{"title": "Refactoring of crosscutting concerns with metaphor-based heuristics\n", "abstract": " It has been advocated that Aspect-Oriented Programming (AOP) is an effective technique to improve software maintainability through explicit support for modularising crosscutting concerns. However, in order to take the advantages of AOP, there is a need for supporting the systematic refactoring of crosscutting concerns to aspects. Existing techniques for aspect-oriented refactoring are too fine-grained and do not take the concern structure into consideration. This paper presents two categories towards a metaphor-based classification of crosscutting concerns driven by their manifested shapes through a system's modular structure. The proposed categories provide an intuitive and fundamental terminology for detecting concern-oriented design flaws and identifying refactorings in terms of recurring crosscutting structures. On top of this classification, we define a suite of metaphor-based refactorings to guide the\u00a0\u2026", "num_citations": "18\n", "authors": ["1209"]}
{"title": "Experimental evaluation of code smell detection tools\n", "abstract": " Code smells are code fragments that can hinder the evolution and maintenance of software systems. Their detection is a challenge for developers and their informal definition leads to the implementation of multiple detection techniques by tools. This paper aims to evaluate and compare three code smell detection tools, namely inFusion, JDeodorant and PMD. These tools were applied to different versions of a same system. The results were analyzed to answer four research questions related to the evolution of the smells, the relevance of the smells detected, and the agreement among tools. This study allowed us to understand the evolution of code smells in the target system and to evaluate the accuracy of each tool in the detection of three code smells: God Class, God Method, and Feature Envy.", "num_citations": "17\n", "authors": ["1209"]}
{"title": "Students perception on the use of project-based learning in software engineering education\n", "abstract": " Balancing theory and practice is a recurring challenge in Software Engineering (SE) education. However, the curriculum guidelines of the ACM/IEEE and Brazilian Computer Society emphasize the need of providing students with sufficient practical experiences for the development of competences expected for SE professional. Student-centered and learn-by-doing approaches, such as Project-Based Learning (PBL), have been advocated as suited for the development of competences. These approaches aim to promote higher motivation for the learner, a more active role in the learning process, and better learning in the application level. The goal of this paper is to evaluate the students' perception on the adoption of PBL in SE education. To achieve this goal, we performed a long-term study spanning for about 2 years. This study includes a survey to collect responses of 32 undergraduate students enrolled in an\u00a0\u2026", "num_citations": "15\n", "authors": ["1209"]}
{"title": "Game Elements for Learning Programming: A Mapping Study.\n", "abstract": " Serious games have been used as a tool to support learning in several areas and subjects. To achieve its educational goals, a serious game must consist of a set of game elements that are related to the learning outcomes. In Computer Science, educators are also using serious games and their elements to enhance learning of programming-related disciplines, which are often considered challenging by first-year students. It is important for educators in Computer Science to know what are the types of game elements used in games to learn programming. Besides that, it is also important to know how game elements are evaluated and what are the game elements that mostly contribute to learning achievements. In this work, we aim to verify how serious games and their composing elements are used and evaluated to support learning programming. To achieve this goal, we conducted a systematic mapping study on the use and evaluation of game elements for learning programming. Our results indicate that game elements are only evaluated indirectly by means of their serious games. Furthermore, we identify some shortcomings in game elements evaluation, such as the lack of evaluation in some primary studies and low number of quantitative studies.", "num_citations": "15\n", "authors": ["1209"]}
{"title": "Heuristic and exact algorithms for product configuration in software product lines\n", "abstract": " Software product line (SPL) is a set of software applications that share a common set of features satisfying the specific needs of a particular market segment. SPL engineering is a paradigm to develop software applications that commonly use a feature model to capture and document common and variable features, and their relationships. A big challenge is to derive one product among all possible products in the SPL, which satisfies the business and customer requirements. This task is known as product configuration. Although product configuration has been extensively investigated in the literature, customer's preferences are frequently neglected. In this paper, we propose a novel approach to configure a product that considers both qualitative and quantitative feature properties. We model the product configuration task as a combinatorial optimization problem, and heuristic and exact algorithms are proposed. As far\u00a0\u2026", "num_citations": "15\n", "authors": ["1209"]}
{"title": "An Empirical Study of Two Software Product Line Tools.\n", "abstract": " In the last decades, software product lines (SPL) have proven to be an efficient software development technique in industries due its capability to increase quality and productivity and decrease cost and time-tomarket through extensive reuse of software artifacts. To achieve these benefits, tool support is fundamental to guide industries during the SPL development life-cycle. However, many different SPL tools are available nowadays and the adoption of the appropriate tool is a big challenge in industries. In order to support engineers choosing a tool that best fits their needs, this paper presents the results of a controlled empirical study to assess two Eclipse-based tools, namely FeatureIDE and pure:: variants. This empirical study involved 84 students who used and evaluated both tools. The main weakness we observe in both tools are the lack adequate mechanisms for managing the variability, such as for product configuration. As a strength, we observe the automated analysis and the feature model editor.", "num_citations": "15\n", "authors": ["1209"]}
{"title": "A systematic review of contemporary metrics for software maintainability\n", "abstract": " Previous studies have been conducted with the aim of increasing the system quality. As a result, some contemporary technologies have been proposed for software development to improve maintainability, such as feature-oriented and aspect-oriented programming. Metrics are used to quantify the quality of systems developed in these technologies. Recently, contemporary metrics have been proposed or adapted from existing ones to evaluate specific issues of these contemporary technologies. This paper presents results of applying a systematic literature review to identify contemporary metrics associated with software maintainability and proposed for the feature-oriented and aspect-oriented technologies. Initially, we identify 672 published works and, after the primary selection, these quantity was reduced to 11 papers. These papers account for 33 and 78 contemporary metrics for feature-oriented and aspect\u00a0\u2026", "num_citations": "15\n", "authors": ["1209"]}
{"title": "A literature review and comparison of three feature location techniques using ArgoUML-SPL\n", "abstract": " Over the last decades, the adoption of Software Product Line (SPL) engineering for supporting software reuse has increased. An SPL can be extracted from one single product or from a family of related software products, and feature location strategies are widely used for variability mining. Several feature location strategies have been proposed in the literature and they usually aim to map a feature to its source code implementation. In this paper, we present a systematic literature review that identifies and characterizes existing feature location strategies. We also evaluated three different strategies based on textual information retrieval in the context of the ArgoUML-SPL feature location case study. In this evaluation, we compare the strategies based on their ability to correctly identify the source code of several features from ArgoUML-SPL ground truth. We then discuss the strengths and weaknesses of each feature\u00a0\u2026", "num_citations": "14\n", "authors": ["1209"]}
{"title": "Games and gamification in software engineering education: A survey with educators\n", "abstract": " The use of games and game elements in software engineering education is not new. In fact, their use in Software Engineering education is found in research papers since 1974, with a notorious increase after 2000. However, there is little information about the actual adoption of these approaches in software engineering education. Therefore, the goal of this paper is to investigate the use of games and game elements in software engineering education, in the perspective of educators. To achieve this goal, this study proposes and analyzes the results of a survey answered by 88 software engineering professors. We sample the participants by inviting 285 educators mined from one hundred well-stablished universities and educational institutions of different regions of Brazil. The goal of the survey is (i) to collect information about the use of games and gamification in classrooms and (ii) to understand the relation of ACM\u00a0\u2026", "num_citations": "14\n", "authors": ["1209"]}
{"title": "On the evaluation of an open software engineering course\n", "abstract": " Open online courses are a method of online lecturing whose application in education is not bounded by space and location constraints. The successful implementation of open courses requires conceptual changes in how instructors and students behave in open unbounded education environment. There are some emerging open courses for teaching specific topics of Software Engineering. However, it is still limited the knowledge about the best practices for learning Software Engineering processes, methods, and tools in such an open environment. To address this limitation, this paper presents and evaluates an open course for Introduction to Software Engineering. The presented open course has over 250 online students registered and is based on a face-to-face equivalent. The online course is currently composed of 44 video lectures, 160 questions in 16 quizzes, and several discussion topics. We evaluate this\u00a0\u2026", "num_citations": "12\n", "authors": ["1209"]}
{"title": "Revealing mistakes in concern mapping tasks: an experimental evaluation\n", "abstract": " Concern mapping is the activity of assigning a stakeholder's concern to its corresponding elements in the source code. This activity is primordial to guide software maintainers in several tasks, such as understanding and restructuring the implementation of existing concerns. Even though different techniques are emerging to facilitate the concern mapping process, they are still manual and error-prone according to recent studies. Existing work does not provide any guidance to developers to review and correct concern mappings. In this context, this paper presents the characterization and classification of eight concern mapping mistakes commonly made by developers. These mistakes were found to be associated with various properties of concerns and modules in the source code. The mistake categories were derived from actual mappings of 10 concerns in 12 versions of industry systems. In order to further evaluate\u00a0\u2026", "num_citations": "12\n", "authors": ["1209"]}
{"title": "An Empirical Study on the Impact of Android Code Smells on Resource Usage.\n", "abstract": " Code smells are symptoms that something may be wrong with the app. Aiming at removing code smells and improving the maintainability and performance of the app, we may apply the refactoring technique, which could reduce hardware resource use, such as CPU and memory. However, a few studies have evaluated the impacts of the refactoring in Android. This paper presents a study to assess the effects of smartphone resource use caused by refactoring of 3 classic code smells: God Class, God Method, and Feature Envy. To this purpose, we selected 9 apps from GitHub. The results show that refactoring used in desktop software may not be appropriate for Android apps. For example, the refactoring of God Method had increased CPU consumption by more than 47%, while the refactoring of the 3 code smells reduced memory consumption in average 6.51%, 8.4%, and 6.37%, respectively, in one app. Our results can support the community in conducting research and future implementation of new tools. Also, it guides app developers in refactoring and thus improving the quality of their apps.", "num_citations": "11\n", "authors": ["1209"]}
{"title": "Evaluation of duplicated code detection tools in cross-project context\n", "abstract": " Two or more code segments are considered duplicated when there is a high rate of similarity among them or they are exactly the same. Aiming to detect duplicated code in single software projects, several tools have been proposed. However, in case of cross-project detection, there are few tools. There is little empirical knowledge about the efficacy of these tools to detect duplicated code across different projects. Therefore, our goal is to assess the efficacy of duplicated code detection tools for single projects in cross-project context. It was concluded that the evaluated tools has no sufficient efficacy in the detection of some types of duplicated code beyond exact copy-paste. As a result, this work proposes guidelines for future implementation of tools.", "num_citations": "10\n", "authors": ["1209"]}
{"title": "Concern-oriented heuristic assessment of design stability.\n", "abstract": " Software systems are always changing to address new stakeholders\u2019 concerns. Design modularity improves the stability of software by decoupling design concerns that are likely to change so that they can be maintained independently. Despite the efforts of modern programming languages, some concerns cannot be well modularised in the system design and implementation. These concerns, called crosscutting concerns, are often blamed to hinder design modularity and stability. However, recent studies have pointed out that crosscutting concerns are not always harmful to design stability. Hence, software maintainers would benefit from well documented patterns of crosscutting concerns and a better understanding about their actual impact on design stability. This document presents a catalogue of crosscutting patterns empirically observed in several software systems. These patterns are described and classified based on an intuitive vocabulary that facilitates their recognition by software engineers. Crosscutting patterns are detected by a heuristic assessment technique composed of metrics and heuristic rules. We also proposed a formalism to define the crosscutting patterns and their means of detection. This formalism includes a measurement framework and a meta-model of the concern realisation. The heuristic assessment technique is supported by a prototype tool which automates the detection of crosscutting patterns in software designs. The accuracy of the heuristic technique is assessed through their application to seven systems. Then, we select three of these systems to empirically evaluate the correlation of crosscutting patterns and\u00a0\u2026", "num_citations": "10\n", "authors": ["1209"]}
{"title": "Understanding machine learning software defect predictions\n", "abstract": " Software defects are well-known in software development and might cause several problems for users and developers aside. As a result, researches employed distinct techniques to mitigate the impacts of these defects in the source code. One of the most notable techniques focuses on defect prediction using machine learning methods, which could support developers in handling these defects before they are introduced in the production environment. These studies provide alternative approaches to predict the likelihood of defects. However, most of these works concentrate on predicting defects from a vast set of software features. Another key issue with the current literature is the lack of a satisfactory explanation of the reasons that drive the software to a defective state. Specifically, we use a tree boosting algorithm (XGBoost) that receives as input a training set comprising records of easy-to-compute characteristics\u00a0\u2026", "num_citations": "9\n", "authors": ["1209"]}
{"title": "How well do you know this library? mining experts from source code analysis\n", "abstract": " Third-party libraries have been widely adopted in modern software projects due to several benefits, such as code reuse and software quality. Software development is increasingly complex and requires specialists with knowledge in several technologies, such as the nowadays libraries. Such complexity turns it extremely challenging to deliver quality software given the time pressure. For this purpose, it is necessary to identify and hire qualified developers, to obtain a good team, both in open source and proprietary systems. For these reasons, enterprise and open source projects try to build teams composed of highly skilled developers in specific libraries. Developers with expertise in specific libraries may reduce the time spent on software development tasks and improve the quality of the final product. However, their identification may not be trivial. In this paper, we first argue that source code activities can be used to\u00a0\u2026", "num_citations": "8\n", "authors": ["1209"]}
{"title": "Cleangame: Gamifying the identification of code smells\n", "abstract": " Refactoring is the process of transforming the internal structure of existing code without changing its observable behavior. Many studies have shown that refactoring increases program maintainability and understandability. Due to these benefits, refactoring is recognized as a best practice in the software development community. However, prior to refactoring activities, developers need to look for refactoring opportunities, ie, developers need to be able to identify code smells, which essentially are instances of poor design and ill-considered implementation choices that may hinder code maintainability and understandability. However, code smell identification is overlooked in the Computer Science curriculum. Recently, Software Engineering educators have started exploring gamification, which entails using game elements in non-game contexts, to improve instructional outcomes in educational settings. The potential of\u00a0\u2026", "num_citations": "8\n", "authors": ["1209"]}
{"title": "Detecting bad smells with machine learning algorithms: an empirical study\n", "abstract": " Bad smells are symptoms of bad design choices implemented on the source code. They are one of the key indicators of technical debts, specifically, design debt. To manage this kind of debt, it is important to be aware of bad smells and refactor them whenever possible. Therefore, several bad smell detection tools and techniques have been proposed over the years. These tools and techniques present different strategies to perform detections. More recently, machine learning algorithms have also been proposed to support bad smell detection. However, we lack empirical evidence on the accuracy and efficiency of these machine learning based techniques. In this paper, we present an evaluation of seven different machine learning algorithms on the task of detecting four types of bad smells. We also provide an analysis of the impact of software metrics for bad smell detection using a unified approach for interpreting\u00a0\u2026", "num_citations": "7\n", "authors": ["1209"]}
{"title": "Understanding similarities and differences in software development practices across domains\n", "abstract": " Since software engineering is globalized and not a homogeneous whole, we expect that development practices are differently adopted across domains. However, little is known about how practices are followed in different software domains (e.g., healthcare, banking, and Oil and gas). In this paper, we report the results of an exploratory and inductive research, in which we seek differences and similarities regarding the adoption of several widespread practices across 13 domains. We interviewed 19 worldwide developers with experience in multiple domains (i.e., cross-domain developers) from large multinational companies, such as Facebook, Google, and Macy's. We also run a Web survey to confirm (or not) the interview results. Our findings show that, in fact, different domains adopt practices in a different fashion. We identified that continuous integration practices are interrupted during important commerce periods\u00a0\u2026", "num_citations": "7\n", "authors": ["1209"]}
{"title": "Exploring Game Elements in Learning Programming: An Empirical Evaluation\n", "abstract": " The worldwide demand for software developers are increasing, however, students are facing problems to learn programming at universities. To make things worse, the failure and dropout rates are high, especially in introductory computer programming courses. To address this type of problem, new strategies have been proposed to engage students in programming courses. One strategy is to use game elements to learn programming. Game elements are important for the success or failure of an educational serious game. In the same way, the students' learning process may benefit from proper use of game elements. In this work, we aim to identify and evaluate which game elements contribute to the students' learning in programming education. We performed 19 user studies to investigate the impact on learning of game elements present in two serious games for learning programming. The study was carried out with\u00a0\u2026", "num_citations": "7\n", "authors": ["1209"]}
{"title": "How clear is your code? an empirical study with programming challenges\n", "abstract": " To maintain a software system, developers have to read and properly understand the source code. Previous work confirms that developers spend too much time reading code before maintaining it. Clear code is the one that is easy to read, to understand and, consequently, to maintain. Since readability and understandability are subjective properties of code, to understand how developers characterize clear code may support maintainability. Software metrics, such as Source Lines of Code (SLOC) and McCabe\u2019s Complexity (McCabe), are the basic means to quantify clear code properties. However, we still lack empirical knowledge on the correlation between such metrics and the subjective view of developers on clear code. In this paper, we investigate how developers characterize clear code by analyzing 6,775 alternative code solutions to 131 programming challenges from CheckIO, an online coding challenge platform. In CheckIO, developers submit supposedly clear code solutions to a challenge and other developers provide positive votes to the clearest ones. We aim to identify correlations between the number of positive votes for a clear solution and six metrics: SLOC, McCabe, Number of Commented Lines, Comments Rate, Developer Experience, and Days After 1st Solution. Our results suggest a high correlation between clear code and the two last metrics. We also observed a higher correlation of clear code with SLOC and McCabe when the programming challenges have few (less than 20) solutions. However, we could not find correlation of clear code with Number of Commented Lines and Comments Rate.", "num_citations": "7\n", "authors": ["1209"]}
{"title": "Investigating how features of online learning support software process education\n", "abstract": " Online courses are a method of lecturing whose application in education is not bounded by space and location constraints. They include features such as video lectures and online questionnaires. There are a few online courses to teach subjects related to Software Engineering. However, for the best of our knowledge, there is no online course to teach software process, which is a key area of Software Engineering. More important, there is no systematic study to investigate whether this way of teaching is efficient and viable to teach software process. This paper presents an empirical study to evaluate whether and how online features support the learning of software process in the light of an online Software Engineering course with 61 video lectures, 16 online questionnaires, and a discussion forum. This study relies on data of 100 undergraduate students over three consecutive years: 2014, 2015, and 2016. Data of\u00a0\u2026", "num_citations": "7\n", "authors": ["1209"]}
{"title": "Understanding collaborative software development: An interview study\n", "abstract": " In globally distributed software development, many software developers have to collaborate and deal with issues of collaboration. Although collaboration is challenging, collaborative development produces better software than any developer could produce alone. Unlike previous work which focuses on the proposal and evaluation of models and tools to support collaborative work, this paper presents an interview study aiming to understand (i) the motivations,(ii) how collaboration happens, and (iii) the challenges and barriers of collaborative software development. After interviewing twelve experienced software developers from GitHub, we found different types of collaborative contributions, such as in the management of requests for changes. Our analysis also indicates that the main barriers for collaboration are related to non-technical, rather than technical issues.", "num_citations": "6\n", "authors": ["1209"]}
{"title": "Mining software repositories to identify library experts\n", "abstract": " Programming is multi-faceted, inherently involving several different skills. With the advent of collaboration platforms like GitHub, developers have the opportunity to contribute to projects from different organizations and collaborate with various developers from around the world. With GitHub data, new opportunities to identify developers abilities become possible. From GitHub, it is possible to infer several skills from a developer, for instance, the user of libraries. In this paper, we propose a method to identify library experts, based on the knowledge they produce on GitHub. We evaluated our method in an experiment to identify possible experts in three Java libraries. Our method ranked the top 100 developers for each technology. Then we compared the selected profiles from GitHub with profiles of these developers on the social network LinkedIn to see if what they report in LinkedIn matches what they produce in GitHub\u00a0\u2026", "num_citations": "6\n", "authors": ["1209"]}
{"title": "A method based on naming similarity to identify reuse opportunities\n", "abstract": " We propose a method for extraction of reuse opportunities based on naming similarity of two types of object-oriented entities: classes and methods. Our method, called JReuse, computes a similarity function to identify similarly named classes and methods from a set of software systems from a domain. These classes and methods compose a repository with reuse opportunities. We also present a prototype tool to support the extraction by applying our method. We evaluate the JReuse with 71 software systems mined from GitHub, in 4 domains distinct. In total, we evaluate 1,772,269 lines of code; 75,447 methods, and 17,821 classes. As a result, we observe that the JReuse is able to identify main classes and methods that are relevant in domain selected. Furthermore, we evaluated the JReuse, through a survey with developers GitHub, of each evaluated domain. The observed results indicate that our method is able of extracting the possibilities for reuse, independent of the software domain.", "num_citations": "6\n", "authors": ["1209"]}
{"title": "ConcernReCS: finding code smells in software aspectization\n", "abstract": " Refactoring object-oriented (OO) code to aspects is an error-prone task. To support this task, this paper presents ConcernReCS, an Eclipse plug-in to help developers to avoid recurring mistakes during software aspectization. Based on a map of concerns, ConcernReCS automatically finds and reports error-prone scenarios in OO source code; i.e., before the concerns have been refactored to aspects.", "num_citations": "6\n", "authors": ["1209"]}
{"title": "Concern-based assessment of architectural stability: A comparative study\n", "abstract": " A concern is any consideration that can impact the software architecture and other artefacts. Sustaining stability of concerns realised in architectural designs is essential to obtain long-lasting software products. It is often assumed that concern assessment mechanisms are effective to predict architecture stability. They ought to exert a positive or detrimental effect on software stability. In fact, there is a growing variety of concern assessment mechanisms to support the quantification of concern properties in software artefacts. They range from metrics that compute basic concern characteristics - such as concern tangling and scattering - to patterns that represent recurring concern structures. However, the vast majority of concern assessment mechanisms has not been empirically validated yet. This paper presents a comparative study on the efficacy of a family of concern metrics and patterns to support architectural stability\u00a0\u2026", "num_citations": "6\n", "authors": ["1209"]}
{"title": "Aspect-oriented composition of design patterns: A quantitative assessment\n", "abstract": " Pattern composition has been shown as a challenge to applying design patterns in real software systems. One of the main problems is that the implementations of multiple design patterns in a system are not limited to affect the application classes. They also crosscut each other in multiple heterogeneous ways so that their separation and composition are far from being trivial. In this context, it is of paramount importance to systematically verify whether aspect-oriented programming (AOP) supports improved composability of design patterns. This paper presents a systematic investigation on how AOP scales up to deal with modularization of patternspecific concerns in the presence of pattern interactions. We have made both qualitative and quantitative assessments of 62 pair-wise compositions taken from 3 medium-sized systems implemented in Java and AspectJ programming languages. Our analysis has also included the evaluation of compositions involving more than two patterns. The assessment was based on four fundamental software attributes, namely separation of concerns, coupling, cohesion, and conciseness.", "num_citations": "6\n", "authors": ["1209"]}
{"title": "How do code changes evolve in different platforms? a mining-based investigation\n", "abstract": " Code changes are performed differently in the mobile and non-mobile platforms. Prior work has investigated the differences in specific platforms. However, we still lack a deeper understanding of how code changes evolve across different software platforms. In this paper, we present a study aiming at investigating the frequency of changes and how source code, build and test changes co-evolve in mobile and non-mobile platforms. We developed regression models to explain which factors influence the frequency of changes and applied the Apriori algorithm to find types of changes that frequently co-occur. Our findings show that non-mobile repositories have a higher number of commits per month and our regression models suggest that being mobile significantly impacts on the number of commits in a negative direction when controlling for confound factors, such as code size. We also found that developers do not\u00a0\u2026", "num_citations": "5\n", "authors": ["1209"]}
{"title": "Latency amplification: Characterizing the impact of web page content on load times\n", "abstract": " Web users like sites that load quickly. Longer web page load times translate to reduced user satisfaction and loss of revenue and mindshare. The time required to load a given web page is difficult to predict because it is a complex function of many factors, such as the latencies associated with the network requests used to retrieve that content from remote servers. However, one of the most important factors is the page content, including the scripts, images, style sheets and other objects that are present on the page. In this paper we propose a simple metric for characterizing the content of a web page in terms of its impact on page loading times. This metric, called the latency amplification factor (LAF), characterizes the content of a web page in terms of how it affects the page load time. The LAF of a web page can be estimated quickly and easily, and we describe a lightweight method for doing so. In addition, we propose\u00a0\u2026", "num_citations": "5\n", "authors": ["1209"]}
{"title": "On the support and application of macro-refactorings for crosscutting concerns\n", "abstract": " Crosscutting concerns hinder software stability and reuse and, hence, refactorings have been proposed to modularise them using aspectoriented programming technology. However, refactoring of crosscutting concerns is challenging and time-consuming because it involves many interdependent micro-refactorings. It may also be a repetitive task as recent studies have pointed out that most crosscutting concerns share a limited number of recurring shape patterns. This paper presents a family of macrorefactorings for modularising crosscutting concerns which share similar forms and patterns. It also proposes a complementary set of change impact algorithms which support designers on the decision whether to apply concern refactoring. We evaluate our technique by measuring the impact of refactoring 22 crosscutting concerns in two applications from different domains.", "num_citations": "4\n", "authors": ["1209"]}
{"title": "Uma abordagem quantitativa para desenvolvimento de software orientado a aspectos\n", "abstract": " Design assessment in software engineering has strictly based on module coupling, cohesion, and size. With the advent of aspect-oriented (AO) programming, this traditional approach has led to a number of assessment breakdowns since it does not consider new AO abstractions (eg concerns) and composition mechanisms. This paper:(i) presents AO metrics which consider concerns as explicit abstractions,(ii) proposes a systematic assessment method, and (iii) investigates the hypothesis that heuristic rules enhances the assessment process. Our proposal is supported by a measurement tool. We have evaluated our approach through its application to six software systems from different domains and with distinct degrees of complexity. The analysis was based on the metrics and heuristics support for finding the presence of design flaws relative to certain crosscutting concerns.Resumo. Avalia\u00e7\u00e3o de sistemas em engenharia de software tem sido baseada estritamente em acoplamento, coes\u00e3o e tamanho dos m\u00f3dulos. Com o surgimento da programa\u00e7\u00e3o orientada a aspectos (OA), esta tradicional abordagem de avalia\u00e7\u00e3o tem levado a ocorr\u00eancia de muitos falsos positivos e falsos negativos nos resultados por n\u00e3o considerar novas abstra\u00e7\u00f5es OA, como interesses, e novos mecanismos de composi\u00e7\u00e3o. Neste contexto, este artigo:(i) apresenta m\u00e9tricas OA que consideram interesses como abstra\u00e7\u00f5es expl\u00edcitas nas medi\u00e7\u00f5es,(ii) prop\u00f5e um m\u00e9todo sistem\u00e1tico de avalia\u00e7\u00e3o, e (iii) investiga a hip\u00f3tese de regras heur\u00edsticas auxiliarem o processo de avalia\u00e7\u00e3o de software. Nossa proposta \u00e9 suportada por uma ferramenta de medi\u00e7\u00e3o. Adicionalmente\u00a0\u2026", "num_citations": "4\n", "authors": ["1209"]}
{"title": "Playing the project: incorporating gamification into project-based approaches for software engineering education\n", "abstract": " In Software Engineering higher education, besides learning theory and acquiring technical skills, students need to develop the ability to apply, evolve, and practice those skills throughout their lifetime. From 2016 to 2018, we had been adapting an introductory Software Engineering course from a theory-oriented course to a more practical experience for students. Therefore, the goal of this paper is to describe our experience incorporating Project-based Learning (PBL) principles and gamification elements in practical assignments for SE education. To achieve this goal, we present the structure of PBL projects we have been using and how we adapted game elements to the context of SE education in order to create a gamified course. Based on our experience, we defined 17 guidelines that instructors may follow when defining a practical assignment for SE education. While PBL was helpful to create a practice-oriented teaching experience, gamification was not only useful in improving the engagement of students, but also in creating a roadmap of activities and a structure for students to self-assess their progress in the project.", "num_citations": "3\n", "authors": ["1209"]}
{"title": "Prevalence of Zika, dengue and Chikungunya virus infection in pregnant women and surveillance of congenital Zika infection in Salvador, Brazil\n", "abstract": " Background: An unprecedented outbreak of Zika virus (ZIKV) occurred in Brazil in 2015. Approximately 18,372 cases were notified in the city of Salvador, located in the state of Bahia in northeastern Brazil.", "num_citations": "3\n", "authors": ["1209"]}
{"title": "A systematic mapping study on game elements and serious games for learning programming\n", "abstract": " This work aims to verify how serious games and their composing elements are used and evaluated to support learning programming. Serious games have been used as a tool to support learning in several areas and subjects. To achieve its educational goals, a serious game must consist of a set of game elements that are related to the learning outcomes. In Computer Science, educators are also using serious games and their elements to enhance learning of programming-related disciplines, which are often considered challenging by first-year students. To achieve our goal we defined three research questions: (1) What are the serious games for learning programming? (2) What are the game elements in the serious games for learning programming? and (3) What is the empirical strategies and methods used to evaluate existing game elements? A systematic mapping study on the use and evaluation of game\u00a0\u2026", "num_citations": "3\n", "authors": ["1209"]}
{"title": "Detecting Code Anomalies in Software Product Lines\u201d\n", "abstract": " A Software Product Line (SPL) is a set of software systems that share common features designed to a specific domain. Although the design of SPL aims to support reuse with minimization of development costs, an inappropriate implementation of SPLs may lead to code anomalies. These code anomalies may affect negatively costs and management of SPL development. Few studies investigate anomalies in SPL with focus on detection strategies and automated detection of these anomalies. Moreover, recent studies indicate the need of proposing new anomalies and detection strategies, as the development of supporting detection tools. In this study, we investigate anomalies in SPL to (i) comprehend the state of the art on anomalies and detection strategies from literature,(ii) propose new detection strategies for well-known anomalies in SPL and, eventually, propose new anomalies and respective detection strategies,(iii) evaluate the proposed strategies,(iv) propose a supporting tool for the proposed detection strategies, and (v) evaluate the proposed tool. Preliminary results of the study indicate that anomalies in SPL is an interesting research topic with many opportunities for scientific contribution.", "num_citations": "3\n", "authors": ["1209"]}
{"title": "Information systems development with pair programming: An academic quasi-experiment\n", "abstract": " Pair Programming is a development technique in which two programmers collaborate to conduct the same development task. The use of this technique in information systems development may support many activities, such as code inspection and software integration. Studies have investigated the advantages and drawbacks of pair programming in both industrial and academic context. However, with respect to academic research, the majority of studies investigate this technique in European or North American educational institutions. Considering that some social and geographic factors may impact on the application and efficiency of agile methods such as pair programming, we lack an evaluation of this programming practice in the context of Brazilian students. In this paper, we discuss the findings of three one-hour quasi-experiments conducted with 55 undergraduate and graduate students to assess pair programming in the development of tasks to implement an information system. These participants are students enrolled in Information Systems and related courses of two Brazilian institutions. For the experiment, we divided each class in two groups: one group for solo programming and the other for pair programming. As a result, we observed that participants developing tasks in pairs presented lower rates of time spent and difficulty faced to complete development tasks when compared with solo programming participants. However, we did not observe a significant increase on the correctness in tasks developed by both experiment groups: paired and solo programmers. Finally, we conducted an analysis of participant feedback regarding other\u00a0\u2026", "num_citations": "3\n", "authors": ["1209"]}
{"title": "Using JavaScript static checkers on GitHub systems: A first evaluation\n", "abstract": " To improve code quality in JavaScript systems, static code analyzers are used to detect bad coding practices that can be potential bugs and can cause the system to not work properly. This paper investigates bad coding practices in JavaScript reported by two static analyzers (JSHint and JSLint) in order to verify if JavaScript systems are using this lint-like checkers to avoid bad coding practices and what are the most common warnings detected by them. Through an empirical study, we analyze 31 JavaScript systems and our results show that JSHint and JSLint are used by the development team of systems. We also found bad coding practices in all analyzed systems. In five systems, the number of warnings between old and new versions decreased by 14%.", "num_citations": "3\n", "authors": ["1209"]}
{"title": "Avalia\u00e7\u00e3o de um modelo de qualidade para implementa\u00e7\u00f5es orientadas a objetos e orientadas a aspectos\n", "abstract": " Neste artigo o nosso principal objetivo \u00e9 avaliar, identificar as fraquezas e propor revis\u00f5es ao modelo de qualidade utilizado por Sant\u2019Anna em estudos que comparam sistemas orientados a objetos com sistemas orientados a aspectos. A avalia\u00e7\u00e3o inclui um estudo emp\u00edrico e uma an\u00e1lise qualitativa feita sobre o conjunto de m\u00e9tricas que comp\u00f5e este modelo de qualidade. A seguir apresentamos um modelo de qualidade revisado que procura eliminar os pontos fracos identificados no modelo original. Este novo modelo cont\u00e9m um conjunto m\u00ednimo de m\u00e9tricas, algumas das quais adicionais ao modelo original. As m\u00e9tricas do modelo revisado s\u00e3o definidas de modo que possam vir a ser automatizadas.", "num_citations": "3\n", "authors": ["1209"]}
{"title": "Analyzing the impact of refactoring on bad smells\n", "abstract": " Refactoring aims to remove bad smells and increase software maintainability by improving the software structure without changing its behavior. However, some studies show that refactoring tools may introduce new bad smells into the source code, but to the best of our knowledge, we have not been able to find a complete catalog that states the bad smells introduced from refactoring. To bridge this gap, this paper goal is to evaluate the impacts of refactoring on the detection of bad smells in open-source Java systems. Hence, we want to know if and when the automated refactoring removes or introduces bad smells.", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Insights on software product line extraction processes: ArgoUML to ArgoUML-SPL revisited\n", "abstract": " Software Product Lines (SPLs) are rarely developed from scratch. Commonly, they emerge from monolithic architectures when there is a need to create tailored variants, or from existing variants created in an ad-hoc way once their separated maintenance and evolution become challenging. Despite the vast literature about re-engineering systems into SPLs and related technical approaches, there is a lack of detailed analysis about the process itself and the effort that is involved. We provide and analyze empirical data of an existing SPL extraction process: the ArgoUML monolithic architecture transition to ArgoUML-SPL. The analysis relies on information mined from the version control history of the source-code repository and the discussion with developers that took part in the process. The contribution of this study is an in-depth characterization of the process compared to previous works that focused only on the\u00a0\u2026", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Testing configurable software systems: the failure observation challenge\n", "abstract": " Configurable software systems can be adapted or configured according to a set of features to increase reuse and productivity. The testing process is essential because configurations that fail may potentially hurt user experience and degrade the reputation of a project. However, testing configurable systems is very challenging due to the number of configurations to run with each test, leading to a combinatorial explosion in the number of configurations and tests. Currently, several testing techniques and tools have been proposed to deal with this challenge, but their potential practical application remains mostly unexplored. To encourage the research area on testing configurable systems, researchers and practitioners should be able to try out their solutions in common datasets. In this paper, we propose a dataset with 22 configurable software systems and an extensive test suite. Moreover, we report failures found in\u00a0\u2026", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Failure of One, Fall of Many: An Exploratory Study of Software Features for Defect Prediction\n", "abstract": " Software defect prediction represents an area of interest in both academia and the software industry. Thus, software defects are prevalent in software development and might generate numerous difficulties for users and developers apart. The current literature offers multiple alternative approaches to predict the likelihood of defects in the source code. Most of these studies concentrate on predicting defects from a broad set of software features. As a result, the individual discriminating power of software features is still unknown as some perform well only with specific projects or metrics. In this study, we applied machine learning techniques in a popular dataset. This data has information about software defects in five Java projects, containing 5,371 classes and 37 software features. To this aim, we convey an exploratory investigation that produced hundreds of thousands of machine learning models from a diverse\u00a0\u2026", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Commit Classification using Natural Language Processing: Experiments over Labeled Datasets.\n", "abstract": " Software commits play an important role in collaborative software development. A commit allows developers to collaboratively contribute to open-source software projects. Previous studies show that developers spend a lot of time in identifying and prioritizing critical issues and respective commits. For this reason, understanding what a software commit is trying to solve in the project is very important. In this context, commit classification could help managers to plan and allocate resources in advance for the software project. Despite its relevance, we still lack accurate models to support automated classification of commits into relevant categories. In this work, we conduct an empirical study to evaluate commit classification techniques using the commit message given by developers as input. After an ad-hoc literature review, we created a dataset based on labeled data from different works found in the literature. Second, we compared five Machine Learning (ML) state-or-art algorithms seeking a reliable baseline model. Finally, we applied Natural Language Processing (NLP) to a novel ML model aiming at improving results compared to the baseline models. Our findings show that the new NLP-based model outperforms the random baseline models by a relevant rate, achieving 91% of F-measure for the commit classification task.", "num_citations": "2\n", "authors": ["1209"]}
{"title": "A systematic mapping of literature on software refactoring tools\n", "abstract": " Refactoring consists of improving the internal structure of the code without changing the external behavior of a software system. However, the task of refactoring is very costly in the development of an information system. Thus, many tools have been proposed to support refactoring the source code. In order to find tools cited in the literature, this work presents a Systematic Literature Mapping about refactoring. As a result, this paper summarizes the refactoring tools that have been published in the last 5 years in terms of the tool profiles developed, which programming languages have support for refactoring and which are the main refactoring strategies that are handled by tools. It has been identified that publications on refactoring have remained constant over the past 5 years. Also, most of the refactoring works describe tools, being they for systems written in the Java language, that perform code refactoring\u00a0\u2026", "num_citations": "2\n", "authors": ["1209"]}
{"title": "On the investigation of domain-sensitive bad smells in information systems\n", "abstract": " Bad smells are symptoms that something may be wrong in the information system design or source code. Although bad smells have been widely studied, we still lack an in-deep analysis about how they appear more or less frequently in specific information systems domains. The frequency of bad smells in a domain of information systems can be useful, for instance, to allow software developers to focus on the more relevant bad smells of a certain domain. Moreover, developers of new bad smell detection tools could take information about domains into consideration to improve the tool detection rates. In this paper, we investigate code smells more likely to appear in four specific information systems domains: accounting, e-commerce, health, and restaurant. Our analysis relies on 52 information systems mined from GitHub. We identified bad smells with two detection tools, PMD and JDeodorant. Our findings suggest that Comments is a domain-independent bad smell since they uniformly appear in all investigated domains. On the other hand, Large Class and Long Method can be considered domain-sensitive bad smells since they appear more frequently in accounting systems. Although less frequent in general, Long Parameter List and Switch Statements also appear more in health and e-commerce systems, respectively, than in other domains.", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Medindo Acoplamento em Software Orientado a Objeto: Uma Perspectiva do Desenvolvedor\n", "abstract": " As m\u00e9tricas de acoplamento ajudam a identi\ufb01car os elementos que possam impactar na qualidade de um software orientado a objetos. O alto grau de acoplamento pode afetar alguns atributos externos de qualidade de software, como manutenibilidade. Este artigo apresenta os resultados de um estudo com desenvolvedores de software de diferentes n\u00edveis de experi\u00eancia em programa\u00e7\u00e3o que avaliaram o grau de acoplamento de um projeto. Com base nas respostas obtidas, foram relacionadas m\u00e9tricas de acoplamento com o prop\u00f3sito de identi\ufb01car pontos cr\u00edticos e melhorar a qualidade e manutenibilidade de sistemas orientados a objetos.", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Mushroom acceptability and consumption intention for the main mushrooms produced in Brazil [Conference poster].\n", "abstract": " see more details are known for their functional and nutritional importance. However, there are few works about their acceptance as food by Brazilian consumers, which are important as directives for mushroom producers. The objective of this study was to evaluate Agaricus bisporus agaricus bisporus Subject Category: Organism Names", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Modelo computacional para apoiar a configura\u00e7\u00e3o de produtos em linha de produtos de software\n", "abstract": " Software Product Line (SPL) is a set of software systems QUE sharing a set of characteristics to satisfy specific needs of a particular domain. The configuration of a product among thousands of possible combinations of features has proved to be impractical even for small SPL. To support companies in semiautomatic product extraction and maximize customer satisfaction, this paper proposes a model based on search algorithms. The model has two implementations:(i) exhaustive enumeration with preprocessing and backtracking and (ii) a greedy algorithm. Due the NP-complete nature of the problem, our experiments revealed that the exhaustive enumeration is impractical for larger instances. Moreover, the greedy heuristic implementation solves the problem in polynomial time with 92% of accuracy.Resumo. Linha de produtos de software (LPS) \u00e9 um conjunto de sistemas de software que compartilham um conjunto\u00a0\u2026", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Proposta e Avalia\u00e7\u00e3o de Educa\u00e7\u00e3o Aberta para Engenharia de Software\n", "abstract": " Massive Open Online Course (MOOC) is an emerging method of online lecturing whose application in education is not bounded by space and location constraints. The successful implementation of MOOCs requires conceptual changes in how instructors and students behave in an open unbounded education environment. There are some emerging MOOC initiatives for Software Engineering. However, the knowledge about the best practices for learning Software Engineering processes, methods, and tools in such an open environment is still limited. This paper presents a MOOC, based on a face-to-face course, for introductory Software Engineering courses. Over 60 students are taking this MOOC, which is composed of 44 video lectures, 60 questions in 6 quizzes, and several discussion topics. To evaluate the proposed MOOC, we (i) compared students\u2019 performance in online vs. face-to-face courses and (ii\u00a0\u2026", "num_citations": "2\n", "authors": ["1209"]}
{"title": "ConcernMeBS: Metrics-based Detection of Code Smells\n", "abstract": " Software metrics have been traditionally used to evaluate the maintainability of the software systems and to detect code smells. Code smells are symptoms that may indicate something wrong in the system code. Recently, concern-sensitive metrics and metrics-based heuristics have been proposed to detect code smells. However, the application of this kind of metrics and heuristics are time consuming without proper tool support. To address this task, this paper presents a tool, called ConcernMeBS, to help developers to detected code smells. Based on concern to code mapping, ConcernMeBS automatically finds and reports classes and methods that are prone to suffer from code smells in OO source code.", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Parameter based constant propagation\n", "abstract": " JavaScript is nowadays the lingua franca of web browsers. This programming language is not only the main tool that developers have to implement the client side of web applications, but it is also the target of frameworks such as Google Web Toolkit. Given this importance, it is fundamental that JavaScript programs can be executed efficiently. Just-in-time (JIT) compilation is one of the keys to achieve this much necessary efficiency. An advantage that a JIT compiler has over a traditional compiler is the possibility to use runtime values to specialize the target code. In this paper we push JIT speculation to a new extreme: we have empirically observed that many JavaScript functions are called only once during a typical browser section. A natural way to capitalize on this observation is to specialize the code produced by a function to the particular values that are passed to this function as parameters. We have\u00a0\u2026", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Requisitos Funcionais e Requisitos N\u00e3o Funcionais\n", "abstract": " \u220e O usu\u00e1rio pode pesquisar todo ou um sub-conjunto do banco de dados\u220e O sistema deve oferecer telas apropriadas para o usu\u00e1rio ler documentos armazenados\u220e Cada pedido deve ser associado a um identificador \u00fanico (PID), o qual o usu\u00e1rio pode copiar para a \u00e1rea de armazenamento permanente da conta", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Aspectizing design patterns: rewards and pitfalls\n", "abstract": " Design patterns offer flexible solutions to common problems in software development. Recent studies have shown that several design patterns involve crosscutting concerns. Unfortunately, object-oriented (OO) abstractions are often not able to modularize those crosscutting concerns, which in turn decrease the system reusability and maintainability. Hence, it is important verifying whether aspectoriented approaches support improved modularization of crosscutting concerns relative to design patterns. Ideally, quantitative studies should be performed to compare object-oriented and aspect-oriented implementations of classical patterns with respect to important software engineering attributes for reusability and maintainability, such as coupling, cohesion. This paper presents a quantitative study that compares aspect-based and OO solutions for the 23 Gang-of-Four patterns. We have used stringent software engineering attributes as the assessment criteria. We have found that most aspect-oriented solutions improve separation of pattern-related concerns, although some aspect-oriented implementations of specific patterns result in higher coupling or lower cohesion.", "num_citations": "2\n", "authors": ["1209"]}
{"title": "Main Differences of DevOps on IoT Systems\n", "abstract": " IoT systems have barriers related to the different areas that involve their development. Hence, the scientific literature and industry practices investigate approaches that enable continuous interaction of these areas. Through semi-structured interviews with thirty-one professionals working in industry, this study investigated how DevOps is applied to make the development of IoT projects continuous and meet the demands of the industry. Through group discussions, we categorized the results of this study. As a preliminary contribution to this work, we investigate the contrasts between using DevOps in IoT system projects and using rigid, plan-oriented processes to develop embedded systems.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "A systematic review on the use of DevOps in internet of things software systems\n", "abstract": " Based on Systematic Literature Review (SLR), we search to investigate the relations of DevOps in IoT software systems. As a result, we characterize the benefits and challenges in the context of knowledge previously reported in primary studies.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "An exploratory study on the identification and evaluation of bad smell agglomerations\n", "abstract": " Systems must evolve to cope with new stakeholders requirements, or to fix existing problems. These changes are complex due to several factors, including the need of understanding the source code, activity that is impaired by the presence of bad smells. Bad smell is a symptom of bad decisions about the system design or code. When two or more bad smells occur in the same snippet of code, they form an agglomeration. Hence, developers need to put more effort to perform their development and maintenance tasks. However, few studies in the literature evaluate how such agglomerations may impact development activities. We aim at exploring agglomerations focusing on evaluating how they are spread in the code, and how they impact on the metrics of software modularity. In this work, we evaluate agglomerations composed of four kinds of bad smells: Large Class, Long Method, Feature Envy and Refused\u00a0\u2026", "num_citations": "1\n", "authors": ["1209"]}
{"title": "PLATOOL: A Functional Test Generation Tool for Mobile Applications\n", "abstract": " Mobile applications are ubiquitous nowadays and their testing is a central activity for quality assurance. Software testing is considered an important activity in this context. Application testers are faced with several classes of events in this domain including GUI and system events, such as sensor-related events. While GUI events have been systematically explored in mobile application testing literature, system events have received less attention. A possible difficulty faced by mobile application testers is the identification and generation of input data for system events. This paper presents PLATOOL for assisting mobile application testers to deal with common events of the mobile applications during the automation of functional tests. Our preliminary results indicate that PLATOOL is able to generate and execute useful functional tests to support testing of mobile applications.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "Quantifying the Effects of Refactorings on Bad Smells\n", "abstract": " Refactoring aims to remove bad smells and increase software maintainability by improving the software structure without changing its behavior. Even with the existence of tools to assist refactoring, many developers do not trust in their solutions, claiming that some studies show that refactoring may even introduce new bad smells into the source code. However, we do not find a complete catalog that states when this may occur. To investigate this subject deeply, the goal of this dissertation is to evaluate the effects of refactoring on the detection of bad smells. Specifically, we want to know if and what refactoring removes bad smells or introduces them. To achieve our goal, we plan to conduct empirical studies to provide a catalog showing these situations.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "How Difficult and Effective is Writing Assertions for Observing Bugs at Runtime?\n", "abstract": " Context: Executable Assertion (EA) is a boolean expression written to assess the conformance of the program behavior with its requirements. Contrary to unit test cases, EA supports the bug detection at runtime. An advantage of adopting EA is capturing the fine-grained bug location. Objective: Writing EA instances can be expensive and time consuming, due to the need for understanding in depth the program structure and invariants. Unfortunately, there is no empirical evidence on how difficult and effective is writing EA instances. This paper fills this literature gap with a quasi-experiment. Method: We asked 22 participants to write EA instances for seven AVL Tree properties. We assessed i) the time spent to write each instance, ii) the difficultly faced by the participants, and iii) the correctness of each instance. Finally, we assessed how effective are the EA instances written by the participants in observing bugs. We relied on the analysis of 155 bugs generated via mutation testing. Results: Participants spent from 5.7 to 13.2 minutes in average to write each EA instance; they reported an average difficulty from 2.2 to four out of 5. In average, writing EA instances for three out of the seven AVL Tree properties was sufficient to observe 57% of the bugs. Conclusions: Our results suggest that writing assertions for observing bugs at runtime is feasible while quite effective, but it requires reasonable effort.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "On the Impact of Bad Smell Agglomerations on Software Quality\n", "abstract": " When a system evolution is not planned, developers can take decisions that degrade the system quality. To cope with this problem, refactoring can be applied to the source code aiming to increase code quality without modifying the software external behavior. To know when to refactor, the concept of bad smells can be used. Bad smells are snippets of source code that suggest the need of refactoring. However, bad smells does not always appear isolated. The aim of this study is to understand the impact of bad smell agglomerations on the software quality by evaluating a large dataset of open source systems. To achieve our goal, we plan to use data mining techniques complemented with correlation analysis of the dataset.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "Uma avalia\u00e7\u00e3o de ferramentas de modelagem de software\n", "abstract": " Ferramentas de modelagem servem para orientar e disciplinar o processo de desenvolvimento de software durante a fase de projeto. Entretanto, tais ferramentas n\u00e3o s\u00e3o totalmente exploradas do ponto de vista funcional, seja por complexidade do assunto abordado ou pela usabilidade das mesmas. Este artigo se prop\u00f5e a avaliar o uso de duas ferramentas de modelagem de software, sendo uma delas no formato online e outra em desktop, por meio de um experimento realizado na Universidade Federal de Minas Gerais com alunos de gradua\u00e7\u00e3o e p\u00f3s-gradua\u00e7\u00e3o. O objetivo do estudo foi avaliar a usabilidade das duas ferramentas open source, ArgoUml e Gliffy, que permitem a modelagem de software utilizando a nota\u00e7\u00e3o da UML. S\u00e3o apresentados estudos referentes aos n\u00edveis de aceita\u00e7\u00e3o e de utiliza\u00e7\u00e3o das ferramentas investigadas.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "Avalia\u00e7\u00e3o por Meio de Question\u00e1rios de um Curso Online para Engenharia de Software\n", "abstract": " Curso aberto e online, tais como MOOC (Massive Open Online Course), \u00e9 um m\u00e9todo emergente de ensino que n\u00e3o \u00e9 limitado por restri\u00e7\u00f5es de espa\u00e7o e localiza\u00e7\u00e3o. A implanta\u00e7\u00e3o bem sucedida de um curso online exige mudan\u00e7as conceituais na forma como professores e alunos se comportam em um ambiente aberto de ensino. Existem algumas iniciativas emergentes de cursos online para a Engenharia de Software. No entanto, ainda \u00e9 limitado o conhecimento sobre as vantagens de um curso online para o ensino de Engenharia de Software. Este artigo avalia o desempenho de alunos em um curso online de Engenharia de Software. Mais de 230 alunos est\u00e3o registrados neste curso online que apoia um curso presencial de ementa equivalente. O curso online \u00e9 composto de 44 aulas em v\u00eddeo, 140 perguntas em 14 question\u00e1rios de revis\u00e3o e v\u00e1rios t\u00f3picos de discuss\u00e3o. Para avaliar o curso, foi comparado o desempenho de alunos nos question\u00e1rios de revis\u00e3o em rela\u00e7\u00e3o \u00e0:(i) participa\u00e7\u00e3o destes alunos em outras atividades do curso como v\u00eddeos assistidos,(ii) frequ\u00eancia dos alunos em aulas presenciais e (iii) desempenho dos alunos em provas presenciais. Os resultados indicam baixa correla\u00e7\u00e3o entre os v\u00eddeos assistidos e o desempenho nos question\u00e1rios de revis\u00e3o. Por outro lado, frequ\u00eancia em aulas presenciais e desempenho nas provas est\u00e3o diretamente relacionados ao sucesso em question\u00e1rios online de revis\u00e3o.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "Estudo Explorat\u00f3rio para Avalia\u00e7\u00e3o de uma Ferramenta de Ger\u00eancia de Projetos\n", "abstract": " O desenvolvimento de software necessita de ferramentas para apoiar a ger\u00eancia de projetos espec\u00edficos. Existem dezenas de ferramentas para ger\u00eancia de projetos no mercado. Entretanto, profissionais t\u00eam dificuldades em escolher a ferramenta mais apropriada devido \u00e0 aus\u00eancia de estudos que avaliem os fatores positivos e negativos destas ferramentas. Este artigo apresenta a avalia\u00e7\u00e3o de uma ferramenta de ger\u00eancia de projetos chamada iTeamwork. A ferramenta iTeamwork \u00e9 gratuita e dispon\u00edvel online via uma interface Web. Al\u00e9m disso, ela inclui funcionalidades t\u00edpicas para ger\u00eancia de projetos encontradas em outras ferramentas, como aloca\u00e7\u00e3o de pessoas aos projetos, cria\u00e7\u00e3o e aloca\u00e7\u00e3o tarefas. Para avalia\u00e7\u00e3o da ferramenta, foi projetado e executado um estudo explorat\u00f3rio nos quais 29 alunos de gradua\u00e7\u00e3o usaram a ferramenta. Os resultados dos estudos indicam os pontos positivos e negativos\u00a0\u2026", "num_citations": "1\n", "authors": ["1209"]}
{"title": "Concern-Sensitive Heuristic Assessment of Aspect-Oriented Design\n", "abstract": " Recent empirical studies of aspect-oriented design have stressed that the inaccurate modularisation of some concerns potentially leads to a plethora of non-obvious modularity flaws. Nowadays, modularity assessment is mostly supported by design heuristics rooted at conventional attributes such as module coupling, module cohesion, and interface complexity. However, such traditional module-driven assessments cannot be tailored to the driving design concerns, thereby leading to recurring false positives and false negatives in design evaluation processes. Our goal is to promote concerns as explicit abstraction in the design assessment process. We propose an assessment technique composed of (i) a concern-oriented measurement framework to support the instantiation and comparison of concern metrics,(ii) a set of concern metrics instantiated and formalised according to our measurement framework, and (iii) a representative suite of concern-sensitive heuristic rules for detection of design flaws. To evaluate our concern-oriented assessment technique, we are conducting a number of empirical studies which encompass a plethora of crosscutting and non-crosscutting concerns.", "num_citations": "1\n", "authors": ["1209"]}
{"title": "Vaporiza\u00e7\u00e3o a laser do cervix para tratamento da neoplasia intraepitelial cervical\n", "abstract": " O c\u00e2ncer c\u00e9rvico-uterino \u00e9 muito comum em v\u00e1rios pa\u00edses da Am\u00e9rica Latina. As estat\u00edsticas de mortalidade e as taxas de incid\u00eancia demonstram a sua real import\u00e2ncia. O c\u00e2nver c\u00e9rvico-uterino freq\u00fcentemente \u00e9 uma doen\u00e7a progressiva iniciada com mudan\u00e7as intra-epiteliais, que podem se transformar em um processo invasivo, sendo o nosso objetivo tratar precocemente estas les\u00f5es quando ainda \u00e9 poss\u00edvel a cura de 100%. Em nosso estudo prospectivo foram selecionadas 21 pacientes com neoplasia cervical intra-epitelial reatreadas pela citplogia e diagnosticadas pela histopatologia ap\u00f3s bi\u00f3psia dirigida pela colposcopia. O m\u00e9todo terap\u00eautico empregado foi a vaporiza\u00e7\u00e3o a laser com o CO2. Tiveram como pr\u00e9-requisito os seguintes crit\u00e9rios: informa\u00e7\u00e3o segura pela colposcopia da zona de transforma\u00e7\u00e3o e afastar a presen\u00e7a de c\u00e2ncer invasivo; a neoplasia epitelial cervical deve ocupar a ectocervix sem nenhuma extens\u00e3o para o canal cervical e correla\u00e7\u00e3o positiva entre a citologia, colposcopia e histologia. O uso de laser CO2 com microsc\u00f3pio permitiu precis\u00e3o na aplica\u00e7\u00e3o e com vantagens de ser um procedimento ambulatorial diminuindo estresse cir\u00fargico das pacientes. Foi realizado sem anestesia e com dura\u00e7\u00e3o m\u00e9dia de 15 minutos. A cicatriza\u00e7\u00e3o completou-se em torno de tr\u00eas semanas e com cuidados operat\u00f3rios m\u00ednimos. Somente dois casos tiveram sangramento vaginal discreto no quinto e d\u00e9cimo dia de p\u00f3s-operat\u00f3rio, resolvido com tamponamento vaginal por 24 horas. A colposcopia, cirurgia e o seguimento foram feitos pelo autor, tendo uma paciente sido submetida a uma segunda vaporiza\u00e7\u00e3o no quinto m\u00eas de\u00a0\u2026", "num_citations": "1\n", "authors": ["1209"]}
{"title": "Detecting God Methods with Concern Metrics\n", "abstract": " Software metrics have been traditionally used to evaluate the modularity of software systems and to detect code smells, such as God Method. Code smells are symptoms that may indicate something wrong in the system code. God Method represents a method that has grown too much. It tends to centralize the functionality of a class. Recently, concern metrics have also been proposed to evaluate software maintainability. While traditional metrics quantify properties of software modules, concern metrics quantify properties of concerns, such as scattering and tangling. Despite being increasingly used in empirical studies, there is a lack of empirical knowledge about the usefulness of concern metrics to detect code smells. This paper goal is to report the results of an exploratory study which investigates whether concern metrics provide useful indicators to detect God Method. In this study, a set of 47 subjects from two institutions have analyzed traditional and concern metrics aiming to detect instances of this code smell in a system. The study results indicate that elaborated joint analysis of both traditional and concern metrics is often required to detect God Method. We conclude that new focused metrics may be required to support detection of smelly methods.", "num_citations": "1\n", "authors": ["1209"]}