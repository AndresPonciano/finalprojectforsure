{"title": "Non-interactive verifiable computing: Outsourcing computation to untrusted workers\n", "abstract": " We introduce and formalize the notion of Verifiable Computation, which enables a computationally weak client to \u201coutsource\u201d the computation of a function F on various dynamically-chosen inputs x                 1,...,x                                    k                  to one or more workers. The workers return the result of the function evaluation, e.g., y                                    i                 \u2009=\u2009F(x                                    i                 ), as well as a proof that the computation of F was carried out correctly on the given value x                                    i                 . The primary constraint is that the verification of the proof should require substantially less computational effort than computing F(x                                    i                 ) from scratch.               We present a protocol that allows the worker to return a computationally-sound, non-interactive proof that can be verified in O(m\u00b7poly\u03bb) time, where m is the bit-length of the output of F, and \u03bb is a security parameter\u00a0\u2026", "num_citations": "1246\n", "authors": ["1869"]}
{"title": "Distributed detection of node replication attacks in sensor networks\n", "abstract": " The low-cost, off-the-shelf hardware components in unshielded sensor-network nodes leave them vulnerable to compromise. With little effort, an adversary may capture nodes, analyze and replicate them, and surreptitiously insert these replicas at strategic locations within the network. Such attacks may have severe consequences; they may allow the adversary to corrupt network data or even disconnect significant parts of the network. Previous node replication detection schemes depend primarily on centralized mechanisms with single points of failure, or on neighborhood voting protocols that fail to detect distributed replications. To address these fundamental limitations, we propose two new algorithms based on emergent properties (Gligor (2004)), i.e., properties that arise only through the collective action of multiple nodes. Randomized multicast distributes node location information to randomly-selected witnesses\u00a0\u2026", "num_citations": "934\n", "authors": ["1869"]}
{"title": "Pinocchio: Nearly practical verifiable computation\n", "abstract": " To instill greater confidence in computations outsourced to the cloud, clients should be able to verify the correctness of the results returned. To this end, we introduce Pinocchio, a built system for efficiently verifying general computations while relying only on cryptographic assumptions. With Pinocchio, the client creates a public evaluation key to describe her computation; this setup is proportional to evaluating the computation once. The worker then evaluates the computation on a particular input and uses the evaluation key to produce a proof of correctness. The proof is only 288 bytes, regardless of the computation performed or the size of the inputs and outputs. Anyone can use a public verification key to check the proof. Crucially, our evaluation on seven applications demonstrates that Pinocchio is efficient in practice too. Pinocchio's verification time is typically 10ms: 5-7 orders of magnitude less than previous work\u00a0\u2026", "num_citations": "928\n", "authors": ["1869"]}
{"title": "Flicker: An execution infrastructure for TCB minimization\n", "abstract": " We present Flicker, an infrastructure for executing security-sensitive code in complete isolation while trusting as few as 250 lines of additional code. Flicker can also provide meaningful, fine-grained attestation of the code executed (as well as its inputs and outputs) to a remote party. Flicker guarantees these properties even if the BIOS, OS and DMA-enabled devices are all malicious. Flicker leverages new commodity processors from AMD and Intel and does not require a new OS or VMM. We demonstrate a full implementation of Flicker on an AMD platform and describe our development environment for simplifying the construction of Flicker-enabled code.", "num_citations": "902\n", "authors": ["1869"]}
{"title": "Quadratic span programs and succinct NIZKs without PCPs\n", "abstract": " We introduce a new characterization of the NP complexity class, called Quadratic Span Programs (QSPs), which is a natural extension of span programs defined by Karchmer and Wigderson. Our main motivation is the quick construction of succinct, easily verified arguments for NP statements.             To achieve this goal, QSPs use a new approach to the well-known technique of arithmetization of Boolean circuits. Our new approach yields dramatic performance improvements. Using QSPs, we construct a NIZK argument - in the CRS model - for Circuit-SAT consisting of just 7 group elements. The CRS size and prover computation are quasi-linear, making our scheme seemingly quite practical, a result supported by our implementation. Indeed, our NIZK argument attains the shortest proof, most efficient prover, and most efficient verifier of any known technique. We also present a variant of QSPs, called Quadratic\u00a0\u2026", "num_citations": "674\n", "authors": ["1869"]}
{"title": "Challenges in securing vehicular networks\n", "abstract": " In the near future, most new vehicles will be equipped with shortrange radios capable of communicating with other vehicles or with highway infrastructure at distances of at least one kilometer. The radios will allow new applications that will revolutionize the driving experience, providing everything from instant, localized traffic updates to warning signals when the car ahead abruptly brakes. While resembling traditional sensor and ad hoc networks in some respects, vehicular networks pose a number of unique challenges. For example, the information conveyed over a vehicular network may affect life-or-death decisions, making fail-safe security a necessity. However, providing strong security in vehicular networks raises important privacy concerns that must also be considered. To address these challenges, we propose a set of security primitives that can be used as the building blocks of secure applications. The deployment of vehicular networks is rapidly approaching, and their success and safety will depend on viable security solutions acceptable to consumers, manufacturers and governments.", "num_citations": "668\n", "authors": ["1869"]}
{"title": "How to delegate and verify in public: Verifiable computation from attribute-based encryption\n", "abstract": " The wide variety of small, computationally weak devices, and the growing number of computationally intensive tasks makes it appealing to delegate computation to data centers. However, outsourcing computation is useful only when the returned result can be trusted, which makes verifiable computation (VC) a must for such scenarios.               In this work we extend the definition of verifiable computation in two important directions: public delegation and public verifiability, which have important applications in many practical delegation scenarios. Yet, existing VC constructions based on standard cryptographic assumptions fail to achieve these properties.               As the primary contribution of our work, we establish an important (and somewhat surprising) connection between verifiable computation and attribute-based encryption (ABE), a primitive that has been widely studied. Namely, we show how to\u00a0\u2026", "num_citations": "409\n", "authors": ["1869"]}
{"title": "Permacoin: Repurposing bitcoin work for data preservation\n", "abstract": " Bit coin is widely regarded as the first broadly successful e-cash system. An oft-cited concern, though, is that mining Bit coins wastes computational resources. Indeed, Bit coin's underlying mining mechanism, which we call a scratch-off puzzle (SOP), involves continuously attempting to solve computational puzzles that have no intrinsic utility. We propose a modification to Bit coin that repurposes its mining resources to achieve a more broadly useful goal: distributed storage of archival data. We call our new scheme Perm coin. Unlike Bit coin and its proposed alternatives, Perm coin requires clients to invest not just computational resources, but also storage. Our scheme involves an alternative scratch-off puzzle for Bit coin based on Proofs-of-Retrievability (PORs). Successfully minting money with this SOP requires local, random access to a copy of a file. Given the competition among mining clients in Bit coin, this\u00a0\u2026", "num_citations": "324\n", "authors": ["1869"]}
{"title": "Phoolproof phishing prevention\n", "abstract": " Phishing, or web spoofing, is a growing problem: the Anti-Phishing Working Group (APWG) received almost 14,000 unique phishing reports in August 2005, a 56% jump over the number of reports in December 2004 [3]. For financial institutions, phishing is a particularly insidious problem, since trust forms the foundation for customer relationships, and phishing attacks undermine confidence in an institution.               Phishing attacks succeed by exploiting a user\u2019s inability to distinguish legitimate sites from spoofed sites. Most prior research focuses on assisting the user in making this distinction; however, users must make the right security decision every time. Unfortunately, humans are ill-suited for performing the security checks necessary for secure site identification, and a single mistake may result in a total compromise of the user\u2019s online account. Fundamentally, users should be authenticated using\u00a0\u2026", "num_citations": "304\n", "authors": ["1869"]}
{"title": "User-driven access control: Rethinking permission granting in modern operating systems\n", "abstract": " Modern client platforms, such as iOS, Android, Windows Phone, Windows 8, and web browsers, run each application in an isolated environment with limited privileges. A pressing open problem in such systems is how to allow users to grant applications access to user-owned resources, e.g., to privacy- and cost-sensitive devices like the camera or to user data residing in other applications. A key challenge is to enable such access in a way that is non-disruptive to users while still maintaining least-privilege restrictions on applications. In this paper, we take the approach of user-driven access control, whereby permission granting is built into existing user actions in the context of an application, rather than added as an afterthought via manifests or system prompts. To allow the system to precisely capture permission-granting intent in an application's context, we introduce access control gadgets (ACGs). Each user\u00a0\u2026", "num_citations": "285\n", "authors": ["1869"]}
{"title": "Portcullis: Protecting connection setup from denial-of-capability attacks\n", "abstract": " Systems using capabilities to provide preferential service to selected flows have been proposed as a defense against large-scale network denial-of-service attacks. While these systems offer strong protection for established network flows, the Denial-of-Capability (DoC) attack, which prevents new capability-setup packets from reaching the destination, limits the value of these systems. Portcullis mitigates DoC attacks by allocating scarce link bandwidth for connection establishment packets based on per-computation fairness. We prove that a legitimate sender can establish a capability with high probability regardless of an attacker's resources or strategy and that no system can improve on our guarantee. We simulate full and partial deployments of Portcullis on an Internet-scale topology to confirm our theoretical results and demonstrate the substantial benefits of using per-computation fairness.", "num_citations": "275\n", "authors": ["1869"]}
{"title": "Bootstrapping trust in commodity computers\n", "abstract": " Trusting a computer for a security-sensitive task (such as checking email or banking online) requires the user to know something about the computer's state. We examine research on securely capturing a computer's state, and consider the utility of this information both for improving security on the local computer (e.g., to convince the user that her computer is not infected with malware) and for communicating a remote computer's state (e.g., to enable the user to check that a web server will adequately protect her data). Although the recent \"Trusted Computing\" initiative has drawn both positive and negative attention to this area, we consider the older and broader topic of bootstrapping trust in a computer. We cover issues ranging from the wide collection of secure hardware that can serve as a foundation for trust, to the usability issues that arise when trying to convey computer state information to humans. This approach\u00a0\u2026", "num_citations": "202\n", "authors": ["1869"]}
{"title": "Bootstrapping Trust in a \"Trusted\" Platform.\n", "abstract": " For the last few years, many commodity computers have come equipped with a Trusted Platform Module (TPM). Existing research shows that the TPM can be used to establish trust in the software executing on a computer. However, at present, there is no standard mechanism for establishing trust in the TPM on a particular machine. Indeed, any straightforward approach falls victim to a cuckoo attack. In this work, we propose a formal model for establishing trust in a platform. The model reveals the cuckoo attack problem and suggests potential solutions. Unfortunately, no instantiation of these solutions is fully satisfying, and hence, we pose the development of a fully satisfactory solution as an open question to the community.", "num_citations": "161\n", "authors": ["1869"]}
{"title": "Resolving the conflict between generality and plausibility in verified computation\n", "abstract": " The area of proof-based verified computation (outsourced computation built atop probabilistically checkable proofs and cryptographic machinery) has lately seen renewed interest. Although recent work has made great strides in reducing the overhead of naive applications of the theory, these schemes still cannot be considered practical. A core issue is that the work for the server is immense, in general; it is practical only for hand-compiled computations that can be expressed in special forms.", "num_citations": "135\n", "authors": ["1869"]}
{"title": "Secure sensor network routing: A clean-slate approach\n", "abstract": " The deployment of sensor networks in security-and safety-critical environments requires secure communication primitives. In this paper, we design, implement, and evaluate a new secure routing protocol for sensor networks. Our protocol requires no special hardware and provides message delivery even in an environment with active adversaries. We adopt a clean-slate approach and design a new sensor network routing protocol with security and efficiency as central design parameters. Our protocol is efficient yet highly resilient to active attacks. We demonstrate the performance of our algorithms with simulation results as well as an implementation on Telos sensor nodes.", "num_citations": "120\n", "authors": ["1869"]}
{"title": "CLAMP: Practical prevention of large-scale data leaks\n", "abstract": " Providing online access to sensitive data makes Web servers lucrative targets for attackers. A compromise of any of the Web server's scripts, applications, or operating system can leak the sensitive data of millions of customers. Unfortunately, many systems for stopping data leaks require considerable effort from application developers, hindering their adoption. In this work, we investigate how such leaks can be prevented with minimal developer effort. We propose CLAMP, an architecture for preventing data leaks even in the presence of Web server compromises or SQL injection attacks. CLAMP protects sensitive data by enforcing strong access control on user data and by isolating code running on behalf of different users. By focusing on minimizing developer effort, we arrive at an architecture that allows developers to use familiar operating systems, servers, and scripting languages, while making relatively few\u00a0\u2026", "num_citations": "112\n", "authors": ["1869"]}
{"title": "Komodo: Using verification to disentangle secure-enclave hardware from software\n", "abstract": " Intel SGX promises powerful security: an arbitrary number of user-mode enclaves protected against physical attacks and privileged software adversaries. However, to achieve this, Intel extended the x86 architecture with an isolation mechanism approaching the complexity of an OS microkernel, implemented by an inscrutable mix of silicon and microcode. While hardware-based security can offer performance and features that are difficult or impossible to achieve in pure software, hardware-only solutions are difficult to update, either to patch security flaws or introduce new features.", "num_citations": "106\n", "authors": ["1869"]}
{"title": "How low can you go? Recommendations for hardware-supported minimal TCB code execution\n", "abstract": " We explore the extent to which newly available CPU-based security technology can reduce the Trusted Computing Base (TCB) for security-sensitive applications. We find that although this new technology represents a step in the right direction, significant performance issues remain. We offer several suggestions that leverage existing processor technology, retain security, and improve performance. Implementing these recommendations will finally allow application developers to focus exclusively on the security of their own code, enabling it to execute in isolation from the numerous vulnerabilities in the underlying layers of legacy code.", "num_citations": "96\n", "authors": ["1869"]}
{"title": "Bootstrapping trust in modern computers\n", "abstract": " Trusting a computer for a security-sensitive task (such as checking email or banking online) requires the user to know something about the computer's state. We examine research on securely capturing a computer's state, and consider the utility of this information both for improving security on the local computer (eg, to convince the user that her computer is not infected with malware) and for communicating a remote computer's state (eg, to enable the user to check that a web server will adequately protect her data). Although the recent\" Trusted Computing\" initiative has drawn both positive and negative attention to this area, we consider the older and broader topic of bootstrapping trust in a computer. We cover issues ranging from the wide collection of secure hardware that can serve as a foundation for trust, to the usability issues that arise when trying to convey computer state information to humans. This approach unifies disparate research efforts and highlights opportunities for additional work that can guide real-world improvements in computer security.", "num_citations": "93\n", "authors": ["1869"]}
{"title": "Unidirectional Key Distribution Across Time and Space with Applications to RFID Security.\n", "abstract": " We explore the problem of secret-key distribution in unidirectional channels, those in which a sender transmits information blindly to a receiver. We consider two approaches:(1) Key sharing across space, ie, via simultaneously emitted values that may follow different data paths and (2) Key sharing across time, ie, in temporally staggered emissions. Our constructions are of general interest, treating, for instance, the basic problem of constructing highly compact secret shares. Our main motivating problem, however, is practical key management in RFID (Radio-Frequency IDentification) systems. We describe the application of our techniques to RFID-enabled supply chains and a prototype privacy-enhancing system.", "num_citations": "93\n", "authors": ["1869"]}
{"title": "Minimal TCB code execution\n", "abstract": " We propose an architecture that allows code to execute in complete isolation from other software while trusting only a tiny software base that is orders of magnitude smaller than even minimalist virtual machine monitors. Our technique also enables more meaningful attestation than previous proposals, since only measurements of the security-sensitive portions of an application need to be included. We achieve these guarantees by leveraging hardware support provided by commodity processors from AMD and Intel that are shipping today.", "num_citations": "89\n", "authors": ["1869"]}
{"title": "Embassies: Radically refactoring the web\n", "abstract": " Managing a network requires support for multiple concurrent tasks, from routing and traf\ufb01c monitoring, to access control and server load balancing. Software-De\ufb01ned Networking (SDN) allows applications to realize these tasks directly, by installing packet-processing rules on switches. However, today\u2019s SDN platforms provide limited support for creating modular applications. This paper introduces new abstractions for building applications out of multiple, independent modules that jointly manage network traf\ufb01c. First, we de\ufb01ne composition operators and a library of policies for forwarding and querying traf\ufb01c. Our parallel composition operator allows multiple policies to operate on the same set of packets, while a novel sequential composition operator allows one policy to process packets after another. Second, we enable each policy to operate on an abstract topology that implicitly constrains what the module can see and do. Finally, we de\ufb01ne a new abstract packet model that allows programmers to extend packets with virtual \ufb01elds that maybe used to associate packets with high-level meta-data. We realize these abstractions in Pyretic, an imperative, domain-speci\ufb01c language embedded in Python.", "num_citations": "54\n", "authors": ["1869"]}
{"title": "User-driven access control\n", "abstract": " An access system is described herein which allows an application module to access a user-owned resource based on an indication of a user's intent to interact with the user-owned resource. For example, the application module can provide an application user interface which embeds a gadget associated with a particular user-owned resource. The access system can interpret the user's interaction with the gadget as conferring implicit permission to the application module to access the user-owned resource associated with the gadget. In addition, or alternatively, the user may make a telltale gesture in the course of interacting with the application module. The access system can interpret this gesture as conferring implicit permission to the application module to access a user-owned resource that is associated with the gesture.", "num_citations": "52\n", "authors": ["1869"]}
{"title": "Lockdown: Towards a safe and practical architecture for security applications on commodity platforms\n", "abstract": " We investigate a new point in the design space of red/green systems [19,30], which provide the user with a highly-protected, yet also highly-constrained trusted (\u201cgreen\u201d) environment for performing security-sensitive transactions, as well as a high-performance, general-purpose environment for all other (non-security-sensitive or \u201cred\u201d) applications. Through the design and implementation of the Lockdown architecture, we evaluate whether partitioning, rather than virtualizing, resources and devices can lead to better security or performance for red/green systems. We also design a simple external interface to allow the user to securely learn which environment is active and easily switch between them. We find that partitioning offers a new tradeoff between security, performance, and usability. On the one hand, partitioning can improve the security of the \u201cgreen\u201d environment and the performance of the \u201cred\u00a0\u2026", "num_citations": "52\n", "authors": ["1869"]}
{"title": "Method and apparatus for secure online transactions\n", "abstract": " Phishing attacks succeed by exploiting a user's inability to distinguish legitimate websites from spoofed websites. Most prior work focuses on assisting the user in making this distinction; however, users must make the right security decision every time. Unfortunately, humans are ill-suited for performing the security checks necessary for secure site identification, and a single mistake may result in a total compromise of the user's online account. Fundamentally, users should be authenticated using information that they cannot readily reveal to malicious parties. Placing less reliance on the user during the authentication process enhances security and eliminates many forms of fraud. We disclose using a trusted device to perform mutual authentication that eliminates reliance on perfect user behavior, thwarts Man-in-the-Middle attacks after setup, and protects a user's account even in the presence of keyloggers and most\u00a0\u2026", "num_citations": "47\n", "authors": ["1869"]}
{"title": "How to Run {POSIX} Apps in a Minimal Picoprocess\n", "abstract": " We envision a future where Web, mobile, and desktop applications are delivered as isolated, complete software stacks to a minimal, secure client host. This shift imbues app vendors with full autonomy to maintain their apps\u2019 integrity. Achieving this goal requires shifting complex behavior out of the client platform and into the vendors\u2019 isolated apps. We ported rich, interactive POSIX apps, such as Gimp and Inkscape, to a spartan host platform. We describe this effort in sufficient detail to support reproducibility.", "num_citations": "38\n", "authors": ["1869"]}
{"title": "Lockdown: A safe and practical environment for security applications\n", "abstract": " We describe, build, and evaluate Lockdown, a system that significantly increases the level of security for online transactions, even on a platform infested with malicious code. Lockdown provides the user with a highly-protected, yet also highly-constrained trusted environment for performing online transactions, as well as a high-performance, general-purpose environment for all other (non-security-sensitive) applications. A simple, user-friendly external interface allows the user to securely learn which environment is active and easily switch between them. We focus on making Lockdown deployable and usable today. Lockdown works with both Windows and Linux, and provides immediate improvements to security-sensitive tasks while imposing, on average, only 3% memory overhead and 2\u20137% storage overhead on non-security-related tasks.", "num_citations": "34\n", "authors": ["1869"]}
{"title": "Methods and apparatuses for user-verifiable execution of security-sensitive code\n", "abstract": " A computer including a processor and a verification device. The processor in the computer performs the steps of authenticating a secure connection between a hypervisor and the verification device, measuring the identity of at least a portion of a select guest before the select guest executes any instruction, and sending a measurement of the identity of the select guest to the verification device. The verification device compares the policy stored in the verification device with the measurement of the select guest received by the verification device. The steps of authenticating, measuring, sending, and comparing are performed after receiving a signal indicative of a request to execute the select guest and without rebooting the computer.", "num_citations": "31\n", "authors": ["1869"]}
{"title": "A verified, efficient embedding of a verifiable assembly language\n", "abstract": " High-performance cryptographic libraries often mix code written in a high-level language with code written in assembly. To support formally verifying the correctness and security of such hybrid programs, this paper presents an embedding of a subset of x64 assembly language in F* that allows efficient verification of both assembly and its interoperation with C code generated from F*. The key idea is to use the computational power of a dependent type system's type checker to run a verified verification-condition generator during type checking. This allows the embedding to customize the verification condition sent by the type checker to an SMT solver. By combining our proof-by-reflection style with SMT solving, we demonstrate improved automation for proving the correctness of assembly-language code. This approach has allowed us to complete the first-ever proof of correctness of an optimized implementation of\u00a0\u2026", "num_citations": "28\n", "authors": ["1869"]}
{"title": "SNAPP: Stateless network-authenticated path pinning\n", "abstract": " This paper examines a new building block for next-generation networks: SNAPP, or Stateless Network-Authenticated Path Pinning. SNAPP-enabled routers securely embed their routing decisions in the packet headers of a stream of traffic, effectively pinning a flow's path between sender and receiver. A sender can use the pinned path (even if routes subsequently change) by including the path embedding in later packet headers. This architectural building block decouples routing from forwarding, which greatly enhances the availability of a path in the face of routing misconfigurations or malicious attacks. To demonstrate the extreme flexibility of SNAPP, we show how it can support a wide range of applications, including sender-controlled paths, expensive route lookups, sender anonymity, and sender accountability. Our analysis shows that SNAPP's overhead is low, and the system is easily implemented in hardware\u00a0\u2026", "num_citations": "25\n", "authors": ["1869"]}
{"title": "Trust extension as a mechanism for secure code execution on commodity computers\n", "abstract": " As society rushes to digitize sensitive information and services, it is imperative to adopt adequate security protections. However, such protections fundamentally conflict with the benefits we expect from commodity computers. In other words, consumers and businesses value commodity computers because they provide good performance and an abundance of features at relatively low costs. Meanwhile, attempts to build secure systems from the ground up typically abandon such goals, and hence are seldom adopted [8, 72, 104].", "num_citations": "20\n", "authors": ["1869"]}
{"title": "An Analysis of Database-Driven Mail Servers.\n", "abstract": " This paper compares the performance of three different IMAP servers, each of which uses a different storage mechanism: Cyrus uses a database built on BerkeleyDB, Courier-IMAP uses maildirs, and UW-IMAP uses mbox files. We also use a mySQL database to simulate a relational-database-driven IMAP server. We find that Cyrus and mySQL outperform UW and Courier in most tests, often dramatically beating Courier. Cyrus is particularly efficient at scan operations such as retrieving headers, and it also does particularly well on searches on header fields. UW and Cyrus perform similarly on full-text searches, although Cyrus seems to scale slightly better as the size of the mailbox grows. mySQL excels at full-text searches and header retrieval, but it performs poorly when deleting messages. In general, we believe that a database system offers better email storage facilities than traditional file systems.", "num_citations": "17\n", "authors": ["1869"]}
{"title": "Storing and Retrieving Secrets on a Blockchain.\n", "abstract": " Multiple protocols implementing exciting blockchain-based cryptographic functionalities (eg, time-lock encryption, one-time programs, and fair multi-party computation) assume the existence of a cryptographic primitive called extractable witness encryption. Unfortunately, there are no known efficient constructions (or even constructions based on any well-studied assumptions) of extractable witness encryption. In this work, we propose a protocol that uses a blockchain to provide a functionality that is effectively the same as extractable witness encryption. Hence, by making small adjustments to existing blockchains, we can easily implement applications that rely on extractable witness encryption. This includes both new applications, and those that previously existed only as theoretical designs. As a key building block, our protocol uses a new and highly efficient batched dynamic proactive secret sharing (DPSS) scheme which may be of independent interest. We provide a proof-of-concept implementation of our protocol.", "num_citations": "15\n", "authors": ["1869"]}
{"title": "Key distribution in unidirectional channels with applications to RFID\n", "abstract": " A technique for securing information involves encrypting raw data into encrypted data based on an initial key. The technique further involves generating a set of key shares from the initial key via application of error correction code encoding. Each key share has a size which is independent of a size of the initial key. The technique further involves electronically storing each key share on a respective memory device of a set of memory devices (eg, RFID tags). The initial key is reconstructable from a predetermined number of the key shares read from their respective memory devices to enable decryption of the encrypted data.", "num_citations": "14\n", "authors": ["1869"]}
{"title": "Talek: a private publish-subscribe protocol\n", "abstract": " Modern applications share user-generated data over the cloud, often exposing sensitive information. Talek is a private publish-subscribe (pub/sub) system that shares user data through potentially untrustworthy servers, while hiding both data content and the communication patterns among its users. Talek is designed with two goals that distinguish it from the prior work in private messaging. First, Talek is designed with the strong security goal of access sequence indistinguishability, where clients leak no information to adversarial servers that might help an adversary distinguish between two arbitrary-length client access sequences. Second, our system aims to be practical for general-purpose workloads, from one-to-one messaging to one-to-many news feeds. To achieve these properties, we introduce two novel techniques. Oblivious logging is a mechanism for supporting private reads and writes to shared logs stored on servers without coordination between clients. Private notifications provide a private and efficient mechanism for subscribers to learn which topics have new messages without polling. We demonstrate a 3-server Talek cluster that achieves throughput of 566,000 messages/minute with 5.57-second end-to-end latency on commodity servers, a 3\u20134 order of magnitude improvement over related work with similar security goals.", "num_citations": "12\n", "authors": ["1869"]}
{"title": "The trusted platform module (TPM) and sealed storage\n", "abstract": " The Trusted Computing Group (TCG) is an organization that promotes open standards to help strengthen computing platforms against software-based attacks [1]. The TCG issued a specification for a Trusted Platform Module (TPM)[4], which is a dedicated security chip designed to enhance software security. The background on the TPM necessary to understand sealed storage is presented below, along with an example of how sealed storage might be used by an application.", "num_citations": "12\n", "authors": ["1869"]}
{"title": "Providing intent-based access to user-owned resources\n", "abstract": " An access system is described herein which allows an application to access a system-level and/or application-specific user-owned resource based on a user's interaction with an intent-based access mechanism. For example, the intent-based access mechanism may correspond to a gadget that is embedded in an application user interface provided by the application, and/or logic for detecting a permission-granting input sequence. The access system accommodates different types of intent-based access mechanisms. One type is a scheduled intent-based access mechanism. Another type provides access to two or more user-owned resources. Further, the access system includes a mechanism for determining whether the application is permitted to use an intent-based access mechanism.", "num_citations": "10\n", "authors": ["1869"]}
{"title": "Using trustworthy host-based information in the network\n", "abstract": " As hardware support for improved endhost security becomes ubiquitous, it is important to consider how network security and performance can benefit from these improvements. If portions of each endhost can be trusted, then network infrastructure no longer needs to arduously and imprecisely reconstruct data already known by the endhosts. Through the design of a general-purpose architecture we call Assayer, we explore issues in providing trusted host-based data, including the balance between useful data and user privacy, and the tradeoffs between security and efficiency. We also evaluate the usefulness of such information in several case studies. We implement and evaluate a basic Assayer prototype. Our prototype requires fewer than 1,000 lines of code on the endhost. Endhosts can annotate their outbound traffic in a few microseconds, and these annotations can be checked efficiently; even packet-level\u00a0\u2026", "num_citations": "10\n", "authors": ["1869"]}
{"title": "Talek: Private group messaging with hidden access patterns\n", "abstract": " Talek is a private group messaging system that sends messages through potentially untrustworthy servers, while hiding both data content and the communication patterns among its users. Talek explores a new point in the design space of private messaging; it guarantees access sequence indistinguishability, which is among the strongest guarantees in the space, while assuming an anytrust threat model, which is only slightly weaker than the strongest threat model currently found in related work. Our results suggest that this is a pragmatic point in the design space, since it supports strong privacy and good performance: we demonstrate a 3-server Talek cluster that achieves throughput of 9,433 messages/second for 32,000 active users with 1.7-second end-to-end latency. To achieve its security goals without coordination between clients, Talek relies on information-theoretic private information retrieval. To achieve\u00a0\u2026", "num_citations": "9\n", "authors": ["1869"]}
{"title": "Fast geometric projections for local robustness certification\n", "abstract": " Local robustness ensures that a model classifies all inputs within an -ball consistently, which precludes various forms of adversarial inputs. In this paper, we present a fast procedure for checking local robustness in feed-forward neural networks with piecewise-linear activation functions. Such networks partition the input space into a set of convex polyhedral regions in which the network's behavior is linear; hence, a systematic search for decision boundaries within the regions around a given input is sufficient for assessing robustness. Crucially, we show how the regions around a point can be analyzed using simple geometric projections, thus admitting an efficient, highly-parallel GPU implementation that excels particularly for the  norm, where previous work has been less effective. Empirically we find this approach to be far more precise than many approximate verification approaches, while at the same time performing multiple orders of magnitude faster than complete verifiers, and scaling to much deeper networks.", "num_citations": "9\n", "authors": ["1869"]}
{"title": "Memoir\u2014formal specs and correctness proofs\n", "abstract": " This tech report presents formal specifications for the Memoir system and proofs of the system\u2019s correctness. The proofs were constructed manually but have been programmatically machine-verified using the TLA+ Proof System. 3 Taken together, the specifications and proofs contain 61 top-level definitions, 182 LET-IN definitions, 74 named theorems, and 5816 discrete proof steps. The proofs address only the safety of the Memoir system, not the liveness of the system. Safety is proven by showing that a formal low-level specification of the Memoir-Basic system implements a formal high-level specification of desired behavior. The proofs then show that a formal specification of the Memoir-Opt system implements the Memoir-Basic system.", "num_citations": "9\n", "authors": ["1869"]}
{"title": "An execution infrastructure for TCB minimization\n", "abstract": " We present Flicker, an infrastructure for executing security-sensitive code in complete isolation while trusting as few as 250 lines of additional code. Flicker can also provide meaningful, fine-grained attestation of the code executed (as well as its inputs and outputs) to a remote party. Flicker guarantees these properties even if the BIOS, OS and DMA-enabled devices are all malicious. Flicker leverages new commodity processors from AMD and Intel and does not require a new OS or VMM. We demonstrate a full implementation of Flicker on an AMD platform and describe our development environment for simplifying the construction of Flicker-enabled code.", "num_citations": "9\n", "authors": ["1869"]}
{"title": "Internet ballistics: Retrieving forensic data from network scans\n", "abstract": " The typical network receives millions of hostile probes every day. A significant portion of these probes constitute network scans. During a network scan, the attacker sends connection requests to every possible network address and listens for replies indicating the presence of a (possibly vulnerable) computer. Since a network scan often serves as a precursor to an attack, reliable identification of scanners can significantly enhance cybersecurity. Furthermore, the ability to map adversary hierarchies and correlate attacks with events in the real world contributes to counterintelligence work. For a variety of reasons, source IP addresses fail to provide the necessary identification information. However, analyzing packet arrival timing data reveals highly distinctive patterns that may correlate with the attacker's choice of tools, physical platform and/or network location. By selecting data transforms conducive to periodic analysis\u00a0\u2026", "num_citations": "9\n", "authors": ["1869"]}
{"title": "A Note on the Unsoundness of vnTinyRAM's SNARK.\n", "abstract": " Gennaro, Gentry, Parno, and Raykova (GGPR) introduced Quadratic Arithmetic Programs (QAPs) as a way of representing arithmetic circuits in a form amendable to highly efficient cryptographic protocols [11], particularly for verifiable computation and succinct non-interactive arguments [12]. Subsequently, Parno, Gentry, Howell, and Raykova introduced an improved cryptographic protocol (and implementation), which they dubbed Pinocchio [13]. Ben-Sasson et al.[5] then introduced a lightly modified version of the Pinocchio protocol and implemented it as part of their libsnark distribution. Later work by the same authors employed this protocol [2\u20134, 10], as did a few works by others [1, 14]. Many of these works cite the version of the paper which was published at USENIX Security [6]. However, the protocol does not appear in that peer-reviewed paper; instead, it appears only in a technical report [5], where it is justified via a lemma that lacks a proof. Unfortunately, the lemma is incorrect, and the modified protocol is unsound. With probability one, an adversary can submit false statements and proofs that the verifier will accept. We demonstrate this theoretically, as well as with concrete examples in which the protocol\u2019s implementation in libsnark accepts invalid statements.", "num_citations": "8\n", "authors": ["1869"]}
{"title": "The web interface should be radically refactored\n", "abstract": " The Web API conflates two conflicting goals: serving developers by supporting a wide and growing suite of functionality, and providing applications with an isolated execution environment. We propose to split the API into two levels of interface: a low-level interface that governs the relationship between the application and the browser, and a set of high-level interfaces that govern the relationship between the application and its developer. We delineate a tiny set of properties needed by the low-level interface. We argue that this restructuring provides significant benefit to both developers and users.", "num_citations": "8\n", "authors": ["1869"]}
{"title": "Help me help you: Using trustworthy host-based information in the network\n", "abstract": " As hardware support for improved endhost se-curity becomes ubiquitous, it is important to consider how network security and performance can benefit from these improvements. If endhosts (or at least portions of each endhost) can be trusted, then network infrastructure no longer needs to arduously and imprecisely reconstruct data already known by the endhosts. Through the design of a general-purpose architecture we call Assayer, we explore the issues in providing trusted host-based data, including the balance between useful information and user privacy, and the tradeoffs between security and efficiency. We also evaluate the usefulness of such information in three case studies. To gain insight into the performance we could expect from such a system, we implement and evaluate a basic Assayer prototype. Our prototype requires fewer than 1,000 lines of code on the endhost. Endhosts can annotate their outbound traffic in a few microseconds, and these annotations can be checked efficiently; even packet-level annotations on a gigabit link can be checked with a loss in throughput of only 3.7-18.3%.", "num_citations": "7\n", "authors": ["1869"]}
{"title": "Trust extension for commodity computers\n", "abstract": " A user's trust in a single device can be extended to many other devices.", "num_citations": "6\n", "authors": ["1869"]}
{"title": "Roots of Trust\n", "abstract": " Trust in any system needs a foundation or a root of trust. Here, we discuss the roots of trust that have been proposed or deployed. Typically, the root of trust is based on the secrecy of a private key that is embedded in hardware; the corresponding public key is certified by the hardware\u2019s manufacturer. As we discuss, some systems further rely on a piece of code that must execute in the early boot process for their root of trust.We also discuss schemes where the root of trust is established by the properties of the physical hardware itself.", "num_citations": "5\n", "authors": ["1869"]}
{"title": "Don\u2019t Talk to Zombies: Mitigating DDoS Attacks via Attestation\n", "abstract": " Distributed Denial-of-Service (DDoS) attacks typically originate from exploited endhosts controlled by a remote attacker. Current network-based DDoS defenses can only filter out malicious traffic based on the traffic\u2019s inherent properties; they cannot filter based on properties of the endhost that generated the traffic. We observe that the identity of the code that has generated a packet offers powerful predicates for filtering, and we develop a secure, general architecture, Assayer, for in-network filtering based on endhost properties. Our proposed Assayer architecture leverages hardwarebased attestation mechanisms to enable legitimate endhosts to embed secure proofs of code identity in packets. Receivers can specify traffic policies, which are enforced by on-path prioritizers. We design Assayer to achieve scalability, efficiency, and incremental deployability. We implement and evaluate a basic Assayer prototype and find that the perceived application overhead, felt only during periods of significant network congestion, is less than 12%. Our simulations indicate that our architecture, even when deployed only at the victim\u2019s ISP, provides excellent protection against a botnet of 100,000 attacking hosts.", "num_citations": "5\n", "authors": ["1869"]}
{"title": "Storage Systems are Distributed Systems (So Verify Them That Way!)\n", "abstract": " To verify distributed systems, prior work introduced a methodology for verifying both the code running on individual machines and the correctness of the overall system when those machines interact via an asynchronous distributed environment. The methodology requires neither domain-specific logic nor tooling. However, distributed systems are only one instance of the more general phenomenon of systems code that interacts with an asynchronous environment. We argue that the software of a storage system can (and should!) be viewed similarly.", "num_citations": "4\n", "authors": ["1869"]}
{"title": "Countermeasures against government-scale monetary forgery\n", "abstract": " Physical cash is vulnerable to rising threats, such as large-scale, government-mandated forgeries, that digital cash may protect against more effectively. We study mechanisms to combine physical cash with digital cash to remove their respective shortcomings and obtain their combined advantages. We discuss initial mechanisms and examine their cost and benefit trade-offs.", "num_citations": "4\n", "authors": ["1869"]}
{"title": "Flicker: Minimal TCB code execution\n", "abstract": " Flicker: Minimal TCB Code Execution Page 1 1 Flicker: Minimal TCB Code Execution Jonathan M. McCune Carnegie Mellon University March 25, 2008 Bryan Parno, Arvind Seshadri Adrian Perrig, Michael Reiter Page 2 2 Password Reuse \u2022 People often use 1 password for 2+ websites \u2022 Banking, social networking, file sharing, \u2026 PASSWORD Page 3 3 Password Exposure \u2022 Password provided to compromised web server PASSWORD Myhobby .com www.myhobby.com is compromised! Page 4 4 Password Verification \u2022 What if\u2026 \u2013 A compromised OS cannot learn the password \u2013 Only essential code can access password \u2022 Decrypt SSL traffic \u2022 Salt and hash password \u2022 Compare with stored hash \u2022 Output MATCH or FAILURE \u2013 Can remotely verify this is so \u2022 Requires strong system security \u2022 What about zero knowledge protocols? \u2013 A viable alternative for passwords \u2013 Our techniques are more general \u2022 Password \u2026", "num_citations": "3\n", "authors": ["1869"]}
{"title": "FANFARE for the common flow\n", "abstract": " This paper presents FANFARE1, a suite of infrastructure-based primitives that empowers routers and receivers to secure and enforce various flow-control mechanisms, such as per-flow admission control, service differentiation, and congestion control, even in the face of sophisticated attackers. In FANFARE, a sender must receive capabilities from both a receiver and forwarding routers in order to acquire a certain bandwidth allocation, thus empowering both receivers and routers to control the rates of flows. FANFARE provides strong incremental deployment properties; in particular, FANFARE\u2019s automatic congestion response mechanism can protect a downstream legacy link from being flooded by FANFARE traffic. In FANFARE, routers use no per-flow state; they only need to rely on local information to make decisions, and hence do not have to trust other routers. FANFARE can be used to secure several known architectures for managing flows. In this paper, for example, we show how to use FANFARE to halt DDoS attacks and to secure a Diffserv infrastructure.", "num_citations": "3\n", "authors": ["1869"]}
{"title": "Poppins: a direct construction for asymptotically optimal zkSNARKs\n", "abstract": " We present Poppins, a direct construction of a zero-knowledge argument system for general computation that features an  time prover and an  time verifier (after a single  public setup) for computations of size . Our scheme utilizes a universal linear-size structured reference string (SRS) that allows a single trusted setup to be used across all computation instances of a bounded size. Concretely, for computations of size , our prover's cost is dominated by  multi-exponentiations of size  and our verifier's cost is dominated by  pairings. To achieve the stated asymptotics, we first construct a nearly-optimal zkSNARK with a logarithmic verifier in the random oracle model. We then show how to achieve a constant-time verifier using (single-layer) proof composition. Along the way we design (1) a new polynomial commitment scheme for evaluation-based representations of polynomials,(2) an asymptotically optimal inner-product argument system,(3) an asymptotically optimal multi-Hadamard-product argument system, and (4)~ a new constraint system for NP that is particularly well-suited for our bundle of techniques.", "num_citations": "2\n", "authors": ["1869"]}
{"title": "Missive: Fast application launch from an untrusted buffer cache\n", "abstract": " Embassies system turns the web browser model inside out: the client is ultra-minimal, and hence strongly isolates pages and apps; every app carries its own libraries and provides itself OS-like services. A typical Embassies app is 100 MiB of binary code. We have found that the first reaction most people have upon learning of this design is: how can big apps start quickly in such a harsh, mutually-untrusting environment'", "num_citations": "2\n", "authors": ["1869"]}
{"title": "1 Browser Enhancements for Preventing Phishing Attacks\n", "abstract": " Phishing attacks exploit human vulnerabilities. They play on our feelings of greed, our instinct to help others, or our need to protect what we have. Phishers often use the same social engineering strategies that con artists have used in the offline world for generations. And despite years of consumer education efforts, users continue to be scammed by offline con artists. In fact, in the first half of 2005, victims of telemarketing scams lost an average of $4100\u2013more than double the average loss in 2004 [7].The continued \u201csuccess\u201d of con artists in the offline environment demonstrates the effectiveness of social engineering in manipulating human judgment. Relying on human judgment to combat phishing attacks\u2013which are often social engineering attacks\u2013is a curious choice. But that is exactly what has happened. In many anti-phishing schemes, users are responsible for detecting and avoiding phishing sites.", "num_citations": "2\n", "authors": ["1869"]}
{"title": "Defending a P2P digital preservation system\n", "abstract": " The LOCKSS (Lots Of Copies Keep Stuff Safe) system allows users to store and preserve electronic content through a system of inexpensive computers arranged in an ad hoc peer-to-peer network. These peers cooperate to detect and repair damage by voting in \"opinion polls.\" We develop a more accurate view of how the network will perform over time by simulating the system's behavior using dynamic models in which peers can be subverted and repaired. These models take into account a variety of parameters, including the rate of peer subversion, the rate of repair, the extent of subversion, and the responsiveness of each peer's system administrator. These models reveal certain systemic vulnerabilities not apparent in our static simulations: a typical adversary that begins with a small foothold within the system (e.g., 20 percent of the population) will completely dominate the voting process within 10 years, even if\u00a0\u2026", "num_citations": "2\n", "authors": ["1869"]}
{"title": "HerQules: securing programs via hardware-enforced message queues\n", "abstract": " Many computer programs directly manipulate memory using unsafe pointers, which may introduce memory safety bugs. In response, past work has developed various runtime defenses, including memory safety checks, as well as mitigations like no-execute memory, shadow stacks, and control-flow integrity (CFI), which aim to prevent attackers from obtaining program control. However, software-based designs often need to update in-process runtime metadata to maximize accuracy, which is difficult to do precisely, efficiently, and securely. Hardware-based fine-grained instruction monitoring avoids this problem by maintaining metadata in special-purpose hardware, but suffers from high design complexity and requires significant microarchitectural changes.", "num_citations": "1\n", "authors": ["1869"]}
{"title": "Don't Yank My Chain: Auditable {NF} Service Chaining\n", "abstract": " Auditing is a crucial component of network security practices in organizations with sensitive information such as banks and hospitals. Unfortunately, network function virtualization (NFV) is viewed as incompatible with auditing practices which verify that security functions operate correctly. In this paper, we bring the benefits of NFV to security sensitive environments with the design and implementation of AuditBox.", "num_citations": "1\n", "authors": ["1869"]}
{"title": "CAPS: Smoothly Transitioning to a More Resilient Web PKI\n", "abstract": " Many recent proposals to increase the resilience of the Web PKI against misbehaving CAs face significant obstacles to deployment. These hurdles include (1) the requirement of drastic changes to the existing PKI players and their interactions,(2) the lack of signaling mechanisms to protect against downgrade attacks,(3) the lack of an incremental deployment strategy, and (4) the use of inflexible mechanisms that hinder recovery from misconfiguration or from the loss or compromise of private keys. As a result, few of these proposals have seen widespread deployment, despite their promise of a more secure Web PKI. To address these roadblocks, we propose Certificates with Automated Policies and Signaling (CAPS), a system that leverages the infrastructure of the existing Web PKI to overcome the aforementioned hurdles. CAPS offers a seamless and secure transition away from today\u2019s insecure Web PKI and\u00a0\u2026", "num_citations": "1\n", "authors": ["1869"]}
{"title": "Missive: Fast appliance launch from an untrusted buffer cache\n", "abstract": " The rise of virtualization on servers and more secure application architectures on client systems (eg, iOS, Android, Windows 8) has resulted in a multitude of systems in which strongly isolated applications from mutually distrusting vendors run atop a minimal layer of host software. As functionality migrates out of the trusted computing base and into applications, how can we provide fast, interactive application launch times without relying on a trusted buffer cache?This paper presents Missive, an end-to-end system for generating application image files, transmitting them across the wide-area Internet, and storing them in an untrusted cache. Via an architecture that is carefully designed to exploit application commonality, Missive preserves the abstraction of purely isolated app launch and yet launches apps in only a few hundred milliseconds.", "num_citations": "1\n", "authors": ["1869"]}
{"title": "Monetary Forgery in the Digital Age: Will Physical-Digital Cash Be a Solution\n", "abstract": " Despite cryptographic breakthroughs in the area of digital cash and the rapid advance of information technology, physical cash remains the dominant currency: it is easy to use and its exchanges are largely independent of computing devices. However, physical cash is vulnerable to rising threats such as high quality, government-mandated forgeries. Can a hybrid of physical and digital cash protect more effectively against these threats? We discuss the rise of high-quality counterfeits and review technological solutions to thwart such threats. Specifically, we study mechanisms to combine physical cash with digital cash to remove their respective shortcomings and obtain their combined advantages. The mechanisms range from cryptographic signatures embedded in 2-D barcodes to online verification systems assisted by physical one-way functions. Notably, we compare these different proposals by looking at them\u00a0\u2026", "num_citations": "1\n", "authors": ["1869"]}
{"title": "Challenges in bootstrapping trust in secure hardware\n", "abstract": " Thus far, we have discussed how to use various secure hardware mechanisms to bootstrap trust in a platform, in particular by using the secure hardware to monitor and report on the software state of the platform. Given the software state, the user (or an agent acting on the user\u2019s behalf) can decide whether the platform should be trusted. Due to cost considerations, most commodity computers do not include a full-blown secure coprocessor such as the IBM 4758 [185]. Instead, the move has been towards cheaper devices such as the Trusted Platform Module (TPM) [213]. The cost reduction is due in part to the decision to make the TPM secure only against software attacks. As a consequence, a TPM in the physical possession of an adversary cannot be trusted.", "num_citations": "1\n", "authors": ["1869"]}
{"title": "Architectures for Practical Client\u2013Side Security\n", "abstract": " Architectures for Practical Client \u2013Side Security Page 1 VDG, Oct 28, 2010 1 Copyright \u00a9 2010 Architectures for Practical Client \u2013Side Security Virgil D. Gligor* Carnegie Mellon University Pittsburgh, PA 15213 gligor@cmu.edu NSF Trustworthy Computing Workshop October 28, 2010 * based on joint work with J. McCune, B. Parno, Adrian Perrig, A. Vasudevan and Z. Zhou Page 2 VDG, Oct 28, 2010 2 Copyright \u00a9 2010 How would an NSF Panel react to this title? \u2026. Architectures for Security \u2026 Report Comments \u263a: \u2026 When was the last time you\u2019ve seen such things in real life? \u2026 My grandfather did this in kindergarten \u2026 Page 3 VDG, Oct 28, 2010 3 Copyright \u00a9 2010 NSF Panel: Architectures for Practical Security? Report Comments \u263a: \u2026 are you kidding? Page 4 VDG, Oct 28, 2010 4 Copyright \u00a9 2010 NSF Panel: Architectures for Practical Client \u2013Side Security? Report Comments (without apologizing to John \u2026", "num_citations": "1\n", "authors": ["1869"]}
{"title": "Dependable and Secure Computing\n", "abstract": " [Front cover] Page 1 IEEE TRANSA CTIONS ON DEPEND ABLE AND SECURE COMPUTING V o l. 1, No. 4, October-December 2004 IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING A publication of the IEEE Computer Society VOLUME 1 NUMBER 4 ITDSCM (ISSN 1545-5971) http://computer.org tdsc@computer.org OCTOBER-DECEMBER 2004 PAPERS Change-Point Monitoring for the Detection of DoS Attacks H. Wang, D. Zhang, and KG Shin .................................................................................................................................... Defending a P2P Digital Preservation System B. Parno and M. Roussopoulos ........................................................................................................................................ Effective Fault Treatment for Improving the Dependability of COTS and Legacy-Based Applications A. Bondavalli, S. Chiaradonna, D. Cotroneo, and L. Romano............................................................................................ An \u2026", "num_citations": "1\n", "authors": ["1869"]}