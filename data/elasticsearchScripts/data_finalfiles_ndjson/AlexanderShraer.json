{"title": "Efficient traffic splitting on commodity switches\n", "abstract": " Traffic often needs to be split over multiple equivalent backend servers, links, paths, or middleboxes. For example, in a load-balancing system, switches distribute requests of online services to backend servers. Hash-based approaches like Equal-Cost Multi-Path (ECMP) have low accuracy due to hash collision and incur significant churn during update. In a Software-Defined Network (SDN) the accuracy of traffic splits can be improved by crafting a set of wildcard rules for switches that better match the actual traffic distribution. The drawback of existing SDN-based traffic-splitting solutions is poor scalability as they generate too many rules for small rule-tables on switches. In this paper, we propose Niagara, an SDN-based traffic-splitting scheme that achieves accurate traffic splits while being extremely efficient in the use of rule-table space available on commodity switches. Niagara uses an incremental update strategy\u00a0\u2026", "num_citations": "93\n", "authors": ["863"]}
{"title": "Verifying cloud services: present and future\n", "abstract": " As cloud-based services gain popularity in both private and enterprise domains, cloud consumers are still lacking in tools to verify that these services work as expected. Such tools should consider properties such as functional correctness, service availability, reliability, performance and security guarantees. In this paper we survey existing work in these areas and identify gaps in existing cloud technology in terms of the verification tools provided to users. We also discuss challenges and new research directions that can help bridge these gaps.", "num_citations": "82\n", "authors": ["863"]}
{"title": "Dynamic Recon\ufb01guration of Primary/Backup Clusters\n", "abstract": " Dynamically changing (reconfiguring) the membership of a replicated distributed system while preserving data consistency and system availability is a challenging problem. In this paper, we show that reconfiguration can be simplified by taking advantage of certain properties commonly provided by Primary/Backup systems. We describe a new reconfiguration protocol, recently implemented in Apache Zookeeper. It fully automates configuration changes and minimizes any interruption in service to clients while maintaining data consistency. By leveraging the properties already provided by Zookeeper our protocol is considerably simpler than state of the art.", "num_citations": "68\n", "authors": ["863"]}
{"title": "Top-k publish-subscribe for social annotation of news\n", "abstract": " Social content, such as Twitter updates, often have the quickest first-hand reports of news events, as well as numerous commentaries that are indicative of public view of such events. As such, social updates provide a good complement to professionally written news articles. In this paper we consider the problem of automatically annotating news stories with social updates (tweets), at a news website serving high volume of pageviews. The high rate of both the pageviews (millions to billions a day) and of the incoming tweets (more than 100 millions a day) make real-time indexing of tweets ineffective, as this requires an index that is both queried and updated extremely frequently. The rate of tweet updates makes caching techniques almost unusable since the cache would become stale very quickly. We propose a novel architecture where each story is treated as a subscription for tweets relevant to the story's content\u00a0\u2026", "num_citations": "67\n", "authors": ["863"]}
{"title": "Slicer: Auto-sharding for datacenter applications\n", "abstract": " Sharding is a fundamental building block of large-scale applications, but most have their own custom, ad-hoc implementations. Our goal is to make sharding as easily reusable as a filesystem or lock manager. Slicer is Google\u2019s general purpose sharding service. It monitors signals such as load hotspots and server health to dynamically shard work over a set of servers. Its goals are to maintain high availability and reduce load imbalance while minimizing churn from moved work.", "num_citations": "66\n", "authors": ["863"]}
{"title": "Efficient fork-linearizable access to untrusted shared memory\n", "abstract": " When data is stored on a faulty server that is accessed concurrently by multiple clients, the server may present inconsistent data to different clients. For example, the server might complete a write operation of one client, but respond with stale data to another client. Mazi\u00e8res and Shasha (PODC 2002) introduced the notion of fork-consistency, also called fork-linearizability, which ensures that the operations seen by every client are linearizable and guarantees that if the server causes the views of two clients to differ in a single operation, they may never again see each other's updates after that without the server being exposed as faulty. In this paper, we improve the communication complexity of their fork-linearizable storage access protocol with n clients from \u03a9 (n 2) to O (n). We also prove that in every such protocol, a reader must wait for a concurrent writer. This explains a seeming limitation of their and of our\u00a0\u2026", "num_citations": "62\n", "authors": ["863"]}
{"title": "Timeliness, Failure-Detectors, and Consensus Performance\n", "abstract": " Consensus is a widely-studied fundamental problem in distributed computing, theory and practice. Roughly speaking, it allows processes to agree on a common output. We are interested in the performance of consensus algorithms in different timing models. It is known that consensus is not solvable in a completely asynchronous environment, and a completely synchronous one is often too restrictive for real systems. Therefore, many middle-ground models have been previously suggested. One known model is the Eventually Synchronous model, in which the system is asynchronous for an arbitrary period of time and then becomes synchronous. Another method is assuming that each process has an unreliable failure detector oracle, which eventually gives some level of indication to the process about the failed processes or about a common non-faulty leader.We study the implications that various timeliness and failure detector assumptions have on the performance of consensus algorithms that exploit them. We present a general framework, GIRAF, for expressing such assumptions, and reasoning about the performance of indulgent algorithms (algorithms that tolerate an arbitrary period of asynchrony). This framework addresses several shortcomings of a previously known framework-RRFD. We use GIRAF to revisit the notion of oracle (or model) reducibility and define -reducibility that takes time complexity of the reduction into account. We investigate several interesting indulgent models (all weaker than Eventual Synchrony) using GIRAF and give upper and lower bounds for the number of rounds needed to reach consensus in these models. Our\u00a0\u2026", "num_citations": "54\n", "authors": ["863"]}
{"title": "Mobius: unified messaging and data serving for mobile apps\n", "abstract": " Mobile application development is challenging for several reasons: intermittent and limited network connectivity, tight power constraints, server-side scalability concerns, and a number of fault-tolerance issues. Developers handcraft complex solutions that include client-side caching, conflict resolution, disconnection tolerance, and backend database sharding. To simplify mobile app development, we present Mobius, a system that addresses the messaging and data management challenges of mobile application development. Mobius introduces MUD (Messaging Unified with Data). MUD presents the programming abstraction of a logical table of data that spans devices and clouds. Applications using Mobius can asynchronously read from/write to MUD tables, and also receive notifications when tables change via continuous queries on the tables. The system combines dynamic client-side caching (with intelligent\u00a0\u2026", "num_citations": "50\n", "authors": ["863"]}
{"title": "Take me to your leader!: online optimization of distributed storage configurations\n", "abstract": " The configuration of a distributed storage system typically includes, among other parameters, the set of servers and their roles in the replication protocol. Although mechanisms for changing the configuration at runtime exist, it is usually left to system administrators to manually determine the \u201cbest\u201d configuration and periodically reconfigure the system, often by trial and error. This paper describes a new workload-driven optimization framework that dynamically determines the optimal configuration at runtime. We focus on optimizing leader and quorum based replication schemes and divide the framework into three optimization tiers, dynamically optimizing different configuration aspects: 1) leader placement, 2) roles of different servers in the replication protocol, and 3) replica locations. We showcase our optimization framework by applying it to a large-scale distributed storage system used internally in Google and demonstrate that most client applications significantly benefit from using our framework, reducing average operation latency by up to 94%.", "num_citations": "39\n", "authors": ["863"]}
{"title": "Modular Composition of Coordination Services.\n", "abstract": " Coordination services like ZooKeeper, etcd, Doozer, and Consul are increasingly used by distributed applications for consistent, reliable, and high-speed coordination. When applications execute in multiple geographic regions, coordination service deployments trade-off between performance,(achieved by using independent services in separate regions), and consistency.", "num_citations": "33\n", "authors": ["863"]}
{"title": "Self-aware systems for the internet-of-things\n", "abstract": " The IoT will host a large number of co-existing cyber-physical applications. Continuous change, application interference, environment dynamics and uncertainty lead to complex effects which must be controlled to give performance and application guarantees. Application and platform self-configuration and self-awareness are one paradigm to approach this challenge. They can leverage context knowledge to control platform and application functions and their interaction. They could play a dominant role in large scale cyber-physical systems and systems-of-systems, simply because no person can oversee the whole system functionality and dynamics. IoT adds a new dimension because Internet based services will increasingly be used in such system functions. Autonomous vehicles accessing cloud services for efficiency and comfort as well as to reach the required level of safety and security are an example. Such\u00a0\u2026", "num_citations": "19\n", "authors": ["863"]}
{"title": "FoundationDB Record Layer: A Multi-Tenant Structured Datastore\n", "abstract": " The FoundationDB Record Layer is an open source library that provides a record-oriented data store with semantics similar to a relational database implemented on top of FoundationDB, an ordered, transactional key-value store. The Record Layer provides a lightweight, highly extensible way to store structured data. It offers schema management and a rich set of query and indexing facilities, some of which are not usually found in traditional relational databases, such as nested record types, indexes on commit versions, and indexes that span multiple record types. The Record Layer is stateless and built for massive multi-tenancy, encapsulating and isolating all of a tenant's state, including indexes, into a separate logical database. We demonstrate how the Record Layer is used by CloudKit, Apple's cloud backend service, to provide powerful abstractions to applications serving hundreds of millions of users. CloudKit\u00a0\u2026", "num_citations": "13\n", "authors": ["863"]}
{"title": "Space Bounds for Reliable Multi-Writer Data Store: Inherent Cost of Read/Write Primitives\n", "abstract": " Reliable storage emulations from fault-prone components have established themselves as an algorithmic foundation of modern storage services and applications. Most existing reliable storage emulations are built from storage services supporting arbitrary read-modify-write primitives. Since such primitives are not typically exposed by pre-existing or off-the-shelf components (such as cloud storage services or network-attached disks) it is natural to ask if they are indeed essential for efficient storage emulations. In this paper, we answer this question in the affirmative. We show that relaxing the underlying storage to only support read/write operations leads to a linear blow-up in the emulation space requirements. We also show that the space complexity is not adaptive to concurrency, which implies that the storage cannot be reliably reclaimed even in sequential runs. On a positive side, we show that Compare-and-Swap primitives, which are commonly available with many off-the-shelf storage services, can be used to emulate a reliable multi-writer atomic register with constant storage and adaptive time complexity.", "num_citations": "13\n", "authors": ["863"]}
{"title": "CloudKit: Structured Storage for Mobile Applications\n", "abstract": " CloudKit is Apple's cloud backend service and application development framework that provides strongly-consistent storage for structured data and makes it easy to synchronize data across user devices or share it among multiple users. Launched more than 3 years ago, CloudKit forms the foundation for more than 50 Apple apps, including many of our most important and popular applications such as Photos, iCloud Drive, Notes, Keynote, and News, as well as many third-party apps. To deliver this at large scale, CloudKit explicitly leverages multi-tenancy at the application level as well as at the user level to guide efficient data placement and distribution. By using CloudKit application developers are free to focus on delivering the application front-end and logic while relying on CloudKit for scale, consistency, durability and security. CloudKit manages petabytes of data and handles hundreds of millions of users around\u00a0\u2026", "num_citations": "12\n", "authors": ["863"]}
{"title": "Foundationdb: A distributed unbundled transactional key value store\n", "abstract": " FoundationDB is an open source transactional key value store created more than ten years ago. It is one of the first systems to combine the flexibility and scalability of NoSQL architectures with the power of ACID transactions (aka NewSQL). FoundationDB adopts an unbundled architecture that decouples an in-memory transaction management system, a distributed storage system, and a built-in distributed configuration system. Each sub-system can be independently provisioned and configured to achieve the desired scalability, high-availability and fault tolerance properties. FoundationDB uniquely integrates a deterministic simulation framework, used to test every new feature of the system under a myriad of possible faults. This rigorous testing makes FoundationDB extremely stable and allows developers to introduce and release new features in a rapid cadence. FoundationDB offers a minimal and carefully\u00a0\u2026", "num_citations": "6\n", "authors": ["863"]}
{"title": "Systems and methods for increasing bandwidth in a computer network\n", "abstract": " Systems and methods for increasing bandwidth in a computer network are provided. A computer network can include a first lower level switch having a first port and a second port. The computer network can include a second lower level switch having a first port and a second port. The computer network can include an upper level switch having respective ports directly coupled to ports of the first and second lower level switches. A third port of the upper level switch can couple to a first port of a passive optical splitter. The passive optical splitter can have second and third ports coupled to respective ports of the first and second lower level switches. The passive optical splitter can be configured to transmit signals received at its first port as output signals on both of its second and third ports.", "num_citations": "5\n", "authors": ["863"]}
{"title": "Distributed storage system with replica location selection\n", "abstract": " Replicas are selected in a large distributed network, and the roles for these replicas are identified. In one example, an indication that a number N of clusters are to be assigned a replica role and a second number M of the replica-role assigned clusters are to be assigned to a voting role. N computing clusters are selected using workload data, and M of the clusters are assigned to a voting role.", "num_citations": "4\n", "authors": ["863"]}
{"title": "Distributed storage system with replica selection\n", "abstract": " Replicas are selected in a large distributed network, and the roles for these replicas are identified. In one example, the role of voting is assigned to a number of computing clusters. To make this selection, a task assigning service finds a candidate leader and M computing clusters to be used as voters. This selection may be based on finding latencies between the M computing clusters and the leader.", "num_citations": "4\n", "authors": ["863"]}
{"title": "Publish-subscribe based methods and apparatuses for associating data files\n", "abstract": " Various methods and apparatuses are provided which may be implemented using one or more computing devices within a networked computing environment to employ publish-subscribe techniques to associate subscriber encoded data files with a set of publisher encoded data files.", "num_citations": "2\n", "authors": ["863"]}
{"title": "Quick: a queuing system in cloudkit\n", "abstract": " We present QuiCK, a queuing system built for managing asynchronous tasks in CloudKit, Apple's storage backend service. QuiCK stores queued messages along with user data in CloudKit, and supports CloudKit's tenancy model including isolation, fair resource allocation, observability, and tenant migration. QuiCK is built on the FoundationDB Record Layer, an open source transactional DBMS. It employs massive two-level sharding, with tens of billions of queues on the first level (separately storing the queued items for each user of every CloudKit app), and hundreds of queues on a second level (one per FoundationDB cluster used by CloudKit). Our evaluation demonstrates that QuiCK scales linearly with additional consumer resources, effectively avoids contention, provides fairness across CloudKit tenants, and executes deferred tasks with low latency.", "num_citations": "1\n", "authors": ["863"]}
{"title": "Weighted auto-sharding\n", "abstract": " Methods, systems, and apparatus for automatic sharding and load balancing in a distributed data processing system. In one aspect, a method includes determining workload distribution for an application across worker computers and in response to determining a load balancing operation is required: selecting a first worker computer having a highest load measure relative to respective load measure of the other work computers; determining one or more move operations for a partition of data assigned to the first worker computer and a weight for each move operation; and selecting the move operation with a highest weight the selected move operation.", "num_citations": "1\n", "authors": ["863"]}
{"title": "Consistent hashing using exact matching with application to hardware load balancing\n", "abstract": " Aspects and implementations of the present disclosure are directed to a network device storing an address table. Each of the address table entries is assigned to a respective provisioned index value and an instance of a distributed service. The device is configured to add a new service instance to the address table by obtaining an assignable index value for the new service instance, identifying an assigned index value that is a companion index value to the obtained index value, dividing a packet source address set associated with the companion index value into first and second address subsets, and assigning the first address subset to the service instance entry in the address table associated with the assigned companion index value and the second address subset to an entry in the address table associated with the obtained index value and the newly added service instance.", "num_citations": "1\n", "authors": ["863"]}