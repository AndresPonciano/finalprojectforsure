{"title": "Return-oriented programming without returns\n", "abstract": " We show that on both the x86 and ARM architectures it is possible to mount return-oriented programming attacks without using return instructions. Our attacks instead make use of certain instruction sequences that behave like a return, which occur with sufficient frequency in large libraries on (x86) Linux and (ARM) Android to allow creation of Turing-complete gadget sets.", "num_citations": "680\n", "authors": ["337"]}
{"title": "Privilege escalation attacks on android\n", "abstract": " Android is a modern and popular software platform for smartphones. Among its predominant features is an advanced security model which is based on application-oriented mandatory access control and sandboxing. This allows developers and users to restrict the execution of an application to the privileges it has (mandatorily) assigned at installation time. The exploitation of vulnerabilities in program code is hence believed to be confined within the privilege boundaries of an application\u2019s sandbox. However, in this paper we show that a privilege escalation attack is possible. We show that a genuine application exploited at runtime or a malicious application can escalate granted permissions. Our results immediately imply that Android\u2019s security model cannot deal with a transitive permission usage attack and Android\u2019s sandbox model fails as a last resort against malware and sophisticated runtime attacks.", "num_citations": "635\n", "authors": ["337"]}
{"title": "Just-in-time code reuse: On the effectiveness of fine-grained address space layout randomization\n", "abstract": " Fine-grained address space layout randomization (ASLR) has recently been proposed as a method of efficiently mitigating runtime attacks. In this paper, we introduce the design and implementation of a framework based on a novel attack strategy, dubbed just-in-time code reuse, that undermines the benefits of fine-grained ASLR. Specifically, we derail the assumptions embodied in fine-grained ASLR by exploiting the ability to repeatedly abuse a memory disclosure to map an application's memory layout on-the-fly, dynamically discover API functions and gadgets, and JIT-compile a target program using those gadgets -- all within a script environment at the time an exploit is launched. We demonstrate the power of our framework by using it in conjunction with a real-world exploit against Internet Explorer, and also provide extensive evaluations that demonstrate the practicality of just-in-time code reuse attacks. Our\u00a0\u2026", "num_citations": "594\n", "authors": ["337"]}
{"title": "Towards Taming Privilege-Escalation Attacks on Android.\n", "abstract": " Android\u2019s security framework has been an appealing subject of research in the last few years. Android has been shown to be vulnerable to application-level privilege escalation attacks, such as confused deputy attacks, and more recently, attacks by colluding applications. While most of the proposed approaches aim at solving confused deputy attacks, there is still no solution that simultaneously addresses collusion attacks.In this paper, we investigate the problem of designing and implementing a practical security framework for Android to protect against confused deputy and collusion attacks. We realize that defeating collusion attacks calls for a rather system-centric solution as opposed to application-dependent policy enforcement. To support our design decisions, we conduct a heuristic analysis of Android\u2019s system behavior (with popular apps) to identify attack patterns, classify different adversary models, and point out the challenges to be tackled. Then we propose a solution for a system-centric and policy-driven runtime monitoring of communication channels between applications at multiple layers: 1) at the middleware we control IPCs between applications and indirect communication via Android system components. Moreover, inspired by the approach in QUIRE, we establish semantic links between IPCs and enable the reference monitor to verify the call-chain; 2) at the kernel level we realize mandatory access control on the file system (including Unix domain sockets) and local Internet sockets. To allow for runtime, dynamic low-level policy enforcement, we provide a callback channel between the kernel and the middleware. Finally, we\u00a0\u2026", "num_citations": "516\n", "authors": ["337"]}
{"title": "Stitching the gadgets: On the ineffectiveness of coarse-grained control-flow integrity protection\n", "abstract": " Return-oriented programming (ROP) offers a robust attack technique that has, not surprisingly, been extensively used to exploit bugs in modern software programs (eg, web browsers and PDF readers). ROP attacks require no code injection, and have already been shown to be powerful enough to bypass fine-grained memory randomization (ASLR) defenses. To counter this ingenious attack strategy, several proposals for enforcement of (coarse-grained) control-flow integrity (CFI) have emerged. The key argument put forth by these works is that coarse-grained CFI policies are sufficient to prevent ROP attacks. As this reasoning has gained traction, ideas put forth in these proposals have even been incorporated into coarse-grained CFI defenses in widely adopted tools (eg, Microsoft\u2019s EMET framework).", "num_citations": "394\n", "authors": ["337"]}
{"title": "Counterfeit object-oriented programming: On the difficulty of preventing code reuse attacks in C++ applications\n", "abstract": " Code reuse attacks such as return-oriented programming (ROP) have become prevalent techniques to exploit memory corruption vulnerabilities in software programs. A variety of corresponding defenses has been proposed, of which some have already been successfully bypassed -- and the arms race continues. In this paper, we perform a systematic assessment of recently proposed CFI solutions and other defenses against code reuse attacks in the context of C++. We demonstrate that many of these defenses that do not consider object-oriented C++ semantics precisely can be generically bypassed in practice. Our novel attack technique, denoted as counterfeit object-oriented programming (COOP), induces malicious program behavior by only invoking chains of existing C++ virtual functions in a program through corresponding existing call sites. COOP is Turing complete in realistic attack scenarios and we show\u00a0\u2026", "num_citations": "390\n", "authors": ["337"]}
{"title": "ROPdefender: A detection tool to defend against return-oriented programming attacks\n", "abstract": " Modern runtime attacks increasingly make use of the powerful return-oriented programming (ROP) attack techniques and principles such as recent attacks on Apple iPhone and Acrobat products to name some. These attacks even work under the presence of modern memory protection mechanisms such as data execution prevention (DEP). In this paper, we present our tool, ROPdefender, that dynamically detects conventional ROP attacks (that are based on return instructions). In contrast to existing solutions, ROPdefender can be immediately deployed by end-users, since it does not rely on side information (eg, source code or debugging information) which are rarely provided in practice. Currently, our tool adds a runtime overhead of 2x which is comparable to similar instrumentation-based tools.", "num_citations": "371\n", "authors": ["337"]}
{"title": "Xmandroid: A new android evolution to mitigate privilege escalation attacks\n", "abstract": " Google Android has become a popular mobile operating system which is increasingly deployed by mobile device manufactures for various platforms. Recent attacks show that Android\u2019s permission framework is vulnerable to applicationlevel privilege escalation attacks, ie, an application may indirectly gain privileges to perform unauthorized actions. The existing proposals for security extensions to Android\u2019s middleware (eg, Kirin, Saint, TaintDroid, or QUIRE) cannot fully and adequately mitigate these attacks or detect Trojans such as Soundcomber that exploit covert channels in the Android system. In this paper we present the design and implementation of XManDroid (eXtended Monitoring on Android), a security framework that extends the monitoring mechanism of Android to detect and prevent application-level privilege escalation attacks at runtime based on a systemcentric system policy. Our implementation dynamically analyzes applications\u2019 transitive permission usage while inducing a minimal performance overhead unnoticeable for the user. Depending on system policy our system representation allows for an effective detection of (covert) channels established through the Android system services and content providers while simultaneously optimizing the rate of false positives. We evaluate the effectiveness of XManDroid on our test suite that simulates known application-level privilege escalation attacks (including Soundcomber), and demonstrate successful detection of attacks that use Android\u2019s inter-component communication (ICC) framework (standard for most attacks). We also performed a usability test to evaluate the impact of\u00a0\u2026", "num_citations": "365\n", "authors": ["337"]}
{"title": "Practical and lightweight domain isolation on android\n", "abstract": " In this paper, we introduce a security framework for practical and lightweight domain isolation on Android to mitigate unauthorized data access and communication among applications of different trust levels (eg, private and corporate). We present the design and implementation of our framework, TrustDroid, which in contrast to existing solutions enables isolation at different layers of the Android software stack:(1) at the middleware layer to prevent inter-domain application communication and data access,(2) at the kernel layer to enforce mandatory access control on the file system and on Inter-Process Communication (IPC) channels, and (3) at the network layer to mediate network traffic. For instance,(3) allows network data to be only read by a particular domain, or enables basic context-based policies such as preventing Internet access by untrusted applications while an employee is connected to the company's\u00a0\u2026", "num_citations": "267\n", "authors": ["337"]}
{"title": "Readactor: Practical code randomization resilient to memory disclosure\n", "abstract": " Code-reuse attacks such as return-oriented programming (ROP) pose a severe threat to modern software. Designing practical and effective defenses against code-reuse attacks is highly challenging. One line of defense builds upon fine-grained code diversification to prevent the adversary from constructing a reliable code-reuse attack. However, all solutions proposed so far are either vulnerable to memory disclosure or are impractical for deployment on commodity systems. In this paper, we address the deficiencies of existing solutions and present the first practical, fine-grained code randomization defense, called Read actor, resilient to both static and dynamic ROP attacks. We distinguish between direct memory disclosure, where the attacker reads code pages, and indirect memory disclosure, where attackers use code pointers on data pages to infer the code layout without reading code pages. Unlike previous\u00a0\u2026", "num_citations": "265\n", "authors": ["337"]}
{"title": "The Cybersecurity Landscape in Industrial Control Systems\n", "abstract": " Industrial control systems (ICSs) are transitioning from legacy-electromechanical-based systems to modern information and communication technology (ICT)-based systems creating a close coupling between cyber and physical components. In this paper, we explore the ICS cybersecurity landscape including: 1) the key principles and unique aspects of ICS operation; 2) a brief history of cyberattacks on ICS; 3) an overview of ICS security assessment; 4) a survey of \u201cuniquely-ICS\u201d testbeds that capture the interactions between the various layers of an ICS; and 5) current trends in ICS attacks and defenses.", "num_citations": "243\n", "authors": ["337"]}
{"title": "MoCFI: A Framework to Mitigate Control-Flow Attacks on Smartphones.\n", "abstract": " Runtime and control-flow attacks (such as code injection or return-oriented programming) constitute one of the most severe threats to software programs. These attacks are prevalent and have been recently applied to smartphone applications as well, of which hundreds of thousands are downloaded by users every day. While a framework for control-flow integrity (CFI) enforcement, an approach to prohibit this kind of attacks, exists for the Intel x86 platform, there is no such a solution for smartphones. In this paper, we present a novel framework, MoCFI (Mobile CFI), that provides a general countermeasure against control-flow attacks on smartphone platforms by enforcing CFI. We show that CFI on typical smartphone platforms powered by an ARM processor is technically involved due to architectural differences between ARM and Intel x86, as well as the specifics of smartphone OSes. Our framework performs CFI on-the-fly during runtime without requiring the application\u2019s source code. For our reference implementation we chose Apple\u2019s iOS, because it has been an attractive target for control-flow attacks. Nevertheless, our framework is also applicable to other ARM-based devices such as Google\u2019s Android. Our performance evaluation demonstrates that MoCFI is efficient and does not induce notable overhead when applied to popular iOS applications.", "num_citations": "216\n", "authors": ["337"]}
{"title": "C-FLAT: control-flow attestation for embedded systems software\n", "abstract": " Remote attestation is a crucial security service particularly relevant to increasingly popular IoT (and other embedded) devices. It allows a trusted party (verifier) to learn the state of a remote, and potentially malware-infected, device (prover). Most existing approaches are static in nature and only check whether benign software is initially loaded on the prover. However, they are vulnerable to runtime attacks that hijack the application's control or data flow, eg, via return-oriented programming or data-oriented exploits. As a concrete step towards more comprehensive runtime remote attestation, we present the design and implementation of Control-FLow ATtestation (C-FLAT) that enables remote attestation of an application's control-flow path, without requiring the source code. We describe a full prototype implementation of C-FLAT on Raspberry Pi using its ARM TrustZone hardware security extensions. We evaluate C\u00a0\u2026", "num_citations": "206\n", "authors": ["337"]}
{"title": "Isomeron: Code randomization resilient to (just-in-time) return-oriented programming\n", "abstract": " Until recently, it was widely believed that code randomization (such as fine-grained ASLR) can effectively mitigate code reuse attacks. However, a recent attack strategy, dubbed just-in-time return oriented programming (JIT-ROP), circumvents code randomization by disclosing the (randomized) content of many memory pages at runtime. In order to remedy this situation, new and improved code randomization defenses have been proposed.The contribution of this paper is twofold: first, we conduct a security analysis of a recently proposed fine-grained ASLR scheme that aims at mitigating JIT-ROP based on hiding direct code references in branch instructions. In particular, we demonstrate its weaknesses by constructing a novel JIT-ROP attack that is solely based on exploiting code references residing on the stack and heap. Our attack stresses that designing code randomization schemes resilient to memory disclosure is highly challenging. Second, we present a new and hybrid defense approach, dubbed Isomeron, that combines code randomization with executionpath randomization to mitigate conventional ROP and JITROP attacks. Our reference implementation of Isomeron neither requires source code nor a static analysis phase. We evaluated its efficiency based on SPEC benchmarks and discuss its effectiveness against various kinds of code reuse attacks.", "num_citations": "205\n", "authors": ["337"]}
{"title": "Dynamic integrity measurement and attestation: towards defense against return-oriented programming attacks\n", "abstract": " Despite the many efforts made in recent years to mitigate runtime attacks such as stack and heap based buffer overflows, these attacks are still a common security concern in today's computing platforms. Attackers have even found new ways to enforce runtime attacks including use of a technique called return-oriented programming. Trusted Computing provides mechanisms to verify the integrity of all executable content in an operating system. But they only provide integrity at load-time and are not able to prevent or detect runtime attacks. To mitigate return-oriented programming attacks, we propose new runtime integrity monitoring techniques that use tracking instrumentation of program binaries based on taint analysis and dynamic tracing. We also describe how these techniques can be employed in a dynamic integrity measurement architecture (DynIMA). In this way we fill the gap between static load-time and\u00a0\u2026", "num_citations": "205\n", "authors": ["337"]}
{"title": "Losing control: On the effectiveness of control-flow integrity under stack attacks\n", "abstract": " Adversaries exploit memory corruption vulnerabilities to hijack a program's control flow and gain arbitrary code execution. One promising mitigation, control-flow integrity (CFI), has been the subject of extensive research in the past decade. One of the core findings is that adversaries can construct Turing-complete code-reuse attacks against coarse-grained CFI policies because they admit control flows that are not part of the original program. This insight led the research community to focus on fine-grained CFI implementations. In this paper we show how to exploit heap-based vulnerabilities to control the stack contents including security-critical values used to validate control-flow transfers. Our investigation shows that although program analysis and compiler-based mitigations reduce stack-based vulnerabilities, stack-based memory corruption remains an open problem. Using the Chromium web browser we\u00a0\u2026", "num_citations": "168\n", "authors": ["337"]}
{"title": "Hardware-assisted fine-grained control-flow integrity: Towards efficient protection of embedded systems against software exploitation\n", "abstract": " Embedded systems have become pervasive and are built into a vast number of devices such as sensors, vehicles, mobile and wearable devices. However, due to resource constraints, they fail to provide sufficient security, and are particularly vulnerable to runtime attacks (code injection and ROP). Previous works have proposed the enforcement of control-flow integrity (CFI) as a general defense against runtime attacks. However, existing solutions either suffer from performance overhead or only enforce coarse-grain CFI policies that a sophisticated adversary can undermine. In this paper, we tackle these limitations and present the design of novel security hardware mechanisms to enable fine-grained CFI checks. Our CFI proposal is based on a state model and a per-function CFI label approach. In particular, our CFI policies ensure that function returns can only transfer control to active call sides (i.e, return landing\u00a0\u2026", "num_citations": "142\n", "authors": ["337"]}
{"title": "It's a TRaP: Table Randomization and Protection against Function-Reuse Attacks\n", "abstract": " Code-reuse attacks continue to evolve and remain a severe threat to modern software. Recent research has proposed a variety of defenses with differing security, efficiency, and practicality characteristics. Whereas the majority of these solutions focus on specific code-reuse attack variants such as return-oriented programming (ROP), other attack variants that reuse whole functions, such as the classic return-into-libc, have received much less attention. Mitigating function-level code reuse is highly challenging because one needs to distinguish a legitimate call to a function from an illegitimate one. In fact, the recent counterfeit object-oriented programming (COOP) attack demonstrated that the majority of code-reuse defenses can be bypassed by reusing dynamically bound functions, ie, functions that are accessed through global offset tables and virtual function tables, respectively.", "num_citations": "141\n", "authors": ["337"]}
{"title": "Gadge me if you can: secure and efficient ad-hoc instruction-level randomization for x86 and ARM\n", "abstract": " Code reuse attacks such as return-oriented programming are one of the most powerful threats to contemporary software. ASLR was introduced to impede these attacks by dispersing shared libraries and the executable in memory. However, in practice its entropy is rather low and, more importantly, the leakage of a single address reveals the position of a whole library in memory. The recent mitigation literature followed the route of randomization, applied it at different stages such as source code or the executable binary. However, the code segments still stay in one block. In contrast to previous work, our randomization solution, called Xifer,(1) disperses all code (executable and libraries) across the whole address space,(2) re-randomizes the address space for each run,(3) is compatible to code signing, and (4) does neither require offline static analysis nor source-code. Our prototype implementation supports the Linux\u00a0\u2026", "num_citations": "119\n", "authors": ["337"]}
{"title": "Things, trouble, trust: on building trust in IoT systems\n", "abstract": " The emerging and much-touted Internet of Things (IoT) presents a variety of security and privacy challenges. Prominent among them is the establishment of trust in remote IoT devices, which is typically attained via remote attestation, a distinct security service that aims to ascertain the current state of a potentially compromised remote device. Remote attestation ranges from relatively heavy-weight secure hardware-based techniques, to light-weight software-based ones, and also includes approaches that blend software (e.g., control-flow integrity) and hardware features (e.g., PUFs). In this paper, we survey the landscape of state-of-the-art attestation techniques from the IoT device perspective and argue that most of them have a role to play in IoT trust establishment.", "num_citations": "117\n", "authors": ["337"]}
{"title": "Leakage-resilient layout randomization for mobile devices\n", "abstract": " Attack techniques based on code reuse continue to enable real-world exploits bypassing all current mitigations. Code randomization defenses greatly improve resilience against code reuse. Unfortunately, sophisticated modern attacks such as JITROP can circumvent randomization by discovering the actual code layout on the target and relocating the attack payload on the fly. Hence, effective code randomization additionally requires that the code layout cannot be leaked to adversaries.Previous approaches to leakage-resilient diversity have either relied on hardware features that are not available in all processors, particularly resource-limited processors commonly found in mobile devices, or they have had high memory overheads. We introduce a code randomization technique that avoids these limitations and scales down to mobile and embedded devices: Leakage-Resilient Layout Randomization (LR2).", "num_citations": "108\n", "authors": ["337"]}
{"title": "Sereum: Protecting Existing Smart Contracts Against Re-Entrancy Attacks\n", "abstract": " Recently, a number of existing blockchain systems have witnessed major bugs and vulnerabilities within smart contracts. Although the literature features a number of proposals for securing smart contracts, these proposals mostly focus on proving the correctness or absence of a certain type of vulnerability within a contract, but cannot protect deployed (legacy) contracts from being exploited. In this paper, we address this problem in the context of re-entrancy exploits and propose a novel smart contract security technology, dubbed Sereum (Secure Ethereum), which protects existing, deployed contracts against re-entrancy attacks in a backwards compatible way based on run-time monitoring and validation. Sereum does neither require any modification nor any semantic knowledge of existing contracts. By means of implementation and evaluation using the Ethereum blockchain, we show that Sereum covers the actual execution flow of a smart contract to accurately detect and prevent attacks with a false positive rate as small as 0.06% and with negligible run-time overhead. As a by-product, we develop three advanced re-entrancy attacks to demonstrate the limitations of existing offline vulnerability analysis tools.", "num_citations": "89\n", "authors": ["337"]}
{"title": "Lo-fat: Low-overhead control flow attestation in hardware\n", "abstract": " Attacks targeting software on embedded systems are becoming increasingly prevalent. Remote attestation is a mechanism that allows establishing trust in embedded devices. However, existing attestation schemes are either static and cannot detect control-flow attacks, or require instrumentation of software incurring high performance overheads. To overcome these limitations, we present LO-FAT, the first practical hardware-based approach to control-flow attestation. By leveraging existing processor hardware features and commonly-used IP blocks, our approach enables efficient control-flow attestation without requiring software instrumentation. We show that our proof-of-concept implementation based on a RISC-V SoC incurs no processor stalls and requires reasonable area overhead.", "num_citations": "77\n", "authors": ["337"]}
{"title": "The guard's dilemma: Efficient code-reuse attacks against intel sgx\n", "abstract": " Intel Software Guard Extensions (SGX) isolate security-critical code inside a protected memory area called enclave. Previous research on SGX has demonstrated that memory corruption vulnerabilities within enclave code can be exploited to extract secret keys and bypass remote attestation. However, these attacks require kernel privileges, and rely on frequently probing enclave code which results in many enclave crashes. Further, they assume a constant, not randomized memory layout. In this paper, we present novel exploitation techniques against SGX that do not require any enclave crashes and work in the presence of existing SGX randomization approaches such as SGX-Shield. A key contribution of our attacks is that they work under weak adversarial assumptions, eg, not requiring kernel privileges. In fact, they can be applied to any enclave that is developed with the standard Intel SGX SDK on either Linux or Windows.", "num_citations": "76\n", "authors": ["337"]}
{"title": "Return-oriented programming without returns on ARM\n", "abstract": " In this paper we present a novel and general memory-related attack method on ARM-based computing platforms. Our attack deploys the principles of return-oriented programming (ROP), however, in contrast to conventional ROP, it exploits jumps instead of returns, and hence it can not be detected by return address checkers. Although a similar attack has been recently proposed for Intel x86, it was unclear if the attack technique can be deployed to ARM-based computing platforms as well. Developing a jump-based attack on ARM is more involved, because ARM is based on a RSIC architecture which differs in many aspects from Intel\u2019s x86 architecture. Nevertheless, we show a Turing-complete attack that can induce arbitrary change of behavior in running programs without requiring code injection. As proof of concept, we instantiate our attack method on the Android platform.", "num_citations": "62\n", "authors": ["337"]}
{"title": "Address-Oblivious Code Reuse: On the Effectiveness of Leakage-Resilient Diversity\n", "abstract": " Memory corruption vulnerabilities not only allow modification of control data and injection of malicious payloads; they also allow adversaries to reconnoiter a diversified program, customize a payload, and ultimately bypass code randomization defenses. In response, researchers have proposed and built various leakage-resilient defenses against code reuse. Leakage-resilient defenses use memory protection techniques to prevent adversaries from directly reading code as well as pointer indirection or encryption techniques to decouple code pointers from the randomized code layout, avoiding indirect leakage. In this paper, we show that although current code pointer protections do prevent leakage per se, they are fundamentally unable to stop code reuse. Specifically, we demonstrate a new class of attacks we call address-oblivious code reuse that bypasses state-of-the-art leakage-resilience techniques by profiling and reusing protected code pointers, without leaking the code layout. We show that an attacker can accurately identify protected code pointers of interest and mount code-reuse attacks at the abstraction level of pointers without requiring any knowledge of code addresses. We analyze the prevalence of opportunities for such attacks in popular code bases and build three real-world exploits against Nginx and Apache to demonstrate their practicality. We analyze recently proposed leakage resilient defenses and show that they are vulnerable to address oblivious code reuse. Our findings indicate that because of the prevalence of code pointers in realistic programs and the fundamental need to expose them to \u201cread\u201d operations (even\u00a0\u2026", "num_citations": "58\n", "authors": ["337"]}
{"title": "Can\u2019t touch this: Software-only mitigation against rowhammer attacks targeting kernel memory\n", "abstract": " Rowhammer is a hardware bug that can be exploited to implement privilege escalation and remote code execution attacks. Previous proposals on rowhammer mitigations either require hardware changes or follow heuristic-based approaches (based on CPU performance counters). To date, there exists no instant protection against rowhammer attacks on legacy systems.", "num_citations": "57\n", "authors": ["337"]}
{"title": "PSiOS: bring your own privacy & security to iOS devices\n", "abstract": " Apple iOS is one of the most popular mobile operating systems. As its core security technology, iOS provides application sandboxing but assigns a generic sandboxing profile to every third-party application. However, recent attacks and incidents with benign applications demonstrate that this design decision is vulnerable to crucial privacy and security breaches, allowing applications (either benign or malicious) to access contacts, photos, and device IDs. Moreover, the dynamic character of iOS apps written in Objective-C renders the currently proposed static analysis tools less useful.", "num_citations": "56\n", "authors": ["337"]}
{"title": "PT-Rand: practical mitigation of data-only attacks against page tables\n", "abstract": " Kernel exploits constitute a powerful attack class allowing attackers to gain full control over a system. Various kernel hardening solutions have been proposed or deployed in practice to protect the kernel against code injection (eg, DEP) or code-reuse exploits (eg, CFI). However, the security of all these hardening techniques relies heavily on the assumption that kernel page tables cannot be manipulated, eg, by means of dataonly attacks. Ensuring kernel page tables integrity is not only essential for kernel security but also a challenging task in practice since existing solutions require hardware trust anchors, costly hypervisors, or inefficient integrity checks.In this paper, we first motivate the importance of protecting kernel page tables by presenting a data-only attack against page tables to bypass the recently released CFI-based (Linux) kernel hardening technique RAP. Thereafter, we present the design and implementation of PT-Rand, the first practical solution to protect kernel page tables that does not suffer from the mentioned deficiencies of previous proposals. PT-Rand randomizes the location of page tables and tackles a number of challenges to ensure that the location of page tables is not leaked. This effectively prevents the attacker from manipulating access permissions of code pages, thereby enabling secure enforcement of kernel exploit mitigation technologies such as CFI. We extensively evaluate our prototype implementation of PT-Rand for the current Linux kernel on the popular Linux distribution Debian and report a low overhead of 0.22% for common benchmarks. Moreover, we combine RAP with PT-Rand to protect RAP against data\u00a0\u2026", "num_citations": "47\n", "authors": ["337"]}
{"title": "CFI CaRE: Hardware-Supported Call and Return Enforcement for Commercial Microcontrollers\n", "abstract": " With the increasing scale of deployment of Internet of Things (IoT), concerns about IoT security have become more urgent. In particular, memory corruption attacks play a predominant role as they allow remote compromise of IoT devices. Control-flow integrity (CFI) is a promising and generic defense technique against these attacks. However, given the nature of IoT deployments, existing protection mechanisms for traditional computing environments (including CFI) need to be adapted to the IoT setting. In this paper, we describe the challenges of enabling CFI on microcontroller (MCU) based IoT devices. We then present CaRE, the first interrupt-aware CFI scheme for low-end MCUs. CaRE uses a novel way of protecting the CFI metadata by leveraging TrustZone-M security extensions introduced in the ARMv8-M architecture. Its binary instrumentation approach preserves the memory layout of the target MCU\u00a0\u2026", "num_citations": "38\n", "authors": ["337"]}
{"title": "K-miner: Uncovering memory corruption in linux\n", "abstract": " Operating system kernels are appealing attack targets: compromising the kernel usually allows attackers to bypass all deployed security mechanisms and take control over the entire system. Commodity kernels, like Linux, are written in low-level programming languages that offer only limited type and memory-safety guarantees, enabling adversaries to launch sophisticated run-time attacks against the kernel by exploiting memory-corruption vulnerabilities.Many defenses have been proposed to protect operating systems at run time, such as control-flow integrity (CFI). However, the goal of these run-time monitors is to prevent exploitation as a symptom of memory corruption, rather than eliminating the underlying root cause, ie, bugs in the kernel code. While finding bugs can be automated, eg, using static analysis, all existing approaches are limited to local, intra-procedural checks, and face severe scalability challenges due to the large kernel code base. Consequently, there currently exist no tools for conducting global static analysis of operating system kernels.", "num_citations": "37\n", "authors": ["337"]}
{"title": "Mobile Platform Security\n", "abstract": " Download Free Sample   Recently, mobile security has garnered considerable interest in both the research community and industry due to the popularity of smartphones. The current smartphone platforms are open systems that allow application development, also for malicious parties. To protect the mobile device, its user, and other mobile ecosystem stakeholders such as network operators, application execution is controlled by a platform security architecture. This book explores how such mobile platform security architectures work. We present a generic model for mobile platform security architectures: the model illustrates commonly used security mechanisms and techniques in mobile devices and allows a systematic comparison of different platforms. We analyze several mobile platforms using the model. In addition, this book explains hardware-security mechanisms typically present in a mobile device. We also\u00a0\u2026", "num_citations": "31\n", "authors": ["337"]}
{"title": "CAn't Touch This: Practical and Generic Software-only Defenses Against Rowhammer Attacks\n", "abstract": " Rowhammer is a hardware bug that can be exploited to implement privilege escalation and remote code execution attacks. Previous proposals on rowhammer mitigation either require hardware changes or follow heuristic-based approaches (based on CPU performance counters). To date, there exists no instant protection against rowhammer attacks on legacy systems. In this paper, we present the design and implementation of two practical and efficient software-only defenses against rowhammer attacks. Our defenses prevent the attacker from leveraging rowhammer to corrupt physically co-located data in memory that is owned by a different system entity. Our first defense, B-CATT, extends the system bootloader to disable vulnerable physical memory. B-CATT is highly practical, does not require changes to the operating system, and can be deployed on virtually all x86-based systems. While B-CATT is able to stop all known rowhammer attacks, it does not yet tackle the fundamental problem of missing memory isolation in physical memory. To address this problem, we introduce our second defense G-CATT, a generic solution that extends the physical memory allocator of the OS to physically isolate the memory of different system entities (e.g., kernel and user space). As proof of concept, we implemented B-CATT on x86, and our generic defense, G-CATT, on x86 and ARM to mitigate rowhammer-based kernel exploits. Our extensive evaluation shows that both mitigation schemes (i) can stop available real- world rowhammer attacks, (ii) impose virtually no run-time overhead for common user and kernel benchmarks as well as commonly used\u00a0\u2026", "num_citations": "29\n", "authors": ["337"]}
{"title": "Subversive-C: Abusing and Protecting Dynamic Message Dispatch\n", "abstract": " The lower layers in the modern computing infrastructure are written in languages threatened by exploitation of memory management errors. Recently deployed exploit mitigations such as control-flow integrity (CFI) can prevent traditional return-oriented programming (ROP) exploits but are much less effective against newer techniques such as Counterfeit Object-Oriented Programming (COOP) that execute a chain of C++ virtual methods. Since these methods are valid control-flow targets, COOP attacks are hard to distinguish from benign computations. Code randomization is likewise ineffective against COOP. Until now, however, COOP attacks have been limited to vulnerable C++ applications which makes it unclear whether COOP is as general and portable a threat as ROP.", "num_citations": "25\n", "authors": ["337"]}
{"title": "Check My Profile: Leveraging Static Analysis for Fast and Accurate Detection of ROP Gadgets\n", "abstract": " Return-oriented programming (ROP) offers a powerful technique for undermining state-of-the-art security mechanisms, including non-executable memory and address space layout randomization. To mitigate this daunting attack strategy, several in-built defensive mechanisms have been proposed. In this work, we instead focus on detection techniques that do not require any modification to end-user platforms. Specifically, we propose a novel framework that efficiently analyzes documents (PDF, Office, or HTML files) and detects whether they contain a returnoriented programming payload. To do so, we provide advanced techniques for taking memory snapshots of a target application, efficiently transferring the snapshots to a host system, as well as novel static analysis and filtering techniques to identify and profile chains of code pointers referencing ROP gadgets (that may even reside in randomized libraries\u00a0\u2026", "num_citations": "24\n", "authors": ["337"]}
{"title": "Control behavior integrity for distributed cyber-physical systems\n", "abstract": " Cyber-physical control systems, such as industrial control systems (ICS), are increasingly targeted by cyberattacks. Such attacks can potentially cause tremendous damage, affect critical infrastructure or even jeopardize human life when the system does not behave as intended. Cyberattacks, however, are not new and decades of security research have developed plenty of solutions to thwart them. Unfortunately, many of these solutions cannot be easily applied to safety-critical cyber-physical systems. Further, the attack surface of ICS is quite different from what can be commonly assumed in classical IT systems. We present Scadman, a novel control-logic aware anomaly detection system for distributed cyber-physical systems. By observing the system-wide behavior, the correctness of individual controllers (like programmable logic controllers-PLCs) in ICS can be verified. This allows Scadman to detect a wide range\u00a0\u2026", "num_citations": "22\n", "authors": ["337"]}
{"title": "XiOS: Extended Application Sandboxing on iOS\n", "abstract": " Until very recently it was widely believed that iOS malware is effectively blocked by Apple's vetting process and application sandboxing. However, the newly presented severe malicious app attacks (eg, Jekyll) succeeded to undermine these protection measures and steal private data, post Twitter messages, send SMS, and make phone calls. Currently, no effective defenses against these attacks are known for iOS.", "num_citations": "18\n", "authors": ["337"]}
{"title": "Trusted virtual domains on OKL4: Secure information sharing on smartphones\n", "abstract": " The flexibility and computing power of modern smartphones to install and execute various applications allows for a rich user experience but also imposes several security concerns. Smartphones that are used both for private and corporate purposes do not separate the data and applications of different security domains, and users are usually too unskilled to deploy and configure extra security mechanisms. Hence, data leakage and unwanted information flow may occur.", "num_citations": "18\n", "authors": ["337"]}
{"title": "TeeRex: Discovery and Exploitation of Memory Corruption Vulnerabilities in {SGX} Enclaves\n", "abstract": " Intel's Software Guard Extensions (SGX) introduced new instructions to switch the processor to enclave mode which protects it from introspection. While the enclave mode strongly protects the memory and the state of the processor, it cannot withstand memory corruption errors inside the enclave code. In this paper, we show that the attack surface of SGX enclaves provides new challenges for enclave developers as exploitable memory corruption vulnerabilities are easily introduced into enclave code. We develop TeeRex to automatically analyze enclave binary code for vulnerabilities introduced at the host-to-enclave boundary by means of symbolic execution. Our evaluation on public enclave binaries reveal that many of them suffer from memory corruption errors allowing an attacker to corrupt function pointers or perform arbitrary memory writes. As we will show, TeeRex features a specifically tailored framework for SGX enclaves that allows simple proof-of-concept exploit construction to assess the discovered vulnerabilities. Our findings reveal vulnerabilities in multiple enclaves, including enclaves developed by Intel, Baidu, and WolfSSL, as well as biometric fingerprint software deployed on popular laptop brands.", "num_citations": "17\n", "authors": ["337"]}
{"title": "SandScout: Automatic Detection of Flaws in iOS Sandbox Profiles\n", "abstract": " Recent literature on iOS security has focused on the malicious potential of third-party applications, demonstrating how developers can bypass application vetting and code-level protections. In addition to these protections, iOS uses a generic sandbox profile called\" container\" to confine malicious or exploited third-party applications. In this paper, we present the first systematic analysis of the iOS container sandbox profile. We propose the SandScout framework to extract, decompile, formally model, and analyze iOS sandbox profiles as logic-based programs. We use our Prolog-based queries to evaluate file-based security properties of the container sandbox profile for iOS 9.0. 2 and discover seven classes of exploitable vulnerabilities. These attacks affect non-jailbroken devices running later versions of iOS. We are working with Apple to resolve these attacks, and we expect that SandScout will play a significant role in\u00a0\u2026", "num_citations": "17\n", "authors": ["337"]}
{"title": "Code-Reuse Attacks and Defenses\n", "abstract": " Laufzeitangriffe nutzen Speicher-und Programmierfehler aus, um beliebiges Schadverhalten auf einem Computersystem zu verursachen. Obwohl diese Angriffe seit \u00fcber zwei Jahrzehnten bekannt sind, stellen sie immer noch eine gro\u00dfe Bedrohung f\u00fcr moderne Software-Programme dar. Dabei benutzen heutige Angriffe eine ausgekl\u00fcgelte Technik, die sich Return-Oriented Programming (ROP) nennt. Im Gegensatz zu klassischen Laufzeitangriffen, die auf das Einschleusen von Schadcode in den Speicher eines Programmes angewiesen waren, k\u00f6nnen ROP Angriffe allein \u00fcber das Zusammensetzen von vorhandenen gutartigen Code Schadverhalten erzeugen. Weil hierbei kein neuer Schadcode explizit eingeschleust wird, umgehen ROP Angriffe weit verbreitete Abwehrmechanismen wie beispielsweise Ausf\u00fchrungsschutz f\u00fcr den Arbeitsspeicher. Insbesondere k\u00f6nnen ROP Angriffe in Kombination mit sogenannten Speicherlecks\u2013in der englischen Fachliteratur h\u00e4ufig als Memory Disclosure bezeichnet\u2013dazu verwendet werden, um Adress Randomisierung zu umgehen. Um effektiv gegen diese neuartigen Laufzeitangriffe vorzugehen, wurden in den letzten Jahre eine Vielzahl an Abwehrmethoden vorgeschlagen, die meistens entweder auf Kontrollfluss-Integrit\u00e4t oder auf fortgeschrittenen Speicheradressen Randomisierungstechniken basieren. In dieser Dissertation erforschen wir die Grenzen und Einschr\u00e4nkungen von existierenden Schutzmechanismen gegen ROP Angriffe und demonstrieren praktische Angriffe gegen k\u00fcrzlich pr\u00e4sentierte Kontrollfluss-Integrit\u00e4tsl\u00f6sungen sowie Speicheradressen Randomisierungstechniken, die nicht\u00a0\u2026", "num_citations": "17\n", "authors": ["337"]}
{"title": "XIFER: a software diversity tool against code-reuse attacks\n", "abstract": " The enormous growth of mobile devices and their app markets has raised many security and privacy concerns. Runtime attacks seem to be a major threat, in particular, codereuse attacks that do not require any external code injection (eg, return-to-libc or return-oriented programming). We present, for the first time, a code transformation tool that completely mitigates code-reuse attacks by applying software diversity to the binary at runtime. Our tool XIFER (1) randomly diversifies the code of an application over the entire memory for each invocation,(2) requires no source code or any static analysis,(3) can be applied to both Intel x86 and ARM Linux executables, and (4) induces a negligible runtime overhead of only 1% in average.", "num_citations": "15\n", "authors": ["337"]}
{"title": "Poster: the quest for security against privilege escalation attacks on android\n", "abstract": " In this paper we present the design and implementation of a security framework that extends the reference monitor of the Android middleware and deploys a mandatory access control on Linux kernel (based on Tomoyo [9]) aiming at detecting and preventing application-level privilege escalation attacks at runtime. In contrast to existing solutions, our framework is system-centric, efficient, detects attacks that involve communication channels controlled by both, Android middleware and the Linux kernel (particularly, Binder IPC, Internet sockets and file system). It can prevent known confused deputy attacks without false positives and is also flexible enough to prevent unknown confused deputy attacks and attacks by colluding applications (eg, Soundcomber [11]) at the cost of a small rate of false positives.", "num_citations": "14\n", "authors": ["337"]}
{"title": "Securing Legacy Software against Real-World Code-Reuse Exploits: Utopia, Alchemy, or Possible Future?\n", "abstract": " Exploitation of memory-corruption vulnerabilities in widely-used software has been a threat for over two decades and no end seems to be in sight. Since performance and backwards compatibility trump security concerns, popular programs such as web browsers, servers, and office suites still contain large amounts of untrusted legacy code written in error-prone languages such as C and C++. At the same time, modern exploits are evolving quickly and routinely incorporate sophisticated techniques such as code reuse and memory disclosure. As a result, they bypass all widely deployed countermeasures including data execution prevention (DEP) and code randomization such as address space layout randomization (ASLR).", "num_citations": "13\n", "authors": ["337"]}
{"title": "Advances and throwbacks in hardware-assisted security: special session\n", "abstract": " Hardware security architectures and primitives are becoming increasingly important in practice providing trust anchors and trusted execution environment to protect modern software systems. Over the past two decades we have witnessed various hardware security solutions and trends from Trusted Platform Modules (TPM), performance counters for security, ARM's TrustZone, and Physically Unclonable Functions (PUFs), to very recent advances such as Intel's Software Guard Extension (SGX). Unfortunately, these solutions are rarely used by third party developers, make strong trust assumptions (including in manufacturers), are too expensive for small constrained devices, do not easily scale, or suffer from information leakage. Academic research has proposed a variety of solutions, in hardware security architectures, these advancements are rarely deployed in practice.", "num_citations": "12\n", "authors": ["337"]}
{"title": "Automated software diversity\n", "abstract": " Whereas user-facing applications are often written in modern languages, the firmware, operating system, support libraries, and virtual machines that underpin just about any modern computer system are still written in low-level languages that value flexibility and performance over convenience and safety. Programming errors in low-level code are often exploitable and can, in the worst case, give adversaries unfettered access to the compromised host system.  This book provides an introduction to and overview of automatic software diversity techniques that, in one way or another, use randomization to greatly increase the difficulty of exploiting the vast amounts of low-level code in existence. Diversity-based defenses are motivated by the observation that a single attack will fail against multiple targets with unique attack surfaces. We introduce the many, often complementary, ways that one can diversify attack surfaces\u00a0\u2026", "num_citations": "11\n", "authors": ["337"]}
{"title": "Special Session: Advances and Throwbacks in Hardware-Assisted Security\n", "abstract": " Hardware security architectures and primitives are becoming increasingly important in practice providing trust anchors and trusted execution environment to protect modern software systems. Over the past two decades we have witnessed various hardware security solutions and trends from Trusted Platform Modules (TPM), performance counters for security, ARM's TrustZone, and Physically Unclonable Functions (PUFs), to very recent advances such as Intel's Software Guard Extension (SGX). Unfortunately, these solutions are rarely used by third party developers, make strong trust assumptions (including in manufacturers), are too expensive for small constrained devices, do not easily scale, or suffer from information leakage. Academic research has proposed a variety of solutions, in hardware security architectures, these advancements are rarely deployed in practice.", "num_citations": "9\n", "authors": ["337"]}
{"title": "Scalable trust establishment with software reputation\n", "abstract": " Users and administrators are often faced with the choice between different software solutions, sometimes even have to assess the security of complete software systems. With sufficient time and resources, such decisions can be based on extensive testing and review. However, in practice this is often too expensive and time consuming.", "num_citations": "9\n", "authors": ["337"]}
{"title": "Breaking and Fixing Destructive Code Read Defenses\n", "abstract": " Just-in-time return-oriented programming (JIT-ROP) is a powerful memory corruption attack that bypasses various forms of code randomization. Execute-only memory (XOM) can potentially prevent these attacks, but requires source code. In contrast, destructive code reads (DCR) provide a trade-off between security and legacy compatibility. The common belief is that DCR provides strong protection if combined with a high-entropy code randomization.", "num_citations": "8\n", "authors": ["337"]}
{"title": "Building Secure Defenses Against Code-Reuse Attacks\n", "abstract": " Computing platforms have become an integral part of our society over the last few decades. The landscape of computing platforms is highly diverse: starting from desktop PCs and laptops for end-users, powerful workstations used to perform highly complex calculations (eg, weather calculations), web servers that need to simultaneously handle thousands of incoming requests, smartphones and tablets enabling on-the-road data access, up to tiny embedded devices deployed in sensors, cars, electronic passports, and medical devices. The inter-connectivity of these devices, ie, the Internet of Everything [15], as well as the sensitive operations and everyday tasks we perform on these devices have made computing platforms an appealing target for various attacks. In particular, the fact that devices are connected with each other and to the Internet has facilitated remote attacks, where the attacker does not require any\u00a0\u2026", "num_citations": "8\n", "authors": ["337"]}
{"title": "Method and system for securing smart contracts in blockchains\n", "abstract": " A method for securing smart contracts in a blockchain includes receiving in the blockchain a contract creation transaction having a control flow graph (CFG) and contract code for a smart contract to be created. The contract creation transaction is verified by checking a signature of a creator of the smart contract and determining that the CFG is correct based on the contract code. The verified contract creation transaction is included as a block in a distributed ledger of the blockchain.", "num_citations": "7\n", "authors": ["337"]}
{"title": "Over-the-Air Cross-platform Infection for Breaking mTAN-based Online Banking Authentication\n", "abstract": " We present a novel stealthy cross-platform infection attack in WiFi networks. Our attack has high impact on two-factor authentication schemes that make use of mobile phones. In particular, we apply our attack to break mTAN authentication, one of the most used scheme for online banking worldwide (Europe, US, China). We present the design and implementation of the online banking Trojan which spreads over the WiFi network from the user's PC to her mobile phone and automatically pairs these devices. When paired, the host and the mobile malware deliver to the attacker authentication secrets which allow her to successfully authenticate against the online-banking portal and perform financial transactions in the name of the user. Our attack is stealthy compared to the known banking Trojans ZeuS/ZitMo and SpyEye/Spitmo, as it does not rely on phishing or na\u00efve user behavior for malware spreading and pairing.Our reference implementation targets Windows PCs and Android based smartphones, although our attack is not platform specific. To achieve cross-platform infection, we applied and adapted attack techniques such as remote code execution, privilege escalation, GOT overwriting, DLL injection and function hooking. Our attack can be implemented by knowledgeable attackers and calls for re-thinking of security measures deployed for protection of online transactions by banks.", "num_citations": "6\n", "authors": ["337"]}
{"title": "Poster: control-flow integrity for smartphones\n", "abstract": " Despite extensive research over the last two decades, runtime attacks on software are still prevalent. Recently, smartphones, of which millions are in use today, have become an attractive target for adversaries. However, existing solutions are either ad-hoc or limited in their effectiveness. In this poster, we present a general countermeasure against runtime attacks on smartphone platforms. Our approach makes use of control-flow integrity (CFI), and tackles unique challenges of the ARM architecture and smartphone platforms. Our framework and implementation is efficient, since it requires no access to source code, performs CFI enforcement on-the-fly during runtime, and is compatible to memory randomization and code signing/encryption. We chose Apple iPhone for our reference implementation, because it has become an attractive target for runtime attacks. Our performance evaluation on a real iOS device\u00a0\u2026", "num_citations": "6\n", "authors": ["337"]}
{"title": "Combining Safety and Security in Autonomous Cars Using Blockchain Technologies\n", "abstract": " Modern cars increasingly deploy complex software systems consisting of millions of lines of code that may be subject to cyber attacks. An infamous example is the Jeep hack which allowed an attacker to remotely control the car engine by just exploiting a software bug in the infotainment system. The digitalization and connectivity of modern cars demands a rethinking of car safety as security breaches now affect the driver\u2019s safety. To address the new threat landscape, we develop a novel concept that simultaneously addresses both car safety and security based on the arising blockchain technology, which we mainly exploit to ensure integrity. Previous related work exploited the blockchain for the purpose of forensics, where vehicle data is stored on an externally shared ledger that is accessible by authorized third parties. However, those approaches cannot ensure integrity of information used by the vehicle\u2019s\u00a0\u2026", "num_citations": "5\n", "authors": ["337"]}
{"title": "SandBlaster: Reversing the Apple Sandbox\n", "abstract": " In order to limit the damage of malware on Mac OS X and iOS, Apple uses sandboxing, a kernel-level security layer that provides tight constraints for system calls. Particularly used for Apple iOS, sandboxing prevents apps from executing potentially dangerous actions, by defining rules in a sandbox profile. Investigating Apple's built-in sandbox profiles is difficult as they are compiled and stored in binary format. We present SandBlaster, a software bundle that is able to reverse/decompile Apple binary sandbox profiles to their original human readable SBPL (SandBox Profile Language) format. We use SandBlaster to reverse all built-in Apple iOS binary sandbox profiles for iOS 7, 8 and 9. Our tool is, to the best of our knowledge, the first to provide a full reversing of the Apple sandbox, shedding light into the inner workings of Apple sandbox profiles and providing essential support for security researchers and professionals interested in Apple security mechanisms.", "num_citations": "5\n", "authors": ["337"]}
{"title": "EVMPatch: Timely and Automated Patching of Ethereum Smart Contracts\n", "abstract": " Recent attacks exploiting errors in smart contract code had devastating consequences thereby questioning the benefits of this technology. It is currently highly challenging to fix errors and deploy a patched contract in time. Instant patching is especially important since smart contracts are always online due to the distributed nature of blockchain systems. They also manage considerable amounts of assets, which are at risk and often beyond recovery after an attack. Existing solutions to upgrade smart contracts depend on manual and error-prone processes. This paper presents a framework, called EVMPatch, to instantly and automatically patch faulty smart contracts. EVMPatch features a bytecode rewriting engine for the popular Ethereum blockchain, and transparently/automatically rewrites common off-the-shelf contracts to upgradable contracts. The proof-of-concept implementation of EVMPatch automatically hardens smart contracts that are vulnerable to integer over/underflows and access control errors, but can be easily extended to cover more bug classes. Our evaluation on 14,000 real-world contracts demonstrates that our approach successfully blocks attack transactions launched on contracts, while keeping the intended functionality of the contract intact. We perform a study with experienced software developers, showing that EVMPatch is practical, and reduces the time for converting a given Solidity smart contract to an upgradable contract by 97.6%, while ensuring functional equivalence to the original contract.", "num_citations": "4\n", "authors": ["337"]}
{"title": "The Industrial Control Systems Cyber Security Landscape\n", "abstract": " Industrial Control Systems (ICS) are transitioning from legacy electromechanical based systems to modern information and communication technology (ICT) based systems creating a close coupling between cyber and physical systems. In this paper, we explore the ICS security landscape including:(1) the key principles and unique aspects of ICS operation,(2) a brief history of cyber attacks on ICS,(3) an overview of ICS security assessment,(4) a survey of \u201cuniquely-ICS\u201d testbeds that capture the interactions between the various layers of an ICS and (5) current trends in ICS attacks and defenses.", "num_citations": "3\n", "authors": ["337"]}
{"title": "Building Control-Flow Integrity Defenses\n", "abstract": " In particular, Abadi et\u00a0al.\u00a0[2, 4] suggest a label-based CFI approach, where each CFG node is marked with a unique label\u00a0ID that is placed at the beginning of a BBL. In order to preserve the program\u2019s original semantics, the label is either encoded as an offset into a x86 cache prefetch instruction or as simple data word. Inserting labels into a program binary will require moving instructions from their original position. As a consequence, CFI requires adjusting all memory offsets embedded into jump/call and data load/store instructions that are affected by the insertion of the additional prefetch instructions.", "num_citations": "3\n", "authors": ["337"]}
{"title": "HERA: Hotpatching of Embedded Real-time Applications\n", "abstract": " Memory corruption attacks are a pre-dominant attack vector against IoT devices. Simply updating vulnerable IoT software is not always possible due to unacceptable downtime and a required reboot. These side-effects must be avoided for highly-available embedded systems such as medical devices and, generally speaking, for any embedded system with real-time constraints. To avoid downtime and reboot of a system, previous research has introduced the concept of hotpatching. However, the existing approaches cannot be applied to resource-constrained IoT devices. Furthermore, possible hardware-related issues have not been addressed, ie, the inability to directly modify the firmware image due to read-only memory.In this paper, we present the design and implementation of HERA (Hotpatching of Embedded Real-time Applications) which utilizes hardware-based built-in features of commodity Cortex-M microcontrollers to perform hotpatching of embedded systems. HERA preserves hard real-time constraints while keeping the additional resource usage to a minimum. In a case study, we apply HERA to two vulnerable medical devices. Furthermore, we leverage HERA to patch an existing vulnerability in the FreeRTOS operating system. These applications demonstrate the high practicality and efficiency of our approach.", "num_citations": "2\n", "authors": ["337"]}
{"title": "ClepsydraCache--Preventing Cache Attacks with Time-Based Evictions\n", "abstract": " Both the shift towards attacks on the microarchitectural CPU level and the ongoing transition towards cloud computing and shared VM hosts have increasingly drawn attention towards cache attacks. In these fields of application, cache side-channels lay the cornerstone that is leveraged by attackers to exfiltrate secret information from the CPU microarchitecture. We build upon the observation that current cache side-channel attacks mostly exploit the architectural visibility of conflicting cache addresses. With ClepsydraCache, we break away this foundation by unraveling the linkage between cache evictions and accesses to conflicting addresses. Our solution takes a new approach that assigns each cache entry a random time-to-live to reduce the amount of cache conflicts. By making those conflicts unobservable to an attacker, ClepsydraCache efficiently protects against attacks like Prime+Probe and Flush+Reload. Furthermore, our solution is applicable to large last-level caches which are the most common targets for cache attacks. We implement ClepsydraCache using the Gem5 simulator and provide a proof-of-concept hardware design and simulation using 65-nm CMOS technology. ClepsydraCache matches the performance of traditional cache architectures while improving the system security against cache attacks.", "num_citations": "1\n", "authors": ["337"]}
{"title": "Nano Security: From Nano-Electronics to Secure Systems\n", "abstract": " The field of computer hardware stands at the verge of a revolution driven by recent breakthroughs in emerging nanodevices. \u201cNano Security\u201d is a new Priority Program recently approved by DFG, the German Research Council. This initial-stage project initiative at the crossroads of nano-electronics and hardware-oriented security includes 11 projects with a total of 23 Principal Investigators from 18 German institutions. It considers the interplay between security and nano-electronics, focusing on a dichotomy which emerging nano-devices (and their architectural implications) have on system security. The projects within the Priority Program consider both: potential security threats and vulnerabilities stemming from novel nano-electronics, and innovative approaches to establishing and improving system security based on nano-electronics. This paper provides an overview of the Priority Program's overall philosophy and\u00a0\u2026", "num_citations": "1\n", "authors": ["337"]}
{"title": "CHASE: A Configurable Hardware-Assisted Security Extension for Real-Time Systems\n", "abstract": " Real-time autonomous systems are becoming pervasive in many application domains such as vehicular ad-hoc networks, smart factories and delivery drones. The correct functioning of these real-time systems is timing-critical with hard deadlines. However, although they interact with other systems and exchange inputs/outputs with the physical world, they usually lack security mechanisms, which makes them susceptible to a wide range of attacks with critical consequences. Typically, this is because security mechanisms usually violate the real-time requirements of these systems and cannot be adjusted at runtime to provide the adequate security without compromising performance. In this paper, we propose a consolidated runtime-configurable hardware-assisted security extension called CHASE that supports different levels of security at runtime. Depending on the desired security level and the system real-time\u00a0\u2026", "num_citations": "1\n", "authors": ["337"]}
{"title": "Towards a Policy-Agnostic Control-Flow Integrity Implementation\n", "abstract": " Towards a Policy-Agnostic Control-Flow Integrity Implementation - TUbiblio TUbiblio TU Darmstadt / ULB / TUbiblio Towards a Policy-Agnostic Control-Flow Integrity Implementation Sullivan, Dean ; Arias, Orlando ; Davi, Lucas ; Sadeghi, Ahmad-Reza ; Jin, Yier (2016): Towards a Policy-Agnostic Control-Flow Integrity Implementation. In: Black Hat Europe, [Konferenzver\u00f6ffentlichung] Typ des Eintrags: Konferenzver\u00f6ffentlichung Erschienen: 2016 Autor(en): Sullivan, Dean ; Arias, Orlando ; Davi, Lucas ; Sadeghi, Ahmad-Reza ; Jin, Yier Titel: Towards a Policy-Agnostic Control-Flow Integrity Implementation Sprache: Deutsch Buchtitel: Black Hat Europe Freie Schlagworte: Solutions; S2;ICRI-SC;STC Secure and Trustworthy Systems;Secure Things Fachbereich(e)/-gebiet(e): 20 Fachbereich Informatik 20 Fachbereich Informatik > Systemsicherheit DFG-Sonderforschungsbereiche (inkl. Transregio) DFG-(inkl. Transregio) (-\u2026", "num_citations": "1\n", "authors": ["337"]}