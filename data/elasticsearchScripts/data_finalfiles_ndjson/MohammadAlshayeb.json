{"title": "Software defect prediction using ensemble learning on selected features\n", "abstract": " ContextSeveral issues hinder software defect data including redundancy, correlation, feature irrelevance and missing samples. It is also hard to ensure balanced distribution between data pertaining to defective and non-defective software. In most experimental cases, data related to the latter software class is dominantly present in the dataset.ObjectiveThe objectives of this paper are to demonstrate the positive effects of combining feature selection and ensemble learning on the performance of defect classification. Along with efficient feature selection, a new two-variant (with and without feature selection) ensemble learning algorithm is proposed to provide robustness to both data imbalance and feature redundancy.MethodWe carefully combine selected ensemble learning models with efficient feature selection to address these issues and mitigate their effects on the defect classification performance.ResultsForward\u00a0\u2026", "num_citations": "283\n", "authors": ["793"]}
{"title": "An empirical validation of object-oriented metrics in two different iterative software processes\n", "abstract": " Object-oriented (OO) metrics are used mainly to predict software engineering activities/efforts such as maintenance effort, error proneness, and error rate. There have been discussions about the effectiveness of metrics in different contexts. In this paper, we present an empirical study of OO metrics in two iterative processes: the short-cycled agile process and the long-cycled framework evolution process. We find that OO metrics are effective in predicting design efforts and source lines of code added, changed, and deleted in the short-cycled agile process and ineffective in predicting the same aspects in the long-cycled framework process. This leads us to believe that OO metrics' predictive capability is limited to the design and implementation changes during the development iterations, not the long-term evolution of an established system in different releases.", "num_citations": "184\n", "authors": ["793"]}
{"title": "Empirical investigation of refactoring effect on software quality\n", "abstract": " Developers and designers always strive for quality software. Quality software tends to be robust, reliable and easy to maintain, and thus reduces the cost of software development and maintenance. Several methods have been applied to improve software quality. Refactoring is one of those methods. The goal of this paper is to validate/invalidate the claims that refactoring improves software quality. We focused this study on different external quality attributes, which are adaptability, maintainability, understandability, reusability, and testability. We found that refactoring does not necessarily improve these quality attributes.", "num_citations": "171\n", "authors": ["793"]}
{"title": "KHATT: An open Arabic offline handwritten text database\n", "abstract": " A comprehensive Arabic handwritten text database is an essential resource for Arabic handwritten text recognition research. This is especially true due to the lack of such database for Arabic handwritten text. In this paper, we report our comprehensive Arabic offline Handwritten Text database (KHATT) consisting of 1000 handwritten forms written by 1000 distinct writers from different countries. The forms were scanned at 200, 300, and 600 dpi resolutions. The database contains 2000 randomly selected paragraphs from 46 sources, 2000 minimal text paragraph covering all the shapes of Arabic characters, and optionally written paragraphs on open subjects. The 2000 random text paragraphs consist of 9327 lines. The database forms were randomly divided into 70%, 15%, and 15% sets for training, testing, and verification, respectively. This enables researchers to use the database and compare their results. A formal\u00a0\u2026", "num_citations": "121\n", "authors": ["793"]}
{"title": "Toward successful project management in global software development\n", "abstract": " Project management in the context of global software development (GSD) is challenging due to a number of issues. This paper has a two-fold objective: (1) to identify the factors from the literature related to the successful project management in GSD and to validate the identified factors in the real-world practice; (2) to map the identified factors to 10 project management knowledge areas of PMBOK. Our results show a positive correlation between the ranks obtained from the literature and the survey. The results of t-test (i.e., t\u00a0=\u00a01.979, p\u00a0=\u00a00.061\u00a0>\u00a00.05) show that there is no significant difference between the findings of the literature and survey. Our mapping shows that most of the success factors are related to human resource knowledge area. It is anticipated that the identified success factors can be helpful to practitioners for developing strategic implementation of project management activities in GSD environment.", "num_citations": "98\n", "authors": ["793"]}
{"title": "An empirical study of system design instability metric and design evolution in an agile software process\n", "abstract": " Software project tracking and project plan adjustment are two important software engineering activities. The class growth shows the design evolution of the software. The System Design Instability (SDI) metric indicates the progress of an object-oriented (OO) project once the project is set in motion. The SDI metric provides information on project evolution to project managers for possible adjustment to the project plan. The objectives of this paper are to test if the System Design Instability metric can be used to estimate and re-plan software projects in an XP-like agile process and study system design evolution in the Agile software process. We present an empirical study of the class growth and the SDI metric in two OO systems, developed using an agile process similar to Extreme Programming (XP). We analyzed the system evolutionary data collected on a daily basis from the two systems. We concluded that: the\u00a0\u2026", "num_citations": "89\n", "authors": ["793"]}
{"title": "Exploring software security approaches in software development lifecycle: A systematic mapping study\n", "abstract": " There is an increase use of security driven approaches to support software development activities, such as requirements, design and implementation. The objective of this paper is to identify the existing software security approaches used in the software development lifecycle (SDLC). In order to meet our goal, we conducted a systematic mapping study to identify the primary studies on the use of software security techniques in SDLC. In total, we selected and categorized 118 primary studies. After analyzing the selected studies, we identified 52 security approaches and we categorized them in to five main categories, namely, \u2018secure requirements modeling\u2019, \u2018vulnerability identification, adaption and mitigation\u2019, \u2018software security focused process\u2019, \u2018extended UML-based secure modeling profiles\u2019, \u2018non UML-based secure modeling notations\u2019. The results show that the most frequently used approaches are static analysis\u00a0\u2026", "num_citations": "87\n", "authors": ["793"]}
{"title": "UML model refactoring: a systematic literature review\n", "abstract": " Model-driven engineering, an emerging trend in software engineering, has enabled the use of refactoring to UML models. Numerous approaches to model refactoring, problem detection, consistency management, and tool support to automate and verify refactoring are discussed and distributed across numerous research literatures. This paper provides a systematic overview of existing research in the field of model refactoring. A total of 3,295 articles, related to the field of UML model refactoring, were extracted from well-known electronic databases. A multi-stage selection process was used to ensure proper inclusion of relevant studies for review and analysis. Ninety-four primary studies were eventually selected and analyzed based on a number of different criteria: UML models considered for refactoring, formalisms used to support refactoring at the model level, important to consider when building\u00a0\u2026", "num_citations": "84\n", "authors": ["793"]}
{"title": "Khatt: Arabic offline handwritten text database\n", "abstract": " In this paper, we report our comprehensive Arabic offline Handwritten Text database (KHATT) after completion of the collection of 1000 handwritten forms written by 1000 writers from different countries. It is composed of an image database containing images of the written text at 200, 300, and 600 dpi resolutions, a manually verified ground truth database that contains meta-data describing the written text at the page, paragraph, and line levels. A formal verification procedure is implemented to align the handwritten text with its ground truth at the form, paragraph and line levels. Tools to extract paragraphs from pages and segment paragraphs into lines are developed. Preliminary experiments on Arabic handwritten text recognition are conducted using sample data from the database and the results are reported. The database will be made freely available to researchers world-wide for research in various handwritten\u00a0\u2026", "num_citations": "82\n", "authors": ["793"]}
{"title": "Cyber security threats and vulnerabilities: a systematic mapping study\n", "abstract": " There has been a tremendous increase in research in the area of cyber security to support cyber applications and to avoid key security threats faced by these applications. The goal of this study is to identify and analyze the common cyber security vulnerabilities. To achieve this goal, a systematic mapping study was conducted, and in total, 78 primary studies were identified and analyzed. After a detailed analysis of the selected studies, we identified the important security vulnerabilities and their frequency of occurrence. Data were also synthesized and analyzed to present the venue of publication, country of publication, key targeted infrastructures and applications. The results show that the security approaches mentioned so far only target security in general, and the solutions provided in these studies need more empirical validation and real implementation. In addition, our results show that most of the selected\u00a0\u2026", "num_citations": "72\n", "authors": ["793"]}
{"title": "Empirical investigation of the challenges of the existing tools used in global software development projects\n", "abstract": " Global software development (GSD) is continuously increasing because of many factors such as high quality software production in offshore destinations with significant cost-savings. Objective - The objective of this study is to identify the challenges of the existing tools used in GSD projects. Method - The authors applied the systematic literature review (SLR) approach and a survey-based empirical study approach to address the research objective. Results - From both data sets, the authors identified eight challenges of the existing tools used in GSD projects. The top-ranked challenges in the SLR are the `inappropriate use of synchronous and asynchronous communication tools' and `difficulties in adopting and learning to use the existing tools'. The top-ranked challenges in the questionnaire-based empirical study are the `lack of awareness of existing tools used in GSD projects' and the `lack of support for\u00a0\u2026", "num_citations": "49\n", "authors": ["793"]}
{"title": "Challenges of project management in global software development: initial results\n", "abstract": " Over the last decade, many firms in the world have started adopting Global Software Development (GSD) in order to reduce software development cost. GSD helps companies to leverage the benefits of multi-site development with respect to time, cost and access to skillful resource. Recent research suggests that half of the companies that have tried global software development have failed to realize the anticipated outcomes. One of the major issues is that many clients endorse global contracts with their vendors prior to testing their project management readiness for the global activity. The objective of this research is to identify challenges associated with project management in GSD. We have performed a Systematic Literature Review (SLR) by applying customized search strings derived from our research question. We have identified challenges such as lack of cultural understanding in teams, lack of communication\u00a0\u2026", "num_citations": "48\n", "authors": ["793"]}
{"title": "Software refactoring at the package level using clustering techniques\n", "abstract": " Enhancing, modifying or adapting the software to new requirements increases the internal software complexity. Software with high level of internal complexity is difficult to maintain. Software refactoring reduces software complexity and hence decreases the maintenance effort. However, software refactoring becomes quite challenging task as the software evolves. The authors use clustering as a pattern recognition technique to assist in software refactoring activities at the package level. The approach presents a computer aided support for identifying ill-structured packages and provides suggestions for software designer to balance between intra-package cohesion and inter-package coupling. A comparative study is conducted applying three different clustering techniques on different software systems. In addition, the application of refactoring at the package level using an adaptive  k -nearest neighbour (A-KNN\u00a0\u2026", "num_citations": "45\n", "authors": ["793"]}
{"title": "A classification of refactoring methods based on software quality attributes\n", "abstract": " Refactoring is the process of improving the design of existing code by changing its internal structure without affecting its external behavior. Refactoring tends to improve software quality by improving design, improving readability and reducing \u2018bugs\u2019. There are many different refactoring methods, each having a particular purpose and effect. Consequently, the effect of refactoring methods on software quality attributes may vary. Moreover, it is often unclear to software designers how to use refactoring methods to improve specific quality attributes. In this paper, we propose a classification of refactoring methods based on their measurable effect on software quality attributes. This, in turn, helps software designers choose appropriate refactoring methods that will improve the quality of their designs, based on the design objectives. It also enables them to predict the quality drift caused by using particular refactoring\u00a0\u2026", "num_citations": "43\n", "authors": ["793"]}
{"title": "Software refactoring at the function level using new Adaptive K-Nearest Neighbor algorithm\n", "abstract": " Improving the quality of software is a vital target of software engineering. Constantly evolving requirements force software developers to enhance, modify, or adapt software. Thus, increasing internal complexity, maintenance effort, and ultimately cost. In trying to balance between the needs to change software, maintain high quality, and keep the maintenance effort and cost low, refactoring comes up as a solution. Refactoring aims to improve a number of quality factors, among which is understandability. Enhancing understandability of ill-structured software decreases the maintenance effort and cost. To improve understandability, designers need to maximize cohesion and minimize coupling, which becomes more difficult to achieve as software evolves and internal complexity increases. In this paper, we propose a new Adaptive K-Nearest Neighbor (A-KNN) algorithm to perform clustering with different attribute weights\u00a0\u2026", "num_citations": "41\n", "authors": ["793"]}
{"title": "Towards implementation of requirements management specific practices (SP1. 3 and SP1. 4) for Saudi Arabian small and medium sized software development organizations\n", "abstract": " There is a significant need to give careful consideration to Capability Maturity Model Integration (CMMI) Level 2 specific practices-SP 1.3 \u201cmanage requirements changes,\u201dand SP 1.4 \u201cmaintain bidirectional traceability of requirements,\u201despecially in the context of smalland medium-sized software development organizations in Saudi Arabia, in order to assist such organizations in getting one step closer to achieving CMMI Level 2 certification. The objective of this research is to implement CMMI Level 2 specific practices-SP 1.3 and SP 1.4. In this paper, a workflow model for each specific practice has been developed. In addition, initial evaluation of the models has been discussed. It is necessary to highlight that this paper contributes not only to the implementation of SP 1.3 and SP 1.4 of Requirements management process area in the context of smalland medium-sized software development organizations but also to\u00a0\u2026", "num_citations": "37\n", "authors": ["793"]}
{"title": "An empirical study to improve software security through the application of code refactoring\n", "abstract": " ContextCode bad smells indicate design flaws that can degrade the quality of software and can potentially lead to the introduction of faults. They can be eradicated by applying refactoring techniques. Code bad smells that impact the security perspective of software should be detected and removed from their code base. However, the existing literature is insufficient to support this claim and there are few studies that empirically investigate bad smells and refactoring opportunities from a security perspective.ObjectiveIn this paper, we investigate how refactoring can improve the security of an application by removing code bad smell.MethodWe analyzed three different code bad smells in five software systems. First, the identified code bad smells are filtered against security attributes. Next, the object-oriented design and security metrics are calculated for the five investigated systems. Later, refactoring is applied to remove\u00a0\u2026", "num_citations": "33\n", "authors": ["793"]}
{"title": "Extending the UML use case metamodel with behavioral information to facilitate model analysis and interchange\n", "abstract": " Use case diagrams are primary artifacts used for modeling functional requirements. Use case diagrams are part of the Unified Modeling Language (UML) suite of models that has become a de facto standard for modeling object oriented languages. Each model in this suite is described by a metamodel that dictates its syntax and semantics. The use case diagram is considered the most controversial diagram in UML. Practitioners claim that the use case diagram cannot be used as a valuable artifact for requirement analysis. The main reason behind this concern is the lack of behavioral description of a use case depicted within the model. Quite a few extensions to the use case metamodel have been proposed in literature to incorporate behavioral aspect of a use case within the metamodel. All these extensions omit a few important features like generalization and most of them can only be used for model\u00a0\u2026", "num_citations": "27\n", "authors": ["793"]}
{"title": "Using Software Quality Attributes to Classify Refactoring to Patterns.\n", "abstract": " Refactoring to patterns allows software designers to safely move their designs towards specific design patterns by applying multiple low-level refactorings. There are many different refactoring to pattern techniques, each with a particular purpose and a varying effect on software quality attributes. Thus far, software designers do not have a clear means to choose refactoring to pattern techniques to improve certain quality attributes. This paper takes the first step towards a classification of refactoring to pattern techniques based on their measurable effect on software quality attributes. This classification helps software designers in selecting the appropriate refactoring to pattern techniques that will improve the quality of their design based on their design objectives. It also enables them to predict the quality drift caused by using specific refactoring to pattern techniques.", "num_citations": "27\n", "authors": ["793"]}
{"title": "Automatic software refactoring: a systematic literature review\n", "abstract": " Refactoring a software artifact is an embedded task in the maintenance phase of the software life cycle. To reduce the time and effort required for this task, researchers proposed methods to automate the software refactoring process at the design and code levels. In this paper, we conducted a systematic literature review of papers that suggest, propose, or implement an automated refactoring process. Using different phases, setting several quality measures, and snowballing, only 41 papers passed to the last stage to be analyzed and reviewed. We observe an increase in the number of papers that propose automatic refactoring. The results show that while most of the papers discuss code refactoring, only a few recent papers are focused on model refactoring. Search-based refactoring is gaining more popularity, and several researchers have used it to perform refactoring in a quick and efficient manner.", "num_citations": "25\n", "authors": ["793"]}
{"title": "The impact of refactoring to patterns on software quality attributes\n", "abstract": " The search for techniques to improve software quality and achieve robust, reliable, and maintainable software is ongoing. Refactoring, an approach that improves the internal structure of software without affecting its external behavior, is one method that aims to achieve better quality. Refactoring to patterns is another. The goal of this paper is to investigate whether refactoring to patterns improves software quality. This is done empirically by examining the metric values of external quality attributes for different software systems before and after refactoring to patterns is applied. We found no consistent improvement trends in the software quality attributes. This is because each refactoring to patterns technique has a particular purpose and effect, and hence affects software quality attributes differently.", "num_citations": "25\n", "authors": ["793"]}
{"title": "EVE: On-board process planning and execution\n", "abstract": " According to NASA\u2019s Earth Science Vision, on-board processing will play a significant role in the next generation of Earth Science missions, providing the opportunity for greater flexibility and versatility in measurements of the Earth\u2019s systems. Such on-board processing can contribute to many Earth Science research applications, including natural hazard detection and prediction, intelligent sensor control, and the generation of customized data products for direct distribution to users. Ideally, the availability of custom processing, feature extraction, and data mining on-board satellites can allow end users to specify their own data products through the definition of a processing plan. On-board processing will reduce the volume of delivered data since only the data", "num_citations": "22\n", "authors": ["793"]}
{"title": "Investigating the effect of refactoring on software testing effort\n", "abstract": " Refactoring, the process of improving the design of existing code by changing its internal structure without affecting its external behavior, tends to improve software quality by improving design, improving readability, and reducing bugs. There are many different refactoring methods, each having a particular purpose and effect. Consequently, the effect of refactorings on software quality attribute may vary. Software testing is an external software quality attributes that takes lots of time and effort to make sure that the software performs as intended. In this paper, we propose a classification of refactoring methods based on their measurable effect on software testing effort. This, in turn, helps the software developers decide which refactoring methods to apply in order to optimize a software system with regard to the testing effort.", "num_citations": "21\n", "authors": ["793"]}
{"title": "Extreme learning machine as maintainability prediction model for object-oriented software systems\n", "abstract": " As the number of object-oriented software systems increases, it becomes more important for organizations to maintain those systems effectively. However, currently only a small number of maintainability prediction models are available for object oriented systems. In this paper, we develop an extreme learning machine (ELM) maintainability prediction model for objectoriented software systems. The model is based on extreme learning machine algorithm for single-hidden layer feed-forward neural networks (SLFNs) which randomly chooses hidden nodes and analytically determines the output weights of SLFNs. The model is constructed using popular object-oriented metric datasets, collected from different object-oriented systems. Prediction accuracy of the model is evaluated and compared with commonly used regression-based models and also with Bayesian network based model which was earlier developed\u00a0\u2026", "num_citations": "20\n", "authors": ["793"]}
{"title": "Survey on software design-pattern specification languages\n", "abstract": " A design pattern is a well-defined solution to a recurrent problem. Over the years, the number of patterns and domains of design patterns have expanded, as the patterns are the experiences of the experts of the domain captured in a higher-level abstraction. This led others to work on languages for design patterns to systematically document abstraction detailed in the design pattern rather than capture algorithms and data. These design-pattern specification languages come in different flavors, targeting different aspects of design patterns. Some design-pattern specification languages tried to capture the description of the design pattern in graphical or textual format, others tried to discover design patterns in code or design diagrams, and still other design-pattern specification languages have other objectives. However, so far, no effort has been made to compare these design-pattern specification languages and\u00a0\u2026", "num_citations": "19\n", "authors": ["793"]}
{"title": "UML model integration and refactoring method\n", "abstract": " The UML model integration and refactoring method steps include extending the metamodels, composing an integrated UML model derived from the extended metamodels, defining refactoring opportunities and transformation operations during the integrated UML composition, and applying a set of composite refactorings to remove an identified smell from the integrated UML model.", "num_citations": "19\n", "authors": ["793"]}
{"title": "An empirical study of relationships among extreme programming engineering activities\n", "abstract": " Extreme programming (XP) is an agile software process that promotes early and quick production of working code. In this paper, we investigated the relationship among three XP engineering activities: new design, refactoring, and error fix. We found that the more the new design performed to the system the less refactoring and error fix were performed. However, the refactoring and error fix efforts did not seem to be related. We also found that the error fix effort is related to number of days spent on each story, while new design is not. The relationship between the refactoring effort and number of days spent on each story was not conclusive.", "num_citations": "18\n", "authors": ["793"]}
{"title": "A readiness model for security requirements engineering\n", "abstract": " The focus on secure software development has been growing steadily in all phases of the software development life cycle. Security awareness in the requirements engineering stage of software development is important in building secure software. One of the major issues faced by the software industry is that many organizations undertake secure software development initiatives without knowing whether they are ready to undertake them. Currently, there is no model to measure the readiness of security requirements engineering in an organization. The objective of this paper is to develop a security requirements engineering readiness model (SRERM) to enable organizations to assess their security requirements engineering (SRE) readiness levels. In order to achieve this goal, a systematic mapping study was conducted to identify the relevant studies in the SRE domain. A total of 104 primary studies were identified\u00a0\u2026", "num_citations": "17\n", "authors": ["793"]}
{"title": "Software refactoring at the class level using clustering techniques\n", "abstract": " Software becomes more and more complex as it adapts new requirements, is enhanced or is modified. Thus, the quality of the software decreases. Therefore, there is a need to reduce the software's complexity and improve its quality. Refactoring reduces software complexity and improves quality by restructuring the code into a more readable form that improves its internal structure without changing its external functionality. However, it is a challenging task and requires effort from the software designer. In this paper, we propose a method for identifying ill-structured software at the class level that provides heuristic refactoring advice to software designers in order to create balance between coupling and cohesion using pattern recognition techniques. To identify the illstructured code we use three clustering techniques, namely, the Single Linkage algorithm (SLINK), the Complete Linkage algorithm (CLINK) and the\u00a0\u2026", "num_citations": "17\n", "authors": ["793"]}
{"title": "Refactoring effect on cohesion metrics\n", "abstract": " Developers and designers always strive for quality software. Quality software tends to be robust, reliable and easy to maintain, and thus reduces the cost of software development and maintenance. Class cohesion is an important internal quality attribute. Several methods have been applied to improve software quality; refactoring is one of those methods. The goal of this paper is to investigate whether refactoring improves software quality, by improving class cohesion. This is done by examining different cohesion metrics values after refactoring is applied. We found that in general refactoring indeed improves class cohesion values.", "num_citations": "17\n", "authors": ["793"]}
{"title": "Earth science markup language\n", "abstract": " ESML greatly simplifies a scientist\u2019s job by removing the overhead for handling heterogeneous data formats, enabling them to use virtually any data format in their analysis tools. Since ESML description files are external to the data files, they can be easily created, modified, and viewed using any text editor. Scientists can view an ESML description file as a set of instructions to the analysis tool on how to read and understand a data file (a machine-readable README file). Furthermore, if the structure of the data format changes for any reason (eg, a new version of the dataset) no software modifications are required; rather, a new ESML description file is created for the modified dataset. ESML also provides several advantages to data archiving centers by allowing the flexibility to store data in their native formats, rather than converting them to some standard format. The archive center need not provide an ESML description file for every data file, but instead can write a single ESML description file for all data files belonging to the same data class, where a data class defines a set of data files that are structurally and semantically similar. This feature provides an inexpensive solution for dealing with legacy datasets. Data centers can easily create ESML description files for all of their legacy datasets with minimal effort in terms of time and labor. The existing legacy datasets then become a more valuable data resource for scientists, because they can be easily used more efficiently and effectively. The ESML library is written in C++ for Windows and LINUX operating systems. The ESML library application programming interface (API) has been designed to be\u00a0\u2026", "num_citations": "17\n", "authors": ["793"]}
{"title": "Bad smell detection using machine learning techniques: a systematic literature review\n", "abstract": " Code smells are indicators of potential problems in software. They tend to have a negative impact on software quality. Several studies use machine learning techniques to detect bad smells. The objective of this study is to systematically review and analyze machine learning techniques used to detect code smells to provide interested research community with knowledge about the adopted techniques and practices for code smells detection. We use a systematic literature review approach to review studies that use machine learning techniques to detect code smells. Seventeen primary studies were identified. We found that 27 code smells were used in the identified studies; God Class and Long Method, Feature Envy, and Data Class are the most frequently detected code smells. In addition, we found that 16 machine learning algorithms were employed to detect code smells with acceptable prediction accuracy\u00a0\u2026", "num_citations": "16\n", "authors": ["793"]}
{"title": "Object-oriented class stability prediction: a comparison between artificial neural network and support vector machine\n", "abstract": " Software stability is an important factor for better software quality. Stable classes tend to reduce the software maintenance cost and effort. Therefore, achieving class stability is an important quality objective when developing software. Designers can make better decisions to improve class stability if they can predict it before the fact using some predictors. In this paper, we investigate the correlation between some available design measurements and class stability over versions and propose a stability prediction model using such available measurements. We conducted a set of experiments using artificial neural network (ANN) and support vector machine (SVM) to build different prediction models. We compared the accuracy of these prediction models. Our experiments reveal that ANN and SVM prediction models are effective in predicting object-oriented class stability.", "num_citations": "15\n", "authors": ["793"]}
{"title": "Towards design pattern definition language\n", "abstract": " Design patterns are rapidly gaining acceptance in the software community not only as reusable constructs for software development but also for the documentation of the software architectural design. Most of the existing design pattern languages describe design patterns using a combination of a natural language, UML\u2010style diagrams and complex mathematical or logic based formalisms, which makes them hard for programmers to understand. In this paper we propose a design pattern definition language (DPDL) based on XML which can be used for sharing design patterns\u2019 implementation details among developers. DPDL is easy to understand and use. It provides unambiguous description of the patterns and is extensible. DPDL also has the flexibility of defining design patterns in a generic term to be used as templates. Copyright \u00a9 2011 John Wiley & Sons, Ltd.", "num_citations": "15\n", "authors": ["793"]}
{"title": "An empirical study on the effect of the order of applying software refactoring\n", "abstract": " Refactoring has been widely used to improve software design. Refactoring is applied when a bad smell is detected. Several bad smells might be present in the code. In this paper, we conduct an empirical study to find if the order of applying refactoring has any impact on the quality of the final code. We run six experiments by applying three refactoring methods in different orders and evaluate the quality of the code using software metrics at the end of each refactoring sequence. Our experiments results show that that applying refactoring in different order provides different impact on the final code.", "num_citations": "14\n", "authors": ["793"]}
{"title": "A database for offline Arabic handwritten text recognition\n", "abstract": " Arabic handwritten text recognition has not received the same attention as that directed towards Latin script-based languages. In this paper, we present our efforts to develop a comprehensive Arabic Handwritten Text database (AHTD). At this stage, the database will consist of text written by 1000 writers from different countries. Currently, it has data from over 300 writers. It is composed of an images database containing images of the written text at various resolutions, and a ground truth database that contains meta-data describing the written text at the page, paragraph, and line levels. Tools to extract paragraphs from pages, segment paragraphs into lines have also been developed. Segmentation of lines into words will follow. The database will be made freely available to researchers world-wide. It is hoped that the AHTD database will stir research efforts in various handwritten-related problems such as text\u00a0\u2026", "num_citations": "14\n", "authors": ["793"]}
{"title": "Earth Science Markup Language: a solution for generic access to heterogeneous data sets\n", "abstract": " The Earth Science community is processing and analyzing a large amount and variety of data. These data are generally stored in different data formats, which forces the scientists to spend a significant amount of time in writing specialized, data format specific readers. However, this preprocessing burden can by alleviated by using the Earth Science Markup Language (ESML). ESML is a specialized markup language for Earth Science metadata. Based on the eXtensible Markup Language (XMLTM), ESML allows data descriptions to be written in a standard fashion.", "num_citations": "14\n", "authors": ["793"]}
{"title": "A metrics suite for UML model stability\n", "abstract": " Software metrics have become an essential part of software development because of their importance in estimating cost, effort, and time during the development phase. Many metrics have been proposed to assess different software quality attributes, including stability. A number of software stability metrics have been proposed at the class, architecture, and system levels. However, these metrics typically target the source code. This paper proposes a software stability metrics suite at the model level for three UML diagrams: class, use case, and sequence. These three diagrams represent the most common diagrams in the three UML views: structural, functional, and behavioral. We introduce a client\u2013master assessment approach to avoid measurement duplication. We also theoretically and empirically validate the proposed metrics suite. We also provide examples to demonstrate the use of the proposed metrics\u00a0\u2026", "num_citations": "13\n", "authors": ["793"]}
{"title": "A survey on UML model smells detection techniques for software refactoring\n", "abstract": " Bad smells tend to have a negative impact on software by degrading its quality. It is beneficial to detect model smells to avoid their propagation to later stages of software development. The objective of this paper is to present the state\u2010of\u2010the\u2010art research on techniques for detecting UML model bad smells. The detection techniques are compared and evaluated using a proposed evaluation framework. The framework consists of two parts. The first part of the framework compares the techniques in terms of the implemented approach, the investigated model, and the explored model smells, while the experimental design is explored in the second part of the framework. We found that the detection of bad smells in class and sequence diagrams is accomplished via design patterns, software metrics, and predefined rules, while model smells in use cases are detected using metrics and predefined rules. We also found that\u00a0\u2026", "num_citations": "12\n", "authors": ["793"]}
{"title": "Effect of coupling on software faults: An empirical study\n", "abstract": " Software product's quality is one of the important aspects that affect the user, the developer, and the product. Measuring quality in the early phases of the project life cycle is a major goal of project planning. Accordingly, several research studies have been proposed to measure the software product quality attributes. In this paper, we empirically study the impact of afferent coupling (Ca), efferent coupling (Ce) and coupling between object (CBO) metrics on fault prediction using bivariate correlation. We built a prediction model using these metrics to predict faults by using multivariate logistic linear regression. A case study of an open source object oriented systems is used to evaluate the correlation between coupling metrics and faults. The results indicate that the efferent coupling (Ce) is a better indicator for fault prediction than afferent coupling (Ca) and CBO (coupling between object).", "num_citations": "12\n", "authors": ["793"]}
{"title": "Hybrid intelligent model for software maintenance prediction\n", "abstract": " Maintenance is an important activity in the software life cycle. No software product can do without undergoing the process of maintenance. Estimating a software\u2019s maintainability effort and cost is not an easy task considering the various factors that influence the proposed measurement. Hence, Artificial Intelligence (AI) techniques have been used extensively to find optimized and more accurate maintenance estimations. In this paper, we propose an Evolutionary Neural Network (NN) model to predict software maintainability. The proposed model is based on a hybrid intelligent technique wherein a neural network is trained for prediction and a genetic algorithm (GA) implementation is used for evolving the neural network topology until an optimal topology is reached. The model was applied on a popular open source program, namely, Android. The results are very promising, where the correlation between actual and predicted points reaches 0.91", "num_citations": "11\n", "authors": ["793"]}
{"title": "The impact of refactoring on class and architecture stability\n", "abstract": " Refactoring is used to improve the internal structure of the code without affecting its external behaviour. This is done by restructuring the components of the software, i.e. changing the internal structure within classes or changing the structure between classes. However, this may have an impact on class and architecture stability. In this paper we assess the impact of refactoring on class and architecture stability and then propose a classification for refactoring methods based on the impact of refactoring on class and architecture stability.", "num_citations": "11\n", "authors": ["793"]}
{"title": "Extending the UML metamodel for sequence diagram to enhance model traceability\n", "abstract": " Specification of object-oriented systems by UML models has become an eminent practice among software practitioners. UML Sequence diagrams are used to model the dynamic behavior of the software system depicting how objects interact by passing messages. The UML Metamodel, which is contained in the UML Specification Version 2, has undergone a significant change with respect to sequence diagrams. Complex logic that allows message exchange between objects in a non-sequential manner was made possible through the use of combined fragments. The UML metamodel is used by design tools to verify the correctness of the constructed models. Ensuring well-formedness of these models still remains a challenging task mainly due to unavailability of a formal description for some rules listed in the UML specification. In this paper, we propose an extension to the UML metamodel that eliminates some well\u00a0\u2026", "num_citations": "11\n", "authors": ["793"]}
{"title": "Towards implementation of process and product quality assurance process area for Saudi Arabian small and medium sized software development organizations\n", "abstract": " There is a significant need to give more careful consideration to the process and product quality assurance (PPQA) process area of the capability maturity model integration (CMMI) Level 2, especially in the context of smalland medium-sized software development organizations, to help such organizations achieve CMMI Level 2. The objective of this paper is to report the implementation of the PPQA process area for smalland medium-sized software development organizations in Saudi Arabia. An abstract-level model for each specific practice of the PPQA process area has been developed. In addition, an initial evaluation of the proposed models has been discussed. Data have been collected by exploring published research articles and high-level software process descriptions. Moreover, previous research works that dealt with the implementation of CMMI Level 2 process areas have been reviewed. Furthermore\u00a0\u2026", "num_citations": "10\n", "authors": ["793"]}
{"title": "On the relationship of class stability and maintainability\n", "abstract": " Maintainability is an essential software quality attribute as software maintenance is a costly process. ISO 9126 characterised maintainability with five sub-characteristics, one of which is stability. Unstable software may lead to high maintenance cost and effort. Classes in object-oriented systems form the basic elements of the software architecture; hence, stable classes may contribute to reducing the software maintenance cost and effort. In this study, the author conducts an empirical study to evaluate the relationship between class stability and maintainability. The author correlates class stability with maintainability effort measured by the number of hours spent on maintenance activities and by the line of code changes. Results show that classes with higher values of stability measured by the class stability metric (CSM) are associated with a lower value of perfective maintenance effort measured by hours. CSM also\u00a0\u2026", "num_citations": "10\n", "authors": ["793"]}
{"title": "An empirical study of refactoring, new design, and error-fix efforts in extreme programming\n", "abstract": " Extreme Programming (XP) was introduced as a new process model, which has three main activities in each XP iteration cycle: new design, error-fix, and refactoring. In an empirical study on two Java systems developed using an XP-like process, we found that new design seems to dominate the development effort throughout all iteration cycles. We also found that the evolutionary trends of all three activities agree with exceptions.", "num_citations": "8\n", "authors": ["793"]}
{"title": "Software smell detection techniques: A systematic literature review\n", "abstract": " Software smells indicate design or code issues that might degrade the evolution and maintenance of software systems. Detecting and identifying these issues are challenging tasks. This paper explores, identifies, and analyzes the existing software smell detection techniques at design and code levels. We carried out a systematic literature review (SLR) to identify and collect 145 primary studies related to smell detection in software design and code. Based on these studies, we address several questions related to the analysis of the existing smell detection techniques in terms of abstraction level (design or code), targeted smells, used metrics, implementation, and validation. Our analysis identified several detection techniques categories. We observed that 57% of the studies did not use any performance measures, 41% of them omitted details on the targeted programing language, and the detection techniques were\u00a0\u2026", "num_citations": "6\n", "authors": ["793"]}
{"title": "A maturity model for secure requirements engineering\n", "abstract": " Security is considered to be a critical software quality attribute. Tackling security at the requirements phase helps to avoid the need to rework secure software development issues. The aim of this paper is to develop a Requirements Engineering (RE) Security Maturity Model (RESMM) to assist software development organizations to better specify the requirements for secure software development. To achieve this objective, first, we conducted a systematic literature review (SLR) to identify the requirement practices for secure software development. Then we modified Sommerville's requirements engineering practices. We also conducted a questionnaire survey based on the identified security requirements practices. Next, the RESMM was built based on the results of the SLR, the modified Sommerville practices and feedback from the security practitioners. Finally, two case studies were conducted to assess RESMM\u00a0\u2026", "num_citations": "6\n", "authors": ["793"]}
{"title": "Measurement of Actor External Dependencies in GRL Models.\n", "abstract": " Goal models represent interests, intentions, and strategies of different stakeholders in early requirements engineering. When capturing requirements of socio-technical systems, goal models evolve quickly to become large and complex. Hence, understanding and maintaining such goal models become more challenging. Software engineering metric-based approaches have shown good potential in measuring software designs. In this paper, we propose a structural metric to measure actor external dependencies in GRL (Goal-oriented Requirement Language) models. We illustrate our approach by applying our metric to a goal model describing undergraduate students\u2019 involvement in research activities.", "num_citations": "6\n", "authors": ["793"]}
{"title": "A framework for evaluating software design pattern specification languages\n", "abstract": " Software design patterns are solutions to recurring problems. These solutions have been widely accepted and adopted by the software practitioners. Design Patterns were initially described informally through the use of textual descriptions or some object oriented graphical notations. However, informal descriptions of design patterns give rise to ambiguity and incorrect usage of the design pattern. Many design pattern specification languages have been proposed to address the shortcomings of informal descriptions. These design pattern formalization techniques have been developed for different intentions including verification of design patterns and detection of design patterns in source code. In this paper we provide a set of evaluation criteria to evaluate and compare the various design pattern specification languages in order to aid practitioners and researchers to select the appropriate language for their use.", "num_citations": "6\n", "authors": ["793"]}
{"title": "Reuse environments for software artifacts: Analysis framework\n", "abstract": " Systematic software reuse facilitates achieving quality software, faster and at a lower cost. Software reuse environments play an important role in exploiting reusable artifacts to the extent. Environments that support reusing early-stage software artifacts are of great interest. There have been a number of reuse environments proposed in the literature for reuse of software artifacts. However, there is no framework to allow analyzing (i.e. classifying and comparing) reuse environments. The significance of such a framework is twofold: (1) to be used by reuse practitioners to select appropriate environment; and (2) to be used by researchers to identify gaps for future research. In this paper, we present an attribute-based framework to provide such aid to practitioners and researchers. The paper also presents an indicative survey of current reuse environments proposed for systematic reuse of software artifacts. We use the\u00a0\u2026", "num_citations": "6\n", "authors": ["793"]}
{"title": "Improving the security of UML sequence diagram using genetic algorithm\n", "abstract": " A sequence diagram is a modeling approach for visualizing the behavioral execution of a system. The objective of this research is to investigate the problem of security in a behavioral model (sequence diagram) through the application of model refactoring. We propose detection and correction techniques, empirical evaluation of the proposed techniques and assessment of security improvement in sequence diagrams. The detection of security bad smells is achieved through the adaptation of a genetic algorithm, while correction is accomplished by the model transformation approach. The results show significant detection recall and correction efficacy of the proposed detection and correction approaches, respectively. Our results show that the proposed approach is effective in detecting and correcting bad smells and can improve the security of UML Sequence Diagram.", "num_citations": "5\n", "authors": ["793"]}
{"title": "Threshold extraction framework for software metrics\n", "abstract": " Software metrics are used to measure different attributes of software. To practically measure software attributes using these metrics, metric thresholds are needed. Many researchers attempted to identify these thresholds based on personal experiences. However, the resulted experience-based thresholds cannot be generalized due to the variability in personal experiences and the subjectivity of opinions. The goal of this paper is to propose an automated clustering framework based on the expectation maximization (EM) algorithm where clusters are generated using a simplified 3-metric set (LOC, LCOM, and CBO). Given these clusters, different threshold levels for software metrics are systematically determined such that each threshold reflects a specific level of software quality. The proposed framework comprises two major steps: the clustering step where the software quality historical dataset is\u00a0\u2026", "num_citations": "5\n", "authors": ["793"]}
{"title": "An integrated metamodel-based approach to software model refactoring\n", "abstract": " Software refactoring is the process of changing a software system in a manner that does not alter its external behavior and yet improving its internal structure. Model-driven architecture and the popularity of the UML enabled the application of refactoring at model level, which was earlier applied to software code. In this paper, we propose a multi-view integrated approach to model-driven refactoring using UML models. We selected a single model from each UML view at metamodel level to construct an integrated metamodel. We selected class diagram to represent the structural view, sequence diagram to represent the behavioral view and use case diagram to represent the functional view. We validated the proposed approach by comparing integrated refactoring approach with refactoring applied to models individually in terms of quality improvement through UML model metrics. Our results indicate that more\u00a0\u2026", "num_citations": "5\n", "authors": ["793"]}
{"title": "Method, apparatus, and non-transitory computer readable media for the assessment of software products\n", "abstract": " A method, apparatus, and non-transitory computer-readable storage medium to objectively assess the quality of software products. The method, apparatus, and non-transitory computer-readable storage medium relate to determining a product maturity level of one or more software products. The disclosure describes a method for acquiring product quality attributes of a software product. Each product quality attribute is assessed by one or more metric parameters which test the software product by mathematical or logical test methodologies. Once evaluated, the one or more metric parameters and the one or more product quality attributes may each be mapped to a capability level based on a capability scale. A maturity level may be mapped from the capability level of the capability level of the one or more product quality attributes to the software product to provide a quality assessment of the software product.", "num_citations": "5\n", "authors": ["793"]}
{"title": "Analysis and evaluation of software artifact reuse environments\n", "abstract": " Software reuse enables the development of software that is of better quality and at lower cost. Software reuse environments are sought to enhance the reuse of software artifacts especially when done at early-stage of the software life cycle. A number of software reuse environments have been proposed, however, there is no framework that helps in analyzing and evaluating such environments. In this paper the authors provide an attribute-based framework to analyze, evaluate, classify and compare the reuse environments in order to aid practitioners and researchers to select the appropriate reuse environments for their use. The authors first present a survey of existing reuse environments for systematic reuse of software artifacts. Then, they use the framework to analyze those reuse environments. The evaluation of existing environments provides an understanding of current reuse approaches and identifies gaps for\u00a0\u2026", "num_citations": "5\n", "authors": ["793"]}
{"title": "Towards a multi-view approach to model-driven refactoring\n", "abstract": " Model-driven engineering, an emerging trend in software engineering, has enabled the application of refactoring to UML models. One of the important steps in refactoring is the identification of refactoring opportunities within the model, also referred to as Model Smells. An Object-Oriented system modeled by UML is built up from many different views. Model refactoring, in recent proposals, is applied to a single view in the model. Hence information from other views are either not considered or later synchronized for consistency preservation. In this paper we outline an approach to refactor UML models using a multi-view approach. We exploit the inter-view relationship to suggest model smells by combining information from each UML view. We restrict our scope to one diagram from each UML view, class diagram (structural view), sequence diagram (behavioral view) and use case diagram (functional view). For each\u00a0\u2026", "num_citations": "5\n", "authors": ["793"]}
{"title": "Promoting student engagement using social media technologies\n", "abstract": " Using social media in education provides learners with an informal way for communication. Informal communication tends to remove barriers and hence promotes student engagement. This paper presents our experience in using three different social media technologies in teaching software project management course. We conducted different surveys at the end of every semester to evaluate students\u2019 satisfaction and engagement. Results show that using social media enhances students\u2019 engagement and satisfaction. However, familiarity with the tool is an important factor for student satisfaction.", "num_citations": "4\n", "authors": ["793"]}
{"title": "Empirical study of the relationship between design patterns and code smells\n", "abstract": " Software systems are often developed in such a way that good practices in the object-oriented paradigm are not met, causing the occurrence of specific disharmonies which are sometimes called code smells. Design patterns catalogue best practices for developing object-oriented software systems. Although code smells and design patterns are widely divergent, there might be a co-occurrence relation between them. The objective of this paper is to empirically evaluate if the presence of design patterns is related to the presence of code smells at different granularity levels. We performed an empirical study using 20 design patterns and 13 code smells in ten small-size to medium-size, open source Java-based systems. We applied statistical analysis and association rules. Results confirm that classes participating in design patterns have less smell-proneness and smell frequency than classes not participating in design patterns. We also noticed that every design pattern category act in the same way in terms of smell-proneness in the subject systems. However, we observed, based on the association rules learning and the proposed validation technique, that some patterns may be associated with certain smells in some cases. For instance, Command patterns can co-occur with God Class, Blob and External Duplication smell.", "num_citations": "3\n", "authors": ["793"]}
{"title": "A measurement framework for software product maturity assessment\n", "abstract": " The need to ensure the quality of software is growing in importance on a daily basis due to the growing role of software in critical products and application areas, such as defense, aerospace, aviation, and medicine. To meet this need, many organizations use the Capability Maturity Model Integration process model to assess and improve software development processes. This paper proposes a framework for measuring software product maturity as an indicator of product quality. The proposed framework consists of two parts: a reference model and an assessment method. The reference model provides a platform for gathering product quality indicators as evidence of product capability, which reflects the product's maturity. The quality indicators are then used to assess the product maturity level. The assessment method utilizes standard steps for assessing product maturity that are reflected in the degree of the product\u00a0\u2026", "num_citations": "3\n", "authors": ["793"]}
{"title": "ENHANCING STUDENTS\u2019LEARNING AND SATISFACTION THROUGH THE USE OF SOCIAL MEDIA\n", "abstract": " Communication in and out the classroom is an essential component for education. As the technology emerges, there is a need to adopt to the new technologies to enhance students\u2019 learning experience. Social media technologies provide informal communication methods that promote student engagement and satisfaction by removing communication barriers. In this paper, we report our experience in using different social media technologies to enhance students\u2019 learning experience and satisfaction with the course. We perform our experiment in software project management course and conduct a survey to assess the students\u2019 perspective towards using these different social media technologies in enhancing their learning and satisfaction. Results show that students are satisfied and feel that their learning experience has improved when using social media for class communication.", "num_citations": "3\n", "authors": ["793"]}
{"title": "MOVING FROM WATERFALL TO AGILE PROCESS IN SOFTWARE ENGINEERING CAPSTONE PROJECTS\n", "abstract": " Universities offer software engineering capstone course to simulate a real world-working environment in which students can work in a team for a fixed period to deliver a quality product. The objective of the paper is to report on our experience in moving from Waterfall process to Agile process in conducting the software engineering capstone project. We present the capstone course designs for both Waterfall driven and Agile driven methodologies that highlight the structure, deliverables and assessment plans. To evaluate the improvement, we conducted a survey for two different sections taught by two different instructors to evaluate students\u2019 experience in moving from traditional Waterfall model to Agile like process. Twentyeight students filled the survey. The survey consisted of eight multiple-choice questions and an open-ended question to collect feedback from students. The survey results show that students were able to attain hands one experience, which simulate a real world-working environment. The results also show that the Agile approach helped students to have overall better design and avoid mistakes they have made in the initial design completed in of the first phase of the capstone project. In addition, they were able to decide on their team capabilities, training needs and thus learn the required technologies earlier which is reflected on the final product quality.", "num_citations": "3\n", "authors": ["793"]}
{"title": "A framework for an integrated unified modeling language\n", "abstract": " The unified modeling language (UML) is one of the most commonly used modeling languages in the software industry. It simplifies the complex process of design by providing a set of graphical notations, which helps express the objectoriented analysis and design of software projects. Although UML is applicable to different types of systems, domains, methods, and processes, it cannot express certain problem domain needs. Therefore, many extensions to UML have been proposed. In this paper, we propose a framework for integrating the UML extensions and then use the framework to propose an integrated unified modeling language-graphical (iUML-g) form. iUML-g integrates the existing UML extensions into one integrated form. This includes an integrated diagram for UML class, sequence, and use case diagrams. The proposed approach is evaluated using a case study. The proposed iUML-g is capable\u00a0\u2026", "num_citations": "3\n", "authors": ["793"]}
{"title": "Model-driven refactoring approaches: A comparison criteria\n", "abstract": " Model-driven engineering, an emerging trend in software engineering, has enabled the application of refactoring to UML models. Due to its growing popularity in the domain of refactoring, a number of approaches to specify models and transformation rules have been proposed in literature. A comparison framework is required by researchers and practitioners to guide them in selecting an appropriate approach suitable to their specific needs and trade-offs. In this paper, we provide a set of suitable criteria to evaluate and compare the various model refactoring approaches that can aid practitioners and researchers in the selection process. The paper also compares the refactoring approaches against the framework.", "num_citations": "3\n", "authors": ["793"]}
{"title": "Towards the implementation of requirements management specific practices (SP 1.1 and SP 1.2) for small-and medium-sized software development organisations\n", "abstract": " There is a significant need to give careful consideration to the Capability Maturity Model Integration (CMMI) level 2 specific practices (i.e. SP 1.1 \u2018understand requirements\u2019 and SP 1.2 \u2018obtain commitment to requirements\u2019), especially in the context of small- and medium-sized software development organisations, in order to assist such organisations in effectively managing their requirements engineering processes. In this study, the authors propose an abstract-level model for each of these two specific practices as well as cover the initial evaluation of the models. In addition, necessary templates and checklists are also provided for each proposed model. The proposed models are based on a significant amount of research in software process improvement, CMMI and requirements engineering. The initial evaluation of the proposed models was executed using an expert panel review process. The results showed that\u00a0\u2026", "num_citations": "2\n", "authors": ["793"]}
{"title": "Software model stability metrics\n", "abstract": " Methods and computing devices are described for computing a structural model stability metric, a functional model stability metric, and a behavioral model stability metric. A first state of a diagram having a first plurality of actors or participants and a second state of the diagram having a second plurality of actors or participants are obtained. One or more properties for the first state and the second state are identified. A transformation is tracked in the properties from the first state to the second state. The stability metric is calculated for the second state as a ratio of a percentage of unchanged properties from the first state to the second state to a total number of the first plurality of actors or participants in the first state of the diagram.", "num_citations": "2\n", "authors": ["793"]}
{"title": "Toward a Software Bad Smell Prioritization Model for Software Maintainability\n", "abstract": " Bad smells are indicators of possible problems in software. Refactoring is usually undertaken to eradicate bad smells. Many studies have investigated the impact of bad smells on software quality, however, only a few have proposed methods to prioritize bad smells. The objective of this paper is to propose a model to prioritize bad smells based on their impact on software maintainability. We use the analytical hierarchy process (AHP) to prioritize bad smells based on their maintainability impact by measuring the code before and after refactoring. The model is validated against five bad smells and five open-source projects. In addition, a visualization of the relationships between classes\u2019 maintainability and its bad smells\u2019 ranking is presented. The prioritization model can help software practitioners in prioritizing their effort and better utilizing their resources. The proposed prioritization model provides an effective method\u00a0\u2026", "num_citations": "1\n", "authors": ["793"]}
{"title": "GLOB: A global project management readiness framework\n", "abstract": " In global software development (GSD), software is developed by a team of geographically dispersed people. Many organizations that develop projects globally do not evaluate their project management readiness to undertake such projects. The objective of this paper is to propose a global project management readiness framework (GLOB) to help organizations in evaluating and assessing their GSD project management readiness to improve their capabilities in managing GSD projects. To develop GLOB, three systematic literature reviews (SLRs) were conducted. For each SLR, an empirical study was conducted with GSD practitioners to validate the SLR results in a real\u2010world environment. We identified 45 factors that can play a positive or negative role in global project management readiness. In total, 305 best practices were identified for global project management. Based on the findings of the SLRs and\u00a0\u2026", "num_citations": "1\n", "authors": ["793"]}
{"title": "Package-Level stability evaluation of object-oriented systems\n", "abstract": " ContextSoftware stability is an important object-oriented design characteristic that contributes to the maintainability quality attribute. Software stability quantifies a given systems sensitivity to change between different versions. Stable software tends to reduce the maintenance effort. Assessing software stability during the object-oriented design phase is one of the measures to obtain maintainable software. To determine software stability, there are several metrics at the architecture, system and class levels, but few studies have investigated stability at the package level.ObjectiveIn this paper, we propose a new package stability metrics (PSM) based on the notion of change between package contents, intra-package connections and inter-package connections.MethodWe validate the PSM theoretically and empirically. The theoretical validation is based on a study of the mathematical properties of the metrics. The\u00a0\u2026", "num_citations": "1\n", "authors": ["793"]}
{"title": "Sequence diagram refactoring using single and hybridized algorithms\n", "abstract": " Data mining and search-based algorithms have been applied to various problems due to their power and performance. There have been several studies on the use of these algorithms for refactoring. In this paper, we show how search based algorithms can be used for sequence diagram refactoring. We also show how a hybridized algorithm of Kmeans and Simulated Annealing (SA) algorithms can aid each other in solving sequence diagram refactoring. Results show that search based algorithms can be used successfully in refactoring sequence diagram on small and large case studies. In addition, the hybridized algorithm obtains good results using selected quality metrics. Detailed insights on the experiments on sequence diagram refactoring reveal that the limitations of SA can be addressed by hybridizing the Kmeans algorithm to the SA algorithm.", "num_citations": "1\n", "authors": ["793"]}
{"title": "Analysis of the correlation between class stability and maintainability\n", "abstract": " It is assumed that stability and maintainability are relating to each other. We attempt to verify and validate this assumption in object-oriented paradigm. Two candidate metrics were chosen, one for stability and one for maintainability. CSM is used in stability due to its high accuracy and wide coverage. MI was chosen for maintainability due to its clarity, ease of use and solely based on source code. The experiment shows that there is fluctuation in the correlation behavior between these two metrics and a direct causality cannot be concluded. However, in-depth analysis and through tracing of all the steps of these experiments reveal promising results. These observations can aid researchers to measure the correlation between CSM and MI correctly.", "num_citations": "1\n", "authors": ["793"]}
{"title": "Using Software Technologies to Enhance Students Learning: An Experience in Software Project Management Course\n", "abstract": " The use of Information technology (IT) tools in teaching provides innovative learning environments that increases students' interaction with instructor and among students themselves. It is expected that the use of technology to enhance student learning experience. In this paper, I report my experience in teaching software project management course using different technologies. A survey was conducted, at the end of the semester, to evaluate students' experience; the student feedback indicates that using technology in teaching enhanced their learning experience.", "num_citations": "1\n", "authors": ["793"]}
{"title": "Towards the Identification of Quran Reciters\n", "abstract": " It is hard sometime to know the name of the reciter of the Holy Quran \"Qarie\" and the \"Soura/Aya\" while listening to Quran recitation. In this paper, we present the technical details of \"Sout Albayan\" which is an iPhone mobile application that uses audio fingerprinting to identify the details of the reciter, the Aya and the Soura that is being recited. The system allows the user to record a few seconds from the recitation, then it identifies the reciter, the Aya and the Soura being recited. It also has the ability to view and play the identified Aya.", "num_citations": "1\n", "authors": ["793"]}
{"title": "Approaches for Refactoring to Frameworks\n", "abstract": " Software refactoring is the process of improving the internal structure of the software while not affecting its external behavior. Refactoring to framework is a software refactoring process that is applied to an existing software application to produce reusable domain classes while improving their quality. These produced classes form the software architecture and can be reused in the development of other applications. In this paper, we propose two approaches for refactoring to framework; the quality attribute based refactoring to framework (QARtF) and the level based refactoring to framework (LRtF). We empirically validate these two proposed approaches. Results show that these two approaches can produce high quality domain classes that can be used to form software frameworks.", "num_citations": "1\n", "authors": ["793"]}
{"title": "Validating object-oriented software metrics in the agile and framework iterative software processes\n", "abstract": " Object-oriented (OO) software metrics are mainly used to quantitatively evaluate and predict certain Software Engineering (SE) aspects including process and products. This dissertation empirically validates some OO metrics' predictive capabilities in two iterative processes: the short-cycled agile process and the long-cycled framework evolution process. This dissertation also validates the System Design Instability (SDI) metric by testing its project-progress indicative capability in the short-cycled agile process and comparing the result with a previous study.", "num_citations": "1\n", "authors": ["793"]}
{"title": "An Empirical Study of Extreme Programming\n", "abstract": " Extreme Programming (XP) is a drastic departure from the traditional software development processes in which a complete planning cycle usually proceeds any design and implementation work. We report empirical study results from two object-oriented systems, which were developed using a process similar to XP. In particular, we used two metrics\u00be System Design Instability (SDI) and Class Implementation Instability (CII) \u00beto track the design evolution. We found that both systems experienced a significant increase in classes in the middle of the process. The new stories introduced at the beginning of each cycle may change existing design unpredictably. The CII metric seems to give good indication of project completeness.", "num_citations": "1\n", "authors": ["793"]}
{"title": "Challenges of the Existing Tools Used in Global Software Development Projects\n", "abstract": " Global Software Development (GSD) has been embraced by organizations due to the availability of highly trained software engineers at a relatively low cost. GSD is not a risk free activity as several GSD failures have been reported. It is anticipated that the appropriate use of available software tools can play an important role in overcoming some of the risks associated with management of GSD projects. However, there are many challenges in adopting the existing tools in globally distributed projects. The objective of this paper is to identify challenges of existing tools used in GSD projects. We have used a Systematic Literature Review (SLR) approach by applying customized search string derived from our research questions. We have identified 105 papers that discuss the challenges of the existing GSD tools. We have identified key challenges for adopting existing tools in GSD projects, such as:\u201cdifficulties in adopting and learning existing tools\u201d,\u201cinappropriate use of tools\u201d,\u201clack of coverage of GSD processes\u201d and \u201clack of security and privacy\u201d. Based on our SLR results, we suggest that GSD organizations should address these challenges in order to compete in the GSD business.", "num_citations": "1\n", "authors": ["793"]}
{"title": "Automatic Refactoring of Single and Multiple-view UML Models using Artificial Intelligence Algorithms\n", "abstract": " Refactoring tends to improve the internal structure of the software while preserving its behaviour (Fowler and Beck, 1999). This process attempts to reduce the complexity of the software and cut its maintaince cost (Mens and Tourwe, 2004) promoting its quality status (Alshayeb, 2009).", "num_citations": "1\n", "authors": ["793"]}