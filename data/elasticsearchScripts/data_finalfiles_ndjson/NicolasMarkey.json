{"title": "Temporal logic with forgettable past\n", "abstract": " We investigate NLTL, a linear-time temporal logic with forgettable past. NLTL can be exponentially more succinct than LTL+Past (which in turn can be more succinct than LTL). We study satisfiability and model checking for NLTL and provide optimal automata-theoretic algorithms for these EXPSPACE-complete problems.", "num_citations": "244\n", "authors": ["1642"]}
{"title": "Model checking a path\n", "abstract": " We consider the problem of checking whether a finite (or ultimately periodic) run satisfies a temporal logic formula. This problem is at the heart of \u201cruntime verification\u201d but it also appears in many other situations. By considering several extended temporal logics, we show that the problem of model checking a path can usually be solved efficiently, and profit from specialized algorithms. We further show it is possible to efficiently check paths given in compressed form.", "num_citations": "138\n", "authors": ["1642"]}
{"title": "Model checking timed automata with one or two clocks\n", "abstract": " In this paper, we study model checking of timed automata (TAs), and more precisely we aim at finding efficient model checking for subclasses of TAs. For this, we consider model checking TCTL and TCTL \u2264,\u2265 over TAs with one clock or two clocks.               First we show that the reachability problem is NLOGSPACE-complete for one clock TAs (i.e. as complex as reachability in classical graphs) and we give a polynomial time algorithm for model checking TCTL \u2264,\u2265 over this class of TAs. Secondly we show that model checking becomes PSPACE-complete for full TCTL over one clock TAs. We also show that model checking CTL (without any timing constraint) over two clock TAs is PSPACE-complete and that reachability is NP-hard.", "num_citations": "121\n", "authors": ["1642"]}
{"title": "ATL with strategy contexts and bounded memory\n", "abstract": " We extend the alternating-time temporal logics ATL and ATL* with strategy contexts and memory constraints: the first extension makes strategy quantifiers to not \u201cforget\u201d the strategies being executed by the other players. The second extension allows strategy quantifiers to restrict to memoryless or bounded-memory strategies.             We first consider expressiveness issues. We show that our logics can express important properties such as equilibria, and we formally compare them with other similar formalisms (ATL, ATL*, Game Logic, Strategy Logic,\u00a0...). We\u00a0then address the problem of model-checking for our logics, especially we provide a PSPACE algorithm for the sublogics involving only memoryless strategies and an EXPSPACE algorithm for the bounded-memory case.", "num_citations": "113\n", "authors": ["1642"]}
{"title": "Temporal logic with past is exponentially more succinct\n", "abstract": " We positively answer the old question whether temporal logic with past is more succinct than pure-future temporal logic. Surprisingly, the proof is quite simple and elementary, although the question has been open for twenty years.", "num_citations": "113\n", "authors": ["1642"]}
{"title": "On the expressiveness and complexity of ATL\n", "abstract": " ATL is a temporal logic geared towards the specification and verification of properties in multi-agents systems. It allows to reason on the existence of strategies for coalitions of agents in order to enforce a given property. In this paper, we first precisely characterize the complexity of ATL model-checking over Alternating Transition Systems and Concurrent Game Structures when the number of agents is not fixed. We prove that it is \\Delta^P_2 - and \\Delta^P_?_3-complete, depending on the underlying multi-agent model (ATS and CGS resp.). We also consider the same problems for some extensions of ATL. We then consider expressiveness issues. We show how ATS and CGS are related and provide translations between these models w.r.t. alternating bisimulation. We also prove that the standard definition of ATL (built on modalities \"Next\", \"Always\" and \"Until\") cannot express the duals of its modalities: it is necessary to explicitely add the modality \"Release\".", "num_citations": "85\n", "authors": ["1642"]}
{"title": "Robustness and implementability of timed automata\n", "abstract": " In a former paper, we defined a new semantics for timed automata, the Almost ASAP semantics, which is parameterized by \u0394 to cope with the reaction delay of the controller. We showed that this semantics is implementable provided there exists a strictly positive value for the parameter\u00a0\u0394 for which the strategy is correct. In this paper, we define the implementability problem to be the question of existence of such a\u00a0\u0394. We show that this question is closely related to a notion of robustness for timed automata defined in\u00a0[Pur98] and prove that the implementability problem is decidable.", "num_citations": "79\n", "authors": ["1642"]}
{"title": "Robust safety of timed automata\n", "abstract": " Timed automata are governed by an idealized semantics that assumes a perfectly precise behavior of the clocks. The traditional semantics is not robust because the slightest perturbation in the timing of actions may lead to completely different behaviors of the automaton. Following several recent works, we consider a relaxation of this semantics, in which guards on transitions are widened by\u00a0\u0394>0 and clocks can drift by\u00a0\u03b5>0. The relaxed semantics encompasses the imprecisions that are inevitably present in an implementation of a timed automaton, due to the finite precision of digital clocks.               We solve the safety verification problem for this robust semantics: given a timed automaton and a set of bad states, our algorithm decides if there exist positive values for the parameters\u00a0\u0394 and\u00a0\u03b5 such that the timed automaton never enters the bad states under the relaxed semantics.", "num_citations": "75\n", "authors": ["1642"]}
{"title": "Model Checking CTL+ and FCTL Is Hard\n", "abstract": " Among the branching-time temporal logics used for the specification and verification of systems, CTL+, FCTL and ECTL+ are the most notable logics for which the precise computational complexity of model checking is not known. We answer this longstanding open problem and show that model checking these (and some related) logics is \u0394                   Stackp                                  stack2-complete.", "num_citations": "73\n", "authors": ["1642"]}
{"title": "ATL with strategy contexts: Expressiveness and model checking\n", "abstract": " We study the alternating-time temporal logics ATL and ATL* extended with strategy contexts: these make agents commit to their strategies during the evaluation of formulas, contrary to plain ATL and ATL* where strategy quantifiers reset previously selected strategies. We illustrate the important expressive power of strategy contexts by proving that they make the extended logics, namely ATLsc and ATLsc*, equally expressive: any formula in ATLsc* can be translated into an equivalent, linear-size ATLsc formula. Despite the high expressiveness of these logics, we~ prove that their model-checking problems remain decidable by~ designing a tree-automata-based algorithm for model-checking ATLsc* on the full class of -player concurrent game structures.", "num_citations": "68\n", "authors": ["1642"]}
{"title": "Efficient timed model checking for discrete-time systems\n", "abstract": " We consider model checking of timed temporal formulae in durational transition graphs (DTGs), ie, Kripke structures where transitions have integer durations. Two semantics for DTGs are presented and motivated. We consider timed versions of CTL where subscripts put quantitative constraints on the time it takes before a property is satisfied. We exhibit an important gap between logics where subscripts of the form \u201c= c\u201d(exact duration) are allowed, and simpler logics that only allow subscripts of the form \u201c\u2a7d c\u201d or \u201c\u2a7e c\u201d(bounded duration). Without exact durations, model checking can be done in polynomial time, but with exact durations, it becomes \u0394 2 p-complete or PSPACE-complete depending on the considered semantics.", "num_citations": "53\n", "authors": ["1642"]}
{"title": "Augmenting ATL with strategy contexts\n", "abstract": " We study the extension of the alternating-time temporal logic (ATL) with strategy contexts: contrary to the original semantics, in this semantics the strategy quantifiers do not reset the previously selected strategies. We show that our extension ATL s c is very expressive, but that its decision problems are quite hard: model checking is k-EXPTIME-complete when the formula has k nested strategy quantifiers; satisfiability is undecidable, but we prove that it is decidable when restricting to turn-based games. Our algorithms are obtained through a very convenient translation to QCTL (the computation-tree logic CTL extended with atomic quantification), which we show also applies to Strategy Logic, as well as when strategy quantification ranges over memoryless strategies.", "num_citations": "48\n", "authors": ["1642"]}
{"title": "Non-deterministic temporal logics for general flow systems\n", "abstract": " In this paper, we use the constructs of branching temporal logic to formalize reasoning about a class of general flow systems, including discrete-time transition systems, continuous-time differential inclusions, and hybrid-time systems such as hybrid automata. We introduce Full General Flow Logic, GFL                         \u2009\u22c6\u2009, which has essentially the same syntax as the well-known Full Computation Tree Logic, CTL                         \u2009\u22c6\u2009, but generalizes the semantics to general flow systems over arbitrary time-lines. We propose an axiomatic proof system for GFL                         \u2009\u22c6\u2009 and establish its soundness w.r.t. the general flow semantics.", "num_citations": "48\n", "authors": ["1642"]}
{"title": "Past is for free: on the complexity of verifying linear temporal properties with past\n", "abstract": " We study the complexity of satisfiability and model checking problems for fragments of linear-time temporal logic with past (PLTL). We consider many fragments of PLTL, obtained by restricting the set of allowed temporal modalities, the use of negations or the nesting of future formulas into past formulas. Our results strengthen the widely accepted fact that \u201cpast is for free\u201d, in the sense that allowing symmetric past-time modalities does not bring additional theoretical complexity. This result holds even for small fragments and even when nesting future formulas into past formulas.", "num_citations": "44\n", "authors": ["1642"]}
{"title": "Quantified CTL: expressiveness and complexity\n", "abstract": " While it was defined long ago, the extension of CTL with quantification over atomic propositions has never been studied extensively. Considering two different semantics (depending whether propositional quantification refers to the Kripke structure or to its unwinding tree), we study its expressiveness (showing in particular that QCTL coincides with Monadic Second-Order Logic for both semantics) and characterise the complexity of its model-checking and satisfiability problems, depending on the number of nested propositional quantifiers (showing that the structure semantics populates the polynomial hierarchy while the tree semantics populates the exponential hierarchy).", "num_citations": "40\n", "authors": ["1642"]}
{"title": "Model-checking timed ATL for durational concurrent game structures\n", "abstract": " We extend the framework of ATL model-checking to \u201csimply timed\u201d concurrent game structures, i.e., multi-agent structures where each transition carry an integral duration (or interval thereof). While the case of single durations is easily handled from the semantics point of view, intervals of durations raise several interesting questions. Moreover subtle algorithmic problems have to be handled when dealing with model checking. We propose a semantics for which we develop efficient (PTIME) algorithms for timed ATL without equality constraints, while the general case is shown to be EXPTIME-complete.", "num_citations": "38\n", "authors": ["1642"]}
{"title": "On model checking durational Kripke structures\n", "abstract": " We consider quantitative model checking in durational Kripke structures (Kripke structures where transitions have integer durations) with timed temporal logics where subscripts put quantitative constraints on the time it takes before a property is satisfied.               We investigate the conditions that allow polynomial-time model checking algorithms for timed versions of CTL and exhibit an important gap between logics where subscripts of the form \u201c= c\u201d (exact duration) are allowed, and simpler logics that only allow subscripts of the form \u201c\u2264c\u201d or \u201c\u2265 c\u201d (bounded duration).               A surprising outcome of this study is that it provides the second example of a \u0394p                 2-complete model checking problem.", "num_citations": "38\n", "authors": ["1642"]}
{"title": "Tame the beast\n", "abstract": " This 48-page tutorial presents and explains, as clearly and exhaustively as possible, what BibTEX can do. Indeed, BibTEX manuals, essentially two documents by its author [Pat88a, Pat88b] and chapters in some LATEX books [Lam97, GMS93, MGB+ 04,...], are often short and incomplete. The capital letters \u201cBST\u201d in the title represent the standard extension of BibTEX style files.\u201cB to X\u201d means that I tried to be as complete as possible. Don\u2019t hesitate to e-mail me your TEXnical as well as (mis) spelling remarks.", "num_citations": "35\n", "authors": ["1642"]}
{"title": "Robustness in real-time systems.\n", "abstract": " We review several aspects of robustness of real-time systems, and present recent results on the robust verification of timed automata.", "num_citations": "34\n", "authors": ["1642"]}
{"title": "Symbolic model checking for simply-timed systems\n", "abstract": " We describe OBDD-based symbolic model checking algorithms for simply-timed systems, i.e. finite state graphs where transitions carry a duration. These durations can be arbitrary natural numbers. A simple and natural semantics for these systems opens the way for improved efficiency. Our algorithms have been implemented in NuSMV and perform well in practice (on standard case studies).", "num_citations": "31\n", "authors": ["1642"]}
{"title": "Language preservation problems in parametric timed automata\n", "abstract": " Parametric timed automata (PTA) are a powerful formalism to model and reason about concurrent systems with some unknown timing delays. In this paper, we address the (untimed) language- and trace-preservation problems: given a reference parameter valuation, does there exist another parameter valuation with the same untimed language, or with the same set of traces? We show that these problems are undecidable both for general PTA and for the restricted class of L/U-PTA, even for integer-valued parameters, or over bounded time. On the other hand, we exhibit decidable subclasses: 1-clock PTA, and 1-parameter deterministic L-PTA and U-PTA. We also consider robust versions of these problems, where we additionally require that the language be preserved for all valuations between the reference valuation and the new valuation.", "num_citations": "30\n", "authors": ["1642"]}
{"title": "On the Expressiveness and Complexity of ATL\n", "abstract": " ATL is a temporal logic geared towards the specification and verification of properties in multi-agents systems. It allows to reason on the existence of strategies for coalitions of agents in order to enforce a given property. We prove that the standard definition of ATL (built on modalities \u201cNext\u201d, \u201cAlways\u201d and \u201cUntil\u201d) has to be completed in order to express the duals of its modalities: it is necessary to add the modality \u201cRelease\u201d. We then precisely characterize the complexity of ATL model-checking when the number of agents is not fixed. We prove that it is - and -complete, depending on the underlying multi-agent model (ATS and CGS resp.). We also prove that ATL+ model-checking is -complete over both models, even with a fixed number of agents.", "num_citations": "30\n", "authors": ["1642"]}
{"title": "A PTIME-complete matching problem for SLP-compressed words\n", "abstract": " SLP-compressed words are words given by simple deterministic grammars called \u201cstraight-line programs\u201d. We prove that the problem of deciding whether an SLP-compressed word is recognized by an FSA is complete for polynomial-time.", "num_citations": "26\n", "authors": ["1642"]}
{"title": "Quantified CTL: Expressiveness and Model Checking\n", "abstract": " While it was defined long ago, the extension of CTL with quantification over atomic propositions has never been studied extensively. Considering two different semantics (depending whether propositional quantification refers to the Kripke structure or to its unwinding tree), we\u00a0study its expressiveness (showing in particular that QCTL coincides with Monadic Second-Order Logic for both semantics) and characterize the complexity of its model-checking problem, depending on the number of nested propositional quantifiers (showing that the structure semantics populates the polynomial hierarchy while the tree semantics populates the exponential hierarchy). We also show how these results apply to model checking ATL-like temporal logics for games.", "num_citations": "25\n", "authors": ["1642"]}
{"title": "Timed concurrent game structures\n", "abstract": " We propose a new model for timed games, based on concurrent game structures\u00a0(CGSs). Compared to the classical timed game automata of\u00a0Asarin et\u00a0al. [8], our timed\u00a0CGSs are \u201cmore concurrent\u201d, in the sense that they always allow all the agents to act on the system, independently of the delay they want to elapse before their action. Timed CGSs weaken the \u201celement of surprise\u201d of timed game automata reported by de\u00a0Alfaro et\u00a0al. [15].               We prove that our model has nice properties, in particular that model-checking timed CGSs against timed ATL is decidable via region abstraction, and in particular that strategies are \u201cregion-stable\u201d if winning objectives are. We also propose a new extension of TATL, containing ATL*, which we call TALTL. We prove that model-checking this logic remains decidable on timed CGSs. Last, we explain how our algorithms can be adapted in order to rule out Zeno (co\u00a0\u2026", "num_citations": "25\n", "authors": ["1642"]}
{"title": "Synchronizing words for weighted and timed automata\n", "abstract": " The problem of synchronizing automata is concerned with the existence of a word that sends all states of the automaton to one and the same state. This problem has classically been studied for complete deterministic finite automata, with the existence problem being NLOGSPACE-complete. In this paper we consider synchronizing-word problems for weighted and timed automata. We consider the synchronization problem in several variants and combinations of these, including deterministic and non-deterministic timed and weighted automata, synchronization to unique location with possibly different clock valuations or accumulated weights, as well as synchronization with a safety condition forbidding the automaton to visit states outside a safety-set during synchronization (eg energy constraints). For deterministic weighted automata, the synchronization problem is proven PSPACE-complete under energy constraints, and in 3-EXPSPACE under general safety constraints. For timed automata the synchronization problems are shown to be PSPACE-complete in the deterministic case, and undecidable in the non-deterministic case.", "num_citations": "23\n", "authors": ["1642"]}
{"title": "Model checking restricted sets of timed paths\n", "abstract": " In this paper, we study the complexity of model-checking formulas of four important real-time logics (TPTL, MTL, MITL, and TCTL) over restricted sets of timed paths. The classes of restricted sets of timed paths that we consider are (i) a single finite (or ultimately periodic) timed path,(ii) an infinite set of finite (or infinite) timed paths defined by a finite (or ultimately periodic) path in a region graph,(iii) an infinite set of finite (or infinite) timed paths defined by a finite (or ultimately periodic) path in a zone graph. Several results are quite negative: TPTL and MTL remain undecidable along region-and zone-paths. On the other hand, we obtained PTIME algorithms for model-checking TCTL along a region path, and for MTL along a single timed path.", "num_citations": "20\n", "authors": ["1642"]}
{"title": "Past is for free: on the complexity of verifying linear temporal properties with past\n", "abstract": " We study the complexity of satisfiability and model-checking of the linear-time temporal logic with past (PLTL). More precisely, we consider several fragments of PLTL. depending on the allowed set of temporal modalities, the use of negations or the nesting of future formulae into past formulae. Our results show that \u201cpast is for free\u201d, that is it does not bring additional theoretical complexity, even for small fragments, and even when nesting future formulae into past formulae. We also remark that existential and universal model-checking can have different complexity for certain fragments.", "num_citations": "19\n", "authors": ["1642"]}
{"title": "Logiques temporelles pour la v\u00e9rification: expressivit\u00e9, complexit\u00e9, algorithmes\n", "abstract": " Ce travail s' inscrit dans le cadre de la v\u00e9rification formelle de programmes: le model checking est une technique qui permet de s' assurer qu'une propri\u00e9t\u00e9, exprim\u00e9e en logique temporelle, est v\u00e9rifi\u00e9e par le mod\u00e8le d'un syst\u00e8me. Cette th\u00e8se \u00e9tudie plusieurs logiques temporelles, du point de vue de l'expressivit\u00e9 et de la complexit\u00e9. Nous \u00e9tudions trois grands types de logiques temporelles:-concernant la logique temporelle du temps lin\u00e9aire, nous prouvons que l'ajout de modalit\u00e9s du pass\u00e9 permet de simplifier l'\u00e9criture des formules sans augmenter la complexit\u00e9 des probl\u00e8mes de model checking. Nous \u00e9tudions \u00e9galement l'impact de l'ajout de la modalit\u00e9 Now;-concernant la logique temporelle du temps arborescent, nous \u00e9tablissons la complexit\u00e9 du model checking pour plusieurs extensions classiques de CTL;-enfin, nous montrons qu'il est possible, sous certaines conditions, de v\u00e9rifier efficacement des propri\u00e9t\u00e9s quantitatives sur la dur\u00e9e s\u00e9parant deux \u00e9v\u00e8nements.", "num_citations": "18\n", "authors": ["1642"]}
{"title": "Distributed synthesis of state-dependent switching control\n", "abstract": " We present a correct-by-design method of state-dependent control synthesis for linear discrete-time switching systems. Given an objective region R of the state space, the method builds a capture set S and a control which steers any element of S into R. The method works by iterated backward reachability from R. More precisely, S is given as a parametric extension of R, and the maximum value of the parameter is solved by linear programming. The method can also be used to synthesize a stability control which maintains indefinitely within R all the states starting at R. We explain how the synthesis method can be performed in a distributed manner. The method has been implemented and successfully applied to the synthesis of a distributed control of a concrete floor heating system with 11 rooms and  switching modes.", "num_citations": "17\n", "authors": ["1642"]}
{"title": "TSMV: A symbolic model checker for quantitative analysis of systems\n", "abstract": " TSMV is an extension of NuSMV, the open-source symbolic model checker, aimed at dealing with timed versions of (models of) circuits, PLC controllers, protocols, etc. The underlying model is an extension of Kripke structures, where every transition carries an integer duration (possibly zero). This simple model supports efficient symbolic algorithms for RTCTL formulae.", "num_citations": "14\n", "authors": ["1642"]}
{"title": "Component-based analysis of hierarchical scheduling using linear hybrid automata\n", "abstract": " Formal methods (e.g. Timed Automata or Linear Hybrid Automata) can be used to analyse a real-time system by performing a reachability analysis on the model. The advantage of using formal methods is that they are more expressive than classical analytic models used in schedulability analysis. For example, it is possible to express state-dependent behaviour, arbitrary activation patterns, etc. In this paper we use the formalism of Linear Hybrid Automata to encode a hierarchical scheduling system. In particular, we model a dynamic server algorithm and the tasks contained within, abstracting away the rest of the system, thus enabling component-based scheduling analysis. We prove the correctness of the model and the decidability of the reachability analysis for the case of periodic tasks. Then, we compare the results of our model against classical schedulability analysis techniques, showing that our analysis\u00a0\u2026", "num_citations": "13\n", "authors": ["1642"]}
{"title": "Mu-calculus path checking\n", "abstract": " We investigate the path model checking problem for the \u03bc-calculus. Surprisingly, restricting to deterministic structures does not allow for more efficient model checking algorithm, as we prove that it can encode any instance of the standard model checking problem for the \u03bc-calculus.", "num_citations": "12\n", "authors": ["1642"]}
{"title": "Satisfiability of ATL with strategy contexts\n", "abstract": " Various extensions of the temporal logic ATL have recently been introduced to express rich properties of multi-agent systems. Among these, ATLsc extends ATL with strategy contexts, while Strategy Logic has first-order quantification over strategies. There is a price to pay for the rich expressiveness of these logics: model-checking is non-elementary, and satisfiability is undecidable. We prove in this paper that satisfiability is decidable in several special cases. The most important one is when restricting to turn-based games. We prove that decidability also holds for concurrent games if the number of moves available to the agents is bounded. Finally, we prove that restricting strategy quantification to memoryless strategies brings back undecidability.", "num_citations": "11\n", "authors": ["1642"]}
{"title": "Using model checking for analyzing distributed power control problems\n", "abstract": " Model checking (MC) is a formal verification technique which has been known and still knows a resounding success in the computer science community. Realizing that the distributed power control (PC) problem can be modeled by a timed game between a given transmitter and its environment, the authors wanted to know whether this approach can be applied to distributed PC. It turns out that it can be applied successfully and allows one to analyze realistic scenarios including the case of discrete transmit powers and games with incomplete information. The proposed methodology is as follows. We state some objectives a transmitter-receiver pair would like to reach. The network is modeled by a game where transmitters are considered as timed automata interacting with each other. The objectives are then translated into timed alternating-time temporal logic formulae and MC is exploited to know whether the\u00a0\u2026", "num_citations": "11\n", "authors": ["1642"]}
{"title": "ATLsc with partial observation\n", "abstract": " Alternating-time temporal logic with strategy contexts (ATLsc) is a powerful formalism for expressing properties of multi-agent systems: it extends CTL with strategy quantifiers, offering a convenient way of expressing both collaboration and antagonism between several agents. Incomplete observation of the state space is a desirable feature in such a framework, but it quickly leads to undecidable verification problems. In this paper, we prove that uniform incomplete observation (where all players have the same observation) preserves decidability of the model-checking problem, even for very expressive logics such as ATLsc.", "num_citations": "10\n", "authors": ["1642"]}
{"title": "Verification of embedded systems--Algorithms and complexity\n", "abstract": " CiteSeerX \u2014 Verification of embedded systems -- Algorithms and complexity Documents Authors Tables Log in Sign up MetaCart DMCA Donate CiteSeerX logo Documents: Advanced Search Include Citations Authors: Advanced Search Include Citations Tables: DMCA Verification of embedded systems -- Algorithms and complexity (2011) Cached Download as a PDF Download Links [www.lsv.ens-cachan.fr] [www.lsv.ens-cachan.fr] [www.lsv.ens-cachan.fr] Save to List Add to Collection Correct Errors Monitor Changes by Nicolas Markey Citations: 3 - 1 self Summary Citations Active Bibliography Co-citation Clustered Documents Version History Share Facebook Twitter Reddit Bibsonomy OpenURL Abstract Keyphrases embedded system algorithm Powered by: Apache Solr About CiteSeerX Submit and Index Documents Privacy Policy Help Data Source Contact Us Developed at and hosted by The College of \u2026", "num_citations": "10\n", "authors": ["1642"]}
{"title": "Good friends are hard to find!\n", "abstract": " We focus on the problem of finding (the size of) a minimal winning coalition in a multi-player game. We prove that deciding whether there is a winning coalition of size at most k is HP-complete, while deciding whether k is the optimal size is DP -complete. We also study different variants of our original problem: the function problem, where the aim is to effectively compute the coalition; more succinct encoding of the game; and richer families of winning objectives.", "num_citations": "7\n", "authors": ["1642"]}
{"title": "Impl\u00e9mentabilit\u00e9 des automates temporis\u00e9s\n", "abstract": " In this paper, we present the problem of the implementability of timed automata. The theoretical semantics of timed automata can not be exactly implemented in practice, because computers are digital and more or less precise; the properties verified on a timed automaton are not necessarily preserved when implementing it. We deal with two approaches: the first one is based on the modeling of the execution platform and the second studies an enlarged semantics for timed automata that takes the imprecision into account.", "num_citations": "7\n", "authors": ["1642"]}
{"title": "Model checking restricted sets of timed paths\n", "abstract": " In this paper, we study the complexity of model-checking formulas of three important real-time logics (MTL, MITL, and TCTL) over restricted sets of timed paths. The classes of restricted sets of timed paths that we consider are (i) a single finite (or ultimately periodic) timed path, (ii) a infinite set of finite (or infinite) timed paths defined by a finite (or ultimately periodic) path in a region graph, (iii) a infinite set of finite (or infinite) timed paths defined by a finite (or ultimately periodic) path in a zone graph.", "num_citations": "6\n", "authors": ["1642"]}
{"title": "Abstraction refinement algorithms for timed automata\n", "abstract": " We present abstraction-refinement algorithms for model checking safety properties of timed automata. The\u00a0abstraction domain we consider abstracts away zones by restricting the set of clock constraints that can be used to define them, while the refinement procedure computes the set of constraints that must be taken into consideration in the abstraction so as to exclude a given spurious counterexample. We\u00a0implement this idea in two\u00a0ways: an\u00a0enumerative algorithm where a lazy abstraction approach is adopted, meaning that possibly different abstract domains are assigned to each exploration node; and a\u00a0symbolic algorithm where the abstract transition system is encoded with Boolean formulas.", "num_citations": "5\n", "authors": ["1642"]}
{"title": "Parameterized verification of synchronization in constrained reconfigurable broadcast networks\n", "abstract": " Reconfigurable broadcast networks provide a convenient formalism for modelling and reasoning about networks of mobile agents broadcasting messages to other agents following some (evolving) communication topology. The\u00a0parameterized verification of such models aims at checking whether a given property holds irrespective of the initial configuration (number of agents, initial states and initial communication topology). We\u00a0focus here on the synchronization property, asking whether all agents converge to a set of target states after some execution. This problem is known to be decidable in polynomial time when no constraints are imposed on the evolution of the communication topology (while it\u00a0is undecidable for static broadcast networks).                 In this paper we investigate how various constraints on reconfigurations affect the decidability and complexity of the synchronization problem. In\u00a0particular\u00a0\u2026", "num_citations": "4\n", "authors": ["1642"]}
{"title": "Temporal logics\n", "abstract": " These notes have been written as a support for the course about temporal logics taught at MPRI (Master Parisien de Recherche en Informatique) during the first semester of year 2006-2007. They contain most of what will be studied during the course, most often with detailled proofs, and several exercises, ranked from easy (\u2605) to hard (\u2605\u2605\u2605).", "num_citations": "4\n", "authors": ["1642"]}
{"title": "Expressiveness of temporal logics\n", "abstract": " 3 Linear-time temporal logics Definitions, basic formulas LTL, PLTL and FO Normal forms for LTL+ Past", "num_citations": "4\n", "authors": ["1642"]}
{"title": "Compositional synthesis of state-dependent switching control\n", "abstract": " We present a correct-by-design method of state-dependent control synthesis for sampled switching systems. Given a target region R of the state space, our method builds a capture set S and a control that steers any element of S into R. The method works by iterated backward reachability from R. The method is also used to synthesize a recurrence control that makes any state of R return to R infinitely often. We explain how the synthesis method can be performed in a compositional manner, and apply it to the synthesis of a compositional control of a concrete floor-heating system with 11 rooms and up to 2 11= 2048 switching modes.", "num_citations": "3\n", "authors": ["1642"]}
{"title": "Game-based synthesis of distributed controllers for sampled switched systems\n", "abstract": " Switched systems are a convenient formalism for modeling physical processes interacting with a digital controller. Unfortunately, the formalism does not capture the distributed nature encountered eg in cyber-physical systems, which are organized as networks of elements interacting with local controllers. Most current methods for control synthesis can only produce a centralized controller, which is assumed to have complete knowledge of all the component states and can interact with all of them. In this paper, we consider a centralized-controller synthesis technique based on state-space decomposition, and use a game-based approach to extend it to a distributed framework.", "num_citations": "3\n", "authors": ["1642"]}
{"title": "On the expressiveness of QCTL\n", "abstract": " QCTL extends the temporal logic CTL with quantification over atomic propositions. While the algorithmic questions for QCTL and its fragments with limited quantification depth are well-understood (eg satisfiability of QkCTL, with at most k nested blocks of quantifiers, is (k+ 1)-EXPTIME-complete), very few results are known about the expressiveness of this logic. We address such expressiveness questions in this paper. We first consider the distinguishing power of these logics (ie, their ability to separate models), their relationship with behavioural equivalences, and their ability to capture the behaviours of finite Kripke structures with so-called characteristic formulas. We then consider their expressive power (ie, their ability to express a property), showing that in terms of expressiveness the hierarchy QkCTL collapses at level 2 (in other terms, any QCTL formula can be expressed using at most two nested blocks of quantifiers).", "num_citations": "2\n", "authors": ["1642"]}
{"title": "Symmetry reduction in infinite games with finite branching\n", "abstract": " Symmetry reductions have been applied extensively for the verification of finite-state concurrent systems and hardware designs using model-checking of temporal logics such as LTL, CTL and\u00a0CTLs, as well as real-time and probabilistic-system model-checking. In this paper we extend the technique to handle infinite-state games on graphs with finite branching where the objectives of the players can be very general. As\u00a0particular applications, it is shown that the technique can be applied to reduce the state space in parity games as well as when doing model-checking of the temporal logic\u00a0ATLs.", "num_citations": "2\n", "authors": ["1642"]}
{"title": "Contr\u00f4le et impl\u00e9mentation des syst\u00e8mes temporis\u00e9s\n", "abstract": " Cet article est une introduction au contr\u00f4le des syst\u00e8mes mod\u00e9lis\u00e9s par des automates temporis\u00e9s. Nous d\u00e9finissons les notions de base du contr\u00f4le vu comme un jeu: strat\u00e9gie, objectif de contr\u00f4le, \u00e9tats gagnants. On s\u2019 int\u00e9resse ensuite aux op\u00e9rateurs de base permettant de r\u00e9soudre les jeux temporis\u00e9s. Nous consid\u00e9rons le cas des jeux de s\u00fbret\u00e9 pour lesquels nous donnons un exemple complet de calcul de contr\u00f4leur. Nous abordons ensuite la notion importante d\u2019impl\u00e9mentabilit\u00e9 des contr\u00f4leurs. Deux points de vue sont propos\u00e9s: l\u2019un syntaxique, qui consiste \u00e0 d\u00e9crire la plate-forme cible pour l\u2019impl\u00e9mentation par des automates temporis\u00e9s; l\u2019autre s\u00e9mantique, qui consid\u00e8re une s\u00e9mantique impl\u00e9mentable des automates temporis\u00e9s.", "num_citations": "2\n", "authors": ["1642"]}
{"title": "Dynamic network congestion games\n", "abstract": " Congestion games are a classical type of games studied in game theory, in which n players choose a resource, and their individual cost increases with the number of other players choosing the same resource. In network congestion games (NCGs), the resources correspond to simple paths in a graph, e.g. representing routing options from a source to a target. In this paper, we introduce a variant of NCGs, referred to as dynamic NCGs: in this setting, players take transitions synchronously, they select their next transitions dynamically, and they are charged a cost that depends on the number of players simultaneously using the same transition. We study, from a complexity perspective, standard concepts of game theory in dynamic NCGs: social optima, Nash equilibria, and subgame perfect equilibria. Our contributions are the following: the existence of a strategy profile with social cost bounded by a constant is in PSPACE and NP-hard. (Pure) Nash equilibria always exist in dynamic NCGs; the existence of a Nash equilibrium with bounded cost can be decided in EXPSPACE, and computing a witnessing strategy profile can be done in doubly-exponential time. The existence of a subgame perfect equilibrium with bounded cost can be decided in 2EXPSPACE, and a witnessing strategy profile can be computed in triply-exponential time.", "num_citations": "1\n", "authors": ["1642"]}
{"title": "Strategies in infinite games: structured reactive programs and transducers over infinite alphabets\n", "abstract": " Das Thema dieser Arbeit ist die Konstruktion von Gewinnstrategien in unendlichen Spielen folgender Art: Zwei Spieler w\u00e4hlen abwechselnd jeweils ein Symbol aus einem gegebenen Alphabet, so dass sich eine unendliche Symbolfolge ergibt. Als Gewinnbedingung dient eine Menge L solcher Folgen-der zweite Spieler gewinnt, falls die produzierte Folge in L enthalten ist, andernfalls gewinnt der erste Spieler. Solche Spiele sind ein n\u00fctzliches Modell f\u00fcr die Interaktion zwischen einem sogenannten reaktiven System und dessen Umgebung: Das System nimmt fortw\u00e4hrend Eingabesymbole entgegen und antwortet jeweils mit einem Ausgabesymbol. Eine Gewinnbedingung kann als Spezifikation f\u00fcr solch ein System aufgefasst werden, und eine Gewinnstrategie f\u00fcr das System als korrekte Implementierung. Wir untersuchen zwei Varianten von Churchs Syntheseproblem, das wie folgt formuliert werden kann\u00a0\u2026", "num_citations": "1\n", "authors": ["1642"]}
{"title": "Temporal logics for multi-agent systems\n", "abstract": " This is an overview of an invited talk delivered during the 42nd International Conference on Mathematical Foundations of Computer Science (MFCS 2017).", "num_citations": "1\n", "authors": ["1642"]}
{"title": "Courcelle's Theorem Made Dynamic\n", "abstract": " Dynamic complexity is concerned with updating the output of a problem when the input is slightly changed. We study the dynamic complexity of model checking a fixed monadic second-order formula over evolving subgraphs of a fixed maximal graph having bounded tree-width; here the subgraph evolves by losing or gaining edges (from the maximal graph). We show that this problem is in DynFO (with LOGSPACE precomputation), via a reduction to a Dyck reachability problem on an acyclic automaton.", "num_citations": "1\n", "authors": ["1642"]}
{"title": "Model checking CTL+ is hard\n", "abstract": " \u0424 \u041a \u042b\u0434 \u040c \u0438 \u0433\u0432 \u0412 \u042e \u0436 \u040c \u0438 \u0433\u0432 \u0426\u042b \u0432 \u0412 \u0426\u042a\u042b \u042d\u0425\u042a \u041f \u041d\u0418 \u043a\u041a \u0428 \u0438\u041a \u042f \u0430\u0437\u0433\u0432\u0418 \u041e\u041f \u0432 \u043c \u0436 \u0432 \u0431 \u0430 \u0430\u0418\u0431 \u0436 \u043d\u0418\u0434 \u0437 \u0430\u0437\u043a\u041a \u0432\u0437\u0419 \u0432\u041a \u0436 \u0437\u0438\u0436 \u0438\u041a \u0431\u0433\u0432 \u0438 \u0436 \u0432 \u0432 \u0419\u0438 \u0431 \u0438 \u0431\u0434\u0433\u0436 \u0430 \u0430\u0433 \u0437 \u0439\u0437 \u0433\u0436 \u0438 \u0437\u0434 \u0419 \u040c \u0438 \u0433\u0432 \u0432 \u043a \u0436 \u040c \u0438 \u0433\u0432 \u0433 \u0437\u043d\u0437\u0438 \u0431\u0437\u0418 \u042c\u0424 \u0417 \u0432 \u042c\u0424 \u0417 \u0436 \u0438 \u0431\u0433\u0437\u0438 \u0432\u0433\u0438 \u0430 \u0430\u0433 \u0437 \u0433\u0436 \u043b \u0438 \u0434\u0436 \u0437 \u0433\u0431\u0434\u0439\u0438 \u0438 \u0433\u0432 \u0430 \u0433\u0431\u0434\u0430 \u043c \u0438\u043d \u0433 \u0431\u0433 \u0430 \u0432 \u0437 \u0432\u0433\u0438 \u0432\u0433\u043b\u0432\u041a \u042f \u0432\u0437\u043b \u0436 \u0438 \u0437 \u0430\u0433\u0432 \u0437\u0438 \u0432 \u0432 \u0433\u0434 \u0432 \u0434\u0436\u0433 \u0430 \u0431 \u0432 \u0437 \u0433\u043b \u0438 \u0438 \u0431\u0433 \u0430 \u0432 \u042c\u0424 \u0417 \u0418 \u042c\u0424 \u0417 \u0432 \u0437\u0433\u0431 \u0436 \u0430 \u0438 \u0430\u0433 \u0437 \u0437 \u0401\u0434 \u041e\u0419 \u0433\u0431\u0434\u0430 \u0438 \u041a", "num_citations": "1\n", "authors": ["1642"]}