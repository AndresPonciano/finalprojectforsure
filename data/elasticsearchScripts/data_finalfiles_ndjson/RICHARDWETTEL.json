{"title": "Visualizing software systems as cities\n", "abstract": " This paper presents a 3D visualization approach which gravitates around the city metaphor, i.e., an object-oriented software system is represented as a city that can be traversed and interacted with: the goal is to give the viewer a sense of locality to ease program comprehension. The key point in conceiving a realistic software city is to map the information about the source code in meaningful ways in order to take the approach beyond beautiful pictures. We investigated several concepts that contribute to the urban feeling, such as appropriate layouts, topology, and facilities to ease navigation and interaction. We experimented our approach on a number of systems, and present our findings.", "num_citations": "322\n", "authors": ["135"]}
{"title": "Program comprehension through software habitability\n", "abstract": " The comprehensive understanding of a large software system is a daunting task because of the sheer size and complexity that such systems exhibit. In this context software visualization is a widely used approach, since well-conceived visual representations allow one to spot patterns. The large majority of visualizations use 2D representations, because they are easier to construct, navigate, and interact with. 3D representations usually exploit the 3rd dimension as an additional means to encode quantitative values, which is dismissed by many as a too small benefit in the light of the added complexity in terms of navigation and interaction. We argue that a well-constructed, interactive, and easily navigable 3D visualization can greatly help in program comprehension tasks by supporting habitability. Habitability transmits to a developer the notion that a software system is a physical space with strong orientation points\u00a0\u2026", "num_citations": "139\n", "authors": ["135"]}
{"title": "Codecity: 3d visualization of large-scale software\n", "abstract": " CodeCity is a language-independent interactive 3D visualization tool for the analysis of large software systems. Based on a city metaphor, it depicts classes as buildings and packages as districts of a\" software city\". By offering consistent locality and solid orientation points we keep the viewer oriented during the exploration of a city. We applied our tool on several large-scale industrial systems.", "num_citations": "130\n", "authors": ["135"]}
{"title": "Visual exploration of large-scale system evolution\n", "abstract": " The goal of reverse engineering is to obtain a mental model of software systems. However, evolution adds another dimension to their implicit complexity, effectively making them moving targets: The evolution of software systems still remains an intangible and complex process. Metrics have been extensively used to quantify various facets of evolution, but even the usage of complex metrics often leads to overly simplistic insights, thus failing at adequately characterizing the complex evolutionary processes.We present an approach based on real-time interactive 3D visualizations, whose goal is to render the structural evolution of object-oriented software systems at both a coarse-grained and a fine-grained level. By providing insights into a system's history, our visualizations allow us to reason about the origins and the causalities which led to the current state of a system. We illustrate our approach on three large open\u00a0\u2026", "num_citations": "124\n", "authors": ["135"]}
{"title": "Visually localizing design problems with disharmony maps\n", "abstract": " Assessing the quality of software design is difficult, as\" design\" is expressed through guidelines and heuristics, not rigorous rules. One successful approach to assess design quality is based on detection strategies, which are metrics-based composed logical conditions, by which design fragments with specific properties are detected in the source code. Such detection strategies, when executed on large software systems usually return large sets of artifacts, which potentially exhibit one or more\" design disharmonies\", which are then inspected manually, a cumbersome activity.", "num_citations": "86\n", "authors": ["135"]}
{"title": "Software systems as cities\n", "abstract": " Software understanding takes up a large share of the total cost of a software system. The high costs attributed to software understanding activities are caused by the size and complexity of software systems, by the continuous evolution that these systems are subject to, and by the lack of physical presence which makes software intangible. Reverse engineering helps practitioners deal with the intrinsic complexity of software, by providing a broad range of patterns and techniques. One of these techniques is software visualization, which makes software more tangible, by providing visible representations of software systems. Interpreting a visualization is by no means trivial and requires knowledge about the visual language of the visualization. One means to ease the learning of a new visualization's language are metaphors, which allow the interpretation of new data representations by analogy. Possibly one of the most\u00a0\u2026", "num_citations": "44\n", "authors": ["135"]}
{"title": "Visual exploration of large-scale evolving software\n", "abstract": " The comprehensive understanding of today's software systems is a daunting activity, because of the sheer size and complexity that such systems exhibit. Moreover, software systems evolve, which dramatically increases the amount of data one needs to analyze in order to gain insights into such systems. Indeed, software complexity is recognized as one of the major challenges to the development and maintenance of industrial-size software projects. Our vision is a 3D visualization approach which helps software engineers build knowledge about their systems. We settled on an intuitive metaphor, which depicts software systems as cities. To validate the ideas emerging from our research, we implemented a tool called CodeCity. We devised a set of visualization techniques to support tasks related to program comprehension, design quality assessment, and evolution analysis, and applied them on large open-source\u00a0\u2026", "num_citations": "21\n", "authors": ["135"]}
{"title": "CodeCity\n", "abstract": " The analysis of large-scale software is difficult in the absence of supporting tools, due to the sheer size and complexity of today\u2019s systems. We present CODECITY, a language-independent interactive 3D visualization tool for the analysis of large object-oriented software systems. Using a city metaphor, it depicts classes as buildings and packages as districts of a \u201csoftware city\u201d. We start presenting the tool in the context of its integration in our tool chain and gradually increase the level of detail, by continuing with the system\u2019s architecture and ending with a peek into one of its main class hierarchies. We apply our tool on a set of Java, C++, and Smalltalk systems and discuss tool-related issues. Key words: software visualization, city metaphor", "num_citations": "21\n", "authors": ["135"]}
{"title": "Automated detection of code duplication clusters\n", "abstract": " I am very proud to have Dr. Radu Marinescu as my advisor. I am profoundly indebted to him for his trust in me and for seeing my skills even when I was sceptical about it. Due to his permanent encouragement I was able to understand that research is not something unreachable and too much above us, but rather something that can be done with hard work and enthusiasm. Being around him is a permanent source of inspiration to me.The experiences I\u2019ve been through in the LOOSE Research Group made me feel fortunate. The great ideas that Dani Ratiu had, expressed in his rather reserved way due to modesty, helped me many times over this project (by the way, pair programming is really fun), as well as Pepi\u2019s permanent availability to discuss algorithms (and to share the scalability progress!). I learned a lot with you guys. I would also like to thank Cristina and everyone else who tested the tool, starting with its early versions. Without the feedback I got from her, DuDe would have never become that reliable.", "num_citations": "10\n", "authors": ["135"]}
{"title": "Scripting 3d visualizations with codecity\n", "abstract": " Software visualization is a useful means to present and explore large amounts of information. However, constructing useful visualizations targeted at specific tasks is often a trial-and-error process. As a consequence, a visualization prototyping tools needs to be flexible to allow for the creation of new visualizations and also to provide an environment that grants access to its powerful mechanisms. In this paper, we report on our experience with complementing the rich graphical user interface of CODECITY, a 3D visualization tool, with a scripting environment. The scripting language gives the programmers full access to the configurability of our system, without the need for them to be exposed to the real complexity of the application. Thanks to the scripting engine, adapting CODECITY to new types of data has become easy, as we illustrate with examples.", "num_citations": "5\n", "authors": ["135"]}