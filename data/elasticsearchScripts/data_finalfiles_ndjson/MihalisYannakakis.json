{"title": "Optimization, approximation, and complexity classes\n", "abstract": " We define a natural variant of NP, MAX NP, and also a subclass called MAX SNP. These are classes of optimization problems, and in fact contain several natural, well-studied ones. We show that problems in these classes can be approximated with some bounded error. Furthermore, we show that a number of common optimization problems are complete for MAX SNP under a kind of careful transformation (called L-reduction) that preserves approximability. It follows that such a complete problem has a polynomial-time approximation scheme iff the whole class does. These results may help explain the lack of progress on the approximability of a host of optimization problems.", "num_citations": "2294\n", "authors": ["1860"]}
{"title": "Principles and methods of testing finite state machines-a survey\n", "abstract": " With advanced computer technology, systems are getting larger to fulfill more complicated tasks: however, they are also becoming less reliable. Consequently, testing is an indispensable part of system design and implementation; yet it has proved to be a formidable task for complex systems. This motivates the study of testing finite stare machines to ensure the correct functioning of systems and to discover aspects of their behavior. A finite state machine contains a finite number of states and produces outputs on state transitions after receiving inputs. Finite state machines are widely used to model systems in diverse areas, including sequential circuits, certain types of programs, and, more recently, communication protocols. In a testing problem we have a machine about which we lack some information; we would like to deduce this information by providing a sequence of inputs to the machine and observing the\u00a0\u2026", "num_citations": "1633\n", "authors": ["1860"]}
{"title": "Simple linear-time algorithms to test chordality of graphs, test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs\n", "abstract": " Chordal graphs arise naturally in the study of Gaussian elimination on sparse symmetric matrices; acyclic hypergraphs arise in the study of relational data bases. Rose, Tarjan and Lueker [SIAM J. Comput., 5 (1976), pp. 266\u2013283] have given a linear-time algorithm to test whether a graph is chordal, which Yannakakis has modified to test whether a hypergraph is acyclic. Here we develop a simplified linear-time test for graph chordality and hypergraph acyclicity. The test uses a new kind of graph (and hypergraph) search, which we call maximum cardinality search A variant of the method gives a way to selectively reduce acyclic hypergraphs, which is needed for evaluating queries in acyclic relational data bases.", "num_citations": "1392\n", "authors": ["1860"]}
{"title": "On the hardness of approximating minimization problems\n", "abstract": " We prove results indicating that it is hard to compute efficiently good approximate solutions to the Graph Coloring, Set Covering and other related minimization problems. Specifically, there is an E> 0 such that Graph Coloring cannot be approximated with ratio n\u2019unless P= NP. Set Covering cannot be approximated with ratio c log n for any c< l/4 unless NP is contained in DTIME (nP\u201d Y\u2019\u201c~\u201c). Similar results follow for related problems such as Clique Cover, Fractional Chromatic Number, Dominating Set, and others.", "num_citations": "1358\n", "authors": ["1860"]}
{"title": "Computing the minimum fill-in is NP-complete\n", "abstract": " We show that the following problem is NP-complete. Given a graph, find the minimum number of edges (fill-in) whose addition makes the graph chordal. This problem arises in the solution of sparse symmetric positive definite systems of linear equations by Gaussian elimination.", "num_citations": "1104\n", "authors": ["1860"]}
{"title": "On the desirability of acyclic database schemes\n", "abstract": " A class of database schemes, called acychc, was recently introduced. It is shown that this class has a number of desirable properties. In particular, several desirable properties that have been studied by other researchers m very different terms are all shown to be eqmvalent to acydicity. In addition, several equivalent charactenzauons of the class m terms of graphs and hypergraphs are given, and a smaple algorithm for determining acychclty is presented. Also given are several eqmvalent characterizations of those sets M of multivalued dependencies such that M is the set of muRlvalued dependencies that are the consequences of a given join dependency. Several characterizations for a conflict-free (in the sense of Lien) set of muluvalued dependencies are provided.", "num_citations": "973\n", "authors": ["1860"]}
{"title": "On generating all maximal independent sets\n", "abstract": " We present an algorithm that generates all maximal independent sets of a graph in lexicographic order, with only polynomial delay between the output of two successive independent sets. We also show that there is no polynomial-delay algorithm for generating all maximal independent sets in reverse lexicographic order, unless P=NP.", "num_citations": "968\n", "authors": ["1860"]}
{"title": "How easy is local search?\n", "abstract": " We investigate the complexity of finding locally optimal solutions to NP-hard combinatorial optimization problems. Local optimality arises in the context of local search algorithms, which try to find improved solutions by considering perturbations of the current solution (\u201cneighbors\u201d of that solution). If no neighboring solution is better than the current solution, it is locally optimal. Finding locally optimal solutions is presumably easier than finding optimal solutions. Nevertheless, many popular local search algorithms are based on neighborhood structures for which locally optimal solutions are not known to be computable in polynomial time, either by using the local search algorithms themselves or by taking some indirect route. We define a natural class PLS consisting essentially of those local search problems for which local optimality can be verified in polynomial time, and show that there are complete problems for this\u00a0\u2026", "num_citations": "905\n", "authors": ["1860"]}
{"title": "The complexity of multiterminal cuts\n", "abstract": " In the multiterminal cut problem one is given an edge-weighted graph and a subset of the vertices called terminals, and is asked for a minimum weight set of edges that separates each terminal from all the others. When the number k of terminals is two, this is simply the mincut, max-flow problem, and can be solved in polynomial time. It is shown that the problem becomes NP-hard as soon as , but can be solved in polynomial time for planar graphs for any fixed k. The planar problem is NP-hard, however, if k is not fixed. A simple approximation algorithm for arbitrary graphs that is guaranteed to come within a factor of  of the optimal cut weight is also described.", "num_citations": "817\n", "authors": ["1860"]}
{"title": "The complexity of probabilistic verification\n", "abstract": " We determine the complexity of testing whether a finite state, sequential or concurrent probabilistic program satisfies its specification expressed in linear-time temporal logic. For sequential programs, we present an algorithm that runs in time linear in the program and exponential in the specification, and also show that the problem is in PSPACE, matching the known lower bound. For concurrent programs, we show that the problem can be solved in time polynomial in the program and doubly exponential in the specification, and prove that it is complete for double exponential time. We also address these questions for specifications described by \u03c9-automata or formulas in extended temporal logic.", "num_citations": "686\n", "authors": ["1860"]}
{"title": "Towards an architecture-independent analysis of parallel algorithms\n", "abstract": " A simple and efficient method for evaluating the performance of an algorithm, rendered as a directed acyclic graph, on any parallel computer is presented. The crucial ingredient is an efficient approximation algorithm for a particular scheduling problem. The only parameter of the parallel computer needed by our method is the message-to-instruction ratio . Although the method used in this paper does not take into account the number of processors available, its application to several common algorithms shows that it is surprisingly accurate.", "num_citations": "650\n", "authors": ["1860"]}
{"title": "Shortest paths without a map\n", "abstract": " We study several versions of the shortest-path problem when the map is not known in advance, but is specified dynamically. We are seeking dynamic decision rules that optimize the worst-case ratio of the distance covered to the length of the (statically) optimal path. We describe optimal decision rules for two cases: layered graphs of width two, and two-dimensional scenes with unit square obstacles. The optimal rules turn out to be intuitive, common-sense heuristics. For slightly more general graphs and scenes, we show that no bounded ratio is possible. We also show that the computational problem of devising a strategy that achieves a given worst-case ratio to the optimum path in a graph with unknown parameters is a universal two-person game, and thus PSPACE-complete, whereas optimizing the expected ratio is #P-hard.", "num_citations": "639\n", "authors": ["1860"]}
{"title": "Node-and edge-deletion NP-complete problems\n", "abstract": " If \u03c0 is a graph property, the general node (edge) deletion problem can be stated as follows: Find the minimum number of nodes (edges), whose deletion results in a subgraph satisfying property \u03c0. In this paper we show that if \u03c0 belongs to a rather broad class of properties (the class of properties that are hereditary on induced subgraphs) then the node-deletion problem is NP-complete, and the same is true for several restrictions of it. For the same class of properties, requiring the remaining graph to be connected does not change the NP-complete status of the problem; moreover for a certain subclass, finding any\" reasonable\" approximation is also NP-complete. Edge-deletion problems seem to be less amenable to such generalizations. We show however that for several common properties (eg planar, outer-planar, line-graph, transitive digraph) the edge-deletion problem is NP-complete.", "num_citations": "614\n", "authors": ["1860"]}
{"title": "Expressing combinatorial optimization problems by linear programs\n", "abstract": " Many combinatorial optimization problems call for the optimization of a linear function over a certain polytope. Typically, these polytopes have an exponential number of facets. We explore the problem of finding small linear programming formulations when one may use any new variables and constraints. We show that expressing the matching and the Traveling Salesman Problem by a symmetric linear program requires exponential size. We relate the minimum size needed by a LP to express a polytope to a combinatorial parameter, point out some connections with communication complexity theory, and examine the vertex packing polytope for some classes of graphs.", "num_citations": "610\n", "authors": ["1860"]}
{"title": "Algorithms for acyclic database schemes\n", "abstract": " AfSSTRACT: Many real-world situations can be captured by a set of functional dependencies and a single join dependency of a particular form called acyclic [B..]. The join dependency corresponds to a natural decomposition into meaningful1 objects (an acyclic database scheme). 0ur purpose in this paper is to describe efficient a& rithms in this setting for various problems, such as computing projections, minimizing joins, inferring dependencies, and testing for dependency satisfaction.", "num_citations": "604\n", "authors": ["1860"]}
{"title": "On the approximability of trade-offs and optimal access of web sources\n", "abstract": " We study problems in multiobjective optimization, in which solutions to a combinatorial optimization problem are evaluated with respect to several cost criteria, and we are interested in the trade-off between these objectives (the so-called Pareto curve). We point out that, under very general conditions, there is a polynomially succinct curve that /spl epsiv/-approximates the Pareto curve, for any /spl epsiv/>0. We give a necessary and sufficient condition under which this approximate Pareto curve can be constructed in time polynomial in the size of the instance and 1//spl epsiv/. In the case of multiple linear objectives, we distinguish between two cases: when the underlying feasible region is convex, then we show that approximating the multi-objective problem is equivalent to approximating the single-objective problem. If however the feasible region is discrete, then we point out that the question reduces to an old and\u00a0\u2026", "num_citations": "572\n", "authors": ["1860"]}
{"title": "On the complexity of protein folding\n", "abstract": " We show that the protein folding problem in the two-dimensional H-P model is NP-complete.", "num_citations": "553\n", "authors": ["1860"]}
{"title": "The traveling salesman problem with distances one and two\n", "abstract": " We present a polynomial-time approximation algorithm with worst-case ratio 7/6 for the special case of the traveling salesman problem in which all distances are either one or two. We also show that this special case of the traveling salesman problem is MAX SNP-hard, and therefore it is unlikely that it has a polynomial-time approximation scheme.", "num_citations": "537\n", "authors": ["1860"]}
{"title": "The node-deletion problem for hereditary properties is NP-complete\n", "abstract": " We consider the family of graph problems called node-deletion problems, defined as follows; For a fixed graph property \u03a0, what is the minimum number of nodes which must be deleted from a given graph so that the resulting subgraph satisfies \u03a0? We show that if \u03a0 is nontrivial and hereditary on induced subgraphs, then the node-deletion problem for \u03a0 is NP-complete for both undirected and directed graphs.", "num_citations": "497\n", "authors": ["1860"]}
{"title": "Equivalences among relational expressions with the union and difference operators\n", "abstract": " Queries in relational databases can be formulated in terms of relational expressions using the relational operations select, project, join, union, and difference The equivalence problem for these queries is studied with query optimization m mind It ts shown that testmg eqmvalence of relational expressions with the operators select, project, join, and union is complete m the class FIt of the polynomial-time hierarchy A nonprocedural representation for queries formulated by these expressions is proposed This method of query representation can be viewed as a generahzatlon of tableaux or conjunctive queries (which are used to represent expressions with only select, project, and join) Furthermore, this method is extended to queries formulated by relatmnal expressions that also contain the difference operator, provided that the project operator is not applied to subexpresstons with the difference operator A procedure for\u00a0\u2026", "num_citations": "491\n", "authors": ["1860"]}
{"title": "The complexity of the partial order dimension problem\n", "abstract": " The dimension of a partial order P is the minimum number of linear orders whose intersection is P. There are efficient algorithms to test if a partial order has dimension 1 or 2. We prove that it is NP-complete to determine if a partial order has dimension 3. As a consequence, several other related dimension-type problems are shown to be NP-complete.", "num_citations": "477\n", "authors": ["1860"]}
{"title": "Edge dominating sets in graphs\n", "abstract": " We prove that the edge dominating set problem for graphs is -complete even when restricted to planar or bipartite graphs of maximum degree 3. We show as a corollary that the minimum maximal matching and the achromatic number problems are -complete. A new linear time algorithm for finding minimum independent edge dominating sets in trees is described, based on an observed relationship between edge dominating sets and independent sets in total graphs.", "num_citations": "469\n", "authors": ["1860"]}
{"title": "The complexity of facets (and some facets of complexity)\n", "abstract": " Many important combinatorial optimization problems, including the traveling salesman problem (TSP), the clique problem and many others, call for the optimization of a linear functional over some discrete set of vectors.", "num_citations": "443\n", "authors": ["1860"]}
{"title": "Primal-dual approximation algorithms for integral flow and multicut in trees\n", "abstract": " We study the maximum integral multicommodity flow problem and the minimum multicut problem restricted to trees. This restriction is quite rich and contains as special cases classical optimization problems such as matching and vertex cover for general graphs. It is shown that both the maximum integral multicommodity flow and the minimum multicut problem are NP-hard and MAX SNP-hard on trees, although the maximum integral flow can be computed in polynomial time if the edges have unit capacity. We present an efficient algorithm that computes a multicut and integral flow such that the weight of the multicut is at most twice the value of the flow. This gives a 2-approximation algorithm for minimum multicut and a 1/2-approximation algorithm for maximum integral multicommodity flow in trees.", "num_citations": "437\n", "authors": ["1860"]}
{"title": "Approximate max-flow min-(multi) cut theorems and their applications\n", "abstract": " Consider the multicommodity flow problem in which the object is to maximize the sum of commodities routed. We prove the following approximate max-flow min-multicut theorem:   where k is the number of commodities. Our proof is constructive; it enables us to find a multicut within  of the max flow (and hence also the optimal multicut). In addition, the proof technique provides a unified framework in which one can also analyse the case of flows with specified demands of Leighton and Rao and Klein et al. and thereby obtain an improved bound for the latter problem.", "num_citations": "392\n", "authors": ["1860"]}
{"title": "Testing finite-state machines: State identification and verification\n", "abstract": " We study the complexity of two fundamental problems in the testing of finite-state machines. 1) Distinguishing sequences (state identification). We show that it is PSPACE-complete to determine whether a finite-state machine has a preset distinguishing sequence. There are machines that have distinguishing sequences, but only of exponential length. We give a polynomial time algorithm that determines whether a finite-state machine has an adaptive distinguishing sequence. (The previous classical algorithms take exponential time.) Furthermore, if there is an adaptive distinguishing sequence, then we give an efficient algorithm that constructs such a sequence of length at most n(n/spl minus/1)/2 (which is the best possible), where n is the number of states. 2) Unique input output sequences (state verification). It is PSPACE-complete to determine whether a state of a machine has a unique input output sequence. There\u00a0\u2026", "num_citations": "356\n", "authors": ["1860"]}
{"title": "Linear approximation of shortest superstrings\n", "abstract": " We consider the following problem: given a collection of strings s1,\u2026, sm, find the shortest string s such that each si appears as a substring (a consecutive block) of s. Although this problem is known to be NP-hard, a simple greedy procedure appears to do quite well and is routinely used in DNA sequencing and data compression practice, namely: repeatedly merge the pair of (distinct) strings with maximum overlap until only one string remains. Let n denote the length of the optimal superstring. A common conjecture states that the above greedy procedure produces a superstring of length O(n) (in fact, 2n), yet the only previous nontrivial bound known for any polynomial-time algorithm is a recent O(n log n) result. We show that the greedy algorithm does in fact achieve a constant factor approximation, proving an upper bound of 4n. Furthermore, we present a simple modified version of the greedy algorithm that we show\u00a0\u2026", "num_citations": "318\n", "authors": ["1860"]}
{"title": "Near-optimal hardness results and approximation algorithms for edge-disjoint paths and related problems\n", "abstract": " We study the approximability of edge-disjoint paths and related problems. In the edge-disjoint paths (EDP) problem, we are given a network G with source\u2013sink pairs (s i, t i), 1\u2a7d i\u2a7d k, and the goal is to find a largest subset of source\u2013sink pairs that can be simultaneously connected in an edge-disjoint manner. We show that in directed networks, for any \u03b5> 0, EDP is NP-hard to approximate within m 1/2\u2212 \u03b5. We also design simple approximation algorithms that achieve essentially matching approximation guarantees for some generalizations of EDP. Another related class of routing problems that we study concerns EDP with the additional constraint that the routing paths be of bounded length. We show that, for any \u03b5> 0, bounded length EDP is hard to approximate within m 1/2\u2212 \u03b5 even in undirected networks, and give an O (m)-approximation algorithm for it. For directed networks, we show that even the single source\u2013sink\u00a0\u2026", "num_citations": "317\n", "authors": ["1860"]}
{"title": "On the approximation of maximum satisfiability\n", "abstract": " We present a 3/4 polynomial time approximation algorithm for the Maximum Satisfiability problem: Given a set of clauses, find a truth assignment that satisfies the maximum number of clauses. The algorithm applies to the weighted case as well, and involves nontrivial application of network flow techniques.", "num_citations": "312\n", "authors": ["1860"]}
{"title": "Scheduling interval-ordered tasks\n", "abstract": " We show that unit execution time jobs subject to a precedence constraint whose complement is chordal can be scheduled in linear time on m processors. Generalizations to arbitrary execution times are NP-complete.", "num_citations": "301\n", "authors": ["1860"]}
{"title": "On the complexity of Nash equilibria and other fixed points\n", "abstract": " We reexamine what it means to compute Nash equilibria and, more generally, what it means to compute a fixed point of a given Brouwer function, and we investigate the complexity of the associated problems. Specifically, we study the complexity of the following problem: given a finite game, , with 3 or more players, and given , compute an approximation within  of some (actual) Nash equilibrium. We show that approximation of an actual Nash equilibrium, even to within any nontrivial constant additive factor  in just one desired coordinate, is at least as hard as the long-standing square-root sum problem, as well as a more general arithmetic circuit decision problem that characterizes P-time in a unit-cost model of computation with arbitrary precision rational arithmetic; thus, placing the approximation problem in P, or even NP, would resolve major open problems in the complexity of numerical computation. We\u00a0\u2026", "num_citations": "292\n", "authors": ["1860"]}
{"title": "The complexity of multiway cuts\n", "abstract": " In the Multiway Cut problem we are given an edge-weighted graph and a subset of the vertices called terminals, and asked for a minimum weight set of edges that separates each terminal from all the others. When the number k of terminals is two, this is simply the min-cut, max-flow problem, and can be solved in polynomial time. We show that the problem becomes NP-hard as soon as k= 3, but can be solved in polynomial time for planar graphs for any fixed k. The planar problem is NP-hard, however, if k is not fixed. We also describe a simple approximation algorithm for arbitrary graphs that is guaranteed to come within a factor of 2\u20132/k of the optimal cut weight.", "num_citations": "264\n", "authors": ["1860"]}
{"title": "Node-deletion problems on bipartite graphs\n", "abstract": " A set of problems which has attracted considerable interest recently is the set of node-deletion problems. The general node-deletion problem can be stated as follows: Given a graph, find the minimum number of nodes whose deletion results in a subgraph satisfying property . In [LY] this problem was shown to be NP-complete for a large class of properties (the class of properties that are hereditary on induced subgraphs) using a small number of reduction schemes from the node cover problem. Since the node cover problem becomes polynomial on bipartite graphs, it might be hoped that this is the case with other node-deletion problems too.In this paper we characterize those properties for which the bipartite restriction of the node-deletion problem is polynomial and those for which it remains NP-complete. Similar results follow for analogous problems on other structures such as families of sets, hypergraphs and 0\u00a0\u2026", "num_citations": "264\n", "authors": ["1860"]}
{"title": "On notions of information transfer in VLSI circuits\n", "abstract": " Several papers have recently dealt with techniques for proving area-time lower bounds for VLSI computation by \u201ccrossing sequence\u201d methods. A number of natural questions are raised by these definitions.", "num_citations": "263\n", "authors": ["1860"]}
{"title": "On limited nondeterminism and the complexity of the VC dimension\n", "abstract": " We characterize precisely the complexity of several natural computational problems in NP, which have been proposed but not categorized satisfactorily in the literature: Computing the Vapnik\u2013Chervonenkis dimension of a 0\u20131 matrix; finding the minimum dominating set of a tournament; satisfying a Boolean expression by perturbing the default truth assignment; and several others. These problems can be solved innO(log\u00a0n)time, and thus, they are probably not NP-complete. We define two new complexity classes between P and NP, very much in the spirit of MAXNP and MAXSNP. We show that computing the V\u2013C dimension is complete for the more general class, while the other two problems are complete for the weaker class.", "num_citations": "258\n", "authors": ["1860"]}
{"title": "On the complexity of database queries\n", "abstract": " We revisit the issue of the complexity of database queries, in the light of the recent parametric refinement of complexity theory. We show that, if the query size (or the number of variables in the query) is considered as a parameter, then the relational calculus and its fragments (conjunctive queries, positive queries) are classified at appropriate levels of the so-called W hierarchy of Downey and Fellows. These results strongly suggest that the query size is inherently in the exponent of the data complexity of any query evaluation algorithm, with the implication becoming stronger as the expressibility of the query language increases. On the positive side, we show that this exponential dependence can be avoided for the extension of acyclic queries with \u2260 (but not <) inequalities.", "num_citations": "248\n", "authors": ["1860"]}
{"title": "Online minimization of transition systems\n", "abstract": " We are given a transition system implicitly through a compact representation and wish to perform simultaneously reachability analysis and minimization without constructing first the whole system graph. We present an algorithm for this problem that applies to general systems, provided we have appropriate primitive operations for manipulating blocks of states and we can determine termination; the number of operations needed to construct the minimal reachable graph is quadratic in the size of this graph. We specialize the method to obtain efficient algorithms for extended finite state machines that apply separable affine transformations on the variables.", "num_citations": "246\n", "authors": ["1860"]}
{"title": "Graph-theoretic methods in database theory\n", "abstract": " As in many areas of computer science and other disciplines, graph theoretic tools play an important role also in databases. Many concepts are best captured in terms of graphs or hypergraphs, and problems can then be formulated and solved using graph theoretic algorithms. There is a great number of such examples from schema design, dependency theory, transaction processing, query optimization, data distribution, and a host of other areas. We will not attempt to touch on the wide range of all these applications. Rather, we will concentrate on a particular, basic type of problems that has attracted a great deal of attention in the database literature over the last few years and has come to play a central role: techniques for searching graphs and computing transitive closure, and some of the applications and related problems in query processing. There is an extensive literature on these types of problems, which we\u00a0\u2026", "num_citations": "241\n", "authors": ["1860"]}
{"title": "Embedding planar graphs in four pages\n", "abstract": " A book embedding of a graph consists of an embedding of its nodes along the spine of a book (ie, a linear ordering of the nodes), and an embedding of its edges on the pages so that edges embedded on the same page do not intersect. The objective is to minimize the number of pages used. The minimum number of pages in which a graph can be embedded is called the pagenumber of the graph. The book embedding problem arises in connection with an approach to faulttolerant VLSI design [R, CLRl, CLR2]. The graph models a desired interconnection pattern among a set of processors. The processors are arranged (physically or logically) on a line and are tested to determine which ones are good and which are faulty. The good processors are interconnected via \u201cbundles\u201d of wires running parallel to the line. Each bundle functions like a stack: Scan the line from left to right and suppose that a good processor u wants to connect to some processor v to its right. At u, the connection (u, u) is pushed into one of the stack-bundles; that is,(u, Y) occupies the bottom wire of the bundle, while the other connections that are currently in this bundle are shifted up one place. At u, the connection (u, u) is popped from the stack. The problem is to realize the desired interconnection graph using the minimum number of stack-bundles. This is equivalent to the problem of embedding the graph in a book with the minimum number of pages. The pages correspond to the bundles. The constraint that edges on the same page do not intersect corresponds to the LIFO property of stacks. Computationally, the book embedding problem is hard: it is NP-complete to tell if a\u00a0\u2026", "num_citations": "238\n", "authors": ["1860"]}
{"title": "Edge-deletion problems\n", "abstract": " If  is a property on graphs or digraphs, the edge-deletion problem can be stated as follows: find the minimum number of edges whose deletion results in a subgraph (or subdigraph) satisfying property . Several well-studied graph problems can be formulated as edge-deletion problems.In this paper we show that the edge-deletion problem is NP-complete for the following properties: (1) without cycles of specified length l, or of any length , (2) connected and degree-constrained, (3) outerplanar, (4) transitive digraph, (5) line-invertible, (6) bipartite, (7) transitively orientable. For problems (5), (6), (7) we determine the best possible bounds on the node-degrees for which the problems remain NP-complete.", "num_citations": "231\n", "authors": ["1860"]}
{"title": "Multi-objective model checking of Markov decision processes\n", "abstract": " We study and provide efficient algorithms for multi-objective model checking problems for Markov Decision Processes (MDPs). Given an MDP, M, and given multiple linear-time (\u03c9-regular or LTL) properties \u03d5                                    i                 , and probabilities r                                    i                 \u2009\u2208\u2009[0,1], i\u2009=\u20091,...,k, we ask whether there exists a strategy \u03c3 for the controller such that, for all i, the probability that a trajectory of M controlled by \u03c3 satisfies \u03d5                                    i                  is at least r                                    i                 . We provide an algorithm that decides whether there exists such a strategy and if so produces it, and which runs in time polynomial in the size of the MDP. Such a strategy may require the use of both randomization and memory. We also consider more general multi-objective \u03c9-regular queries, which we motivate with an application to assume-guarantee compositional reasoning for probabilistic\u00a0\u2026", "num_citations": "225\n", "authors": ["1860"]}
{"title": "A note on succinct representations of graphs\n", "abstract": " Galperin and Wigderson (Inform. and Control 56 (1983), 183-198) showed that certain trivial graph properties become NP-complete when the graph is represented in a particular exponentially succinct way. We show that under the same representation, graph properties that are ordinarily NP-complete become complete for nondeterministic exponential time.\u00a9 1986 Academic Press. Inc.", "num_citations": "216\n", "authors": ["1860"]}
{"title": "Black box checking\n", "abstract": " Two main approaches are used for increasing the quality of systems: in model checking, one checks properties of a known design of a system; in testing, one usually checks whether a given implementation, whose internal structure is often unknown, conforms with an abstract design. We are interested in the combination of these techniques. Namely, we would like to be able to test whether an implementation with unknown structure satisfies some given properties. We propose and formalize this problem of black box checking and suggest several algorithms. Since the input to black box checking is not given initially, as is the case in the classical model of computation, but is learned through experiments, we propose a computational model based on games with incomplete information. We use this model to analyze the complexity of the problem. We also address the more practical question of finding an\u00a0\u2026", "num_citations": "212\n", "authors": ["1860"]}
{"title": "Minimum and maximum delay problems in real-time systems\n", "abstract": " We consider a finite-state system with a finite number of clocks, where the transitions may depend on the values of the clocks, and may reset some of the clocks. We address the complexity and provide algorithms for the following problems. Suppose that the system starts from a given current state with a given assignment of values to the clocks. Can a given target state ever appear in the history of the system? What is the earliest time it can appear? What is the latest time it can appear?", "num_citations": "212\n", "authors": ["1860"]}
{"title": "The approximation of maximum subgraph problems\n", "abstract": " We consider the following class of problems: given a graph, find the maximum number of nodes inducing a subgraph that satisfies a desired property \u03c0, such as planar, acyclic, bipartite, etc. We show that this problem is hard to approximate for any property \u03c0 on directed or undirected graphs that is nontrivial and hereditary on induced subgraphs.", "num_citations": "208\n", "authors": ["1860"]}
{"title": "High-probability parallel transitive-closure algorithms\n", "abstract": " There is a straightforward algorithm for computing the transitive-closure of an n-node graph in  time on an EREW-PRAM, using  processors, or indeed with  processors if serial matrix multiplication in  time can be done. This algorithm is within a log factor of optimal in work (processor-time product), for solving the all-pairs transitive-closure problem for dense graphs. However, this algorithm is far from optimal when either (a) the graph is sparse, or (b) we want to solve the single-source transitive-closure problem. It would be ideal to have an  algorithm for transitive-closure that took about e processors for the single-source problem on a graph with n nodes and  arcs, or about  processors for the all-pairs problem on the same graph. While an algorithm that good cannot be offered, algorithms with the following performance can be offered. (1) For single-source,  time with  processors, provided \u00a0\u2026", "num_citations": "205\n", "authors": ["1860"]}
{"title": "The maximum k-colorable subgraph problem for chordal graphs\n", "abstract": " We discuss the problems of finding maximum and connected maximum k-colorable subgraphs in chordal graphs. We prove that the problems are polynomially solvable when k is fixed and NP-hard when k is not fixed. As a special case, we can find in polynomial time the maximum induced tree and forest of a chordal graph.", "num_citations": "191\n", "authors": ["1860"]}
{"title": "Properties of acyclic database schemes\n", "abstract": " There is a class of database descriptions, involving one \u201cacyclic\u201d join dependency and a collection of functional dependencies, and nothing else, that appears powerful enough to describe most any real-world body of data in relational database terms. Further, this class has many desirable properties. Some properties make operations like updates and the selection of joins to implement a query over a universal relation especially easy. Other properties of interest were studied by other researchers who described the same class in radically different terms, and found desirable properties in their own contexts. It is the purpose of this paper to define the class formally, to give its important properties and the equivalences with the other classes mentioned, and to explain the importance of each property. This paper is intended to summarize the results that will appear in more detail in [FMU] and [BFMY].", "num_citations": "186\n", "authors": ["1860"]}
{"title": "Batch sizing and job sequencing on a single machine\n", "abstract": " We study a single-machine scheduling problem in which the items to be processed have to be batched as well as sequenced. Since processed items become available in batches, flow times are defined to be the same for all items in the same batch. A constant set-up delay is incurred between consecutive batches. For any fixed, but arbitrary item sequence, we present an algorithm that finds a sequence of batches such that the total flow time of the items is minimized; we prove that for a set ofn items, the algorithm runs inO(n) time. We show that, among all sequences, the one leading to the minimum flow time has the items in non-decreasing order of running times. Thus, the optimal algorithm for the combined problem, called thebatch-sizing problem, runs inO(n logn) time. We also prove that this algorithm yields an improved solution to a scheduling problem recently studied by Baker [1].", "num_citations": "180\n", "authors": ["1860"]}
{"title": "Verifying temporal properties of finite-state probabilistic programs\n", "abstract": " The complexity of testing whether a finite-state (sequential or concurrent) probabilistic program satisfies its specification expressed in linear temporal logic. For sequential programs an exponential-time algorithm is given and it is shown that the problem is in PSPACE; this improves the previous upper bound by two exponentials and matches the known lower bound. For concurrent programs is is shown that the problem is complete in double exponential time, improving the previous upper and lower bounds by one exponential each. These questions are also addressed for specifications described by omega-automata or formulas in extended temporal logic.", "num_citations": "180\n", "authors": ["1860"]}
{"title": "The complexity of restricted spanning tree problems\n", "abstract": " The complexity of the foUowmg class of problems Is investigated: Given a distance matrix, fred the shortest spanning tree that is isomorphic to a given prototype. Several classical combinatorial problems, both easy and hard, fall into this category for an appropriate choice of the family of prototypes, for example, taking the family to be the set of all paths gives the traveling salesman problem or taking the family to be the set of all 2-stars gives the weighted matching problem It is shown that the complexity of these problems depends explicitly on the rate of growth of a sLmple parameter of the family of prototypes.", "num_citations": "180\n", "authors": ["1860"]}
{"title": "A polynomial algorithm for the min-cut linear arrangement of trees\n", "abstract": " An algorithm is presented that finds a min-cut linear arrangement of a tree in O(n log n) time. An extension of the algorithm determines the number of pebbles needed to play the black and white pebble game on a tree.", "num_citations": "179\n", "authors": ["1860"]}
{"title": "On complexity as bounded rationality\n", "abstract": " It has been hoped that computational approaches can help resolve some well-known paradoxes in game theory. We prove that tf the repeated prisoner\u2019s dilemma M played by finite automata with less than exponentially(in the number of rounds) many states, then cooperation can be achieved an equilibrium(while with ezponentiaily many states, defection is the only equtlibrzum). We furthermore prove a generalization to arbitrary games and Pareto optimai points. Finally, we present a general model of poiynomially computable games, and characterize in terms of fami! iar complexity classes ranging from NP to NEXP the natural problems that arise in relation with such games.", "num_citations": "177\n", "authors": ["1860"]}
{"title": "Adaptive model checking\n", "abstract": " We consider the case where inconsistencies are present between a system and its corresponding model, used for automatic verification. Such inconsistencies can be the result of modeling errors or recent modifications of the system. Despite such discrepancies we can still attempt to perform automatic verification. In fact, as we show, we can sometimes exploit the verification results to assist in automatically learning the required updates to the model. In a related previous work, we have suggested the idea of black box checking, where verification starts without any model, and the model is obtained while repeated verification attempts are performed. Under the current assumptions, an existing inaccurate (but not completely obsolete) model is used to expedite the updates. We use techniques from black box testing and machine learning. We present an implementation of the proposed methodology called AMC\u00a0\u2026", "num_citations": "160\n", "authors": ["1860"]}
{"title": "Multiway cuts in directed and node weighted graphs\n", "abstract": " Given an undirected graph G=(V, E) with weights on the edges and a set of k terminals, Sl, s2 9 9 sk, a mulliway cut is a set of edges whose removal disconnects every pair of terminals. This generalizes the fundamental notion of an s-t cut to the case of more than two terminals. Whereas the problem of computing a minimum s-t cut can be solved in polynomial time using a maximum flow algorithm, the problem of computing a minimum weight multiway cut was shown to be NP-hard and MAX SNP-hard even if k is fixed and k> 3, by Dahlhaus, Johnson, Papadimitriou, Seymour and Yannakakis [DJPSY]. As a consequence of the max SNP-hardness, this problem does not have a polynomial time approximation scheme unless P= NP [ALMSS]. Dalhaus et. al. also give a (2-5) factor approximation algorithm for the problem. For trees, a minimum multiway cut can be found in polynomial time using dynamic programming [CR\u00a0\u2026", "num_citations": "158\n", "authors": ["1860"]}
{"title": "Recursive Markov chains, stochastic grammars, and monotone systems of nonlinear equations\n", "abstract": " We define Recursive Markov Chains (RMCs), a class of finitely presented denumerable Markov chains, and we study algorithms for their analysis. Informally, an RMC consists of a collection of finite-state Markov chains with the ability to invoke each other in a potentially recursive manner. RMCs offer a natural abstract model for probabilistic programs with procedures. They generalize, in a precise sense, a number of well-studied stochastic models, including Stochastic Context-Free Grammars (SCFG) and Multi-Type Branching Processes (MT-BP). We focus on algorithms for reachability and termination analysis for RMCs: what is the probability that an RMC started from a given state reaches another target state, or that it terminates? These probabilities are in general irrational, and they arise as (least) fixed point solutions to certain (monotone) systems of nonlinear equations associated with RMCs. We address both\u00a0\u2026", "num_citations": "155\n", "authors": ["1860"]}
{"title": "Approximate max-flow min-(multi) cut theorems and their applications\n", "abstract": " Consider the multicommodity flow problem in which the object is to maximize the sum of commodities routed. We prove the following approximate max-flow min-multicut theorem: min multicut O (log k)~ max flow~ min multicut, where k is the number of commodities. Our proof is constructive; it enables us to find a multicut within O (log k) of the max flow (and hence also the optimal multicut). In addition, the proof technique provides a unified framework in which one can also analyse the case of flows with specified demands, of Leighton-Rao and Klein et, al., and thereby obtain an improved bound for the latter problem.", "num_citations": "151\n", "authors": ["1860"]}
{"title": "2. Computational complexity\n", "abstract": " 1 INTRODUCTION 19 2 PRELIMINARIES 22 3 THE CLASS PLS 26 3.1 Definition 26 3.2 Basic properties 27 3.3 PLS-reductions and PLS-completeness 29 3.4 A first PLS-complete problem 30 4 PLS-COMPLETE PROBLEMS 32 4.1 Definitions 32 4.2 Reductions 37 5 COMPLEXITY OF THE STANDARD LOCAL SEARCH ALGORITHM 42 5.1 The neighborhood and transition graphs 42 5.2 Tight PLS-reductions 43 5.3 Running time of local search heuristics 45 5.4 The standard local optimum problem 47 6 PARALLEL COMPLEXITY 49 6.1 Parallel complexity of the local optimality problem 49 6.2 Parallel complexity of local search problems 50 7 LOCAL VERSUS GLOBAL OPTIMALITY 52 8 CONCLUSIONS 54", "num_citations": "141\n", "authors": ["1860"]}
{"title": "Black box checking\n", "abstract": " Two main approaches are used for increasing the quality of systems: in model checking, one checks properties of a known design of a system; in testing, one usually checks whether a given implementation, whose internal structure is often unknown, conforms with an abstract design. We are interested in the combination of these techniques. Namely, we would like to be able to test whether an implementation with unknown structure satis es some given properties. We propose and formalize this problem of black box checking and suggest several algorithms. Since the input to black box checking is not given initially, as is the case in the classical model of computation, but is learned through experiments, we propose a computational model based on games with incomplete information. We use this model to analyze the complexity of the problem. We also address the more practical question of nding an approach that can detect errors in the implementation before completing an exhaustive search.", "num_citations": "139\n", "authors": ["1860"]}
{"title": "Multiobjective query optimization\n", "abstract": " The optimization of queries in distributed database systems is known to be subject to delicate trade-offs. For example, the Mariposa database system allows users to specify a desired delay-cost tradeoff (that is, to supply a decreasing function u (d), specifying how much the user is willing to pay in order to receive the query results within time d); Mariposa divides a query graph into horizontal \u201cstrides,\u201d analyzes each stride, and uses a greedy heuristic to find the \u201cbest\u201d plan for all strides. We show that Mariposa's greedy heuristic can be arbitrarily far from the desired optimum. Applying a recent approach in multiobjective optimization algorithms to this problem, we show that the optimum cost-delay trade-off (Pareto) curve in Mariposa's framework can be approximated fast within any desired accuracy. We also present a polynomial algorithm for the general multiobjective query optimization problem, which approximates\u00a0\u2026", "num_citations": "137\n", "authors": ["1860"]}
{"title": "Multiway cuts in node weighted graphs\n", "abstract": " A (2\u22122/k) approximation algorithm is presented for the node multiway cut problem, thus matching the result of Dahlhaus et\u00a0al. (SIAM J. Comput. 23 (4) (1994) 864\u2013894) for the edge version of this problem. This is done by showing that the associated LP-relaxation always has a half-integral optimal solution.", "num_citations": "131\n", "authors": ["1860"]}
{"title": "Linear programming without the matrix\n", "abstract": " We study the problem facing a set of decision-makers who must select values for the variables of a linear program, when only parts of the matrix are available to each of them. The goal is to find a feasible solution that is as close to the true optimum as possible, When each decision-maker decides one variable and knows all constraints involving this variable, we show that the worst-case ratio is related tc, the maximum number of variables appearing in each constraint, and a simple\u201csafe\u201d heuristic is optimal. Since this problem involves constrained optimization, there is a novel criterion, besides the competitive ratio, comparing the performance of a heuristic with the best feasible distributed algorithm, perhaps specializing on the current inst ante; we show different bounds for this parameter. When the constraint structure(the zero-nonzero pattern of the matrix) is known in advance, and the variables are partitioned bet\u00a0\u2026", "num_citations": "130\n", "authors": ["1860"]}
{"title": "Locking policies: Safety and freedom from deadlock\n", "abstract": " A database consists of ellliflc.\\'yvhich reLlte to each other in certain ways, i, e., they satisfy cerltlin cOllsistency con-straints. Many tinles, when a user updates the database, he nlay have to update tcnlporarily these constraints in order tC) eventuaIIy tI'an s1'0I'111 the database into a new, consistent statC. For this I'eas0 n, at0 nlic actions by the sanlC user arc grouped together into units of consistency called transactiolls. In practice. a transaction nlay be either an interactive session, or the execution of a user update progranl. When, however, nlany'transactions access and update the SanlC database cOI1curTently, there rnust he sonle kind of coordination to ensure that the resulting sequence of interleaved atonlic actions (or schedule) is correct. This TlleanS that all transactions have a consistent view of the data. and furthernlore the database is Icft at the end in sonle consistent state, This required coordination is achic\\cd via the COIl-currency cOlltrol, nechalllsfn () f the database.('onsiderahle research effort has heen devoted recently to the theoretical aspects or the design of such a systenl! ECiLTl. SLR, SK, KS, Pa, PBR, KPI. The theory of databasc concurrency control bears a superficial silllilarity to the () perating systenlS-inspiI'ed concLI rrency 1he0 I'Y [K [vI,('[) 1. The difference is lhtl {in operating systeIllS\\\\le have cooperating, Ill0nitoring. dnd 1110n itored. processes, and the goal is to prevent had cooperation or Tllanagenlent (eg indetcrnlinacy. deadlocks) In databases, we have a population of'users that arc una\\\\'are of each other's pres-", "num_citations": "126\n", "authors": ["1860"]}
{"title": "Market equilibrium under separable, piecewise-linear, concave utilities\n", "abstract": " We consider Fisher and Arrow--Debreu markets under additively separable, piecewise-linear, concave utility functions and obtain the following results. For both market models, if an equilibrium exists, there is one that is rational and can be written using polynomially many bits. There is no simple necessary and sufficient condition for the existence of an equilibrium: The problem of checking for existence of an equilibrium is NP-complete for both market models; the same holds for existence of an \u03b5-approximate equilibrium, for \u03b5 = O(n\u22125). Under standard (mild) sufficient conditions, the problem of finding an exact equilibrium is in PPAD for both market models. Finally, building on the techniques of Chen et al. [2009a] we prove that under these sufficient conditions, finding an equilibrium for Fisher markets is PPAD-hard.", "num_citations": "120\n", "authors": ["1860"]}
{"title": "Algebraic dependencies\n", "abstract": " A new kind of data dependencies called algebraic dependencies, which generalize all previously known kinds, are proposed. A complete axiomatization of algebraic dependencies in terms of simple algebraic rewriting rules is given. In the process the expressive power of tableaux is characterized exactly, thus solving an open problem of Aho, Sagiv, and Ullman; we show that it is NP-complete to tell whether a tableau is realizable by an expression; and an interesting dual interpretation of the chase procedure is given. We also show that algebraic dependencies over a language augmented to contain union and set difference can express arbitrary domain-independent predicates of finite index over finite relations. In the class or embedded implicational dependencies recently-and independently\u2014introduced by Fagin is shown to coincide with our algebraic dependencies. Based on this, we give a simple proof of Fagin\u00a0\u2026", "num_citations": "120\n", "authors": ["1860"]}
{"title": "Searching a fixed graph\n", "abstract": " We study three combinatorial optimization problems related to searching a graph that is known in advance, for an item that resides at an unknown node. The search ratio of a graph is the optimum competitive ratio (the worst-case ratio of the distance traveled before the unknown node is visited, over the distance between the node and a fixed root, minimized over all Hamiltonian walks of the graph). We also define the randomized search ratio (we minimize over all distributions of permutations). Finally, the traveling repairman problem seeks to minimize the expected time of visit to the unknown node, given some distribution on the nodes. All three of these novel graph-theoretic parameters are NP-complete \u2014and MAXSNP-hard \u2014 to compute exactly; we present interesting approximation algorithms for each. We also show that the randomized search ratio and the traveling repairman problem are related via\u00a0\u2026", "num_citations": "117\n", "authors": ["1860"]}
{"title": "Markov decision processes and regular events\n", "abstract": " Desirable properties of the infinite histories of a finite state Markov Decision Process are specified in terms of a finite number of events represented as \u03c9-regular sets. An infinite history of the process produces a reward which depends on the properties it satisfies. We investigate the existence of optimal policies and provide algorithms for the construction of such policies.", "num_citations": "117\n", "authors": ["1860"]}
{"title": "Pfaffian orientations, 0\u20131 permanents, and even cycles in directed graphs\n", "abstract": " The following issues in computational complexity remain imprecisely understood: The striking difference in the complexities of computing the permanent and determinant of a matrix despite their similar looking formulae, the complexity of checking if a directed graph contains an even length cycle, and the complexity of computing the number of perfect matchings in a graph using Pfaffian orientations. Via polynomial time equivalences, we show inter-relationships among these issues.", "num_citations": "117\n", "authors": ["1860"]}
{"title": "Testing finite state machines: fault detection\n", "abstract": " We present simple randomized algorithms for the fault detection problem: Given a specification in the form of a deterministic finite state machine A and an implementation machine B, determine whether B is equal to A. If A has n states and p inputs, then in randomized polynomial time we can construct with high probability a checking sequence of length O(pn4 log n), i.e., a sequence that detects all faulty machines with at most n states. Better bounds can be obtained in certain cases. The techniques generalize to partially specified finite state machines.", "num_citations": "116\n", "authors": ["1860"]}
{"title": "Four pages are necessary and sufficient for planar graphs\n", "abstract": " Recent activity in the TCS community on this problem is motivated largely by an approach to fault-tolerant VLSI design [R, CLR1, CLR2]. Briefly, processing elements have to be interconnected to form a desired pattern. The processing elements are arranged (logically or physically) on a line. There are\" bundles\" of wires running over the line. The faulty elements are bypassed, and the healthy ones are interconnected through the bundles. If the bundles function as stacks, then the minimum number of bundles required to realise an interconnection graph is equal to its pagenumber.Computationally, the book embedding problem is hard: it is NP-complete to tall if a planar graph can be embedded in two pages [W, CLR2]. Note that in this case the crux of the problem is in the node-embedding part, as once this is fixed, it is easy to tell whether the edges can be embedded in two pages. The subproblem of embedding\u00a0\u2026", "num_citations": "116\n", "authors": ["1860"]}
{"title": "The complexity of testing whether a graph is a superconcentrator\n", "abstract": " Pinsker [7] and Val&t [8] defined an (m, n)-concentrator to be a directed acyclic graph G=(V, E) with m designated input nodes and n designated output nodes (m Z n) such that for each subset of n input nodes, there exist n vertex-disjoint paths from these input nodes to the output nodes. Concentrators have been used as building blocks for the construction of superconcentrators. A superconcentrator [8] is a directed acyclic graph G=(V, E) with n designated input nodes and n designated output nodes such that for any set S of m< n inputs and any set T of m outputs there exist m node-disjoint paths connecting S to T. A very surprising result due to Valiant [8] is the existence of superconcentrators with n inputs and O (n) edges. Valiant\u2019s result relied on a non-constructive counting argument, and so did the subsequent refinement due to Pippenger [6 1. Until", "num_citations": "116\n", "authors": ["1860"]}
{"title": "Scheduling opposing forests\n", "abstract": " A basic problem of deterministic scheduling theory is that of scheduling n unit-length tasks on m identical processors subject to precedence constraints so as to meet a given overall deadline. T. C. Hu\u2019s classic \u201clevel algorithm\u201d can be used to solve this problem in linear time if the precedence constraints have the form of an in-forest or an out-forest. We show that a polynomial time algorithm for a wider class of precedence constraints is unlikely, by proving the problem to be NP-complete for precedence constraints that are the disjoint union of an in-forest and an out-forest (the \u201copposing forests\u201d of our title). However, for any fixed value of m we show that this problem can be solved in polynomial time for such precedence constraints. For the special case of  we provide a linear time algorithm.", "num_citations": "114\n", "authors": ["1860"]}
{"title": "Recursive Markov chains, stochastic grammars, and monotone systems of nonlinear equations\n", "abstract": " We introduce and study Recursive Markov Chains (RMCs), which extend ordinary finite state Markov chains with the ability to invoke other Markov chains in a potentially recursive manner. They offer a natural abstract model for probabilistic programs with procedures, and are a probabilistic version of Recursive State Machines. RMCs generalize Stochastic Context-Free Grammars (SCFG) and multi-type Branching Processes, and are intimately related to Probabilistic Pushdown Systems. We focus here on termination and reachability analysis for RMCs. We present both positive and negative results for the general class of RMCs, as well as for important subclasses including SCFGs.", "num_citations": "112\n", "authors": ["1860"]}
{"title": "Optimal scheduling of products with two subassemblies on a single machine\n", "abstract": " We consider a single machine job shop in which subassemblies of two different types are made and then assembled into products. The time required for each type is known. A fixed changeover cost is incurred whenever the machine is switched over from one type to the other. We describe and analyze an efficient algorithm for minimizing the total flow time of the products. Applications to the automated manufacture of circuit boards are noted.", "num_citations": "112\n", "authors": ["1860"]}
{"title": "On the complexity of local search\n", "abstract": " We prove a number of complexity results on the computational paradigm of local op-timality. Our main results are thes", "num_citations": "111\n", "authors": ["1860"]}
{"title": "An efficient algorithm for minimizing real-time transition systems\n", "abstract": " Time plays an important role in the operation and correct functioning of many systems. The last few years there has been significant progress in the modeling and formal analysis of such systems that incorporate real time. An attractive model for real time systems that is being extensively investigated is the timed automaton (or timed graph) model [4, 14]. This is an extension of the familiar finite automaton (state machine) model by a finite set of clock variables. The transitions of the automaton may depend on the values of the clocks and can have the effect of resetting some of the clocks. The values of the clock variables increase continuously and spontaneously with the passage of time. The model has provided the foundation for studying a number of issues concerning real time systems, including the computation of teachability information among the states of the system, providing bounds on the delays of events, the\u00a0\u2026", "num_citations": "110\n", "authors": ["1860"]}
{"title": "Recursive Markov decision processes and recursive stochastic games\n", "abstract": " We introduce Recursive Markov Decision Processes (RMDPs) and Recursive Simple Stochastic Games (RSSGs), and study the decidability and complexity of algorithms for their analysis and verification. These models extend Recursive Markov Chains (RMCs), introduced in [EY05a, EY05b] as a natural model for verification of probabilistic procedural programs and related systems involving both recursion and probabilistic behavior. RMCs define a class of denumerable Markov chains with a rich theory generalizing that of stochastic context-free grammars and multi-type branching processes, and they are also intimately related to probabilistic pushdown systems. RMDPs & RSSGs extend RMCs with one controller or two adversarial players, respectively. Such extensions are useful for modeling nondeterministic and concurrent behavior, as well as modeling a system\u2019s interactions with an environment\u00a0\u2026", "num_citations": "104\n", "authors": ["1860"]}
{"title": "On Datalog vs polynomial time\n", "abstract": " We show that certain monotonic polynomial time queries are not expressible in variants of Datalog. The proof techniques include lower bounds for monotone circuit size and a \"Pumping Lemma\" for Datalog queries.", "num_citations": "100\n", "authors": ["1860"]}
{"title": "Serializability by locking\n", "abstract": " The power of locking as a primitive for controlling concurrency in database systems is examined. It is accepted that the concurrent execution (or schedule) of different transactions must be serializable; that is, it must behave like a serial schedule, one in which the transactions run one at a time. It is shown that locking cannot achieve the full power of serializability. An exact characterization of the schedules that can be produced if locking is used to control concurrency is given for two versions of serializability. In the first one, state serializabdity, only the effect of the schedule on the database is taken into account. In the second one, vww serializability, the view of the data received by the transactions is also taken into account. We show that it is possible to determine efficiently whether the transactions in a given set can be permitted to run safely by themselves without the need of any control while ensuring view\u00a0\u2026", "num_citations": "96\n", "authors": ["1860"]}
{"title": "A theory of safe locking policies in database systems\n", "abstract": " When several transacuons access (read and update) the same database concurrently, there must be some kind of coordmauon to ensure that all transacuons receive a consistent view of the data Such coordination is usually achieved by locking the transactions according to some locking policy A locking policy that guarantees the preservation of consistency of the database is called safe Necessary and sufficient conditions are found for a locking pohcy to be safe, but it is shown that in general it is NP-complete to test for these conditions. However, when the database has a given structure, a simple set of rules which is sufficient for safety and, moreover, necessary for a wide class of natural locking pohcles is developed", "num_citations": "94\n", "authors": ["1860"]}
{"title": "Efficiently computing succinct trade-off curves\n", "abstract": " Trade-off (aka Pareto) curves are typically used to represent the trade-off among different objectives in multiobjective optimization problems. Although trade-off curves are exponentially large for typical combinatorial optimization problems (and infinite for continuous problems), it was observed in Papadimitriou and Yannakakis [On the approximability of trade-offs and optimal access of web sources, in: Proc. 41st IEEE Symp. on Foundations of Computer Science, 2000] that there exist polynomial size \u03b5 approximations for any \u03b5> 0, and that under certain general conditions, such approximate \u03b5-Pareto curves can be constructed in polynomial time. In this paper we seek general-purpose algorithms for the efficient approximation of trade-off curves using as few points as possible. In the case of two objectives, we present a general algorithm that efficiently computes an \u03b5-Pareto curve that uses at most 3 times the number of\u00a0\u2026", "num_citations": "91\n", "authors": ["1860"]}
{"title": "Bin packing with discrete item sizes, Part I: Perfect packing theorems and the average case behavior of optimal packings\n", "abstract": " We consider the one-dimensional bin packing problem with unit-capacity bins and item sizes chosen according to the discrete uniform distribution U{j,k},  where each item size in {1/k,2/k,. . .,j/k} has probability 1/j of being chosen. Note that for fixed j,k as  the discrete distributions U{mj,mk} approach the continuous distribution U(0,j/k], where the item sizes are chosen uniformly from the interval (0,j/k]. We show that average-case behavior can differ substantially between the two types of distributions. In particular, for all j,k with j < k-1, there exist on-line algorithms that have constant expected wasted space under U{j,k}, whereas no on-line algorithm has even o(n1/2 ) expected waste under U(0,u] for any . Our U{j,k} result is an application of a general theorem of Courcoubetis and Weber [C. Courcoubetis and R.R. Weber, Probab. Engrg. Inform. Sci., 4 (1990), pp. 447--460] that covers all discrete\u00a0\u2026", "num_citations": "91\n", "authors": ["1860"]}
{"title": "The analysis of local search problems and their heuristics\n", "abstract": " Local search is a widely used, general approach to solving hard optimization problems. An optimization problem has a set of solutions and a cost function that assigns a numerical value to every solution. The goal is to find an optimal solution, one that has the minimum (or maximum) cost. To obtain a local search heuristic for an optimization problem, one superimposes a neighborhood structure on the solutions, that is, one specifies for each solutions a set of\" neighboring\" solutions. The heuristic starts from some initial solution that is constructed by some other algorithm, or just generated randomly, and from then on it keeps moving to a better neighboring solution, as long as there is one, until finally it terminates at a locally optimal solution, one that does not have a better neighbor.This scheme has been used successfully for several problems. The two important issues concerning a local search heuristic are:(1) the\u00a0\u2026", "num_citations": "87\n", "authors": ["1860"]}
{"title": "Recursive concurrent stochastic games\n", "abstract": " We study Recursive Concurrent Stochastic Games (RCSGs), extending our recent analysis of recursive simple stochastic games [14, 15] to a concurrent setting where the two players choose moves simultaneously and independently at each state. For multi-exit games, our earlier work already showed undecidability for basic questions like termination, thus we focus on the important case of single-exit RCSGs (1-RCSGs).               We first characterize the value of a 1-RCSG termination game as the least fixed point solution of a system of nonlinear minimax functional equations, and use it to show PSPACE decidability for the quantitative termination problem. We then give a strategy improvement technique, which we use to show that player 1 (maximizer) has \u03b5-optimal randomized Stackless & Memoryless (r-SM) strategies, while player 2 (minimizer) has optimal r-SM strategies. Thus, such games are r-SM\u00a0\u2026", "num_citations": "85\n", "authors": ["1860"]}
{"title": "Markov decision processes and regular events\n", "abstract": " Desirable properties of the infinite histories of a finite-state Markov decision process are specified in terms of a finite number of events represented as /spl omega/-regular sets. An infinite history of the process produces a reward which depends on the properties it satisfies. The authors investigate the existence of optimal policies and provide algorithms for the construction of such policies.", "num_citations": "81\n", "authors": ["1860"]}
{"title": "Testing the universal instance assumption\n", "abstract": " Among the first steps taken in the design of a relational database management system is the identification of the database scheme, ie, the formats (or schemes) of the relations into with the data are to be stored. Selection of the database scheme is guided by knowledge of certain constraints on the data, eg, functional or multivalued dependencies [4-71. The mechanism proposed by Codd, normalization, prevents certain types of anomalous behavior due to modifications of the data. The process involves decomposing relation schemes into subschemes which satisfy a normal form. Bernstein\u2019s synthesis algorithm operates in a similar manner. it is expected that the information contained in an undecomposed relation (or universal instance) will be accurately reflected in its decomposed version. Conversely, we may require that modifications to the decomposed relations produce new relations which would result from modifying the universal instance and then decomposing it.(Observe, though, that the normalization approach prevents anomalous behaviors", "num_citations": "81\n", "authors": ["1860"]}
{"title": "Suboptimal cuts: Their enumeration, weight and number\n", "abstract": " We present (1) an algorithm that enumerates the cuts of a network by increasing weight with polynomial delay, and (2) an algorithm that computes the k-th minimum weight in polynomial time for fixed k We also show that in the case of undirected networks there are only polynomially many cuts that have the k-th minimum weight for any fixed k (whereas directed networks can have exponentially many different minimum cuts).", "num_citations": "80\n", "authors": ["1860"]}