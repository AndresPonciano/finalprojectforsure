{"title": "Foreshadow: Extracting the keys to the intel {SGX} kingdom with transient out-of-order execution\n", "abstract": " Trusted execution environments, and particularly the Software Guard eXtensions (SGX) included in recent Intel x86 processors, gained significant traction in recent years. A long track of research papers, and increasingly also real-world industry applications, take advantage of the strong hardware-enforced confidentiality and integrity guarantees provided by Intel SGX. Ultimately, enclaved execution holds the compelling potential of securely offloading sensitive computations to untrusted remote platforms.", "num_citations": "720\n", "authors": ["328"]}
{"title": "Cookieless monster: Exploring the ecosystem of web-based device fingerprinting\n", "abstract": " The web has become an essential part of our society and is currently the main medium of information delivery. Billions of users browse the web on a daily basis, and there are single websites that have reached over one billion user accounts. In this environment, the ability to track users and their online habits can be very lucrative for advertising companies, yet very intrusive for the privacy of users. In this paper, we examine how web-based device fingerprinting currently works on the Internet. By analyzing the code of three popular browser-fingerprinting code providers, we reveal the techniques that allow websites to track users without the need of client-side identifiers. Among these techniques, we show how current commercial fingerprinting approaches use questionable practices, such as the circumvention of HTTP proxies to discover a user's real IP address and the installation of intrusive browser plugins. At the\u00a0\u2026", "num_citations": "520\n", "authors": ["328"]}
{"title": "FPDetective: dusting the web for fingerprinters\n", "abstract": " In the modern web, the browser has emerged as the vehicle of choice, which users are to trust, customize, and use, to access a wealth of information and online services. However, recent studies show that the browser can also be used to invisibly fingerprint the user: a practice that may have serious privacy and security implications.", "num_citations": "365\n", "authors": ["328"]}
{"title": "VeriFast: A powerful, sound, predictable, fast verifier for C and Java\n", "abstract": " VeriFast is a prototype verification tool for single-threaded and multithreaded C and Java programs. In this paper, we first describe the basic symbolic execution approach in some formal detail. Then we zoom in on two technical aspects: the approach to permission accounting, including fractional permissions, precise predicates, and counting permissions; and the approach to lemma function termination in the presence of dynamically-bound lemma function calls. Finally, we describe three ongoing efforts: application to JavaCard programs, integration of shape analysis, and application to Linux device drivers.", "num_citations": "361\n", "authors": ["328"]}
{"title": "Key reinstallation attacks: Forcing nonce reuse in WPA2\n", "abstract": " We introduce the key reinstallation attack. This attack abuses design or implementation flaws in cryptographic protocols to reinstall an already-in-use key. This resets the key's associated parameters such as transmit nonces and receive replay counters. Several types of cryptographic Wi-Fi handshakes are affected by the attack. All protected Wi-Fi networks use the 4-way handshake to generate a fresh session key. So far, this 14-year-old handshake has remained free from attacks, and is even proven secure. However, we show that the 4-way handshake is vulnerable to a key reinstallation attack. Here, the adversary tricks a victim into reinstalling an already-in-use key. This is achieved by manipulating and replaying handshake messages. When reinstalling the key, associated parameters such as the incremental transmit packet number (nonce) and receive packet number (replay counter) are reset to their initial value\u00a0\u2026", "num_citations": "352\n", "authors": ["328"]}
{"title": "You are what you include: large-scale evaluation of remote javascript inclusions\n", "abstract": " JavaScript is used by web developers to enhance the interactivity of their sites, offload work to the users' browsers and improve their sites' responsiveness and user-friendliness, making web pages feel and behave like traditional desktop applications. An important feature of JavaScript, is the ability to combine multiple libraries from local and remote sources into the same page, under the same namespace. While this enables the creation of more advanced web applications, it also allows for a malicious JavaScript provider to steal data from other scripts and from the page itself. Today, when developers include remote JavaScript libraries, they trust that the remote providers will not abuse the power bestowed upon them.", "num_citations": "324\n", "authors": ["328"]}
{"title": "Noninterference through secure multi-execution\n", "abstract": " A program is defined to be noninterferent if its outputs cannot be influenced by inputs at a higher security level than their own. Various researchers have demonstrated how this property (or closely related properties) can be achieved through information flow analysis, using either a static analysis (with a type system or otherwise), or using a dynamic monitoring system. We propose an alternative approach, based on a technique we call secure multi-execution. The main idea is to execute a program multiple times, once for each security level, using special rules for I/O operations. Outputs are only produced in the execution linked to their security level. Inputs are replaced by default inputs except in executions linked to their security level or higher. Input side effects are supported by making higher-security-level executions reuse inputs obtained in lower-security-level threads. We show that this approach is interesting\u00a0\u2026", "num_citations": "319\n", "authors": ["328"]}
{"title": "Sancus: Low-cost trustworthy extensible networked devices with a zero-software trusted computing base\n", "abstract": " In this paper we propose Sancus, a security architecture for networked embedded devices. Sancus supports extensibility in the form of remote (even third-party) software installation on devices while maintaining strong security guarantees. More specifically, Sancus can remotely attest to a software provider that a specific software module is running uncompromised, and can authenticate messages from software modules to software providers. Software modules can securely maintain local state, and can securely interact with other software modules that they choose to trust. The most distinguishing feature of Sancus is that it achieves these security guarantees without trusting any infrastructural software on the device. The Trusted Computing Base (TCB) on the device is only the hardware. Moreover, the hardware cost of Sancus is low.", "num_citations": "234\n", "authors": ["328"]}
{"title": "A systematic evaluation of transient execution attacks and defenses\n", "abstract": " Research on transient execution attacks including Spectre and Meltdown showed that exception or branch misprediction events might leave secret-dependent traces in the CPU\u2019s microarchitectural state. This observation led to a proliferation of new Spectre and Meltdown attack variants and even more ad-hoc defenses (eg, microcode and software patches). Both the industry and academia are now focusing on finding effective defenses for known issues. However, we only have limited insight on residual attack surface and the completeness of the proposed defenses.", "num_citations": "218\n", "authors": ["328"]}
{"title": "Telling your secrets without page faults: Stealthy page table-based attacks on enclaved execution\n", "abstract": " Protected module architectures, such as Intel SGX, enable strong trusted computing guarantees for hardware-enforced enclaves on top a potentially malicious operating system. However, such enclaved execution environments are known to be vulnerable to a powerful class of controlled-channel attacks. Recent research convincingly demonstrated that adversarial system software can extract sensitive data from enclaved applications by carefully revoking access rights on enclave pages, and recording the associated page faults. As a response, a number of state-of-the-art defense techniques has been proposed that suppress page faults during enclave execution.", "num_citations": "201\n", "authors": ["328"]}
{"title": "Breaking the memory secrecy assumption\n", "abstract": " Many countermeasures exist that attempt to protect against buffer overflow attacks on applications written in C and C++. The most widely deployed countermeasures rely on artificially introducing randomness in the memory image of the application. StackGuard and similar systems, for instance, will insert a random value before the return address on the stack, and Address Space Layout Randomization (ASLR) will make the location of stack and/or heap less predictable for an attacker.", "num_citations": "200\n", "authors": ["328"]}
{"title": "FlowFox: a web browser with flexible and precise information flow control\n", "abstract": " We present FlowFox, the first fully functional web browser that implements a precise and general information flow control mechanism for web scripts based on the technique of secure multi-execution. We demonstrate how FlowFox subsumes many ad-hoc script containment countermeasures developed over the last years. We also show that FlowFox is compatible with the current web, by investigating its behavior on the Alexa top-500 web sites, many of which make intricate use of JavaScript.", "num_citations": "189\n", "authors": ["328"]}
{"title": "Why MAC address randomization is not enough: An analysis of Wi-Fi network discovery mechanisms\n", "abstract": " We present several novel techniques to track (unassociated) mobile devices by abusing features of the Wi-Fi standard. This shows that using random MAC addresses, on its own, does not guarantee privacy. First, we show that information elements in probe requests can be used to fingerprint devices. We then combine these fingerprints with incremental sequence numbers, to create a tracking algorithm that does not rely on unique identifiers such as MAC addresses. Based on real-world datasets, we demonstrate that our algorithm can correctly track as much as 50% of devices for at least 20 minutes. We also show that commodity Wi-Fi devices use predictable scrambler seeds. These can be used to improve the performance of our tracking algorithm. Finally, we present two attacks that reveal the real MAC address of a device, even if MAC address randomization is used. In the first one, we create fake hotspots to\u00a0\u2026", "num_citations": "188\n", "authors": ["328"]}
{"title": "Implicit dynamic frames: Combining dynamic frames and separation logic\n", "abstract": " The dynamic frames approach has proven to be a powerful formalism for specifying and verifying object-oriented programs. However, it requires writing and checking many frame annotations. In this paper, we propose a variant of the dynamic frames approach that eliminates the need to explicitly write and check frame annotations. Reminiscent of separation logic\u2019s frame rule, programmers write access assertions inside pre- and postconditions instead of writing frame annotations. From the precondition, one can then infer an upper bound on the set of locations writable or readable by the corresponding method. We implemented our approach in a tool, and used it to automatically verify several challenging programs, including subject-observer, iterator and linked list.", "num_citations": "174\n", "authors": ["328"]}
{"title": "A quick tour of the VeriFast program verifier\n", "abstract": " This paper describes the main features of VeriFast, a sound and modular program verifier for C and Java. VeriFast takes as input a number of source files annotated with method contracts written in separation logic, inductive data type and fixpoint definitions, lemma functions and proof steps. The verifier checks that (1) the program does not perform illegal operations such as dividing by zero or illegal memory accesses and (2) that the assumptions described in method contracts hold in each execution.               Although VeriFast supports specifying and verifying deep data structure properties, it provides an interactive verification experience as verification times are consistently low and errors can be diagnosed using its symbolic debugger. VeriFast and a large number of example programs are available online at:                                         http://www.cs.kuleuven.be/~bartj/verifast", "num_citations": "162\n", "authors": ["328"]}
{"title": "The VeriFast program verifier\n", "abstract": " This note describes a separation-logic-based approach for the specification and verification of safety properties of pointer-manipulating imperative programs. We describe the approach for the C language. The safety properties to be verified are specified as annotations in the source code, in the form of function preconditions and postconditions expressed as separation logic assertions. To enable rich specifications, the user may include additional annotations that define inductive datatypes, primitive recursive pure functions over these datatypes, and abstract predicates (ie named, parameterized assertions). A restricted form of existential quantification is supported in assertions in the form of pattern matching. Verification is based on forward symbolic execution, where memory is represented as a separate conjunction of points-to assertions and abstract predicate assertions, and data values are represented as first-order logic terms with a set of constraints. Abstract predicates must be folded and unfolded explicitly using ghost statements. Rewritings of the abstract state that require induction, or derivations of facts over data values that require induction, can be done by defining lemma functions, which are like ordinary C functions except that it is checked that they terminate. Specifically, when a lemma function performs a recursive call, either the recursive call must apply to a strict subset of memory, or one of its parameters must be an inductive value whose size decreases at each recursive call.Assertions over data values are delegated to an SMT solver, formulated as queries against an axiomatization of the inductive datatypes and recursive pure\u00a0\u2026", "num_citations": "156\n", "authors": ["328"]}
{"title": "Foreshadow-NG: Breaking the virtual memory abstraction with transient out-of-order execution\n", "abstract": " In January 2018, we discovered the Foreshadow transient execution attack (USENIX Security\u201918) targeting Intel SGX technology. Intel\u2019s subsequent investigation of our attack uncovered two closely related variants, which we collectively call Foreshadow-NG and which Intel refers to as L1 Terminal Fault. Current analyses focus mostly on mitigation strategies, providing only limited insight into the attacks themselves and their consequences. The aim of this report is to alleviate this situation by thoroughly analyzing Foreshadow-type attacks and their implications in the light of the emerging transient execution research area. At a high level, whereas previous generation Meltdown-type attacks are limited to reading privileged supervisor data within the attacker\u2019s virtual address space, Foreshadow-NG attacks completely bypass the virtual memory abstraction by directly exposing cached physical memory contents to unprivileged applications and guest virtual machines. We review mitigation strategies proposed by Intel, and explain how Foreshadow-NG necessitates additional OS and hypervisor-level defense mechanisms on top of existing Meltdown mitigations.", "num_citations": "147\n", "authors": ["328"]}
{"title": "Seven months' worth of mistakes: A longitudinal study of typosquatting abuse\n", "abstract": " Typosquatting is the act of purposefully registering a domain name that is a mistype of a popular domain name. It is a concept that has been known and studied for over 15 years, yet still thoroughly practiced up until this day. While previous typosquatting studies have always taken a snapshot of the typosquatting landscape or base their longitudinal results only on domain registration data, we present the first content-based, longitudinal study of typosquatting. We collected data about the typosquatting domains of the 500 most popular sites of the Internet every day, for a period of seven months, and we use this data to establish whether previously discovered typosquatting trends still hold today, and to provide new results and insights in the typosquatting landscape. In particular we reveal that, even though 95% of the popular domains we investigated are actively targeted by typosquatters, only few trademark owners protect themselves against this practice by proactively registering their own typosquatting domains. We take advantage of the longitudinal aspect of our study to show, among other results, that typosquatting domains change hands from typosquatters to legitimate owners and vice versa, and that typosquatters vary their monetization strategy by hosting different types of pages over time. Our study also reveals that a large fraction of typosquatting domains can be traced back to a small group of typosquatting page hosters and that certain top-level domains are much more prone to typosquatting than others.", "num_citations": "140\n", "authors": ["328"]}
{"title": "SGX-Step: A practical attack framework for precise enclave execution control\n", "abstract": " Protected module architectures such as Intel SGX hold the promise of protecting sensitive computations from a potentially compromised operating system. Recent research convincingly demonstrated, however, that SGX's strengthened adversary model also gives rise to to a new class of powerful, low-noise side-channel attacks leveraging first-rate control over hardware. These attacks commonly rely on frequent enclave preemptions to obtain fine-grained side-channel observations. A maximal temporal resolution is achieved when the victim state is measured after every instruction. Current state-of-the-art enclave execution control schemes, however, do not generally achieve such instruction-level granularity.", "num_citations": "129\n", "authors": ["328"]}
{"title": "Fallout: Leaking data on meltdown-resistant cpus\n", "abstract": " Meltdown and Spectre enable arbitrary data leakage from memory via various side channels. Short-term software mitigations for Meltdown are only a temporary solution with a significant performance overhead. Due to hardware fixes, these mitigations are disabled on recent processors. In this paper, we show that Meltdown-like attacks are still possible on recent CPUs which are not vulnerable to Meltdown. We identify two behaviors of the store buffer, a microarchitectural resource to reduce the latency for data stores, that enable powerful attacks. The first behavior, Write Transient Forwarding forwards data from stores to subsequent loads even when the load address differs from that of the store. The second, Store-to-Leak exploits the interaction between the TLB and the store buffer to leak metadata on store addresses. Based on these, we develop multiple attacks and demonstrate data leakage, control flow recovery\u00a0\u2026", "num_citations": "126\n", "authors": ["328"]}
{"title": "Dismantling megamos crypto: Wirelessly lockpicking a vehicle immobilizer\n", "abstract": " The Megamos Crypto transponder is used in one of the most widely deployed electronic vehicle immobilizers. It is used among others in most Audi, Fiat, Honda, Volkswagen and Volvo cars. Such an immobilizer is an anti-theft device which prevents the engine of the vehicle from starting when the corresponding transponder is not present. This transponder is a passive RFID tag which is embedded in the key of the vehicle.", "num_citations": "123\n", "authors": ["328"]}
{"title": "Plundervolt: Software-based fault injection attacks against Intel SGX\n", "abstract": " Dynamic frequency and voltage scaling features have been introduced to manage ever-growing heat and power consumption in modern processors. Design restrictions ensure frequency and voltage are adjusted as a pair, based on the current load, because for each frequency there is only a certain voltage range where the processor can operate correctly. For this purpose, many processors (including the widespread Intel Core series) expose privileged software interfaces to dynamically regulate processor frequency and operating voltage.In this paper, we demonstrate that these privileged interfaces can be reliably exploited to undermine the system\u2019s security. We present the Plundervolt attack, in which a privileged software adversary abuses an undocumented Intel Core voltage scaling interface to corrupt the integrity of Intel SGX enclave computations. Plundervolt carefully controls the processor\u2019s supply voltage\u00a0\u2026", "num_citations": "118\n", "authors": ["328"]}
{"title": "JSand: complete client-side sandboxing of third-party JavaScript without browser modifications\n", "abstract": " The inclusion of third-party scripts in web pages is a common practice. A recent study has shown that more than half of the Alexa top 10000 sites include scripts from more than 5 different origins. However, such script inclusions carry risks, as the included scripts operate with the privileges of the including website.", "num_citations": "117\n", "authors": ["328"]}
{"title": "Expressive modular fine-grained concurrency specification\n", "abstract": " Compared to coarse-grained external synchronization of operations on data structures shared between concurrent threads, fine-grained, internal synchronization can offer stronger progress guarantees and better performance. However, fully specifying operations that perform internal synchronization modularly is a hard, open problem. The state of the art approaches, based on linearizability or on concurrent abstract predicates, have important limitations on the expressiveness of specifications. Linearizability does not support ownership transfer, and the concurrent abstract predicates-based specification approach requires hardcoding a particular usage protocol. In this paper, we propose a novel approach that lifts these limitations and enables fully general specification of fine-grained concurrent data structures. The basic idea is that clients pass the ghost code required to instantiate an operation's specification for a\u00a0\u2026", "num_citations": "117\n", "authors": ["328"]}
{"title": "Fides: Selectively hardening software application components against kernel-level or process-level malware\n", "abstract": " Protecting commodity operating systems against software exploits is known to be challenging, because of their sheer size. The same goes for key software applications such as web browsers or mail clients. As a consequence, a significant fraction of internet-connected computers is infected with malware.", "num_citations": "116\n", "authors": ["328"]}
{"title": "Efficient isolation of trusted subsystems in embedded systems\n", "abstract": " Many embedded systems have relatively strong security requirements because they handle confidential data or support secure electronic transactions. A prototypical example are payment terminals. To ensure that sensitive data such as cryptographic keys cannot leak, security-critical parts of these systems are implemented as separate chips, and hence physically isolated from other parts of the system.               But isolation can also be implemented in software. Higher-end computing platforms are equipped with hardware support to facilitate the implementation of virtual memory and virtual machine monitors. However many embedded systems lack such hardware features.               In this paper, we propose a design for a generic and very lightweight hardware mechanism that can support an efficient implementation of isolation for several subsystems that share the same processor and memory space. A\u00a0\u2026", "num_citations": "116\n", "authors": ["328"]}
{"title": "PAriCheck: an efficient pointer arithmetic checker for C programs\n", "abstract": " Buffer overflows are still a significant problem in programs written in C and C++. In this paper we present a bounds checker, called PAriCheck, that inserts dynamic runtime checks to ensure that attackers are not able to abuse buffer overflow vulnerabilities. The main approach is based on checking pointer arithmetic rather than pointer dereferences when performing bounds checks. The checks are performed by assigning a unique label to each object and ensuring that the label is associated with each memory location that the object inhabits. Whenever pointer arithmetic occurs, the label of the base location is compared to the label of the resulting arithmetic. If the labels differ, an out-of-bounds calculation has occurred. Benchmarks show that PAriCheck has a very low performance overhead compared to similar bounds checkers. This paper demonstrates that using bounds checkers for programs or parts of programs\u00a0\u2026", "num_citations": "113\n", "authors": ["328"]}
{"title": "On the importance of the separation-of-concerns principle in secure software engineering\n", "abstract": " The separation-of-concerns principle is one of the essential principles in software engineering. It says that software should be decomposed in such a way that different \u201cconcerns\u201d or aspects of the problem at hand are solved in well-separated modules or parts of the software. Yet, many security experts feel uneasy about trying to isolate security-related concerns, because security is such a pervasive property of a piece of software. And in fact, separating security-related concerns such as access control, or defensive input checking, is indeed very hard to achieve with current software engineering techniques.While the authors fully agree with the observation that security is a pervasive property, they argue in this position paper that attempts to separate security aspects from other aspects of an application (even though in many cases not completely successful) are a necessary means to raise the security level of most applications. The two main arguments are: increased flexibility of the security mechanisms (leading to easier adaptation to unanticipated or evolving risks), and better-focused efforts of the few security experts in the development team, leading to fewer security design and implementation errors.", "num_citations": "110\n", "authors": ["328"]}
{"title": "Secure compilation to protected module architectures\n", "abstract": " A fully abstract compiler prevents security features of the source language from being bypassed by an attacker operating at the target language level. Unfortunately, developing fully abstract compilers is very complex, and it is even more so when the target language is an untyped assembly language. To provide a fully abstract compiler that targets untyped assembly, it has been suggested to extend the target language with a protected module architecture\u2014an assembly-level isolation mechanism which can be found in next-generation processors. This article provides a fully abstract compilation scheme whose source language is an object-oriented, high-level language and whose target language is such an extended assembly language. The source language enjoys features such as dynamic memory allocation and exceptions. Secure compilation of first-order method references, cross-package inheritance, and\u00a0\u2026", "num_citations": "106\n", "authors": ["328"]}
{"title": "LVI: Hijacking transient execution through microarchitectural load value injection\n", "abstract": " The recent Spectre attack first showed how to inject incorrect branch targets into a victim domain by poisoning microarchitectural branch prediction history. In this paper, we generalize injection-based methodologies to the memory hierarchy by directly injecting incorrect, attacker-controlled values into a victim\u2019s transient execution. We propose Load Value Injection (LVI) as an innovative technique to reversely exploit Meltdown-type microarchitectural data leakage. LVI abuses that faulting or assisted loads, executed by a legitimate victim program, may transiently use dummy values or poisoned data from various microarchitectural buffers, before eventually being re-issued by the processor. We show how LVI gadgets allow to expose victim secrets and hijack transient control flow. We practically demonstrate LVI in several proof-of-concept attacks against Intel SGX enclaves, and we discuss implications for traditional\u00a0\u2026", "num_citations": "105\n", "authors": ["328"]}
{"title": "Advanced Wi-Fi attacks using commodity hardware\n", "abstract": " We show that low-layer attacks against Wi-Fi can be implemented using user-modifiable firmware. Hence cheap off-the-shelf Wi-Fi dongles can be used carry out advanced attacks. We demonstrate this by implementing five low-layer attacks using open source Atheros firmware. The first attack consists of unfair channel usage, giving the user a higher throughput while reducing that of others. The second attack defeats countermeasures designed to prevent unfair channel usage. The third attack performs continuous jamming, making the channel unusable for other devices. For the fourth attack we implemented a selective jammer, allowing one to jam specific frames already in the air. The fifth is a novel channel-based Man-in-the-Middle (MitM) attack, enabling reliable manipulation of encrypted traffic.", "num_citations": "104\n", "authors": ["328"]}
{"title": "All your biases belong to us: Breaking rc4 in wpa-tkip and {TLS}\n", "abstract": " We present new biases in RC4, break the Wi-Fi Protected Access Temporal Key Integrity Protocol (WPA-TKIP), and design a practical plaintext recovery attack against the Transport Layer Security (TLS) protocol. To empirically find new biases in the RC4 keystream we use statistical hypothesis tests. This reveals many new biases in the initial keystream bytes, as well as several new longterm biases. Our fixed-plaintext recovery algorithms are capable of using multiple types of biases, and return a list of plaintext candidates in decreasing likelihood. To break WPA-TKIP we introduce a method to generate a large number of identical packets. This packet is decrypted by generating its plaintext candidate list, and using redundant packet structure to prune bad candidates. From the decrypted packet we derive the TKIP MIC key, which can be used to inject and decrypt packets. In practice the attack can be executed within an hour. We also attack TLS as used by HTTPS, where we show how to decrypt a secure cookie with a success rate of 94% using 9\u2022 2 27 ciphertexts. This is done by injecting known data around the cookie, abusing this using Mantin\u2019s ABSAB bias, and brute-forcing the cookie by traversing the plaintext candidates. Using our traffic generation technique, we are able to execute the attack in merely 75 hours.", "num_citations": "92\n", "authors": ["328"]}
{"title": "Secure compilation to modern processors\n", "abstract": " We present a secure (fully abstract) compilation scheme to compile an object-based high-level language to low-level machine code. Full abstraction is achieved by relying on a fine-grained program counter-based memory access protection scheme, which is part of our low-level target language. We discuss why standard compilers fail to provide full abstraction and introduce enhancements needed to achieve this goal. We prove that our enhanced compilation scheme provides full abstraction from our high-level source language to our low-level target language. Lastly, we show by means of a prototype implementation that our low-level language with fine-grained memory access control can be realized efficiently on modern commodity platforms.", "num_citations": "91\n", "authors": ["328"]}
{"title": "Sancus 2.0: A low-cost security architecture for IoT devices\n", "abstract": " The Sancus security architecture for networked embedded devices was proposed in 2013 at the USENIX Security conference. It supports remote (even third-party) software installation on devices while maintaining strong security guarantees. More specifically, Sancus can remotely attest to a software provider that a specific software module is running uncompromised and can provide a secure communication channel between software modules and software providers. Software modules can securely maintain local state and can securely interact with other software modules that they choose to trust. Over the past three years, significant experience has been gained with applications of Sancus, and several extensions of the architecture have been investigated\u2014both by the original designers as well as by independent researchers. Informed by these additional research results, this journal version of the Sancus paper\u00a0\u2026", "num_citations": "90\n", "authors": ["328"]}
{"title": "Ariadne: A minimal approach to state continuity\n", "abstract": " Protected-module architectures such as Intel SGX provide strong isolation guarantees to sensitive parts of applications while the system is up and running. Unfortunately systems in practice crash, go down for reboots or lose power at unexpected moments in time. To deal with such events, additional security measures need to be taken to guarantee that stateful modules will either recover their state from the last stored state, or fail-stop on detection of tampering with that state. More specifically, protected-module architectures need to provide a security primitive that guarantees that (1) attackers cannot present a stale state as being fresh (ie rollback protection),(2) once a module accepted a specific input, it will continue execution on that input or never advance, and (3) an unexpected loss of power must never leave the system in a state from which it can never resume execution (ie liveness guarantee).", "num_citations": "88\n", "authors": ["328"]}
{"title": "Safe concurrency for aggregate objects with invariants\n", "abstract": " Developing safe multithreaded software systems is difficult due to the potential unwanted interference among concurrent threads. This paper presents a flexible methodology for object-oriented programs that protects object structures against inconsistency due to race conditions. It is based on a recent methodology for single-threaded programs where developers define aggregate object structures using an ownership system and declare invariants over them. The methodology is supported by a set of language elements and by both a sound modular static verification method and run-time checking support. The paper reports on preliminary experience with a prototype implementation.", "num_citations": "87\n", "authors": ["328"]}
{"title": "WebJail: least-privilege integration of third-party components in web mashups\n", "abstract": " In the last decade, the Internet landscape has transformed from a mostly static world into Web 2.0, where the use of web applications and mashups has become a daily routine for many Internet users. Web mashups are web applications that combine data and functionality from several sources or components. Ideally, these components contain benign code from trusted sources. Unfortunately, the reality is very different. Web mashup components can misbehave and perform unwanted actions on behalf of the web mashup's user.", "num_citations": "86\n", "authors": ["328"]}
{"title": "Generics of a higher kind\n", "abstract": " With Java 5 and C# 2.0, first-order parametric polymorphism was introduced in mainstream object-oriented programming languages under the name of generics. Although the first-order variant of generics is very useful, it also imposes some restrictions: it is possible to abstract over a type, but the resulting type constructor cannot be abstracted over. This can lead to code duplication. We removed this restriction in Scala, by allowing type constructors as type parameters and abstract type members. This paper presents the design and implementation of the resulting type constructor polymorphism. Furthermore, we study how this feature interacts with existing object-oriented constructs, and show how it makes the language more expressive.", "num_citations": "83\n", "authors": ["328"]}
{"title": "Automatic and precise client-side protection against CSRF attacks\n", "abstract": " A common client-side countermeasure against Cross Site Request Forgery (CSRF) is to strip session and authentication information from malicious requests. The difficulty however is in determining when a request is malicious. Existing client-side countermeasures are typically too strict, thus breaking many existing websites that rely on authenticated cross-origin requests, such as sites that use third-party payment or single sign-on solutions.               The contribution of this paper is the design, implementation and evaluation of a request filtering algorithm that automatically and precisely identifies expected cross-origin requests, based on whether they are preceded by certain indicators of collaboration between sites. We formally show through bounded-scope model checking that our algorithm protects against CSRF attacks under one specific assumption about the way in which good sites collaborate cross\u00a0\u2026", "num_citations": "78\n", "authors": ["328"]}
{"title": "Bitsquatting: Exploiting bit-flips for fun, or profit?\n", "abstract": " Over the last fifteen years, several types of attacks against domain names and the companies relying on them have been observed. The well-known cybersquatting of domain names gave way to typosquatting, the abuse of a user's mistakes when typing a URL in her browser's address bar. Recently, a new attack against domain names surfaced, namely bitsquatting. In bitsquatting, an attacker leverages random bit-errors occurring in the memory of commodity computers and smartphones, to redirect Internet traffic to attacker-controlled domains.", "num_citations": "77\n", "authors": ["328"]}
{"title": "On the bright side of type classes: instance arguments in Agda\n", "abstract": " We present instance arguments: an alternative to type classes and related features in the dependently typed, purely functional programming language/proof assistant Agda. They are a new, general type of function arguments, resolved from call-site scope in a type-directed way. The mechanism is inspired by both Scala's implicits and Agda's existing implicit arguments, but differs from both in important ways. Our mechanism is designed and implemented for Agda, but our design choices can be applied to other programming languages as well. Like Scala's implicits, we do not provide a separate structure for type classes and their instances, but instead rely on Agda's standard dependently typed records, so that standard language mechanisms provide features that are missing or expensive in other proposals. Like Scala, we support the equivalent of local instances. Unlike Scala, functions taking our new arguments are\u00a0\u2026", "num_citations": "77\n", "authors": ["328"]}
{"title": "CsFire: Transparent client-side mitigation of malicious cross-domain requests\n", "abstract": " Protecting users in the ubiquitous online world is becoming more and more important, as shown by web application security \u2013 or the lack thereof \u2013 making the mainstream news. One of the more harmful attacks is cross-site request forgery (CSRF), which allows an attacker to make requests to certain web applications while impersonating the user without their awareness. Existing client-side protection mechanisms do not fully mitigate the problem or have a degrading effect on the browsing experience of the user, especially with web 2.0 techniques such as AJAX, mashups and single sign-on. To fill this gap, this paper makes three contributions: first, a thorough traffic analysis on real-world traffic quantifies the amount of cross-domain traffic and identifies its specific properties. Second, a client-side enforcement policy has been constructed and a Firefox extension, named CsFire (CeaseFire), has been\u00a0\u2026", "num_citations": "75\n", "authors": ["328"]}
{"title": "A survey of customizability in operating systems research\n", "abstract": " An important goal of an operating system is to make computing and communication resources available in a fair and efficient way to the applications that will run on top of it. To achieve this result, the operating system implements a number of policies for allocating resources to, and sharing resources among applications, and it implements safety mechanisms to guard against misbehaving applications. However, for most of these allocation and sharing tasks, no single optimal policy exists. Different applications may prefer different operating system policies to achieve their goals in the best possible way. A customizable or adaptable operating system is an operating system that allows for flexible modification of important system policies. Over the past decade, a wide range of approaches for achieving customizability has been explored in the operating systems research community. In this survey, an overview of these\u00a0\u2026", "num_citations": "75\n", "authors": ["328"]}
{"title": "Runtime countermeasures for code injection attacks against C and C++ programs\n", "abstract": " The lack of memory safety in C/C++ often leads to vulnerabilities. Code injection attacks exploit these vulnerabilities to gain control over the execution flow of applications. These attacks have played a key role in many major security incidents. Consequently, a huge body of research on countermeasures exists. We provide a comprehensive and structured survey of vulnerabilities and countermeasures that operate at runtime. These countermeasures make different trade-offs in terms of performance, effectivity, compatibility, etc., making it hard to evaluate and compare countermeasures in a given context. We define a classification and evaluation framework on the basis of which countermeasures can be assessed.", "num_citations": "69\n", "authors": ["328"]}
{"title": "Implicit dynamic frames\n", "abstract": " An important, challenging problem in the verification of imperative programs with shared, mutable state is the frame problem in the presence of data abstraction. That is, one must be able to specify and verify upper bounds on the set of memory locations a method can read and write without exposing that method's implementation. Separation logic is now widely considered the most promising solution to this problem. However, unlike conventional verification approaches, separation logic assertions cannot mention heap-dependent expressions from the host programming language, such as method calls familiar to many developers. Moreover, separation logic-based verifiers are often based on symbolic execution. These symbolic execution-based verifiers typically do not support non-separating conjunction, and some of them rely on the developer to explicitly fold and unfold predicate definitions. Furthermore, several\u00a0\u2026", "num_citations": "68\n", "authors": ["328"]}
{"title": "Parser combinators in Scala\n", "abstract": " Parser combinators are well-known in functional programming languages such as Haskell. In this paper, we describe how they are implemented as a library in Scala, a functional object-oriented language. Thanks to Scala\u2019s flexible syntax, we are able to closely approximate the EBNF notation supported by dedicated parser generators. For the uninitiated, we first explain the concept of parser combinators by developing a minimal library from scratch. We then turn to the existing Scala library, and discuss its features using various examples.", "num_citations": "66\n", "authors": ["328"]}
{"title": "An automatic verifier for Java-like programs based on dynamic frames\n", "abstract": " Data abstraction is crucial in the construction of modular programs, since it ensures that internal changes in one module do not propagate to other modules. In object-oriented programs, classes typically enforce data abstraction by providing access to their internal state only through methods. By using method calls in method contracts, data abstraction can be extended to specifications. In this paper, methods used for this purpose must be side-effect free, and are called pure methods.               We present an approach to the automatic verification of object- oriented programs that use pure methods for data abstraction. The cornerstone of our approach is the solution to the framing problem, i.e. client code must be able to determine whether state changes affect the return values of pure methods. More specifically, we extend each method contract with a method footprint, an upper bound on the memory locations\u00a0\u2026", "num_citations": "65\n", "authors": ["328"]}
{"title": "Developing secure applications through aspect-oriented programming\n", "abstract": " Abstract Aspect-Oriented Programming represents a (if not the most) promising approach to improve the software development process in cases where application requirements that seem to be well-separated result in software behavior that crosscuts the basic decomposition of the application. The domain of software security is an excellent real-world concern that requires sophisticated solutions to this well-known challenge of separation of concerns.In this paper, we report upon our experiences in using AspectJ to secure application software in a manageable way. Our case studies illustrate the effectiveness of AOP technology and show encouraging results, though we also highlight some challenges to be addressed in the further development of aspect-oriented software development technology.", "num_citations": "64\n", "authors": ["328"]}
{"title": "Extended protection against stack smashing attacks without performance loss\n", "abstract": " In this paper we present an efficient countermeasure against stack smashing attacks. Our countermeasure does not rely on secret values (such as canaries) and protects against attacks that are not addressed by state-of-the-art countermeasures. Our technique splits the standard stack into multiple stacks. The allocation of data types to one of the stacks is based on the chances that a specific data element is either a target of attacks and/or an attack vector. We have implemented our solution in a C-compiler for Linux. The evaluation shows that the overhead of using our countermeasure is negligible", "num_citations": "62\n", "authors": ["328"]}
{"title": "A taxonomy of causes of software vulnerabilities in internet software\n", "abstract": " At the root of almost every security incident on the Internet are one or more software vulnerabilities, ie security-related bugs in the software that can be exploited by an attacker to perform actions he should not be able to perform. Analysis of vulnerability alerts as distributed by organisations like CERT ([CER]) or SANS ([SAN]), and analysis of causes of actual incidents shows that many vulnerabilities can be traced back to a relatively small number of causes: software developers are making the same mistakes over and over again. The goal of this paper is to propose a structured taxonomy of the most frequently occuring causes of vulnerabilities. Such a taxonomy can be useful in a number of scenarios: as an aid for developers, to avoid common pitfalls, as didactical material for students in software engineering or as a \u201cchecklist\u201d for software testers or auditors. Due to space limitations, examples and discussion of related work are omitted in this paper. In a longer technical report ([Pie02]), the reader can find examples of all categories of vulnerabilities, and an extensive discussion of related work.", "num_citations": "62\n", "authors": ["328"]}
{"title": "A tale of two worlds: Assessing the vulnerability of enclave shielding runtimes\n", "abstract": " This paper analyzes the vulnerability space arising in Trusted Execution Environments (TEEs) when interfacing a trusted enclave application with untrusted, potentially malicious code. Considerable research and industry effort has gone into developing TEE runtime libraries with the purpose of transparently shielding enclave application code from an adversarial environment. However, our analysis reveals that shielding requirements are generally not well-understood in real-world TEE runtime implementations. We expose several sanitization vulnerabilities at the level of the Application Binary Interface (ABI) and the Application Programming Interface (API) that can lead to exploitable memory safety and side-channel vulnerabilities in the compiled enclave. Mitigation of these vulnerabilities is not as simple as ensuring that pointers are outside enclave memory. In fact, we demonstrate that state-of-the-art mitigation\u00a0\u2026", "num_citations": "61\n", "authors": ["328"]}
{"title": "Nemesis: Studying microarchitectural timing leaks in rudimentary CPU interrupt logic\n", "abstract": " Recent research on transient execution vulnerabilities shows that current processors exceed our levels of understanding. The prominent Meltdown and Spectre attacks abruptly revealed fundamental design flaws in CPU pipeline behavior and exception handling logic, urging the research community to systematically study attack surface from microarchitectural interactions. We present Nemesis, a previously overlooked side-channel attack vector that abuses the CPU's interrupt mechanism to leak microarchitectural instruction timings from enclaved execution environments such as Intel SGX, Sancus, and TrustLite. At its core, Nemesis abuses the same subtle microarchitectural behavior that enables Meltdown, ie, exceptions and interrupts are delayed until instruction retirement. We show that by measuring the latency of a carefully timed interrupt, an attacker controlling the system software is able to infer instruction\u00a0\u2026", "num_citations": "61\n", "authors": ["328"]}
{"title": "Soundsquatting: Uncovering the use of homophones in domain squatting\n", "abstract": " In this paper we present soundsquatting, a previously unreported type of domain squatting which we uncovered during analysis of cybersquatting domains. In soundsquatting, an attacker takes advantage of homophones, i.e., words that sound alike, and registers homophone-including variants of popular domain names. We explain why soundsquatting is different from existing domain-squatting attacks, and describe a tool for the automatic generation of soundsquatting domains. Using our tool, we discover that attackers are already aware of the principles of soundsquatting and are monetizing them in various unethical and illegal ways. In addition, we register our own soundsquatting domains and study the population of users who reach our monitors, recording a monthly average of more than 1,700 non-bot page requests. Lastly, we show how sound-dependent users are particularly vulnerable to\u00a0\u2026", "num_citations": "61\n", "authors": ["328"]}
{"title": "Universal arrow foundations for visual modeling\n", "abstract": " The goal of the paper is to explicate some common formal logic underlying various notational systems used in visual modeling. The idea is to treat the notational diversity as the diversity of visualizations of the same basic specificational format. It is argued that the task can be well approached in the arrow-diagram logic framework where specifications are directed graphs carrying a structure of diagram predicates and operations.", "num_citations": "61\n", "authors": ["328"]}
{"title": "Stranger danger: exploring the ecosystem of ad-based url shortening services\n", "abstract": " URL shortening services facilitate the need of exchanging long URLs using limited space, by creating compact URL aliases that redirect users to the original URLs when followed. Some of these services show advertisements (ads) to link-clicking users and pay a commission of their advertising earnings to link-shortening users.", "num_citations": "60\n", "authors": ["328"]}
{"title": "Software verification with VeriFast: Industrial case studies\n", "abstract": " In this article, we present a series of four industrial case studies in software verification. We applied VeriFast, a sound and modular software verifier based on separation logic, to two Java Card smart card applets, a Linux device driver, and an embedded Linux network management component, the latter two written in C. Our case studies have been carefully selected so as to evaluate the industrial applicability of VeriFast. We focus on proving the absence of safety violations, e.g., that the programs do not perform illegal operations such as dividing by zero or illegal memory accesses. Yet, given the sensitive application environment of our case studies, these safety properties typically have security implications. In this article we give a detailed description of the VeriFast approach to software verification based on two of the above case studies, one in Java and one in C. Finally, we draw conclusions on the overall\u00a0\u2026", "num_citations": "56\n", "authors": ["328"]}
{"title": "Practical verification of WPA-TKIP vulnerabilities\n", "abstract": " We describe three attacks on the Wi-Fi Protected Access Temporal Key Integrity Protocol (WPA-TKIP). The first attack is a Denial of Service attack that can be executed by injecting only two frames every minute. The second attack demonstrates how fragmentation of 802.11 frames can be used to inject an arbitrary amount of packets, and we show that this can be used to perform a portscan on any client. The third attack enables an attacker to reset the internal state of the Michael algorithm. We show that this can be used to efficiently decrypt arbitrary packets sent towards a client. We also report on implementation vulnerabilities discovered in some wireless devices. Finally we demonstrate that our attacks can be executed in realistic environments.", "num_citations": "54\n", "authors": ["328"]}
{"title": "A statically verifiable programming model for concurrent object-oriented programs\n", "abstract": " Reasoning about multithreaded object-oriented programs is difficult, due to the non-local nature of object aliasing, data races, and deadlocks. We propose a programming model that prevents data races and deadlocks, and supports local reasoning in the presence of object aliasing and concurrency. Our programming model builds on the multi-threading and synchronization primitives as they are present in current mainstream languages. Java or C# programs developed according to our model can be annotated by means of stylized comments to make the use of the model explicit. We show that such annotated programs can be formally verified to comply with the programming model. In other words, if the annotated program verifies, the underlying Java or C# program is guaranteed to be free from data races and deadlocks, and it is sound to reason locally about program behavior. We have implemented a\u00a0\u2026", "num_citations": "50\n", "authors": ["328"]}
{"title": "Fully-abstract compilation by approximate back-translation\n", "abstract": " A compiler is fully-abstract if the compilation from source language programs to target language programs reflects and preserves behavioural equivalence. Such compilers have important security benefits, as they limit the power of an attacker interacting with the program in the target language to that of an attacker interacting with the program in the source language. Proving compiler full-abstraction is, however, rather complicated. A common proof technique is based on the back-translation of target-level program contexts to behaviourally-equivalent source-level contexts. However, constructing such a back-translation is problematic when the source language is not strong enough to embed an encoding of the target language. For instance, when compiling from the simply-typed \u03bb-calculus (\u03bb\u03c4) to the untyped \u03bb-calculus (\u03bbu), the lack of recursive types in \u03bb\u03c4 prevents such a back-translation. We propose a general and\u00a0\u2026", "num_citations": "49\n", "authors": ["328"]}
{"title": "Fallout: Reading kernel writes from user space\n", "abstract": " Recently, out-of-order execution, an important performance optimization in modern high-end processors, has been revealed to pose a significant security threat, allowing information leaks across security domains. In particular, the Meltdown attack leaks information from the operating system kernel to user space, completely eroding the security of the system. To address this and similar attacks, without incurring the performance costs of software countermeasures, Intel includes hardware-based defenses in its recent Coffee Lake R processors. In this work, we show that the recent hardware defenses are not sufficient. Specifically, we present Fallout, a new transient execution attack that leaks information from a previously unexplored microarchitectural component called the store buffer. We show how unprivileged user processes can exploit Fallout to reconstruct privileged information recently written by the kernel. We further show how Fallout can be used to bypass kernel address space randomization. Finally, we identify and explore microcode assists as a hitherto ignored cause of transient execution. Fallout affects all processor generations we have tested. However, we notice a worrying regression, where the newer Coffee Lake R processors are more vulnerable to Fallout than older generations.", "num_citations": "48\n", "authors": ["328"]}
{"title": "FlashOver: Automated discovery of cross-site scripting vulnerabilities in rich internet applications\n", "abstract": " The last fifteen years have transformed the Web in ways that would seem unimaginable to anyone of the\" few\" Internet users of the year 1995 [8]. What began as a simple set of protocols and mechanisms facilitating the exchange of static documents between remote computers is now an everyday part of billions' of users life, technical and non-technical alike. The sum of a user's daily experience is composed of open standards, such as HTML, JavaScript and Cascading Style Sheets as well as proprietary plugins, such as Adobe's Flash [1] and Microsoft's Silverlight [6].", "num_citations": "47\n", "authors": ["328"]}
{"title": "VulCAN: Efficient component authentication and software isolation for automotive control networks\n", "abstract": " Vehicular communication networks have been subject to a growing number of attacks that put the safety of passengers at risk. This resulted in millions of vehicles being recalled and lawsuits against car manufacturers. While recent standardization efforts address security, no practical solutions are implemented in current cars.", "num_citations": "46\n", "authors": ["328"]}
{"title": "Low-level software security by example\n", "abstract": " Computers are often subject to external attacks that aim to control software behavior. Typically, such attacks arrive as data over a regular communication channel and, once resident in program memory, trigger pre-existing, low-level software vulnerabilities. By exploiting such flaws, these low-level attacks can subvert the execution of the software and gain control over its behavior. The combined effects of these attacks make them one of the most pressing challenges in computer security. As a result, in recent years, many mechanisms have been proposed for defending against these attacks.             This chapter aims to provide insight into low-level software attack and defense techniques by discussing four examples that are representative of the major types of attacks on C and C++ software, and four examples of defenses selected because of their effectiveness, wide applicability, and low enforcement overhead\u00a0\u2026", "num_citations": "46\n", "authors": ["328"]}
{"title": "Stateful declassification policies for event-driven programs\n", "abstract": " We propose a novel mechanism for enforcing information flow policies with support for declassification on event-driven programs. Declassification policies consist of two functions. First, a projection function specifies for each confidential event what information in the event can be declassified directly. This generalizes the traditional security labelling of inputs. Second, a stateful release function specifies the aggregate information about all confidential events seen so far that can be declassified. We provide evidence that such declassification policies are useful in the context of Java Script web applications. An enforcement mechanism for our policies is presented and its soundness and precision is proven. Finally, we give evidence of practicality by implementing and evaluating the mechanism in a browser.", "num_citations": "45\n", "authors": ["328"]}
{"title": "Dependence-preserving data compaction for scalable forensic analysis\n", "abstract": " The full Proceedings published by USENIX for the conference are available for download below. Individual papers can also be downloaded from the presentation page. Copyright to the individual works is retained by the author [s].", "num_citations": "44\n", "authors": ["328"]}
{"title": "Reasoning about object capabilities with logical relations and effect parametricity\n", "abstract": " Object capabilities are a technique for fine-grained privilege separation in programming languages and systems, with important applications in security. However, current formal characterisations do not fully capture capability-safety of a programming language and are not sufficient for verifying typical applications. Using state-of-the-art techniques from programming languages research, we define a logical relation for a core calculus of JavaScript that better characterises capability-safety. The relation is powerful enough to reason about typical capability patterns and supports evolvable invariants on shared data structures, capabilities with restricted authority over them and isolated components with restricted communication channels. We use a novel notion of effect parametricity for deriving properties about effects. Our results imply memory access bounds that have previously been used to characterise capability-safety.", "num_citations": "44\n", "authors": ["328"]}
{"title": "Pattern matching without K\n", "abstract": " Dependent pattern matching is an intuitive way to write programs and proofs in dependently typed languages. It is reminiscent of both pattern matching in functional languages and case analysis in on-paper mathematics. However, in general it is incompatible with new type theories such as homotopy type theory (HoTT). As a consequence, proofs in such theories are typically harder to write and to understand. The source of this incompatibility is the reliance of dependent pattern matching on the so-called K axiom-also known as the uniqueness of identity proofs-which is inadmissible in HoTT. The Agda language supports an experimental criterion to detect definitions by pattern matching that make use of the K axiom, but so far it lacked a formal correctness proof.", "num_citations": "44\n", "authors": ["328"]}
{"title": "Efficient protection against heap-based buffer overflows without resorting to magic\n", "abstract": " Bugs in dynamic memory management, including for instance heap-based buffer overflows and dangling pointers, are an important source of vulnerabilities in C and C++. Overwriting the management information of the memory allocation library is often a source of attack on these vulnerabilities. All existing countermeasures with low performance overhead rely on magic values or canaries. A secret value is placed before a crucial memory location and by monitoring whether the value has changed, overruns can be detected. Hence, if attackers are able to read arbitrary memory locations, they can bypass the countermeasure. In this paper we present an approach that, when applied to a memory allocator, will protect against this attack vector without resorting to magic. We implemented our approach by modifying an existing widely-used memory allocator. Benchmarks show that this implementation has a\u00a0\u2026", "num_citations": "43\n", "authors": ["328"]}
{"title": "A vulnerability taxonomy methodology applied to web services\n", "abstract": " We present a methodology for taxonomizing vulnerabilities based on the likelihood that they will be present in a certain system. It attempts to capture and formalize the intuition that allows security professionals to make predictions about likely security problems. The method exploits the realization that the vulnerabilities present in a system are related to the set of properties that define the system. By modeling it using a selection of relevant properties and correlating this with the body of knowledge on historic vulnerabilities and the systems in which they lived, we obtain a heuristic of the likelihood that these vulnerabilities will reappear in a new system. The predictive nature of this methodology serves as an early warning for systems before they are widely deployed. As an example we apply our methodology to Web Services, thereby providing a tool to focus efforts in securing Web Services.", "num_citations": "43\n", "authors": ["328"]}
{"title": "AOSD & Security: a practical assessment\n", "abstract": " This paper reports on our practical experience in using AOSD for security. In particular we describe one of our past case studies, which focused on the security measures of an existing FTP server implementation. Based on our experience within this scope, we elaborate on several software engineering properties of AOSD.", "num_citations": "43\n", "authors": ["328"]}
{"title": "Secure multi-execution through static program transformation\n", "abstract": " Secure multi-execution (SME) is a dynamic technique to ensure secure information flow. In a nutshell, SME enforces security by running one execution of the program per security level, and by reinterpreting input/output operations w.r.t. their associated security level. SME is sound, in the sense that the execution of a program under SME is non-interfering, and precise, in the sense that for programs that are non-interfering in the usual sense, the semantics of a program under SME coincides with its standard semantics. A further virtue of SME is that its core idea is language-independent; it can be applied to a broad range of languages. A downside of SME is the fact that existing implementation techniques require modifications to the runtime environment, e.g. the browser for Web applications. In this article, we develop an alternative approach where the effect of SME is achieved through program transformation\u00a0\u2026", "num_citations": "42\n", "authors": ["328"]}
{"title": "A methodology for designing countermeasures against current and future code injection attacks\n", "abstract": " This paper proposes a methodology to develop countermeasures against code injection attacks, and validates the methodology by working out a specific countermeasure. This methodology is based on modeling the execution environment of a program. Such a model is then used to build countermeasures. The paper justifies the need for a more structured approach to protect programs against code injection attacks: we examine advanced techniques for injecting code into C and C++ programs and we discuss state-of-the-art (often ad hoc) approaches that typically protect singular memory locations. We validate our methodology by building countermeasures that prevent attacks by protecting a broad variety of memory locations that may be used by attackers to perform code injections. The paper evaluates our approach and discusses ongoing and future work.", "num_citations": "42\n", "authors": ["328"]}
{"title": "Threat modelling for web services based web applications\n", "abstract": " Threat analysis of a web application can lead to a wide variety of identified threats. Some of these threats will be very specific to the application; others will be more related to the underlying infrastructural software, such as the web or application servers, the database, the directory server and so forth. This paper analyzes the threats that can be related to the use of web services technology in a web application. It is part of a series of papers, written by different academic teams, that each focus on one particular technological building block for web applications.", "num_citations": "42\n", "authors": ["328"]}
{"title": "Categorical data specifications\n", "abstract": " We introduce MD-sketches, which are a particular kind of Finite Sum sketches. Two interesting results about MD-sketches are proved. First, we show that, given two MD-sketches, it is algorithmically decidable whether their model categories are equivalent. Next we show that data-specifications, as used in database-design and software engineering, can be translated to MD-sketches. As a corollary, we obtain that equivalence of data-specifications is decidable.", "num_citations": "42\n", "authors": ["328"]}
{"title": "Bridging the gap between web application firewalls and web applications\n", "abstract": " Web applications are the Achilles heel of our current ICT infrastructure. NIST's national vulnerability database clearly shows that the percentage of vulnerabilities located in the application layer increases steadily. Web Application Firewalls (WAFs) play an important role in preventing exploitation of vulnerabilities in web applications. However, WAFs are very pragmatic and ad hoc, and it is very hard to state precisely what security guarantees they offer. The main contribution of this paper is that it shows how, through a combination of static and dynamic verification, WAFs can formally guarantee the absence of certain kinds of erroneous behaviour in web applications. We have done a prototype implementation of our approach building on an existing static verification tool for Java, and we have applied our approach to a medium-sized J2EE based web application.", "num_citations": "40\n", "authors": ["328"]}
{"title": "Sound modular verification of C code executing in an unverified context\n", "abstract": " Over the past decade, great progress has been made in the static modular verification of C code by means of separation logic-based program logics. However, the runtime guarantees offered by such verification are relatively limited when the verified modules are part of a whole program that also contains unverified modules. In particular, a memory safety error in an unverified module can corrupt the runtime state, leading to assertion failures or invalid memory accesses in the verified modules. This paper develops runtime checks to be inserted at the boundary between the verified and the unverified part of a program, to guarantee that no assertion failures or invalid memory accesses can occur at runtime in any verified module. One of the key challenges is enforcing the separation logic frame rule, which we achieve by checking the integrity of the footprint of the verified part of the program on each control flow\u00a0\u2026", "num_citations": "39\n", "authors": ["328"]}
{"title": "ICE: A passive, high-speed, state-continuity scheme\n", "abstract": " The amount of trust that can be placed in commodity computing platforms is limited by the likelihood of vulnerabilities in their huge software stacks. Protected-module architectures, such as Intel SGX, provide an interesting alternative by isolating the execution of software modules. To minimize the amount of code that provides support for the protected-module architecture, persistent storage of (confidentiality and integrity protected) states of modules can be delegated to the untrusted operating system. But precautions should be taken to ensure state continuity: an attacker should not be able to cause a module to use stale states (a so-called rollback attack), and while the system is not under attack, a module should always be able to make progress, even when the system could crash or lose power at unexpected, random points in time (ie, the system should be crash resilient).", "num_citations": "39\n", "authors": ["328"]}
{"title": "Information flow enforcement in monadic libraries\n", "abstract": " In various scenarios, there is a need to expose a certain API to client programs which are not fully trusted. In cases where the client programs need access to sensitive data, confidentiality can be enforced using an information flow policy. This is a general and powerful type of policy that has been widely studied and implemented.", "num_citations": "39\n", "authors": ["328"]}
{"title": "Security of web mashups: a survey\n", "abstract": " Web mashups, a new web application development paradigm, combine content and services from multiple origins into a new service. Web mashups heavily depend on interaction between content from multiple origins and communication with different origins. Contradictory, mashup security relies on separation for protecting code and data. Traditional HTML techniques fail to address both the interaction/communication needs and the separation needs. This paper proposes concrete requirements for building secure mashups, divided in four categories: separation, interaction, communication and advanced behavior control. For the first three categories, all currently available techniques are discussed in light of the proposed requirements. For the last category, we present three relevant academic research results with high potential. We conclude the paper by highlighting the most applicable techniques for\u00a0\u2026", "num_citations": "39\n", "authors": ["328"]}
{"title": "Release the Kraken: new KRACKs in the 802.11 Standard\n", "abstract": " We improve key reinstallation attacks (KRACKs) against 802.11 by generalizing known attacks, systematically analyzing all handshakes, bypassing 802.11's official countermeasure, auditing (flawed) patches, and enhancing attacks using implementation-specific bugs. Last year it was shown that several handshakes in the 802.11 standard were vulnerable to key reinstallation attacks. These attacks manipulate handshake messages to reinstall an already-in-use key, leading to both nonce reuse and replay attacks. We extend this work in several directions. First, we generalize attacks against the 4-way handshake so they no longer rely on hard-to-win race conditions, and we employ a more practical method to obtain the required man-in-the-middle (MitM) position. Second, we systematically investigate the 802.11 standard for key reinstallation vulnerabilities, and show that the Fast Initial Link Setup (FILS) and\u00a0\u2026", "num_citations": "38\n", "authors": ["328"]}
{"title": "On modular and fully-abstract compilation\n", "abstract": " Secure compilation studies compilers that generate target-level components that are as secure as their source-level counterparts. Full abstraction is the most widely-proven property when defining a secure compiler. A compiler is modular if it allows different components to be compiled independently and then to be linked together to form a whole program. Unfortunately, many existing fully-abstract compilers to untyped machine code are not modular. So, while fully-abstractly compiled components are secure from malicious attackers, if they are linked against each other the resulting component may become vulnerable to attacks. This paper studies how to devise modular, fully-abstract compilers. It first analyses the attacks arising when compiled programs are linked together, identifying security threats that are due to linking. Then, it defines a compiler from an object-based language with method calls and dynamic\u00a0\u2026", "num_citations": "37\n", "authors": ["328"]}
{"title": "Predicting, decrypting, and abusing WPA2/802.11 group keys\n", "abstract": " We analyze the generation and management of 802.11 group keys. These keys protect broadcast and multicast Wi-Fi traffic. We discovered several issues and illustrate their importance by decrypting all group (and unicast) traffic of a typical Wi-Fi network.", "num_citations": "36\n", "authors": ["328"]}
{"title": "Serene: Self-Reliant Client-Side Protection against Session Fixation\n", "abstract": " The web is the most wide-spread and de facto distributed platform, with a plethora of valuable applications and services. Building stateful services on the web requires a session mechanism that keeps track of server-side session state, such as authentication data. These sessions are an attractive attacker target, since taking over an authenticated session fully compromises the user\u2019s account. This paper focuses on session fixation, where an attacker forces the user to use the attacker\u2019s session, allowing the attacker to take over the session after authentication.             We present Serene, a self-reliant client-side countermeasure that protects the user from session fixation attacks, regardless of the security provisions \u2013 or lack thereof \u2013 of a web application. By specifically protecting session identifiers from fixation and not interfering with other cookies or parameters, Serene is able to autonomously protect a large\u00a0\u2026", "num_citations": "36\n", "authors": ["328"]}
{"title": "On securely scheduling a meeting\n", "abstract": " When people want to schedule a meeting, their agendas must be compared to find a time suitable for all participants. At the same time, people want to keep their agendas private. This paper presents several approaches which intend to solve this contradiction. A custom-made protocol for secure meeting scheduling and a protocol based on secure distributed computing are discussed. The security properties and complexity of these protocols are compared. A trade-off between trust and bandwidth requirements is shown to be possible by implementing the protocols using mobile agents.", "num_citations": "35\n", "authors": ["328"]}
{"title": "Multi-tier functional reactive programming for the web\n", "abstract": " The development of robust and efficient interactive web applications is challenging, because developers have to deal with multiple programming languages, asynchronous events, propagating data and events between clients and servers, data consistency and much more. Several approaches for (partly) addressing these challenges have been proposed. Two relevant ones are (1) multi-tier languages and (2) functional reactive programming (FRP). Multi-tier programming languages support the development of client and server in a single language, and hide much of the complexity related to distribution. FRP offers the right abstractions to make event-driven programming convenient, safe and composable. However, existing web frameworks and programming languages exploit the benefits of both approaches separately, for example by restricting the use of FRP to the client side.", "num_citations": "33\n", "authors": ["328"]}
{"title": "Formal methods and object technology\n", "abstract": " Rationale Software engineering aims to develop software by using approaches which en able large and complex program suites to be developed in a systematic way. However, it is well known that it is difficult to obtain the level of assurance of correctness required for safety critical software using old fashioned program ming techniques. The level of safety required becomes particularly high in software which is to function without a break for long periods of time, since the software cannot be restarted and errors can accumulate. Consequently programming for mission critical systems, for example, needs to address the requirements of correctness with particular care. In the search for techniques for making software cheaper and more reliable, two important but largely independent influences have been visible in recent years. These are:\u2022 Object Technology\u2022 Formal Methods First, it has become evident that objects are, and will remain an important concept in software. Experimental languages of the 1970's introduced various concepts of package, cluster, module, etc. giving concrete expression to the importance of modularity and encapsulation, the construction of software com ponents hiding their state representations and algorithmic mechanisms from users, exporting only those features (mainly the procedure calling mechanisms) which were needed in order to use the objects. This gives the software com ponents a level of abstraction, separating the view of what a module does for the system from the details of how it does them.", "num_citations": "33\n", "authors": ["328"]}
{"title": "A caller-side inline reference monitor for an object-oriented intermediate language\n", "abstract": " Runtime security policy enforcement systems are crucial to limit the risks associated with running untrustworthy (malicious or buggy) code. The inlined reference monitor approach to policy enforcement, pioneered by Erlingsson and Schneider, implements runtime enforcement through program rewriting: security checks are inserted inside untrusted programs.                 Ensuring complete mediation \u2013 the guarantee that every security-relevant event is actually intercepted by the monitor \u2013 is non-trivial when the program rewriter operates on an object-oriented intermediate language with state-of-the-art features such as virtual methods and delegates.                 This paper proposes a caller-side rewriting algorithm for MSIL \u2013 the bytecode of the .NET virtual machine \u2013 where security checks are inserted around calls to security-relevant methods. We prove that this algorithm achieves sound and complete mediation\u00a0\u2026", "num_citations": "33\n", "authors": ["328"]}
{"title": "VeriCool: An automatic verifier for a concurrent object-oriented language\n", "abstract": " Reasoning about object-oriented programs is hard, due to aliasing, dynamic binding and the need for data abstraction and framing. Reasoning about concurrent object-oriented programs is even harder, since in general interference by other threads has to be taken into account at each program point.                 In this paper, we propose an approach to the automatic verification of concurrent Java-like programs. The cornerstone of the approach is a programming model, a set of rules, which limits thread inference to synchronization points such that one can reason sequentially about most code. In particular, programs conforming to the programming model are guaranteed to be data race free. Compared to previous incarnations of the programming model, our approach is more flexible in describing the set of memory locations protected by an object\u2019s lock. In addition, we combine the model with an approach for\u00a0\u2026", "num_citations": "32\n", "authors": ["328"]}
{"title": "How secure is AOP and what can we do about it?\n", "abstract": " From a software engineering perspective, using Aspect-Oriented Programming (AOP) to build secure software has clear advantages. Until recently, the security perspective of this approach has been given less attention, however. This paper analyses the security risks in using AOP to develop secure software and discusses one particular solution to some of the identified risks, an aspect permission system. This permission system is one part of an overall AOP-based development platform for secure software.", "num_citations": "32\n", "authors": ["328"]}
{"title": "Protected software module architectures\n", "abstract": " A significant fraction of Internet-connected computing devices is infected with malware. With the increased connectivity and software extensibility of embedded and industrial devices, this threat is now also relevant for our industrial infrastructure and our personal environments. Since many of these devices interact with remote parties for security-critical or privacy sensitive transactions, it is important to develop security architectures that allow a stakeholder to assess the trustworthiness of a computing device, and that allow such stakeholders to securely execute software on that device. Over the past decade, the security research community has proposed and evaluated such architectures. Important and promising examples are protected software module architectures. These architectures support the secure execution of small protected software modules even on devices that are malware infected. They also\u00a0\u2026", "num_citations": "30\n", "authors": ["328"]}
{"title": "VeriFast: Imperative programs as proofs\n", "abstract": " This paper describes the VeriFast prototype program verification tool, which implements a separation-logic-based approach for the specification and verification of safety properties of pointer-manipulating imperative programs. The approach's distinctive feature is that it combines very good and predictable verification performance with powerful proofs written conveniently as part of the program. We describe the tool's support for the C language. The paper introduces the tool's various features by means of a running example of a linked list implementation. A detailed formalization of the core of the approach and a soundness proof are available on the website.", "num_citations": "30\n", "authors": ["328"]}
{"title": "Failboxes: Provably safe exception handling\n", "abstract": " The primary goal of exception mechanisms is to help ensure that when an operation fails, code that depends on the operation\u2019s successful completion is not executed (a property we call dependency safety). However, the exception mechanisms of current mainstream programming languages make it hard to achieve dependency safety, in particular when objects manipulated inside a try block outlive the try block.               Many programming languages, mechanisms and paradigms have been proposed that address this issue. However, they all depart significantly from current practice. In this paper, we propose a language mechanism called failboxes. When applied correctly, failboxes have no significant impact on the structure, the semantics, or the performance of the program, other than to eliminate the executions that violate dependency safety.               Specifically, programmers may create failboxes\u00a0\u2026", "num_citations": "30\n", "authors": ["328"]}
{"title": "Monkey-in-the-browser: malware and vulnerabilities in augmented browsing script markets\n", "abstract": " With the constant migration of applications from the desktop to the web, power users have found ways of enhancing web applications, at the client-side, according to their needs.", "num_citations": "28\n", "authors": ["328"]}
{"title": "Secure compilation of object-oriented components to protected module architectures\n", "abstract": " A fully abstract compilation scheme prevents the security features of the high-level language from being bypassed by an attacker operating at a particular lower level. This paper presents a fully abstract compilation scheme from a realistic object-oriented language with dynamic memory allocation, cross-package inheritance, exceptions and inner classes to untyped machine code. Full abstraction of the compilation scheme relies on enhancing the low-level machine model with a fine-grained, program counter-based memory access control mechanism. This paper contains the outline of a formal proof of full abstraction of the compilation scheme. Measurements of the overhead introduced by the compilation scheme indicate that it is negligible.", "num_citations": "28\n", "authors": ["328"]}
{"title": "A programming model for concurrent object-oriented programs\n", "abstract": " Reasoning about multithreaded object-oriented programs is difficult, due to the nonlocal nature of object aliasing and data races. We propose a programming regime (or programming model) that rules out data races, and enables local reasoning in the presence of object aliasing and concurrency. Our programming model builds on the multithreading and synchronization primitives as they are present in current mainstream programming languages. Java or C# programs developed according to our model can be annotated by means of stylized comments to make the use of the model explicit. We show that such annotated programs can be formally verified to comply with the programming model. If the annotated program verifies, the underlying Java or C# program is guaranteed to be free from data races, and it is sound to reason locally about program behavior. Verification is modular: a program is valid if all methods\u00a0\u2026", "num_citations": "28\n", "authors": ["328"]}
{"title": "Secure multi-execution of web scripts: Theory and practice\n", "abstract": " Secure Multi-Execution (SME) is a precise and general information flow control mechanism that was claimed to be a good fit for implementing information flow security in browsers. We validate this claim by developing FlowFox, the first fully functional web browser that implements an information flow control mechanism for web scripts based on the technique of secure multi-execution. We provide evidence for the security of FlowFox by proving non-interference for a formal model of the essence of FlowFox, and by showing how it stops real attacks. We provide evidence of usefulness by showing how FlowFox subsumes many ad-hoc script-containment countermeasures developed over the last years. An experimental evaluation on the Alexa top-500 web sites provides evidence for compatibility, and shows that FlowFox is compatible with the current web, even on sites that make intricate use of JavaScript.", "num_citations": "27\n", "authors": ["328"]}
{"title": "HeapSentry: kernel-assisted protection against heap overflows\n", "abstract": " The last twenty years have witnessed the constant reaction of the security community to memory corruption attacks and the evolution of attacking techniques in order to circumvent the newly-deployed countermeasures. In this evolution, the heap of a process received little attention and thus today, the problem of heap overflows is largely unsolved.               In this paper we present HeapSentry, a system designed to detect and stop heap overflow attacks through the cooperation of the memory allocation library of a program and the operating system\u2019s kernel. HeapSentry places unique random canaries at the end of each heap object which are later checked by the kernel, before system calls are allowed to proceed. HeapSentry operates on binaries (no source code needed) and has, by design, no false-positives. At the same time, the active involvement of the kernel provides stronger security guarantees than\u00a0\u2026", "num_citations": "27\n", "authors": ["328"]}
{"title": "Safe type-level abstraction in Scala\n", "abstract": " Most formal accounts of object-oriented languages have focussed on type soundness: the safety that type checking provides with respect to term-level computation and abstractions. However, with type-level abstraction mechanisms becoming increasingly more sophisticated, bringing this guarantee to the level of types has become quite pressing. We call this property kind soundness: kind checking ensures that type constructors are never applied to unexpected type arguments. We present Scalina, a purely object-oriented calculus that employs the same abstraction mechanisms at the type level as well as at the kind level. Soundness for both levels can thus be proven by essentially the same arguments. Kind soundness finally allows designers of type-level abstractions to join their term-level colleagues in relying on the compiler to catch deficiencies before they are discovered by their clients.", "num_citations": "27\n", "authors": ["328"]}
{"title": "ValueGuard: Protection of native applications against data-only buffer overflows\n", "abstract": " Code injection attacks that target the control-data of an application have been prevalent amongst exploit writers for over 20 years. Today however, these attacks are getting increasingly harder for attackers to successfully exploit due to numerous countermeasures that are deployed by modern operating systems. We believe that this fact will drive exploit writers away from classic control-data attacks and towards data-only attacks. In data-only attacks, the attacker changes key data structures that are used by the program\u2019s logic and thus forces the control flow into existing parts of the program that would be otherwise unreachable, e.g. overflowing into a boolean variable that states whether the current user is an administrator or not and setting it to \u201ctrue\u201d thereby gaining access to the administrative functions of the program.               In this paper we present ValueGuard, a canary-based defense mechanism to\u00a0\u2026", "num_citations": "26\n", "authors": ["328"]}
{"title": "Verifying the composite pattern using separation logic\n", "abstract": " Often, a module developer wishes to expose a graph of objects to client code, allowing client code to access the graph through any node directly, while maintaining hidden consistency conditions over the graph. In this note, we describe how to specify and verify such code using separation logic, using as an example a binary tree structure where each node keeps a count of its descendant nodes. The idea is to describe the tree structure as the separate conjunction of the focus node\u2019s subtree and the focus node\u2019s context. The description can be rewritten to use any other node as the focus node at any time. This enables an elegant modular proof of the tree implementation on the one hand, and client code on the other hand. We describe how we verified an example program using the VeriFast program verifier prototype.", "num_citations": "26\n", "authors": ["328"]}
{"title": "Code pointer masking: Hardening applications against code injection attacks\n", "abstract": " In this paper we present an efficient countermeasure against code injection attacks. Our countermeasure does not rely on secret values such as stack canaries and protects against attacks that are not addressed by state-of-the-art countermeasures of similar performance. By enforcing the correct semantics of code pointers, we thwart attacks that modify code pointers to divert the application\u2019s control flow. We have implemented a prototype of our solution in a C-compiler for Linux. The evaluation shows that the overhead of using our countermeasure is small and the security benefits are substantial.", "num_citations": "25\n", "authors": ["328"]}
{"title": "The Heisenberg defense: Proactively defending SGX enclaves against page-table-based side-channel attacks\n", "abstract": " Protected-module architectures (PMAs) have been proposed to provide strong isolation guarantees, even on top of a compromised system. Unfortunately, Intel SGX -- the only publicly available high-end PMA -- has been shown to only provide limited isolation. An attacker controlling the untrusted page tables, can learn enclave secrets by observing its page access patterns. Fortifying existing protected-module architectures in a real-world setting against side-channel attacks is an extremely difficult task as system software (hypervisor, operating system, ...) needs to remain in full control over the underlying hardware. Most state-of-the-art solutions propose a reactive defense that monitors for signs of an attack. Such approaches unfortunately cannot detect the most novel attacks, suffer from false-positives, and place an extraordinary heavy burden on enclave-developers when an attack is detected. We present Heisenberg, a proactive defense that provides complete protection against page table based side channels. We guarantee that any attack will either be prevented or detected automatically before {\\em any} sensitive information leaks. Consequently, Heisenberg can always securely resume enclave execution -- even when the attacker is still present in the system. We present two implementations. Heisenberg-HW relies on very limited hardware features to defend against page-table-based attacks. We use the x86/SGX platform as an example, but the same approach can be applied when protected-module architectures are ported to different platforms as well. Heisenberg-SW avoids these hardware modifications and can readily be applied\u00a0\u2026", "num_citations": "24\n", "authors": ["328"]}
{"title": "Parametricity versus the universal type\n", "abstract": " There has long been speculation in the scientific literature on how to dynamically enforce parametricity such as that yielded by System F. Almost 20 years ago, Sumii and Pierce proposed a formal compiler from System F into the cryptographic lambda calculus: an untyped lambda calculus extended with an idealised model of encryption. They conjectured that this compiler was fully abstract, i.e. that compiled terms are contextually equivalent if and only if the original terms were, a property that can be seen as a form of secure compilation. The conjecture has received attention in several other publications since then, but remains open to this day.   More recently, several researchers have been looking at gradually-typed languages that extend System F. In this setting it is natural to wonder whether embedding System F into these gradually-typed languages preserves contextual equivalence and thus parametricity.   In\u00a0\u2026", "num_citations": "23\n", "authors": ["328"]}
{"title": "Modular, fully-abstract compilation by approximate back-translation\n", "abstract": " A compiler is fully-abstract if the compilation from source language programs to target language programs reflects and preserves behavioural equivalence. Such compilers have important security benefits, as they limit the power of an attacker interacting with the program in the target language to that of an attacker interacting with the program in the source language. Proving compiler full-abstraction is, however, rather complicated. A common proof technique is based on the back-translation of target-level program contexts to behaviourally-equivalent source-level contexts. However, constructing such a back- translation is problematic when the source language is not strong enough to embed an encoding of the target language. For instance, when compiling from STLC to ULC, the lack of recursive types in the former prevents such a back-translation.   We propose a general and elegant solution for this problem. The key insight is that it suffices to construct an approximate back-translation. The approximation is only accurate up to a certain number of steps and conservative beyond that, in the sense that the context generated by the back-translation may diverge when the original would not, but not vice versa. Based on this insight, we describe a general technique for proving compiler full-abstraction and demonstrate it on a compiler from STLC to ULC. The proof uses asymmetric cross-language logical relations and makes innovative use of step-indexing to express the relation between a context and its approximate back-translation. The proof extends easily to common compiler patterns such as modular compilation and it, to the best of our knowledge, it\u00a0\u2026", "num_citations": "23\n", "authors": ["328"]}
{"title": "Request and conquer: Exposing cross-origin resource size\n", "abstract": " Numerous initiatives are encouraging website owners to enable and enforce TLS encryption for the communication between the server and their users. Although this encryption, when configured properly, completely prevents adversaries from disclosing the content of the traffic, certain features are not concealed, most notably the size of messages. As modern-day web applications tend to provide users with a view that is tailored to the information they entrust these web services with, it is clear that knowing the size of specific resources, an adversary can easily uncover personal and sensitive information.", "num_citations": "23\n", "authors": ["328"]}
{"title": "Secure interrupts on low-end microcontrollers\n", "abstract": " Embedded devices are increasingly becoming interconnected, sometimes over the public Internet. This poses a major security concern, as these devices handle sensitive information (e.g, banking credentials, personal data) or they are critical for the safety of human lives (e.g, smoke detector, airbag system). Security protocols need to be used in combination with a trusted computing base to ensure that attackers cannot alter the state of the software running on these devices to leak secrets. In this work we focus on the problem of secure interrupt handling, which has not been covered in related work. Our architecture for secure interrupts build on the idea of using simple memory isolation techniques to ensure leakage free processing of secret information on a microcontroller. Three methods of securely handling interrupts are proposed, each exploring a different tradeoff between hardware and software complexity, and\u00a0\u2026", "num_citations": "23\n", "authors": ["328"]}
{"title": "Typed syntactic meta-programming\n", "abstract": " We present a novel set of meta-programming primitives for use in a dependently-typed functional language. The types of our meta-programs provide strong and precise guarantees about their termination, correctness and completeness. Our system supports type-safe construction and analysis of terms, types and typing contexts. Unlike alternative approaches, they are written in the same style as normal programs and use the language's standard functional computational model. We formalise the new meta-programming primitives, implement them as an extension of Agda, and provide evidence of usefulness by means of two compelling applications in the fields of datatype-generic programming and proof tactics.", "num_citations": "23\n", "authors": ["328"]}
{"title": "Uniform application-level access control enforcement of organizationwide policies\n", "abstract": " Fine-grained and expressive access control policies on application resources need to be enforced in application-level code. Uniformly enforcing a single policy (referred to as the organizationwide policy) in diverse applications is challenging with current technologies. This is due to a poor delimitation of the responsibilities of application deployer and security officer, which hampers a centralized management of a policy and therefore compromises the uniformity of its enforcement. To address this problem, the concept of an access interface is introduced as a contract between an organization-wide authorization engine and the various applications that need its services. The access interface provides support for the central management of the policy by the security officer. By means of a view connector, the application deployer ensures that each application complies with this contract, so that the policy can be enforced", "num_citations": "23\n", "authors": ["328"]}
{"title": "Exploring the ecosystem of malicious domain registrations in the. eu TLD\n", "abstract": " This study extensively scrutinizes 14\u00a0months of registration data to identify large-scale malicious campaigns present in the .eu TLD. We explore the ecosystem and modus operandi of elaborate cybercriminal entities that recurrently register large amounts of domains for one-shot, malicious use. Although these malicious domains are short-lived, by incorporating registrant information, we establish that at least 80.04% of them can be framed in\u00a0to 20 larger campaigns with varying duration and intensity. We further report on insights in the operational aspects of this business and observe, amongst other findings, that their processes are only partially automated. Finally, we apply a post-factum clustering process to validate the campaign identification process and to automate the ecosystem analysis of malicious registrations in a TLD zone.", "num_citations": "22\n", "authors": ["328"]}
{"title": "Towards automatic compartmentalization of C programs on capability machines\n", "abstract": " Capability-based protection mechanisms can offer fine-grained memory protection (through memory capabilities), as well as fine-grained protection of general software-defined objects (through object capabilities). Because of the similarity that capabilities have to the notion of pointer in C, compilers can use the capability mechanisms offered by the target platform to generate code that is more resilient to attack. For instance, C arrays can be compiled to memory capabilities thus providing hardwareenforced spatial safety guarantees and hence strong resilience against buffer overflow attacks. State-of-the-art capability-based systems (like for instance the CHERI system [1]) come with a C compiler that provides such safety guarantees. But such safe compilation does not provide security guarantees for an attacker model where an attacker can compromise part of the code of an application, for instance by providing a malicious library, possibly in compiled form. An application is still executed in a single protection domain. The mechanism of object capabilities can be used to remedy this: object capabilities support compartmentalization of an application where different parts of the application can be executed in different protection domains, and hence one part of the application can be protected against malicious behaviour in other parts. However, to the best of our knowledge, state-of-the-art C compilers provide no automatic support for such compartmentalization. In CHERI, support for such compartmentalization is offered as an API [2]. This paper reports on our work-in-progress on the definition, implementation and evaluation of a compiler that\u00a0\u2026", "num_citations": "22\n", "authors": ["328"]}
{"title": "Featherweight verifast\n", "abstract": " VeriFast is a leading research prototype tool for the sound modular verification of safety and correctness properties of single-threaded and multithreaded C and Java programs. It has been used as a vehicle for exploration and validation of novel program verification techniques and for industrial case studies; it has served well at a number of program verification competitions; and it has been used for teaching by multiple teachers independent of the authors. However, until now, while VeriFast's operation has been described informally in a number of publications, and specific verification techniques have been formalized, a clear and precise exposition of how VeriFast works has not yet appeared. In this article we present for the first time a formal definition and soundness proof of a core subset of the VeriFast program verification approach. The exposition aims to be both accessible and rigorous: the text is based on lecture notes for a graduate course on program verification, and it is backed by an executable machine-readable definition and machine-checked soundness proof in Coq.", "num_citations": "22\n", "authors": ["328"]}
{"title": "Filter-resistant code injection on ARM\n", "abstract": " Code injection attacks are one of the most powerful and important classes of attacks on software. In these attacks, the attacker sends malicious input to a software application, where it is stored in memory. The malicious input is chosen in such a way that its representation in memory is also a valid representation of a machine code program that performs actions chosen by the attacker. The attacker then triggers a bug in the application to divert the control flow to this injected machine code. A typical action of the injected code is to launch a command interpreter shell, and hence the malicious input is often called shellcode. Attacks are usually performed against network facing applications, and such applications often perform validations or encodings on input. Hence, a typical hurdle for attackers, is that the shellcode has to pass one or more filtering methods before it is stored in the vulnerable application\u2019s\u00a0\u2026", "num_citations": "22\n", "authors": ["328"]}
{"title": "Sound, modular and compositional verification of the input/output behavior of programs\n", "abstract": " We present a sound verification approach for verifying input/output properties of programs. Our approach supports defining high-level I/O actions on top of low-level ones (compositionality), defining input/output actions without taking into account which other actions exist (modularity), and other features. As the key ingredient, we developed a separation logic over Petri nets. We also show how with the same specification style we can elegantly modularly verify \u201cI/O-like\u201d code that uses the Template Pattern. We have implemented our approach in the VeriFast verifier and applied it to a number of challenging examples.", "num_citations": "21\n", "authors": ["328"]}
{"title": "VeriFast for Java: A tutorial\n", "abstract": " VeriFast is a separation logic-based program verifier for Java. This tutorial introduces the verifier\u2019s features step by step.", "num_citations": "21\n", "authors": ["328"]}
{"title": "Sound formal verification of Linux\u2019s USB BP keyboard driver\n", "abstract": " Case studies on formal software verification can be divided into two categories: while (i) unsound approaches may miss errors or report false-positive alarms due to coarse abstractions, (ii) sound approaches typically do not handle certain programming constructs like concurrency and/or suffer from scalability issues. This paper presents a case study on successfully verifying the Linux USB BP keyboard driver. Our verification approach is (a) sound, (b) takes into account dynamic memory allocation, complex API rules and concurrency, and (c) is applied on a real kernel driver which was not written with verification in mind. We employ VeriFast, a software verifier based on separation logic. Besides showing that it is possible to verify this device driver, we identify the parts where the verification went smoothly and the parts where the verification approach requires further research to be carried out.", "num_citations": "21\n", "authors": ["328"]}
{"title": "Explicitly recursive grammar combinators\n", "abstract": " We propose a novel context-free grammar representation for parsing libraries in a pure programming language. Our representation explicitizes the recursion in the grammar, thus avoiding fundamental limitations of the grammar model currently employed by parser combinator libraries. Additionally, we decouple the grammar from its semantic actions using techniques from the Multirec generic programming library. The look and feel of the grammar and semantic actions remain close to traditional EBNF and syntax-directed definitions respectively.               In an accompanying technical report, we demonstrate that our representation supports more declarative implementations of grammar transformations than other work. The ideas described in this paper form the basis for our freely available grammar-combinators parsing library.", "num_citations": "21\n", "authors": ["328"]}
{"title": "A machine-checked soundness proof for an efficient verification condition generator\n", "abstract": " Verification conditions (VCs) are logical formulae whose validity implies the correctness of a program with respect to a specification. The technique of checking software properties by specifying them in a program logic, then generating VCs, and finally feeding these VCs to a theorem prover, is several decades old. It is the underlying technology for state-of-the-art program verifiers such as the Spec# programming system, or ESC/Java. The classic way of computing VCs is by means of Dijkstra's weakest precondition calculus. However, modern verification condition generators (VCgens), including Spec# and ESC/Java's VCgens, are based on an optimized version of this algorithm, that avoids an exponential growth of the VCs in the length of the program to be verified. For this optimized VCgen algorithm, only informal soundness arguments are available. The main contribution of this paper is a fully formal, machine\u00a0\u2026", "num_citations": "21\n", "authors": ["328"]}
{"title": "Jitsec: Just-in-time security for code injection attacks\n", "abstract": " In order to combat code injection attacks, modern operating systems use among others, the Write-XOR-Execute (W\u2295 X) countermeasure which disallows code execution from writable memory pages. Unfortunately though, a widely used programming technique, namely Just-in-time compilation (JIT), clashes with the use of this countermeasure since its use relies on writable memory where it places dynamically generated code. In order to overcome this problem, programmers that use such techniques, code around the (W\u2295 X) countermeasure in ways that open up their programs to code injection attacks.In this paper we present JITSec, a new countermeasure specifically geared towards programs that use JIT compilation techniques. By decoupling sensitive from non-sensitive code, we block the execution of the former from writable memory pages while allowing the latter. Our distinction is based on the separation of normal function calls within the processes\u2019 address space from system calls. Our resulting system is fully transparent to the operating system and makes it possible to protect all applications without user intervention or access to source code. The overhead of our prototype is negligible (under 2%), allowing its adoption as an extra line of defense in cases where code execution from writable memory pages is desired.", "num_citations": "21\n", "authors": ["328"]}
{"title": "Implicit dynamic frames\n", "abstract": " The dynamic frames approach has proven to be a powerful formalism for modular specification and verification of object-oriented programs. However, the approach requires writing and checking frame annotations.In this paper, we propose a variant of the dynamic frames approach that eliminates the need to explicitly write and check frame annotations. Reminiscent of separation logic\u2019s frame rule, programmers write accessibility predicates inside pre-and postconditions instead of writing frame annotations. From the precondition one can then infer an upper bound on the set of locations writable or readable by the corresponding method. We implemented our approach in a tool, and used it to automatically verify several challenging examples, including the iterator and observer patterns.", "num_citations": "21\n", "authors": ["328"]}
{"title": "Static verification of code access security policy compliance of. net applications\n", "abstract": " The base class library of the .NET Framework makes extensive use of the Code Access Security system to ensure that partially trusted code can be executed securely. Imperative or declarative permission demands indicate where permission checks have to be performed at run time to make sure partially trusted code does not exceed the permissions granted to it in the security policy.In this paper we propose expressive method contracts for specifying required security permissions, and a modular static verification technique for Code Access Security based on these method contracts. If a program verifies, it will never fail a run time check for permissions, and hence these run time checks can be omitted. Advantages of our approach include improved run time performance, and improved and checkable documentation for security requirements. Our system builds on the Spec# programming language and its accompanying static verification tool.", "num_citations": "21\n", "authors": ["328"]}
{"title": "Linear capabilities for fully abstract compilation of separation-logic-verified code\n", "abstract": " Separation logic is a powerful program logic for the static modular verification of imperative programs. However, dynamic checking of separation logic contracts on the boundaries between verified and untrusted modules is hard, because it requires one to enforce (among other things) that outcalls from a verified to an untrusted module do not access memory resources currently owned by the verified module.   This paper proposes an approach to dynamic contract checking by relying on support for capabilities, a well-studied form of unforgeable memory pointers that enables fine-grained, efficient memory access control. More specifically, we rely on a form of capabilities called linear capabilities for which the hardware enforces that they cannot be copied.   We formalize our approach as a fully abstract compiler from a statically verified source language to an unverified target language with support for linear capabilities\u00a0\u2026", "num_citations": "20\n", "authors": ["328"]}
{"title": "Off-limits: Abusing legacy x86 memory segmentation to spy on enclaved execution\n", "abstract": " Enclaved execution environments, such as Intel SGX, enable secure, hardware-enforced isolated execution of critical application components without having to trust the underlying operating system or hypervisor. A recent line of research, however, explores innovative controlled-channel attacks mounted by untrusted system software to partially compromise the confidentiality of enclave programs. Apart from exploiting relatively well-known side-channels like the CPU cache and branch predictor, these attacks have so far focused on tracking side-effects from enclaved address translations via the paging unit. This paper shows, however, that for 32-bit SGX enclaves the unacclaimed x86 segmentation unit can be abused as a novel controlled-channel to reveal enclaved memory accesses at a page-level granularity, and in restricted circumstances even at a very precise byte-level granularity. While the x86 paging unit\u00a0\u2026", "num_citations": "20\n", "authors": ["328"]}
{"title": "On the workings and current practices of web-based device fingerprinting\n", "abstract": " By analyzing the code of three popular browser-fingerprinting code providers, the authors reveal the techniques that allow websites to track users without client-side identifiers. They expose questionable practices, such as the circumvention of HTTP proxies to discover a user's real IP address and the installation of intrusive browser plug-ins. In addition, they measure the adoption of fingerprinting on the Web and evaluate user-agent-spoofing browser extensions, showing that current commercial approaches can bypass the extensions and take advantage of their shortcomings.", "num_citations": "20\n", "authors": ["328"]}
{"title": "Heap-dependent expressions in separation logic\n", "abstract": " Separation logic is a popular specification language for imperative programs where the heap can only be mentioned through points-to assertions. However, separation logic\u2019s take on assertions does not match well with the classical view of assertions as boolean, side effect-free, potentially heap-dependent expressions from the host programming language familiar to many developers.               In this paper, we propose a variant of separation logic where side effect-free expressions from the host programming language, such as pointer dereferences and invocations of pure methods, can be used in assertions. We modify the symbolic execution-based verification algorithm used in Smallfoot to support mechanized checking of our variant of separation logic. We have implemented this algorithm in a tool and used the tool to verify some interesting programming patterns.", "num_citations": "20\n", "authors": ["328"]}
{"title": "Security of memory allocators for C and C++\n", "abstract": " Most memory allocators ignore security issues. Instead they focus on maximizing performance and limiting fragmentation and waste. While these are very important issues for a memory allocator, in the days of worms that use code injection attacks to cause significant economical damage, security can not be ignored. This paper evaluates a representative set of commonly used memory allocators for C and C++ with respect to their resilience against code injection attacks. We present a significant improvement for memory allocators in order to increase robustness against code injection attacks. We evaluate this new approach in terms of performance and memory usage and show that the associated overhead is negligible.", "num_citations": "20\n", "authors": ["328"]}
{"title": "Annotation inference for separation logic based verifiers\n", "abstract": " With the years, program complexity has increased dramatically: ensuring program correctness has become considerably more difficult with the advent of multithreading, security has grown more prominent during the last decade, etc. As a result, static verification has become more important than ever.             Automated verification tools exist, but they are only able to prove a limited set of properties, such as memory safety. If we want to prove full functional correctness of a program, other more powerful tools are available, but they generally require a lot more input from the programmer: they often need the code to be verified to be heavily annotated.             In this paper, we attempt to combine the best of both worlds by starting off with a manual verification tool based on separation logic for which we develop techniques to automatically generate part of the required annotations. This approach provides more\u00a0\u2026", "num_citations": "19\n", "authors": ["328"]}
{"title": "Enlarging instruction streams\n", "abstract": " Web applications are widely adopted and their correct functioning is mission critical for many businesses. At the same time, Web applications tend to be error prone and implementation vulnerabilities are readily and commonly exploited by attackers. The design of countermeasures that detect or prevent such vulnerabilities or protect against their exploitation is an important research challenge for the fields of software engineering and security engineering. In this paper, we focus on one specific type of implementation vulnerability, namely, broken dependencies on session data. This vulnerability can lead to a variety of erroneous behavior at runtime and can easily be triggered by a malicious user by applying attack techniques such as forceful browsing. This paper shows how to guarantee the absence of runtime errors due to broken dependencies on session data in Web applications. The proposed solution combines\u00a0\u2026", "num_citations": "19\n", "authors": ["328"]}
{"title": "Iterators revisited: Proof rules and implementation\n", "abstract": " The Iterator design pattern allows client code to access the elements of an aggregate object sequentially without exposing its underlying representation. Several modern programming languages, like Java or C#, include constructs that facilitate the implementation of the Iterator design pattern. They typically provide for-each loops for client code and iterator methods that specify the values yielded by the enumeration. However, when iterator methods are used to perform recursive enumerations, such as when enumerating the nodes of a tree, the worst-case running time often becomes quadratic.", "num_citations": "19\n", "authors": ["328"]}
{"title": "Provably secure isolation for interruptible enclaved execution on small microprocessors\n", "abstract": " Computer systems often provide hardware support for isolation mechanisms like privilege levels, virtual memory, or enclaved execution. Over the past years, several successful software-based side-channel attacks have been developed that break, or at least significantly weaken the isolation that these mechanisms offer. Extending a processor with new architectural or micro-architectural features, brings a risk of introducing new such side-channel attacks. This paper studies the problem of extending a processor with new features without weakening the security of the isolation mechanisms that the processor offers. We propose to use full abstraction as a formal criterion for the security of a processor extension, and we instantiate that criterion to the concrete case of extending a microprocessor that supports enclaved execution with secure interruptibility of these enclaves. This is a very relevant instantiation as several\u00a0\u2026", "num_citations": "18\n", "authors": ["328"]}
{"title": "Unifiers as equivalences: Proof-relevant unification of dependently typed data\n", "abstract": " Dependently typed languages such as Agda, Coq and Idris use a syntactic first-order unification algorithm to check definitions by dependent pattern matching. However, these algorithms don\u2019t adequately consider the types of the terms being unified, leading to various unintended results. As a consequence, they require ad hoc restrictions to preserve soundness, but this makes them very hard to prove correct, modify, or extend.   This paper proposes a framework for reasoning formally about unification in a dependently typed setting. In this framework, unification rules compute not just a unifier but also a corresponding correctness proof in the form of an equivalence between two sets of equations. By rephrasing the standard unification rules in a proof-relevant manner, they are guaranteed to preserve soundness of the theory. In addition, it enables us to safely add new rules that can exploit the dependencies between\u00a0\u2026", "num_citations": "18\n", "authors": ["328"]}
{"title": "The VeriFast program verifier: A tutorial\n", "abstract": " VeriFast is a program verification tool for verifying certain correctness properties of single-threaded and multithreaded C 1 programs. The tool reads a C program consisting of one or more. c source code files (plus any. h header files referenced from these. c files) and reports either \u201c0 errors found\u201d or indicates the location of a potential error. If the tool reports \u201c0 errors found\u201d, this means 2 that the program\u2022 does not perform illegal memory accesses, such as reading or writing a struct instance field after the struct instance has been freed, or reading or writing beyond the end of an array (known as a buffer overflow, the most common cause of security vulnerabilities in operating systems and internet services) and\u2022 does not include a certain type of concurrency errors known as data races, ie unsynchronized conflicting accesses of the same field by multiple threads. Accesses are considered conflicting if at least one of them is a write access. And\u2022 complies with function preconditions and postconditions specified by the programmer in the form of special comments (known as annotations) in the source code.Many errors in C programs, such as illegal memory accesses and data races, are generally very difficult to detect by conventional means such as testing or code review, since they are often subtle and typically do not cause a clean crash but have unpredictable effects that are difficult to diagnose. However, many security-critical and safety-critical programs, such as operating systems, device drivers, web servers (that may serve e-commerce or e-banking applications), embedded software for automobiles, airplanes, space applications, nuclear and\u00a0\u2026", "num_citations": "18\n", "authors": ["328"]}
{"title": "A principled approach to tracking information flow in the presence of libraries\n", "abstract": " There has been encouraging progress on information flow control for programs in increasingly complex programming languages, tracking the propagation of information from input sources to output sinks. Yet, programs are typically deployed in an environment with rich APIs and powerful libraries, posing challenges for information flow control when the code for these APIs and libraries is either unavailable or written in a different language.                 This paper presents a principled approach to tracking information flow in the presence of libraries. With the goal to strike the balance between security and precision, we present a framework that explores the middle ground between the \u201cshallow\u201d, signature-based modeling of libraries and the \u201cdeep\u201d, stateful approach, where library models need to be supplied manually. We formalize our approach for a core language, extend it with lists and higher-order functions\u00a0\u2026", "num_citations": "17\n", "authors": ["328"]}
{"title": "Discovering logical vulnerabilities in the Wi-Fi handshake using model-based testing\n", "abstract": " We use model-based testing techniques to detect logical vulnerabilities in implementations of the Wi-Fi handshake. This reveals new fingerprinting techniques, multiple downgrade attacks, and Denial of Service (DoS) vulnerabilities. Stations use the Wi-Fi handshake to securely connect with wireless networks. In this handshake, mutually supported capabilities are determined, and fresh pairwise keys are negotiated. As a result, a proper implementation of the Wi-Fi handshake is essential in protecting all subsequent traffic. To detect the presence of erroneous behaviour, we propose a model-based technique that generates a set of representative test cases. These tests cover all states of the Wi-Fi handshake, and explore various edge cases in each state. We then treat the implementation under test as a black box, and execute all generated tests. Determining whether a failed test introduces a security weakness is\u00a0\u2026", "num_citations": "17\n", "authors": ["328"]}
{"title": "Let\u2019s face it: Faceted values for taint tracking\n", "abstract": " Taint tracking has been successfully deployed in a range of security applications to track data dependencies in hardware and machine-, binary-, and high-level code. Precision of taint tracking is key for its success in practice: being a vulnerability analysis, false positives must be low for the analysis to be practical. This paper presents an approach to taint tracking, which does not involve tracking taints throughout computation. Instead, we include shadow memories in the execution context, so that a single run of a program has the effect of computing on both tainted and untainted data. This mechanism is inspired by the technique of secure multi-execution, while in contrast to the latter it does not require running the entire program multiple times. We present a general framework and establish its soundness with respect to explicit secrecy, a policy for preventing insecure data leaks, and its precision showing that\u00a0\u2026", "num_citations": "17\n", "authors": ["328"]}
{"title": "Towards availability and real-time guarantees for protected module architectures\n", "abstract": " Protected Module Architectures are a new brand of security architectures whose main objective is to support the secure isolated execution of software modules with a minimal Trusted Computing Base (TCB)--several prototypes for embedded systems (and also the Intel Software Guard eXtensions for higher-end systems) ensure isolation with a hardware-only TCB. However, while these architectures offer strong confidentiality and integrity guarantees for software modules, they offer no availability (let alone real-time) guarantees. This paper reports on our work-in-progress towards extending a protected module architecture for small microprocessors with availability and real-time guarantees. Our objective is to maintain the existing security guarantees with a hardware-only TCB, but to also guarantee availability (and even real-time properties) if one can also trust the scheduler. The scheduler, as any software on the\u00a0\u2026", "num_citations": "17\n", "authors": ["328"]}
{"title": "Facebook tracking through social plug-ins\n", "abstract": " This report provides a technical description of Facebook's online tracking capabilities enabled by its social plug-ins4. Social plug-ins are extremely popular, as website owners increase their audience if individuals share their content through online social networks. Facebook's Like Button, the most popular Facebook social plug-in, is present on 32% of the top 10.000 sites5, covering almost all website categories including health and government websites6.The near-ubiquity of the social plug-ins also makes them the ideal tool for collecting the browsing activities of Web users, also known as tracking7. For the purposes of this report,\u201ctracking\u201d is defined as the collection of users' web browsing activities across different websites. The type of tracking facilitated by Facebook social plug-ins is commonly referred to as\" third-party tracking\", because the tracker (eg Facebook) is a different party from the (first-party) website visited by the user, as displayed in the user's browser address bar.", "num_citations": "17\n", "authors": ["328"]}
{"title": "Towards equal rights for higher-kinded types\n", "abstract": " Generics are a very popular feature of contemporary OO languages, such as Java, C# or Scala. Their support for genericity is lacking, however. The problem is that they only support abstracting over proper types, and not over generic types. This limitation makes it impossible to, eg, define a precise interface for Iterable, a core abstraction in Scala\u2019s collection API. We implemented \u201ctype constructor polymorphism\u201d in Scala 2.5, which solves this problem at the root, thus greatly reducing the duplication of type signatures and code.", "num_citations": "17\n", "authors": ["328"]}
{"title": "An object-oriented approach to datatype-generic programming\n", "abstract": " Datatype-generic programming (DGP) is the next step beyond abstracting over types using parametric polymorphism, which is often called\" genericity\" in object-oriented languages. However, unlike genericity, DGP has not received much attention in the OO community. Nonetheless, in the context of functional languages, it has proven to make programs more robust with respect to changes in the type structure, as well as in many other applications, such as type-safe XML processing and marshalling. To carry these strengths over to an OO language, we present an extensible library for lightweight DGP in Scala, based on an existing lightweight approach in Haskell. We discuss the challenges in developing and using our library, and explore ways to overcome them.", "num_citations": "17\n", "authors": ["328"]}
{"title": "Authentic execution of distributed event-driven applications with a small TCB\n", "abstract": " This paper presents an approach to provide strong assurance of the secure execution of distributed event-driven applications on shared infrastructures, while relying on a small Trusted Computing Base. We build upon and extend security primitives provided by a Protected Module Architecture (PMA) to guarantee authenticity and integrity properties of applications, and to secure control of input and output devices used by these applications. More specifically, we want to guarantee that if an output is produced by the application, it was allowed to be produced by the application\u2019s source code. We present a prototype implementation as an extension of Sancus, a light-weight embedded PMA that extends the TI MSP430 CPU. Our evaluation of the security and performance aspects of our approach and the prototype show that PMAs together with our programming model form a basis for powerful security\u00a0\u2026", "num_citations": "16\n", "authors": ["328"]}
{"title": "Clubbing seals: Exploring the ecosystem of third-party security seals\n", "abstract": " In the current web of distrust, malware, and server compromises, convincing an online consumer that a website is secure, can make the difference between a visitor and a buyer. Third-party security seals position themselves as a solution to this problem, where a trusted external company vouches for the security of a website, and communicates it to visitors through a security seal which the certified website can embed in its pages. In this paper, we explore the ecosystem of third-party security seals focusing on their security claims, in an attempt to quantify the difference between the advertised guarantees of security seals, and reality. Through a series of automated and manual experiments, we discover a real lack of thoroughness from the side of the seal providers, which results in obviously insecure websites being certified as secure. Next to the incomplete protection, we demonstrate how malware can trivially evade\u00a0\u2026", "num_citations": "16\n", "authors": ["328"]}
{"title": "Provable protection against web application vulnerabilities related to session data dependencies\n", "abstract": " Web applications are widely adopted and their correct functioning is mission critical for many businesses. At the same time, Web applications tend to be error prone and implementation vulnerabilities are readily and commonly exploited by attackers. The design of countermeasures that detect or prevent such vulnerabilities or protect against their exploitation is an important research challenge for the fields of software engineering and security engineering. In this paper, we focus on one specific type of implementation vulnerability, namely, broken dependencies on session data. This vulnerability can lead to a variety of erroneous behavior at runtime and can easily be triggered by a malicious user by applying attack techniques such as forceful browsing. This paper shows how to guarantee the absence of runtime errors due to broken dependencies on session data in Web applications. The proposed solution combines\u00a0\u2026", "num_citations": "16\n", "authors": ["328"]}
{"title": "Sound reasoning about unchecked exceptions\n", "abstract": " In most software development projects, it is not feasible for developers to handle explicitly all possible unusual events which may occur during program execution, such as arithmetic overflow, highly unusual environment conditions, heap memory or call stack exhaustion, or asynchronous thread cancellation. Modern programming languages provide unchecked exceptions to deal with these circumstances safely and with minimal programming overhead. However, reasoning about programs in the presence of unchecked exceptions is difficult, especially in a multithreaded setting where the system should survive the failure of a subsystem. We propose a static verification approach for multithreaded programs with unchecked exceptions. Our approach is an extension of the Spec# verification methodology for object-oriented programs. It verifies that objects encapsulating shared resources are always ready to be\u00a0\u2026", "num_citations": "16\n", "authors": ["328"]}
{"title": "Inspector Methods for State Abstraction.\n", "abstract": " Consider the program in Figure 1. Class Cell provides access to the state of a Cell object using method getX. It also uses getX to specify the effect of the class\u2019s constructor and of the setX method. This makes it possible to prove the correctness of the client program using a proof that does not depend on the internal representation of the Cell object\u2019s state using field x. As a result, when class Cell\u2019s internal representation is changed, only class Cell needs to be reverified. The client program\u2019s proof remains valid.", "num_citations": "16\n", "authors": ["328"]}
{"title": "Selective attribute elimination for categorical data specifications\n", "abstract": " Semantic data specifications are important components of most object oriented software development methodologies. When making a semantic data specification, one has to classify the different kinds of entities that occur in the part of the real world one wants to specify. This classification can be done in two semantically equivalent ways: by putting them in different entity types, or by putting them in one entity type and distinguishing them by means of an attribute. This redundancy, which exists in almost all semantic data specification systems, leads to problems during the view integration process. If two software engineers have chosen to do this classification in a different way, it is hard to integrate their specifications.             In this paper we develop and prove correct a transformation which, given a specification that models the real world in one of these ways, computes a new specification that models the real\u00a0\u2026", "num_citations": "16\n", "authors": ["328"]}
{"title": "Operating channel validation: preventing Multi-Channel Man-in-the-Middle attacks against protected Wi-Fi networks\n", "abstract": " We present a backwards compatible extension to the 802.11 standard to prevent multi-channel man-in-the-middle attacks. This extension authenticates parameters that define the currently in-use channel.", "num_citations": "15\n", "authors": ["328"]}
{"title": "An implementation of a high assurance smart meter using protected module architectures\n", "abstract": " Due to ongoing changes in the power grid towards decentralised and highly volatile energy production, smart electricity meters are required to provide fine-grained measurement and timely remote access to consumption and production data. This enables flexible tariffing and dynamic load optimisation. As the power grid forms part of the critical infrastructure of our society, increasing the resilience of the grid\u2019s software components against failures and attacks is vitally important.                 In this paper we explore the use of Protected Module Architectures (PMAs) to securely implement and deploy software for smart electricity meters. Outlining security challenges and an architectural solution in the light of security features provided by PMAs, we evaluate a proof-of-concept implementation of a security-focused smart metering scenario. Our implementation is based on Sancus, an embedded PMA for low-power\u00a0\u2026", "num_citations": "15\n", "authors": ["328"]}
{"title": "Software security: Vulnerabilities and countermeasures for two attacker models\n", "abstract": " History has shown that attacks against network-connected software based systems are common and dangerous. An important fraction of these attacks exploit implementation details of the software based system. These attacks - sometimes called low-level attacks - rely on characteristics of the hardware, compiler or operating system used to execute software programs to make these programs misbehave, or to extract sensitive information from them. With the increased Internet-connectivity of embedded devices, including industrial control systems, sensors as well as consumer devices, there is a substantial risk that similar attacks will target these devices. This tutorial paper explains the vulnerabilities, attacks and countermeasures relevant for low-level software security. The paper discusses software security for two different attacker models: the classic model of an attacker that can only interact with the program by\u00a0\u2026", "num_citations": "15\n", "authors": ["328"]}
{"title": "Fixing non-determinism\n", "abstract": " Non-deterministic computations are conventionally modelled by lists of their outcomes. This approach provides a concise declarative description of certain problems, as well as a way of generically solving such problems.", "num_citations": "15\n", "authors": ["328"]}
{"title": "SecSess: Keeping your session tucked away in your browser\n", "abstract": " Session management is a crucial component in every modern web application. It links subsequent requests and temporary stateful information together, enabling a rich and interactive user experience. Unfortunately, the de facto standard cookie-based session management mechanism is imperfect, which is why session management vulnerabilities rank second in the OWASP top 10 of web application vulnerabilities [18]. While improved session management mechanisms have been proposed, none of them achieves compatibility with currently deployed applications or infrastructure components such as web caches.", "num_citations": "15\n", "authors": ["328"]}
{"title": "Salus: Kernel support for secure process compartments\n", "abstract": " Consumer devices are increasingly being used to perform security and privacy critical tasks. The software used to perform these tasks is often vulnerable to attacks, due to bugs in the application itself or in included software libraries. Recent work proposes the isolation of security-sensitive parts of applications into protected modules, each of which can be accessed only through a predefined public interface. But most parts of an application can be considered security-sensitive at some level, and an attacker who is able to gain in-application level access may be able to abuse services from protected modules. We propose Salus, a Linux kernel modification that provides a novel approach for partitioning processes into isolated compartments sharing the same address space. Salus significantly reduces the impact of insecure interfaces and vulnerable compartments by enabling compartments (1) to restrict the system calls they are allowed to perform,(2) to authenticate their callers and callees and (3) to enforce that they can only be accessed via unforgeable references. We describe the design of Salus, report on a prototype implementation and evaluate it in terms of security and performance. We show that Salus provides a significant security improvement with a low performance overhead, without relying on any non-standard hardware support.", "num_citations": "15\n", "authors": ["328"]}
{"title": "A generic architecture for web applications to support threat analysis of infrastructural components\n", "abstract": " In order to perform a useful threat analysis of a web application platform, some architectural assumptions about such applications must be made. This document describes a generic architecture for typical 3-tier web applications. It serves as the basis for analyzing the threats in the most important infrastructural components in that architecture, presented in the following papers.", "num_citations": "15\n", "authors": ["328"]}
{"title": "A realistic experiment in knowledge representation in open event calculus: Protocol specification\n", "abstract": " This paper presents one of the rst realistic experiments in the use of Event Calculus in Open Logic Programming: the speci cation of a process protocol. The speci cation task involves most of the common complications of temporal reasoning: the representation of context dependent actions, of preconditions and rami cations of actions, the modelling of system faults, and most of all, the representation of uncertainty of actions. As the underlying language, the Open Logic Programming formalism, an extension of Logic Programming, is used. The experiment shows that Event Calculus is a promising candidate for the speci cation of dynamic systems. A comparison between speci cation of process protocols in Event Calculus and in the more commonly used process algebras shows fundamental di erences between the two approaches.", "num_citations": "15\n", "authors": ["328"]}
{"title": "Mitigating password database breaches with Intel SGX\n", "abstract": " In order to prevent rainbow attacks against a stolen password database, most passwords are appended with a unique salt before hashing them as to make the password random and more secure. However, the decreasing cost of hardware has made it feasible to perform brute force attacks by guessing the passwords (even when extended with their salt).", "num_citations": "14\n", "authors": ["328"]}
{"title": "Salus: Non-hierarchical memory access rights to enforce the principle of least privilege\n", "abstract": " Consumer devices are increasingly being used to perform security and privacy critical tasks. The software used to perform these tasks is often vulnerable to attacks, due to bugs in the application itself or in included software libraries. Recent work proposes the isolation of security-sensitive parts of applications into protected modules, each of which can only be accessed through a predefined public interface. But most parts of an application can be considered security-sensitive at some level, and an attacker that is able to gain in-application level access may be able to abuse services from protected modules.               We propose Salus, a Linux kernel modification that provides a novel approach for partitioning processes into isolated compartments. By enabling compartments to restrict the system calls they are allowed to perform and to authenticate their callers and callees, the impact of unsafe interfaces and\u00a0\u2026", "num_citations": "14\n", "authors": ["328"]}
{"title": "Security enforcement aware software development\n", "abstract": " In the domain of security policy enforcement, the concerns of application developers are almost completely ignored. As a consequence, it is hard to develop useful and reliable applications that will function properly under a variety of policies. This paper addresses this issue for application security policies specified as security automata, and enforced through run-time monitoring. Our solution consists of three elements: the definition of an abstract interface to the policy that is being enforced, a sound construct to query that policy, and a static verification algorithm that guarantees absence of security policy violations in critical blocks of code.", "num_citations": "14\n", "authors": ["328"]}
{"title": "Symbolic execution of security protocol implementations: handling cryptographic primitives\n", "abstract": " We show how to efficiently simulate cryptographic primitives during symbolic execution. This allows analysis of security protocol implementations, and revealed several flaws in implementations of WPA2's 4-way handshake.", "num_citations": "13\n", "authors": ["328"]}
{"title": "Lightweight and flexible trust assessment modules for the Internet of Things\n", "abstract": " In this paper we describe a novel approach to securely obtain measurements with respect to the integrity of software running on a low-cost and low-power computing node autonomously or on request. We propose to use these measurements as an indication of the trustworthiness of that node. Our approach is based on recent developments in Program Counter Based Access Control. Specifically, we employ Sancus, a light-weight hardware-only Trusted Computing Base and Protected Module Architecture, to integrate trust assessment modules into an untrusted embedded OS without using a hypervisor. Sancus ensures by means of hardware extensions that code and data of a protected module cannot be tampered with, and that the module\u2019s data remains confidential. Sancus further provides cryptographic primitives that are employed by our approach to enable the trust management system to verify that\u00a0\u2026", "num_citations": "13\n", "authors": ["328"]}
{"title": "Primer on client-side web security\n", "abstract": " This volume illustrates the continuous arms race between attackers and defenders of the Web ecosystem by discussing a wide variety of attacks. In the first part of the book, the foundation of the Web ecosystem is briefly recapped and discussed. Based on this model, the assets of the Web ecosystem are identified, and the set of capabilities an attacker may have are enumerated. In the second part, an overview of the web security vulnerability landscape is constructed. Included are selections of the most representative attack techniques reported in great detail. In addition to descriptions of the most common mitigation techniques, this primer also surveys the research and standardization activities related to each of the attack techniques, and gives insights into the prevalence of those very attacks. Moreover, the book provides practitioners a set of best practices to gradually improve the security of their web-enabled services. Primer on Client-Side Web Security expresses insights into the future of web application security. It points out the challenges of securing the Web platform, opportunities for future research, and trends toward improving Web security.", "num_citations": "13\n", "authors": ["328"]}
{"title": "Verification of unloadable modules\n", "abstract": " Programs in unsafe languages, like C and C++, may dynamically load and unload modules. For example, some operating system kernels support dynamic loading and unloading of device drivers. This causes specific difficulties in the verification of such programs and modules; in particular, it must be verified that no functions or global variables from the module are used after the module is unloaded.               We present the approach we used to add support for loading and unloading modules to our separation-logic-based program verifier VeriFast. Our approach to the specification and verification of function pointer calls, based on parameterizing function types by predicates, is sound in the presence of unloading, but at the same time does not complicate the verification of programs that perform no unloading, and does not require callers to distinguish between function pointers that point into unloadable\u00a0\u2026", "num_citations": "13\n", "authors": ["328"]}
{"title": "Prototyping a tool environment for run-time assertion checking in JML with communication histories\n", "abstract": " In this paper we present prototype tool-support for the runtime assertion checking of the Java Modeling Language (JML) extended with communication histories specified by attribute grammars. Our tool suite integrates Rascal, a meta programming language and ANTLR, a popular parser generator. Rascal instantiates a generic model of history updates for a given Java program annotated with history specifications. ANTLR is used for the actual evaluation of history assertions.", "num_citations": "13\n", "authors": ["328"]}
{"title": "Protecting global and static variables from buffer overflow attacks\n", "abstract": " Many countermeasures exist to protect the stack and heap from code injection attacks, however very few countermeasures exist that will specifically protect global and static variables from attack. In this paper we suggest a way of protecting global and static variables from these type of attacks, with negligible performance and memory overheads. Our approach is based on the idea of separating data in de data segment based on its type. These separated areas are then protected from each other by a guard page. This prevents a buffer overflow from overwriting data or code pointers, in turn preventing attackers from being able to perform a code injection attack.", "num_citations": "13\n", "authors": ["328"]}
{"title": "A simple sequential reasoning approach for sound modular verification of mainstream multithreaded programs\n", "abstract": " Reasoning about multithreaded object-oriented programs is difficult, due to the non-local nature of object aliasing, data races, and deadlocks. We propose a programming model that prevents data races and deadlocks, and supports local reasoning in the presence of object aliasing and concurrency. Our programming model builds on the multi-threading and synchronization primitives as they are present in current mainstream languages. Java or C# programs developed according to our model can be annotated by means of stylized comments to make the use of the model explicit. We show that such annotated programs can be formally verified to comply with the programming model. In other words, if the annotated program verifies, the underlying Java or C# program is guaranteed to be free from data races and deadlocks, and it is sound to reason locally about program behavior. Our approach supports immutable\u00a0\u2026", "num_citations": "13\n", "authors": ["328"]}
{"title": "Adaptable access control policies for medical information systems\n", "abstract": " IT enforced access control policies in medical information systems have to be fine-grained and dynamic. We justify this observation on the basis of legislation and on the basis of the evolution within the healthcare domain. Consequently, a reconfigurable or at least adaptable implementation of access control facilities has become extremely important. For this purpose, current technology provides insufficient support. We highlight a basic solution to address shortcomings by using interception techniques. In addition, we identify further research that is required to address the challenges of dynamic and fine-grained access control in the long run.", "num_citations": "13\n", "authors": ["328"]}
{"title": "Developing secure software\n", "abstract": " More and more software is deployed in an environment with wide area network connectivity, in particular with connectivity to the Internet. Software developers are not always aware of the security implications of this connectivity, and hence the software they produce contains a large number of vulnerabilities exploitable by attackers.               Statistics show that a limited number of types of vulnerabilities account for the majority of successful attacks on the Internet. Hence, we believe that it is very useful for a software developer to have a deep understanding of these kinds of vulnerabilities, in order to avoid them in new software. In this paper, we present a survey and classification of the most commonly exploited software vulnerabilities.", "num_citations": "13\n", "authors": ["328"]}
{"title": "Breaking virtual memory protection and the SGX ecosystem with foreshadow\n", "abstract": " Foreshadow is a speculative execution attack that allows adversaries to subvert the security guarantees of Intel's Software Guard eXtensions (SGX). Foreshadow allows access to data across process boundaries, and allows virtual machines (VMs) to read the physical memory belonging to other VMs or the hypervisor.", "num_citations": "12\n", "authors": ["328"]}
{"title": "Protected web components: Hiding sensitive information in the shadows\n", "abstract": " Most modern Web applications depend on the integration of code from third-party providers, such as JavaScript libraries and advertisements. Because the included code runs within the page's security context, it represents an attractive attack target, allowing the compromise of numerous Web applications through a single attack vector (such as a malicious advertisement). Such opportunistic attackers aim to execute low-profile, nontargeted, widely applicable data-gathering attacks, such as the silent extraction of user-specific data and authentication credentials. In this article, the authors show that third-party code inclusion is rampant, even in privacy-sensitive applications such as online password managers, thereby potentially exposing the user's most sensitive data to attackers. They propose protected Web components, which leverage the newly proposed Web components, repurposing them to protect private data\u00a0\u2026", "num_citations": "12\n", "authors": ["328"]}
{"title": "Pesap: A privacy enhanced social application platform\n", "abstract": " Nowadays, social networking sites provide third party application developers with means to access their social graph, by providing a social application platform. Through their users, these developers acquire a significant set of personal information from the social graph. The current protection mechanisms, such as privacy policies and access control mechanisms fall short on protecting the privacy of the users. In this paper we present a framework for a privacy enhanced social application platform, called PESAP, that technically enforces the protection of the personal information of a user, when interacting with social applications. The framework is based on two pillars: anonymization of the social graph and secure information flow inside the browser. PESAP is targeted to be as compatible as possible with the current state-of-the-art design of social application platforms, while technically enforcing the protection of user\u00a0\u2026", "num_citations": "12\n", "authors": ["328"]}
{"title": "Automatic verification of Java programs with dynamic frames\n", "abstract": " Framing in the presence of data abstraction is a challenging and important problem in the verification of object-oriented programs Leavens et\u00a0al. (Formal Aspects Comput (FACS) 19:159\u2013189, 2007). The dynamic frames approach is a promising solution to this problem. However, the approach is formalized in the context of an idealized logical framework. In particular, it is not clear the solution is suitable for use within a program verifier for a Java-like language based on verification condition generation and automated, first-order theorem proving. In this paper, we demonstrate that the dynamic frames approach can be integrated into an automatic verifier based on verification condition generation and automated theorem proving. The approach has been proven sound and has been implemented in a verifier prototype. The prototype has been used to prove correctness of several programming patterns\u00a0\u2026", "num_citations": "12\n", "authors": ["328"]}
{"title": "Modular full functional specification and verification of lock-free data structures\n", "abstract": " We propose an approach for specifying and verifying full functional (partial) correctness of modules of multithreaded imperative programs that implement or use lock-free data structures for interthread communication. The approach extends separation logic with simple atomic spaces, which are regions of memory that may be accessed concurrently using atomic operations. A fixed invariant is associated with each atomic space. The specification of an atomic operation consists of the usual precondition and postcondition, as well as a number of proof obligations. The precondition requires permission to access an atomic space. The proof obligations state that, in the specific context of the call, the atomic space\u2019s invariant can be rewritten to separate out the lock-free data structure, and that updating the data structure preserves the invariant. To allow threads to retain information about the state of the data structure, a combination of fractional permissions and ghost cells is used in a way similar to the use of auxiliary variables in Owicki-Gries reasoning. The approach has been implemented in the VeriFast program verifier, and used to verify an implementation and a client program of a multiple-enqueueer, single-dequeueer lock-free queue.", "num_citations": "12\n", "authors": ["328"]}
{"title": "CopyCat: Controlled Instruction-Level Attacks on Enclaves\n", "abstract": " The adversarial model presented by trusted execution environments (TEEs) has prompted researchers to investigate unusual attack vectors. One particularly powerful class of controlled-channel attacks abuses page-table modifications to reliably track enclave memory accesses at a page-level granularity. In contrast to noisy microarchitectural timing leakage, this line of deterministic controlled-channel attacks abuses indispensable architectural interfaces and hence cannot be mitigated by tweaking microarchitectural resources.", "num_citations": "11\n", "authors": ["328"]}
{"title": "Copycat: Controlled instruction-level attacks on enclaves for maximal key extraction\n", "abstract": " The adversarial model presented by trusted execution environments (TEEs) has prompted researchers to investigate unusual attack vectors. One particularly powerful class of controlledchannel attacks abuses page-table modifications to reliably track enclave memory accesses at a page-level granularity. In contrast to noisy microarchitectural timing leakage, this line of deterministic controlled-channel attacks abuses indispensable architectural interfaces and hence cannot be mitigated by tweaking microarchitectural resources. We propose an innovative controlled-channel attack, named COPYCAT, that deterministically counts the number of instructions executed within a single enclave code page. We show that combining the instruction counts harvested by COPYCAT with traditional, coarse-grained page-level leakage allows the accurate reconstruction of enclave control flow at a maximal instruction-level granularity. COPYCAT can identify intra-page and intra-cache line branch decisions that ultimately may only differ in a single instruction, underscoring that even extremely subtle control flow deviations can be deterministically leaked from secure enclaves. We demonstrate the improved resolution and practicality of COPYCAT on Intel SGX in an extensive study of single-trace and deterministic attacks against cryptographic implementations, and give novel algorithmic attacks to perform single-trace key extraction that exploit subtle vulnerabilities in the latest versions of widely-used cryptographic libraries. Our findings highlight the importance of stricter verification of cryptographic implementations, especially in the context of TEEs.", "num_citations": "11\n", "authors": ["328"]}
{"title": "Automatically generating secure wrappers for SGX enclaves from separation logic specifications\n", "abstract": " Intel Software Guard Extensions (SGX) is a recent technology from Intel that makes it possible to execute security-critical parts of an application in a so-called SGX enclave, an isolated area of the system that is shielded from all other software (including the OS and/or hypervisor). SGX was designed with the objective of making it relatively straightforward to take a single module of an existing C application, and put that module in an enclave. The SGX SDK includes tooling to semi-automatically generate wrappers for an enclaved C module. The wrapped enclave can then easily be linked to the legacy application that uses the module.                 However, when the enclaved module and the surrounding application share a part of the heap and exchange pointers (a very common case in C programs), the generation of these wrappers requires programmer annotations and is error-prone \u2013 it is easy to introduce\u00a0\u2026", "num_citations": "11\n", "authors": ["328"]}
{"title": "FRP IoT modules as a Scala DSL\n", "abstract": " With Internet of Things applications growing in size and popularity, physical sensor networks are more often running multiple complex applications. It becomes increasingly important to maintain these event-driven programs on embedded systems. Traditionally, event-driven applications such as sensor network applications are written using an imperative style of programming where different callback routines are registered to handle events. As the application complexity grows, the inverted control flow and reliance on shared global state makes this style of programming hard to maintain. Furthermore, sensor network applications are inherently distributed and are written by manually managing code-bases of sub-applications that go on all nodes separately. If security is important, the programmer needs to manually interface with low-level security primitives because there is no built-in notion of components.", "num_citations": "11\n", "authors": ["328"]}
{"title": "Learning assertions to verify linked-list programs\n", "abstract": " C programs that manipulate list-based dynamic data structures remain a challenging target for static verification. In this paper we employ the dynamic analysis of dsOli to locate and identify data structure operations in a program, and then use this information to automatically annotate that program with assertions in separation logic. These annotations comprise candidate pre/post-conditions and loop invariants suitable to statically verify memory safety with the verification tool VeriFast. By using both textbook and real-world examples on our prototype implementation, we show that the generated assertions are often discharged automatically. Even when this is not the case, candidate invariants are of great help to the verification engineer, significantly reducing the manual verification effort.", "num_citations": "11\n", "authors": ["328"]}
{"title": "Finally tagless observable recursion for an abstract grammar model\n", "abstract": " We define a finally tagless, shallow embedding of a typed grammar language. In order to avoid the limitations of traditional parser combinator libraries (no bottom-up parsing, no full grammar analysis or transformation), we require object-language recursion to be observable in the meta-language. Since existing proposals for recursive constructs are not fully satisfactory, we propose new finally tagless primitive recursive constructs to solve the problem. To do this in a well-typed way, we require considerable infrastructure, for which we reuse techniques from the multirec generic programming library. Our infrastructure allows a precise model of the complex interaction between a grammar, a parsing algorithm and a set of semantic actions. On the flip side, our approach requires the grammar author to provide a type- and value-level encoding of the grammar's domain and we can provide only a limited form of constructs\u00a0\u2026", "num_citations": "11\n", "authors": ["328"]}
{"title": "DEMACRO: Defense against malicious cross-domain requests\n", "abstract": " In the constant evolution of theWeb, the simple always gives way to the more complex. Static webpages with click-through dialogues are becoming more and more obsolete and in their place, asynchronous JavaScript requests, Web mash-ups and proprietary plug-ins with the ability to conduct cross-domain requests shape the modern user experience. Three recent studies showed that a significant number ofWeb applications implement poor cross-domain policies allowing malicious domains to embed Flash and Silverlight applets which can conduct arbitrary requests to these Web applications under the identity of the visiting user. In this paper, we confirm the findings of the aforementioned studies and we design DEMACRO, a client-side defense mechanism which detects potentially malicious cross-domain requests and de-authenticates them by removing existing session credentials. Our system requires\u00a0\u2026", "num_citations": "11\n", "authors": ["328"]}
{"title": "Theoretical aspects of compositional symbolic execution\n", "abstract": " Given a program and an assertion in that program, determining if the assertion can fail is one of the key applications of program analysis. Symbolic execution is a well-known technique for finding such assertion violations that can enjoy the following two interesting properties. First, symbolic execution can be precise: if it reports that an assertion can fail, then there is an execution of the program that will make the assertion fail. Second, it can be progressing: if there is an execution that makes the assertion fail, it will eventually be found. A symbolic execution algorithm that is both precise and progressing is a semi-decision procedure.               Recently, compositional symbolic execution has been proposed. It improves scalability by analyzing each execution path of each method only once. However, proving precision and progress is more challenging for these compositional algorithms. This paper investigates\u00a0\u2026", "num_citations": "11\n", "authors": ["328"]}
{"title": "Supporting security monitor-aware development\n", "abstract": " With the emergence of support for third-party applications on mobile devices such as cell phones and PDA's, support for setting application security policies is also built into these devices. While this can significantly increase security for end-users, it also significantly complicates the task of building useful and reliable applications for these devices. Different devices will set different policies, and violations of the policy will lead to security exceptions or even immediate abortion of the application potentially leaving it in an inconsistent state. This paper addresses this issue in the context of application security policies specified by means of security automata, and enforced by means of run-time monitoring. We propose a language element, the check block, that developers can use to make their applications more security monitor-aware. At run-time, a check block will query the security policy enforced by the monitor to make\u00a0\u2026", "num_citations": "11\n", "authors": ["328"]}
{"title": "Implementing a modular access control service to support application-specific policies in caesarj\n", "abstract": " Ideally, the enforcement of application-specific policies in an access control service should be untangled from the application logic. The access control services that are provided in state-of-the-art application servers typically fail to support such a separation. Aspect-Oriented Software Development techniques can be used to alleviate such shortcomings. This paper describes the design and implementation of a modular access control service that improves the separation between application logic and access control. The prototype has been implemented in CaesarJ.", "num_citations": "11\n", "authors": ["328"]}
{"title": "Proving semantical equivalence of data specifications\n", "abstract": " More than two decades ago, Peter Freyd introduced essentially algebraic specifications, a well-behaved generalization of algebraic specifications, allowing for equational partiality. These essentially algebraic specifications turn out to have a number of very interesting applications in computer science. In this paper, we present a deduction system for essentially algebraic specifications that is very suitable as the underlying deduction system of an automated theorem prover. Using the well-known fact that theories of sketches can be constructed as initial algebras of essentially algebraic specifications, we describe a semi-automatic procedure for proving the equivalence of the theories of two sketches. Next, we demonstrate that sketches are a very suitable formalism for making semantic data specifications, as used in database design and software engineering. Two such data specifications are semantically equivalent\u00a0\u2026", "num_citations": "11\n", "authors": ["328"]}
{"title": "Canonical forms for data-specifications\n", "abstract": " Certain real-world situations can be specified in a number of different (nonisomorphic) ways. In other words: equivalence of specifications does not imply isomorphism of specifications.", "num_citations": "11\n", "authors": ["328"]}
{"title": "Temporal safety for stack allocated memory on capability machines\n", "abstract": " Memory capabilities as supported in capability machines are very similar to fat pointers, and hence are very useful for the efficient enforcement of spatial memory safety. Enforcing temporal memory safety however, is more challenging. This paper investigates an approach to enforce temporal memory safety for stack-allocated memory in C-like languages by extending capabilities with a simple dynamic mechanism. This mechanism ensures that capabilities with a certain lifetime can only be stored in memory that has a longer lifetime. Our mechanism prevents temporal memory safety violations, yet is sufficiently permissive to allow typical C coding idioms where addresses of local variables are passed up the call stack. We formalize the desired behavior of a simple C-like language as a dependently typed operational semantics, and we show that existing compilers to capability machines do not simulate this desired\u00a0\u2026", "num_citations": "10\n", "authors": ["328"]}
{"title": "Tracking information flow via delayed output\n", "abstract": " This paper focuses on tracking information flow in the presence of delayed output. We motivate the need to address delayed output in the domains of IoT apps and email marketing. We discuss the threat of privacy leaks via delayed output in code published by malicious app makers on popular IoT app platforms. We discuss the threat of privacy leaks via delayed output in non-malicious code on popular platforms for email-driven marketing. We present security characterizations of projected noninterference and projected weak secrecy to capture information flows in the presence of delayed output in malicious and non-malicious code, respectively. We develop two security type systems: for information flow control in potentially malicious code and for taint tracking in non-malicious code, engaging read and write security types to soundly enforce projected noninterference and projected weak secrecy.", "num_citations": "10\n", "authors": ["328"]}
{"title": "Prudent design principles for information flow control\n", "abstract": " Recent years have seen a proliferation of research on information flow control. While the progress has been tremendous, it has also given birth to a bewildering breed of concepts, policies, conditions, and enforcement mechanisms. Thus, when designing information flow controls for a new application domain, the designer is confronted with two basic questions:(i) What is the right security characterization for a new application domain? and (ii) What is the right enforcement mechanism for a new application domain?", "num_citations": "10\n", "authors": ["328"]}
{"title": "Secure resource sharing for embedded protected module architectures\n", "abstract": " Low-end embedded devices and the Internet of Things (IoT) are becoming increasingly important for our lives. They are being used in domains such as infrastructure management, and medical and healthcare systems, where business interests and our security and privacy are at stake. Yet, security mechanisms have been appallingly neglected on many IoT platforms. In this paper we present a secure access control mechanism for extremely lightweight embedded microcontrollers. Being based on Sancus, a hardware-only Trusted Computing Base and Protected Module Architecture for the embedded domain, our mechanism allows for multiple software modules on an IoT-node to securely share resources. We implement and evaluate our approach for two application scenarios, a shared memory system and a shared flash drive. Our implementation is based on a Sancus-enabled TI MSP430 microcontroller\u00a0\u2026", "num_citations": "10\n", "authors": ["328"]}
{"title": "Client side web session integrity as a non-interference property\n", "abstract": " Sessions on the web are fragile. They have been attacked successfully in many ways, by network-level attacks, by direct attacks on session cookies (the main mechanism for implementing the session concept) and by application-level attacks where the integrity of sessions is violated by means of cross-site request forgery or malicious script inclusion. This paper defines a variant of non-interference \u2013 the classical security notion from information flow security \u2013 that can be used to formally define the notion of client-side application-level web session integrity. The paper also develops and proves correct an enforcement mechanism. Combined with state-of-the-art countermeasures for network-level and cookie-level attacks, this enforcement mechanism gives very strong assurance about the client-side preservation of session integrity for authenticated sessions.", "num_citations": "10\n", "authors": ["328"]}
{"title": "Partial type signatures for haskell\n", "abstract": " Strong type systems can be used to increase the reliability and performance of programs. In combination with type inference the overhead for the programmer can be kept small. Nevertheless, explicit type signatures often remain needed or useful. In languages with standard Hindley-Milner-based type systems, programmers have a binary choice between omitting the type signature (and rely on type inference) or explicitly providing the type entirely; there are no intermediate options. Proposals for partial type signatures exist, but none support features like local constraints and GHC\u2019s non-generalisation of local bindings. Therefore we propose and motivate a practical form of partial type signatures for present-day Haskell. We formally describe our proposal as an extension of the OutsideIn(X) system and prove some of its properties. We have developed a (not yet complete) implementation for the GHC Haskell\u00a0\u2026", "num_citations": "10\n", "authors": ["328"]}
{"title": "CPM: Masking code pointers to prevent code injection attacks\n", "abstract": " Code Pointer Masking (CPM) is a novel countermeasure against code injection attacks on native code. By enforcing the correct semantics of code pointers, CPM thwarts attacks that modify code pointers to divert the application\u2019s control flow. It does not rely on secret values such as stack canaries and protects against attacks that are not addressed by state-of-the-art countermeasures of similar performance. This article reports on two prototype implementations on very distinct processor architectures, showing that the idea behind CPM is portable. The evaluation also shows that the overhead of using our countermeasure is very small and the security benefits are substantial.", "num_citations": "10\n", "authors": ["328"]}
{"title": "Verification of programs with inspector methods\n", "abstract": " Most classes in an object-oriented program provide access to an object\u2019s state through methods, so that client code does not depend on and cannot interfere with the object\u2019s internal representation composed of fields and internal component objects. Methods used for this purpose are sometimes called inspector methods. In order to extend the benefits of inspector methods to specifications, the method contracts of non-inspector methods may be expressed using inspector methods, hence providing support for state abstraction in specifications. In this paper, we propose an approach to the verification of programs that use inspector methods in method contracts and object invariants. Inspector methods may have parameters, and they may depend on the state of objects passed as arguments. Our approach builds on the Boogie methodology for object invariants and ownership. Performing state abstraction in a programming language that allows aliasing through object references poses a framing problem. Specifically, client code needs to be able to tell whether modifying a given object or calling a given method may affect the value of a given inspector method call. We solve this by modeling inspector methods as functions that take as arguments only those parts of the heap on which they depend. Thanks to a novel logical encoding of the heap, we can do this without breaking information hiding, even in cases where inspector methods depend on internal component objects.", "num_citations": "10\n", "authors": ["328"]}
{"title": "A modular access control service for supporting application-specific policies\n", "abstract": " Aspect-oriented software development techniques can help modularize the enforcement of application-specific access control policies. Middleware platforms must cater to a variety of applications. The access control services integrated in these platforms support only access control policies with limited expressiveness and typically enforce only an invocation access policy. Enforcing such a policy only takes into account information in the method invocation and fails to include application state or context in the access decision process", "num_citations": "10\n", "authors": ["328"]}
{"title": "On the Practical Feasibility of Secure Distributed Computing\n", "abstract": " Secure Distributed Computing addresses the problem of performing a computation with a number of mutually distrustful participants, in such a way that each of the participants has only limited access to the information needed for doing the computation. Over the past decade, a number of solutions for this problem have been developed. The various proposed solutions differ in the cryptographic primitives that are used, and in the class of computations that can be performed. However, all sufficiently general solutions have one thing in common: the communication overhead between the involved parties seems to be prohibitive.               In this paper, we consider a concrete instance (with considerable practical interest) of the general problem of secure distributed computing, and we investigate how bad the communication overhead really is. This involves tailoring the different general solutions to the specific\u00a0\u2026", "num_citations": "10\n", "authors": ["328"]}
{"title": "Secure Compilation (Dagstuhl Seminar 18201)\n", "abstract": " Secure compilation is an emerging field that puts together advances in security, programming languages, verification, systems, and hardware architectures in order to devise secure compilation chains that eliminate many of today's vulnerabilities. Secure compilation aims to protect a source language's abstractions in compiled code, even against low-level attacks. For a concrete example, all modern languages provide a notion of structured control flow and an invoked procedure is expected to return to the right place. However, today's compilation chains (compilers, linkers, loaders, runtime systems, hardware) cannot efficiently enforce this abstraction: linked low-level code can call and return to arbitrary instructions or smash the stack, blatantly violating the high-level abstraction. The emerging secure compilation community aims to address such problems by devising formal security criteria, efficient enforcement mechanisms, and effective proof techniques. This seminar strived to take a broad and inclusive view of secure compilation and to provide a forum for discussion on the topic. The goal was to identify interesting research directions and open challenges by bringing together people working on building secure compilation chains, on developing proof techniques and verification tools, and on designing security mechanisms.", "num_citations": "9\n", "authors": ["328"]}
{"title": "Eliminating dependent pattern matching without K\n", "abstract": " Dependent pattern matching is an intuitive way to write programs and proofs in dependently typed languages. It is reminiscent of both pattern matching in functional languages and case analysis in on-paper mathematics. However, in general, it is incompatible with new type theories such as homotopy type theory (HoTT). As a consequence, proofs in such theories are typically harder to write and to understand. The source of this incompatibility is the reliance of dependent pattern matching on the so-called K axiom \u2013 also known as the uniqueness of identity proofs \u2013 which is inadmissible in HoTT. In this paper, we propose a new criterion for dependent pattern matching without K, and prove it correct by a translation to eliminators in the style of Goguen et al. (2006 Algebra, Meaning, and Computation). Our criterion is both less restrictive than existing proposals, and solves a previously undetected problem in the old\u00a0\u2026", "num_citations": "9\n", "authors": ["328"]}
{"title": "The Belgian electronic identity card: a verification case study\n", "abstract": " In the field of annotation-based source code level program verification for Java-like languages, separation-logic based verifiers offer a promising alternative to classic JML based verifiers such as ESC/Java2, the Mobius tool or Spec#. Researchers have demonstrated the advantages of separation logic based verification by showing that it is feasible to verify very challenging (though very small) sample code, such as design patterns, or highly concurrent code. However, there is little experience in using this new breed of verifiers on real code. In this paper we report on our experience of verifying several thousands of lines of Java Card code using VeriFast, one of the state-of-the-art separation logic based verifiers. We quantify annotation overhead, verification performance, and impact on code quality (number of bugs found). Finally, our experiments suggest a number of potential improvements to the VeriFast tool.", "num_citations": "9\n", "authors": ["328"]}
{"title": "A machine checked soundness proof for an intermediate verification language\n", "abstract": " Machine-checked proofs of properties of programming languages have gained in importance significantly over the past few years. This paper contributes to this trend by proposing an approach for doing machine-checked soundness proofs for verification condition (VC) generators. Our approach embraces the multi-phase VC generation common in modern program verifiers. Such verifiers split the generation of VCs in two (or even more) phases, using an intermediate verification language as the bridge between the programming language and logic. In our approach, we define a formal operational semantics of the intermediate verification language, and we prove the soundness of two translations separately: (1) the translation of the intermediate verification language to VCs, and (2) the translation of the source programming language to the intermediate language. This paper presents a fully machine checked\u00a0\u2026", "num_citations": "9\n", "authors": ["328"]}
{"title": "Requirements traceability to support evolution of access control\n", "abstract": " One of the hurdles in the enforcement of access control remains the translation of the organization's high level policy, that drives the access control decisions, down to technology specific deployment descriptors, configuration files and code. This huge gap between the high level policy and the access logic has as a consequence that it is hard to trace implementation fragments to the actual requirement they contribute to, and to support evolution. The notion of an access interface is introduced as a contract between the authorization engine and the various applications using its services. A so-called view connector makes sure that the application behaves consistently with this contract. The implementation is based on aspect orientation, rendering the whole design more robust in the light of unanticipated changes.", "num_citations": "9\n", "authors": ["328"]}
{"title": "Support for Metadata-driven Selection of Run-time Services in .NET is Promising but Immature\n", "abstract": " The .NET Framework allows developers to add run-time services to their classes by specifying them in metadata. This metadata-driven service selection is a very powerful and promising mechanism, closely related to ideas developed in the Aspect-Oriented Programming community. Interestingly, the .NET framework supports both services implemented by weaving and services implemented by interception. However, the weaving-based and the interception-based mechanisms seem to have been introduced in the framework independently, and show some unnecessary differences in flexibility, extensibility and configurability. Also both mechanisms still contain some anomalies in their design. In this paper, we describe the mechanisms, and discuss these shortcomings.", "num_citations": "9\n", "authors": ["328"]}
{"title": "Denial-of-service attacks against the 4-way wi-fi handshake\n", "abstract": " Having a secure implementation of the 4-way Wi-Fi handshake is necessary to guarantee that all subsequent Wi-Fi traffic is properly protected. After all, the 4-way handshake negotiates a fresh pairwise key, authenticates both the client and Access Point (AP), and is used by practically all protected Wi-Fi networks. As a result, it has been widely studied, and even formally proven secure. Yet we found that, in practice, many implementations are vulnerable to denial-of-service attacks.Our first two attacks highlight synchronization issues between when the client and AP install the pairwise key. More concretely, in the first attack the adversary blocks the initial message 4 of the 4-way handshake. This causes the client, but not yet the AP, to install the pairwise key. Therefore the handshake will fail, since the client now expects and sends encrypted handshake messages, while the AP only uses plaintext ones. Our second attack makes the client install the pairwise key before it transmits message 4. Hence, the client will again install the pairwise key, while the AP will not. In the third attack, an adversary waits until the victim completes the 4-way handshake. Then, she initiates a rekey by injecting a malformed message 1 to the client. This causes certain clients to disconnect from the network. Finally, we propose countermeasures against our new attacks.", "num_citations": "8\n", "authors": ["328"]}
{"title": "Towards safe enclaves\n", "abstract": " Protected module architectures, like the recently launched Intel Software Guard Extensions (Intel SGX), make it possible to protect individual software modules of an application against attacks from other modules of the application, or from the operating system. But if the code of the protected module (the enclave in Intel SGX terminology) has vulnerabilities itself, that module can still be exploitable. Programming enclaves in a safe programming language can prevent a wide range of vulnerabilities within the enclave.However, the simple approach of programming enclaves in a safe programming languages gives less security guarantees than one might expect. A safe language only provides safety guarantees for whole programs, not for individual modules that are part of a bigger program. If the context of the module is malicious, additional defensive measures are required to guarantee the safety of the enclave. This paper illustrates this problem, and reports on work-in-progress towards a solution.", "num_citations": "8\n", "authors": ["328"]}
{"title": "Towards preserving correctness in self-managed software systems\n", "abstract": " Currently, paradigms such as component-based software development and service-oriented software architectures promote modularization of software systems into highly decoupled and reusable software components and services. In addition, to improve manageability and evolveability, software systems are extended with management capabilities and self-managed behavior. Because of their very nature, these self-managed software systems often are mission critical and highly available. In this paper, we focus on the complexity of preserving correctness in modularized self-managed systems. We discuss the importance of consistent software compositions in the context of self-managed systems, and the need for a correctness-preserving adaptation process. We also give a flavor of possible approaches for preserving correctness, and conclude with some remarks and open questions.", "num_citations": "8\n", "authors": ["328"]}
{"title": "AOSD as an enabler for good enough security\n", "abstract": " The idea of business driven, good enough security for distributed software applications is promising, but many challenges remain. In this paper, we discuss some of the essential requirements, and focus in detail on one of the key technological challenges: how to engineer secure applications so that they support easy evolution of the security measures. Traditional (object-oriented) software engineering techniques cannot provide adequate support for the highly evolutionary character of good enough security because of the crosscutting nature of security. The technique of aspectoriented software development is developed to support the modularisation of such crosscutting concerns and, hence, it is a prime candidate to address this matter. In this paper, we evaluate the benefits of aspect-oriented software development for engineering evolvable secure applications based on some case studies we have done in the past. We also discuss the potential business impact of these benefits.", "num_citations": "8\n", "authors": ["328"]}
{"title": "Semi-trusted hosts and mobile agents: enabling secure distributed computations\n", "abstract": " Secure distributed computing addresses the problem of per- forming a computation with a number of mutually distrustful participants, in such a way that each of the participants has only limited access to the information needed for doing the computation. In the presence of a third party, completely trusted by all participants the problem is trivially solvable. However, this assumption is in many applications non-realistic. Over the past two decades, a number of solutions requiring no trusted third party have been developed using cryptographic techniques. The disadvantage of these cryptographic solutions is the excessive communication overhead they incur.               In this paper, we will show how to overcome these disadvantages and thus enable secure distributed computations in practice. Our approach uses mobile agents employing these cryptographic techniques to provide for a trade-off between\u00a0\u2026", "num_citations": "8\n", "authors": ["328"]}
{"title": "Formalizing correlate-from practice to pi\n", "abstract": " Correlate is a concurrent object-oriented language that has been used in real-world applications in areas of High- Performance Computing, network applications and multi-agent systems. The practical goal of the language is to offer a powerful programming environment in which both application and system software can be described using the paradigm of concurrent objects. In this paper, the formal description of Correlate in the pi-calculus is discussed. In our experience, such a formalization process is a crucial step in the design process of a practical language, even though not every detail need to be modelled. Several examples illustrate the benefits of our specification especially from the viewpoint of the language designer. Finally it is shown that an operational prototype can be easily constructed by translation from the pi-calculus to Pict.", "num_citations": "8\n", "authors": ["328"]}
{"title": "Gavial: Programming the web with multi-tier FRP\n", "abstract": " Developing web applications requires dealing with their distributed nature and the natural asynchronicity of user input and network communication. For facilitating this, different researchers have explored the combination of a multi-tier programming language and functional reactive programming. However, existing proposals take this approach only part of the way (some parts of the application remain imperative) or remain naive, with no regard for avoiding glitches across network communication, network traffic overhead, compatibility with common APIs like XMLHttpRequest etc. In this paper, we present Gavial: the first mature design and implementation of multi-tier FRP that allows constructing an entire web application as a functionally reactive program. By applying a number of new ideas, we demonstrate that multi-tier FRP can in fact deal realistically with important practical aspects of building web applications. At the same time, we retain the declarative nature of FRP, where behaviors and events have an intuitive, compositional semantics and a clear dependency structure.", "num_citations": "7\n", "authors": ["328"]}
{"title": "Experience Report: Functional Reactive Programming and the DOM\n", "abstract": " Web applications are inherently event-driven and traditionally implemented using imperative callbacks in Javascript. An alternative approach for such programs is functional reactive programming (FRP). FRP offers abstractions to make event-driven programming convenient, safe and composable, but like pure functions it is isolated from the'outside'world. In this paper we describe our experience in developing a library that binds FRP to the document object model (DOM). We describe that in its current state there are fundamental issues that do not yet have a perfect solution. We expand upon the functionality of existing FRP DOM libraries with an FRP model for DOM properties. We show that despite of some design problems a pragmatic library can be created that can be used to create web applications.", "num_citations": "7\n", "authors": ["328"]}
{"title": "Ensuring endpoint authenticity in WebRTC peer-to-peer communication\n", "abstract": " WebRTC is one of the latest additions to the ever growing repository of Web browser technologies, which push the envelope of native Web application capabilities. WebRTC allows real-time peer-to-peer audio and video chat, that runs purely in the browser. Unlike existing video chat solutions, such as Skype, that operate in a closed identity ecosystem, WebRTC was designed to be highly flexible, especially in the domains of signaling and identity federation. This flexibility, however, opens avenues for identity fraud. In this paper, we explore the technical underpinnings of WebRTC's identity management architecture. Based on this analysis, we identify three novel attacks against endpoint authenticity. To answer the identified threats, we propose and discuss defensive strategies, including security improvements for the WebRTC specifications and mitigation techniques for the identity and service providers.", "num_citations": "7\n", "authors": ["328"]}
{"title": "Shared boxes: rely-guarantee reasoning in VeriFast\n", "abstract": " VeriFast is a verifier for single-threaded and multithreaded C and Java programs. It takes a C or Java program annotated with preconditions and postconditions in a separation logic notation, and verifies statically that these preconditions and postconditions hold, using symbolic execution. In plain separation logic, a thread either has full ownership of a memory location and knows the value at the location, or it has no ownership and no knowledge of the value of the location. Existing work proposes a marriage of rely-guarantee reasoning and separation logic to address this. In this document, we describe the shared boxes mechanism, which marries separation logic and rely-guarantee reasoning in VeriFast. We introduce and motivate the shared boxes mechanism using a minimalistic example and a realistic example. The minimalistic example is a counter program where one thread continuously increments a counter and other threads check that the counter does not decrease. For the realistic example, we verify functional correctness of the Michael-Scott queue, a lock-free concurrent data structure. We define the syntax and semantics of a simple C-like programming language, and we define a separation logic with shared boxes and prove its soundness. We discuss the implementation in VeriFast and the examples we verified using our VeriFast implementation.", "num_citations": "7\n", "authors": ["328"]}
{"title": "Overlapping and order-independent patterns\n", "abstract": " Dependent pattern matching is a safe and efficient way to write programs and proofs in dependently typed languages. Current languages with dependent pattern matching treat overlapping patterns on a first-match basis, hence the order of the patterns can matter. Perhaps surprisingly, this order-dependence can even occur when the patterns do not overlap. To fix this confusing behavior, we developed a new semantics of pattern matching which treats all clauses as definitional equalities, even when the patterns overlap. A confluence check guarantees correctness in the presence of overlapping patterns. Our new semantics has two advantages. Firstly, it removes the order-dependence and thus makes the meaning of definitions clearer. Secondly, it allows the extension of existing definitions with new (consistent) evaluation rules. Unfortunately it also makes pattern matching harder to understand theoretically\u00a0\u2026", "num_citations": "7\n", "authors": ["328"]}
{"title": "ProtoLeaks: A reliable and protocol-independent network covert channel\n", "abstract": " We propose a theoretical framework for a network covert channel based on enumerative combinatorics. It offers protocol independence and avoids detection by using a mimicry defense. Using a network monitoring phase, traffic is analyzed to detect which application-layer protocols are allowed through the firewalls. Using these results, a covert channel is built based on permutations of benign network objects, such as FTP commands and HTTP requests to different web servers. Any protocol that offers reliability guarantees can be plugged into the framework. This includes any protocol that is built on top of the TCP protocol. The framework closely mimics the behavioral statistics of the legitimate traffic, making the covert channel very hard to detect.", "num_citations": "7\n", "authors": ["328"]}
{"title": "Exploring the ecosystem of referrer-anonymizing services\n", "abstract": " The constant expansion of the World Wide Web allows users to enjoy a wide range of products and services delivered directly to their browsers. At the same time however, this expansion of functionality is usually coupled with more ways of attacking a user\u2019s security and privacy. In this arms race, certain web-services present themselves as privacy-preserving or privacy-enhancing. One type of such services is a Referrer-Anonymizing Service (RAS), a service which relays users from a source site to a destination site while scrubbing the contents of the referrer header from user requests.               In this paper, we investigate the ecosystem of RASs and how they interact with web-site administrators and visiting users. We discuss their workings, what happens behind the scenes and how top Internet sites react to traffic relayed through such services. In addition, we present user statistics from our own Referrer\u00a0\u2026", "num_citations": "7\n", "authors": ["328"]}
{"title": "VC generation for functional behavior and non-interference of iterators\n", "abstract": " We propose a formalism for the full functional specification of enumerator methods, which are C# methods that return objects of type IEnumerable< T> or IEnumerator< T>. We further propose a sound modular automatic verification approach for enumerator methods implemented using C# 2.0's iterator blocks (ie, using yield return and yield break statements), and for client code that uses for-each loops. We require for-each loops to be annotated with special for-each loop invariants. The approach prevents interference between iterator implementations and client code. Specifically, an enumerator method may read a field o. f only if o is reflexively-transitively owned by an object listed in the enumerator method's reads clause, and the body of a for-each loop may not modify these objects. For example, we verify that a for-each loop iterating over an ArrayList does not modify the ArrayList. Note that one may break out of a\u00a0\u2026", "num_citations": "7\n", "authors": ["328"]}
{"title": "A \u03c0-Calculus Semantics of Java: The Full Definition\n", "abstract": " We present a formal semantics of the concurrent objectoriented programming language Java, as a mapping of Java programs to \u03c0-calculus processes. Our semantics shows how Java features such as polymorphism, typecasts, exceptions, per-thread memory caching, and native method invocations can together be modelled in the \u03c0-calculus.", "num_citations": "7\n", "authors": ["328"]}
{"title": "Plundervolt: How a little bit of undervolting can create a lot of trouble\n", "abstract": " Historically, fault injection was the realm of adversaries with physical access. This changed when research revealed that remote attackers could use software to inject faults. Plundervolt is a new software-based attack on Intel's trusted execution technology (SGX). Plundervolt can break cryptography and inject memory-safety bugs into secure code.", "num_citations": "6\n", "authors": ["328"]}
{"title": "Impossibility of precise and sound termination-sensitive security enforcements\n", "abstract": " An information flow policy is termination-sensitive if it imposes that the termination behavior of programs is not influenced by confidential input. Termination-sensitivity can be statically or dynamically enforced. On one hand, existing static enforcement mechanisms for termination-sensitive policies are typically quite conservative and impose strong constraints on programs like absence of while loops whose guard depends on confidential information. On the other hand, dynamic mechanisms can enforce termination-sensitive policies in a less conservative way. Secure Multi-Execution (SME), one of such mechanisms, was even claimed to be sound and precise in the sense that the enforcement mechanism will not modify the observable behavior of programs that comply with the termination-sensitive policy. However, termination-sensitivity is a subtle policy, that has been formalized in different ways. A key aspect is\u00a0\u2026", "num_citations": "6\n", "authors": ["328"]}
{"title": "A security analysis of emerging web standards-html5 and friends, from specification to implementation\n", "abstract": " Over the past few years, a significant effort went into the development of a new generation of web standards, centered around the HTML5 specification. Given the importance of the web in our society, it is essential that these new standards are scrutinized for potential security problems. This paper reports on a systematic analysis of ten important, recent specifications with respect to two generic security goals:(1) new web mechanisms should not break the security of existing web applications, and (2) different newly proposed mechanisms should interact with each other gracefully. In total, we found 45 issues, of which 12 are violations of the security goals and 31 issues concern under-specified features. Additionally, we found that 6 out of 11 explicit security considerations have been overlooked/overruled in major browsers, leaving secure specifications vulnerable in the end. All details can be found in an extended version of this paper (De Ryck et al., 2012).", "num_citations": "6\n", "authors": ["328"]}
{"title": "Better security and privacy for web browsers: A survey of techniques, and a new implementation\n", "abstract": " The web browser is one of the most security critical software components today. It is used to interact with a variety of important applications and services, including social networking services, e-mail services, and e-commerce and e-health applications. But the same browser is also used to visit less trustworthy sites, and it is unreasonable to make it the end-user\u2019s responsibility to \u201cbrowse safely\u201d. So it is an important design goal for a browser to provide adequate privacy and security guarantees, and to make sure that potentially malicious content from one web site can not compromise the browser, violate the user\u2019s privacy, or interfere with other web sites that the user interacts with.             Hence, browser security has been a very active topic of research over the past decade, and many proposals have been made for new browser security techniques or architectures. In the first part of this paper, we provide a\u00a0\u2026", "num_citations": "6\n", "authors": ["328"]}
{"title": "Efficient and effective buffer overflow protection on ARM processors\n", "abstract": " Although many countermeasures have been developed for desktop and server environments, buffer overflows still pose a big threat. The same approach can be used to target mobile devices. Unfortunately, they place more severe limitations on countermeasures. Not only are the performance requirements at least as important, memory and power consumption need to be considered as well. Moreover, processors used in mobile devices generally are equipped with a different instruction set. Therefore countermeasures may not be ported easily.               Multistack is an effective countermeasure against stack-based buffer overflows. It protects applications by using multiple stacks to separate possible attack targets from possible sources. However, its performance overhead will no longer be negligible on the ARMv7 platform (widely used on mobile devices) and it wastes too much memory, making it too costly\u00a0\u2026", "num_citations": "6\n", "authors": ["328"]}
{"title": "Towards building secure web mashups\n", "abstract": " Web mashups combine components from multiple sources into a single, interactive application. This kind of setup typically requires both in-teraction between the components to achieve the necessary functionality, as well as component separation to achieve a secure execution. Unfortunately, the traditional web is not designed to easily fulfill both requirements, which can be seen in the restrictions imposed by traditional development techniques. This paper gives an overview of these traditional techniques and investigates new developments, specifically aimed at combining components in a secure manner. In addition, topics for further improvement are identified to ensure a wide adaptation of secure mashups.", "num_citations": "6\n", "authors": ["328"]}
{"title": "Security Middleware for Mobile Applications\n", "abstract": " Over the last decade the popularity of mobile devices has increased enormously. Initially, personal managers and mobile phones were designed as closed, dedicated devices. More and more, these devices have evolved into general purpose instruments that can be extended at user\u2019s will (a.o. via proper software development kits). This has lead to the current generation of smartphones and full-blown personal information management systems. At the same time, the information managed by the devices has evolved from limited and personal to general purpose and business-centric and, consequently, they constitute a core component of daily life.", "num_citations": "6\n", "authors": ["328"]}
{"title": "Protecting global and static variables from buffer overflow attacks without overhead\n", "abstract": " Many countermeasures exist to protect the stack and heap from code injection attacks, however very few countermeasures exist that will specifically protect global and static variables from attack. In this paper we suggest a way of protecting global and static variables from these type of attacks, with negligible performance and memory overheads. Our approach is based on the idea of separating data in de data segment based on its type. These separated areas are then protected from each other by a guard page. This prevents a buffer overflow from overwriting data or code pointers, in turn preventing attackers from being able to perform a code injection attack. 1", "num_citations": "6\n", "authors": ["328"]}
{"title": "Advances in Network and Distributed Systems Security: IFIP TC11 WG11. 4 First Annual Working Conference on Network Security November 26\u201327, 2001, Leuven, Belgium\n", "abstract": " The more our society relies on electronic forms of communication, the more the security of these communication networks is essential for its well-functioning. As a consequence, research on methods and techniques to improve network security is extremely important. Topics in this volume include the developments in: security protocols; secure software engineering; mobile agent security; e-commerce security; and security for distributed computing.; This title contains the proceedings of the First International Working Conference on Network Security (I-NetSec 01), which was sponsored by the International Federation for Information Processing (IFIP), and held in Leuven, Belgium in November 2001.", "num_citations": "6\n", "authors": ["328"]}
{"title": "Safe concurrency for aggregate objects with invariants: Soundness proof\n", "abstract": " Developing safe multithreaded software systems is difficult due to the potential unwanted interference among concurrent threads. This paper presents a flexible methodology for object-oriented programs that protects object structures against inconsistency due to race conditions. It is based on a recent methodology for single-threaded programs where developers define aggregate object structures using an ownership system and declare invariants over them. The methodology is supported by a set of language elements and by both a sound modular static verification method and run-time checking support. The paper reports on preliminary experience with a prototype implementation.", "num_citations": "6\n", "authors": ["328"]}
{"title": "Software security: experiments on the. NET common language run-time and the shared source common language infrastructure\n", "abstract": " As more and more software applications are directly or indirectly accessible from the Internet, the importance of the security of these applications grows steadily. Hence, it is important that university curricula for computer scientists and software engineers include courses on secure software development. Such courses should make students familiar with the programming language technology, run-time support and available API for security, and they should also teach them how to use these technological means appropriately. The .NET framework is a good example of the current state-of-the-art support for secure development. The Shared Source Common Language Infrastructure (SSCLI) provides a source for some of the security related aspects of the framework. The paper describes how the secure software development course at the Katholieke Universiteit Leuven uses the .NET framework and the SSCLI. An\u00a0\u2026", "num_citations": "6\n", "authors": ["328"]}
{"title": "Adaptable access control policies for medical information systems: requirements analysis and case studies\n", "abstract": " IT enforced access control policies in medical information systems have to be fine-grained and dynamic. We justify this observation on the basis of legislation and on the basis of the evolution within the healthcare domain. Consequently, a reconfigurable or at least adaptable implementation of access control facilities has become extremely important. For this purpose, current technology provides insufficient support. We highlight a basic solution to address shortcomings by using interception techniques. In addition, we identify further research that is required to address the challenges of dynamic and fine-grained access control in the long run.", "num_citations": "6\n", "authors": ["328"]}
{"title": "Cryptolog: a theorem prover for cryptographic protocols\n", "abstract": " Logics for cryptographic protocols have proved very useful in validating the correctness of these protocols. However, neither the speci cation, nor the logic proof help the implementor of the protocol. Although the proof states the assumptions explicitly, it does not| in general| contain guidelines for the implementation. In this paper, we present a theorem prover whose input is very close to a program written in a procedural language. Moreover, explicit guidelines for implementors may be given.", "num_citations": "6\n", "authors": ["328"]}
{"title": "CapablePtrs: securely compiling partial programs using the pointers-as-capabilities principle\n", "abstract": " Capability machines such as CHERI provide memory capabilities that can be used by compilers to provide security benefits for compiled code (e.g., memory safety). The existing C to CHERI compiler, for example, achieves memory safety by following a principle called \u201cpointers as capabilities\u201d (PAC). Informally, PAC says that a compiler should represent a source language pointer as a machine code capability. But the security properties of PAC compilers are not yet well understood. We show that memory safety is only one aspect, and that PAC compilers can provide significant additional security guarantees for partial programs: the compiler can provide security guarantees for a compilation unit, even if that compilation unit is later linked to attacker-provided machine code.As such, this paper is the first to study the security of PAC compilers for partial programs formally. We prove for a model of such a compiler that it is\u00a0\u2026", "num_citations": "5\n", "authors": ["328"]}
{"title": "Scalagna 0.1: towards multi-tier programming with Scala and Scala. js\n", "abstract": " In the state-of-practice, developing web applications requires dealing with multiple programming languages or codebases. To address this issue, researchers have proposed multi-tier languages such as Hop or Links that support client and server development in a single language and in one codebase. Even if such multi-tier languages are often strongly based on an existing language-for instance Hop is based on Scheme-they are new languages, and require a new compiler.", "num_citations": "5\n", "authors": ["328"]}
{"title": "Security guarantees for the execution infrastructure of software applications\n", "abstract": " Software applications run on top of infrastructure consisting of hardware (processors, devices, communication networks, ...) and software (operating systems, compilers, virtual machines, language runtimes, databases, ...). In many cases, attacks against application software rely at least to some extent on aspects of that infrastructure, and in some cases vulnerabilities can be fixed by strengthening the infrastructure, as well as by patching the application code. This paper argues that it is beneficial for secure software development if the security guarantees offered by the execution infrastructure are explicit and precisely defined. More specifically, a developer writing source code that will be executed on the infrastructure should know what guarantees the infrastructure offers against what class of attackers. We survey existing proposals for precise statements of such security guarantees, and argue that the notion of full\u00a0\u2026", "num_citations": "5\n", "authors": ["328"]}
{"title": "Secure compilation by approximate back-translation\n", "abstract": " Secure Compilation by Approximate Back-Translation Page 1 Secure Compilation by Approximate Back-Translation Dominique Devriese1 Marco Patrignani2 Frank Piessens1 1iMinds-DistriNet, Dept. Computer Science, KU Leuven, Belgium first.last@cs.kuleuven.be 2MPI-SWS Saarbr\u00fccken, Germany first.last@mpi-sws.org Dominique Devriese, Marco Patrignani, Frank Piessens Secure Compilation by Approximate Back-Translation 1/12 Page 2 t1 ? \u2243ctx t2 C[t1 ] \u21d3 ? \u21d2 C[t2 ] \u21d3 (1) (2) (3) C \u2248 [C] t2 \u2248 [t2] C \u2248 [C] t1 \u2248 [t1] [C] [ [t1] ] \u21d3 \u21d2 [C] [ [t2] ] \u21d3 [t1] \u2243ctx [t2] compiler correctness direction Dominique Devriese, Marco Patrignani, Frank Piessens Secure Compilation by Approximate Back-Translation 2/12 Page 3 t1 \u2243ctx t2 \u2329\u2329C\u232a\u232a[t1 ] \u21d3 \u21d2 \u2329\u2329C\u232a\u232a[t2 ] \u21d3 (1) (2) (3) \u2329\u2329C\u232a\u232a \u2248 C t2 \u2248 [t2] \u2329\u2329C\u232a\u232a \u2248 C t1 \u2248 [t1] C [ [t1] ] \u21d3 ? \u21d2 C [ [t2] ] \u21d3 [t1] ? \u2243ctx [t2] compiler security direction Dominique Devriese, Marco Patrignani, Frank \u2026", "num_citations": "5\n", "authors": ["328"]}
{"title": "Fully abstract compilation by approximate back-translation: Technical appendix\n", "abstract": " A compiler is fully-abstract if the compilation from source language programs to target language programs reflects and preserves behavioural equivalence. Such compilers have important security benefits, as they limit the power of an attacker interacting with the program in the target language to that of an attacker interacting with the program in the source language. Proving compiler full-abstraction is, however, rather complicated. A common proof technique is based on the back-translation of target-level program contexts to behaviourallyequivalent source-level contexts. However, constructing such a back-translation is problematic when the source language is not strong enough to embed an encoding of the target language. For instance, when compiling from the simplytyped \u03bb-calculus (\u03bb\u03c4) to the untyped \u03bb-calculus (\u03bbu), the lack of recursive types in \u03bb\u03c4 prevents such a back-translation.We propose a general and elegant solution for this problem. The key insight is that it suffices to construct an approximate back-translation. The approximation is only accurate up to a certain number of steps and conservative beyond that, in the sense that the context generated by the back-translation may diverge when the original would not, but not vice versa. Based on this insight, we describe a general technique for proving compiler full-abstraction and demonstrate it on a compiler from \u03bb\u03c4 to \u03bbu. The proof uses asymmetric cross-language logical relations and makes innovative use of step-indexing to express the relation between a context and its approximate back-translation. We believe this proof technique can scale to challenging settings and enable simpler, more\u00a0\u2026", "num_citations": "5\n", "authors": ["328"]}
{"title": "Multi-module fully abstract compilation\n", "abstract": " High-level languages like Java or ML support abstraction and data encapsulation through language features such as modules, objects, classes, and/or abstract data types. But traditional compilation does not preserve such abstraction boundaries. At machine code level, there is just a single address-space where all code is readable and all data is read/writable. In other words, the entire high-level program is compiled down into one single protection domain. To a large extent, this is the case because the protection domain granularity of modern execution platforms is very coarse grained: the smallest unit of protection is an operating system process, and most programs are compiled to a single process.For fully safe languages, and if attackers can only provide input to and read output from programs, there is no need to preserve abstraction or protection boundaries after compilation: for such attackers, language safety is sufficient to guarantee that program abstractions are maintained. However, most compiled languages (including for instance C#, Java, Go, and Rust) are not fully safe: programs can contain unsafe blocks that might be subject to memory safety errors [1], or programs can interface with code written in unsafe languages through a native interface. In addition, attackers may have more powers than just the abilities to provide input and read output: for instance, programs might support binary plugins making it possible for attackers to load arbitrary machine code into a process, or kernel-level malware can inspect any user process at the machine code abstraction level. In these circumstances, mechanisms for protecting source code data\u00a0\u2026", "num_citations": "5\n", "authors": ["328"]}
{"title": "On the effectiveness of virtualization-based security\n", "abstract": " Protecting commodity operating systems and applications against malware and targeted attacks has proven to be difficult. In recent years, virtualization has received attention from security researchers who utilize it to harden existing systems and provide strong security guarantees. This has lead to interesting use cases such as cloud computing where possibly sensitive data is processed on remote, third party systems. The migration and processing of data in remote servers, poses new technical and legal questions, such as which security measures should be taken to protect this data or how can it be proven that execution of code wasn't tampered with. In this paper we focus on technological aspects. We discuss the various possibilities of security within the virtualization layer and we use as a case study \\HelloRootkitty{}, a lightweight invariance-enforcing framework which allows an operating system to recover from kernel-level attacks. In addition to \\HelloRootkitty{}, we also explore the use of special hardware chips as a way of further protecting and guaranteeing the integrity of a virtualized system.", "num_citations": "5\n", "authors": ["328"]}
{"title": "Eradicating bearer tokens for session management\n", "abstract": " Session management is a crucial component in every modern web application. It links multiple requests and temporary stateful information together, enabling a rich and interactive user experience. The de facto cookie-based session management mechanism is however flawed by design, enabling the theft of the session cookie through simple eavesdropping or script injection attacks. Possession of the session cookie gives an adversary full control over the user\u2019s session, allowing him to impersonate the user to the target application and perform transactions in the user\u2019s name. While several alternatives for secure session management exist, they fail to be adopted due to the introduction of additional roundtrips and overhead, as well as incompatibility with current Web technologies, such as thirdparty authentication providers, or widely deployed middleboxes, such as web caches.We identify four key objectives for a secure session management mechanism, aiming to be compatible with the current and future Web. We propose SecSess, a lightweight session management mechanism based on a shared secret between client and server, used to authenticate each request. SecSess ensures that a session remains under control of the parties that established it, and only introduces limited overhead. During session establishment, SecSess introduces no additional roundtrips and only adds 4.3 milliseconds to client-side and server-side processing. Once a session is established, the overhead becomes negligible (< 0.1 ms), and the average size of the request headers is even smaller than with common session cookies. Additionally, SecSess works well\u00a0\u2026", "num_citations": "5\n", "authors": ["328"]}
{"title": "Authentication and Access control: Part I\n", "abstract": " \u2022 Objective= strict control of information flow\u2022 Concrete example MAC model: Lattice Based Access Control (LBAC)\u2022 Objective=", "num_citations": "5\n", "authors": ["328"]}
{"title": "Verifying java programs with VeriFast\n", "abstract": " VeriFast is a modular, sound program verifier for concurrent Java programs. The verifier takes as input a number of Java source files annotated with method contracts written in a form of separation logic, inductive data type and fixpoint definitions, lemma functions and proof steps. If VeriFast reports that a program is correct, then (1) that program does not raise NullPointer-or ArrayIndexOutOfBoundsExceptions,(2) contains no data races,(3) never violates assertions, and (4) the assumptions described in the method contracts are guaranteed to hold in each execution.", "num_citations": "5\n", "authors": ["328"]}
{"title": "Symbolic execution for implicit dynamic frames\n", "abstract": " The combination of verification condition generation and automated theorem proving is a well-known and widely used technique for checking whether a program satisfies its specification. However, for Java-like languages with shared mutable state and support for data abstraction, experience has shown that this technique has 3 important disadvantages:(1) it is slow,(2) it is unpredictable-small changes to the specification can have significant impact on verification time, and (3) it can be hard to determine why a verification condition fails.In this paper, we propose an approach for automatically verifying whether a Java program satisfies its specification based on symbolic execution instead of verification condition generation. The specification language used is a JML-like language supporting the technique of implicit dynamic frames for dealing with data abstraction and framing. We implemented our approach in a\u00a0\u2026", "num_citations": "5\n", "authors": ["328"]}
{"title": "Developing Secure Software Applications DRAFT\n", "abstract": " Software is often an enabler of new possibilities. Software running on an ecommerce site enables customers from all over the world to purchase goods. Software running on a company web server enables people to look up information about the company or its products. Software on your PC enables you to manage and efficiently use your documents, images, digital audio files and so on. The main driving factor for developing or installing software is typically that the software will be an enabler for some useful functionality. On the other hand, by making information, resources, procedures or other assets more easily available, you also increase the risk of abuse or damage. An e-commerce server could potentially be abused to buy goods for an incorrect price, or to buy goods on some other customers account. Through the web server software, a hacker could modify company information, making the company look ridiculous on the Internet. Your privacy could be seriously compromised if a hacker can work his way into the software on your PC and browse through your personal files.So while we use software for its useful functionalities, we also often rely on the software to enforce certain rules. The e-commerce server should make sure that any purchase is always correctly paid for by the purchasing party. The web server should make sure that it only gives read-access to the information it serves to the web. And the software on your PC should only give you access to your personal files.", "num_citations": "5\n", "authors": ["328"]}
{"title": "Dependency analysis of the Gatormail webmail application\n", "abstract": " Nowadays, software systems are evolving towards modular composed applications, in which existing, loosely-coupled software components are reused in new compositions. In practice, these looselycoupled software components tend to have quite often a set of hidden dependencies on other components in software systems. In this report, we illustrate the complexity of inter-component dependencies in loosely-coupled software systems by exploring the dependencies in an existing component-based webmail application, GatorMail. We identify four types of dependencies in the GatorMail webmail application, resulting in more that 2000 dependencies. By creating a better understanding of dependencies in software compositions, we hope to come to a better management of dependencies and to achieve more reliable software compositions. Two versions of this report are available: a technical report and a shrinked version without the appendices.", "num_citations": "5\n", "authors": ["328"]}
{"title": "Towards a unifying view on security contracts\n", "abstract": " A key property of software component technology is predictability, which means that the properties of an overall system can be deduced from the properties of the individual components. One of the crucial building blocks in component technology is the notion of component contract. In order to leverage predictability for the construction of secure systems, security requirements and properties must be adequately supported by component contracts, which is currently a challenging and open problem. This paper provides an overview of the problem domain by presenting an initial taxonomy of security contracts and their representative security properties.", "num_citations": "5\n", "authors": ["328"]}
{"title": "View connectors for the integration of domain specific access control\n", "abstract": " Engineering access control in distributed applications is a challenging problem for many application domains. It should be possible to set and manage one organization-wide access control policy that must then be enforced reliably in a multitude of applications running within the organization. This is severely complicated by the fact that an access control policy can be fine-grained and dependent on application state, and hence its enforcement can crosscut an application in an intricate way. Based on the observation that the access control enforcement points in an application are essentially pointcuts, this paper proposes a new approach for engineering access control into applications. Experience with the access control concern also clearly shows the need for full life-cycle support for aspects.", "num_citations": "5\n", "authors": ["328"]}
{"title": "What vs. how of visual modeling: The arrow logic of graphic notations\n", "abstract": " The goal of the paper is to explicate some universal logic underlying various notational systems used in visual modeling. The idea is to treat the notational diversity as the diversity of visualizations of the same basic specificational format. It is argued that the task can be well approached in the arrow-diagram logic framework where specifications are directed graphs carrying a structure of diagram predicates and operations.", "num_citations": "5\n", "authors": ["328"]}
{"title": "Categorical Semantics for Object-Oriented Data-Specifications\n", "abstract": " Semantic data-specifications have been used for many years in the early stages of database design. The most influential example is undoubtedly the Entity Relationship specification method ([Chen, 1976]), in which aspects of a certain reality are expressed in terms of entities, relations and attributes. The paradigm of object-oriented software development stimulated new research in the area of data-specifications. Indeed, the major goal of object-oriented analysis ([Coad and Yourdon, 1990, Van Baelen et al., 1991]), is to develop a specification of the external world. Since then, many extensions to ER-like data-specifications have been suggested, either to enhance the expressiveness, or to suit them more to the needs of software engineering. However, most of the data-specification mechanisms used in practice are of an informal nature.", "num_citations": "5\n", "authors": ["328"]}
{"title": "Interconnecting domains with heterogeneous key distribution and authentication protocols\n", "abstract": " A number of mechanisms are described that can be used in the design of a protocol converter for authentication and key distribution protocols. First, the scope of the mechanisms is defined. The authors outline the class of authentication systems that were considered during the design of the mechanisms. A first mechanism, based on proxies and a synchronization protocol, allows for a transparent protocol conversion. It is generic, and can be tailored to different specific situations. The second mechanism addresses the problem of the state of the protocol converter. Both mechanisms can be used separately or in combination. When properly combined, they provide for a robust, transparent, and safe protocol converter for authentication and key distribution protocols. Example applications are described in some detail.< >", "num_citations": "5\n", "authors": ["328"]}
{"title": "Secure End-to-End Sensing in Supply Chains\n", "abstract": " Trust along digitalized supply chains is challenged by the aspect that monitoring equipment may not be trustworthy or unreliable as respective measurements originate from potentially untrusted parties. To allow for dynamic relationships along supply chains, we propose a blockchain-backed supply chain monitoring architecture relying on trusted hardware. Our design provides a notion of secure end-to-end sensing of interactions even when originating from untrusted surroundings. Due to attested checkpointing, we can identify misinformation early on and reliably pinpoint the origin. A blockchain enables long-term verifiability for all (now trustworthy) IoT data within our system even if issues are detected only after the fact. Our feasibility study and cost analysis further show that our design is indeed deployable in and applicable to today\u2019s supply chain settings.", "num_citations": "4\n", "authors": ["328"]}
{"title": "Solving the VerifyThis 2012 challenges with VeriFast\n", "abstract": " We describe our experience solving the VerifyThis 2012 challenges with our program verification tool VeriFast, including detailed explanations of our solutions. We also describe some alternative solutions that we developed after the competition. VeriFast is a modular verifier that takes Java or C source code annotated with function/method specifications written in a variant of separation logic, and verifies that the code complies with the annotations through symbolic execution.", "num_citations": "4\n", "authors": ["328"]}
{"title": "ICE: A passive, high-speed, state-continuity scheme (extended version)\n", "abstract": " The amount of trust that can be placed in commodity computing platforms is limited by the likelihood of vulnerabilities in their huge software stacks. Protected-module architectures, such as Intel SGX, provide an interesting alternative by isolating the execution of software modules. To minimize the amount of code that provides support for the protected-module architecture, persistent storage of (confidentiality and integrity protected) states of modules can be delegated to the untrusted operating system. But precautions should be taken to ensure state continuity: an attacker should not be able to cause a module to use stale states (a so-called rollback attack), and while the system is not under attack, a module should always be able to make progress, even when the system could crash or lose power at unexpected, random points in time (ie, the system should be crash resilient).Providing state-continuity support is non-trivial as many algorithms are vulnerable to attack, require on-chip non-volatile memory, wear-out existing offchip secure non-volatile memory and/or are too slow for many applications. We introduce ICE, a system and algorithm providing state-continuity guarantees to protected modules. ICE\u2019s novelty lies in the facts that (1) it does not rely on secure non-volatile storage for every state update (eg, the slow TPM chip).(2) ICE is a passive security measure. An attacker interrupting the main power supply or any other source of power, cannot break state-continuity.(3) Benchmarks show that ICE already enables state-continuous updates almost 5x faster than writing to TPM NVRAM. With dedicated hardware, performance can be increased 2\u00a0\u2026", "num_citations": "4\n", "authors": ["328"]}
{"title": "Web-platform security guide: Security assessment of the web ecosystem\n", "abstract": " In this document, we report on the Web-platform security guide, which has been developed within the EC-FP7 project STREWS. Based on their research, the STREWS consortium argues that in order to strengthening the Internet (eg against pervasive monitoring), it is crucial to also strengthen the web application ecosystem, the de-facto Internet application platform.The Web security guide is the result of a broad security assessment of the current situation on the Web1. It looks at the Web ecosystem and provides a timely and comprehensive web security overview. It was written by the STREWS Consortium, that brings together a unique set of expertise in Europe to grasp the complexity of the Web platform and its security characteristics. It is unique because it brings together strong peers in academic web security research in Europe, a large European software vendor, and principal actors in standardisation activities in W3C and IETF, the predominant specification developing organisations for the Web. The Web platform security guide consists of four parts, and looks as follows:", "num_citations": "4\n", "authors": ["328"]}
{"title": "Improving the security of session management in web applications\n", "abstract": " Session management is a critical component of modern web applications, allowing a server to keep track of user-specific state, such as an authentication status. Unfortunately, many applications deploy session management over an insecure HTTP channel, making them vulnerable to eavesdropping, session hijacking or session fixation attacks. On the contrary, state-of-practice guidelines advocate the deployment of session management on a secure HTTPS channel, using the HttpOnly and Secure cookie attributes, effectively eliminating these well-known session management attacks. The goal of this paper is to provide secure session management to web applications deployed over HTTP. We propose a secure and lightweight session management mechanism, effectively improving session management security with HTTP deployments. By establishing a safely contained, shared secret between browser and server, an attacker is prevented from taking over a user\u2019s session, since the secret is never transmitted, nor accessible. We demonstrate the applicability of our solution to a common scenario involving third-party authentication, clearly indicating the gained security properties. Our secure and lightweight session management mechanism raises the security bar for HTTP deployments, which will eventually lead to secure session management for all web applications.", "num_citations": "4\n", "authors": ["328"]}
{"title": "Secure compilation to modern processors: extended version\n", "abstract": " We present a secure (fully abstract) compilation scheme to compile an object-based high-level language to low-level machine code. Full abstraction is achieved by relying on a fine-grained program counter-based memory access protection scheme, which is part of our low-level target language. We discuss why standard compilers fail to provide full abstraction and introduce enhancements needed to achieve this goal. We prove that our enhanced compilation scheme provides full abstraction from our high-level source language to our low-level target language. Lastly, we show by means of a prototype implementation that our low-level language with fine-grained memory access control can be realized efficiently on modern commodity platforms.", "num_citations": "4\n", "authors": ["328"]}
{"title": "The VeriFast program verifier\u2013a tutorial for Java Card developers\n", "abstract": " VeriFast is a program verification tool for verifying certain correctness properties of single-threaded and multithreaded C, Java, and Java Card programs. In this tutorial, we introduce VeriFast\u2019s support for Java Card (Classic) programs.", "num_citations": "4\n", "authors": ["328"]}
{"title": "Verification of unloadable modules (Extended version)\n", "abstract": " Programs in unsafe languages, like C and C++, may dynamically load and unload modules. For example, some operating system kernels support dynamic loading and unloading of device drivers. This causes specific difficulties in the verification of such programs and modules; in particular, it must be verified that no functions or global variables from the module are used after the module is unloaded. We present the approach we used to add support for loading and unloading modules to our separation-logic-based program verifier VeriFast. Our approach to the specification and verification of function pointer calls, based on parameterizing function types by predicates, is sound in the presence of unloading, but at the same time does not complicate the verification of programs that perform no unloading, and does not require callers to distinguish between function pointers that point into unloadable modules and ones that do not.We offer a machine-checked formalization and soundness proof and we report on verifying a small kernel-like program using Veri-Fast. To the best of our knowledge, ours is the first approach for sound modular verification of C programs that load and unload modules.", "num_citations": "4\n", "authors": ["328"]}
{"title": "Verification of imperative programs: The Veri-Fast approach. a draft course text\n", "abstract": " This draft course text presents a formalization and soundness proof of a core subset of the VeriFast approach for verification of imperative programs.", "num_citations": "4\n", "authors": ["328"]}
{"title": "Second Price Auctions\n", "abstract": " Secure distributed computing addresses the problem of performing a computation with a number of mutually distrustful participants, in such a way that each of the participants has only limited access to the information needed for doing the computation. Over the past two decades, a number of solutions requiring no trusted third party have been developed using cryptographic techniques. The disadvantage of these cryptographic solutions is the excessive communication overhead they incur.               In this paper, we use one of the SDC protocols for one particular application: second price auctions, in which the highest bidder acquires the item for sale at the price of the second highest bidder. The protocol assures that only the name of the highest bidder and the amount of the second highest bid are revealed. All other information is kept secret (the amount of the highest bid, the name of the second highest\u00a0\u2026", "num_citations": "4\n", "authors": ["328"]}
{"title": "On the trade-off between communication and trust in secure computations\n", "abstract": " In this paper, we show that mobile code technology may prove to be a useful tool in advanced cryptographic protocols for secure distributed computing. Secure distributed computing addresses the problem of performing a computation with a number of mutually distrustful participants, in such a way that each of the participants has only limited access to the information needed for doing the computation. In the presence of a third party completely trusted by all participants, the problem is trivially solvable. However, this assumption is in many applications non-realistic. Over the past two decades, a number of solutions requiring no trusted third party have been developed using cryptographic techniques. The disadvantage of these cryptographic solutions is the excessive communication overhead they incur. We will show in this paper how the use of mobile agents employing these cryptographic techniques can provide for a trade-off between communication overhead and trust. The communication ov...", "num_citations": "4\n", "authors": ["328"]}
{"title": "Faulty Point Unit: ABI Poisoning Attacks on Intel SGX\n", "abstract": " This paper analyzes a previously overlooked attack surface that allows unprivileged adversaries to impact supposedly secure floating-point computations in Intel SGX enclaves through the Application Binary Interface (ABI). In a comprehensive study across 7 widely used industry-standard and research enclave shielding runtimes, we show that control and state registers of the x87 Floating-Point Unit (FPU) and Intel Streaming SIMD Extensions (SSE) are not always properly sanitized on enclave entry. First, we abuse the adversary\u2019s control over precision and rounding modes as a novel \u201cABI-level fault injection\u201d primitive to silently corrupt enclaved floating-point operations, enabling a new class of stealthy, integrity-only attacks that disturb the result of SGX enclave computations. Our analysis reveals that this threat is especially relevant for applications that use the older x87 FPU, which is still being used under certain\u00a0\u2026", "num_citations": "3\n", "authors": ["328"]}
{"title": "A categorical approach to secure compilation\n", "abstract": " We introduce a novel approach to secure compilation based on maps of distributive laws. We demonstrate through four examples that the coherence criterion for maps of distributive laws can potentially be a viable alternative for compiler security instead of full abstraction, which is the preservation and reflection of contextual equivalence. To that end, we also make use of the well-behavedness properties of distributive laws to construct a categorical argument for the contextual connotations of bisimilarity.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Elmsvuur: A multi-tier version of elm and its time-traveling debugger\n", "abstract": " Debugging dynamic web applications is challenging in many ways. Applications intrinsically consist of (at least) a server and a client program, each deployed on different nodes. Because of that, web applications behave like distributed systems and debugging them faces much of the same problems like managing state and heterogeneity of nodes. For web applications the latter problem also applies for the distinction between client and server code. These sections are typically written in different languages which further complicates the debugging of a web application.               The most common solution is dealing with each program layer individually using language-specific debugging tools, but this does not give an overview of the entire application flow.               Multi-tier languages allow programming a web application in a single language as a single application. They are primarily designed to offer\u00a0\u2026", "num_citations": "3\n", "authors": ["328"]}
{"title": "Modular fully abstract compilation by approximate back-translation: Technical appendix\n", "abstract": " A compiler is fully-abstract if the compilation from source language programs to target language programs reflects and preserves behavioural equivalence. Such compilers have important security benefits, as they limit the power of an attacker interacting with the program in the target language to that of an attacker interacting with the program in the source language. Proving compiler full-abstraction is, however, rather complicated. A common proof technique is based on the back-translation of target-level program contexts to behaviourallyequivalent source-level contexts. However, constructing such a back-translation is problematic when the source language is not strong enough to embed an encoding of the target language. For instance, when compiling from the simplytyped \u03bb-calculus (\u03bb\u03c4) to the untyped \u03bb-calculus (\u03bbu), the lack of recursive types in \u03bb\u03c4 prevents such a back-translation.We propose a general and elegant solution for this problem. The key insight is that it suffices to construct an approximate back-translation. The approximation is only accurate up to a certain number of steps and conservative beyond that, in the sense that the context generated by the back-translation may diverge when the original would not, but not vice versa. Based on this insight, we describe a general technique for proving compiler full-abstraction and demonstrate it on a compiler from \u03bb\u03c4 to \u03bbu. The proof uses asymmetric cross-language logical relations and makes innovative use of step-indexing to express the relation between a context and its approximate back-translation. The proof extends easily to common compiler patterns such as modular compilation and it\u00a0\u2026", "num_citations": "3\n", "authors": ["328"]}
{"title": "Sound modular verification of C code executing in an unverified context: extended version\n", "abstract": " Over the past decade, great progress has been made in the static modular verification of C code by means of separation logic-based program logics. However, the runtime guarantees offered by such verification are relatively limited when the verified modules are part of a whole program that also contains unverified modules. In particular, a memory safety error in an unverified module can corrupt the runtime state, leading to assertion failures or invalid memory accesses in the verified modules. This paper develops runtime checks to be inserted at the boundary between the verified and the unverified part of a program, to guarantee that no assertion failures or invalid memory accesses can occur at runtime in any verified module. One of the key challenges is enforcing the separation logic frame rule, which we achieve by checking the integrity of the footprint of the verified part of the program on each control flow transition from the unverified to the verified part. This in turn requires the presence of some support for module-private memory at runtime. We formalize our approach and prove soundness. We implement the necessary runtime checks by means of a program transformation that translates C code with separation logic annotations into plain C, and that relies on a protected module architecture for providing module-private memory and restricted module entry points. Benchmarks show the performance impact of this transformation depends on the choice of boundary between the verified and unverified parts of the program, but is below 4% for real-world applications.", "num_citations": "3\n", "authors": ["328"]}
{"title": "There is safety in numbers: Preventing control-flow hijacking by duplication\n", "abstract": " Despite the large number of proposed countermeasures against control-flow hijacking attacks, these attacks still pose a great threat for today\u2019s applications. The problem with existing solutions is that they either provide incomplete probabilistic protection (e.g., stack canaries) or impose a high runtime overhead (e.g., bounds checking).               In this paper, we show how the concept of program-part duplication can be used to protect against control-flow hijacking attacks and present two different instantiations of the duplication concept which protect against popular attack vectors. First, we use the duplication of functions to eliminate the need of return addresses and thus provide complete protection against attacks targeting a function\u2019s return address. Then we demonstrate how the integrity of function pointers can be protected through the use of data duplication. We test the combined effectiveness of our two\u00a0\u2026", "num_citations": "3\n", "authors": ["328"]}
{"title": "Recent developments in low-level software security\n", "abstract": " An important objective for low-level software security research is to develop techniques that make it harder to launch attacks that exploit implementation details of the system under attack. Baltopoulos and Gordon have summarized this as the principle of source-based reasoning for security: security properties of a software system should follow from review of the source code and its source-level semantics, and should not depend on details of the compiler or execution platform.               Whether the principle holds \u2013 or to what degree \u2013 for a particular system depends on the attacker model. If an attacker can only provide input to the program under attack, then the principle holds for any safe programming language. However, for more powerful attackers that can load new native machine code into the system, the principle of source-based reasoning typically breaks down completely.               In this paper we\u00a0\u2026", "num_citations": "3\n", "authors": ["328"]}
{"title": "A security analysis of emerging web standards-extended version\n", "abstract": " Over the past few years, a significant effort went into the development of a new generation of web standards, centered around the HTML5 specification. Given the importance of the web in our society, it is essential that these new standards are scrutinized for potential security problems. This paper reports on a systematic analysis of ten important, recent specifications with respect to two generic security goals:(1) new web mechanisms should not break the security of existing web applications, and (2) different newly proposed mechanisms should interact with each other gracefully. Our analysis reveals several violations of these security goals, which should be addressed by the specifications.In addition, we analyze the implementations of some of these standards in major browsers, and show that (1) even explicit security considerations in the standards are not consistently implemented, and (2) ambiguities and underspecification in the standards lead to suboptimal browser implementations. In total, the security analysis reveals 45 issues, of which 12 are violations of the proposed security goals and 31 issues concern vague and ambiguous features in the specifications. Additionally, we found that 6 out of 11 explicit security considerations have been overlooked/overruled in major browsers, leaving secure specifications vulnerable in the end.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Improving memory management security for C and C++\n", "abstract": " Memory managers are an important part of modern language and are used to dynamically allocate memory. Many managers exist; however, two major types can be identified: manual memory allocators and garbage collectors. In the case of manual memory allocators, the programmer must manually release memory back to the system when it is no longer needed. Problems can occur when a programmer forgets to release it, releases it twice or uses freed memory. These problems are solved in garbage collectors. However, both manual memory allocators and garbage collectors store management information. This paper describes several vulnerabilities for C and C++ and how these could be remedied by modifying the management information of a representative manual memory allocator and garbage collector. Additionally, the authors present an approach that, when applied to memory managers, will protect\u00a0\u2026", "num_citations": "3\n", "authors": ["328"]}
{"title": "Explicitly Recursive Grammar Combinators--The Implementation of some Grammar Algorithms\n", "abstract": " In a companion paper, we have presented an alternative representation of grammars in Haskell, explicitizing the grammar\u2019s recursion, decoupling the grammar from its semantic actions and making semantic actions independent of matching order. In this technical report, we present the implementation of some interesting grammar algorithms in order to provide evidence for the increased power and declarative style of our novel grammar representation. The presented code is a simplification of parts of our freely available Haskell library grammar-combinators.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Verification of unloadable C modules\u2014soundness proof\n", "abstract": " C programs may dynamically load and unload modules. For example, some operating system kernels support dynamic loading and unloading of device drivers. This causes specific difficulties in the verification of such programs and modules; in particular, it must be verified that no functions or global variables from the module are used after the module is unloaded. We propose a separation-logic-based approach for the verification of such programs and modules. We propose proof rules for loading and unloading modules, and for dealing with pointers to functions in unloadable modules, that ensure soundness while imposing minimal verification overhead. The approach is based on parameterized function types and assertion closures, both of which may mention themselves and each other. We offer a machine-checked formalization and soundness proof and we report on verifying a small kernellike program using a prototype implementation of the approach in our verifier, VeriFast. To the best of our knowledge, ours is the first approach for sound modular verification of unloadable modules.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Implicit dynamic frames: Combining dynamic frames and separation logic (soundness proof)\n", "abstract": " The dynamic frames approach has proven to be a powerful formalism for specifying and verifying object-oriented programs. However, it requires writing and checking many frame annotations. In this paper, we propose a variant of the dynamic frames approach that eliminates the need to explicitly write and check frame annotations.In this paper, we improve upon the classical dynamic frames approach in two ways:(1) method contracts are more concise and (2) fewer proof obligations must be discharged by the verifier. We have proven soundness, implemented the approach in a verifier prototype and demonstrated its expressiveness by verifying several challenging examples from related work.", "num_citations": "3\n", "authors": ["328"]}
{"title": "A machine-checked soundness proof for an efficient verification condition generator: technical report\n", "abstract": " Verification conditions (VCs) are logical formulae whose validity implies the correctness of a program with respect to a specification. The technique of checking software properties by specifying them in a program logic, then generating VCs, and finally feeding these VCs to a theorem prover, is several decades old. It is the underlying technology for state-of-the-art program verifiers such as the Spec\u266f programming system, or ESC/Java. The classic way of computing VCs is by means of Dijkstra\u2019s weakest precondition calculus. However, modern verification condition generators (VCgens), including Spec\u266f and ESC/Java\u2019s VCgens, are based on an optimized version of this algorithm, that avoids an exponential growth of the VCs in the length of the program to be verified. For this optimized VCgen algorithm, only informal soundness arguments are available. The paper \u201cA machine-checked soundness proof for an efficient verification condition generator\u201d by the same authors describes a fully formal, machine-checked proof of the soundness of such an efficient VCgen algorithm. This technical report elaborates further on the subject by fully detailing all definitions, theorems and proofs.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Practical experience with the. NET cryptographic API\n", "abstract": " When a vulnerability is discovered in a cryptographic algorithm, or in a specific implementation of that algorithm, it is important that software using that algorithm or implementation is upgraded quickly. Hence, modern cryptographic libraries such as the Java Cryptographic Architecture and Extensions (JCA/JCE) and the .NET crypto libraries are designed to be extensible with new algorithms. In addition, they also support algorithm and implementation independent use. Software written against these libraries can be implemented such that switching to a new crypto algorithm or implementation requires very little effort. This paper reports on our experiences with the implementation of a number of extensions to the .NET cryptographic framework. The extensions we consider are smart card based implementations of existing algorithms. We evaluate the extensibility of the libraries, and the support for implementation independence. We identify several problems with the libraries that have a negative impact on these properties, and we propose solutions. The main conclusion of the paper is that extensibility and implementation independence can be substantially improved with only minor changes. These changes maintain backwards compatibility for client code.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Inspector methods for state abstraction: soundness proof\n", "abstract": " This note formalizes and proves the soundness of an approach for modular static verification of safety properties of object-oriented programs where module specifications refer to module state abstractly, using inspector methods, to eliminate dependencies of clients on a module\u2019s internal implementation details.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Static verification of indirect data sharing in loosely-coupled component systems\n", "abstract": " To maintain loose coupling and facilitate dynamic composition, components in a pipe-and-filter architecture have a very limited syntactic interface and often communicate indirectly by means of a shared data repository. This severely limits the possibilities for compile time compatibility checking. Even static type checking is made largely irrelevant due to the very general types given in the interfaces. The combination of pipe-and-filter and a shared data repository is widely used, and in this paper we study this problem in the context of the Struts framework. We propose simple, but formally specified, behavioural contracts for components in such frameworks and show that automated formal verification of certain semantical compatibility properties is feasible. In particular, our verification guarantees that indirect data sharing through the shared data repository is performed consistently.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Improving software reliability in data-centered software systems by enforcing composition time constraints\n", "abstract": " Specifying and enforcing constraints and invariants such as architectural constraints and data typing, strongly enhances the safety and reliability of the software system. Next to design and development constraints, the composition of software systems in component-based software also introduces composition time constraints and dependencies. In data-centered software systems, for example, the software composer implicitly creates dataflow dependencies between software components. Describing composition time constraints and enforcing these constraints at deploy time or at run-time strongly improves the safety and reliability of the software. In this paper, we present an approach for expressing and enforcing dataflow dependencies in data-centered software systems, and conclude with a validation of the approach in a servlet-based case study.", "num_citations": "3\n", "authors": ["328"]}
{"title": "PAM. NET: A. NET Framework For Pluggable Authentication Modules\n", "abstract": " Authentication is one of the core security services of a distributed application platform. A variety of mechanisms to perform authentication have been developed, and it is beneficial if the choice for a specific mechanism is not hardcoded in an application. Pluggable Authentication Modules (PAM) is the name of a technology to support flexible changes with respect to the authentication mechanisms that an operating system or application uses. In this report, we describe an implementation of this technology, PAM .NET, on the .NET Common Language Runtime, Microsoft\u2019s new application platform. PAM .NET is well integrated with .NET\u2019s role-based access control, and enables a developer to build platform independent, extensible and configurable authentication and", "num_citations": "3\n", "authors": ["328"]}
{"title": "Humans, Computers, Specifications: The Arrow Logic of Information System Engineering\n", "abstract": " The goal of the paper is to manifest a special arrow diagram logic developed in mathematical category theory as capable to provide a general speci cation framework for information system engineering. We show that, unexpectedly, abstract ideas developed in categorical logic are of extremely high relevance for approaching some di cult speci cation problems in the eld. Correspondingly, the arrow thinking underlying the diagram logic is suggested as a working way of thinking in information system engineering.", "num_citations": "3\n", "authors": ["328"]}
{"title": "Compiling a secure variant of C to capabilities\n", "abstract": " Compiling a secure variant of C to capabilities Page 1 Compiling a secure variant of C to capabilities Akram El-Korashy*, Stelios Tsampas^, Marco Patrignani~, Dominique Devriese^, Deepak Garg*, Frank Piessens^ *MPI-SWS, ^KU-Leuven, ~CISPA Dagstuhl Seminar on Secure Compilation Page 2 How to keep C variables in RAM in a secure way? 2 Your intentions may be noble, but they are also misguided. The short answer is that there's really no way to do what you want on a general purpose system (ie commodity processors/motherboard and general-purpose O/S). https://stackoverflow.com/questions/16500549/how-to-keep-c-variables-in-ram-securely Page 3 No data isolation in C 3 Data isolation is needed to be able to reason about security invariants. C semantics does not require any isolation guarantee. Page 4 Data isolation? We mean private state. Only specific functions should be given access to specific \u2026", "num_citations": "3\n", "authors": ["328"]}
{"title": "Security across abstraction layers: old and new examples\n", "abstract": " A common technique for building ICT systems is to build them as successive layers of bstraction: for instance, the Instruction Set Architecture (ISA) is an abstraction of the hardware, and compilers or interpreters build higher level abstractions on top of the ISA.The functionality of an ICT application can often be understood by considering only a single level of abstraction. For instance the source code of the application defines the functionality using the level of abstraction of the source programming language. Functionality can be well understood by just studying this source code.Many important security issues in ICT system however are cross-layer issues: they can not be understood by considering the system at a single level of abstraction, but they require understanding how multiple levels of abstraction are implemented. Attacks may rely on, or exploit, implementation details of one or more layers below the source\u00a0\u2026", "num_citations": "2\n", "authors": ["328"]}
{"title": "Improving Privacy Through Fast Passive Wi-Fi Scanning\n", "abstract": " Traditionally, Wi-Fi networks are discovered by actively transmitting probe requests. The alternative, passive scanning, is rarely used because it is substantially slower. Unfortunately, active scanning can be abused to track users based on (physical) fingerprints of probe requests. Previous work attempted to address these issues by making active scanning more privacy-friendly. For instance, Franklin et al. proposed to make implementations more uniform (USENIX Security\u00a02006), and Lindqvist et al. suggested to use encrypted probe requests (WiSec\u00a02009). However, a better approach is to make passive scanning faster. This motivates vendors to use passive scanning, increasing the privacy of users. Motivated by the above insight, we improve the performance of passive scanning. We implement our proposals on Android, and show the average time needed to connect to a known network using passive scanning now\u00a0\u2026", "num_citations": "2\n", "authors": ["328"]}
{"title": "Securely deploying distributed computation systems on peer-to-peer networks\n", "abstract": " More and more off-the-shelf processors support the dynamic construction of Trusted Execution Environments. For instance, Intel Software Guard Extensions (Intel SGX) supports the construction of so-called enclaves on modern Intel Core processors. Hence, it is interesting to design and evaluate practical security architectures that leverage this new technology.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Tutorial: Uncovering and mitigating side-channel leakage in Intel SGX enclaves\n", "abstract": " The inclusion of the Software Guard eXtensions (SGX) in recent Intel processors has been broadly acclaimed for bringing strong hardware-enforced trusted computing guarantees to mass consumer devices, and for protecting end user data in an untrusted cloud environment. While SGX assumes a very strong attacker model and indeed even safeguards enclave secrets against a compromised operating system, recent research has demonstrated that considerable private data (eg, full text and images, complete cryptographic keys) may still be reconstructed by monitoring subtle side-effects of the enclaved execution. We argue that a systematic understanding of such side-channel leakage sources is essential for writing intrinsically secure enclave applications, and will be instrumental to the success of this new trusted execution technology. This tutorial and write-up therefore aims to bring a better understanding of current state-of-the-art side-channel attacks and defenses on Intel SGX platforms. Participants will learn how to extract data from elementary example applications, thereby recognizing how to avoid common pitfalls and information leakage sources in enclave development.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Developing secure SGX enclaves: new challenges on the horizon\n", "abstract": " The combination of (1) hard to eradicate low-level vulnerabilities,(2) a large trusted computing base written in a memory-unsafe language and (3) a desperate need to provide strong software security guarantees, led to the development of protected-module architectures. Such architectures provide strong isolation of protected modules: Security of code and data depends only on a module's own implementation.", "num_citations": "2\n", "authors": ["328"]}
{"title": "On Modular and Fully-Abstract Compilation--Technical Appendix\n", "abstract": " Secure compilation studies compilers that generate target-level components that are as secure as their source-level counterparts. Full abstraction is the most widely-proven property when defining a secure compiler. A compiler is modular if it allows different components to be compiled independently and then to be linked together to form a whole program. Unfortunately, many existing fully-abstract compilers to untyped machine code are not modular. So, while fully-abstractly compiled components are secure from malicious attackers, if they are linked against each other the resulting component may become vulnerable to attacks. This paper studies how to devise modular, fully-abstract compilers. It first analyses the attacks arising when compiled programs are linked together, identifying security threats that are due to linking. Then, it defines a compiler from an object-based language with method calls and dynamic memory allocation to untyped assembly language extended with a memory isolation mechanism. The paper provides a proof sketch that the defined compiler is fully-abstract and modular, so its output can be linked together without introducing security violations.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Reasoning about object capabilities with logical relations and effect parametricitytechnical report including proofs and details\n", "abstract": " Object capabilities are a technique for fine-grained privilege separation in programming languages and systems, with important applications in security. However, current formal characterisations do not fully capture capability-safety of a programming language and are not sufficient for verifying typical applications. Using state-ofthe-art techniques from programming languages research, we define a logical relation for a core calculus of JavaScript that better characterises capability-safety. The relation is powerful enough to reason about typical capability patterns and supports evolvable invariants on shared data structures, capabilities with restricted authority over them and isolated components with restricted communication channels. We use a novel notion of effect parametricity for deriving properties about effects. Our results imply memory access bounds that have previously been used to characterise capability-safety. This is a technical report accompanying a paper by the same title and authors, which contains an additional section about a binary version of our results, as well as proofs and details for our results.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Policy ignorant caller-side inline reference monitoring\n", "abstract": " Runtime security policy enforcement systems are crucial to limit the risks associated with running untrustworthy (malicious or buggy) code. The inlined reference monitor approach to policy enforcement, pioneered by Erlingsson and Schneider, implements runtime enforcement through program rewriting: security checks are inserted inside untrusted programs. Ensuring complete mediation\u2014the guarantee that every security-relevant event is actually intercepted by the monitor\u2014is non-trivial when the program rewriter operates on an object-oriented intermediate language with state-of-the-art features such as virtual methods and delegates. This paper proposes a caller-side rewriting algorithm for MSIL\u2014the bytecode of the .NET virtual machine\u2014where security checks are inserted around calls to security-relevant methods. We prove that this algorithm achieves sound and complete mediation and transparency\u00a0\u2026", "num_citations": "2\n", "authors": ["328"]}
{"title": "Secure Compilation of Object-Oriented Components to Protected Module Architectures\u2013Extended Version\n", "abstract": " A fully abstract compilation scheme prevents the security features of the high-level language from being bypassed by an attacker operating at a particular lower level. This paper presents a fully abstract compilation scheme from a realistic object-oriented language with dynamic memory allocation, cross-package inheritance, exceptions and inner classes to untyped machine code. Full abstraction of the compilation scheme relies on enhancing the low-level machine model with a fine-grained, program counter-based memory access control mechanism. This paper contains the outline of a formal proof of full abstraction of the compilation scheme. Measurements of the overhead introduced by the compilation scheme indicate that it is negligible.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Featherweight VeriFast: Extended Version\n", "abstract": " VeriFast is a verification tool based on separation logic which can be used to verify correctness properties of C and Java programs, going from memory safety and absence of race conditions to full functional correctness. While the tool has been applied to several real-world cases, VeriFast as of yet had no published theoretical foundation. This report fills this lacuna by giving a full formalisation and soundness proof of a core subset of VeriFast.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Expressive modular fine-grained concurrency specification (extended version)\n", "abstract": " Compared to coarse-grained external synchronization of operations on data structures shared between concurrent threads, finegrained, internal synchronization can offer stronger progress guarantees and better performance. However, fully specifying operations that perform internal synchronization modularly is a hard, open problem. The state of the art approaches, based on linearizability or on concurrent abstract predicates, have important limitations on the expressiveness of specifications. Linearizability does not support ownership transfer, and the concurrent abstract predicates-based specification approach requires hardcoding a particular usage protocol. In this paper, we propose a novel approach that lifts these limitations and enables fully general specification of fine-grained concurrent data structures. The basic idea is that clients pass the ghost code required to instantiate an operation\u2019s specification for a specific client scenario into the operation in a simple form of higher-order programming.We machine-checked the theory of the paper using the Coq proof assistant. Furthermore, we implemented the approach in our program verifier VeriFast and used it to verify two challenging finegrained concurrent data structures from the literature: a multiplecompare-and-swap algorithm and a lock-coupling list. This extended version includes the definition of validity, a discussion of the machine-checked proof, and a proof outline of the concurrent set example.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Precise and progressing compositional symbolic execution\n", "abstract": " Given a program and an assertion in that program, determining if the assertion can fail is one of the key applications of program analysis. Symbolic execution is a well-known technique for finding such assertion violations. It enjoys the following two interesting properties. First, symbolic execution is precise: if it reports that an assertion can fail, then there is an execution of the program that will make the assertion fail. Second, it is progressing: if there is an execution that makes the assertion fail, it will eventually be found. A symbolic execution algorithm that is both precise and progressing is a semi-decision procedure.Recently, compositional symbolic execution has been proposed. It improves scalability by analyzing each execution path of each method only once. However, proving precision and progress is more challenging for these compositional algorithms. This paper investigates under what conditions a compositional algorithm is precise and progressing (and hence a semi-decision procedure), and reports on the implementation of one such algorithm.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Report: Extensibility and Implementation Independence of the. NET Cryptographic API\n", "abstract": " When a vulnerability is discovered in a cryptographic algorithm, or in a specific implementation of that algorithm, it is important that software using that algorithm or implementation is upgraded quickly. Hence, modern cryptographic libraries such as the .NET crypto libraries are designed to be extensible with new algorithms. In addition, they also support algorithm and implementation independent use. Software written against these libraries can be implemented such that switching to a new crypto algorithm or implementation requires very little effort.               This paper reports on our experiences with the implementation of a number of extensions to the .NET cryptographic framework. The extensions we consider are smart card based implementations of existing algorithms. We evaluate the extensibility of the libraries, and the support for implementation independence. We identify several problems with the\u00a0\u2026", "num_citations": "2\n", "authors": ["328"]}
{"title": "Dynamic owicki-gries reasoning using ghost fields and fractional permissions\n", "abstract": " In this short note, we show how ghost fields and fractional permissions can be used to prove fork-join patterns. The approach is a simple port of Owicki and Gries's auxiliary variables-based approach to the setting with dynamic threads, locks, and objects.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Verification of data-race-freedom of a Java chat server with VeriFast\n", "abstract": " Even now, when computers have become a vital part of our society, software errors are still common, and their effects can be devastating. From the recent rise of multicores emerged the need for multi-threading software and a way to cope with its typical software errors such as data-races and deadlocks. This paper shows how VeriFast can be used to verify the data-race-freedom of a multi-threaded Java application, by means of a simple Java chat server example. We will cover the verification of jar files in general, how to deal with Java core classes and interfaces such as ArrayList and the specifics of verifying a multi-threaded Java application, using Thread, Runnable and Semaphore as building blocks. To achieve this, we need to take a closer look at VeriFast elements such as predicate families, predicate constructors and fractional permissions. This paper is intended as an experience report. We will conclude with some suggested improvements and possible future work.", "num_citations": "2\n", "authors": ["328"]}
{"title": "A machine checked soundness proof for an intermediate verification language: extended version\n", "abstract": " Machine-checked proofs of properties of programming languages have gained in importance significantly over the past few years. This paper contributes to this trend by proposing an approach for doing machine-checked soundness proofs for verification condition (VC) generators. Our approach embraces the multi-phase VC generation common in modern program verifiers. Such verifiers split the generation of VCs in two (or even more) phases, using an intermediate verification language as the bridge between the programming language and logic. In our approach, we define a formal operational semantics of the intermediate verification language, and we prove the soundness of two translations separately:(1) the translation of the intermediate verification language to VCs, and (2) the translation of the source programming language to the intermediate language. This paper presents a fully machine checked proof of step (1) for a prototypical intermediate verification language, and then illustrates step (2) for a very small object oriented programming language.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Access control\n", "abstract": " \u2022 Objective= strict control of information flow\u2022 Concrete example MAC model: Lattice Based Access Control (LBAC)\u2022 Objective=", "num_citations": "2\n", "authors": ["328"]}
{"title": "Safe language support for feature composition through feature-based dispatch\n", "abstract": " Suppose we are developing a large software system to support a stock management business. The core functionality of such a system is simply adding items to the stock, removing items and retrieving an inventory of the actual stockor a subset thereof. The essence of the business is based on charging fees for the core services, starting with charging for stocking items. Such a business model requires features for customer (user) management, for tracking the cost of manipulating the stock and for authenticating and billing clients that use our services. Furthermore, to avoid planning problems, such as one of our clients running out of stock, we support features that implement different planning and ordering strategies. Additional features could be: monitoring the availability of certain items in the stock, sending a notification when the availability reaches a certain level and so on.In the context of the example, the need for different kinds of feature composition arises: some features should be activated only when certain clients use our application, some features must always be composed (eg. the authentication and billing features), other features may be composed dynamically (to change the ordering strategy, for example), some conflict (you may only select one ordering strategy) and again others are optional (the notification feature can only fully function when the monitoring feature is available, but the composition may still be legal when the notification feature is composed without the monitoring feature). The above examples indicate some of the requirements of a composition operator. In many cases, and especially in the development of large software\u00a0\u2026", "num_citations": "2\n", "authors": ["328"]}
{"title": "The Arrow Manifesto: Towards software engineering based on comprehensible yet rigorous graphical specifications\n", "abstract": " A novel formalizable speci cation paradigm is proposed which makes it possible to solve a lot of speci cation problems in software. The roots of the idea are in mathematical category theory; following its terminology we call our speci cations sketches. Among the principal advantages of sketches are the following.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Proving full-system security properties under multiple attacker models on capability machines\n", "abstract": " Assembly-level protection mechanisms (virtual memory, trusted execution environments, virtualization) make it possible to guarantee security properties of a full system in the presence of arbitrary attacker provided code. However, they typically only support a single trust boundary: code is either trusted or untrusted, and protection cannot be nested. Capability machines provide protection mechanisms that are more finegrained and that do support arbitrary nesting of protection. We show in this paper how this enables the formal verification of fullsystem security properties under multiple attacker models: different security objectives of the full system can be verified under a different choice of trust boundary (ie under a different attacker model). The verification approach we propose is modular, and is robust: code outside the trust boundary for a given security objective can be arbitrary, unverified attacker-provided code. It is based on the use of universal contracts for untrusted adversarial code: sound, conservative contracts which can be combined with manual verification of trusted components in a compositional program logic. Compositionality of the program logic also allows us to reuse common parts in the analyses for different attacker models. We instantiate the approach concretely by extending an existing capability machine model with support for memorymapped I/O and we obtain full system, machine-verified security properties about external effect traces while limiting the manual verification effort to a small trusted computing base relevant for the specific property under study.", "num_citations": "2\n", "authors": ["328"]}
{"title": "Aion: Enabling Open Systems through Strong Availability Guarantees for Enclaves\n", "abstract": " Embedded Trusted Execution Environments (TEEs) can provide strong security for software in the IoT or in critical control systems. Approaches to combine this security with real-time and availability guarantees are currently missing. In this paper we present Aion, a configurable security architecture that provides a notion of guaranteed real-time execution for dynamically loaded enclaves. We implement preemptive multitasking and restricted atomicity on top of strong enclave software isolation and attestation. Our approach allows the hardware to enforce confidentiality and integrity protections, while a decoupled small enclaved scheduler software component can enforce availability and guarantee strict deadlines of a bounded number of protected applications, without necessarily introducing a notion of priorities amongst these applications. We implement a prototype on a light-weight TEE processor and provide a\u00a0\u2026", "num_citations": "1\n", "authors": ["328"]}
{"title": "Automated Fuzzing of Automotive Control Units\n", "abstract": " Modern vehicles are governed by a network of Electronic Control Units (ECUs), which are programmed to sense inputs from the driver and the environment, to process these inputs, and to control actuators that, e.g., regulate the engine or even control the steering system. ECUs within a vehicle communicate via automotive bus systems such as the Controller Area Network (CAN), and beyond the vehicles boundaries through upcoming vehicle-to-vehicle and vehicle-to-infrastructure channels. Approaches to manipulate the communication between ECUs for the purpose of security testing and reverse-engineering of vehicular functions have been presented in the past, all of which struggle with automating the detection of system change in response to message injection. In this paper we present our findings with fuzzing CAN networks, in particular while observing individual ECUs with a sensor harness. The harness detects physical responses, which we then use in a oracle functions to inform the fuzzing process. We systematically define fuzzers, fuzzing configurations and oracle functions for testing ECUs. We evaluate our approach based on case studies of commercial instrument clusters and with an experimental framework for CAN authentication. Our results show that the approach is capable of identifying interesting ECU states with a high level of automation. Our approach is applicable in distributed cyber-physical systems beyond automotive computing.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Compiler-Assisted Hardening of Embedded Software Against Interrupt Latency Side-Channel Attacks\n", "abstract": " Recent controlled-channel attacks exploit timing differences in the rudimentary fetch-decode-execute logic of processors. These new attacks also pose a threat to software on embedded systems. Even when Trusted Execution Environments (TEEs) are used, interrupt latency attacks allow untrusted code to extract application secrets from a vulnerable enclave by scheduling interruption of the enclave. Constant-time programming is effective against these attacks but, as we explain in this paper, can come with some disadvantages regarding performance. To deal with this new threat, we propose a novel algorithm that hardens programs during compilation by aligning the execution time of corresponding instructions in secret-dependent branches. Our results show that, on a class of embedded systems with deterministic execution times, this approach eliminates interrupt latency side-channel leaks and mitigates limitations of constant-time programming. We have implemented our approach in the LLVM compiler infrastructure for the Sancus TEE, which extends the openMSP430 microcontroller, and we discuss applicability to other architectures. We make our implementation and benchmarks available for further research.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Abstract Congruence Criteria for Weak Bisimilarity\n", "abstract": " We introduce three general compositionality criteria over operational semantics and prove that, when all three are satisfied together, they guarantee weak bisimulation being a congruence. Our work is founded upon Turi and Plotkin's mathematical operational semantics and the coalgebraic approach to weak bisimulation by Brengos. We demonstrate each criterion with various examples of success and failure and establish a formal connection with the simply WB cool rule format of Bloom and van Glabbeek. In addition, we show that the three criteria induce lax models in the sense of Bonchi et al.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Towards categorical contextual reasoning\n", "abstract": " Morris style contextual equivalence of programs, the equality of observable behavior of these programs under any execution context, is the standard notion of program equivalence for operational models. Distributive laws are a categorical framework to study a large class of operational models, including those that adhere to the GSOS rule format. We define a notion of syntactic execution contexts in this abstract setting and prove that strong bisimilarity is contextually closed: plugging strongly bisimilar programs in the same context, yields strongly bisimilar programs. We argue that for specific languages, it is feasible to fine-tune the operational model and semantics to make bisimilarity coincide with contextual equivalence. We proceed to show in general that maps of distributive laws generate compilers that preserve and often reflect bisimilarity. Thus, we obtain an approach to proving full abstraction of a compiler.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Software Security Knowledge Area\n", "abstract": " The purpose of this Software Security chapter is to provide a structured overview of known categories of software implementation vulnerabilities, and of techniques that can be used to prevent or detect such vulnerabilities, or to mitigate their exploitation. This overview is intended to be useful to academic staff for course and curricula design in the area of software security, as well as to industry professionals for the verification of skills and the design of job descriptions in this area.Let us start by defining some terms and concepts, and by defining the scope of this chapter. A first key issue is what it means for software to be secure? One possible definition is that a software system is secure if it satisfies a specified or implied security objective. This security objective specifies confidentiality, integrity and availability requirements 1 for the system\u2019s data and functionality. Consider, for instance, a social networking service. The security objective of such a system could include the following requirements:", "num_citations": "1\n", "authors": ["328"]}
{"title": "Hardening Intel SGX applications: balancing concerns\n", "abstract": " Today's technologies such as Intel SGX enable developers to protect applications from more privileged security layers. Applications can be developed with significantly smaller TCBs than before. Two main techniques have emerged to harden applications for these new security architectures. One focuses on partitioning applications in pieces-of-application-logic thereby isolating security-sensitive parts in their own enclaves. The other moves full unmodified applications to a single enclave tied together with a library OS. In this paper we argue that both techniques should be treated as separate security mechanisms each providing their own balance in terms of security, performance and usability.", "num_citations": "1\n", "authors": ["328"]}
{"title": "A principled approach to tracking information flow in the presence of libraries: Full version\n", "abstract": " There has been encouraging progress on information flow control for programs in increasingly complex programming languages, tracking the propagation of information from input sources to output sinks. Yet, programs are typically deployed in an environment with rich APIs and powerful libraries, posing challenges for information flow control when the code for these APIs and libraries is either unavailable or written in a different language.This paper presents a principled approach to tracking information flow in the presence of libraries. With the goal to strike the balance between security and precision, we present a framework that explores the middle ground between the \u201cshallow\u201d, signature-based modeling of libraries and the \u201cdeep\u201d, stateful approach, where library models need to be supplied manually. We formalize our approach for a core language, extend it with lists and higher-order functions, and establish soundness results with respect to the security condition of noninterference.", "num_citations": "1\n", "authors": ["328"]}
{"title": "The table monad in Haskell\n", "abstract": " Non-deterministic functions are functions that can return multiple answers. When such a function calls itself recursively it can produce an infinite number of answers where only finitely many distinct results exist. Tabling is a technique that allows the combination of recursion and non-determinism in Prolog. In this paper we construct the Table Monad, introducing tabling for non-deterministic functions in Haskell. This monad is constructed using the \u201cEffect-Handlers\u201d-approach. A variation on tabling, tabling with aggregates is also discussed. Benchmarks show that for some cases this kind of tabling is more efficient.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Proof techniques for precision and progress of computational symbolic execution\n", "abstract": " Given a program and an assertion in that program, determining if the assertion can fail is one of the key applications of program analysis. Symbolic execution is a well-known technique for finding such assertion violations that can enjoy the following two interesting properties. First, symbolic execution can be precise: if it reports that an assertion can fail, then there is an execution of the program that will make the assertion fail. Second, it can be progressing: if there is an execution that makes the assertion fail, it will eventually be found. A symbolic execution algorithm that is both precise and progressing is a semi-decision procedure. Recently, compositional symbolic execution has been proposed. It improves scalability by analyzing each execution path of each method only once. However, proving precision and progress is more challenging for these compositional algorithms. This paper investigates under what conditions a compositional algorithm is precise and progressing (and hence a semi-decision procedure).", "num_citations": "1\n", "authors": ["328"]}
{"title": "Towards lightweight state coverage\n", "abstract": " State coverage is a relatively new metric to evaluate the quality of test suites. While most existing test adequacy criteria measure the degree of exploration of the code under test, state coverage estimates the strength of the assertions in the test suite. Unfortunately, state coverage suffers from two important disadvantages. First, it uses a fairly complicated dependency analysis based on information flow analysis, which is both inefficient and hard to understand for endusers. Second, since state coverage focuses on incorrect assignments, it does not help to detect defects of omission, which are at least as important.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Attacks on the user\u2019s session\n", "abstract": " By attacking the user\u2019s session, an attacker can gain control over an authenticated session, giving him the same level of access to the target application as the victim. Unfortunately, applications often deploy weak authentication systems and insufficiently protect authenticated sessions, thereby enabling these attacks. In this chapter, we cover two attacks that enable the attacker to transfer an authenticated session from the victim\u2019s browser to his own: session-hijacking and Session fixation. In addition, we cover the impact of credential theft, a common attack that gives the attacker valid user credentials, allowing him to impersonate a user to the target application. Attacks on the user\u2019s session are common, and are supported by various tools and attack frameworks.", "num_citations": "1\n", "authors": ["328"]}
{"title": "The Browser as a Platform\n", "abstract": " The browser is the single, most valuable tool for enabling users to access the Web. Browser vendors realize this, which is why domination in the browser market share has been a high-stakes game since the 1990s. In this chapter, we take a look at how browsers can be found on numerous devices today, including mobile devices and smart appliances. We investigate how the browser evolved from a static rendering engine into a full-featured Web application platform, offering Web applications access to local storage facilities, sensor information, communication mechanisms, and more. Finally, we discuss Firefox OS and Google\u2019s Chrome OS that have given the browser the status of an operating system.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Attacks on the Browser\u2019s Requests\n", "abstract": " By attacking the browser\u2019s requests, an attacker is able to trick the user\u2019s browser into sending requests to a target application. Since these requests originate from the user\u2019s browser, a vulnerable application is unable to distinguish them from legitimate requests, thus allowing the attacker to perform actions in the user\u2019s name. The two most common ways of forging requests from the user\u2019s browser are cross-site request forgery (CSRF), where requests are automatically sent by the browser, and UI redressing, where the user is tricked into interacting with a seemingly innocent page, while the interactions are actually sent to the target application. Real-life attacks on vulnerable applications have allowed attackers to transfer money from bank accounts, take over accounts through the password reset feature or secretly enable the webcam in the Flash player.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Attacks on the Client Device\n", "abstract": " By directly attacking the client device, the attacker can gain control over the device, allowing him/her to manipulate the user\u2019s actions, steal sensitive information or abuse the device for other activities, such as denial of service attacks. In this chapter, we discuss two important attack vectors. The first attack vector uses drive-by download techniques to exploit a memory corruption vulnerability in the client software, for example, a buffer overflow vulnerability in the browser. The second attack vector attacks the client device through a malicious browser extension, which is characterized by a high degree of control over the browser.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Client side web session integrity as a non-interference property: Extended version with proofs\n", "abstract": " Sessions on the web are fragile. They have been attacked successfully in many ways, by network-level attacks, by direct attacks on session cookies (the main mechanism for implementing the session concept) and by application-level attacks where the integrity of sessions is violated by means of cross-site request forgery or malicious script inclusion. This paper defines a variant of non-interference\u2013the classical security notion from information flow security\u2013that can be used to formally define the notion of client-side application-level web session integrity. The paper also develops and proves correct an enforcement mechanism. Combined with state-of-the-art countermeasures for network-level and cookie-level attacks, this enforcement mechanism gives very strong assurance about the client-side preservation of session integrity for authenticated sessions.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Instance arguments in Agda-An alternative to type classes\n", "abstract": " We present instance arguments: an alternative to type classes and related features. Instance arguments are a new, general type of function arguments, resolved at the call-site scope in a type-directed way. The concept is inspired by both Scala's implicits and Agda's existing implicit arguments, but differs from both in important ways. Our mechanism is designed and implemented for the dependently typed, purely functional programming language/proof assistant Agda, but our design choices can be applied to other programming languages as well. Like Scala's implicits, we do not provide a separate structure for type classes and their instances, but instead rely on Agda's standard dependently typed records, so that we can reuse standard language mechanisms to provide features that are missing or expensive in other proposals. Like Scala, we support the equivalent of local instances. Unlike Scala, functions taking our new arguments are first-class citizens and can be abstracted over and manipulated in standard ways. Compared to other proposals, we avoid the pitfall of introducing a separate type-level computational model through the instance search mechanism. All values in scope are candidates for instance resolution. A final novelty of our approach is that existing Agda libraries using records gain the benefits of instance arguments without any modification. We discuss our implementation in Agda (part of Agda v2. 3.0 onward) and we use monads as an example to show how it allows existing concepts in the Agda standard library to be used in a similar way as Haskell code uses type classes. We also demonstrate and discuss equivalents and\u00a0\u2026", "num_citations": "1\n", "authors": ["328"]}
{"title": "Information flow control for web scripts\n", "abstract": " Modern web applications heavily rely on JavaScript code executing in the browser. These web scripts are useful for instance for improving the interactivity and responsiveness of web applications, and for gathering web analytics data. However, the execution of server-provided code in the browser also brings substantial security and privacy risks. Web scripts can access a fair amount of sensitive information, and can leak this information to anyone on the Internet. This tutorial paper discusses information flow control mechanisms for countering these threats. We formalize both a static, type-system based and a dynamic, multi-execution based enforcement mechanism, and show by means of examples how these mechanisms can enforce the security of information flows in web scripts.", "num_citations": "1\n", "authors": ["328"]}
{"title": "State coverage: An empirical analysis based on a user study\n", "abstract": " State coverage is a relatively new metric to evaluate the quality of test suites. While most existing test adequacy criteria measure the degree of exploration of the code under test, state coverage estimates the strength of the assertions in the test suite. Initial experiments have shown that there is a correlation between state coverage and mutation adequacy, and that expert users can discover new faults by modifying the test suite to increase state coverage. Since the faults injected by mutation testing are relatively simple, it is not clear whether these experiment are valid in a broader setting. Furthermore, these results may not be reproducible by average users, since they usually lack full understanding of the internals of the tool.                 This paper presents a user-based experiment to evaluate whether the state coverage of a test suite correlates with the number defects it discovers. While the results of the\u00a0\u2026", "num_citations": "1\n", "authors": ["328"]}
{"title": "Partial type signatures for Haskell: Extended version with proofs of the theorems\n", "abstract": " Strong type systems can be used to increase the reliability and performance of programs. In combination with type inference the overhead for the programmer can be kept small. Nevertheless, explicit type signatures often remain needed or useful. In languages with standard Hindley-Milner-based type systems, programmers have a binary choice between omitting the type signature (and rely on type inference) or explicitly providing the type entirely; there are no intermediate options. Proposals for partial type signatures exist, but none support features like local constraints and GHC\u2019s nongeneralisation of local bindings. Therefore we propose and motivate a practical form of partial type signatures for present-day Haskell. We formally describe our proposal as an extension of the OutsideIn (X) system and prove some of its properties. We have developed a (not yet complete) implementation for the GHC Haskell compiler. Our design fits naturally in both the OutsideIn (X) formalism and the compiler.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Security and privacy of online social network applications\n", "abstract": " An important recent innovation on social networking sites is the support for plugging in third-party social applications. Together with the ever-growing number of social network users, social applications come with privacy and security risks for those users. While basic mechanisms for isolating applications are well understood, these mechanisms fall short for social-enabled applications. It is an interesting challenge to design and develop application platforms for social networks that enable the necessary functionality of social applications without compromising both users\u2019 security and privacy. This chapter will identify and discuss the current security and privacy problems related to social applications and their platforms. Next, it will zoom in on proposals on how to address those problems.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Securing web applications with browser add-ons: an experience report\n", "abstract": " With the vast expansion of the web, and the increasing involvement in our everyday lives, web security is as important as ever, illustrated by the frequent reports of security breaches and vulnerabilities, even in mainstream media. Most of the exploited vulnerabilities have been known for some time, have been subject to active research and have been solved on a practical or academic level. Unfortunately, widespread adoption of such solutions is difficult to achieve, either due to an imperfect web developer, or due to the complexity of dealing with legacy code, leaving the user or the user\u2019s data vulnerable in the end. Offering a client-side security measure allows the user to protect himself against these vulnerabilities, since these problems are not (immediately) targeted at the server-side.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Secure Compilation of Object-Oriented Components to Untyped Machine Code\n", "abstract": " A fully abstract compilation scheme prevents high-level code security features from being bypassed by an attacker operating at a lower level. This paper presents a fully abstract compilation scheme from a realistic object-oriented language with dynamic memory allocation to untyped machine code. Full abstraction of the compilation scheme relies on enhancing the low-level machine model with a finegrained, program counter-based memory access control mechanism. This paper contains the outline of a formal proof of full abstraction of the compilation scheme, guaranteeing that low-and high-level attackers have the same power.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Secure multi-execution through static program transformation: extended version\n", "abstract": " Secure multi-execution (SME) is a dynamic technique to ensure secure information flow. In a nutshell, SME enforces security by running one execution of the program per security level, and by reinterpreting input/output operations wrt their associated security level. SME is sound, in the sense that the execution of a program under SME is non-interfering, and precise, in the sense that for programs that are non-interfering in the usual sense, the semantics of a program under SME coincides with its standard semantics. A further virtue of SME is that its core idea is languageindependent; it can be applied to a broad range of languages. A downside of SME is the fact that existing implementation techniques require modifications to the runtime environment, eg the browser for Web applications. In this article, we develop an alternative approach where the effect of SME is achieved through program transformation, without modifications to the runtime, thus supporting server-side deployment on the web. We show on an exemplary language with input/output and dynamic code evaluation (modeled after JavaScript's eval) that our transformation is sound and precise. The crux of the proof is a simulation between the execution of the transformed program and the SME execution of the original program. This proof has been machine-checked using the Agda proof assistant. We also report on prototype implementations for a small fragment of Python and a substantial subset of JavaScript. This report is an extended version of a paper published at FMOODS/FORTE 2012. It extends the conference version with technical details about the formalization and the proofs.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Explicitly Recursive Grammar Combinators The Implementation of some Grammar Algorithms Technical report\n", "abstract": " In a companion paper, we have presented an alternative representation of grammars in Haskell, explicitizing the grammar\u2019s recursion, decoupling the grammar from its semantic actions and making semantic actions independent of matching order. In this technical report, we present the implementation of some interesting grammar algorithms in order to provide evidence for the increased power and declarative style of our novel grammar representation. The presented code is a simplification of parts of our freely available Haskell library grammar-combinators.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Verification of Unloadable C Modules\u2014Status Report\n", "abstract": " C programs may dynamically load and unload modules. For example, some operating system kernels support dynamic loading and unloading of device drivers. This causes specific difficulties in the verification of such programs and modules; in particular, it must be verified that no functions or global variables from the module are used after the module is unloaded. We propose a separation-logic-based approach for the verification of such programs and modules. We propose proof rules for loading and unloading modules, and for dealing with pointers to functions in unloadable modules, that ensure soundness while imposing minimal verification overhead. We offer a formalization and we report on verifying a small kernel-like program using a prototype implementation of the approach in our verifier, VeriFast. To the best of our knowledge, ours is the first approach for sound modular verification of unloadable modules.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Subsystems: provably safe exception handling (status report)\n", "abstract": " The primary goal of exception mechanisms is to help ensure that when an operation fails, code that depends on the operation\u2019s successful completion is not executed (a property we call dependency safety). However, current exception mechanisms make it hard to achieve dependency safety, in particular when objects manipulated inside a try block outlive the try block. To remedy this, we propose a language mechanism called subsystems. Programmers may create subsystems dynamically and execute blocks of code in them. Once any such block fails, all subsequent attempts to execute code in the subsystem will fail. To achieve dependency safety, programmers simply need to ensure that if an operation B depends on an operation A, then A and B are executed in the same subsystem. Furthermore, subsystems help fix the unsafe interaction between locks and exceptions and they enable safe cancellation and robust resource cleanup. We have implemented the mechanism as a C# library, and we show that the constructs have low performance overhead.", "num_citations": "1\n", "authors": ["328"]}
{"title": "M.: Towards equal rights for higher-kinded types. accepted for the\n", "abstract": " Generics are a very popular feature of contemporary OO languages, such as Java, C# or Scala. Their support for genericity is lacking, however. The problem is that they only support abstracting over proper types, and not over generic types. This limitation makes it impossible to, eg, define a precise interface for Iterable, a core abstraction in Scala\u2019s collection API. We implemented \u201ctype constructor polymorphism\u201d in Scala 2.5, which solves this problem at the root, thus greatly reducing the duplication of type signatures and code. 1", "num_citations": "1\n", "authors": ["328"]}
{"title": "Safe Fine-Grained Locking for Aggregate Objects\n", "abstract": " Programmers have difficulty writing correct multithreaded code, not to mention code that scales well. One way to approach this problem is by offering a transaction construct, and leaving it to the compiler and run-time system to implement efficient synchronization. However, automatically generating efficient synchronization code is an open research problem. In this paper, rather than attempting to generate synchronization code automatically, we propose a programming methodology for explicit fine-grained locking of aggregate objects. We also propose a method for run-time checking, and a method for sound modular static verification of the safety of programs written according to the methodology. The system prevents deadlocks. The system is an extension of our methodology for safe concurrency for aggregate objects with invariants, which is in turn based on the Spec#/Boogie methodology for aggregate objects with invariants. This paper is a preliminary result of our investigation into programming methodologies for safe and efficient concurrency in object-oriented languages.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Verifying programs using inspector methods for state abstraction\n", "abstract": " Most classes in an object-oriented program provide access to an object\u2019s state through methods, so that client code does not depend on and cannot interfere with the object\u2019s internal representation composed of fields and internal component objects. Methods used for this purpose are sometimes called inspector methods. In order to extend the benefits of inspector methods to specifications, the method contracts of non-inspector methods may be expressed using inspector methods. In this paper, we propose an approach to the verification of programs that use inspector methods in method contracts and object invariants. Performing state abstraction in a programming language that allows aliasing through object references poses a framing problem. Our solution to this framing problem is a formulation of the Boogie methodology in terms of read bags and write sets which, combined with the Boogie methodology\u2019s ownership system, abstractly capture a method\u2019s effects. We show how programs that are specified using inspector methods can be translated into the input language of the Boogie", "num_citations": "1\n", "authors": ["328"]}
{"title": "Infrastructural support for data dependencies in data-centered software systems\n", "abstract": " The identification of key concerns is crucial for a good application of the separation-of-concerns principle [5, 3]. However, an exhaustive list of all important non-functional concerns and the correct decomposition of software into those concerns is still an open question. Moreover, we believe that some of the important key concerns are application domain or software architecture specific. Therefore, we argue that in order to provide better infrastructural support, the infrastructure must take into account this architectural correlation. The infrastructure must provide explicit support for describing and enforcing implicit application information, that is specific to the software architecture.", "num_citations": "1\n", "authors": ["328"]}
{"title": "Implementing secure distributed computing with mobile agents\n", "abstract": " Secure distributed computing addresses the problem of performing a computation with a number of mutually distrustful participants, in such a way that each of the participants has only limited access to the information needed for doing the computation. Over the past two decades, a number of solutions requiring no trusted third party have been developed using cryptographic techniques. The disadvantage of these cryptographic solutions is the excessive communication overhead they incur.In this paper, we use mobile agents employing these cryptographic techniques to provide for a trade-off between communication overhead and trust. We solve the communication overhead problem by using mobile agents to execute the cryptographic protocols and running these agents on hosts that are close to each other. Of course, a mobile agent needs to trust his execution platform, but we show that the trust requirements in this case are much lower than for a classical trusted third party. As a practical case study, we look at the implementation of a second price auction.", "num_citations": "1\n", "authors": ["328"]}
{"title": "A caller-side inline reference monitor for object-oriented intermediate language: Extended version\n", "abstract": " Runtime security policy enforcement systems are crucial to limit the risks associated with running untrustworthy (malicious or buggy) code. The inlined reference monitor approach to policy enforcement, pioneered by Erlingsson and Schneider, implements runtime enforcement through program rewriting: security checks are inserted inside untrusted programs. Ensuring complete mediation-the guarantee that e v ery securityrele v ant e v ent is actually intercepted by the monitor-is non-triv ial when the program rewriter operates on an ob j ect-oriented intermediate language with state-of-the-art features such as v irtual methods and delegates. This paper proposes a caller-side rewriting algorithm for M S IL-the bytecode of the. N ET v irtual machine-where security checks are inserted around calls to security-rele v ant methods. W e pro v e that this algorithm achie v es sound and complete mediation and transparency for a\u00a0\u2026", "num_citations": "1\n", "authors": ["328"]}