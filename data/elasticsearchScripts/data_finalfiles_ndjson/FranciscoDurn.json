{"title": "Maude as a formal meta-tool\n", "abstract": " Given the different perspectives from which a complex software system has to be analyzed, the multiplicity of formalisms is unavoidable. This poses two important technical challenges: how to rigorously meet the need to interrelate formalisms, and how to reduce the duplication of effort in tool and specification building across formalisms. These challenges could be answered by adequate formal meta-tools that, when given the specification of a formal inference system, generate an efficient inference engine, and when given a specification of two formalisms and a translation, generate an actual translator between them. Similarly, module composition operations that are logic-independent, but that at present require costly implementation efforts for each formalism, could be provided for logics in general by module algebra generator meta-tools. The foundations of meta-tools of this kind can be based on a\u00a0\u2026", "num_citations": "114\n", "authors": ["1800"]}
{"title": "Building equational proving tools by reflection in rewriting logic\n", "abstract": " Publisher SummaryThis chapter explains the design and use of two proving tools such as inductive theorem prover and a Church-Rosser checker. It uses these tools to prove theorems about equational specifications with initial algebra semantics and to check whether such specifications satisfy the Church-Rosser property. These tools have been developed as part of the Cafe project, and can also be used on their own to prove properties of equational specifications in Maude. An important feature of these tools is that they are written entirely in Maude and are in fact executable specifications in rewriting logic of the formal inference systems that they implement. This chapter also gives a brief review of membership equational logic, rewriting logic, and Maude, including reflective features and the related topic of strategies. After summarizing the reflective design of the tools, the chapter explains each of the tools\u00a0\u2026", "num_citations": "113\n", "authors": ["1800"]}
{"title": "Formal and Tool Support for Model Driven Engineering with Maude\n", "abstract": " Models and metamodels play a cornerstone role in Model-Driven Software Development. Although several notations have been proposed to specify them, the kind of formal and tool support they provide is quite limited. In this paper we explore the use of Maude as a formal notation for describing models and metamodels. Maude is an executable rewriting logic language specially well suited for the specification of object-oriented open and distributed systems. We show how Maude offers a simple, natural, and accurate way of specifying models and metamodels, and offers good tool support for reasoning about them. In particular, we show how some basic operations on models, such as model subtyping, type inference, and metric evaluation, can be easily specified and implemented in Maude, and made available in development environments such as Eclipse.", "num_citations": "107\n", "authors": ["1800"]}
{"title": "Proving operational termination of membership equational programs\n", "abstract": " Reasoning about the termination of equational programs in sophisticated equational languages such as Elan, Maude, OBJ, CafeOBJ, Haskell, and so on, requires support for advanced features such as evaluation strategies, rewriting modulo, use of extra variables in conditions, partiality, and expressive type systems (possibly including polymorphism and higher-order). However, many of those features are, at best, only partially supported by current term rewriting termination tools (for instance mu-term, C                         i                         ME, AProVE, TTT, Termptation, etc.) while they may be essential to ensure termination. We present a sequence of theory transformations that can be used to bridge the gap between expressive membership equational programs and such termination tools, and prove the correctness of such transformations. We also discuss a prototype tool performing the transformations on Maude\u00a0\u2026", "num_citations": "101\n", "authors": ["1800"]}
{"title": "Programaci\u00f3n orientada a objetos con Java\n", "abstract": " Reservados los derechos para todos los pa\u00edses de lengua espa\u00f1ola. De conformidad con lo dispuesto en el art\u00edculo 270 del C\u00f3digo Penal vigente, podr\u00e1n ser castigados con penas de multa y privaci\u00f3n de libertad quienes reprodujeren o plagiaren, en todo o en parte, una obra literaria, art\u00edstica o cient\u00edfica fijada en cualquier tipo de soporte sin la preceptiva autorizaci\u00f3n. Ninguna parte de esta publicaci\u00f3n, incluido el dise\u00f1o de la cubierta, puede ser reproducida, almacenada o transmitida de ninguna forma, ni por ning\u00fan medio, sea \u00e9ste electr\u00f3nico, qu\u00edmico, mec\u00e1nico, electro-\u00f3ptico, grabaci\u00f3n, fotocopia o cualquier otro, sin la previa autorizaci\u00f3n escrita por parte de la Editorial..", "num_citations": "76\n", "authors": ["1800"]}
{"title": "On the Church-Rosser and coherence properties of conditional order-sorted rewrite theories\n", "abstract": " In the effort to bring rewriting-based methods into contact with practical applications both in programing and in formal verification, there is a tension between:(i) expressiveness and generality\u2014so that a wide range of applications can be expressed easily and naturally\u2014and (ii) support for formal verification, which is harder to get for general and expressive specifications. This paper answers the challenge of successfully negotiating the tension between goals (i) and (ii) for a wide class of Maude specifications, namely:(a) equational order-sorted conditional specifications (\u03a3, E\u222a A), corresponding to functional programs modulo axioms such as associativity and/or commutativity and/or identity axioms and (b) order-sorted conditional rewrite theories R=(\u03a3, E\u222a A, R, \u03d5), corresponding to concurrent programs modulo axioms A. For Maude functional programs the key formal property checked is the Church-Rosser property\u00a0\u2026", "num_citations": "72\n", "authors": ["1800"]}
{"title": "A Church-Rosser checker tool for conditional order-sorted equational Maude specifications\n", "abstract": " The Church-Rosser property, together with termination, is essential for an equational specification to have good executability conditions, and also for having a complete agreement between the specification\u2019s initial algebra, mathematical semantics, and its operational semantics by rewriting. Checking this property for expressive specifications that are order-sorted, conditional with possibly extra variables in their condition, and whose equations can be applied modulo different combinations of associativity, commutativity and identity axioms is challenging. In particular, the resulting conditional critical pairs that cannot be joined have often an intuitively unsatisfiable condition or seem intuitively joinable, so that sophisticated tool support is needed to eliminate them. Another challenge is the presence of different combinations of associativity, commutativity and identity axioms, including the very challenging case of\u00a0\u2026", "num_citations": "66\n", "authors": ["1800"]}
{"title": "MTT: The Maude termination tool (system description)\n", "abstract": " Despite the remarkable development of the theory of termination of rewriting, its application to high-level programming languages is far from being optimal. This is due to the need for features such as conditional equations and rules, types and subtypes, (possibly programmable) strategies for controlling the execution, matching modulo axioms, and so on, that are used in many programs and tend to place such programs outside the scope of current termination tools.The operational meaning of such features is often formalized in a proof-theoretic manner by means of an inference system (see, e.g., [2, 3, 17]) rather than just by a rewriting relation. In particular, Generalized Rewrite Theories (GRT) [3] are a recent generalization of rewrite theories at the heart of the most recent formulation of Maude [4].", "num_citations": "65\n", "authors": ["1800"]}
{"title": "Proving termination of membership equational programs\n", "abstract": " Advanced typing, matching, and evaluation strategy features, as well as very general conditional rules, are routinely used in equational programming languages such as, for example, ASF+ SDF, OBJ, CafeOBJ, Maude, and equational subsets of ELAN and CASL. Proving termination of equational programs having such expressive features is important but nontrivial, because some of those features may not be supported by standard termination methods and tools, such as muterm, CiME, AProVE, TTT, Termptation, etc. Yet, use of the features may be essential to ensure termination. We present a sequence of theory transformations that can be used to bridge the gap between expressive equational programs and termination tools, prove the correctness of such transformations, and discuss a prototype tool performing the transformations on Maude equational programs and sending the resulting transformed theories to\u00a0\u2026", "num_citations": "62\n", "authors": ["1800"]}
{"title": "The Maude formal tool environment\n", "abstract": " This paper describes the main features of several tools concerned with the analysis of either Maude specifications, or of extensions of such specifications: the ITP, MTT, CRC, ChC, and SCC tools, and Real-Time Maude for real-time systems. These tools, together with Maude itself and its searching and model-checking capabilities, constitute Maude\u2019s formal environment.", "num_citations": "61\n", "authors": ["1800"]}
{"title": "Termination modulo combinations of equational theories\n", "abstract": " Rewriting with rules R modulo axioms E is a widely used technique in both rule-based programming languages and in automated deduction. Termination methods for rewriting systems modulo specific axioms E (e.g., associativity-commutativity) are known. However, much less seems to be known about termination methods that can be modular in the set E of axioms. In fact, current termination tools and proof methods cannot be applied to commonly occurring combinations of axioms that fall outside their scope. This work proposes a modular termination proof method based on semantics- and termination-preserving transformations that can reduce the proof of termination of rules R modulo E to an equivalent proof of termination of the transformed rules modulo a typically much simpler set B of axioms. Our method is based on the notion of variants of a term recently proposed by Comon and Delaune. We\u00a0\u2026", "num_citations": "49\n", "authors": ["1800"]}
{"title": "An extensible module algebra for Maude\n", "abstract": " The fact that rewriting logic and Maude are reflective, so that rewriting logic specifications can be manipulated as terms at the metalevel, opens up the possibility of defining an algebra of module composition and transformation operations within the logic. This makes such a module algebra easily modifiable and extensible, enables the implementation of language extensions within Maude, and allows formal reasoning about the module operations themselves. In this paper we discuss in detail the Maude implementation of a specific choice of operations for a module algebra of this type, supporting module operations in the Clear/OBJ tradition as well as the transformation of object-oriented modules into system modules.", "num_citations": "49\n", "authors": ["1800"]}
{"title": "Maude\u2019s module algebra\n", "abstract": " The reflective capabilities of rewriting logic and their efficient implementation in the Maude language can be exploited to endow a reflective language like Maude with a module algebra in which structured theories can be combined and transformed by means of a rich collection of module operations. We have followed this approach and have used the specification of such a module algebra as its implementation, including a user interface and an execution environment for it. The high level at which the specification of the module algebra has been given makes this approach particularly attractive when compared to conventional implementations, because of its shorter development time and the greater flexibility, maintainability, and extensibility that it affords. We explain the general principles of the reflective design of the module algebra and its categorical foundations, based on the institution-theoretic notion of\u00a0\u2026", "num_citations": "44\n", "authors": ["1800"]}
{"title": "A Maude coherence checker tool for conditional order-sorted rewrite theories\n", "abstract": " For a rewrite theory to be executable, its equations E should be (ground) confluent and terminating modulo the given axioms A, and their rules should be (ground) coherent with E modulo A. The correctness of many important formal verification tasks, including search, LTL model checking, and the development of abstractions, crucially depends on the theory being ground coherent. Furthermore, many specifications of interest are typed, have equations E and rules R that are both conditional, have axioms A involving various combinations of associativity, commutativity and identity, and may contain frozenness restrictions. This makes it essential to extend the known coherence checking methods from the untyped, unconditional, and AC or free case, to this much more general setting. We present the mathematical foundations of the Maude ChC 3 tool, which provide such a generalization to support coherence\u00a0\u2026", "num_citations": "42\n", "authors": ["1800"]}
{"title": "The Maude specification of Full Maude\n", "abstract": " This document describes the executable formal specification of Full Maude--a version of Maude supporting a rich module algebra with module hierarchies, parameterization, views, theories, module expressions, and object-oriented modules--which is in fact its implementation in the Maude 1.00 system", "num_citations": "35\n", "authors": ["1800"]}
{"title": "Parameterized Theories and Views in Full Maude 2.0\n", "abstract": " Parameterized specification and programming is a key modularity and reusability technique crucial for managing the complexity of large specifications and programs. In the search for ever more powerful parameterized module composition operations, languages in the Clear/OBJ tradition, including OBJ3, CafeOBJ, and Maude, have used categorical constructions involving three key notions: (i) modules, which are theories with an initial or, more generally, free extension semantics; (ii) theories, with a loose semantics; and (iii) views, which are theory interpretations used to instantiate parameter theories, and to assert formal properties. It has for long been understood that the full generality and power of a module algebra based on these notions requires parameterized theories and views, not just parameterized modules. However, at present, none of the above-mentioned language implementations supports\u00a0\u2026", "num_citations": "34\n", "authors": ["1800"]}
{"title": "Dynamic validation of OCL constraints with mOdCL\n", "abstract": " This paper presents mOdCL, a Maude based evaluator of OCL expressions and validator of OCL constraints. Given its OCL expression evaluator, the use of execution strategies allows mOdCL, not only validating invariant constraints on concrete system states, but also dynamically validating invariants and pre-and post-conditions on the successive states obtained during system execution.", "num_citations": "33\n", "authors": ["1800"]}
{"title": "A Church-Rosser checker tool for Maude equational specifications\n", "abstract": " This document explains the design and use of a Church-Rosser checker tool, which checks whether an equational specification satisfies the Church-Rosser property. This tool can be used to prove the Church-Rosser property of order-sorted equational specifications in Maude [12, 8, 6]. The tool has been written entirely in Maude and is in fact an executable specification in rewriting logic [29] of the formal inference system that it implements. The fact that rewriting logic is reflective [13, 5], and that Maude efficiently supports reective rewriting logic computations [7, 6] is systematically exploited in the design of the tool.", "num_citations": "33\n", "authors": ["1800"]}
{"title": "Bidimensional cross-cloud management with TOSCA and Brooklyn\n", "abstract": " The diversity in the way different cloud providers offer their services, give their SLAs, present their QoS, support different technologies, etc., complicates the portability and interoperability of cloud applications, and favors vendor lockin. Standards like TOSCA, and tools supporting them, have come to help in the provider-independent description of cloud applications. After the variety of proposed cross-cloud application management tools, we propose going one step further in the unification of cloud services with a deployment tool in which IaaS and PaaS services are integrated into a unified interface. We provide support for applications whose components are to be deployed on different providers, indistinctly using IaaS and PaaS services. The TOSCA standard is used to define a portable model describing the topology of the cloud applications and the required resources in an agnostic, and providers- and resources\u00a0\u2026", "num_citations": "32\n", "authors": ["1800"]}
{"title": "Adaptive management of applications across multiple clouds: The SeaClouds Approach\n", "abstract": " Uno de los problemas que han emergido con el auge de la computaci\u00f3n en la nube (cloud computing), es todo aquello relacionado con el despliegue y la gesti\u00f3n, de manera eficiente y adaptativa, de aplicaciones complejas sobre m\u00f3ltiples plataformas cloud heterog\u00e9neas. En este art\u00edculo, presentamos el contexto, motivaciones y objetivos del proyecto de investigaci\u00f3n Europeo SeaClouds, que se centra en permitir una gesti\u00f3n fluida y adaptativa de los m\u00f3dulos de una aplicaci\u00f3n sobre m\u00faltiples plataformas cloud heterog\u00e9neas. Tras posicionar SeaClouds con respecto a iniciativas cloud relacionadas, presentamos la arquitectura de SeaClouds y discutimos algunos de sus aspectos, tales como el uso del estandar de OASIS, TOSCA, y la compatibilidad con la iniciativa tambi\u00e9n de OASIS, CAMP.", "num_citations": "32\n", "authors": ["1800"]}
{"title": "A generic framework for n-protocol compatibility checking\n", "abstract": " Abstract Service-Oriented Computing promotes the development of new systems from existing services which are usually accessed through their public interfaces. In this context, interfaces must be compatible in order to avoid interoperability issues. In this article, we propose a new framework for checking the compatibility of n service interfaces. Our framework is generic, in the sense that it implements several compatibility notions useful for different application areas, and extensible since new further notions can easily be incorporated. We consider a service interface model which takes behavioural descriptions with value-passing and non-observable actions into account. Our compatibility checking framework has been fully implemented into a prototype tool which relies on the rewriting logic-based system Maude.", "num_citations": "29\n", "authors": ["1800"]}
{"title": "Programming and symbolic computation in Maude\n", "abstract": " Rewriting logic is both a flexible semantic framework within which widely different concurrent systems can be naturally specified and a logical framework in which widely different logics can be specified. Maude programs are exactly rewrite theories. Maude has also a formal environment of verification tools. Symbolic computation is a powerful technique for reasoning about the correctness of concurrent systems and for increasing the power of formal tools. We present several new symbolic features of Maude that enhance formal reasoning about Maude programs and the effectiveness of formal tools. They include: (i) very general unification modulo user-definable equational theories, and (ii) symbolic reachability analysis of concurrent systems using narrowing. The paper does not focus just on symbolic features: it also describes several other new Maude features, including: (iii) Maude's strategy language for controlling\u00a0\u2026", "num_citations": "28\n", "authors": ["1800"]}
{"title": "Structured theories and institutions\n", "abstract": " Category theory provides an excellent foundation for studying structured specifications and their composition. For example, theories can be structured together in a diagram, and their composition can be obtained as a colimit. There is, however, a growing awareness, both in theory and in practice, that structured theories should not be viewed just as the \u201cscaffolding\u201d used to build unstructured theories: they should become first\ue4f8class citizens in the specification process. Given a logic formalized as an institution I, we therefore ask whether there is a good definition of the category of structured I-theories, and whether they can be naturally regarded as the ordinary theories of an appropriate institution S(I) generalizing the original institution I. We answer both questions in the affirmative, and study good properties of the institution I inherited by S(I). We show that, under natural conditions, a number of important properties\u00a0\u2026", "num_citations": "28\n", "authors": ["1800"]}
{"title": "Trans-cloud: CAMP/TOSCA-based bidimensional cross-cloud\n", "abstract": " The diversity in the way in which different cloud providers offer their services, give their SLAs, present their QoS, or support different technologies complicates the portability and interoperability of cloud applications, and favors vendor lock-in. Trying to solve these issues, we have recently witnessed the proposal of unified APIs for IaaS services, unified APIs for PaaS services, and a variety of cross-cloud application management tools. We go one step further in the unification of cloud services, building on the TOSCA and CAMP standards, with a proposal in which the management of IaaS and PaaS services, possibly offered by different providers, are integrated into a unified interface. The TOSCA standard is used for the definition of portable models describing the topology of cloud applications and the required resources in an agnostic, providers-and-resources-independent way. Based on the CAMP standard, we\u00a0\u2026", "num_citations": "27\n", "authors": ["1800"]}
{"title": "Robust and reliable reconfiguration of cloud applications\n", "abstract": " Cloud applications involve a set of interconnected software components running on remote virtual machines. The deployment and dynamic reconfiguration of cloud applications, involving the addition/removal of virtual machines and components hosted on these virtual machines, are error-prone tasks. They must preserve the application consistency and respect important architectural invariants related to software dependencies. In this paper, we introduce a protocol for automating these reconfiguration tasks. In order to ensure its correctness and robustness, we implement the protocol with the support of the Maude system for rapid prototyping purposes, and we verify it with its formal analysis tools.", "num_citations": "27\n", "authors": ["1800"]}
{"title": "Variants, unification, narrowing, and symbolic reachability in Maude 2.6\n", "abstract": " This paper introduces some novel features of Maude 2.6 focusing on the variants of a term. Given an equational theory (Sigma, Ax cup E), the E, Ax-variants of a term t are understood as the set of all pairs consisting of a substitution sigma and the E, Ax-canonical form of t sigma. The equational theory (Ax cup E) has the finite variant property if there is a finite set of most general variants. We have added support in Maude 2.6 for:(i) order-sorted unification modulo associativity, commutativity and identity,(ii) variant generation,(iii) order-sorted unification modulo finite variant theories, and (iv) narrowing-based symbolic reachability modulo finite variant theories. We also explain how these features have a number of interesting applications in areas such as unification theory, cryptographic protocol verification, business processes, and proofs of termination, confluence and coherence.", "num_citations": "25\n", "authors": ["1800"]}
{"title": "Coherence checker and completion tools for Maude specifications\n", "abstract": " This document explains the design and use of a coherence checker tool and of a coherence completion tool. The coherence checker tool checks whether a rewrite logic specification is coherent, and the coherence completion tool tries to complete a rewrite logic specification in order to make it coherent. These tools can be used to prove the coherence property or to coherence complete order-sorted rewrite specifications in Maude [7, 5, 2]. The tools have been written entirely in Maude and are in fact executable specifications in rewriting logic [14] of the formal inference system that they implement. The fact that rewriting logic is reflective [8, 1], and that Maude efficiently supports reflective rewriting logic computations [3, 2] is systematically exploited in the design of the tools.", "num_citations": "25\n", "authors": ["1800"]}
{"title": "Structured theories and institutions\n", "abstract": " Category theory provides an excellent foundation for studying structured specifications and their composition. For example, theories can be structured together in a diagram, and their composition can be obtained as a colimit. There is, however, a growing awareness, both in theory and in practice, that structured theories should not be viewed just as the \u201cscaffolding\u201d used to build unstructured theories: they should become first-class citizens in the specification process. Given a logic formalized as an institution I, we therefore ask whether there is a good definition of the category of structured I-theories, and whether they can be naturally regarded as the ordinary theories of an appropriate institution S (I) generalizing the original institution I. We answer both questions in the affirmative, and study good properties of the institution I inherited by S (I). We show that, under natural conditions, a number of important properties\u00a0\u2026", "num_citations": "24\n", "authors": ["1800"]}
{"title": "The extensibility of Maude\u2019s module algebra\n", "abstract": " The reflective capabilities of rewriting logic and their efficient implementation in the Maude language can be exploited to endow a reflective language like Maude with a module algebra in which structured modules can be combined and transformed by means of a rich collection of module operations. We have followed this approach to use the specification of such a module algebra as its implementation, including a user interface and an execution environment for it. The high level at which the specification of the module algebra has been given makes this approach particularly attractive when compared to conventional implementations, because of its shorter development time and the greater flexibility, maintainability, and extensibility that it affords. We explain the general principles of the reflective design of the module algebra, focusing in its extensibility, and illustrate some of the possibilities for defining\u00a0\u2026", "num_citations": "23\n", "authors": ["1800"]}
{"title": "Termination checker and Knuth-Bendix completion tools for Maude equational specifications\n", "abstract": " This document explains the design and use of a termination checker tool and of a Knuth-Bendix completion tool. The termination checker tool checks whether an equational specication terminates, and the Knuth-Bendix completion tool tries to complete an equational speci-cation. These tools can be used to prove the termination or to complete order-sorted equational specications in Maude [7, 6, 4]. The tools have been written entirely in Maude and are in fact executable specications in rewriting logic [17] of the formal inference system that they implement. The fact that rewriting logic is reective [8, 3], and that Maude eciently supports reective rewriting logic computations [5, 4] is systematically exploited in the design of the tools. Contents 1", "num_citations": "23\n", "authors": ["1800"]}
{"title": "Associative unification and symbolic reasoning modulo associativity in Maude\n", "abstract": " We have added support for associative unification to Maude\u00a02.7.1. Associative unification is infinitary, i.e., there are unification problems  such that there is an infinite minimal set of unifiers, whereas associative-commutative unification is finitary. A unique feature of the associative unification algorithm implemented in Maude is that it is guaranteed to terminate with a finite and complete set of associative unifiers for a fairly large class of unification problems occurring in practice. For any problems outside this class, the algorithm returns a finite set of unifiers together with a warning that such set may be incomplete. This paper describes this associative unification algorithm implemented in Maude and also how other symbolic reasoning Maude features such as (i) variant generation; (ii) variant unification; and (iii) narrowing based symbolic reachability analysis have been extended to deal with associativity.", "num_citations": "22\n", "authors": ["1800"]}
{"title": "Towards a Maude formal environment\n", "abstract": " Maude is a declarative and reflective language based on rewriting logic in which computation corresponds to efficient deduction by rewriting. Because of its reflective capabilities, Maude has been useful as a metatool in the development of formal analysis tools for checking specific properties of Maude specifications. This includes tools for checking termination, confluence, and inductive properties of rewrite theories. Nevertheless, most of these tools have been designed to work in isolation, making it difficult, for instance, to exchange data between them and inconvenient to switch between their environments. This paper presents the Maude Formal Environment (MFE), an executable formal specification in Maude within which a user can interact with tools to mechanically verify properties of Maude specifications. One important aspect of this work is that the MFE has been designed to be easily extended with\u00a0\u2026", "num_citations": "22\n", "authors": ["1800"]}
{"title": "On the reusable specification of non-functional properties in DSLs\n", "abstract": " Domain-specific languages (DSLs) are an important tool for effective system development. They provide concepts that are close to the problem domain and allow analysis as well as generation of full solution implementations. However, this comes at the cost of having to develop a new language for every new domain. To make their development efficient, we must be able to construct DSLs as much as possible from reusable building blocks. In this paper, we discuss how such building blocks can be constructed for the specification and analysis of a range of non-functional properties, such as, for example, throughput, response time, or reliability properties. We assume DSL semantics to be provided through a set of transformation rules, which enables a range of analyses based on model checking. We demonstrate new concepts for defining language modules for the specification of non-functional properties\u00a0\u2026", "num_citations": "21\n", "authors": ["1800"]}
{"title": "Checking protocol compatibility using Maude\n", "abstract": " Checking compatibility of services accessed through their behavioural interfaces is a crucial issue in Service Oriented Computing which aims at building new systems from existing software services. In this paper, we consider a model of services which takes value passing and non-observable actions into account. We propose an approach to check in a unified way several compatibility notions between two service protocols using the rewriting logic system Maude. In particular, we illustrate our approach with three widely used compatibility notions, namely opposite behaviours, unspecified receptions and deadlock freeness. These notions as well as several strategies to handle non-observable actions have been formalised and fully implemented into a prototype tool which is able to automatically detect whether two services are compatible, and return a counterexample if they are not.", "num_citations": "20\n", "authors": ["1800"]}
{"title": "Built-in variant generation and unification, and their applications in Maude 2.7\n", "abstract": " This paper introduces some novel features of Maude 2.7. We have added support for: (i) built-in order-sorted unification modulo associativity, commutativity, and identity, (ii) built-in variant generation, (iii) built-in order-sorted unification modulo a finite variant theory, and (iv) symbolic reachability modulo a finite variant theory.", "num_citations": "19\n", "authors": ["1800"]}
{"title": "Modular DSLs for flexible analysis: An e-Motions reimplementation of Palladio\n", "abstract": " We address some of the limitations for extending and validating MDE-based implementations of NFP analysis tools by presenting a modular, model-based partial reimplementation of one well-known analysis framework, namely the Palladio Architecture Simulator. We specify the key DSLs from Palladio in the e-Motions system, describing the basic simulation semantics as a set of graph transformation rules. Different properties to be analysed are then encoded as separate, parametrised DSLs, independent of the definition of Palladio. These can then be composed with the base Palladio DSL to generate specific simulation environments. Models created in the Palladio IDE can be fed directly into this simulation environment for analysis. We demonstrate two main benefits of our approach: 1) The semantics of the simulation and the non-functional properties to be analysed are made explicit in the respective\u00a0\u2026", "num_citations": "19\n", "authors": ["1800"]}
{"title": "A guide to extending Full Maude illustrated with the implementation of Real-Time Maude\n", "abstract": " The goal of this paper is to serve as a practical guide for implementing extensions of Maude by giving an overview of how the Real-Time Maude tool has been developed by extending the implementation of Full Maude. After giving a high-level summary of the key functionality and structure of the implementation of Full Maude, we describe the implementation of the Real-Time Maude language and tool. This extension includes key issues such as adding new kinds of modules, rules, and commands; as well as the need to store additional information in the persistent state of the execution environment.", "num_citations": "19\n", "authors": ["1800"]}
{"title": "Using Maude\n", "abstract": " Maude is a wide-spectrum reflective logical language based on rewriting logic [7] that can be used to specify, prototype, and formally analyze concurrent soft- ware systems, specification languages, logics, and theorem provers. Because of its efficient implementation, it can also be used as a programming language and as a meta-tool to generate other tools. This paper gives a brief introduction to the language and illustrates with examples some of the features of the current version, available free of charge together with examples, documentation, and papers from SRI: see http://maude.csl.sri.com. The key characteristics of Maude can be summarized as follows:                                         \u2014                                                                      Based on rewriting logic. This makes it particularly well suited to express concurrent and state-changing aspects of systems declaratively\u00a0\u2026", "num_citations": "19\n", "authors": ["1800"]}
{"title": "A distributed implementation of Mobile Maude\n", "abstract": " We present a new specification/implementation of the mobile agent language Mobile Maude. This new version uses the external sockets provided by Maude since its 2.2 version, thus obtaining a really distributed implementation of the mobile language, where messages and mobile objects now may travel from one machine to another one in a transparent way. We also show how, even though the complexity of the Mobile Maude specification and the use of reflection, we have managed to use the Maude's model checker to prove properties about mobile agents applications.", "num_citations": "18\n", "authors": ["1800"]}
{"title": "New evaluation commands for Maude within Full Maude\n", "abstract": " Maude is able to deal with infinite data structures and avoid infinite computations by using strategy annotations. However, they can eventually make the computation of the normal form(s) of some input expressions impossible. We have used Full Maude to implement two new commands norm and eval which furnish Maude with the ability to compute (constructor) normal forms of initial expressions even when the use of strategy annotations together with the built-in computation strategy of Maude is not able to obtain them. These commands have been integrated into Full Maude, making them available inside the programming environment like any other of its commands.", "num_citations": "18\n", "authors": ["1800"]}
{"title": "Stochastic analysis of BPMN with time in rewriting logic\n", "abstract": " A business process is a set of structured activities that provide a certain service or product. Business processes can be modeled using the BPMN standard, and several industrial platforms have been developed for supporting their design, modeling, and simulation. This paper presents a rewriting logic executable specification of BPMN with time and extended with probabilities. Duration times and delays for tasks and flows can be specified as stochastic expressions, while probabilities are associated to various forms of branching behavior in gateways. These quantities enable discrete-event simulation and automatic stochastic verification of properties such as expected processing time, expected synchronization time at merge gateways, and domain-specific quantitative assertions. The mechanization of the stochastic analysis tasks is done with Maude's statistical model checker PVeStA. The approach is illustrated with\u00a0\u2026", "num_citations": "16\n", "authors": ["1800"]}
{"title": "Amalgamation of domain specific languages with behaviour\n", "abstract": " Domain-specific languages (DSLs) become more useful the more specific they are to a particular domain. The resulting need for developing a substantial number of DSLs can only be satisfied if DSL development can be made as efficient as possible. One way in which to address this challenge is by enabling the reuse of (partial) DSLs in the construction of new DSLs. Reuse of DSLs builds on two foundations: a notion of DSL composition and theoretical results ensuring the safeness of composing DSLs with respect to the semantics of the component DSLs.Given a graph-grammar formalisation of DSLs, in this paper, we build on graph transformation system morphisms to define parameterised DSLs and their instantiation by an amalgamation construction. Results on the protection of the behaviour along the induced morphisms allow us to safely reuse and combine definitions of DSLs to build more complex ones. We\u00a0\u2026", "num_citations": "16\n", "authors": ["1800"]}
{"title": "Polytypic programming in Maude\n", "abstract": " The idea of polytypic programming is to write programs that are defined by induction on the structure of user-defined datatypes. In this way, many functions with similar functionalities do not have to be written over and over again for different datatypes. So far, this programming style has been developed in functional languages like Haskell, extended with new syntactic constructs for defining polytypic programs. In this paper we show that polytypic programming can be reduced to metaprogramming, and that can be developed in a reflective first-order language like Maude, without having to extend the language. This has the additional advantage of allowing us to use standard formal tools to prove properties about polytypic programs. We illustrate our methodology via examples. In particular, we explain how to define in Maude two non-trivial generic functions, namely, the polytypic versions of the functions map, and cata\u00a0\u2026", "num_citations": "16\n", "authors": ["1800"]}
{"title": "Verifying timed BPMN processes using Maude\n", "abstract": " A business process is a collection of structured activities producing a particular product or software. BPMN is a workflow-based graphical notation for specifying business processes. Formally analyzing such processes is a crucial challenge in order to avoid erroneous executions of the corresponding software. In this paper, we focus on timed business processes where execution time can be associated to several BPMN constructs. We propose an encoding of timed business processes into the Maude language, which allows one to automatically verify several properties of interest on processes such as the maximum/minimum/average execution time or the timed degree of parallelism that provides a valuable guide for the problem of resource allocation. The analysis is achieved using the rewriting-based tools available in Maude, which also provides other techniques (e.g., reachability analysis and model\u00a0\u2026", "num_citations": "14\n", "authors": ["1800"]}
{"title": "Tracing properties of UML and OCL models with maude\n", "abstract": " The starting point of this paper is a system described in form of a UML class diagram where system states are characterized by OCL invariants and system transitions are defined by OCL pre- and postconditions. The aim of our approach is to assist the developer in learning about the consequences of the described system states and transitions and about the formal implications of the properties that are explicitly given. We propose to draw conclusions about the stated constraints by translating the UML and OCL model into the algebraic specification language and system Maude, which is based on rewrite logic. We will concentrate in this paper on employing Maude's capabilities for state search. Maude's state search offers the possibility to describe a start configuration of the system and then explore all configurations reachable by rewriting. The search can be adjusted by formulating requirements for the allowed states and the allowed transitions.", "num_citations": "14\n", "authors": ["1800"]}
{"title": "On-demand evaluation for Maude\n", "abstract": " Strategy annotations provide a simple mechanism for introducing some laziness in the evaluation of expressions. As an eager programming language, Maude can take advantage of them and, in fact, they are part of the language. Maude strategy annotations are lists of non-negative integers associated to function symbols which specify the ordering in which the arguments are (eventually) evaluated in function calls. A positive index enables the evaluation of an argument whereas 'zero' means that the function call has to be attempted. The use of negative indices has been proposed to express evaluation on-demand, where the demand is an attempt to match an argument term with the left-hand side of a rewrite rule. In this paper we show how to furnish Maude with the ability of dealing with on-demand strategy annotations.", "num_citations": "13\n", "authors": ["1800"]}
{"title": "Executing multilevel domain-specific models in Maude\n", "abstract": " Multilevel modelling (MLM) tackles the limitation in the number of abstraction levels present in traditional modelling approaches within the model-driven software engineering (MDSE) field. One way to specify the behaviour description of MLMs is by means of multilevel model transformations. In this paper, we propose an approach to achieve reusability and flexibility in specifying and executing multilevel model transformations. For this purpose, we rely on code-generation and the efficient rewriting logic mechanisms that the Maude system provides. As a proof of concept, we have developed an infrastructure which combines our MLM tool MultEcore, that facilitates definition of MLM hierarchies and transformations, with Maude, which performs the execution of the transformations on these hierarchies.", "num_citations": "12\n", "authors": ["1800"]}
{"title": "Methods for proving termination of rewriting-based programming languages by transformation\n", "abstract": " Despite the remarkable development of the theory of termination of rewriting, its application to high-level (rewriting-based) programming languages is far from being optimal. This is due to the need for features such as conditional equations and rules, types and subtypes, (possibly programmable) strategies for controlling the execution, matching modulo axioms, and so on, that are used in many programs and tend to place such programs outside the scope of current termination tools. The operational meaning of such features is often formalized in a proof theoretic manner by means of an inference system rather than just by a rewriting relation. The corresponding termination notions can also differ from the standard ones. During the last years we have introduced and implemented different notions and transformation techniques which have been proved useful for proving and disproving termination of such programs by\u00a0\u2026", "num_citations": "12\n", "authors": ["1800"]}
{"title": "A conference reviewing system in Mobile Maude\n", "abstract": " A useful way of presenting a new language is by means of complete examples that show the language features in action. In this paper we do so for the Mobile Maude language, an extension of Maude that supports mobile computation. We implement an ambitious wide area application, namely a conference reviewing system, an example described by Cardelli as a challenge for any wide area language to demonstrate its usability.", "num_citations": "12\n", "authors": ["1800"]}
{"title": "Composing Model-Based Analysis Tools\n", "abstract": " Modelling and analysis are key to managing the increasing complexity and heterogeneity of today\u2019s software-intensive systems. Historically, different research communities have studied the modelling and analysis of different software quality properties (eg, performance or security) for different types of systems. As a result, the tools available for designing and maintaining software that meets such properties are also distinct, using different languages and techniques, making interaction difficult. This leads to a significant amount of unnecessary development work when building modern applications that must meet combinations of these properties\u2014for example, it may be necessary to construct redundant models in different formalisms and using different tools to support analyses for different quality properties. We, the editors of this book, have been working on modelling and analysing software-intensive systems for a\u00a0\u2026", "num_citations": "10\n", "authors": ["1800"]}
{"title": "Behaviour protection in modular rule-based system specifications\n", "abstract": " Model-driven engineering (MDE) and, in particular, the notion of domain-specific modelling languages (DSMLs) is an increasingly popular approach to systems development. DSMLs are particularly interesting because they allow encoding domain-knowledge into a modelling language and enable full code generation and analysis based on high-level models. However, as a result of the domain-specificity of DSMLs, there is a need for many such languages. This means that their use only becomes economically viable if the development of new DSMLs can be made efficient. One way to achieve this is by reusing functionality across DSMLs. On this background, we are working on techniques for modularising DSMLs into reusable units. Specifically, we focus on DSMLs whose semantics are defined through in-place model transformations. In this paper, we present a formal framework of morphisms between\u00a0\u2026", "num_citations": "10\n", "authors": ["1800"]}
{"title": "Tool interoperability in the Maude formal environment\n", "abstract": " We present the Maude Formal Environment (MFE), an executable formal specification in Maude within which a user can seamlessly interact with the Maude Termination Tool, the Maude Sufficient Completeness Checker, the Church-Rosser Checker, the Coherence Checker, and the Maude Inductive Theorem Prover. We explain the high-level design decisions behind MFE, give a summarized account of its main features, and illustrate with an example the interoperation of the tools available in its current release.", "num_citations": "9\n", "authors": ["1800"]}
{"title": "Statistical model checking of e-Motions domain-specific modeling languages\n", "abstract": " Domain experts may use novel tools that allow them to design and model their systems in a notation very close to the domain problem. However, the use of tools for the statistical analysis of stochastic systems requires software engineers to carefully specify such systems in low level and specific languages. In this work we line up both scenarios, specific domain modeling and statistical analysis. Specifically, we have extended the e-Motions system, a framework to develop real-time domain-specific languages where the behavior is specified in a natural way by in-place transformation rules, to support the statistical analysis of systems defined using it. We discuss how restricted e-Motions systems are used to produce Maude corresponding specifications, using a model transformation from e-Motions to Maude, which comply with the restrictions of the VeStA tool, and which can therefore be used to perform\u00a0\u2026", "num_citations": "8\n", "authors": ["1800"]}
{"title": "The rewrite engines competitions: A RECtrospective\n", "abstract": " Term rewriting is a simple, yet expressive model of computation, which finds direct applications in specification and programming languages (many of which embody rewrite rules, pattern matching, and abstract data types), but also indirect applications, e.g., to express the semantics of data types or concurrent processes, to specify program transformations, to perform computer-aided verification, etc. The Rewrite Engines Competition (REC) was created under the aegis of the Workshop on Rewriting Logic and its Applications (WRLA) to serve three main goals: (i) being a forum in which tool developers and potential users of term rewrite engines can share experience; (ii) bringing together the various language features and implementation techniques used for term rewriting; and (iii) comparing the available term rewriting languages and tools in their common features. The present article provides a retrospective overview of the four editions of the Rewrite Engines Competition (2008, 2010, and 2018) and traces their evolution over time.", "num_citations": "7\n", "authors": ["1800"]}
{"title": "Component-wise application migration in bidimensional cross-cloud environments\n", "abstract": " We propose an algorithm for the migration of cloud applications' components between different providers, possibly changing their service level between IaaS and PaaS. Our solution relies on three of the key ingredients of the trans-cloud approach: a unified API, agnostic topology descriptions, and mechanisms for the independent specification of providers. We show how our  approach allows us to overcome some of the current interoperability and portability issues of cloud environments to propose a solution for migration,  present an implementation of our proposed solution, and illustrate it with a case study and experimental results.", "num_citations": "7\n", "authors": ["1800"]}
{"title": "Live migration of trans-cloud applications\n", "abstract": " The development of applications independent of the cloud providers where they are going to be deployed is still an open issue. In fact, cloud agnostic software development presents important challenges to be solved. One of these issues is the runtime migration of components. Even more difficult is dealing with the interoperability issues when the migration also implies a change of provider or service level. This paper presents a solution for the component-wise migration of cloud applications. The migration is performed component-wise in the sense that each component of the application to be migrated, which may be deployed on a specific service on a specific provider, may individually be moved to a different one. Our solution relies on the three key ingredients of the trans-cloud approach, where the CAMP and TOSCA standards play a central role: A CAMP-based unified API, TOSCA-based agnostic topology\u00a0\u2026", "num_citations": "6\n", "authors": ["1800"]}
{"title": "Robust reconfiguration of cloud applications\n", "abstract": " Cloud applications involve a set of interconnected software components running on remote virtual machines. Once cloud applications are deployed, one may need to reconfigure them by adding/removing virtual machines or components hosted on these machines. These tasks are error-prone since they must preserve the application consistency and respect important architectural invariants related to software dependencies. We present in this paper a protocol for automating these reconfiguration tasks.", "num_citations": "6\n", "authors": ["1800"]}
{"title": "A rewriting logic approach to resource allocation analysis in business process models\n", "abstract": " This paper presents an approach for the modeling and analysis of resource allocation for business processes. It enables the automatic computation of measures for precisely identifying and optimizing the allocation of resources in business processes, including resource usage over time. The proposed analysis, especially suited to support decision-making strategies, is illustrated with a case study of a parcel ordering and delivery by drones that is developed throughout the paper. The paper comprises an encoding of a significant and expressive subset of the Business Process Model and Notation (BPMN) in rewriting logic, an executable logic of concurrent change that can naturally deal with state and with concurrent computations. The encoding is by itself a formal semantics and interpreter of the BPMN subset that captures all concurrent behavior and thus is used to simulate the concurrent evolution of any business\u00a0\u2026", "num_citations": "5\n", "authors": ["1800"]}
{"title": "Ground confluence of order-sorted conditional specifications modulo axioms\n", "abstract": " Terminating functional programs should be deterministic, i.e., should evaluate to a unique result, regardless of the evaluation order. For equational functional programs such determinism is exactly captured by the ground confluence property. For operationally terminating conditional equations this is equivalent to ground local confluence, which follows from local confluence. Checking local confluence by computing critical pairs is the standard way to check ground confluence [33]. The problem is that some perfectly reasonable equational programs are not locally confluent and it can be very hard or even impossible to make them so by adding more equations. We propose three methods, called Methods 1\u20133, that can be synergistically combined to prove an order-sorted conditional specification modulo axioms B ground locally confluent. Method 1 applies the strategy proposed in [14] to use non-joinable critical pairs as\u00a0\u2026", "num_citations": "4\n", "authors": ["1800"]}
{"title": "Symbolic specification and verification of data-aware BPMN processes using rewriting modulo SMT\n", "abstract": " The Business Process Model and Notation\u00a0() is the standard notation for modeling business processes. It relies on a workflow-based language that allows for the modeling of the control-flow graph of an entire process. In this paper, the main focus is on an extension of  with data, which is convenient for describing real-world processes involving complex behavior and data descriptions. By considering this level of expressiveness due to the new features, challenging questions arise regarding the choice of the semantic framework for specifying such an extension of , as well as how to carry out the symbolic simulation, validation, and correctness of the process models. These issues are addressed first by providing a symbolic executable rewriting logic semantics of  using the rewriting modulo SMT framework, where the execution is driven by rewriting modulo axioms and by querying\u00a0\u2026", "num_citations": "4\n", "authors": ["1800"]}
{"title": "Proving ground confluence of equational specifications modulo axioms\n", "abstract": " Terminating functional programs should be deterministic, i.e., should evaluate to a unique result, regardless of the evaluation order. For equational functional programs such determinism is exactly captured by the ground confluence property. For terminating equations this is equivalent to ground local confluence, which follows from local confluence. Checking local confluence by computing critical pairs is the standard way to check ground confluence. The problem is that some perfectly reasonable equational programs are not locally confluent and it can be very hard or even impossible to make them so by adding more equations. We propose a three-step strategy to prove that an equational program as is is ground confluent: First: apply the strategy proposed in\u00a0[9] to use non-joinable critical pairs as completion hints to either achieve local confluence or reduce the number of critical pairs. Second: use the\u00a0\u2026", "num_citations": "4\n", "authors": ["1800"]}
{"title": "Deployment over Heterogeneous Clouds with TOSCA and CAMP.\n", "abstract": " Cloud Computing providers offer diverse services and capabilities, which can be used by end-users to compose heterogeneous contexts of multiple cloud platforms to deploy their applications, in accordance with the best offered capabilities. However, this is an ideal scenario, since cloud platforms are being conducted in an isolated way by presenting interoperability and portability restrictions. Each provider defines its own API, non-functional requirements, QoS, add-ons, etc., and developers are often locked-in a concrete cloud environment, hampering the integration of heterogeneous provider services to achieve cross-deployment. This work presents an approach to deploy cross-cloud applications by using standardisation efforts of design, management and deployment of cloud applications. Specifically, using mechanisms specified by the TOSCA and CAMP standards, we propose a methodology to describe the topology and distribution of modules of a cloud application and to deploy the inter-connected modules over heterogeneous clouds. We present our prototype TOMAT, which supports the automatic distribution of cloud applications over multiple providers.", "num_citations": "4\n", "authors": ["1800"]}
{"title": "A formalization of the SMEPP model in Maude\n", "abstract": " This paper introduces a service-oriented model for the description of embedded Peer-to-Peer (EP2P) systems and formalizes the proposed model in Maude. The model is organized around the notions of groups of peers and services offered by these groups. We first summarize the main concepts of the model and then present \u03b1SMoL, an abstract language with a formal semantics that provides a solid ground to develop tools for the automated analysis and verification of EP2P specifications. We then describe a formalization of \u03b1SMoL in Maude, and introduce an example to illustrate both the expressive power of the model and the possibilities of Maude to support automated verification of properties of \u03b1SMoL programs.", "num_citations": "4\n", "authors": ["1800"]}
{"title": "Automated composition, analysis and deployment of IoT applications\n", "abstract": " Building IoT applications of added-value from a set of available devices with minimal human intervention is one of the main challenges facing the IoT. This is a difficult task that requires models for specifying objects, in addition to user-friendly and reliable composition techniques which in turn prevent the design of erroneous applications. In this work, we tackle this problem by first describing IoT applications using abstract models obtained from existing models of concrete devices. Then, we propose automated techniques for building compositions of devices using a repository of available devices, and an abstract goal of what the user expects from such compositions. Since the number of possible solutions can be quite high, we use both filtering and ranking techniques to provide the most pertinent solutions to users. The provided solutions satisfy the given goal and may be analysed with respect to properties\u00a0\u2026", "num_citations": "3\n", "authors": ["1800"]}
{"title": "Runtime migration of applications in a trans-cloud environment\n", "abstract": " Making an application independent of the cloud provider where it is going to be deployed is still an open issue. In fact, cloud agnostic software development still presents important challenges to be solved, and one of them is the problem of runtime migration of components already deployed on a given provider to a different one. Even more difficult is dealing with the interoperability issues when the migration also implies a change of service level (i.e., from IaaS to PaaS, or vice versa). This paper presents an algorithm for the parallel migration of cloud applications. The migration is performed component-wise, in the sense that each component of the application to be migrated may be deployed on a specific service on a specific provider, and be moved to a different provider, possibly changing the service level between IaaS and PaaS of each of them individually. Since the migration of components with state\u00a0\u2026", "num_citations": "3\n", "authors": ["1800"]}
{"title": "Towards the predictive analysis of cloud systems with e-Motions\n", "abstract": " Current methods for the predictive analysis of software systems are not directly applicable on self-adaptive systems as cloud systems, mainly due to their complexity and dynamism. To tackle the difficulties to handle the dynamic changes in the systems and their environments, we propose using graph transformation to define an adaptive com- ponent model and analysis tools for it, what allows us to carry on such analyses on dynamic architectures. Specifically, we use the e-Motions system to define the Palladio component model, and simulation-based analysis tools for it. Adaptation mechanisms are then specified as generic adaptation rules. This setting will allow us to study different mechanisms for the management of dynamic systems and their adaptation mechanisms, and different QoS metrics to be considered in a dynamic environment.", "num_citations": "3\n", "authors": ["1800"]}
{"title": "Operational termination in rewriting logic\n", "abstract": " A rewrite theory R contains both equations E and rewrite rules R. Both equations and rules are computed by rewriting (perhaps modulo some structural axions A). But the equations E and the rules R have a different mathematical and operational semantics. In particular, equations in E can be conditional, but their conditions can only involve other equational axioms. Instead, a condtional rule in R can have both equational conditions and non-equational rewrite conditions. This means that there are two different rewrite relations,\u2192 E and\u2192 R. It also means that termination may crucially depend on the distinction between\u2192 E and\u2192 R. For expressiveness reasons, besides coditional equations E and rules R, rewrite theories have other features, such as context-sensitive rewriting for E and R, sorts, subsorts, and membership predicates, and rewriting modulo axioms. All these features place rewite theories outside the\u00a0\u2026", "num_citations": "3\n", "authors": ["1800"]}
{"title": "Towards (constructor) normal forms for Maude within Full Maude\n", "abstract": " Maude is able to deal with infinite data structures and avoid infinite computations by using strategy annotations, that is, positive indices that indicate which positions can be evaluated. However, they can eventually make the computation of the normal form (s) of some input expressions impossible. In [6, 7], we used Full Maude to implement two new commands norm and eval which furnish Maude with the ability to compute (constructor) normal forms of initial expressions even when the use of strategy annotations together with the built-in computation strategy of Maude is not able to obtain them. These commands were integrated into Full Maude, making them available inside the programming environment like any other of its commands. Moreover, the type of annotations allowed was extended, giving to Maude the ability of dealing with on-demand strategy annotations, that is, negative indices that express evaluation on-demand, where the demand is a failed attempt to match an argument term with the left-hand side of a rewrite rule. In this paper, we recall these new commands and extensions.", "num_citations": "3\n", "authors": ["1800"]}
{"title": "A procedural and flexible approach for specification, modeling, definition, and analysis for self\u2010adaptive systems\n", "abstract": " An adaptive system can modify its settings at runtime as a response to changes in its operational environment. To analyse this kind of systems at design time is a difficult task since it requires considering the system together with the adaptation operations, and taking into account how such adaptations act on the system. In order to use simulation\u2010based techniques for the analysis of such systems, we not only need precise executable models of the systems to be analyzed, but also to capture the semantics of their adaptation mechanisms. Given the wide range and flexibility of adaptation operations, we need ways to allow the definition of new operations. We present a flexible approach for the definition and simulation\u2010based analysis in design\u2010time of adaptive component\u2010based systems. Our approach combines an extension of the Palladio component model in e\u2010Motions, a model of the adaptation mechanisms, and\u00a0\u2026", "num_citations": "2\n", "authors": ["1800"]}
{"title": "R-MOZART: A Reconfiguration Tool for WebThings Applications\n", "abstract": " The Internet of Things (IoT) is a network of physical devices and software entities that interact together for fulfilling an overall objective and thus providing added-value services. Designing such applications by selecting a set of candidate objects and defining how they interact with one another is a difficult and error-prone task. Moreover, IoT applications are not monolithic applications built once and for all. In contrast, they are constantly modified due to removal, replacement, or addition of new objects during the application\u2019s lifetime. In this paper, we present a tool built on top of the WebThings platform, which supports users when they want to dynamically change a running WebThings application. To do so, R-MOZART provides three components for (i) designing the new application using a user-friendly UI, (ii) verifying that this new application respects some consistency properties with respect to the current\u00a0\u2026", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Seamless Reconfiguration of Rule-Based IoT Applications\n", "abstract": " The Internet of Things (IoT) consists of devices and software interacting altogether in order to build powerful and added-value services. One of the main challenges in this context is to support end-users with simple, user-friendly, and automated techniques to design such applications. Given the dynamicity of IoT applications, these techniques should consider that these applications are in most cases not built once and for all. They can evolve over time and objects may be added or removed for several reasons (replacement, loss of connectivity, upgrade, failure, etc.). In this paper, we propose new techniques for supporting the reconfiguration of running IoT applications. These techniques compare two versions of the application (before and after reconfiguration) to check if several properties of interest from a reconfiguration perspective are preserved. The analysis techniques have been implemented using the Maude framework and integrated into the WebThings platform.", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Analysis of the Runtime Resource Provisioning of BPMN Processes using Maude\n", "abstract": " Companies are continuously adjusting their resources to their needs following different strategies. However, the dynamic provisioning strategies are hard to compare. This paper proposes an automatic analysis technique to evaluate and compare the execution time and resource occupancy of a business process relative to a workload and a provisioning strategy. Such analysis is performed on models conforming to an extension of BPMN with quantitative information, including resource availability and constraints. Within this framework, the approach is fully mechanized using a formal and executable specification in the rewriting logic framework, which relies on existing techniques and tools for simulating probabilistic and real-time specifications.", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Analysis of Resource Allocation of BPMN Processes\n", "abstract": " The approach for the modelling and analysis of resource allocation for business processes presented in this paper enables the automatic computation of measures for identifying the allocation of resources in business processes. The proposed analysis, especially suited to support decision-making strategies, is illustrated with a case study of a parcel ordering and delivery by drones that is developed throughout the paper. BPMN models are represented in Maude.", "num_citations": "2\n", "authors": ["1800"]}
{"title": "A foundation for the composition of multilevel domain-specific languages\n", "abstract": " In this paper, we provide a foundation for the definition and composition of multilevel domain-specific modelling languages. We will introduce modularization techniques such as composition, aggregation and referencing to enhance flexibility and reusability of these languages. To explain this foundation, we use Coloured Petri Nets (CPN) as a paradigmatic case study and define two CPN variants motivated by industrial collaboration projects: one used for the definition of protocols and the other one for robot controllers.", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Robust management of trans-cloud applications\n", "abstract": " The fault handling and recovery from runtime failures of cloud applications should be done by taking into account the inter-dependencies occurring among their components, and by dealing with the diverse and heterogeneous cloud offerings used to host them. The latter is even harder in trans-cloud scenarios, i.e., when application components are possibly deployed on different platforms and at different service levels (IaaS or PaaS). In this paper, we propose a methodology to support the automated management and recovery of (un) foreseen failures in a trans-cloud application, which takes into account all interdependencies occurring among its components. We then present a prototype implementation of our proposal, consisting of an orchestrator that exploits a management framework for trans-cloud application deployments, together with management protocols for the automated planning of the fault-aware\u00a0\u2026", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Computing the parallelism degree of timed BPMN processes\n", "abstract": " A business process is a combination of structured and related activities that aim at fulfilling a specific organizational goal for a customer or market. An important measure when developing a business process is the degree of parallelism, namely, the maximum number of tasks that are executable in parallel at any given time in a process. This measure determines the peak demand on tasks and thus can provide valuable insight on the problem of resource allocation in business processes. This paper considers timed business processes modeled in BPMN, a workflow-based graphical notation for processes, where execution times can be associated to several BPMN constructs such as tasks and flows. An encoding of timed business processes into Maude\u2019s rewriting logic system is presented, enabling the automatic computation of timed degrees of parallelism for business processes. The approach is illustrated\u00a0\u2026", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Dynamic Validation of Maude Prototypes of UML Models\n", "abstract": " We propose an approach for the validation of UML models annotated with OCL constraints. Specifically, we provide support for dynamically validating class invariants and operation pre/post conditions during the execution of prototypes automatically obtained from UML diagrams. The supported UML models specify both static and dynamic aspects, specifically, we focus on class and sequence diagrams. The proposal is based on Maude: UML models and OCL expressions are represented as Maude specifications, which allows us to evaluate OCL expressions on UML models by term rewriting. A model transformation allows us to accomplish this transformation automatically, and represents a first step towards the integration of the proposed facilities into development environments. The Maude specifications thus obtained can be seen as high-level executable prototypes of the annotated UML models.", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Validating ocl constraints on maude prototypes of uml models\n", "abstract": " Current tools to dynamically validate OCL constraints require a complete system implementation, whereas those tools which allow to validate constraints directly on the UML model only can do it statically, on concrete system states. We propose the use of high level Maude prototypes of UML models on which constraints can be dynamically validated during their simulation, prior the final implementation. We provide the necessary infrastructure to implement our approach and basic guidelines to obtain Maude prototypes from UML class diagrams. Our tool supports either single thread or multi thread execution and allows synchronous and asynchronous messages. This document shows our proposal and presents some use cases, including the simulation and validation of single-threaded and multi-threaded prototypes.", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Evaluation of OCL expressions in Maude. The evaluator mOdCL.\n", "abstract": " The Object Constraint Language (OCL) is a textual formal language which provides the necessary formal notation to complete UML diagrams with precise and unambiguous specifications, which otherwise would be limited to a set of diagrams with informal notes of textual character. As OCL is a formal language with well founded semantics, there is a growing interest in the development of support tools for it. This paper describes the design and implementation of mOdCL, a Maude based evaluator of OCL expressions.", "num_citations": "2\n", "authors": ["1800"]}
{"title": "Language prototyping in the Maude metalanguage\n", "abstract": " Language Prototyping in the Maude Metalanguage - Dialnet Ir al contenido Dialnet Buscar Revistas Tesis Congresos Ayuda Language Prototyping in the Maude Metalanguage Autores: Manuel Clavel, Francisco Dur\u00e1n Mu\u00f1oz, Steven Eker, Patrick Lincoln, Narciso Mart-Oliet, Jos\u00e9 Meseguer Guaita Localizaci\u00f3n: Primeras jornadas sobre programaci\u00f3n y lenguajes: (Prole 2001) : [celebradas en] Almagro, [el] 23 y 24 de noviembre de 2001 / Fernando Orejas Vald\u00e9s ( ed. lit. ), Fernando Cuartero G\u00f3mez ( ed. lit. ), Diego Cazorla L\u00f3pez ( ed. lit. ), 2001, p\u00e1gs. 93-110 Idioma: ingl\u00e9s Texto completo no disponible (Saber m\u00e1s ...) Fundaci\u00f3n Dialnet Acceso de usuarios registrados Imagen de identificaci\u00f3n Identificarse \u00bfOlvid\u00f3 su contrase\u00f1a? \u00bfEs nuevo? Reg\u00edstrese Ventajas de registrarse Dialnet Plus M\u00e1s informaci\u00f3n sobre Dialnet Plus Opciones de compartir Facebook Twitter Opciones de entorno Sugerencia / Errata \u00a9 2001\u2026", "num_citations": "2\n", "authors": ["1800"]}
{"title": "GTS Families for the Flexible Composition of Graph Transformation Systems\n", "abstract": " Morphisms between graph-transformation systems (GTSs) have been successfully used for the refinement, reuse, and composition of GTSs. All these uses share a fundamental problem: to be able to define a morphism, source and target GTSs need to be quite similar in their structure (in terms of both the type graphs and the set of rules and their respective structures). This limits the applicability of these approaches by excluding a wide range of mappings that would intuitively be accepted as meaningful, but that cannot be captured formally as a morphism. Some researchers have attempted to introduce some flexibility, but these attempts either focus only on the type graphs (e.g., Kleisli morphisms between type graphs) or only support specific forms of deviation (e.g., supporting sub-typing in type graphs through clan morphisms). In this work, we introduce the notion of GTS families, which provide a general\u00a0\u2026", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Component migration in a trans-cloud environment\n", "abstract": " The trans-cloud approach has recently been proposed to simplify the development and operation of cloud applications, and to minimize the lock-in problem. The three key ingredients of the trans-cloud approach are: agnostic topology descriptions, a unified API, and mechanisms for the independent specification of providers\u2019 services. We build on the trans-cloud mechanisms to propose a solution for the migration of stateless cloud components at runtime. In the context of our trans-cloud tool, we propose an algorithm for the migration of cloud applications\u2019 components between different providers, possibly changing their service levels between IaaS and PaaS. We present an implementation of our proposed solution, and illustrate it with a case study and experimental results.", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Towards the performance analysis of elastic systems with e-Motions\n", "abstract": " We use graph transformation to define an adaptive component model, what allows us to carry on predictive analysis of dynamic architectures through simulations. Specifically, we build on an e-Motions definition of the Palladio component model, and then specify adaptation mechanisms as generic adaptation rules. We show how the simulation-based analysis available in such a static definition can be extended in order to use the collected information on metrics such as response time, throughput and resource usage to adapt to the workload of the system and the environmental conditions. We illustrate our approach with rules modeling the scale in and out of servers, fired in response to the violation of specified constraints on the usage of resources. We evaluate this scenario by analyzing its performance, and discuss on its consequences in practice.", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Preface to Rewriting Logic and Its Applications (extended selected papers from WRLA 2012)\n", "abstract": " Preface to Rewriting Logic and Its Applications (extended selected papers from WRLA 2012) | Science of Computer Programming ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Science of Computer Programming Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsScience of Computer ProgrammingVol. , No. CPreface to Rewriting Logic and Its Applications (extended selected papers from WRLA 2012) research-article Preface to Rewriting Logic and Its Applications (extended selected papers from WRLA 2012) Share on Authors: Francisco Dur\u00e1n profile image Francisco Dur\u00e1n Universidad de M\u00e1laga, Spain Universidad de M\u00e1laga, Spain View \u2026", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Equational Abstractions in Rewriting Logic and Maude\n", "abstract": " Maude is a high-level language and high-performance system supporting both equational and rewriting computation for a wide range of applications. Maude also provides a model checker for linear temporal logic. The model-checking procedure can be used to prove properties when the set of states reachable from an initial state in a system is finite; when this is not the case, it may be possible to use an equational abstraction technique for reducing the size of the state space. Abstraction reduces the problem of whether an infinite state system satisfies a temporal logic property to model checking that property on a finite state abstract version of the original infinite system. The most common abstractions are quotients of the original system. We present a simple method for defining quotient abstractions by means of equations identifying states. Our method yields the minimal quotient system together with a set of\u00a0\u2026", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Composition of Graph-Transformation-Based DSL Definitions by Amalgamation\n", "abstract": " Given a graph-grammar formalization of DSLs, we build on graph transformation system morphisms to define parameterized DSLs and their instantiation by an amalgamation construction. Results on the protection of the behavior along the induced morphisms allow us to safely combine definitions of DSLs to build more complex ones. We illustrate our proposal on our e-Motions definition of the Palladio DSL. The resulting DSL allows us to carry on performance analysis on Palladio models.", "num_citations": "1\n", "authors": ["1800"]}
{"title": "The Movie Database Case: A Solution Using the Maude-based e-Motions Tool.\n", "abstract": " The paper presents solutions for the TTC 2014 Movie Database Case, both in the e-Motions DSML and in the rewriting-logic formal language Maude. The DSLs defined in e-Motions are automatically transformed into Maude specifications, which are then used for simulation and analysis purposes. However, since e-Motions is a general purpose language, in which real-time languages may be modeled, with full support for OCL and other advanced features, the Maude specifications automatically generated are not as efficient as one would like. Since most of these features are not needed for the current tasks, we propose solutions both in e-Motions and in Maude, trying to highlight the main features of both languages. The fact that the solutions given directly in Maude lack the overhead included by e-Motions to deal with all those features it provides that are not needed in the current case study, makes these solutions much more efficient, and able to deal with bigger problems.", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Rewriting Logic and Its Applications: 9th International Workshop, WRLA 2012, Held as a Satellite Event of ETAPS 2012, Tallinn, Estonia, March 24-25, 2012, Revised Selected Papers\n", "abstract": " This book constitutes the thoroughly refereed post-workshop proceedings of the 9th International Workshop on Rewriting Logic and its Applications, WRLA 2012, held as a satellite event of ETAPS 2012, in Tallinn, Estonia, in March 2012. The 8 revised full papers presented together with 4 invited papers were carefully reviewed and selected from 12 initial submissions and 5 invited lectures. The papers address a great diversity of topics in the fields of rewriting logic such as: foundations and models, languages, logical and semantic framework, model-based software engineering, real-time and probabilistic extensions, verification techniques, and distributed systems.", "num_citations": "1\n", "authors": ["1800"]}
{"title": "A Maude Coherence Checker Tool for Conditional Order-Sorted Rewrite Theories (Long Version)\n", "abstract": " For a rewrite theory to be executable, its equations E should be (ground) confluent and terminating modulo the given axioms A, and their rules should be (ground) coherent with E modulo A. The correctness of many important formal verification tasks, including search, LTL model checking, and the development of abstractions, crucially depends on the theory being ground coherent. Furthermore, many specifications of interest are typed, have equations E and rules R that are both conditional, have axioms A involving various combinations of associativity, commutativity and identity, and may contain frozenness restrictions. This makes it essential to extend the known coherence checking methods from the untyped, unconditional, and AC or free case, to this much more general setting. We present the mathematical foundations of the Maude ChC 3 tool, which provide such a generalization to support coherence and ground coherence checking for order-sorted rewrite theories under these general assumptions. We also explain and illustrate the use of the ChC 3 tool with a nontrivial example.", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Web services and interoperability for the Maude termination tool\n", "abstract": " This paper presents the Maude Termination Tool (MTT) version 1.5. MTT takes Maude programs as inputs and tries to prove them terminating by applying different transformation techniques and by using existing termination tools as back-ends. MTT can use as back-end tool any termination tool supporting the TPDB syntax, either locally if it follows the rules for the Termination Competition, or remotely as web services. This allows us to interact with the different tools in a uniform way, and not restricting ourselves to a specific set of tools. Thus, tools that have participated in the competition, like AProVE, MU-TERM, TTT, etc., or others that accommodate to the syntax and form of interaction, can be used as back-ends of MTT. In the MTT environment, Maude specifications can be proved terminating by using (any of these) distinct formal tools, allowing the user to choose the most appropriate one for each particular case, a\u00a0\u2026", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Cardelli\u2019s challenge in Mobile Maude: A conference reviewing system\n", "abstract": " A useful way of presenting a new language is by means of complete examples that show the language features in action. In this paper we do so for the Mobile Maude language, an extension of Maude that suports mobile computation. We implement an ambitious wide area application, namely a conference reviewing system, an example described by Cardelli as a challenge for any wide area language to demonstrate its usability.", "num_citations": "1\n", "authors": ["1800"]}
{"title": "El uso de herramientas de apoyo para la valoraci\u00f3n de actividades pr\u00e1cticas de programaci\u00f3n\n", "abstract": " La actual situaci\u00f3n de los grupos en los que se ha aplicado la experiencia piloto de Convergencia al Espacio Europeo de Educaci\u00f3n Superior en las titulaciones de Inform\u00e1tica de la Universidad de M\u00e1laga, y en particular, en la asignatura \u201cLaboratorio de Tecnolog\u00eda de Objetos\u201d, hacen dif\u00edcil un seguimiento personalizado de los alumnos con los recursos de profesorado con los que se ha contado hasta el momento, que no han diferido de los de cursos anteriores. M\u00e1s de 200 alumnos se han visto involucrados, y el contenido, fundamentalmente pr\u00e1ctico, relativo a temas de programaci\u00f3n, agravan esta situaci\u00f3n. Con objeto de conseguir el efecto motivador, el trabajo contin\u00fao y la revisi\u00f3n de temas no asimilados, que un seguimiento personal del profesor suele producir sobre el alumno, durante este curso se ha hecho un uso sistem\u00e1tico del campus virtual de la Universidad de M\u00e1laga, y \u00e9ste se ha complementado con la aplicaci\u00f3n de una herramienta desarrollada por los profesores de la asignatura para informar al alumno sobre los errores detectados en las pr\u00e1cticas desarrolladas, y notificar de la superaci\u00f3n de las mismas. Del mismo modo, se han utilizado herramientas para garantizar la autor\u00eda individual de los trabajos. Aunque la herramienta implementada fue desarrollada inicialmente para ofrecer al profesor una automatizaci\u00f3n del proceso de valoraci\u00f3n de pr\u00e1cticas, asignando niveles distintos de superaci\u00f3n de objetivos, entre las propiedades m\u00e1s interesantes se puede destacar la emisi\u00f3n de informes al alumno, indicando las fases superadas en la pr\u00e1ctica y la detecci\u00f3n inmediata de los errores cometidos. La inmediatez y\u00a0\u2026", "num_citations": "1\n", "authors": ["1800"]}
{"title": "Mutantes como Apoyo para la Valoraci\u00f3n de Pruebas\n", "abstract": " En este trabajo proponemos el uso de mutation testing en asignaturas de pruebas de software para ayudar en la labor de evaluaci\u00f3n de las mismas, a la vez que ayuda a los alumnos a entender y asimilar la t\u00e9cnica en s\u00ed. Describimos nuestra experiencia en una asignatura de pruebas de software. Con ayuda de una herramienta para la generaci\u00f3n y evaluaci\u00f3n de mutantes, el profesor puede obtener una idea r\u00e1pida de la calidad de las pruebas que puede guiar/confirmar su evaluaci\u00f3n. El alumno puede obtener una primera evaluaci\u00f3n de su trabajo y puede mejorar el conjunto de pruebas.", "num_citations": "1\n", "authors": ["1800"]}