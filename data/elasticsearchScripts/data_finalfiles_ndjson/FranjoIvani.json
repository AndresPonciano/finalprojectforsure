{"title": "System and method for modeling, abstraction, and analysis of software\n", "abstract": " A system and method is disclosed for formal verification of software programs that advantageously translates the software, which can have bounded recursion, into a Boolean representation comprised of basic blocks and which applies SAT-based model checking to the Boolean representation.", "num_citations": "256\n", "authors": ["1809"]}
{"title": "Benchmarks for hybrid systems verification\n", "abstract": " There are numerous application examples for hybrid systems verification in recent literature. Most of them were introduced to illustrate a new approach to hybrid systems verification, and are therefore of a limited size. Others are case studies that serve to prove that an approach can be applied to real world problems. Verification of these typically requires a lot of domain experience to obtain a tractable, verifiable model. Verification of a case study yields a singular result that is hard to compare and time-consuming to reproduce.               This paper introduces three benchmarks for hybrid systems verification. These benchmarks are independent from a particular approach to verification, they have a limited domain, and have a simple basic structure. Nevertheless, these benchmarks can be scaled to arbitrary complexity, and offer the possibility to inject phenomena that are known to be problematic in hybrid\u00a0\u2026", "num_citations": "216\n", "authors": ["1809"]}
{"title": "Modeling and analytics for cyber-physical systems in the age of big data\n", "abstract": " In this position paper we argue that the availability of \"big\" monitoring data on Cyber-Physical Systems (CPS) is challenging the traditional CPS modeling approaches by violating their fundamental assumptions. However, big data alsobrings unique opportunities in its wake by enabling new modeling and analytics approaches as well as facilitating novel applications. We highlight a few key challenges andopportunities, and outline research directions for addressing them. To provide a proper context, we also summarize CPS modeling approaches, and discuss how modeling and analytics for CPS differs from general purpose IT systems.", "num_citations": "57\n", "authors": ["1809"]}
{"title": "Efficient decision procedure for non-linear arithmetic constraints using cordic\n", "abstract": " In verification of hybrid discrete-continuous and embedded control systems, one encounters decision problems involving non-linear constraints. We propose an efficient decision procedure (CORD) for such decisions problems using CORDIC algorithms, and an off-the-shelf SMT(LA) (Satisfiability Modulo Theory for Linear Arithmetic) solver, for given precision requirements. We first translate the non-linear part of the decision problem to a SMT(LA) formula using CORDIC algorithms, accounting for all the inaccuracies safely. In the translation, we use a normalization scheme, combined with interval bounds to obtain a linearized formula without compromising the precision requirements. On such a linearized formula, we devise a DPLL-style Interval Search Engine (DISE) that explores various combinations of interval bounds using a SMT(LA) solver. In our experiments, we demonstrate the efficacy of our approach, and\u00a0\u2026", "num_citations": "37\n", "authors": ["1809"]}
{"title": "Fudge: fuzz driver generation at scale\n", "abstract": " At Google we have found tens of thousands of security and robustness bugs by fuzzing C and C++ libraries. To fuzz a library, a fuzzer requires a fuzz driver\u2014which exercises some library code\u2014to which it can pass inputs. Unfortunately, writing fuzz drivers remains a primarily manual exercise, a major hindrance to the widespread adoption of fuzzing. In this paper, we address this major hindrance by introducing the Fudge system for automated fuzz driver generation. Fudge automatically generates fuzz driver candidates for libraries based on existing client code. We have used Fudge to generate thousands of new drivers for a wide variety of libraries. Each generated driver includes a synthesized C/C++ program and a corresponding build script, and is automatically analyzed for quality. Developers have integrated over 200 of these generated drivers into continuous fuzzing services and have committed to address\u00a0\u2026", "num_citations": "33\n", "authors": ["1809"]}
{"title": "Using hardware transactional memory for data race detection\n", "abstract": " Widespread emergence of multicore processors will spur development of parallel applications, exposing programmers to degrees of hardware concurrency hitherto unavailable. Dependable multithreaded software will have to rely on the ability to dynamically detect non-deterministic and notoriously hard to reproduce synchronization bugs manifested through data races. Previous solutions to dynamic data race detection have required specialized hardware, at additional power, design and area costs. We propose RaceTM, a novel approach to data race detection that exploits hardware that will likely be present in future multiprocessors, albeit for a different purpose. In particular, we show how emerging hardware support for transactional memory can be leveraged to aid data race detection. We propose the concept of lightweight debug transactions that exploit the conflict detection mechanisms of transactional memory\u00a0\u2026", "num_citations": "33\n", "authors": ["1809"]}
{"title": "Eclipse feature logic analysis\n", "abstract": " ECLIPSE is a virtual telecommunications network based on IP. It is the result of an ongoing research project at AT&T Labs\u2013Research that is investigating next-generation telecom service architectures. The ECLIPSE Statecharts language was developed to simplify feature (service) development, for example call waiting, by supporting a smooth transition from design to implementation and by supporting automated semantic analysis. The modular nature of ECLIPSE features necessitates that they utilize well-defined protocols for communicating with one another. If an individual feature fails to obey the protocol then it is likely that subscribers to the feature will be unable to complete calls. This paper describes a tool that uses the Mocha model checking tool to analyze ECLIPSE feature modules to ensure that they satisfy the specified protocols.", "num_citations": "26\n", "authors": ["1809"]}
{"title": "Modeling and analysis of hybrid systems\n", "abstract": " This thesis discusses the modeling and analysis of hybrid systems. Hybrid modeling is an appropriate modeling framework for embedded systems and other real-world applications bridging the gap between continuous dynamical systems and discrete event systems. First, this thesis presents the hybrid systems modeling language and toolkit CHARON. In the following, this thesis then addresses the analysis of hybrid systems using model checking techniques. The goal of a reachability analysis is to either be able to discover bugs in a hybrid system model or to be able to guarantee that the model is safe with respect to a certain property. This thesis presents algorithms and tools for reachability analysis of hybrid systems by combining the notion of counter-example guided predicate abstraction with recent techniques for approximating the set of reachable states of linear systems using polyhedra.", "num_citations": "22\n", "authors": ["1809"]}
{"title": "A hybrid dynamical systems approach to intelligent low-level navigation\n", "abstract": " Animated characters may exhibit several kinds of dynamic intelligence when performing low-level navigation (i.e., navigation on a local perceptual scale): they decide among different modes of behavior selectively discriminate entities in the world around them, perform obstacle avoidance, etc. In this paper we present a hybrid dynamical system model of low-level navigation that accounts for the above-mentioned kinds of intelligence. In so doing, the model illustrates general ideas about how a hybrid systems perspective can influence and simplify such reactive/behavioral modeling for multi-agent systems. In addition, we directly employed our formal hybrid system model to generate animations that illustrate our navigation strategies. Overall, our results suggest that hierarchical hybrid systems may provide a natural framework for modeling elements of intelligent animated actors.", "num_citations": "21\n", "authors": ["1809"]}
{"title": "Hybrid system models of navigation strategies for games and animations\n", "abstract": " The virtual worlds of computer games and similar animated simulations may be populated by autonomous characters that intelligently navigate in virtual cities. We concretely apply hybrid system theory and tools to model navigation strategies for virtual characters. In particular, we present hybrid systems for both low-level (local) and high-level (global) navigation strategies, and we describe how we modeled these systems using the hybrid system specification tool Charon. Further, we directly employed our hybrid system models to generate animations that demonstrate these navigation strategies. Overall, our results suggest that hybrid systems may be a natural framework for modeling aspects of intelligent virtual actors. We also present a small verification example for a simple navigation strategy, and we briefly discuss obstacles to widespread practical applicability of verification in this problem domain.", "num_citations": "20\n", "authors": ["1809"]}
{"title": "Testing applications with a defined input format\n", "abstract": " A system and method are provided for testing the performance of applications. By way of example only, the method may include training a neural network with documents containing text elements that are arranged in accordance with a defined format and using the neural network to determine the predictability of the value of individual text elements within a test document. When the neural network indicates that the value of a text element is unlikely, the value may be modified and the modified document may be used to test an application that processes documents in accordance with the defined format.", "num_citations": "17\n", "authors": ["1809"]}
{"title": "A hybrid nano-CMOS architecture for defect and fault tolerance\n", "abstract": " As the end of the semiconductor roadmap for CMOS approaches, architectures based on nanoscale molecular devices are attracting attention. Among several alternatives, silicon nanowires and carbon nanotubes are the two most promising nanotechnologies according to the ITRS. These technologies may enable scaling deep into the nanometer regime. However, they suffer from very defect-prone manufacturing processes. Although the reconfigurability property of the nanoscale devices can be used to tolerate high defect rates, it may not be possible to locate all defects. With very high device densities, testing each component may not be possible because of time or technology restrictions. This points to a scenario in which even though the devices are tested, the tests are not very comprehensive at locating defects, and hence the shipped chips are still defective. Moreover, the devices in the nanometer range will\u00a0\u2026", "num_citations": "14\n", "authors": ["1809"]}
{"title": "Efficient decision method for real non-linear arithmetic constraints\n", "abstract": " A system and method for solving a decision problem having Boolean combinations of linear and non-linear operations includes translating the non-linear real operations using a COordinate Rotation DIgital Computer (CORDIC) method programmed on a computer device into linear operations maintaining a given accuracy. Linear and translated linear operations are combined into a formula. Satisfiability of the formula is solved using a decision procedure for Boolean combinations of linear operations over integers and reals.", "num_citations": "11\n", "authors": ["1809"]}
{"title": "Report on verification of the MoBIES vehicle-vehicle automotive OEP problem\n", "abstract": " The DARPA MoBIES Automotive Vehicle-Vehicle Open Experimental Platform [14] defines a longitudinal controller for the leader car of a platoon moving in an Intelligent Vehicle Highway System (IVHS) autonomously. The challenge is to verify that cars using this longitudinal controller provide a safe (that is, collision-free) ride. This report presents the process of verifying this particular controller using our CHARON [2] toolkit. In particular, it involves modeling and simulation of the system in CHARON and verifying the controller using our predicate abstraction technique for hybrid systems [3].", "num_citations": "11\n", "authors": ["1809"]}
{"title": "Racetm: Detecting data races using transactional memory\n", "abstract": " Widespread emergence of multicore processors will spur development of parallel applications, exposing programmers to more hardware concurrency. Dependable multithreaded software will have to rely on the ability to dynamically detect data races, which are non-deterministic and notoriously hard to reproduce symptoms of synchronization bugs. In this paper, we propose RaceTM, a novel approach that exploits transactional memory support to detect data races. We introduce the concept of lightweight debug transactions that exploit the conflict detection mechanisms of transactional memory systems to perform data race detection. Debug transactions differ from regular transactions in that they do not need to be rolled back, and therefore require no versioning or checkpointing support. Debug transactions do not overlap with a regular transaction, thus providing a transparent mechanism to leverage existing\u00a0\u2026", "num_citations": "8\n", "authors": ["1809"]}
{"title": "Fault-tolerant computing using a hybrid nano-CMOS architecture\n", "abstract": " Architectures based on nanoscale molecular devices are attracting attention for replacing CMOS architectures at the end of the semiconductor roadmap. The two most promising nanotechnologies, according to ITRS, are silicon nanowires and carbon nanotubes. Although they offer unmatched densities for building logic, interconnect and memory, they suffer from very defect-prone manufacturing processes. This is further exacerbated by testing complexities where it is nearly impossible to detect all defects in a large nanoscale chip. Furthermore, the small structures in nanoscale architectures are susceptible to transient faults which can produce arbitrary soft errors. As a result, fault tolerance is necessary to make nanoscale architectures practical and realistic. We propose an architecture that can tolerate a large number of undetected manufacturing faults as well as a large rate of transient faults. Our architecture is\u00a0\u2026", "num_citations": "7\n", "authors": ["1809"]}
{"title": "Modeling and analysis of hybrid systems\n", "abstract": " First, and foremost, I want to thank my advisor Professor Rajeev Alur. His knowl-edge and constant guidance have helped me a long way towards completing this thesis. I would also like to thank Professor Insup Lee for chairing my thesis com-mittee, and Professors Vijay Kumar, George Pappas, and Bruce Krogh from the Carnegie-Mellon University for accepting to be members on my thesis committee. Many thanks go out to Professor Oleg Sokolsky as well. In addition, I would like to thank the whole CIS department for making Penn such a fruitful experience to me. Special thanks go out to Mike Felker who was always helpful. During my time at Penn, I have collaborated with many researchers from the CIS department, as well as other departments of Penn, but also with members of other research organizations. Most importantly, I would like to thank Thao Dang, without whom most of this work would not have been implementable, and who also became a very close friend of mine in the process. Additionally, I would like to thank Eric Aaron, Calin Belta, Ansgar Fehnker, and Jesung Kim for various contributions to my research that is presented in this thesis. I also want to thank Maria Adamou, Dimos", "num_citations": "6\n", "authors": ["1809"]}
{"title": "Offline queries in software defined networks\n", "abstract": " Methods and systems for finding a packet's routing path in a network includes intercepting control messages sent by a controller to one or more switches in a software defined network (SDN). A state of the SDN at a requested time is emulated and one or more possible routing paths through the emulated SDN is identified by replaying the intercepted control messages to one or more emulated switches in the emulated SDN. The one or more possible routing paths correspond to a requested packet injected into the SDN at the requested time.", "num_citations": "5\n", "authors": ["1809"]}
{"title": "Environment-Sensitive Performance Tuning for Distributed Service Orchestration\n", "abstract": " Modern distributed systems are designed to tolerate unreliable environments, i.e., they aim to provide services even when some failures happen in the underlying hardware or network. However, the impact of unreliable environments can be significant on the performance of the distributed systems, which should be considered when deploying the services. In this paper, we present an approach to optimize performance of the distributed systems under unreliable deployed environments, through searching for optimal configuration parameters. To simulate an unreliable environment, we inject several failures in the environment of a service application, such as a node crash in the cluster, network failures between nodes, resource contention in nodes, etc. Then, we use a search algorithm to find the optimal parameters automatically in the user-selected parameter space, under the unreliable environment we\u00a0\u2026", "num_citations": "3\n", "authors": ["1809"]}
{"title": "Small scale integration test generation\n", "abstract": " Provided are methods and systems for automated generation of small scale integration tests to keep mocked input-output contract expectations of external objects synchronized with the actual implementation of the external objects. Such synchronization is achieved through automated creation of small scale integration tests by replacing expected input-output behaviors of mocked interactions with actual code sequences of the mocked interaction. The methods and systems utilize automated test generators with search-based software engineering methods to reuse and adapt developer written tests into new automatically generated tests.", "num_citations": "2\n", "authors": ["1809"]}
{"title": "Effective Lifetime Dependency Analysis and Typestate Analysis\n", "abstract": " Disclosed are typestate and lifetime dependency analysis methods for identifying bugs in C++ programs. Disclosed are an abstract representation (ARC++) that models C++ objects and which makes object creation/destruction, usage, lifetime and pointer operations explicit in the abstract model thereby providing a basis for static analysis on the C++ program. Also disclosed is a lifetime dependency analysis that tracks implied dependency relationships between lifetimes of objects, to capture an effective high-level abstraction for issues involving temporary objects and internal buffers, and subsequently used in the static analysis that supports typestate checking for the C++ program. Finally disclosed a framework that automatically genarates ARC++ representations from C++ programs and performs typestate checking to detect bugs that are specified as typestate automata over ARC++ representations.", "num_citations": "2\n", "authors": ["1809"]}