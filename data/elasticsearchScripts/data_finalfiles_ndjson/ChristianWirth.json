{"title": "An object storage model for the truffle language implementation framework\n", "abstract": " Truffle is a Java-based framework for developing high-performance language runtimes. Language implementers aiming at developing new runtimes have to design all the runtime mechanisms for managing dynamically typed objects from scratch. This not only leads to potential code duplication, but also impacts the actual time needed to develop a fully-fledged runtime.", "num_citations": "63\n", "authors": ["1858"]}
{"title": "A domain-specific language for building self-optimizing AST interpreters\n", "abstract": " Self-optimizing AST interpreters dynamically adapt to the provided input for faster execution. This adaptation includes initial tests of the input, changes to AST nodes, and insertion of guards that ensure assumptions still hold. Such specialization and speculation is essential for the performance of dynamic programming languages such as JavaScript. In traditional procedural and objectoriented programming languages it can be tedious to write selfoptimizing AST interpreters, as those languages fail to provide constructs that would specifically support that. This paper introduces a declarative domain-specific language (DSL) that greatly simplifies writing self-optimizing AST interpreters. The DSL supports specialization of operations based on types of the input and other properties. It can then use these specializations directly or chain them to represent the operation with the minimum amount of code possible. The DSL\u00a0\u2026", "num_citations": "50\n", "authors": ["1858"]}
{"title": "A comprehensive solution for deterministic replay debugging of SoftPLC applications\n", "abstract": " Deterministic replay debugging is an approach to finding bugs in deployed software. It records an application run in the field so that it can deterministically be replayed offline in a development system for debugging purposes. To enable deterministic replay debugging, it is necessary to record all external influences and sources of nondeterminism in the original program run. From that trace log and from a known initial state, the program can be replayed deterministically without requiring any connection to the original environment. In this paper, we present a solution for deterministic replay debugging of hard real-time multitasking SoftPLC applications written in the IEC 61131-3 languages. By taking advantage of the special properties of these programs and by careful engineering, our technique allows recording a SoftPLC application run in the field with minimal overhead and obeying real-time constraints. In later\u00a0\u2026", "num_citations": "36\n", "authors": ["1858"]}
{"title": "Monaco: A dsl approach for programming automation systems\n", "abstract": " In this paper we present the language Monaco, which is a DSL for programming event-based, reactive automation solutions. The main purpose of the language is to bring automation programming closer to the domain experts and end users. Important design goals therefore have been to keep the language simple and allow writing programs which are close to the perception of domain experts. The language Monaco is similar to Statecharts in its expressive power, however, adopts an imperative notation. Moreover, Monaco adopts a state-of-the-art component approach with interfaces and polymorphic implementations and it enforces strict hierarchical communication architectures which support the hierarchical abstraction of control tasks. We discuss the main design goals, the essential programming elements, and the visual program representation and illustrate how the language supports hierarchical abstraction of control functionality by an example application.", "num_citations": "20\n", "authors": ["1858"]}
{"title": "Monaco\u2014a domain-specific language solution for reactive process control programming with hierarchical components\n", "abstract": " In this paper, we present Monaco \u2013 a domain-specific language for developing event-based, reactive process control programs \u2013 and its visual interactive programming environment. The main purpose of the language is to bring process control programming closer to domain experts. Important design goals have therefore been to keep the language concise and to allow programs to be written that reflect the perceptions of domain experts. Monaco is similar to Statecharts in its expressive power, but adopts an imperative notation. Moreover, Monaco uses a state-of-the-art component approach with interfaces and polymorphic implementations, and enforces strict hierarchical component architectures that support hierarchical abstraction of control functionality. We present the main design goals, the essential programming elements, the visual interactive programming environment, results from industrial case studies, and\u00a0\u2026", "num_citations": "15\n", "authors": ["1858"]}
{"title": "The domain-specific language monaco and its visual interactive programming environment\n", "abstract": " Monaco is a domain-specific language for machine automation programming. It has been developed with the objective to empower domain experts with limited programming capabilities. Its main language features are an imperative notation for reactive systems, concepts for describing asynchronous event handling in a concise way, and a state-of-the-art component approach. Monaco is a programming language with a Pascal-like syntax, but also comes with a visual programming environment. In this paper we review the language Monaco, show the visual representation scheme, report on the programming environment and compare our visual notation to Statecharts.", "num_citations": "14\n", "authors": ["1858"]}
{"title": "Deterministic replay debugging of IEC 61131-3 SoftPLC programs\n", "abstract": " Determimstic Replay Debugging is an approach to finding field failures in application runs. It records an application run so that it can be replayed deterministically in a development system for debugging purposes without connection to a physical environment. In this paper, we present a solution for deterministic replay debugging of hard real-time SoftPLC applications written in the IEC 61131-3 languages. By taking advantage of the special properties of these programs and by careful engineering, our technique allows recording a SoftPLC application run with minimal overhead and obeying real-time constraints. In later phases, which are off-line, the original program run is reconstructed to be replayed for debugging. We present the conceptual basis of our approach, a tool chain including a time-traveling debugger, and an evaluation as well as an industrial case study for validating the approach.", "num_citations": "11\n", "authors": ["1858"]}
{"title": "Software support for building end-user programming environments in the automation domain\n", "abstract": " Projects in the automation domain often require that end users, who are the machine operators, have means to change control software to make adaptations and optimizations for the machining task at hand. Although they usually do not have any software development expertise, they intervene in safety-critical software systems. This results in high demands on end-user programming environments with respect to supporting, guiding, and supervising end users. In this paper we present a software framework which is intended to serve as a basis for developing end-user programming environments. The main parts of this framework are a domain-specific language for programming automation solutions at a high level of abstraction, different visual editors for supporting end users, an approach for checking program changes against formal specifications, a variability modeling approach for representing high-level user\u00a0\u2026", "num_citations": "7\n", "authors": ["1858"]}
{"title": "A tool for trace visualization and offline debugging of PLC applications\n", "abstract": " This paper describes a tool for offline debugging and trace visualization of PLC applications. Based on trace data obtained by a deterministic replay technology for multi-threaded Soft PLC applications, the tool allows visualizing an application run in its various aspects and on various levels of abstraction. Each view shows a different level of detail, allowing the user to dive into the program from high-level views showing abstract program behavior to low-level views showing each executed statement or variable value in detail. With a set of views the tool supports the user to get an overview of the program execution, to identify abnormal program behavior, to discover the causes for program failures, and finally to locate defects in the source code. The paper presents the conceptional background of the approach, shows how program runs can be visualized, and how they can be analysed in detail. Then it demonstrates\u00a0\u2026", "num_citations": "6\n", "authors": ["1858"]}
{"title": "Reverse engineering and visualization of the reactive behavior of plc applications\n", "abstract": " This paper presents an approach to reverse engineering and dynamic analysis of the reactive behavior of PLC programs. Based on execution traces, it is shown how to derive a state model representation of the reactive program behavior and how this model supports dynamic program analysis. In particular, the state model is used for mining execution patterns which occur repeatedly in a program execution. We discuss the key ideas of the approach, the various analysis and visualization methods available, and results from a case study.", "num_citations": "5\n", "authors": ["1858"]}
{"title": "A multi-level approach for visualization and exploration of reactive program behavior\n", "abstract": " This paper presents an approach for dynamic analysis and visualization of reactive program behavior. The objective is to understand the reactive behavior of complex programs for the purpose of finding unusual and possibly abnormal behavior, locating defects in the code, and finding causes of failures. Based on execution traces a multi-level analysis and visualization approach is proposed where, on one side, the behavior is analyzed to exhibit recurring execution patterns and their similarities and differences at a higher level of abstraction and, on the other side, program behavior can be explored in detail for giving explanations and showing causes of failures. The approach has been implemented as a tool chain for the analysis of PLC control programs. We discuss the key ideas of the approach, the implementation in a tool chain for PLC programs, and preliminary results from a case study.", "num_citations": "5\n", "authors": ["1858"]}
{"title": "Detection of high-level execution patterns in reactive behavior of control programs\n", "abstract": " This paper presents an approach to extract high-level patterns from traces of programmable logic control (PLC) programs recorded with a deterministic replay debugging tool. Our deterministic replay debugging works by recording an application run in real-time with minimal overhead so that it can be reproduced afterwards. In a subsequent phase, the application is replayed in offline mode to produce a more detailed trace log with additional information about the application run. A software developer can replay the program in a debugger and use debugger features to analyze the program run and locate errors. However, due to the vast amount of data and the complex behavior of reactive control programs, a normal debugger is usually only a poor support in comprehending the program behavior. In this paper we present an approach to analyze recorded program runs of PLC applications. We present a technology to\u00a0\u2026", "num_citations": "4\n", "authors": ["1858"]}
{"title": "Faster fastr through partial evaluation and compilation\n", "abstract": " 1. Oracle Labs 2. Johannes Kepler University, Linz, Austria 3. Purdue University, West Lafayette, IN, USA* Contact author: michael. haupt@ oracle. com", "num_citations": "1\n", "authors": ["1858"]}