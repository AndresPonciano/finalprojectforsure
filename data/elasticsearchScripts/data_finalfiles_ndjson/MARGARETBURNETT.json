{"title": "Principles of explanatory debugging to personalize interactive machine learning\n", "abstract": " How can end users efficiently influence the predictions that machine learning systems make on their behalf? This paper presents Explanatory Debugging, an approach in which the system explains to users how it made each of its predictions, and the user then explains any necessary corrections back to the learning system. We present the principles underlying this approach and a prototype instantiating it. An empirical evaluation shows that Explanatory Debugging increased participants' understanding of the learning system by 52% and allowed participants to correct its mistakes up to twice as efficiently as participants using a traditional learning system.", "num_citations": "372\n", "authors": ["154"]}
{"title": "Forms/3: A first-order visual language to explore the boundaries of the spreadsheet paradigm\n", "abstract": " Although detractors of functional programming sometimes claim that functional programming is too difficult or counter-intuitive for most programmers to understand and use, evidence to the contrary can be found by looking at the popularity of spreadsheets. The spreadsheet paradigm, a first-order subset of the functional programming paradigm, has found wide acceptance among both programmers and end users. Still, there are many limitations with most spreadsheet systems. In this paper, we discuss language features that eliminate several of these limitations without deviating from the first-order, declarative evaluation model. The language used to illustrate these features is a research language called Forms/3. Using Forms/3, we show that procedural abstraction, data abstraction and graphics output can be supported in the spreadsheet paradigm. We show that, with the addition of a simple model of time, animated\u00a0\u2026", "num_citations": "279\n", "authors": ["154"]}
{"title": "A methodology for testing spreadsheets\n", "abstract": " Spreadsheet languages, which include commercial spreadsheets and various research systems, have had a substantial impact on end-user computing. Research shows, however, that spreadsheets often contain faults; thus, we would like to provide at least some of the benefits of formal testing methodologies to the creators of spreadsheets. This article presents a testing methodology that adapts data flow adequacy criteria and coverage monitoring to the task of testing spreadsheets. To accommodate the evaluation model used with spreadsheets, and the interactive process by which they are created, our methodology is incremental. To accommodate the users of spreadsheet languages, we provide an interface to our methodology that does not require an understanding of testing theory. We have  implemented our testing methodology in the context of the Forms/3 visual spreadsheet language. We report  on the\u00a0\u2026", "num_citations": "259\n", "authors": ["154"]}
{"title": "A user-centred approach to functions in Excel\n", "abstract": " We describe extensions to the Excel spreadsheet that integrate user-defined functions into the spreadsheet grid, rather than treating them as a\" bolt-on\". Our first objective was to bring the benefits of additional programming language features to a system that is often not recognised as a programming language. Second, in a project involving the evolution of a well-established language, compatibility with previous versions is a major issue, and maintaining this compatibility was our second objective. Third and most important, the commercial success of spreadsheets is largely due to the fact that many people find them more usable than programming languages for programming-like tasks. Thus, our third objective (with resulting constraints) was to maintain this usability advantage. Simply making Excel more like a conventional programming language would not meet these objectives and constraints. We have therefore\u00a0\u2026", "num_citations": "216\n", "authors": ["154"]}
{"title": "Too much, too little, or just right? Ways explanations impact end users' mental models\n", "abstract": " Research is emerging on how end users can correct mistakes their intelligent agents make, but before users can correctly \u201cdebug\u201d an intelligent agent, they need some degree of understanding of how it works. In this paper we consider ways intelligent agents should explain themselves to end users, especially focusing on how the soundness and completeness of the explanations impacts the fidelity of end users' mental models. Our findings suggest that completeness is more important than soundness: increasing completeness via certain information types helped participants' mental models and, surprisingly, their perception of the cost/benefit tradeoff of attending to the explanations. We also found that oversimplification, as per many commercial agents, can be a problem: when soundness was very low, participants experienced more mental demand and lost trust in the explanations, thereby reducing the likelihood\u00a0\u2026", "num_citations": "205\n", "authors": ["154"]}
{"title": "Interacting meaningfully with machine learning systems: Three experiments\n", "abstract": " Although machine learning is becoming commonly used in today's software, there has been little research into how end users might interact with machine learning systems, beyond communicating simple \u201cright/wrong\u201d judgments. If the users themselves could work hand-in-hand with machine learning systems, the users\u2019 understanding and trust of the system could improve and the accuracy of learning systems could be improved as well. We conducted three experiments to understand the potential for rich interactions between users and machine learning systems. The first experiment was a think-aloud study that investigated users\u2019 willingness to interact with machine learning reasoning, and what kinds of feedback users might give to machine learning systems. We then investigated the viability of introducing such feedback into machine learning systems, specifically, how to incorporate some of these types of user\u00a0\u2026", "num_citations": "199\n", "authors": ["154"]}
{"title": "A practical guide to controlled experiments of software engineering tools with human participants\n", "abstract": " Empirical studies, often in the form of controlled experiments, have been widely adopted in software engineering research as a way to evaluate the merits of new software engineering tools. However, controlled experiments involving human participants actually using new tools are still rare, and when they are conducted, some have serious validity concerns. Recent research has also shown that many software engineering researchers view this form of tool evaluation as too risky and too difficult to conduct, as they might ultimately lead to inconclusive or negative results. In this paper, we aim both to help researchers minimize the risks of this form of tool evaluation, and to increase their quality, by offering practical methodological guidance on designing and running controlled experiments with developers. Our guidance fills gaps in the empirical literature by explaining, from a practical perspective, options in the\u00a0\u2026", "num_citations": "197\n", "authors": ["154"]}
{"title": "Scaling up visual programming languages\n", "abstract": " The directness, immediacy, and simplicity of visual programming languages are appealing. The question is, can VPLs be effectively applied to large scale programming problems while retaining these characteristics. In scaling up, the problem is how to expand applicability without sacrificing the goals of better logic expression and understanding. From a size standpoint, scaling up refers to the programmer's ability to apply VPLs in larger programs. Such programs range from those requiring several days' work by a single programmer to programs requiring months of work, large programming teams, and large data structures. From a problem domain standpoint, scaling up refers to suitability for many kinds of problems. These range from visual application domains-such as user interface design or scientific visualization-to general purpose programming in such diverse areas as financial planning, simulations, and real\u00a0\u2026", "num_citations": "189\n", "authors": ["154"]}
{"title": "Tinkering and gender in end-user programmers' debugging\n", "abstract": " Earlier research on gender effects with software features intended to help problem-solvers in end-user debugging environments has shown that females are less likely to use unfamiliar software features. This poses a serious problem because these features may be key to helping them with debugging problems. Contrasting this with research documenting males' inclination for tinkering in unfamiliar environments, the question arises as to whether encouraging tinkering with new features would help females overcome the factors, such as low self-efficacy, that led to the earlier results. In this paper, we present an experiment with males and females in an end-user debugging setting, and investigate how tinkering behavior impacts several measures of their debugging success. Our results show that the factors of tinkering, reflection, and self-efficacy, can combine in multiple ways to impact debugging effectiveness\u00a0\u2026", "num_citations": "184\n", "authors": ["154"]}
{"title": "How programmers debug, revisited: An information foraging theory perspective\n", "abstract": " Many theories of human debugging rely on complex mental constructs that offer little practical advice to builders of software engineering tools. Although hypotheses are important in debugging, a theory of navigation adds more practical value to our understanding of how programmers debug. Therefore, in this paper, we reconsider how people go about debugging in large collections of source code using a modern programming environment. We present an information foraging theory of debugging that treats programmer navigation during debugging as being analogous to a predator following scent to find prey in the wild. The theory proposes that constructs of scent and topology provide enough information to describe and predict programmer navigation during debugging, without reference to mental states such as hypotheses. We investigate the scope of our theory through an empirical study of 10 professional\u00a0\u2026", "num_citations": "173\n", "authors": ["154"]}
{"title": "Visual object-oriented programming\n", "abstract": " More and more researchers and developers are recognizing the potential of visual programming to make OOP easier and less error-prone. Yet, in spite of much recent activity in the area of visual programming, there are still a number of unsolved problems. The purposes of this workshop were both to determine and to advance the state of the art for visual OOP by:", "num_citations": "168\n", "authors": ["154"]}
{"title": "Tell me more? The effects of mental model soundness on personalizing an intelligent agent\n", "abstract": " What does a user need to know to productively work with an intelligent agent? Intelligent agents and recommender systems are gaining widespread use, potentially creating a need for end users to understand how these systems operate in order to fix their agent's personalized behavior. This paper explores the effects of mental model soundness on such personalization by providing structural knowledge of a music recommender system in an empirical study. Our findings show that participants were able to quickly build sound mental models of the recommender system's reasoning, and that participants who most improved their mental models during the study were significantly more likely to make the recommender operate to their satisfaction. These results suggest that by helping end users understand a system's reasoning, intelligent agents may elicit more and better feedback, thus more closely aligning their output\u00a0\u2026", "num_citations": "165\n", "authors": ["154"]}
{"title": "WYSIWYT testing in the spreadsheet paradigm: An empirical evaluation\n", "abstract": " Is it possible to achieve some of the benefits of formal testing within the informal programming conventions of the spreadsheet paradigm? We have been working on an approach that attempts to do so via the development of a testing methodology for this paradigm. Our \"What You See Is What You Test\" (WYSIWYT) methodology supplements the convention by which spreadsheets provide automatic immediate visual feedback about values by providing automatic immediate visual feedback about \"testedness\". In previous work we described this methodology (G. Rothermal et al., 1998). We present empirical data about the methodology's effectiveness. Our results show that the use of the methodology was associated with significant improvement in testing effectiveness and efficiency, even with no training on the theory of testing or test adequacy that the model implements. These results may be due at least in part to the\u00a0\u2026", "num_citations": "156\n", "authors": ["154"]}
{"title": "Toward harnessing user feedback for machine learning\n", "abstract": " There has been little research into how end users might be able to communicate advice to machine learning systems. If this resource--the users themselves--could somehow work hand-in-hand with machine learning systems, the accuracy of learning systems could be improved and the users' understanding and trust of the system could improve as well. We conducted a think-aloud study to see how willing users were to provide feedback and to understand what kinds of feedback users could give. Users were shown explanations of machine learning predictions and asked to provide feedback to improve the predictions. We found that users had no difficulty providing generous amounts of feedback. The kinds of feedback ranged from suggestions for reweighting of features to proposals for new features, feature combinations, relational features, and wholesale changes to the learning algorithm. The results show that\u00a0\u2026", "num_citations": "152\n", "authors": ["154"]}
{"title": "Invited research overview: end-user programming\n", "abstract": " In the past few decades there has been considerable work on empowering end users to be able to write their own programs, and as a result, users are indeed doing so. In fact, we estimate that over 12 million people in American workplaces would say that they\" do programming\" at work, and almost 50 million people use spreadsheets or databases (and therefore may potentially program), compared to only 3 million professional programmers. The\" programming\" systems used by these end users include spreadsheet systems, web authoring tools, business process authoring tools such as Visual Basic, graphical languages for demonstrating the desired behavior of educational simulations, and even professional languages such as Java. The motivation for end-user programming is to have the computer be useful for each person's specific individual needs. While the empirical study of programming has been an HCI\u00a0\u2026", "num_citations": "142\n", "authors": ["154"]}
{"title": "A classification system for visual programming languages\n", "abstract": " The literature about visual programming languages (VPLs) has grown to the point where some kind of organization must be imposed. Such an organization would make it possible for researchers to classify their work in terms of its main areas of contribution, thereby helping other researchers to locate relevant papers easily and reliably. This then is the goal of a classification system\u2014to aid researchers in their search for relevant work.", "num_citations": "135\n", "authors": ["154"]}
{"title": "Effectiveness of end-user debugging software features: Are there gender issues?\n", "abstract": " Although gender differences in a technological world are receiving significant research attention, much of the research and practice has aimed at how society and education can impact the successes and retention of female computer science professionals-but the possibility of gender issues within software has received almost no attention. If gender issues exist with some types of software features, it is possible that accommodating them by changing these features can increase effectiveness, but only if we know what these issues are. In this paper, we empirically investigate gender differences for end users in the context of debugging spreadsheets. Our results uncover significant gender differences in self-efficacy and feature acceptance, with females exhibiting lower self-efficacy and lower feature acceptance. The results also show that these differences can significantly reduce females' effectiveness.", "num_citations": "123\n", "authors": ["154"]}
{"title": "Gender: An important factor in end-user programming environments?\n", "abstract": " A human-centric issue that has not been considered in the design of end-user programming environments is whether gender differences exist that are important to the design of these environments. Ignoring this issue would miss the opportunity of enhancing the effectiveness of end-user programmers by incorporating appropriate mechanisms to support gender-associated differences in decision making, learning, and problem solving. This paper takes a first step toward building a foundation for investigating this issue by surveying gender difference literature from five domains with an eye toward possible implications for end-user programming. We present a taxonomy of this literature, and derive a number of specific issues for each element of the taxonomy (stated as hypotheses). This foundation provides a starting point for organized investigations into issues that may be important for making breakthroughs in the\u00a0\u2026", "num_citations": "123\n", "authors": ["154"]}
{"title": "GenderMag: A method for evaluating software's gender inclusiveness\n", "abstract": " In recent years, research into gender differences has established that individual differences in how people problem-solve often cluster by gender. Research also shows that these differences have direct implications for software that aims to support users' problem-solving activities, and that much of this software is more supportive of problem-solving processes favored (statistically) more by males than by females. However, there is almost no work considering how software practitioners\u2014such as User Experience (UX) professionals or software developers\u2014can find gender-inclusiveness issues like these in their software. To address this gap, we devised the GenderMag method for evaluating problem-solving software from a gender-inclusiveness perspective. The method includes a set of faceted personas that bring five facets of gender difference research to life, and embeds use of the personas into a concrete\u00a0\u2026", "num_citations": "121\n", "authors": ["154"]}
{"title": "Adding apples and oranges\n", "abstract": " We define a unit system for end-user spreadsheets that is based on the concrete notion of units instead of the abstract concept of types. Units are derived from header information given by spreadsheets. The unit system contains concepts, such as dependent units, multiple units, and unit generalization, that allow the classification of spreadsheet contents on a more fine-grained level than types do. Also, because communication with the end user happens only in terms of objects that are contained in the spreadsheet, our system does not require end users to learn new abstract concepts of type systems.", "num_citations": "114\n", "authors": ["154"]}
{"title": "Interactive Visual Data Abstraction in a Declarative Visual Programming Language\n", "abstract": " Visual data abstraction is the concept of data abstraction for visual languages. In this paper, first we discuss how the requirements of data abstraction for visual languages differ from the requirements for traditional textual languages. We then present a declarative approach to visual data abstraction in the language Forms/3. Within the context of this system, issues of particular importance to declarative visual languages are examined. These issues include enforcing information hiding through visual techniques, supporting abstraction while preserving concreteness, conceptual simplicity and specification of a type's appearance and interactive behavior as part of its definition. Interactive behavior is seen to be part of the larger problem of event-handling in a declarative language. A significant feature is that all programming and execution are done in a fully-integrated visual manner, without requiring other languages or\u00a0\u2026", "num_citations": "109\n", "authors": ["154"]}
{"title": "Influence of visual technology on the evolution of language environments\n", "abstract": " The increasing influence of visual technology on language environments that has resulted from the increasing availability of workstations is discussed. An evolution that began with the relatively straightforward translation of textual techniques into corresponding visual techniques and has progressed to uses of visual techniques that have no natural parallel using purely textural techniques is traced. Visual user interfaces, visual editing, and visual languages are surveyed.< >", "num_citations": "107\n", "authors": ["154"]}
{"title": "Programming, problem solving, and self-awareness: Effects of explicit guidance\n", "abstract": " More people are learning to code than ever, but most learning opportunities do not explicitly teach the problem solving skills necessary to succeed at open-ended programming problems. In this paper, we present a new approach to impart these skills, consisting of: 1) explicit instruction on programming problem solving, which frames coding as a process of translating mental representations of problems and solutions into source code, 2) a method of visualizing and monitoring progression through six problem solving stages, 3) explicit, on-demand prompts for learners to reflect on their strategies when seeking help from instructors, and 4) context-sensitive help embedded in a code editor that reinforces the problem solving instruction. We experimentally evaluated the effects of our intervention across two 2-week web development summer camps with 48 high school students, finding that the intervention increased\u00a0\u2026", "num_citations": "103\n", "authors": ["154"]}
{"title": "Does continuous visual feedback aid debugging in direct-manipulation programming systems?\n", "abstract": " Continuous visual feedback is becoming a common feature in direct-manipulation programming systems of all klnds\u2014from demonstrational macro builders to spreadsheet packages to visual programming languages featuring direct manipulation. But does continuous visual feedback actually help in the domain of programming? There has been little investigation of this question, and what evidence there is from related domains points in conflicting directions. To advance what is known about this issue, we conducted an empirical study to determine whether the inclusion of continuous visual feedback into a direct-manipulation programming system helps with one particular task: debugging. Our results were that although continuous visual feedback did not significantly help with debugging in general, it did significantly help with debugging in some circumstances. Our results also indicate three factors that may help\u00a0\u2026", "num_citations": "103\n", "authors": ["154"]}
{"title": "Gender pluralism in problem-solving software\n", "abstract": " Although there has been significant research into gender regarding educational and workplace practices, there has been little awareness of gender differences as they pertain to software tools, such as spreadsheet applications, that try to support end users in problem-solving tasks. Although such software tools are intended to be gender agnostic, we believe that closer examination of this premise is warranted. Therefore, in this paper, we report an end-to-end investigation into gender differences with spreadsheet software. Our results showed gender differences in feature usage, feature-related confidence, and tinkering (playful exploration) with features. Then, drawing implications from these results, we designed and implemented features for our spreadsheet prototype that took the gender differences into account. The results of an evaluation on this prototype showed improvements for both males and females\u00a0\u2026", "num_citations": "100\n", "authors": ["154"]}
{"title": "Graphical definitions: Expanding spreadsheet languages through direct manipulation and gestures\n", "abstract": " In the past, attempts to extend the spreadsheet paradigm to support graphical objects, such as colored circles or user-defined graphical types, have led to approaches featuring either a direct way of creating objects graphically or strong compatibility with the spreadsheet paradigm, but not both. This inability to conveniently go beyond numbers and strings without straying outside the spreadsheet paradigm has been a limiting factor in the applicability of spreadsheet languages. In this article we present graphical definitions, an approach that removes this limitation, allowing both simple and complex graphical objects to be programmed directly using direct manipulation and gestures, in a manner that fits seamlessly within the spreadsheet paradigm. We  also describe an empirical study, in which subjects programmed such objects faster and with fewer errors using this approach than when using a traditional approach to\u00a0\u2026", "num_citations": "99\n", "authors": ["154"]}
{"title": "End-user software visualizations for fault localization\n", "abstract": " End-user programming has become the most common form of programming today. However, despite this growth, there has been little investigation into bringing the benefits of software visualization to end-user programmers. Evidence from the spreadsheet paradigm, probably the most widely used end-user environment, reveals that end users' programs often contain faults. We would like to integrate software visualization into these end-user environments to help end users deal with the reliability issues in their programs. Towards this end, we have devised several fault localization visualization techniques for spreadsheets. This paper describes these techniques and reports the results of a formative study---using tests created by end users---to investigate how these fault localization techniques compare. Our results reveal some strengths and weaknesses of each technique, and provide insights into the cost\u00a0\u2026", "num_citations": "94\n", "authors": ["154"]}
{"title": "Gender differences and programming environments: Across programming populations\n", "abstract": " Although there has been significant research into gender regarding educational and workplace practices, there has been little investigation of gender differences pertaining to problem solving with programming tools and environments. As a result, there is little evidence as to what role gender plays in programming tools---and what little evidence there is has involved mainly novice and end-user programmers in academic studies. This paper therefore investigates how widespread such phenomena are in industrial programming situations, considering three disparate programming populations involving almost 3000 people and three different programming platforms in industry. To accomplish this, we analyzed four industry\" legacy\" studies from a gender perspective, triangulating results against each other and against a new fifth study, also in industry. We investigated gender differences in software feature usage and in\u00a0\u2026", "num_citations": "92\n", "authors": ["154"]}
{"title": "Why-oriented end-user debugging of naive Bayes text classification\n", "abstract": " Machine learning techniques are increasingly used in intelligent assistants, that is, software targeted at and continuously adapting to assist end users with email, shopping, and other tasks. Examples include desktop SPAM filters, recommender systems, and handwriting recognition. Fixing such intelligent assistants when they learn incorrect behavior, however, has received only limited attention. To directly support end-user \u201cdebugging\u201d of assistant behaviors learned via statistical machine learning, we present a Why-oriented approach which allows users to ask questions about how the assistant made its predictions, provides answers to these \u201cwhy\u201d questions, and allows users to interactively change these answers to debug the assistant's current and future predictions. To understand the strengths and weaknesses of this approach, we then conducted an exploratory study to investigate barriers that participants could\u00a0\u2026", "num_citations": "91\n", "authors": ["154"]}
{"title": "Gender HCI: What about the software?\n", "abstract": " We use the term gender HCI (human-computer interaction) to refer to research into how software relates to gender differences. Our particular focus is on how gender-neutral software works, not on gender-oriented content. Specifically, we have concentrated on software aimed at supporting everyday users doing problem solving. Several of the hypotheses we developed in the first step of our investigative method predict that in a software environment with problem-solving features, gender differences will have a significant impact on the adoption and use of these features, due at least in part to differences related to risk perception and confidence. To maintain its creative edge, an organization must encourage a diversity of ideas", "num_citations": "91\n", "authors": ["154"]}
{"title": "Operational versus definitional: A perspective on programming paradigms\n", "abstract": " Various paradigms that support high-level programming are discussed independently of supporting languages. The paradigms are grouped according to their approach to problem solving. The operational approach describes step-by-step how to construct a solution. The demonstrational approach is a variation on it that illustrates the solution operationally for specific examples and lets the system generalize these example solutions for other cases. The definitional approach is different. It states properties about the solution to constrain it without describing how to compute it. These three approaches are viewed on a continuum from operational to definitional. A pure language solution to the problem of sorting a list into some linear order is presented for each paradigm.< >", "num_citations": "91\n", "authors": ["154"]}
{"title": "Explanatory debugging: Supporting end-user debugging of machine-learned programs\n", "abstract": " Many machine-learning algorithms learn rules of behavior from individual end users, such as task-oriented desktop organizers and handwriting recognizers. These rules form a \u201cprogram\u201d that tells the computer what to do when future inputs arrive. Little research has explored how an end user can debug these programs when they make mistakes. We present our progress toward enabling end users to debug these learned programs via a Natural Programming methodology. We began with a formative study exploring how users reason about and correct a text-classification program. From the results, we derived and prototyped a concept based on \u201cexplanatory debugging\u201d, then empirically evaluated it. Our results contribute methods for exposing a learned program's logic to end users and for eliciting user corrections to improve the program's predictions.", "num_citations": "89\n", "authors": ["154"]}
{"title": "Impact of interruption style on end-user debugging\n", "abstract": " Although researchers have begun to explicitly support end-user programmers' debugging by providing information to help them find bugs, there is little research addressing the proper mechanism to alert the user to this information. The choice of alerting mechanism can be important, because as previous research has shown, different interruption styles have different potential advantages and disadvantages. To explore impacts of interruptions in the end-user debugging domain, this paper describes an empirical comparison of two interruption styles that have been used to alert end-user programmers to debugging information. Our results show that negotiated-style interruptions were superior to immediate-style interruptions in several issues of importance to end-user debugging, and further suggest that a reason for this superiority may be that immediate-style interruptions encourage different debugging strategies.", "num_citations": "88\n", "authors": ["154"]}
{"title": "Testing homogeneous spreadsheet grids with the\" what you see is what you test\" methodology\n", "abstract": " Although there has been recent research into ways to design environments that enable end users to create their own programs, little attention has been given to helping these end users systematically test their programs. To help address this need in spreadsheet systems (the most widely used type of end-user programming language), we previously introduced a visual approach to systematically testing individual cells in spreadsheet systems. However, the previous approach did not scale well in the presence of largely homogeneous grids, which introduce problems somewhat analogous to the array-testing problems of imperative programs. We present two approaches to spreadsheet testing that explicitly support such grids. We present the algorithms, time complexities, and performance data comparing the two approaches. This is part of our continuing work to bring to end users at least some of the benefits of\u00a0\u2026", "num_citations": "88\n", "authors": ["154"]}
{"title": "Using information scent to model the dynamic foraging behavior of programmers in maintenance tasks\n", "abstract": " In recent years, the software engineering community has begun to study program navigation and tools to support it. Some of these navigation tools are very useful, but they lack a theoretical basis that could reduce the need for ad hoc tool building approaches by explaining what is fundamentally necessary in such tools. In this paper, we present PFIS (Programmer Flow by Information Scent), a model and algorithm of programmer navigation during software maintenance. We also describe an experimental study of expert programmers debugging real bugs described in real bug reports for a real Java application. We found that PFIS'performance was close to aggregated human decisions as to where to navigate, and was significantly better than individual programmers' decisions.", "num_citations": "87\n", "authors": ["154"]}
{"title": "What is end-user software engineering and why does it matter?\n", "abstract": " End-user programming has become ubiquitous, so much so that there are more end-user programmers today than there are professional programmers. End-user programming empowers\u2014but to do what? Make really bad decisions based on really bad programs? Enter software engineering\u2019s focus on quality. Considering software quality is necessary, because there is ample evidence that the programs end users create are filled with expensive errors. In this paper, I consider what happens when we add to end-user programming environments considerations of software quality, going beyond the \u201ccreate a program\u201d aspect of end-user programming. I describe a philosophy to software engineering for end users, and then survey several projects in this area. A basic premise is that end-user software engineering can only succeed to the extent that it respects the fact that the user probably has little expertise or\u00a0\u2026", "num_citations": "86\n", "authors": ["154"]}
{"title": "Fixing the program my computer learned: Barriers for end users, challenges for the machine\n", "abstract": " The results of a machine learning from user behavior can be thought of as a program, and like all programs, it may need to be debugged. Providing ways for the user to debug it matters, because without the ability to fix errors users may find that the learned program's errors are too damaging for them to be able to trust such programs. We present a new approach to enable end users to debug a learned program. We then use an early prototype of our new approach to conduct a formative study to determine where and when debugging issues arise, both in general and also separately for males and females. The results suggest opportunities to make machine-learned programs more effective tools.", "num_citations": "86\n", "authors": ["154"]}
{"title": "An Information Foraging Theory Perspective on Tools for Debugging, Refactoring, and Reuse Tasks\n", "abstract": " Theories of human behavior are an important but largely untapped resource for software engineering research. They facilitate understanding of human developers\u2019 needs and activities, and thus can serve as a valuable resource to researchers designing software engineering tools. Furthermore, theories abstract beyond specific methods and tools to fundamental principles that can be applied to new situations. Toward filling this gap, we investigate the applicability and utility of Information Foraging Theory (IFT) for understanding information-intensive software engineering tasks, drawing upon literature in three areas: debugging, refactoring, and reuse. In particular, we focus on software engineering tools that aim to support information-intensive activities, that is, activities in which developers spend time seeking information. Regarding applicability, we consider whether and how the mathematical equations within IFT\u00a0\u2026", "num_citations": "85\n", "authors": ["154"]}
{"title": "Principles of a debugging-first puzzle game for computing education\n", "abstract": " Although there are many systems designed to engage people in programming, few explicitly teach the subject, expecting learners to acquire the necessary skills on their own as they create programs from scratch. We present a principled approach to teach programming using a debugging game called Gidget, which was created using a unique set of seven design principles. A total of 44 teens played it via a lab study and two summer camps. Principle by principle, the results revealed strengths, problems, and open questions for the seven principles. Taken together, the results were very encouraging: learners were able to program with conditionals, loops, and other programming concepts after using the game for just 5 hours.", "num_citations": "80\n", "authors": ["154"]}
{"title": "Automated test case generation for spreadsheets\n", "abstract": " Spreadsheet languages, which include commercial spreadsheets and various research systems, have had a substantial impact on end-user computing. Research shows, however, that spreadsheets often contain faults. Thus, in previous work, we presented a methodology that assists spreadsheet users in testing their spreadsheet formulas. Our empirical studies have shown that this methodology can help end-users test spreadsheets more adequately and efficiently; however, the process of generating test cases can still represent a significant impediment. To address this problem, we have been investigating how to automate test case generation for spreadsheets in ways that support incremental testing and provide immediate visual feedback. We have utilized two techniques for generating test cases, one involving random selection and one involving a goal-oriented approach. We describe these techniques, and\u00a0\u2026", "num_citations": "80\n", "authors": ["154"]}
{"title": "Gender-Inclusiveness Personas vs. Stereotyping: Can we have it both ways?\n", "abstract": " Personas often aim to improve product designers' ability to\" see through the eyes of\" target users through the empathy personas can inspire-but personas are also known to promote stereotyping. This tension can be particularly problematic when personas (who, of course as\" people\" have genders) are used to promote gender inclusiveness-because reinforcing stereotypical perceptions can run counter to gender inclusiveness. In this paper we explicitly investigate this tension through a new approach to personas: one that includes multiple photos (of males and females) for a single persona. We compared this approach to an identical persona with only one photo using a controlled laboratory study and an eye-tracking study. Our goal was to answer the following question: is it possible for personas to encourage product designers to engage with personas while at the same avoiding promoting gender stereotyping\u00a0\u2026", "num_citations": "77\n", "authors": ["154"]}
{"title": "Future of end-user software engineering: beyond the silos\n", "abstract": " End-user software engineering (EUSE) is a research area that aims to invent new kinds of technologies that collaborate with end users to improve the quality of their software. The practice that EUSE research aims to support is end users using new tools and methods to improve the quality of the software that they and other end users have created. There is a need for this outcome because research shows both that the number of end users creating their own software greatly exceeds the number of professional software developers, and that the software they create is riddled with errors. In this paper, we describe the present state of EUSE, and challenges in moving forward toward a bright future. We show how the future of EUSE may become over-siloed, restricting future researchers' vision of what can be achieved. We then show that focusing on the in-the-moment intents of end-user developers can be used to derive\u00a0\u2026", "num_citations": "77\n", "authors": ["154"]}
{"title": "Is it easier to write matrix manipulation programs visually or textually? An empirical study\n", "abstract": " Empirical studies comparing the effectiveness of visual languages versus textual languages have rarely been attempted. We describe an experiment conducted on programmers solving vector and matrix manipulation tasks using the visual language Forms/3, the textual language Pascal, and a textual matrix manipulation language with the capabilities of APL. Our motivation, experimental approach, some of the difficulties experienced in attempting this type of empirical study, and a summary of the experimental results and insights gained are presented.< >", "num_citations": "76\n", "authors": ["154"]}
{"title": "Finding gender-inclusiveness software issues with GenderMag: A field investigation\n", "abstract": " Gender inclusiveness in computing settings is receiving a lot of attention, but one potentially critical factor has mostly been overlooked--software itself. To help close this gap, we recently created GenderMag, a systematic inspection method to enable software practitioners to evaluate their software for issues of gender-inclusiveness. In this paper, we present the first real-world investigation of software practitioners' ability to identify gender-inclusiveness issues in software they create/maintain using this method. Our investigation was a multiple-case field study of software teams at three major US technology organizations. The results were that, using GenderMag to evaluate software, these software practitioners identified a surprisingly high number of gender-inclusiveness issues: 25% of the software features they evaluated had gender-inclusiveness issues.", "num_citations": "75\n", "authors": ["154"]}
{"title": "Open Source barriers to entry, revisited: A sociotechnical perspective\n", "abstract": " Research has revealed that significant barriers exist when entering Open-Source Software (OSS) communities and that women disproportionately experience such barriers. However, this research has focused mainly on social/cultural factors, ignoring the environment itself---the tools and infrastructure. To shed some light onto how tools and infrastructure might somehow factor into OSS barriers to entry, we conducted a field study with five teams of software professionals, who worked through five use-cases to analyze the tools and infrastructure used in their OSS projects. These software professionals found tool/infrastructure barriers in 7% to 71% of the use-case steps that they analyzed, most of which are tied to newcomer barriers that have been established in the literature. Further, over 80% of the barrier types they found include attributes that are biased against women.", "num_citations": "74\n", "authors": ["154"]}
{"title": "Slicing spreadsheets: An integrated methodology for spreadsheet testing and debugging\n", "abstract": " Spreadsheet languages, which include commercial spreadsheets and various research systems, have proven to be flexible tools in many domain specific settings. Research shows, however, that spreadsheets often contain faults. We would like to provide at least some of the benefits of formal testing and debugging methodologies to spreadsheet developers. This paper presents an integrated testing and debugging methodology for spreadsheets. To accommodate the modeless and incremental development, testing and debugging activities that occur during spreadsheet creation, our methodology is tightly integrated into the spreadsheet environment. To accommodate the users of spreadsheet languages, we provide an interface to our methodology that does not require an understanding of testing and debugging theory, and that takes advantage of the immediate visual feedback that is characteristic of the\u00a0\u2026", "num_citations": "74\n", "authors": ["154"]}
{"title": "Scents in programs: Does information foraging theory apply to program maintenance?\n", "abstract": " During maintenance, professional developers generate and test many hypotheses about program behavior, but they also spend much of their time navigating among classes and methods. Little is known, however, about how professional developers navigate source code and the extent to which their hypotheses relate to their navigation. A lack of understanding of these issues is a barrier to tools aiming to reduce the large fraction of time developers spend navigating source code. In this paper, we report on a study that makes use of information foraging theory to investigate how professional developers navigate source code during maintenance. Our results showed that information foraging theory was a significant predictor of the developers' maintenance behavior, and suggest how tools used during maintenance can build upon this result, simply by adding word analysis to their reasoning systems.", "num_citations": "73\n", "authors": ["154"]}
{"title": "Representation design benchmarks: a design-time aid for VPL navigable static representations\n", "abstract": " A weakness of many interactive visual programming languages (VPLs) is their static representations. Lack of an adequate static representation places a heavy cognitive burden on a VPL's programmers, because they must remember potentially long dynamic sequences of screen displays in order to understand a previously written program. However, although this problem is widely acknowledged, research on how to design better static representations for interactive VPLs is still in its infancy.Building upon thecognitive dimensionsdeveloped for programming languages by cognitive psychologists Green and others, we have developed a set of concrete benchmarks for VPL designers to use when designing new static representations. These benchmarks provide design-time information that can be used to improve a VPL's static representation.", "num_citations": "70\n", "authors": ["154"]}
{"title": "The impact of software engineering research on modern progamming languages\n", "abstract": " Software engineering research and programming language design have enjoyed a symbiotic relationship, with traceable impacts since the 1970s, when these areas were first distinguished from one another. This report documents this relationship by focusing on several major features of current programming languages: data and procedural abstraction, types, concurrency, exceptions, and visual programming mechanisms. The influences are determined by tracing references in publications in both fields, obtaining oral histories from language designers delineating influences on them, and tracking cotemporal research trends and ideas as demonstrated by workshop topics, special issue publications, and invited talks in the two fields. In some cases there is conclusive data supporting influence. In other cases, there are circumstantial arguments (i.e., cotemporal ideas) that indicate influence. Using this approach, this\u00a0\u2026", "num_citations": "69\n", "authors": ["154"]}
{"title": "End-user debugging strategies: A sensemaking perspective\n", "abstract": " Despite decades of research into how professional programmers debug, only recently has work emerged about how end-user programmers attempt to debug programs. Without this knowledge, we cannot build tools to adequately support their needs. This article reports the results of a detailed qualitative empirical study of end-user programmers' sensemaking about a spreadsheet's correctness. Using our study's data, we derived a sensemaking model for end-user debugging and categorized participants' activities and verbalizations according to this model, allowing us to investigate how participants went about debugging. Among the results are identification of the prevalence of information foraging during end-user debugging, two successful strategies for traversing the sensemaking model, potential ties to gender differences in the literature, sensemaking sequences leading to debugging progress, and sequences\u00a0\u2026", "num_citations": "67\n", "authors": ["154"]}
{"title": "A debugging perspective on end-user mashup programming\n", "abstract": " In recent years, systems have emerged that enable end users to \u201cmash\u201d together existing web services to build new web sites. However, little is known about how well end users succeed at building such mashups, or what they do if they do not succeed at their first attempt. To help fill this gap, we took a fresh look, from a debugging perspective, at the approaches of end users as they attempted to create mashups. Our results reveal the end users' debugging strategies and strategy barriers, the gender differences between the debugging strategies males and females followed and the features they used, and finally how their debugging successes and difficulties interacted with their design behaviors.", "num_citations": "67\n", "authors": ["154"]}
{"title": "End-user mashup programming: Through the design lens\n", "abstract": " Programming has recently become more common among ordinary end users of computer systems. We believe that these end-user programmers are not just coders but also designers, in that they interlace making design decisions with coding rather than treating them as two separate phases. To better understand and provide support for the programming and design needs of end users, we propose a design theory-based approach to look at end-user programming. Toward this end, we conducted a think-aloud study with ten end users creating a web mashup. By analyzing users' verbal and behavioral data using Sch\u00f6n's reflection-in-action design model and the notion of ideations from creativity literature, we discovered insights into end-user programmers' problem-solving attempts, successes, and obstacles, with accompanying implications for the design of end-user programming environments for mashups. The\u00a0\u2026", "num_citations": "64\n", "authors": ["154"]}
{"title": "Testing vs. code inspection vs. what else?: male and female end users' debugging strategies\n", "abstract": " Little is known about the strategies end-user programmers use in debugging their programs, and even less is known about gender differences that may exist in these strategies. Without this type of information, designers of end-user programming systems cannot know the\" target\" at which to aim, if they are to support male and female end-user programmers. We present a study investigating this issue. We asked end-user programmers to debug spreadsheets and to describe their debugging strategies. Using mixed methods, we analyzed their strategies and looked for relationships among participants' strategy choices, gender, and debugging success. Our results indicate that males and females debug in quite different ways, that opportunities for improving support for end-user debugging strategies for both genders are abundant, and that tools currently available to end-user debuggers may be especially deficient in\u00a0\u2026", "num_citations": "63\n", "authors": ["154"]}
{"title": "End-user programming in the wild: A field study of CoScripter scripts\n", "abstract": " Although a new class of languages has emerged to enable end users to create their own Web applications, little is known about how end-user programmers actually use such languages in the real world. In this paper, we report a field study on over 1400 scripts collected from the Internet which were created by early adopters of CoScripter, a Web macro programming-by-demonstration language. We contrast these Internet scripts with those written by users inside IBM, and describe script usage and re-usage patterns, features used, and users' clever workarounds for features not present in the language. The results show how users grapple with such programming notions as repetition, generalization, and reuse, sometimes inventing their own devices for these. Finally, we discuss the many scripts we found with social implications, whose purposes were to circumvent intended rules, regulations, and usage norm\u00a0\u2026", "num_citations": "62\n", "authors": ["154"]}
{"title": "Integrating automated test generation into the WYSIWYT spreadsheet testing methodology\n", "abstract": " Spreadsheet languages, which include commercial spreadsheets and various research systems, have had a substantial impact on end-user computing. Research shows, however, that spreadsheets often contain faults. Thus, in previous work we presented a methodology that helps spreadsheet users test their spreadsheet formulas. Our empirical studies have shown that end users can use this methodology to test spreadsheets more adequately and efficiently; however, the process of generating test cases can still present a significant impediment. To address this problem, we have been investigating how to incorporate automated test case generation into our testing methodology in ways that support incremental testing and provide immediate visual feedback. We have used two techniques for generating test cases, one involving random selection and one involving a goal-oriented approach. We describe these\u00a0\u2026", "num_citations": "62\n", "authors": ["154"]}
{"title": "Trials and Tribulations of Developers of Intelligent Systems: A Field Study\n", "abstract": " Intelligent systems are gaining in popularity and receiving increased media attention, but little is known about how people actually go about developing them. In this paper, we attempt to fill this gap through a set of field interviews that investigate how people develop intelligent systems that incorporate machine learning algorithms. The developers we interviewed were experienced at working with machine learning algorithms and dealing with the large amounts of data needed to develop intelligent systems. Despite their level of experience, we learned that they struggle to establish a repeatable process. They described problems with each step of the processes they perform, as well as cross-cutting issues that pervade multiple steps of their processes. The unique difficulties that developers like these face seem to point to a need for software engineering advances that address such machine learning systems, and we\u00a0\u2026", "num_citations": "60\n", "authors": ["154"]}
{"title": "The whats and hows of programmers' foraging diets\n", "abstract": " One of the least studied areas of Information Foraging Theory is diet: the information foragers choose to seek. For example, do foragers choose solely based on cost, or do they stubbornly pursue certain diets regardless of cost? Do their debugging strategies vary with their diets? To investigate\" what\" and\" how\" questions like these for the domain of software debugging, we qualitatively analyzed 9 professional developers' foraging goals, goal patterns, and strategies. Participants spent 50% of their time foraging. Of their foraging, 58% fell into distinct dietary patterns-mostly in patterns not previously discussed in the literature. In general, programmers' foraging strategies leaned more heavily toward enrichment than we expected, but different strategies aligned with different goal types. These and our other findings help fill the gap as to what programmers' dietary goals are and how their strategies relate to those goals.", "num_citations": "60\n", "authors": ["154"]}
{"title": "Reactive information foraging: An empirical investigation of theory-based recommender systems for programmers\n", "abstract": " Information Foraging Theory (IFT) has established itself as an important theory to explain how people seek information, but most work has focused more on the theory itself than on how best to apply it. In this paper, we investigate how to apply a reactive variant of IFT (Reactive IFT) to design IFT-based tools, with a special focus on such tools for ill-structured problems. Toward this end, we designed and implemented a variety of recommender algorithms to empirically investigate how to help people with the ill-structured problem of finding where to look for information while debugging source code. We varied the algorithms based on scent type supported (words alone vs. words+ code structure), and based on use of foraging momentum to estimate rapidity of foragers' goal changes. Our empirical results showed that (1) using both words and code structure significantly improved the ability of the algorithms to\u00a0\u2026", "num_citations": "59\n", "authors": ["154"]}
{"title": "Reactive information foraging for evolving goals\n", "abstract": " Information foraging models have predicted the navigation paths of people browsing the web and (more recently) of programmers while debugging, but these models do not explicitly model users' goals evolving over time. We present a new information foraging model called PFIS2 that does model information seeking with potentially evolving goals. We then evaluated variants of this model in a field study that analyzed programmers' daily navigations over a seven-month period. Our results were that PFIS2 predicted users' navigation remarkably well, even though the goals of navigation, and even the information landscape itself, were changing markedly during the pursuit of information.", "num_citations": "58\n", "authors": ["154"]}
{"title": "Implementing level 4 liveness in declarative visual programming languages\n", "abstract": " An increasingly common characteristic in visual programming languages (VPLs) is level 4 liveness-the constant monitoring of the system state with continuous redisplay as events arrive and computations progress. However, level 4 liveness can be expensive. We present an implementation method that supports level 4 liveness in declarative VPLs, ensuring without \"unreasonable\" cost that all values on the screen are correctly updated as computations progress. The method is especially well suited for the growing class of declarative VPLs that display continuously time varying calculations and graphics, such as GUI specification VPLs, event based or reactive VPLs, scientific visualization VPLs, or graphical simulation VPLs.", "num_citations": "58\n", "authors": ["154"]}
{"title": "Can feature design reduce the gender gap in end-user software development environments?\n", "abstract": " Recent research has begun to report that female end-user programmers are often more reluctant than males to employ features that are useful for testing and debugging. These earlier findings suggest that, unless such features can be changed in some appropriate way, there are likely to be important gender differences in end-user programmerspsila benefits from these features. In this paper, we compare end-user programmerspsila feature usage in an environment that supports end-user debugging, against an extension of the same environment with two features designed to help ameliorate the effects of low self-efficacy. Our results show ways in which these features affect female versus male enduser programmerspsila self-efficacy, attitudes, usage of testing and debugging features, and performance.", "num_citations": "57\n", "authors": ["154"]}
{"title": "FAR: An end-user language to support cottage e-services\n", "abstract": " E-commerce has begun to evolve beyond simple web pages to more sophisticated ways of conducting e-business transactions, such as through electronic advertising, negotiation, and delivery. However, to participate in these advances requires the skills of professional programmers, and end-user owners of small businesses often cannot justify this expense. In this paper, we present FAR, an end-user language to offer and deliver e-services. The novel aspects of FAR are its support of small e-services and its multiparadigm approach to combining ideas from spreadsheets and rule-based programming with drag-and-drop web page layout devices.", "num_citations": "55\n", "authors": ["154"]}
{"title": "Modeling programmer navigation: A head-to-head empirical evaluation of predictive models\n", "abstract": " Software developers frequently need to perform code maintenance tasks, but doing so requires time-consuming navigation through code. A variety of tools are aimed at easing this navigation by using models to identify places in the code that a developer might want to visit, and then providing shortcuts so that the developer can quickly navigate to those locations. To date, however, only a few of these models have been compared head-to-head to assess their predictive accuracy. In particular, we do not know which models are most accurate overall, which are accurate only in certain circumstances, and whether combining models could enhance accuracy. Therefore, we have conducted an empirical study to evaluate the accuracy of a broad range of models for predicting many different kinds of code navigations in sample maintenance tasks. Overall, we found that models tended to perform best if they took into\u00a0\u2026", "num_citations": "53\n", "authors": ["154"]}
{"title": "You Are the Only Possible Oracle: Effective Test Selection for End Users of Interactive Machine Learning Systems\n", "abstract": " How do you test a program when only a single user, with no expertise in software testing, is able to determine if the program is performing correctly? Such programs are common today in the form of machine-learned classifiers. We consider the problem of testing this common kind of machine-generated program when the only oracle is an end user: e.g., only you can determine if your email is properly filed. We present test selection methods that provide very good failure rates even for small test suites, and show that these methods work in both large-scale random experiments using a \u201cgold standard\u201d and in studies with real users. Our methods are inexpensive and largely algorithm-independent. Key to our methods is an exploitation of properties of classifiers that is not possible in traditional software testing. Our results suggest that it is plausible for time-pressured end users to interactively detect failures-even very\u00a0\u2026", "num_citations": "52\n", "authors": ["154"]}
{"title": "Integrating rich user feedback into intelligent user interfaces\n", "abstract": " The potential for machine learning systems to improve via a mutually beneficial exchange of information with users has yet to be explored in much detail. Previously, we found that users were willing to provide a generous amount of rich feedback to machine learning systems, and that the types of some of this rich feedback seem promising for assimilation by machine learning algorithms. Following up on those findings, we ran an experiment to assess the viability of incorporating real-time keyword-based feedback in initial training phases when data is limited. We found that rich feedback improved accuracy but an initial unstable period often caused large fluctuations in classifier behavior. Participants were able to give feedback by relying heavily on system communication in order to respond to changes. The results show that in order to benefit from the user's knowledge, machine learning systems must be able to\u00a0\u2026", "num_citations": "52\n", "authors": ["154"]}
{"title": "Software engineering for visual programming languages\n", "abstract": " Visual programming languages (VPLs) are becoming increasingly common in several domains. For example, visual programming languages or sublanguages are becoming the most common way to do some kinds of GUI programming, are becoming the most common way of specifying visualization graphics depicting scientific data, and are also starting to appear as macro generators for end-user applications. However, despite the increase in the use of VPLs for these and other programming tasks, there has been almost no attention to software engineering support mechanisms when working in these languages. Visual programming is programming in which more than one dimension is used to convey semantics [3]. Examples of such additional dimensions are the use of multidimensional objects, the use of spatial relationships, or the use of the time dimension to specify \u201cbefore-after\u201d semantic relationships. Each such potentially significant object or relationship is a token (just as in traditional textual programming languages each word is a token) and the collection of one or more such tokens is a visual expression. Examples of visual expressions used in visual programming include diagrams, free-hand sketches, icons, or demonstrations of actions performed by graphical objects. When a programming language's (semantically significant) syntax includes visual expressions, the programming language is a visual program-ming language.", "num_citations": "52\n", "authors": ["154"]}
{"title": "Scaling up a What you see is what you test methodology to spreadsheet grids\n", "abstract": " Although there has been considerable research into ways to design visual programming environments to improve the processes of creating new programs and of understanding existing ones, little attention has been given to helping users of these environments test their programs. This feature would be particularly important for systems aimed at end users, since testing is the primary device they use to determine whether their programs are correct. To help address this need, we introduce two visual approaches to testing large grids in spreadsheet systems. This work scales up a visual testing methodology we previously developed for individual cells. The approaches are tightly integrated into Forms/3, a visual spreadsheet language, and communication with the user happens solely through the use of checkbox devices and coloring mechanisms. The intent of this work is to bring to end users at least some of the\u00a0\u2026", "num_citations": "51\n", "authors": ["154"]}
{"title": "Testing strategies for form-based visual programs\n", "abstract": " Form based visual programming languages, which include electronic spreadsheets and a variety of research systems, have had a substantial impact on end user computing. Research shows that form based visual programs often contain faults, and that their creators often have unwarranted confidence in the reliability of their programs. Despite this evidence, we find no discussion in the research literature of techniques for testing or assessing the reliability of form based visual programs. The paper addresses this lack. We describe differences between the form based and imperative programming paradigms, and discuss effects these differences have on strategies for testing form based programs. We then present several test adequacy criteria for form based programs, and illustrate their application. We show that an analogue to the traditional \"all-uses\" dataflow test adequacy criterion is well suited for code based\u00a0\u2026", "num_citations": "49\n", "authors": ["154"]}
{"title": "Toward visual programming languages for steering scientific computations\n", "abstract": " Imagine running a computationally intensive model and being able not only to visualize the data as soon as results start emerging, but also to experiment with and change the underlying calculations in midstream, all with a consistent visual interface. This scenario represents a marriage of these two areas: visual programming languages and steering. We classified these two areas of research in six dimensions to provide insights and to suggest future research directions. The first four measure how thoroughly a system fulfils significant attributes of the requirements of a scenario (which is presented). The fifth and sixth dimensions help clarify the advantages and disadvantages of different approaches by looking at the ways they use various programming paradigms. The dimensions are: the system's steering capabilities; the power and visual extent of the interface; the level of support for preexisting scientific application\u00a0\u2026", "num_citations": "49\n", "authors": ["154"]}
{"title": "Interactive, visual fault localization support for end-user programmers\n", "abstract": " End-user programmers are writing an unprecedented number of programs, primarily using languages and environments that incorporate a number of interactive and visual programming techniques. To help these users debug these programs, we have developed an entirely visual, interactive approach to fault localization. This paper presents the approach. We also present the results of a think-aloud study that examined interactive, human-centric issues that arise in end-user debugging using a fault localization approach. Our results provide insights into the contributions such approaches can make to the end-user debugging process.", "num_citations": "48\n", "authors": ["154"]}
{"title": "Strategies and behaviors of end-user programmers with interactive fault localization\n", "abstract": " End-user programmers are writing an unprecedented number of programs, due in large part to the significant effort put forth to bring programming power to end users. Unfortunately, this effort has not been supplemented by a comparable effort to increase the correctness of these often faulty programs. To address this need, we have been working towards bringing fault localization techniques to end users. In order to understand how end users are affected by and interact with such techniques, we conducted a think-aloud study, examining the interactive, human-centric ties between end-user debugging and a fault localization technique. Our results provide insights into the contributions such techniques can make to an interactive end-user debugging process.", "num_citations": "48\n", "authors": ["154"]}
{"title": "How well do professional developers test with code coverage visualizations? An empirical study\n", "abstract": " Despite years of availability of testing tools, professional software developers still seem to need better support to determine the effectiveness of their tests. Without improvements in this area, inadequate testing of software seems likely to remain a major problem. To address this problem, industry and researchers have proposed systems that visualize \"testedness\" for end-user and professional developers. Empirical studies of such systems for end-user programmers have begun to show success at helping end users write more effective tests. Encouraged by this research, we examined the effect that code coverage visualizations have on the effectiveness of test cases that professional software developers write. This paper presents the results of an empirical study conducted using code coverage visualizations found in a commercially available programming environment. Our results reveal how this kind of code\u00a0\u2026", "num_citations": "47\n", "authors": ["154"]}
{"title": "Steering programs via time travel\n", "abstract": " The environments that programmers traditionally use for problem-solving-with separate modes and tools for writing, compiling, testing, visualizing and debugging-derive their basic structure from historical accident, and take little advantage of human-computer interaction (HCI) research into the cognitive issues of programming. We believe that neglect of these issues impedes programmers' ability to produce reliable, maintainable software. Visual programming languages (VPLs) have begun to address this problem by creating more flexible, less modal programming environments, and we have taken a step further in this direction. In this paper, we describe a VPL in which programmers can modelessly steer as they specify, visualize, explore and alter the behavior of a program while traveling through the program's logical time. This approach supports two often-neglected cognitive principles that HCI research shows\u00a0\u2026", "num_citations": "46\n", "authors": ["154"]}
{"title": "On to the real world: Gender and self-efficacy in Excel\n", "abstract": " Although there have been a number of studies of end-user software development tasks, few of them have considered gender issues for real end-user developers in real-world environments for end-user programming. In order to be trusted, the results of such laboratory studies must always be re-evaluated with fewer controls, more closely reflecting real-world conditions. Therefore, the research question in this paper is whether the results of a gender HCI controlled study generalize - to real-world end-user developers, in a real-world spreadsheet environment, using a real-world spreadsheet. Our findings are that the concepts revealed by the original laboratory study appear to be quite robust, being demonstrated in multiple ways in this real-world environment.", "num_citations": "44\n", "authors": ["154"]}
{"title": "A declarative approach to event-handling in visual programming languages\n", "abstract": " The authors address the question of event-handling for declarative visual languages. In the approach presented, system-level, interactive, and user-defined events are fully-supported, while still maintaining the property of referential transparency. An approach to time termed temporal assignment provides a unifying mechanism for events to be defined as ordinary sequences of values, and conversely for ordinary sequences of values to be defined as events. This allows event-handling without additional concepts, and in particular provides a natural means for the user to define higher-level events of any kind.< >", "num_citations": "43\n", "authors": ["154"]}
{"title": "Supporting end-user debugging: what do users want to know?\n", "abstract": " Although researchers have begun to explicitly support end-user programmers' debugging by providing information to help them find bugs, there is little research addressing the right content to communicate to these users. The specific semantic content of these debugging communications matters because, if the users are not actually seeking the information the system is providing, they are not likely to attend to it. This paper reports a formative empirical study that sheds light on what end users actually want to know in the course of debugging a spreadsheet, given the availability of a set of interactive visual testing and debugging features. Our results provide in sights into end-user debuggers' information gaps, and further suggest opportunities to improve end-user debugging systems' support for the things end-user debuggers actually want to know.", "num_citations": "42\n", "authors": ["154"]}
{"title": "A seamless integration of algorithm animation into a visual programming language\n", "abstract": " Until now, only users of textual programming languages have enjoyed the fruits of algorithm animation. Users of visual programming languages (VPLs) have been deprived of the unique semantic insights algorithm animation offers, insights that would foster the understanding and debugging of visual programs. To begin solving this shortcoming, we have seamlessly integrated algorithm animation capabilities into Forms/3, a declarative VPL in which evaluation is the continuous maintenance of a network of one-way constraints. Our results show that a VPL that uses this constraint-based evaluation model can provide features not found in other algorithm animation systems.", "num_citations": "42\n", "authors": ["154"]}
{"title": "Foraging among an overabundance of similar variants\n", "abstract": " Foraging among too many variants of the same artifact can be problematic when many of these variants are similar. This situation, which is largely overlooked in the literature, is commonplace in several types of creative tasks, one of which is exploratory programming. In this paper, we investigate how novice programmers forage through similar variants. Based on our results, we propose a refinement to Information Foraging Theory (IFT) to include constructs about variation foraging behavior, and propose refinements to computational models of IFT to better account for foraging among variants.", "num_citations": "38\n", "authors": ["154"]}
{"title": "Mining problem-solving strategies from HCI data\n", "abstract": " Can we learn about users' problem-solving strategies by observing their actions? This article introduces a data mining system that extracts complex behavioral patterns from logged user actions to discover users' high-level strategies. Our application domain is an HCI study aimed at revealing users' strategies in an end-user debugging task and understanding how the strategies relate to gender and to success. We cast this problem as a sequential pattern discovery problem, where user strategies are manifested as sequential behavior patterns. Problematically, we found that the patterns discovered by standard data mining algorithms were difficult to interpret and provided limited information about high-level strategies. To help interpret the patterns as strategies, we examined multiple ways of clustering the patterns into meaningful groups. This collectively led to interesting findings about users' behavior in terms of both\u00a0\u2026", "num_citations": "38\n", "authors": ["154"]}
{"title": "Spreadsheet Programming.\n", "abstract": " Spreadsheets are among the most widely used programming systems in the world. Individuals and businesses use spreadsheets for a wide variety of applications, ranging from performing simple calculations to building complex financial models. In this article, we first discuss how spreadsheet programs are actually functional programs. We then describe concepts in spreadsheet programming, followed by a brief history of spreadsheet systems. Widespread use of spreadsheets, coupled with their high error-proneness and the impact of spreadsheet errors, has motivated research into techniques aimed at the prevention, detection, and correction of errors in spreadsheets. We present an overview of research effort that seeks to rectify this problem.", "num_citations": "38\n", "authors": ["154"]}
{"title": "Designing features for both genders in end-user programming environments\n", "abstract": " Previous research has revealed gender differences that impact females' willingness to adopt software features in end users' programming environments. Since these features have separately been shown to help end users problem solve, it is important to female end users' productivity that we find ways to make these features more acceptable to females. In this paper, we draw from our ongoing work with users to help inform our design of theory-based methods for encouraging effective feature usage by both genders. This design effort is the first to begin addressing the gender differences in the ways that people go about problem solving in end-user programming situations.", "num_citations": "38\n", "authors": ["154"]}
{"title": "Applying attention investment to end-user programming\n", "abstract": " Attention investment is a model to help the designers of end-user programmable systems understand the cognitive drivers for users deciding how to interact with their products. We present the attention investment model through examples drawn from an actual design project. This project is developing new functionality within Forms/3, a research test-bed for a concept called \"end-user software engineering\". As the examples show, our experience is that attention investment provides a useful design tool for the development of end-user programming features.", "num_citations": "38\n", "authors": ["154"]}
{"title": "Garbage in, garbage out? An empirical look at oracle mistakes by end-user programmers\n", "abstract": " End-user programmers, because they are human, make mistakes. However, past research has not considered how visual end-user debugging devices could be designed to ameliorate the effects of mistakes. This paper empirically examines oracle mistakes - mistakes users make about which values are right and which are wrong - to reveal differences in how different types of oracle mistakes impact the quality of visual feedback about bugs. We then consider the implications of these empirical results for designers of end-user software engineering environments.", "num_citations": "37\n", "authors": ["154"]}
{"title": "To fix or to learn? How production bias affects developers' information foraging during debugging\n", "abstract": " Developers performing maintenance activities must balance their efforts to learn the code vs. their efforts to actually change it. This balancing act is consistent with the \u201cproduction bias\u201d that, according to Carroll's minimalist learning theory, generally affects software users during everyday tasks. This suggests that developers' focus on efficiency should have marked effects on how they forage for the information they think they need to fix bugs. To investigate how developers balance fixing versus learning during debugging, we conducted the first empirical investigation of the interplay between production bias and information foraging. Our theory-based study involved 11 participants: half tasked with fixing a bug, and half tasked with learning enough to help someone else fix it. Despite the subtlety of difference between their tasks, participants foraged remarkably differently-making foraging decisions from different types of\u00a0\u2026", "num_citations": "36\n", "authors": ["154"]}
{"title": "Using cognitive dimensions: advice from the trenches\n", "abstract": " Many researchers have analyzed visual language design using Cognitive Dimensions (CDs), but some have reinterpreted the purpose, vocabulary, and use of CDs, potentially creating confusion. In particular, those who have used CDs to convince themselves or others that their language is usable have tended to ignore or downplay the tradeoffs inherent in design, resulting in evaluations that provide few insights. Researchers who do not consider who, when, and how best to analyze a visual language using CDs are likely to miss the most useful opportunities to uncover problems in their visual languages. In this paper, we consider common breakdowns when using CDs in analysis. Then, using three case studies, we demonstrate how the who, when, and how circumstances under which CDs are applied impact the gains that can be expected.", "num_citations": "36\n", "authors": ["154"]}
{"title": "A strategy-centric approach to the design of end-user debugging tools\n", "abstract": " End-user programmers' code is notoriously buggy. This problem is amplified by the increasing complexity of end users' programs. To help end users catch errors early and reliably, we employ a novel approach for the design of end-user debugging tools: a focus on supporting end users' effective debugging strategies. This paper makes two contributions. We first demonstrate the potential of a strategy-centric approach to tool design by presenting StratCel, an add-in for Excel. Second, we show the benefits of this design approach: participants using StratCel found twice as many bugs as participants using standard Excel, they fixed four times as many bugs, and all this in only a small fraction of the time. Other contributions included: a boost in novices' debugging performance near experienced participants' improved levels, validated design guidelines, a discussion of the generalizability of this approach, and several\u00a0\u2026", "num_citations": "35\n", "authors": ["154"]}
{"title": "Rewarding \"Good\" Behavior: End-User Debugging and Rewards\n", "abstract": " Emerging research has sought to bring effective debugging devices to end-user programmers. This research has largely focused on how well such devices bring genuine \"functional\" rewards to end users. However, emerging models of programming behavior indicate that another, often ignored, type of reward - perceivable rewards - can play an equally vital role in how well debugging devices serve end users. Using an empirically evaluated fault localization device, the paper investigates the impact such perceivable rewards can have on end-user debugging. Our results indicate that perceivable rewards alone can significantly improve the effectiveness and understanding of end users performing debugging tasks", "num_citations": "34\n", "authors": ["154"]}
{"title": "An Exploration of Design Opportunities for \"Gardening\" End-User Programmers\u2019 Ideas\n", "abstract": " Despite recent advances in supporting end-user programmers, empirical studies continue to report barriers that end users experience in problem solving with programming environments. We hypothesize that an important barrier that still needs to be overcome is the lack of support for nurturing end-user programmers' ideas on how a program should be written or on how to solve programming difficulties. Therefore, in this paper, we present a qualitative empirical investigation and triangulate the results with theories from problem solving and creativity. Moreover, we explore design opportunities and a design space for \u201cidea gardening\u201d, a new approach to nurturing end-user programmers' ideas and to helping them gradually gain expertise as they overcome barriers. Our results suggest that nurturing end-user programmers' ideas is a fertile area for research with an interesting, multidimensional design space.", "num_citations": "33\n", "authors": ["154"]}
{"title": "Incorporating incremental validation and impact analysis into spreadsheet maintenance: An empirical study\n", "abstract": " Spreadsheets are among the most common form of software in use today. Unlike more traditional forms of software however, spreadsheets are created and maintained by end users with little or no programming experience. As a result, a high percentage of these \"programs\" contain errors. Unfortunately, software engineering research has for the most part ignored this problem. We have developed a methodology that is designed to aid end users in developing, testing, and maintaining spreadsheets. The methodology communicates testing information and information about the impact of cell changes to users in a manner that does not require an understanding of formal testing theory or the behind the scenes mechanisms. The paper presents the results of an empirical study that shows that, during maintenance, end users using our methodology were more accurate in making changes and did a significantly better job\u00a0\u2026", "num_citations": "33\n", "authors": ["154"]}
{"title": "Foraging and navigations, fundamentally: developers' predictions of value and cost\n", "abstract": " Empirical studies have revealed that software developers spend 35%\u201350% of their time navigating through source code during development activities, yet fundamental questions remain: Are these percentages too high, or simply inherent in the nature of software development? Are there factors that somehow determine a lower bound on how effectively developers can navigate a given information space? Answering questions like these requires a theory that captures the core of developers' navigation decisions. Therefore, we use the central proposition of Information Foraging Theory to investigate developers' ability to predict the value and cost of their navigation decisions. Our results showed that over 50% of developers' navigation choices produced less value than they had predicted and nearly 40% cost more than they had predicted. We used those results to guide a literature analysis, to investigate the extent to\u00a0\u2026", "num_citations": "32\n", "authors": ["154"]}
{"title": "Similarity inheritance: a new model of inheritance for spreadsheet VPLs\n", "abstract": " Although spreadsheets can be argued to be the most widely used visual programming languages (VPLs) today, most are very limited compared to other VPLs, supporting only a few built-in types and offering only primitive support for code reuse. The inheritance mechanisms of object oriented programming might seem to offer help for the latter problem, but incorporating these mechanisms in a traditional way would introduce concepts foreign to spreadsheets, such as message passing. We present similarity inheritance, a new approach to inheritance that is suitable for seamless integration into the spreadsheet paradigm. We first explain the model independently of any implementation, and then present a prototype implementation in the research spreadsheet VPL Forms/3. We show that bringing inheritance functionality to the spreadsheet paradigm can be done using the widely understood idea of copy/paste. Further\u00a0\u2026", "num_citations": "31\n", "authors": ["154"]}
{"title": "Sharing reasoning about faults in spreadsheets: An empirical study\n", "abstract": " Although researchers have developed several ways to reason about the location of faults in spreadsheets, no single form of reasoning is without limitations. Multiple types of errors can appear in spreadsheets, and various fault localization techniques differ in the kinds of errors that they are effective in locating. In this paper, we report empirical results from an emerging system that attempts to improve fault localization for end-user programmers by sharing the results of the reasoning systems found in WYSIWYT and UCheck. By evaluating the visual feedback from each fault localization system, we shed light on where these different forms of reasoning and combinations of them complement - and contradict - one another, and which heuristics can be used to generate the best advice from a combination of these systems", "num_citations": "30\n", "authors": ["154"]}
{"title": "How the experts do it: Assessing and explaining agent behaviors in real-time strategy games\n", "abstract": " How should an AI-based explanation system explain an agent's complex behavior to ordinary end users who have no background in AI? Answering this question is an active research area, for if an AI-based explanation system could effectively explain intelligent agents' behavior, it could enable the end users to understand, assess, and appropriately trust (or distrust) the agents attempting to help them. To provide insights into this question, we turned to human expert explainers in the real-time strategy domain--\" shoutcasters\"--to understand (1) how they foraged in an evolving strategy game in real time,(2) how they assessed the players' behaviors, and (3) how they constructed pertinent and timely explanations out of their insights and delivered them to their audience. The results provided insights into shoutcasters' foraging strategies for gleaning information necessary to assess and explain the players; a\u00a0\u2026", "num_citations": "29\n", "authors": ["154"]}
{"title": "A principled evaluation for a principled Idea Garden\n", "abstract": " Many systems are designed to help novices who want to learn programming, but few support those who are not interested in learning (more) programming. This paper targets the subset of end-user programmers (EUPs) in this category. We present a set of principles on how to help EUPs like this learn just a little when they need to overcome a barrier. We then instantiate the principles in a prototype and empirically investigate the principles in two studies: a formative think-aloud study and a pair of summer camps attended by 42 teens. Among the surprising results were the complementary roles of implicitly actionable hints versus explicitly actionable hints, and the importance of both context-free and context-sensitive availability. Under these principles, the camp participants required significantly less in-person help than in a previous camp to learn the same amount of material in the same amount of time.", "num_citations": "28\n", "authors": ["154"]}
{"title": "End-user development as adaptive maintenance\n", "abstract": " The change of change applications to suit the needs of users in different places and facilitate development over time has long been a major challenge for software maintenance experts. In this chapter we take up tailoring as a means of making software flexible. Starting with two case studies\u2014 one taking up tailoring for different users and the other addressing changes over time\u2014the article discusses problems related to both the use and development of a tailorable application. Developing tailorable software presents newchallenges: howdo you create a user-friendly tailoring interface? How do you decide what should be tailorable, and how do you create a software architecture that permits this? How do you ensure that the tailorable system gives acceptable performance? Our experience shows that the borders between maintenance and use become blurred since tailorability can replace maintenance by professional\u00a0\u2026", "num_citations": "28\n", "authors": ["154"]}
{"title": "Gender HCI and Microsoft: Highlights from a Longitudinal Study\n", "abstract": " Research has emerged over the past decade showing gender biases in software. Although a few methods and prototype systems have emerged to help address this issue, none have been reported to have an impact on the people who actually build software. In this paper, we summarize a few highlights from a year-long field study investigating how Gender HCI methods to address gender biases in software can make impacts on a large software company.", "num_citations": "27\n", "authors": ["154"]}
{"title": "Males\u2019 and females\u2019 script debugging strategies\n", "abstract": " Little research has addressed IT professionals\u2019 script debugging strategies, or considered whether there may be gender differences in these strategies. What strategies do male and female scripters use and what kinds of mechanisms do they employ to successfully fix bugs? Also, are scripters\u2019 debugging strategies similar to or different from those of spreadsheet debuggers? Without the answers to these questions, tool designers do not have a target to aim at for supporting how male and female scripters want to go about debugging. We conducted a think-aloud study to bridge this gap. Our results include (1) a generalized understanding of debugging strategies used by spreadsheet users and scripters, (2) identification of the multiple mechanisms scripters employed to carry out the strategies, and (3) detailed examples of how these debugging strategies were employed by males and females to successfully\u00a0\u2026", "num_citations": "27\n", "authors": ["154"]}
{"title": "Toward foraging for understanding of StarCraft agents: An empirical study\n", "abstract": " Assessing and understanding intelligent agents is a difficult task for users that lack an AI background. A relatively new area, called\" Explainable AI,\" is emerging to help address this problem, but little is known about how users would forage through information an explanation system might offer. To inform the development of Explainable AI systems, we conducted a formative study--using the lens of Information Foraging Theory--into how experienced users foraged in the domain of StarCraft to assess an agent. Our results showed that participants faced difficult foraging problems. These foraging problems caused participants to entirely miss events that were important to them, reluctantly choose to ignore actions they did not want to ignore, and bear high cognitive, navigation, and information costs to access the information they needed.", "num_citations": "26\n", "authors": ["154"]}
{"title": "The future of visual languages\n", "abstract": " In this panel the group discuss the future research directions for visual languages and plan for a workshop to be held prior to VL2000 next year. Participation of all will be welcome to formulate the agenda for this workshop.", "num_citations": "25\n", "authors": ["154"]}
{"title": "Visual forms of iteration that preserve single assignment\n", "abstract": " Many visual languages follow the principle of single assignment, particularly those based on declarative programming paradigms. However, the notion of single assignment seems at odds with most forms of iteration. In this paper, we survey a variety of approaches to this problem, and then present the approach used in the visual language Forms/2.", "num_citations": "25\n", "authors": ["154"]}
{"title": "End-user development in the internet of things era\n", "abstract": " The paradigm of end-user development enables ordinary end-users of computer systems to engage in the modification, extension and even creation of software artifacts. Technology, organization and context are all important aspects that influence end-users' decisions to engage in end-user development. With this workshop, we invite researchers and practitioners to discuss and exchange their experiences on the role of these aspects for end-user development across various domains.", "num_citations": "24\n", "authors": ["154"]}
{"title": "Interactive fault localization techniques in a spreadsheet environment\n", "abstract": " End-user programmers develop more software than any other group of programmers, using software authoring devices such as multimedia simulation builders, e-mail filtering editors, by-demonstration macro builders, and spreadsheet environments. Despite this, there has been only a little research on finding ways to help these programmers with the dependability of the software they create. We have been working to address this problem in several ways, one of which includes supporting end-user debugging activities through interactive fault localization techniques. This paper investigates fault localization techniques in the spreadsheet domain, the most common type of end-user programming environment. We investigate a technique previously described in the research literature and two new techniques. We present the results of an empirical study to examine the impact of two individual factors on the\u00a0\u2026", "num_citations": "24\n", "authors": ["154"]}
{"title": "Visually customizing inference rules about apples and oranges\n", "abstract": " We have been working on a unit system for end-user spreadsheets that is based on the concrete notion of units instead of the abstract concept of types. In previous work, we defined such a system formally. In this paper we describe a visual system to support the formal reasoning in two ways. First, it supports communicating and explaining the unit inference process to users. Second and more important, our approach allows users to change the system's reasoning by adding and customizing the system's inference rules.", "num_citations": "24\n", "authors": ["154"]}
{"title": "From concrete forms to generalized abstractions through perspective-oriented analysis of logical relationships\n", "abstract": " We believe concreteness, direct manipulation and responsiveness in a visual programming language increase its usefulness. However, these characteristics present a challenge in generalizing programs for reuse, especially when concrete examples are used as one way of achieving concreteness. In this paper, we present a technique to solve this problem by deriving generality automatically through the analysis of logical relationships among concrete program entities from the perspective of a particular computational goal. Use of this technique allows a fully general form-based program with reusable abstractions to be derived from one that was specified in terms of concrete examples and direct manipulation.< >", "num_citations": "24\n", "authors": ["154"]}
{"title": "Gender-inclusive HCI research and design: A conceptual review\n", "abstract": " Previous research has investigated gender and its implications for HCI. We consider inclusive design of technology whatever the gender of its users of particular importance. This conceptual review provides an overview of the motivations that have driven research in gender and inclusive HCI design. We review the empirical evidence for the impact of gender in thinking and behavior which underlies HCI research and design. We then present how HCI design might inadvertently embed and perpetuate gender stereotypes. We then present current HCI design approaches to tackle gender stereotypes and to produce gender-inclusive designs. We conclude by discussing possible future directions in this area.", "num_citations": "23\n", "authors": ["154"]}
{"title": "Explaining Reinforcement Learning to Mere Mortals: An Empirical Study\n", "abstract": " We present a user study to investigate the impact of explanations on non-experts' understanding of reinforcement learning (RL) agents. We investigate both a common RL visualization, saliency maps (the focus of attention), and a more recent explanation type, reward-decomposition bars (predictions of future types of rewards). We designed a 124 participant, four-treatment experiment to compare participants' mental models of an RL agent in a simple Real-Time Strategy (RTS) game. Our results show that the combination of both saliency and reward bars were needed to achieve a statistically significant improvement in mental model score over the control. In addition, our qualitative analysis of the data reveals a number of effects for further study.", "num_citations": "23\n", "authors": ["154"]}
{"title": "Idea Garden: Situated Support for Problem Solving by End-User Programmers\n", "abstract": " Although there have been many advances in end-user programming environments, recent empirical studies report that programming still remains difficult for end-users. We hypothesize that one reason may be lack of effective support for helping end-user programmers problem-solve their own way around barriers they encounter. Therefore, in this paper, we describe the Idea Garden, a concept designed to help end-user programmers generate new ideas and problem-solve when they run into barriers. The Idea Garden has its roots in Minimalist Learning Theory and problem-solving theories. Our proof-of-concept prototype of the Idea Garden concept in the CoScripter end-user programming environment currently targets three barriers reported in end-user programming literature. It does so using an integrated, just-in-time combination of scaffolding for problem-solving strategies, for design patterns and for\u00a0\u2026", "num_citations": "23\n", "authors": ["154"]}
{"title": "Six challenges in supporting end-user debugging\n", "abstract": " This paper summarizes six challenges in end-user programming that can impact the debugging efforts of end users. These challenges have been derived through our experiences and empirical investigation of interactive fault localization techniques in the spreadsheet paradigm. Our contributions reveal several insights into debugging techniques for end-user programmers, particularly fault localization techniques, that can help guide the direction of future end-user software engineering research.", "num_citations": "23\n", "authors": ["154"]}
{"title": "Types and type inference in a visual programming language\n", "abstract": " The uses of types and type inference in visual languages are explored. First, we discuss how the goals of a type system must differ from visual languages from those of a type system for textual languages. We then present a type system developed under these goals for the visual language Forms/3. Within the context of this system, issues of particular importance in visual languages are examined, including maintaining the user's conceptual model, the avoidance of language restrictions solely to support a type system, and how the visual process of programming can provide additional information to the type system.< >", "num_citations": "23\n", "authors": ["154"]}
{"title": "Assertions in end-user software engineering: a think-aloud study\n", "abstract": " There has been little research on end-user program development beyond the programming phase. Devising ways to address additional phases may be critical, because research shows that over one-half of the programs written by end users, at least in the widely used spreadsheet paradigm, contain errors. In this paper, we investigate whether providing end users with integrated support for requirement specifications in the form of assertions can help them reason about, recognize, and remove errors in their spreadsheets. Our think-aloud study revealed that end users can indeed use assertions to find and correct errors as they work with their spreadsheets, and also revealed some surprising tendencies and biases about testing.", "num_citations": "22\n", "authors": ["154"]}
{"title": "Supporting reuse of evolving visual code\n", "abstract": " Although the idea of reusing code is very appealing, effective reuse has long been acknowledged as a problem. To help address the difficulties, many advocate strong management commitment to code reuse, leading to the treatment of code as an asset to be carefully managed in a well-organized repository. However, the advent of the Web may bring a change to this outlook encouraging informal, loosely-organized code repositories. Already, for both textual and visual languages, informal repositories are beginning to emerge, featuring a high rate of change and few controls over what a producer must do to submit code. We present techniques to address some aspects of code reuse in this kind of informal, evolving environment. These techniques build upon characteristics found in many visual programming languages. Using these techniques, our approach is able to eliminate the special work traditionally required\u00a0\u2026", "num_citations": "22\n", "authors": ["154"]}
{"title": "End-user feature labeling: Supervised and semi-supervised approaches based on locally-weighted logistic regression\n", "abstract": " When intelligent interfaces, such as intelligent desktop assistants, email classifiers, and recommender systems, customize themselves to a particular end user, such customizations can decrease productivity and increase frustration due to inaccurate predictions\u2014especially in early stages when training data is limited. The end user can improve the learning algorithm by tediously labeling a substantial amount of additional training data, but this takes time and is too ad hoc to target a particular area of inaccuracy. To solve this problem, we propose new supervised and semi-supervised learning algorithms based on locally-weighted logistic regression for feature labeling by end users, enabling them to point out which features are important for a class, rather than provide new training instances.We first evaluate our algorithms against other feature labeling algorithms under idealized conditions using feature labels\u00a0\u2026", "num_citations": "21\n", "authors": ["154"]}
{"title": "Explaining debugging strategies to end-user programmers\n", "abstract": " There has been little research into how end-user programming environments can provide explanations that could fill a critical information gap for end-user debuggers - help with debugging strategy. To address this need, we designed and prototyped a video-based approach for explaining debugging strategy, and accompanied it with a text-only approach. We then conducted a qualitative empirical study with end-user debuggers. The results reveal the influences of the explanations on end-user debuggers' decision making, how users reacted to the video versus textual media, and the information gaps the explanations closed. The results also reveal issues of particular importance to explanations of this type.", "num_citations": "21\n", "authors": ["154"]}
{"title": "Champagne prototyping: A research technique for early evaluation of complex end-user programming systems\n", "abstract": " Although a variety of evaluation techniques are available to researchers of visual and end-user programming systems, they are primarily suited to evaluation of research systems. It is important to have evaluation techniques suitable for real-world programming environments, in order to satisfy real-world product managers of the usefulness of proposed new features. To help fill this gap, we present a new evaluation technique, based in part on cognitive dimensions and attention investment, called \"Champagne prototyping\". The technique is an early-evaluation technique that is inexpensive to do, yet features the credibility that comes from being based on the real commercial environment of interest, and from working with real users of the environment", "num_citations": "20\n", "authors": ["154"]}
{"title": "Using the cognitive walkthrough to improve the design of a visual programming experiment\n", "abstract": " Visual programming languages aim to promote usability, but are rarely examined for it. One reason is the difficulty of designing successful experimental evaluations. We propose the cognitive walkthrough as an aid to improve experimental designs. This is a novel application of an HCI-derived technique designed for evaluating interfaces rather than experiments. The technique focuses on the potential difficulties of novice users and is therefore particularly suited for evaluating the programming situation, which is knowledge-based and non-routine. We describe an empirical study performed without benefit of a walkthrough and show how the study was improved by a series of walkthroughs. We found the method to be quick to use, effective at improving the experimental design, and usable by non-specialists.", "num_citations": "20\n", "authors": ["154"]}
{"title": "A bug's eye view of immediate visual feedback in direct-manipulation programming systems\n", "abstract": " Immediate visual feedback is becoming a common feature in direct-manipulation programming systems of all kinds-from demonstrational macro builders to spreadsheet packages to visual programming languages featuring direct manipulation. But does immediate visual feedback actually help in the domain of programming? We previously reported on an empirical study to determine whether the inclusion of immediate visual feedback into a direct-manipulation programming system helps with one particular task: debugging. In that study, subjects debugged programs with and without immediate visual feedback. We found that although immediate visual feedback did not significantly help with debugging in general, it did significantly help with debugging in some circumstances.In this paper, we follow up on those results, looking at attributes of the bugs themselves to see if they help to determine the circumstances in\u00a0\u2026", "num_citations": "20\n", "authors": ["154"]}
{"title": "From barriers to learning in the Idea Garden: An empirical study\n", "abstract": " How can end-user programming environments better help their users overcome programming barriers? We have been investigating an approach called Idea Gardening, which addresses this problem by helping end users to help themselves overcome barriers in the context of \u201cdoing\u201d. In this paper, we report on a qualitative empirical study of how effectively an Idea Garden prototype helped end users overcome programming barriers in the CoScripter environment, and the extent to which participants learned after interacting with our features. Our results showed that 9 out of 10 participants who encountered barriers and then used the Idea Garden, overcame their barriers. Further, all 9 went on to demonstrate evidence of having learned the programming concepts, patterns, and strategies relevant to overcoming these barriers.", "num_citations": "19\n", "authors": ["154"]}
{"title": "End user software engineering: CHI 2007 special interest group meeting\n", "abstract": " Recently, researchers have been working to bring the benefits of rigorous software engineering methodologies to end users who find themselves in programming situations, to try to make their software more reliable. End users create software whenever they write, for instance, educational simulations, spreadsheets, or dynamic e-business web applications. Unfortunately, errors are pervasive in end-user software, and the resulting impact is sometimes enormous. This special interest group meeting has three purposes: to bring the results of a recent (February 2007) week-long\" Dagstuhl\" meeting on end-user software engineering to interested researchers at CHI; to incorporate attendees' ideas and feedback into an emerging survey of the state of this interesting new subarea; and generally to bring together the community of researchers who are addressing this topic, with the companies that are creating end-user\u00a0\u2026", "num_citations": "19\n", "authors": ["154"]}
{"title": "Gender differences in end-user debugging, revisited: What the miners found\n", "abstract": " We have been working to uncover gender differences in the ways males and females problem solve in end-user programming situations, and have discovered differences in males' versus females' use of several debugging features. Still, because this line of investigation is new, knowing exactly what to look for is difficult and important information could escape our notice. We therefore decided to bring data mining techniques to bear on our data, with two aims: primarily, to expand what is known about how males versus females make use of end-user debugging features, and secondarily, to find out whether data mining could bring new understanding to this research, given that we had already studied the data manually using qualitative and quantitative methods. The results suggested several new hypotheses in how males versus females go about end-user debugging tasks, the factors that play into their choices, and\u00a0\u2026", "num_citations": "18\n", "authors": ["154"]}
{"title": "Exception handling in the spreadsheet paradigm\n", "abstract": " Exception handling is widely regarded as a necessity in programming languages today and almost every programming language currently used for professional software development supports some form of it. However, spreadsheet systems, which may be the most widely used type of \"programming language\" today in terms of number of users using it to create \"programs\" (spreadsheets), have traditionally had only extremely limited support for exception handling. Spreadsheet system users range from end users to professional programmers and this wide range suggests that an approach to exception handling for spreadsheet systems needs to be compatible with the equational reasoning model of spreadsheet formulas, yet feature expressive power comparable to that found in other programming languages. We present an approach to exception handling for spreadsheet system users that is aimed at this goal\u00a0\u2026", "num_citations": "18\n", "authors": ["154"]}
{"title": "Reasoning about many-to-many requirement relationships in spreadsheets\n", "abstract": " To help improve the reliability of spreadsheets created by end users, we are working to allow users to communicate the purpose and other underlying information about their spreadsheets, using a form of requirement specifications we call \"guards.\" For large spreadsheets with replicated/shared formulas across groups of rows or columns, guards can only be practical if users can enter them across these groups of rows or columns. The problem is, this introduces many-to-many relationships, and it is not clear how the system should reason and communicate about them in a way that will make sense to end users. In this paper, we present the human-centric design rationale for our approach to how the system should reason about such many-to-many relationships. The design decisions are presented with their reasons gleaned from two design-time models - cognitive dimensions and attention economics -and from the\u00a0\u2026", "num_citations": "17\n", "authors": ["154"]}
{"title": "End-User Programmers in Trouble: Can the Idea Garden help them to help themselves?\n", "abstract": " End-user programmers often get stuck because they do not know how to overcome their barriers. We have previously presented an approach called the Idea Garden, which makes minimalist, on-demand problem-solving support available to end-user programmers in trouble. Its goal is to encourage end users to help themselves learn how to overcome programming difficulties as they encounter them. In this paper, we investigate whether the Idea Garden approach helps end-user programmers problem-solve their programs on their own. We ran a statistical experiment with 123 end-user programmers. The experiment's results showed that, even when the Idea Garden was no longer available, participants with little knowledge of programming who previously used the Idea Garden were able to produce higher-quality programs than those who had not used the Idea Garden.", "num_citations": "16\n", "authors": ["154"]}
{"title": "End-user interactions with intelligent and autonomous systems\n", "abstract": " Systems that learn from or personalize themselves to users are quickly becoming mainstream yet interaction with these systems is limited and often uninformative for the end user. This workshop focuses on approaches and challenges to explore making these systems transparent, controllable and ultimately trustworthy to end users. The aims of the workshop are to help establish connections among researchers and industrial practitioners using real-world problems as catalysts to facilitate the exchange of approaches, solutions, and ideas about how to better support end users.", "num_citations": "16\n", "authors": ["154"]}
{"title": "End-user feature labeling: A locally-weighted regression approach\n", "abstract": " When intelligent interfaces, such as intelligent desktop assistants, email classifiers, and recommender systems, customize themselves to a particular end user, such customizations can decrease productivity and increase frustration due to inaccurate predictions-especially in early stages, when training data is limited. The end user can improve the learning algorithm by tediously labeling a substantial amount of additional training data, but this takes time and is too ad hoc to target a particular area of inaccuracy. To solve this problem, we propose a new learning algorithm based on locally weighted regression for feature labeling by end users, enabling them to point out which features are important for a class, rather than provide new training instances. In our user study, the first allowing ordinary end users to freely choose features to label directly from text documents, our algorithm was both more effective than others at\u00a0\u2026", "num_citations": "16\n", "authors": ["154"]}
{"title": "End-user strategy programming\n", "abstract": " Rule-based programming systems can be fragile because they force the user to account for all logical alternatives. If an unconsidered case does arise during execution, program behavior falls through the cracks into unspecified behavior. We investigate rule-based, end-user strategy programming by introducing our Interactive Football Playbook\u2014a domain specific, end-user programming environment to allow American football coaches to create animated football scenarios by associating strategy information with virtual football players. We address the problem of rule explosion through \u201crule bending\u201d to support a minimalist, scaffolding-driven programming environment. Additionally, we introduce visual language representations for logical and sequential \u201cand\u201d to mitigate end-user confusion with the semantic meaning of these \u201cand\u201d constructs.", "num_citations": "16\n", "authors": ["154"]}
{"title": "Gender in end-user software engineering\n", "abstract": " In this paper, we describe research that reports gender differences in usage of software engineering tools by end-user programmers. We connect these findings with possible explanations based on theories from other disciplines, and then add to that our recent results that these differences go deeper than software engineering tool usage to software engineering strategies. We enumerate the strategies that work better for males and the ones that work better for females, and discuss implications and possible directions for follow-up.", "num_citations": "16\n", "authors": ["154"]}
{"title": "Gender hci: Results to date regarding issues in problem-solving software\n", "abstract": " We are investigating gender HCI issues in problemsolving software, using quantitative and qualitative empirical methods. Our research approach uses formative work to understand the existence and attributes of gender-relevant design features, based on which we then design and implement new features in our research prototype. Finally, we perform summative empirical work to evaluate effectiveness.", "num_citations": "16\n", "authors": ["154"]}
{"title": "An integrated software engineering approach for end-user programmers\n", "abstract": " End-user programming has become the most common form of programming in use today. Despite this growth, there has been little investigation into the correctness of the programs end-users create. We have been investigating ways to address this problem via a holistic approach we call enduser software engineering. The concept is to bring support for aspects of software development that happen beyond the \u201ccoding\u201d stage\u2014such as testing and debugging\u2014together into the support that already exists for incremental, interactive programming by end-users. In this chapter, we present our progress on three aspects of end-user software engineering: systematic \u201cwhite box\u201d testing assisted by automatic test generation, assertions in a form of postconditions that also serve as preconditions, and fault localization.We also present our strategy for motivating end-user programmers to make use of the end-user software\u00a0\u2026", "num_citations": "16\n", "authors": ["154"]}
{"title": "Pedagogical Content Knowledge for Teaching Inclusive Design\n", "abstract": " Inclusive design is important in today's software industry, but there is little research about how to teach it. In collaboration with 9 teacher-researchers across 8 US universities and more than 400 computer and information science students, we embarked upon an Action Research investigation to gather insights into the pedagogical content knowledge (PCK) that teachers need to teach a particular inclusive design method called GenderMag. Analysis of the teachers' observations and experiences, the materials they used, direct observations of students' behaviors, and multiple data on the students' own reflections on their learning revealed 11 components of inclusive design PCK. These include strategies for anticipating and addressing resistance to the topic of inclusion, strategies for modeling and scaffolding perspective taking, and strategies for tailoring instruction to students' prior beliefs and biases.", "num_citations": "15\n", "authors": ["154"]}
{"title": "GenderMag Experiences in the Field: The Whole, the Parts, and the Workload\n", "abstract": " Recent research has reported numerous studies bringing into question the gender inclusiveness of many kinds of software. Inclusiveness of software (gender or otherwise) matters because supporting diversity matters - it is well-known that the more diverse a group of problem-solvers, the higher the quality of the solution. To help software creators identify features within their software that are not gender-inclusive, we recently created a method known as GenderMag. In this paper, we investigate the experience of teams of software professionals using GenderMag to find problems with software they are building. Our results show a high engagement with GenderMag personas - more than twice that of other personas research - and a very high degree of accuracy (93%) most of the time. Finally, our results pinpointed situations that we term \u201cdetours\u201d that were especially prone to errors, with teams 6 times more likely to\u00a0\u2026", "num_citations": "15\n", "authors": ["154"]}
{"title": "Towards recognizing\" cool\" can end users help computer vision recognize subjective attributes of objects in images?\n", "abstract": " Recent computer vision approaches are aimed at richer image interpretations that extend the standard recognition of objects in images (eg, cars) to also recognize object attributes (eg, cylindrical, has-stripes, wet). However, the more idiosyncratic and abstract the notion of an object attribute (eg, cool car), the more challenging the task of attribute recognition. This paper considers whether end users can help vision algorithms recognize highly idiosyncratic attributes, referred to here as subjective attributes. We empirically investigated how end users recognized three subjective attributes of carscool, cute, and classic. Our results suggest the feasibility of vision algorithms recognizing subjective attributes of objects, but an interactive approach beyond standard supervised learning from labeled training examples is needed.", "num_citations": "15\n", "authors": ["154"]}
{"title": "Can information foraging pick the fix? A field study\n", "abstract": " Previous findings have revealed the ability of information foraging to model or predict where developers will navigate within source code. However, the previous investigation did not consider whether the places developers went were the right places to go. In this paper, we present afield study in which we investigated over 200 open source bug reports and feature requests. We analyzed the textual similarity of these issues in relation to the source code, and determined what files developers had changed to fix these issues. Our results demonstrate that information scent can narrow down quite well where developers should make fixes, implying that future software navigation tools can predict the appropriate places to make fixes based solely on the contents of the issue and the source code.", "num_citations": "15\n", "authors": ["154"]}
{"title": "Retire Superman: Handling Exceptions Seamlessly in a Declarative Visual Programming Language.\n", "abstract": " Exception handling is widely regarded as a necessity in programming languages today, and almost every programming language in current use supports some form of it. Unfortunately however, most approaches to exception handling involve constructs with unusual powers, and even deviations from the language's evaluation model. To avoid such devices in our declarative visual programming language, we have devised a fullfeatured approach to exception handling that fits seamlessly into languages that are declarative and visual. Using this approach allows designers of declarative visual programming languages to provide the expressive power previously available only through complex exception handling techniques.", "num_citations": "15\n", "authors": ["154"]}
{"title": "Seven programming language issues\n", "abstract": " Seven programming language issues | Visual object-oriented programming ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksVisual object-oriented programming: concepts and environmentsSeven programming language issues chapter Seven programming language issues Share on Author: Burnett Margaret M. profile image Margaret M. Burnett View Profile Authors Info & Affiliations Publication: Visual object-oriented programming: concepts and environmentsJanuary 1995 Pages 161\u2013181 1citation 0 Downloads Metrics Total Citations1 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert ! This \u2026", "num_citations": "15\n", "authors": ["154"]}
{"title": "Abstraction in the demand-driven, temporal-assignment, visual language model\n", "abstract": " Degree: Ph. D.DegreeYear: 1991Institute: University of KansasAdviser: Allen L. Ambler.The work developed in this thesis seeks to expand the scope of applicability of declarative visual languages. Historically, research into declarative visual programming languages has had as a primary goal simplification of concepts required for programming. However, the contributions of these attempts has been demonstrated via only certain restricted classes of examples. A continuous criticism of these systems has been that they are not easily extended to adequately handle larger or more general programs without re-introducing the very concepts they have tried to simplify or remove. This criticism is termed the scaling up problem. For any research addressing this problem to be successful, it must address the inherent conflict between abstraction and the most important characteristic of visual programming languages\u00a0\u2026", "num_citations": "15\n", "authors": ["154"]}
{"title": "Mental Models of Mere Mortals with Explanations of Reinforcement Learning\n", "abstract": " How should reinforcement learning (RL) agents explain themselves to humans not trained in AI? To gain insights into this question, we conducted a 124-participant, four-treatment experiment to compare participants\u2019 mental models of an RL agent in the context of a simple Real-Time Strategy (RTS) game. The four treatments isolated two types of explanations vs. neither vs. both together. The two types of explanations were as follows: (1) saliency maps (an \u201cInput Intelligibility Type\u201d that explains the AI\u2019s focus of attention) and (2) reward-decomposition bars (an \u201cOutput Intelligibility Type\u201d that explains the AI\u2019s predictions of future types of rewards). Our results show that a combined explanation that included saliency and reward bars was needed to achieve a statistically significant difference in participants\u2019 mental model scores over the no-explanation treatment. However, this combined explanation was far from a\u00a0\u2026", "num_citations": "14\n", "authors": ["154"]}
{"title": "Exploring the representation of women perspectives in technologies\n", "abstract": " Technology has a profound mediating effect on the way we relate, obtain knowledge, and contribute to society. Given the impact and potential ramifications of technology on our society, it is imperative that both masculine and feminine perspectives are included in shaping our modern day technologies. This panel focuses on the representation of women perspectives in technologies we design, analyze, and use. There are many barriers when it comes to getting women perspectives into system designs such as: the small amount of HCI gender research currently in the literature, the lack of analysis of gender-agnostic software tools which fit female problem-solving approaches, and low grant support for research which looks at the representation of the feminists' perspective in our current discourse. This panel will address these barriers with respect to the tools and technologies we experience and design.", "num_citations": "14\n", "authors": ["154"]}
{"title": "Where are my intelligent assistant\u2019s mistakes? A systematic testing approach\n", "abstract": " Intelligent assistants are handling increasingly critical tasks, but until now, end users have had no way to systematically assess where their assistants make mistakes. For some intelligent assistants, this is a serious problem: if the assistant is doing work that is important, such as assisting with qualitative research or monitoring an elderly parent\u2019s safety, the user may pay a high cost for unnoticed mistakes. This paper addresses the problem with WYSIWYT/ML (What You See Is What You Test for Machine Learning), a human/computer partnership that enables end users to systematically test intelligent assistants. Our empirical evaluation shows that WYSIWYT/ML helped end users find assistants\u2019 mistakes significantly more effectively than ad hoc testing. Not only did it allow users to assess an assistant\u2019s work on an average of 117 predictions in only 10 minutes, it also scaled to a much larger data set\u00a0\u2026", "num_citations": "14\n", "authors": ["154"]}
{"title": "Time in Grid-Oriented VPLs: Just Another Dimension?\n", "abstract": " Specifying varying speeds and temporal relationships is necessary when programming graphical animations, but support for temporal programming has usually been done by adding new language features to a VPL, and these features must be mastered over and above the other aspects of the VPL. However, some researchers have believed that time should be able to be treated like just another dimension. We explore whether temporal programming can indeed be done using exactly the same devices as in spatial programming in grid-oriented VPLs. Toward this end, we provide a continuum of models aimed at this goal, with their advantages and disadvantages. Also, we identify core issues that help illuminate the essence of the problem.", "num_citations": "14\n", "authors": ["154"]}
{"title": "Graphical definitions: making spreadsheets visual through direct manipulation and gestures\n", "abstract": " Until now, attempts to extend the one way constraint evaluation model of the spreadsheet paradigm to support complex objects, such as colored circles or user defined types, have led to approaches featuring either a direct way of creating objects graphically or strong compatibility with the spreadsheet paradigm, but not both. This inability to conveniently go beyond numbers and strings without straying outside the spreadsheet paradigm has been a limiting factor in the applicability of spreadsheets. We present a technique that removes this limitation, allowing complex objects to be programmed directly-and in a manner that fits seamlessly within the spreadsheet paradigm-using direct manipulation and gestures. An empirical study has shown that programmers can use this technique to program complex objects faster and with fewer errors. We show that the graphical definitions technique not only expands the\u00a0\u2026", "num_citations": "14\n", "authors": ["154"]}
{"title": "Engineering Gender-Inclusivity into Software: Ten Teams' Tales from the Trenches\n", "abstract": " Although the need for gender-inclusivity in software is gaining attention among SE researchers and SE practitioners, and at least one method (GenderMag) has been published to help, little has been reported on how to make such methods work in real-world settings. Real-world teams are ever-mindful of the practicalities of adding new methods on top of their existing processes. For example, how can they keep the time costs viable? How can they maximize impacts of using it? What about controversies that can arise in talking about gender? To find out how software teams\" in the trenches\" handle these and similar questions, we collected the GenderMag-based processes of 10 real-world software teams---more than 50 people---for periods ranging from 5 months to 3.5 years. We present these teams' insights and experiences in the form of 9 practices, 2 potential pitfalls, and 2 open issues, so as to provide their\u00a0\u2026", "num_citations": "13\n", "authors": ["154"]}
{"title": "End-User Development in Internet of Things: We the People\n", "abstract": " This position paper considers people aspects of end-user development in the Internet of Things.", "num_citations": "13\n", "authors": ["154"]}
{"title": "A scalable method for deductive generalization in the spreadsheet paradigm\n", "abstract": " In this paper, we present an efficient method for automatically generalizing programs written in spreadsheet languages. The strategy is to do generalization through incremental analysis of logical relationships among concrete program entities from the perspective of a particular computational goal. The method uses deductive dataflow analysis with algebraic back-substitution rather than inference with heuristics, and there is no need for generalization-related dialog with the user. We present the algorithms and their time complexities and show that, because the algorithms perform their analyses incrementally, on only the on-screen program elements rather than on the entire program, the method is scalable. Performance data is presented to help demonstrate the scalability.", "num_citations": "13\n", "authors": ["154"]}
{"title": "What is visual object-oriented programming?\n", "abstract": " What is visual object-oriented programming? | Visual object-oriented programming ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksVisual object-oriented programming: concepts and environmentsWhat is visual object-oriented programming? chapter What is visual object-oriented programming? Share on Authors: Adele Goldberg View Profile , Margaret Burnett View Profile , Ted Lewis View Profile Authors Info & Affiliations Visual object-oriented programming: concepts and environmentsJanuary 1995 Pages 3\u201320 Published:02 January 1995 2citation 0 Downloads Metrics Total Citations2 Total Downloads0 Last 12 Months0 Last ! \u2026", "num_citations": "13\n", "authors": ["154"]}
{"title": "PFIS-V: Modeling Foraging Behavior in the Presence of Variants\n", "abstract": " Foraging among similar variants of the same artifact is a common activity, but computational models of Information Foraging Theory (IFT) have not been developed to take such variants into account. Without being able to computationally predict people's foraging behavior with variants, our ability to harness the theory in practical ways--such as building and systematically assessing tools for people who forage different variants of an artifact--is limited. Therefore, in this paper, we introduce a new predictive model, PFIS-V, that builds upon PFIS3, the most recent of the PFIS family of modeling IFT in programming situations. Our empirical results show that PFIS-V is up to 25% more accurate than PFIS3 in predicting where a forager will navigate in a variationed information space.", "num_citations": "12\n", "authors": ["154"]}
{"title": "Putting information foraging theory to work: Community-based design patterns for programming tools\n", "abstract": " The design of programming tools is slow and costly. To ease this process, we developed a design pattern catalog aimed at providing guidance for tool designers. This catalog is grounded in Information Foraging Theory (IFT), which empirical studies have shown to be useful for understanding how developers look for information during development tasks. New design patterns, authored by members of the research community for the catalog, concretely explain how to apply IFT in tool design. In our evaluation, qualitative analyses revealed the community-written design patterns compared well in quality to patterns that we had ourselves published in a smaller, peer-reviewed catalog.", "num_citations": "12\n", "authors": ["154"]}
{"title": "From GenderMag to InclusiveMag: An Inclusive Design Meta-Method\n", "abstract": " How can software practitioners assess whether their software supports diverse users? Although there are empirical processes that can be used to find \u201cinclusivity bugs\u201d piecemeal, what is often needed is a systematic inspection method to assess software's support for diverse populations. To help fill this gap, this paper introduces InclusiveMag, a generalization of GenderMag that can be used to generate systematic inclusiveness methods for a particular dimension of diversity. We then present a multicase study covering eight diversity dimensions, of eight teams' experiences applying InclusiveMag to eight under-served populations and their \u201cmainstream\u201d counterparts.", "num_citations": "11\n", "authors": ["154"]}
{"title": "Mini-Crowdsourcing End-User Assessment of Intelligent Assistants: A Cost-Benefit Study\n", "abstract": " Intelligent assistants sometimes handle tasks too important to be trusted implicitly. End users can establish trust via systematic assessment, but such assessment is costly. This paper investigates whether, when, and how bringing a small crowd of end users to bear on the assessment of an intelligent assistant is useful from a cost/benefit perspective. Our results show that a mini-crowd of testers supplied many more benefits than the obvious decrease in workload, but these benefits did not scale linearly as mini-crowd size increased - there was a point of diminishing returns where the cost-benefit ratio became less attractive.", "num_citations": "11\n", "authors": ["154"]}
{"title": "Software visualization for end-user programmers: trial period obstacles\n", "abstract": " Software visualization for end-user programmers is a relatively unexplored opportunity area. There are advances in software visualization research pertinent to this, but the adoption stage has been entirely ignored. In this paper, we focus on a popular facilitator of adoption decisions: the free trial period. We conducted a case study of an end-user programmer (an accountant) in this situation, as she tried out a commercial spreadsheet visualization tool to make an adoption decision. The results have implications for both theory and design, revealing open questions, design opportunities, and strengths and weaknesses of theoretical foundations.", "num_citations": "11\n", "authors": ["154"]}
{"title": "Methodology for testing spreadsheet grids\n", "abstract": " The invention includes two methods for testing a spreadsheet region. Du-associations are collected for the spreadsheet region. In the Straightforward approach, du-associations are collected for each cell in the region. Each cell's execution trace is tracked. After the user validates a cell, the du-associations for the cell that participated in the execution trace are marked as executed. In the Region Representative approach, a region representative represents the region. Each cell's execution trace is tracked. After the user validates a cell, the du-associations for the region representative that participated in the execution trace for the validated cell are marked as executed. Du-associations for other cells that are affected by the testing of a spreadsheet region are similarly marked as covered. If the user changes a shared non-constant formula, the collected du-associations for the region are discarded and the steps of\u00a0\u2026", "num_citations": "11\n", "authors": ["154"]}
{"title": "Gender in Open Source Software: What the tools tell\n", "abstract": " This position paper considers what studying Open Source Software tools can lend to understanding the topic of Gender Diversity in Open Source Software. More specifically we investigate the GenderMag method, a Gender Inclusive method and how it can help increase gender inclusiveness in the tools that are used by OSS communities.", "num_citations": "10\n", "authors": ["154"]}
{"title": "Pair collaboration in end-user debugging\n", "abstract": " The problem of dependability in end-user programming is an emerging area of interest. Pair collaboration in end-user software development may offer a way for end users to debug their programs more effectively. While pair programming studies - primarily of computer science students and professionals - report positive outcomes in terms of overall program quality, little is known about specific activities that pairs engage in that lead to those outcomes, or of how the previous results may pertain to end-user programmers. In this paper we analyze protocols of end-user pairs debugging spreadsheets. The results suggest that end-user pairs can achieve rich reasoning, effective planning, and systematic evaluation. Furthermore, end-user pairs provide specific types of mutual support that facilitate the accomplishment of their goals", "num_citations": "10\n", "authors": ["154"]}
{"title": "Static type inference for a first-order declarative visual programming language with inheritance\n", "abstract": " The early detection of type errors is a well-known benefit of static typing, but until recent years, this benefit usually has come at the cost of requiring the programmer to explicitly declare the type of every object in a program. Since many visual programming languages (VPLs), especially those VPLs intended for end users, are designed to eliminate such programming mechanisms, most VPLs have been implemented with dynamic typing, thereby sacrificing early type error feedback and other benefits of static typing. One potential solution for this dilemma is static type inference, but unfortunately, the types inferred under previous approaches have been notoriously difficult to understand, even for professional programmers. Compounding this problem is the fact that when support for inheritance is added to such type inference systems, explicit type declarations have re-emerged.In this paper, we present a model of types\u00a0\u2026", "num_citations": "10\n", "authors": ["154"]}
{"title": "General Principles for a Generalized Idea Garden\n", "abstract": " Many systems are designed to help novices who want to learn programming, but few support those who are not necessarily interested in learning programming. This paper targets the subset of end-user programmers (EUPs) in this category. We present a set of principles on how to help EUPs like this learn just a little when they need to overcome a barrier. We then instantiate the principles in a prototype and empirically investigate them in three studies: a formative think-aloud study, a pair of summer camps attended by 42 teens, and a third summer camp study featuring a different environment attended by 48 teens. Finally, we present a generalized architecture to facilitate the inclusion of Idea Gardens into other systems, illustrating with examples from Idea Garden prototypes. Results have been very encouraging. For example, under our principles, Study #2\u2019s camp participants required significantly less in-person\u00a0\u2026", "num_citations": "9\n", "authors": ["154"]}
{"title": "SIG: gender-inclusive software: What we know about building it\n", "abstract": " Recent research has shown that some software that is intended to be gender-neutral is not, in fact, equally inclusive to males and females. But little is known about how to design software in a gender-aware fashion, and existing research on gender differences relevant to software design is scattered across at least five different academic fields (eg, psychology, computer science, education, communications, and women's studies). This research SIG will bring together female and male academics, industry researchers, and practitioners with three goals in mind:(1) to build community across research/practice boundaries;(2) to pool our knowledge on promising practices for design and evaluation of software from a gender perspective; and (3) to begin to build a shared, on-line research and literature base to support solid, well-informed progress on this important issue.", "num_citations": "9\n", "authors": ["154"]}
{"title": "End-user software engineering and why it matters\n", "abstract": " End-user programming has become ubiquitous; so much so that there are more end-user programmers today than there are professional programmers. End-user programming empowers\u2014but to do what? Make bad decisions based on bad programs? Enter software engineering\u2019s focus on quality. Considering software quality is necessary, because there is ample evidence that the programs end users create are filled with expensive errors. In this paper, we consider what happens when we add considerations of software quality to end-user programming environments, going beyond the \u201ccreate a program\u201d aspect of end-user programming. We describe a philosophy of software engineering for end users, and then survey several projects in this area. A basic premise is that end-user software engineering can only succeed to the extent that it respects that the user probably has little expertise or even interest in software\u00a0\u2026", "num_citations": "9\n", "authors": ["154"]}
{"title": "Improving the design of visual programming language experiments using cognitive walkthroughs\n", "abstract": " Visual programming languages aim to promote usability, but their usability is rarely examined scientifically. One reason is the difficulty of designing successful experimental evaluations. We propose the Cognitive Walkthrough (CW) as an aid to improve experiments' designs. The CW is an HCI technique designed for evaluating interfaces. The technique focuses on the potential difficulties of novice users and is therefore particularly suited for evaluating programming situations that arise in visual programming language experiments performed in laboratory settings. We first describe an empirical study performed without benefit of a walkthrough and show how the study was improved by a series of walkthroughs. We also describe two other empirical studies and how they were improved with the help of the CW. We found the method to be quick to use, effective at improving the experimental design, and usable by non\u00a0\u2026", "num_citations": "9\n", "authors": ["154"]}
{"title": "Keeping it \"organized and logical\": After-action review for AI (AAR/AI)\n", "abstract": " Explainable AI (XAI) is growing in importance as AI pervades modern society, but few have studied how XAI can directly support people trying to assess an AI agent. Without a rigorous process, people may approach assessment in ad hoc ways---leading to the possibility of wide variations in assessment of the same agent due only to variations in their processes. AAR, or After-Action Review, is a method some military organizations use to assess human agents, and it has been validated in many domains. Drawing upon this strategy, we derived an AAR for AI, to organize ways people assess reinforcement learning (RL) agents in a sequential decision-making environment. The results of our qualitative study revealed several strengths and weaknesses of the AAR/AI process and the explanations embedded within it.", "num_citations": "8\n", "authors": ["154"]}
{"title": "Semi-Automating (or not) a Socio-Technical Method for Socio-Technical Systems\n", "abstract": " How can we support software professionals who want to build human-adaptive sociotechnical systems? Building such systems requires skills some developers may lack, such as applying human-centric concepts to the software they develop and/or mentally modeling other people. Effective socio-technical methods exist to help, but most are manual and cognitively burdensome. In this paper, we investigate ways semi-automating a socio-technical method might help, using as our lens GenderMag, a method that requires people to mentally model people with genders different from their own. Toward this end, we created the GenderMag Recorder's Assistant, a semi-automated visual tool, and conducted a small field study and a 92-participant controlled study. Results of our investigation revealed ways the tool helped with cognitive load and ways it did not; unforeseen advantages of the tool in increasing participants'\u00a0\u2026", "num_citations": "8\n", "authors": ["154"]}
{"title": "What Should Be in an XAI Explanation? What IFT Reveals\n", "abstract": " This workshop\u2019s call for participation poses the question: What should be in an explanation? One route toward answering this question is to turn to theories of how humans try to obtain information they seek. Information Foraging Theory (IFT) is one such theory. In this paper, we present lessons we have learned about how IFT informs Explainable Artificial Intelligence (XAI), and also what XAI contributes back to IFT.", "num_citations": "8\n", "authors": ["154"]}
{"title": "Mining interpretable human strategies: A case study\n", "abstract": " This paper focuses on mining human strategies by observing their actions. Our application domain is an HCI study aimed at discovering general strategies used by software users and understanding how such strategies relate to gender and success. We cast this as a sequential pattern discovery problem, where user strategies are manifested as sequential patterns. Problematically, we found that the patterns discovered by standard algorithms were difficult to interpret and provided limited information about high-level strategies. To help interpret the patterns and extract general strategies, we examined multiple ways of clustering the patterns into meaningful groups, which collectively led to interesting findings about user behavior both in terms of gender differences and problem-solving success. As a real-world application of data mining techniques, our work led to the discovery of new strategic patterns that are linked\u00a0\u2026", "num_citations": "8\n", "authors": ["154"]}
{"title": "Panel: Extending conversations about gender and HCI\n", "abstract": " This panel aims to create a space for participants at CHI 2018 to see how far we have come as a community in raising and addressing issues of gender, and how far we have yet to go. Our intent is for open discussion to support the community's intentions to move towards greater equity, inclusivity, and diversity.", "num_citations": "7\n", "authors": ["154"]}
{"title": "Making intelligent systems understandable and controllable by end users\n", "abstract": " Pervasive systems for end users are becoming mainstream yet ways to make them transparent and controllable by users are still in their infancy. In this position paper we describe our work with other kinds of intelligent systems to make them intelligible and adaptable by end users. Our results could hold useful lessons for pervasive systems to better support their use.", "num_citations": "7\n", "authors": ["154"]}
{"title": "Impact of high-intensity negotiated-style interruptions on end-user debugging\n", "abstract": " Extending our previous work [T. Robertson, S. Prabhakararao, M. Burnett, C. Cook, J. Ruthruff, L. Beckwith, A. Phalgune, Impact of interruption style on end-user debugging, ACM Conference on Human Factors in Computing Systems (2004)], we delve deeper into the question of which interruption style best supports end-user debugging. Previously, we found no advantages of immediate-style interruptions (which force the user to divert attention to the interruption at hand) over negotiated-style interruptions (which notify users without actually preventing them from working) in supporting end-user debugging. In this study, we altered our negotiated-style interruptions [A. Wilson, M. Burnett, L. Beckwith, O. Granatir, L. Casburn, C. Cook, M. Durham, G. Rothermel, Harnessing curiosity to increase correctness in end-user programming, Proceedings of the CHI 2003 (2003), 305\u2013312] (which were shown to help end-user\u00a0\u2026", "num_citations": "7\n", "authors": ["154"]}
{"title": "Programming complex objects in spreadsheets: An empirical study comparing textual formula entry with direct manipulation and gestures\n", "abstract": " Hewlett-Packard Company Department of Computer Science 1000 NE Circle Blvd. Oregon State University Corvallis, OR 97330-4239 Corvallis, OR 9733 l-3202 herkyg@ cv. hp. com burnett@ cs. orst. edu", "num_citations": "7\n", "authors": ["154"]}
{"title": "Visual languages and the conflict between single assignment and iteration\n", "abstract": " Many visual languages follow the principle of single assignment, particularly those based on declarative programming paradigms. However, the notion of single assignment seems at odds with most forms of iteration. The authors survey a variety of approaches to this problem and then present the approach used in the visual language Forms/2. Forms/2 treats iteration in a form as a temporal sequence of instances of the form. Termination is controlled rather uniquely in Forms/2 as a direct result of the dependence-resolution evaluation mechanism.<>", "num_citations": "7\n", "authors": ["154"]}
{"title": "Explaining AI: fairly? well?\n", "abstract": " Explainable AI (XAI) has started experiencing explosive growth, echoing the explosive growth that has preceded it of AI becoming used for practical purposes that impact the general public. This spread of AI into the world outside of research labs brings with it pressures and requirements that many of us have perhaps not thought about deeply enough. In this keynote address, I will explain why I think we have a very long way to go.", "num_citations": "6\n", "authors": ["154"]}
{"title": "End-User Development\n", "abstract": " Taking the International Symposium of End User Development to Copenhagen and Scandinavia brought it to the origin of the participatory design community. Participatory design explores techniques and methods to facilitate users to contribute toward shaping the technology they use in the contexts of use, for example, work processes. In Copenhagen and in Malm\u00f6, situated across the \u00d8resund Strait, linked by the 8-km \u00d8resund Bridge, Scandinavian architecture and design traditions meet with participatory design. This connection has brought forward a (sub-) community of design combining esthetic with utilitarian design. The emphasis of the co development of the social and the technical has resulted in a broadening of design beyond the workplace to embrace community-based design, which in turn leads to an opening toward heterogeneous design constituencies and users not only as participating but also\u00a0\u2026", "num_citations": "6\n", "authors": ["154"]}
{"title": "HCI research regarding end-user requirement specification: a tutorial\n", "abstract": " Can end users someday enter their requirements directly into program generation tools? This paper surveys literature that sheds some light upon this question, highlighting devices from HCI research that can be used to help in accomplishing this goal.", "num_citations": "6\n", "authors": ["154"]}
{"title": "Software engineering for end-user programmers\n", "abstract": " There has been considerable work in empowering end users to be able to write their own programs, and as a result, end users are indeed doing so. In fact, the number of end-user programmers is expected to reach 55 million by 2005 in the US alone [2], writing programs using such devices as special-purpose scripting languages, multimedia and web authoring languages, and spreadsheets. Unfortunately, evidence from the spreadsheet paradigm, the most widely used of the end-user programming languages, abounds that end-user programmers are extremely prone to errors [15]. This problem is serious, because although some end users\u2019 programs are simply explorations and scratch pad calculations, others can be quite important to their personal or business livelihood, such as for calculating income taxes, ecommerce web pages, and financial forecasting.We would like to help reduce the error rate in the end-user programs that are important to the user. Although classical software engineering methodologies are not a panacea, there are several that are known to help reduce programming errors, and it would be useful to incorporate some of those successes in end-user programming. Toward this end, we have been working on a vision we call end-user software engineering, a holistic approach to the facets of software development in which end users engage. Its goal is to bring some of the gains from the software engineering community to end-user programming environments, without requiring training or even interest in traditional software engineering techniques.", "num_citations": "5\n", "authors": ["154"]}
{"title": "Bringing HCI research to bear upon end-user requirement specification\n", "abstract": " Can end users someday enter their requirements directly into program generation tools? This paper surveys literature that sheds some light upon this question, including devices from HCI research that can be used to help in accomplishing this goal.", "num_citations": "5\n", "authors": ["154"]}
{"title": "End-user testing of Lyee programs: a preliminary report\n", "abstract": " End-user specification of Lyee programs is one goal envisioned by the Lyee methodology. But with any software development effort comes the possibility of faults. Thus, providing end users a means to enter their own specifications is not enough; they must also be provided with the means to find faults in their specifications, in a manner that is appropriate not only for the end user's programming environment but also for his or her background. We have begun research into how to do exactly that. In this paper, we report our progress in investigating two possible testing approaches for end users who specify their own Lyee programs. are non-", "num_citations": "5\n", "authors": ["154"]}
{"title": "Does a visual \u201ctestedness\u201d methodology aid debugging\n", "abstract": " Spreadsheet languages are the most widely-used form of functional programming, and are used by a wide range of audiences from professional programmers to end users. We have been working to address problems that limit their usefulness, to understand how certain spreadsheet features promote their acceptance, and to make use of these results in other kinds of functional programming environments. One of the problems we would like to address\u2014in a way that is helpful to both programmers and end users\u2014is the high presence of logic errors in spreadsheet formulas. A central part of our strategy has been a program-analysis-based methodology to visually and incrementally guide the user into a systematic testing strategy. In this paper we describe an experiment on how this approach affects human productivity in debugging. Specifically, the experiment described in this paper explores the effect of the methodology\u2019s feedback about testedness on debugging effectiveness. The results show that testedness feedback significantly aids debugging accuracy and speed. However, we have found mixed evidence regarding effects on overconfidence.", "num_citations": "5\n", "authors": ["154"]}
{"title": "FAR: An End-User WYSIWYG Programming Language for E-speak: Interim Report\n", "abstract": " For the past few months, we have been working to design and prototype a WYSIWYG programming tool allowing end users to offer and deliver services through e-speak. This document begins with a brief summary of the design and progress on the prototype to date. We then use an evaluation device called representation design benchmarks to evaluate FAR\u2019s design against some issues derived from cognitive research into programming. The purpose of the evaluation is to find flaws at this early stage that predict problems with usability. As a result of the evaluation, we summarize design changes planned and required.", "num_citations": "5\n", "authors": ["154"]}
{"title": "A Guided Tour of Forms/3\n", "abstract": " Forms/3 is a declarative visual programming language that aims to provide general purpose programming language capabilities in a simple, form-based approach. This report provides an example-driven introduction to programming in Forms/3.", "num_citations": "5\n", "authors": ["154"]}
{"title": "Gender HCI: what about the software?\n", "abstract": " Although there has been recent investigation into how to understand and ameliorate the low representation of females in computing, there has been little research into how software itself fits into the picture. Our focus is on how supposedly gender-neutral software interacts with gender differences. Specifically, we have concentrated on software aimed at supporting users doing problem solving. For example, what if females' problem-solving effectiveness, using software such as Excel, would accelerate if the software were changed to take gender differences into account? This talk reports the investigations my students and I have conducted into whether and how software and its features affect females' and males' performance differently, and describes the beginnings of work on promising interventions that help both males and females.", "num_citations": "4\n", "authors": ["154"]}
{"title": "End-user software engineering and distributed cognition\n", "abstract": " End-user programmers may not be aware of many software engineering practices that would add greater discipline to their efforts, and even if they are aware of them, these practices may seem too costly (in terms of time) to use. Without taking advantage of at least some of these practices, the software these end users create seems likely to continue to be less reliable than it could be. We are working on several ways of lowering both the perceived and actual costs of systematic software engineering practices, and on making their benefits more visible and immediate. Our approach is to leverage the user's cognitive effort through the use of distributed cognition, in which the system and user collaboratively work systematically to reason about the program the end user is creating. This paper demonstrates this concept with a few of our past efforts, and then presents three of our current efforts in this direction.", "num_citations": "4\n", "authors": ["154"]}
{"title": "Gender and end-user computing\n", "abstract": " Although gender differences in a technological world are receiving significant research attention, much of the research and practice has aimed at how society and education can impact the successes and retention of female computer science professionals. The possibility of gender issues within software, however, has received almost no attention, nor has the population of female end users. However, there is relevant foundational research suggesting that gender-related factors within a software environment that supports end-user computing may have a strong impact on how effective male and female end users can be in that environment. Thus, in this article, we summarize theory-establishing results from other domains that point toward the formation of grounded hypotheses for studying gender differences in end-user computing. There has been much background research relevant to human issues of end-user\u00a0\u2026", "num_citations": "4\n", "authors": ["154"]}
{"title": "End-user assertions: propagating their implications\n", "abstract": " Spreadsheet languages are the most commonly used end-user programming paradigm, yet spreadsheets commonly contain errors. Research shows that a significant number of spreadsheets (20%-40%) created by end users contain errors. In an attempt to reduce this error rate, this work presents an assertion propagation system for an end-user spreadsheet programming language, along with proofs of correctness, and complexity analysis. In addition to the traditional benefits of assertions (dynamic error checking and the documentation of programmer assumptions) this system deductively propagates the implications of assertions. This propagation adds two benefits, the cross-checking of program logic, and additional immediate visual feedback about the range of behavior of the program code for the end-user.", "num_citations": "4\n", "authors": ["154"]}
{"title": "Algorithm Animation in a Declarative Visual Programming Language\n", "abstract": " How might capabilities for algorithm animation be seamlessly integrated into a programming language that is both visual and declarative? Until now, visual programming language researchers have not attempted to answer that question, making the fruits of algorithm animation available only to users of textual programming languages. Users of visual programming languages (VPLs) have been deprived of the unique semantic insights algorithm animation offers, insights that would foster the understanding and debugging of visual programs. We have answered the question by seamlessly integrating algorithm animation capabilities into Forms/3, a general-purpose, declarative VPL. Our results show that such a VPL can support algorithm animation without leaving the declarative, visual model, without adding new concepts to the language or how to program in it, and without deviating from the uniform representation established for the language. In addition, our research shows that the characteristics of declarative VPLs result in some interesting algorithm animation features not found in other systems.", "num_citations": "4\n", "authors": ["154"]}
{"title": "After-action review for AI (AAR/AI)\n", "abstract": " Explainable AI is growing in importance as AI pervades modern society, but few have studied how explainable AI can directly support people trying to assess an AI agent. Without a rigorous process, people may approach assessment in ad hoc ways\u2014leading to the possibility of wide variations in assessment of the same agent due only to variations in their processes. AAR, or After-Action Review, is a method some military organizations use to assess human agents, and it has been validated in many domains. Drawing upon this strategy, we derived an After-Action Review for AI (AAR/AI), to organize ways people assess reinforcement learning agents in a sequential decision-making environment. We then investigated what AAR/AI brought to human assessors in two qualitative studies. The first investigated AAR/AI to gather formative information, and the second built upon the results, and also varied the type of\u00a0\u2026", "num_citations": "3\n", "authors": ["154"]}
{"title": "Fixing inclusivity bugs for information processing styles and learning styles\n", "abstract": " Most software systems today do not support cognitive diversity. Further, because of differences in problem-solving styles that cluster by gender, software that poorly supports cognitive diversity can also embed gender biases. To help software professionals fix gender bias \"bugs\" related to people's problem-solving styles for information processing and learning of new software we collected inclusivity fixes from three sources. The first two are empirical studies we conducted: a heuristics-driven user study and a field research industry study. The third is data that we obtained about a before/after user study of inclusivity bugs. The resulting seven potential inclusivity fixes show how to debug software to be more inclusive for diverse problem-solving styles.", "num_citations": "3\n", "authors": ["154"]}
{"title": "Perspectives on gender and product design\n", "abstract": " Interactive technologies have a profound mediating effect on the way we obtain and contribute to knowledge, relate to each other and contribute to society. Often,\" gender\" is not a factor that is explicitly considered in the design of these technologies. When gender is considered, products are often designed with idealised models of gendered\" users\"--designed for men, designed for women, designed for boys, designed for girls, or designed for the\" average user\" who could be male or female. However, the ways in which gender-bias or gender-neutrality are constructed in the design process and the resulting effect on the interactive artifacts that are produced is not well understood. This workshop will address what HCI is currently bringing, and can bring, to the table in addressing this issue.", "num_citations": "3\n", "authors": ["154"]}
{"title": "Designing a debugging interaction language for cognitive modelers: an initial case study in Natural Programming Plus\n", "abstract": " In this paper, we investigate how a debugging environment should support a population doing work at the core of HCI research: cognitive modelers. In conducting this investigation, we extended the Natural Programming methodology (a user-centered design method for HCI researchers of programming environments), to add an explicit method for mapping the outcomes of NP's empirical investigations to a language design. This provided us with a concrete way to make the design leap from empirical assessment of users' needs to a language. The contributions of our work are therefore:(1) empirical evidence about the content and sequence of cognitive modelers' information needs when debugging,(2) a new, empirically derived, design specification for a debugging interaction language for cognitive modelers, and (3) an initial case study of our\" Natural Programming Plus\" methodology.", "num_citations": "3\n", "authors": ["154"]}
{"title": "Does my model work? Evaluation abstractions of cognitive modelers\n", "abstract": " Are the abstractions that scientific modelers use to build their models in a modeling language the same abstractions they use to evaluate the correctness of their models? The extent to which such differences exist seems likely to correspond to additional effort of modelers in determining whether their models work as intended. In this paper, we therefore investigate the distinction between \"programming abstractions\" and \"evaluation abstractions\". As the basis of our investigation, we conducted a case study on cognitive modeling. We report modelers' evaluation abstractions, and the lengths they went to in evaluating their models. From these results, we derive design implications for several categories of persistent, first-class evaluation abstractions in future debugging tools for modelers.", "num_citations": "3\n", "authors": ["154"]}
{"title": "Mining Qualitative Behavioral Data from Quantitative Data: A Case Study from the Gender HCI Project.\n", "abstract": " Recent research has shown that gender differences exist that influence the ways that males and females work with problem-solving software. These gender differences may put females at a disadvantage in competing for jobs requiring these skills. Earlier research has shown the existence of gender differences in confidence that affects feature usage and adoption; however these findings have raised new questions. We are seeking answers to these questions through qualitative methods. The case study we present here documents our methodology and may be used as a guide for others embarking on similar qualitative analyses.", "num_citations": "3\n", "authors": ["154"]}
{"title": "End-user testing for the Lyee methodology using the screen transition paradigm and WYSIWYT\n", "abstract": " End-user specification of Lyee programs is one goal envisioned by the Lyee methodology. But with any software development effort comes the possibility of faults. Thus, providing end users a means to enter their own specifications is not enough; they must also be provided with the means to find faults in their specifications, in a manner that is appropriate not only for the end user's programming environment but also for his or her background. In this paper, we present an approach to solve this problem that marries two proven technologies for end users. One methodology for enabling end users to program is the screen transition paradigm. One useful visual testing methodology is \u2018What you see is what you test (WYSIWYT)\u2019. In this paper, we show that WYSIWYT test adequacy criteria can be used with the screen transition paradigm, and present a systematic translation from this paradigm to the formal model underlying\u00a0\u2026", "num_citations": "3\n", "authors": ["154"]}
{"title": "End-user programming of time as an \u2018ordinary\u2019dimension in grid-oriented visual programming languages\n", "abstract": " Specifying varying speeds and temporal relationships is necessary when programming graphical animations, but support for temporal programming has usually been done by adding new language features to a VPL, and these features must be mastered over and above the other aspects of the VPL. However, some researchers have believed that time should be able to be treated like just another dimension. In this paper, we explore whether programming of temporal relationships can be supported usingexactly the same devices as in spatial programming in grid-oriented VPLs. Toward this end, we provide a continuum of models aimed at this goal, with their advantages and disadvantages, and identify core issues that help illuminate the essence of the problem. We also describe an empirical study comparing one of these models against a widely used traditional approach. The results were that end users were\u00a0\u2026", "num_citations": "3\n", "authors": ["154"]}
{"title": "Introduction to Visual Programming Languages: Scaling-Up Issues\n", "abstract": " In this talk I discuss our experiences from our VPL efforts at IBM during the past 8 years.For many years I have been an advocate of visual programming as a vehicle for end-user programming. In the early 80s, I foolishly decided that what I needed to build better visual tools at the business school at Carleton University was an interactive, object-oriented programming environment. Unfortunately this resulted in a 10+ year diversion into building virtual machines, and IDEs for Smalltalk, Java and application specific languages to serve as a foundation for end-user programming.", "num_citations": "3\n", "authors": ["154"]}
{"title": "Integrating algorithm animation into a declarative visual programming language\n", "abstract": " Until now, only users of textual programming languages have enjoyed the fruits of algorithm animation. Users of visual programming languages (VPLs) have been deprived of the unique semantic insights algorithm animation offers. To begin solving this shortcoming, we have seamlessly integrated algorithm animation capabilities into the VPL Forms/3. Our research shows how a declarative VPL that is responsive can provide features not found in other algorithm animation systems.", "num_citations": "3\n", "authors": ["154"]}
{"title": "Declarative visual languages\n", "abstract": " THERE Is A NATURAL svERGISM between declarative programming paradigms and visual programming that is mutually beneficial. Let us consider declarative programming paradigms first. Declarative programming paradigms focus on relationships rather than algorithms. Relationships tend to be multi-dimensional; algorithms tend to be much more single-dimensional. In addition, declarative languages are largely devoid of control flow information; often they are non-deterministic. Thus, they need a representation that does not require, or even imply, an ordering. In summary, declarative languages need an unordered, multi-dimensional representation. Now, let us consider visual programming. Visual programming offers the potential of improving our ability to communicate and solve problems, provided we use the visual medium to advantage. To do so requires that we realize that visual information is largely\u00a0\u2026", "num_citations": "3\n", "authors": ["154"]}
{"title": "Lazy Marking: A Lazier Implementation of Functional I/O for Graphical User Interfaces\n", "abstract": " Today''s programming applications increasingly include interactive graphical user interfaces (GUIs). These interfaces by their very nature contain a \"display state\" that must be continuously maintained. However, in some cases, maintaining this display state in a lazy functional language involves such eager performance of housekeeping tasks in the runtime system that the quick response needed for a GUI cannot be attained. We introduce a new strategy called lazy marking that eliminates this eagerness, and characterize the situations in which it outperforms more eager approaches. While lazy marking sometimes improves overall performance, more importantly, it significantly improves response time in lazy functional languages supporting GUIs.", "num_citations": "3\n", "authors": ["154"]}
{"title": "The Shoutcasters, the Game Enthusiasts, and the AI: Foraging for Explanations of Real-time Strategy Players\n", "abstract": " Assessing and understanding intelligent agents is a difficult task for users who lack an AI background. \u201cExplainable AI\u201d (XAI) aims to address this problem, but what should be in an explanation? One route toward answering this question is to turn to theories of how humans try to obtain information they seek. Information Foraging Theory (IFT) is one such theory. In this article, we present a series of studies1 using IFT: the first investigates how expert explainers supply explanations in the RTS domain, the second investigates what explanations domain experts demand from agents in the RTS domain, and the last focuses on how both populations try to explain a state-of-the-art AI. Our results show that RTS environments like StarCraft offer so many options that change so rapidly, foraging tends to be very costly. Ways foragers attempted to manage such costs included \u201csatisficing\u201d approaches to reduce their cognitive load\u00a0\u2026", "num_citations": "2\n", "authors": ["154"]}
{"title": "Position: We Can Measure XAI Explanations Better with Templates.\n", "abstract": " This paper argues that the Explainable AI (XAI) research community needs to think harder about how to compare, measure, and describe the quality of XAI explanations. We conclude that one (or a few) explanations can be reasonably assessed with methods of the \u201cExplanation Satisfaction\u201d type, but that scaling up our ability to evaluate explanations requires more development of \u201cExplanation Goodness\u201d methods.", "num_citations": "2\n", "authors": ["154"]}
{"title": "Gender biases in software for problem-solving\n", "abstract": " The workshop call raises the question of how we can help users problem-solve, especially when the problem to be solved is complex. One answer to this question is to change the way we go about building such systems. Why: most software has extensive biases against certain cognitive problem-solving styles\u2014especially those styles preferred by more women than men. In this position paper, we consider the workshop call\u2019s discussion questions from the perspective of GenderMag, a method to pinpoint gender biases in user-facing software that aims to help people problem-solve.", "num_citations": "2\n", "authors": ["154"]}
{"title": "Toward Theory-Based End-User Software Engineering\n", "abstract": " One area of research in the end-user development area is known as end-user software engineering (EUSE). Research in EUSE aims to invent new kinds of technologies that collaborate with end users to improve the quality of their software. EUSE has become an active research area since its birth in the early 2000s, with a large body of literature upon which EUSE researchers can build. However, building upon these works can be difficult when projects lack connections due to an absence of cross-cutting foundations to tie them together. In this chapter, we advocate for stronger theory foundations and show the advantages through three theory-oriented projects: (1) the Explanatory Debugging approach, to help end users debug their intelligent assistants; (2) the GenderMag method, which identifies problems with gender inclusiveness in EUSE tools and other software; and (3) the Idea Garden approach, to help\u00a0\u2026", "num_citations": "2\n", "authors": ["154"]}
{"title": "\" Womenomics\" and gender-inclusive software: what software engineers need to know (invited talk)\n", "abstract": " This short paper is a summary of my keynote at FSE\u201916, with accompanying references for follow-up.", "num_citations": "2\n", "authors": ["154"]}
{"title": "Method and system of determining a prioritized list of users related to a given goal\n", "abstract": " A method and system of determining a prioritized list of one or more users related to a given goal obtaining a set of places, determine one or more future places an expert associated with a given goal is predicted to visit to accomplish the given goal, obtain a history of one or more places users have visited, determine one or more historical places from the history of one or more places that match the future places, and identify one or more users associated with the determined one or more historical places.", "num_citations": "2\n", "authors": ["154"]}
{"title": "Information Foraging Theory in Software Maintenance\n", "abstract": " This grant provides a theoretical foundation as to how to support programmers navigation. We develop a theory of information foraging for software maintenance. Then, to test the theorys validity, generality, and scope, we build predictive models, and use them for empirical lab investigations to evaluate our progress. Finally, we develop library modules and tools for use to empirically investigate real-world settings. The resulting theoretical foundation can replace practices of building software maintenance tools ad hoc, enabling principled progress in supporting programmers who maintain todays complex software.Descriptors:", "num_citations": "2\n", "authors": ["154"]}
{"title": "Improving Intelligent Assistants for Desktop Activities.\n", "abstract": " Tasks have been identified as playing an important role to knowledge workers as high-level units for organizing their information. TaskTracer is a task-aware desktop system that leverages the semi-automatic association between tasks and information to provide intelligent assistance to the user. TaskPredictor is a component that attempts to automatically predict the current task of the user. Our experience with TaskPredictor tells us that there still remain challenges to increasing acceptance by users. We describe our approaches to reduce the number of interruptions to the user, and to improve the accuracy of predictions.", "num_citations": "2\n", "authors": ["154"]}
{"title": "Recovery from Interruptions: Knowledge Workers' Strategies, Failures and Envisioned Solutions\n", "abstract": " This paper presents qualitative results from interviews with knowledge workers about their recovery strategies after interruptions. Special focus is given to when these strategies fail due to the nature of the interruption and existing computer support. Potential solutions offered by participants to overcome some of these problems are presented. These findings will benefit researchers and designers in the area of task-centric applications, especially in the area of support for recovery from interruptions.Descriptors:", "num_citations": "2\n", "authors": ["154"]}
{"title": "Interactive fault localization techniques to empower the debugging efforts of end-user programmers\n", "abstract": " End users develop more software than any other group of programmers, using software authoring devices such as e-mail filtering editors, by-demonstration macro builders, and spreadsheet environments. Despite this, there has been only a little research on finding ways to help these programmers with the dependability of the software they create. We have been working to address this problem in several ways, one of which includes supporting end-user debugging activities through interactive fault localization techniques. This thesis investigates these fault localization techniques in the realm of end-user programming. We investigate a technique previously described in the research literature, and two new techniques that are introduced in this thesis. This thesis also presents the results of two empirical studies to examine whether fault localization techniques are effective in end-user testing and debugging tasks. The first study compares how well the three techniques isolate the faults in two end-user programs. The second study examines the impact of two orthogonal factors on the effectiveness of fault localization techniques. Our results reveal several insights into the contributions such techniques can make to the end-user debugging process, and highlight key issues of interest to researchers and practitioners who may design and evaluate future fault localization techniques.", "num_citations": "2\n", "authors": ["154"]}
{"title": "Challenges and opportunities visual programming languages bring to programming language research\n", "abstract": " Observation 1: Visual programming language research is about programming language design unfettered by any restriction that all semantics must be expressed by a one-dimensional sequence of textual characters. This gives language designers more choices--more materials and devices that can be employed--in the languages they design.Observation 2: Researchers in visual programming languages would like to take advantage of the new choices afforded by Observation 1 to design\" better\" languages than were possible before. Although there are many possible views as to what it means for one programming language to be better than another, most agree that programming language A is better than another programming language B if humans are more likely to correctly create, understand, and/or change a program using A than using B.", "num_citations": "2\n", "authors": ["154"]}
{"title": "Some real-world uses of visual programming systems\n", "abstract": " What kinds of practical uses are people making of visual programming today in the real world? To find this out, we gathered information about users of visual programming systems. The information came in response to a newsgroup posting asking people to report their uses of visual programming, primarily in the form of e-mail directly from users. This information was supplemented with publicly-available written accounts of people using visual programming, newsgroup postings describing people's uses of visual programming, and queries to vendors. The raw data, sources of information, and numeric summary of the data are presented in this report. We have omitted the names of all individuals and companies unless the information was already in the public domain or we obtained permission to publish their identities.We learned about uses of visual programming by a wide variety of people who use visual programming both at home and at work. These users are in large corporations, in small companies, in universities, in government, and in the military. More than half of these particular users use visual programming languages (VPLs), and the rest use visual programming environments for textual languages (VPEs). Table 1 contains information about these users, which systems they use, and whether they use it for general-purpose programming or for a domain-specific purpose intended by the system they are using.", "num_citations": "2\n", "authors": ["154"]}
{"title": "A classi\ufb01cation system for visual programming languages\n", "abstract": " 1. Introduction THE LITERATURE about visual programming languages (VPLs) has grown to the point where some kind of organization must be imposed. Such an organization would make it possible for researchers to classify their work in terms of its main areas of contribution, thereby helping other researchers to locate relevant papers easily and reliably. This then is the goal of a classi\ufb01cation system-\u2014to aid researchers in their search for relevant work. The ACM Computing Reviews Classi\ufb01cation System [1] exists for precisely this purpose, and is partially reprinted in Appendix A of this paper. The bene\ufb01ts of using the Computing Reviews system (ACM CR system) for classifying VPL research would have been many. The ACM CR system is the result of extensive worlt and analysis, it is widely used and understood, and all VPL work classi\ufb01ed according to the system would have \ufb01t into the many databases and\u00a0\u2026", "num_citations": "2\n", "authors": ["154"]}
{"title": "Doing Remote Controlled Studies with Humans: Tales from the COVID Trenches\n", "abstract": " How should empirical researchers conduct controlled, remote \u201clab\u201d studies in the uncontrolled, noisy conditions of each participant's own home? Volatility in participant home environments, hardware, internet connection, and surrounding distractions takes the \u201ccontrolled\u201d out of controlled studies. This paper recounts our in-the-trenches mitigations for designing and conducting two complex controlled studies under COVID, in which participants, from home, interactively localized faults in an AI system. The studies with our COVID-era mitigations in 5 categories\u2014Privacy/Security, Data Collection, Control, Technology Issues, Payment-ultimately produced crisp results beyond what we thought possible under such uncontrolled circumstances.", "num_citations": "1\n", "authors": ["154"]}
{"title": "Gender Inclusivity as a Quality Requirement: Practices and Pitfalls\n", "abstract": " Gender inclusivity in software is gaining attention from researchers and practitioners, with some seeing it as a nonfunctional requirement. To investigate how gender inclusivity can be incorporated into creating software, we gathered data during periods ranging from 5 months to 3.5 years from 10 software teams that used the Gender Inclusiveness Magnifier (GenderMag) to achieve the gender inclusivity quality attribute. GenderMag is a method for detecting and fixing gender inclusivity issues in software. In this article, we summarize several practices the teams devised and pitfalls they encountered.", "num_citations": "1\n", "authors": ["154"]}
{"title": "Doing Inclusive Design: From GenderMag in the Trenches to InclusiveMag in the Research Lab\n", "abstract": " How can user interface and user experience (UI/UX) professionals assess whether their software supports diverse users? And if they find problems, how can they fix them? We begin this keynote address with a summary of GenderMag, a systematic inspection method for finding and fixing\" gender inclusivity bugs---biases against different genders in software interfaces and workflows. We then show what UI/UX professionals are doing with it in the real world, from their bias finds & fixes to their practices & pitfalls in using it. Finally, we present InclusiveMag, a meta-method that can be used by HCI researchers to generate systematic inclusiveness methods for other dimensions of diversity.", "num_citations": "1\n", "authors": ["154"]}
{"title": "End-user feature labeling via locally weighted logistic regression\n", "abstract": " Applications that adapt to a particular end user often make inaccurate predictions during the early stages when training data is limited. Although an end user can improve the learning algorithm by labeling more training data, this process is time consuming and too ad hoc to target a particular area of inaccuracy. To solve this problem, we propose a new learning algorithm based on Locally Weighted Logistic Regression for feature labeling by end users, enabling them to point out which features are important for a class, rather than provide new training instances. In our user study, the first allowing ordinary end users to freely choose features to label directly from text documents, our algorithm was more effective than others at leveraging end users\u2019 feature labels to improve the learning algorithm. Our results strongly suggest that allowing users to freely choose features to label is a promising method for allowing end users to improve learning algorithms effectively.", "num_citations": "1\n", "authors": ["154"]}
{"title": "Applying the NSF broader impacts criteria to HCI research\n", "abstract": " Broader impacts emerged as a major concern in a recent evaluation of the Division of Computer and Network Systems (CNS) at the US National Science Foundation (NSF). Evaluators found that the intellectual merit contributions from the CNS investigators were strong, but broader impacts could (and should) be improved [10]. As a result, a summit was held in Washington, DC, to clarify and strengthen the broader impacts criteria for computing research [4]. In this SIG meeting, we will discuss the outcomes of this summit, with particular attention to broader impacts in human-computer interaction research.", "num_citations": "1\n", "authors": ["154"]}
{"title": "End-user software engineering\n", "abstract": " End-user software engineering (EUSE) refers to processes and technologies that enable ordinary end users to create, perfect, share, and otherwise work with their own software to achieve quality high enough for its intended use (Ko 2010; Nardi 1993). Thus, EUSE combines the goal of end-user programming (EUP), which focuses on enabling end users to create software, with the concern for quality of that software across its entire lifecycle (not just the \u201ccreate\u201d stage).The distinction between EUSE and EUP became increasingly important in the late 1990\u2019s, as people became more reliant on software they created for themselves using spreadsheets, database systems, scripting languages, and other environments. Today, research based on US Bureau of Census and Bureau of Labor data indicates that at least a sixth of the American population now use these tools at work (Scaffidi et al. 2005), highlighting the\u00a0\u2026", "num_citations": "1\n", "authors": ["154"]}
{"title": "The future of software engineering: enhancing human expertise in tackling software quality\n", "abstract": " This paper argues that the essential point of software engineering is not to (semi-automatically) improve the quality of software, but rather to help human problem solvers to improve the quality of software. This paper argues that this essential point of software engineering research has been forgotten, and that without regaining that perspective, significant progress is not likely.", "num_citations": "1\n", "authors": ["154"]}
{"title": "End-user feature engineering in the presence of class imbalance\n", "abstract": " Intelligent user interfaces, such as recommender systems and email classifiers, use machine learning algorithms to customize their behavior to the preferences of an end user. Although these learning systems are somewhat reliable, they are not perfectly accurate. Traditionally, end users who need to correct these learning systems can only provide more labeled training data. In this paper, we focus on incorporating new features suggested by the end user into machine learning systems. To investigate the effects of user-generated features on accuracy we developed an auto-coding application that enables end users to assist a machine-learned program in coding a transcript by adding custom features. Our results show that adding user-generated features to the machine learning algorithm can result in modest improvements to its F1 score. Further improvements are possible if the algorithm accounts for class imbalance in the training data and deals with low-quality user-generated features that add noise to the learning algorithm. We show that addressing class imbalance improves performance to an extent but improving the quality of features brings about the most beneficial change. Finally, we discuss changes to the user interface that can help end users avoid the creation of low-quality features.", "num_citations": "1\n", "authors": ["154"]}
{"title": "Design implications for end-user debugging tools: A strategy-based view\n", "abstract": " End-user programmers\u2019 code (eg, accountants\u2019 spreadsheet formulas) is fraught with errors. To help mitigate this problem, end-user software engineering research is becoming established. However, most of this work has focused on feature usage, rather than debugging strategies. If a debugging tool were to support end-user programmers\u2019 specific debugging strategy needs, what should it take into account and how? To consider the design of such tools, this work contributes a comprehensive overview of end-user debugging strategies at four strategy levels. An example empirical study in Microsoft Excel demonstrates that this view of debugging provides useful insights, and we argue that many of these insights generalize to other environments. Our results include end-user debugging tactics and the effective and ineffective moves employed to achieve them, ten end-user debugging strategems applied to a new environment, and how these strategems were used within three contexts: by strategy used, by sensemaking step, and by debugging phase. These findings coalesce into a comprehensive overview of end-user debugging strategies and detailed implications for the design of strategy-based end-user debugging tools.", "num_citations": "1\n", "authors": ["154"]}
{"title": "A Methodology to Improve Dependability in Spreadsheets\n", "abstract": " Spreadsheets are one of the most commonly used end user programming environments. As such, there has been significant effort on the part of researchers and practitioners to develop methodologies and tools to improve the dependability of spreadsheets. Our work has focused on the development of the \u00c3\u00a2 \u00e2 \u201a\u00ac \u00c5 \u201cWhat You See Is What You Test\u00c3\u00a2 \u00e2 \u201a\u00ac \u00c2 (WYSIWYT) family of techniques. WYSIWYT is designed to be seamlessly integrated into a spreadsheet environment and the user\u00c3\u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 s development processes. It uses visual devices that are integrated into the user\u00c3\u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 s spreadsheet to guide the process of finding and fixing problems with the spreadsheet.", "num_citations": "1\n", "authors": ["154"]}
{"title": "Toward Sharing Reasoning to Improve Fault Localization in Spreadsheets\n", "abstract": " Although researchers have developed several ways to reason about the location of faults in spreadsheets, no single form of reasoning is without limitations. Multiple types of errors can appear in spreadsheets, and various fault localization techniques differ in the kinds of errors that they are effective in locating. Because end users who debug spreadsheets consistently follow the advice of fault localization systems [9], it is important to ensure that fault localization feedback corresponds as closely as possible to where the faults actually appear.In this paper, we describe an emerging system that attempts to improve fault localization for end-user programmers by sharing the results of the reasoning systems found in WYSIWYT [13, 14] and UCheck [1, 6]. By understanding the strengths and weaknesses of the reasoning found in each system, we expect to identify where different forms of reasoning complement one another, when different forms of reasoning contradict one another, and which heuristics can be used to select the best advice from each system. By using multiple forms of reasoning in conjunction with heuristics to choose among recommendations from each system, we expect to produce unified fault localization feedback whose combination is better than the sum of the parts.", "num_citations": "1\n", "authors": ["154"]}
{"title": "WYSIWYT testing in the spreadsheet paradigm: an empirical study of end users\n", "abstract": " This paper reports on an empirical study involving end users that addresses the question of whether it is possible to provide the benefits of formal testing within the informal spreadsheet paradigm. We have developed a\" What You See Is What You Test\"(WYSIWYT) methodology that brings the benefits of formal testing in a way that does not require the users to learn the underlying software engineering theory about testing. Our WYSIWYT methodology attempts to do this by supplementing the immediate visual feedback about the values in cells with feedback about their\" testedness\". A previous controlled experiment using computer science students showed that the subjects who used the methodology were significantly more effective and more efficient in their testing and significantly less overconfident about the correctness of their spreadsheets than subjects who did not use the methodology. The results were obtained without providing any training in the theory of testing or test adequacy that the methodology implements. In this paper we report the results of a similar experiment that investigated whether spreadsheet end users with little or no programming experience would obtain the same benefits using the methodology.", "num_citations": "1\n", "authors": ["154"]}
{"title": "Visual programming languages from an object-oriented perspective\n", "abstract": " Visual programming language research has evolved greatly since its early days. At first, attempts at visual programming mostly took the form of flowchart-like diagrams. But in recent years, a wide number of innovative approaches have been incorporated into visual languages, including object-oriented programming, form-based programming, programming by demonstration, and dataflow programming. Unfortunately, while many of these systems represent important ideas, only a few have been successful as complete visual programming languages. This tutorial explains why this is true, and describes ways in which the problem can be addressed. This tutorial explores the issues behind the successes and failures of earlier approaches from a design perspective. It identifies characteristics of successful visual programming languages, and explains how to design an object-oriented language that maintains those\u00a0\u2026", "num_citations": "1\n", "authors": ["154"]}
{"title": "Efficiency issues in a class of visual language\n", "abstract": " A class of visual programming languages whose members share a common group of underlying principles is identified. In this class (the demand-driven temporal-assignment visual language model), the elimination of certain duplicate computations is a natural by-product of the model. The potential time and space complexity characteristics for visual languages based on this model are discussed, and a method that makes use of these characteristics is presented.< >", "num_citations": "1\n", "authors": ["154"]}