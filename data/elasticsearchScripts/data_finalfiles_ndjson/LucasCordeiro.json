{"title": "Handling loops in bounded model checking of C programs via k-induction\n", "abstract": " The first attempts to apply the k-induction method to software verification are only recent. In this paper, we present a novel proof by induction algorithm, which is built on the top of a symbolic context-bounded model checker and uses an iterative deepening approach to verify, for each step k up to a given maximum, whether a given safety property  holds in the program. The proposed k-induction algorithm consists of three different cases, called base case, forward condition, and inductive step. Intuitively, in the base case, we aim to find a counterexample with up to k loop unwindings; in the forward condition, we check whether loops have been fully unrolled and that  holds in all states reachable within k unwindings; and in the inductive step, we check that whenever  holds for k unwindings, it also holds after the next unwinding of the system. The algorithm was implemented in two different ways, a sequential\u00a0\u2026", "num_citations": "70\n", "authors": ["1711"]}
{"title": "DSVerifier: A bounded model checking tool for digital systems\n", "abstract": " This work presents the Digital-Systems Verifier (DSVerifier), which is a verification tool developed for digital systems. In particular, DSVerifier employs the bounded model checking technique based on satisfiability modulo theories (SMT) solvers, which allows engineers to verify the occurrence of design errors, due to the finite word-length approach employed in fixed-point digital filters and controllers. This tool consists in an additional module for the efficient SMT-based context-bounded model checker and presents command-line and graphical user interface (GUI) versions. Indeed, the GUI version is essential for reporting property violations, together with associated counterexamples. DSVerifier is implemented in C/C and uses JavaFX for providing GUI support.", "num_citations": "36\n", "authors": ["1711"]}
{"title": "ESBMC v6. 0: Verifying C programs using k-induction and invariant inference\n", "abstract": " ESBMC v6. 0 employs a k-induction algorithm to both falsify and prove safety properties in C programs. We have developed a new interval-invariant generator that pre-processes the program, inferring invariants based on intervals and introducing them in the program as assumptions. Our experiments show that ESBMC v6. 0 using k-induction can prove up to 7% more programs when the invariant generation is enabled.", "num_citations": "35\n", "authors": ["1711"]}
{"title": "Model checking LTL properties over ANSI-C programs with bounded traces\n", "abstract": " Context-bounded model checking has been used successfully to verify safety properties in multi-threaded systems automatically, even if they are implemented in low-level programming languages such as C. In this paper, we describe and experiment with an approach to extend context-bounded software model checking to safety and liveness properties expressed in linear-time temporal logic (LTL). Our approach checks the actual C program, rather than an extracted abstract model. It converts the LTL formulas into B\u00fcchi automata for the corresponding never claims and then further into C monitor threads that are interleaved with the execution of the program under analysis. This combined system is then checked using the ESBMC model checker. We use an extended, four-valued LTL semantics to handle the finite traces that bounded model checking explores; we thus check the combined system several\u00a0\u2026", "num_citations": "35\n", "authors": ["1711"]}
{"title": "Model Checking Embedded C Software Using k-Induction and Invariants\n", "abstract": " We present a novel proof by induction algorithm, which combines k-induction with invariants to model check embedded C software with bounded and unbounded loops. The k-induction algorithm consists of three cases: in the base case, we aim to find a counterexample with up\u00a0to k loop unwindings; in the forward condition, we check whether loops have been fully unrolled and that the safety property P holds in all states reachable within k unwindings; and in the inductive step, we check that whenever P holds for k unwindings, it also holds after the next unwinding of the system. For each step of the k-induction algorithm, we infer invariants using affine constraints (i.e., polyhedral) to specify pre and postconditions. The algorithm was implemented in two different ways, with and without invariants using polyhedral, and the results were compared. Experimental results show that both forms can handle a wide\u00a0\u2026", "num_citations": "34\n", "authors": ["1711"]}
{"title": "Verification of fixed-point digital controllers using direct and delta forms realizations\n", "abstract": " The extensive use of fixed-point digital controllers demands a growing effort to prevent design errors that appear in the discrete-time domain. The present article describes a novel verification methodology, which employs bounded model checking (BMC) based on satisfiability modulo theories (SMT) to verify the occurrence of the design errors, because of the finite word-length (FWL) format, in fixed-point digital controllers. Here, the performance realizations of the digital controllers realizations that use delta operators are compared to those that use traditional direct forms. The experimental results show that the delta-form realization substantially reduces the digital controllers\u2019 fragility when compared to the direct-form realization. Additionally, the proposed methodology can be very effective and efficient to verify real-world digital controllers, where conclusive results are obtained in nearly 98\u00a0% of the benchmarks.", "num_citations": "33\n", "authors": ["1711"]}
{"title": "Formal non-fragile stability verification of digital control systems with uncertainty\n", "abstract": " A verification methodology is described and evaluated to formally determine uncertain linear systems stability in digital controllers with considerations to the implementation aspects. In particular, this methodology is combined with the digital-system verifier (DSVerifier), which is a verification tool that employs Bounded Model Checking based on Satisfiability Modulo Theories to check the stability of digital control systems with uncertainty. DSVerifier determines the control system stability, considering all the plant interval variation set, together with the Finite Word-length (FWL) effects in the digital controller implementation; DSVerifier checks the robust non-fragile stability of a given closed-loop system. The proposed methodology and respective tool are evaluated considering non-fragile control examples from literature. Experimental results show that the approach used in this study is able to foresee fragility problems in\u00a0\u2026", "num_citations": "30\n", "authors": ["1711"]}
{"title": "Applying SMT-based verification to hardware/software partitioning in embedded systems\n", "abstract": " When performing hardware/software co-design for embedded systems, the problem of which functions of the system should be implemented in hardware (HW) or in software (SW) emerges. This problem is known as HW/SW partitioning. Over the last 10\u00a0years, a significant research effort has been carried out in this area. In this paper, we present two new approaches to solve the HW/SW partitioning problem by using verification techniques based on satisfiability modulo theories (SMT). We compare the results using the traditional technique of integer linear programming, specifically binary integer programming and a modern method of optimization by genetic algorithm. The experimental results show that SMT-based verification techniques can be effective in particular cases to solve the HW/SW partition problem optimally using a state-of-the-art model checker based on SMT solvers, when compared against\u00a0\u2026", "num_citations": "30\n", "authors": ["1711"]}
{"title": "An agile development methodology applied to embedded control software under stringent hardware constraints\n", "abstract": " In recent years, discrete control systems play an important role in the development and advancement of modern civilization and technology. Practically every aspect of our life is affected by some type of control systems. This kind of system maybe classified as an embedded real-time system and requires rigorous methodologies to develop the software that is under stringent hardware constraints. Therefore, the proposed development methodology adapts agile principles and patterns in order to build embedded control systems focusing on the issues related to the system's constraints and safety. Strong unit testing is the foundation of the proposed methodology for ensuring timeliness and correctness. Moreover, platform-based design approach is used to balance costs and time-to-market in view of performance and functionality constraints. We conclude that the proposed methodology reduces significantly the design\u00a0\u2026", "num_citations": "30\n", "authors": ["1711"]}
{"title": "Agile development methodology for embedded systems: A platform-based design approach\n", "abstract": " This paper describes an agile development methodology which combines agile principles with organizational patterns and adapts them to build embedded real-time systems focusing on the system's constraints. The hardware/software partitioning and platform-based design are used in the proposed methodology to support the embedded system designer meet the system's constraints in an iterative and incremental way and to reduce substantially the design time and cost of the product. To discuss the strengths and weakness of this methodology, a case study involving a pulse oximeter is also presented", "num_citations": "30\n", "authors": ["1711"]}
{"title": "SMT-based bounded model checking for multi-threaded software in embedded systems\n", "abstract": " The transition from single-core to multi-core processors has made multi-threaded software an important subject over the last years in computer-aided verification. Model checkers have been successfully applied to discover subtle errors, but they suffer from combinatorial state space explosion when verifying multi-threaded software. In our previous work, we have extended the encodings from SMT-based bounded model checking (BMC) to provide more accurate support for program verification and to use different background theories and solvers in order to improve scalability and precision in a completely automatic way. We now focus on extending this work to support an SMT-based BMC formulation of multithreaded software which allows the state space to be reduced by abstracting the number of state variables and interleavings from the proof of unsatisfiability generated by the SMT solvers. The core idea of our\u00a0\u2026", "num_citations": "26\n", "authors": ["1711"]}
{"title": "Bounded model checking of C++ programs based on the Qt cross\u2010platform framework\n", "abstract": " The software development process for embedded systems is getting faster and faster, which generally incurs an increase in the associated complexity.\u00a0As a consequence, technology companies tend to invest in fast and automatic verification mechanisms, to create robust systems and reduce product recall rates.\u00a0In addition, further development\u2010time reduction and system robustness can be achieved through cross\u2010platform frameworks, such as Qt, which favor the reliable port of software stacks to different devices.\u00a0Based on that, the present paper proposes a simplified version of the Qt framework, which is integrated into a checker based on satisfiability modulo theories (SMT), known as the Efficient SMT\u2010based Context\u2010Bounded Model Checker, for verifying actual Qt\u2010based applications, with a success rate of 89%, for the developed benchmark suite. Furthermore, the simplified version of the Qt framework, named as\u00a0\u2026", "num_citations": "23\n", "authors": ["1711"]}
{"title": "Context-bounded model checking of LTL properties for ANSI-C software\n", "abstract": " Context-bounded model checking has successfully been used to verify safety properties in multi-threaded systems automatically, even if they are implemented in low-level programming languages like ANSI-C. In this paper, we describe and experiment with an approach to extend context-bounded model checking to liveness properties expressed in linear-time temporal logic (LTL). Our approach converts the LTL formulae into B\u00fcchi-automata and then further into C monitor threads, which are interleaved with the execution of the program under test. This combined system is then checked using the ESBMC model checker. Since this approach explores a larger number of interleavings than normal context-bounded model checking, we use a state hashing technique which substantially reduces the number of redundant interleavings that are explored and so mitigates state space explosion. Our experimental\u00a0\u2026", "num_citations": "22\n", "authors": ["1711"]}
{"title": "Verifying CUDA programs using SMT-based context-bounded model checking\n", "abstract": " We present ESBMC-GPU, an extension to the ESBMC model checker that is aimed at verifying GPU programs written for the CUDA framework. ESBMC-GPU uses an operational model for the verification, ie, an abstract representation of the standard CUDA libraries that conservatively approximates their semantics. ESBMC-GPU verifies CUDA programs, by explicitly exploring the possible interleavings (up to the given context bound), while treating each interleaving itself symbolically. Experimental results show that ESBMC-GPU is able to detect more properties violations, while keeping lower rates of false results.", "num_citations": "21\n", "authors": ["1711"]}
{"title": "Bounded model checking for fixed-point digital filters\n", "abstract": " Currently, digital filters are employed in a wide range of signal processing applications, using fixed- and floating-point processors. Regarding the former, some filter implementations may be highly prone to errors, due to problems related to finite word-length. In particular, signal processing modules may produce overflows and unwanted noise, which are caused by quantization and round-off effects, during accumulative-addition and multiplication operations. As a consequence, the system output may overflow or even keep oscillating, which compromises the expected system performance. The present paper addresses this problem and proposes a new methodology for verifying digital filters, called digital systems verifier, which is based on state-of-the-art bounded model checkers that support full C and employ solvers for boolean satisfiability and satisfiability modulo theories. In addition to verifying overflow and limit-cycle occurrences, the present approach can also check output errors and time constraints, based on discrete-time models implemented in C. Experiments conducted during this work show that the proposed methodology is effective, when finding realistic design errors with respect to fixed-point implementations of digital filters. Going further than previous attempts, the present results suggest that the proposed method, in addition to helping designers in determining the number of bits for fixed-point representations, can also aid in defining details about filter realization and structure.", "num_citations": "19\n", "authors": ["1711"]}
{"title": "Continuous verification of large embedded software using SMT-based bounded model checking\n", "abstract": " The complexity of software in embedded systems has increased significantly over the last years so that software verification now plays an important role in ensuring the overall product quality. In this context, bounded model checking has been successfully applied to discover subtle errors, but for larger applications, it often suffers from the state space explosion problem. This paper describes a new approach called continuous verification to detect design errors as quickly as possible by exploiting information from the software configuration management system and by combining dynamic and static verification to reduce the state space to be explored. We also give a set of encodings that provide accurate support for program verification and use different background theories in order to improve scalability and precision in a completely automatic way. A case study from the telecommunications domain shows that the\u00a0\u2026", "num_citations": "19\n", "authors": ["1711"]}
{"title": "ESBMC-GPU A context-bounded model checking tool to verify CUDA programs\n", "abstract": " The Compute Unified Device Architecture (CUDA) is a programming model used for exploring the advantages of graphics processing unit (GPU) devices, through parallelization and specialized functions and features. Nonetheless, as in other development platforms, errors may occur, due to traditional software creation processes, which may even compromise the execution of an entire system. In order to address such a problem, ESBMC-GPU was developed, as an extension to the Efficient SMT-Based Context-Bounded Model Checker (ESBMC). In summary, ESBMC processes input code through ESBMC-GPU and an abstract representation of the standard CUDA libraries, with the goal of checking a set of desired properties. Experimental results showed that ESBMC-GPU was able to correctly verify 85% of the chosen benchmarks and it also overcame other existing GPU verifiers regarding the verification of data\u00a0\u2026", "num_citations": "18\n", "authors": ["1711"]}
{"title": "Bounded model checking of C++ programs based on the Qt framework\n", "abstract": " The software development process for embedded systems is getting faster and faster, which generally incurs an increase in the associated complexity. As a consequence, consumer electronics companies usually invest a lot of resources in fast and automatic verification processes, in order to create robust systems and reduce product recall rates. Because of that, the present paper proposes a simplified version of the Qt framework, which is integrated into the Efficient SMT-Based Bounded Model Checking tool to verify actual applications that use the mentioned framework. The method proposed in this paper presents a success rate of 94.45%, for the developed test suite.", "num_citations": "18\n", "authors": ["1711"]}
{"title": "SMT\u2010based context\u2010bounded model checking for CUDA programs\n", "abstract": " We present ESBMC\u2010GPU tool, an extension to the Efficient SMT\u2010Based Context\u2010Bounded Model Checker (ESBMC), which is aimed at verifying Graphics Processing Unit (GPU) programs written for the Compute Unified Device Architecture (CUDA) platform. ESBMC\u2010GPU uses an operational model, that is, an abstract representation of the standard CUDA libraries, which conservatively approximates their semantics, in order to verify CUDA\u2010based programs. It then explicitly explores the possible interleavings (up to the given context bound), while treats each interleaving itself symbolically. Additionally, ESBMC\u2010GPU employs the monotonic partial order reduction and the two\u2010thread analysis to prune the state space exploration. Experimental results show that ESBMC\u2010GPU can successfully verify 82% of all benchmarks, while keeping lower rates of false results. Going further than previous attempts, ESBMC\u2010GPU is\u00a0\u2026", "num_citations": "16\n", "authors": ["1711"]}
{"title": "SMT-based bounded model checking of fixed-point digital controllers\n", "abstract": " Digital controllers have several advantages with respect to their flexibility and design's simplicity. However, they are subject to problems that are not faced by analog controllers. In particular, these problems are related to the finite word-length implementation that might lead to overflows, limit cycles, and time constraints in fixed-point or floating-point processors. This paper proposes a new method to detect design's errors in fixed-point digital controllers using a state-of-the art bounded model checker based on satisfiability modulo theories. The experiments with a commercial plant demonstrate that the proposed method can be effective in finding errors in digital controllers than other existing approaches, which are based on traditional simulations tools. The verification results are conclusive in 93.5% of the benchmarks, determining the absence or occurrence of errors.", "num_citations": "16\n", "authors": ["1711"]}
{"title": "SMT-based bounded model checking of multi-threaded software in embedded systems\n", "abstract": " Our reliance on the correct functioning of embedded systems is growing rapidly. Such systems are used in a wide range of applications such as airbag control systems, mobile phones, and high-end television sets. These systems are becoming more and more complex and require multi-core processors with scalable shared memory to meet the increasing computational power demands. The reliability of the embedded (distributed) software is thus a key issue in the system development. In this thesis we describe and evaluate an approach to reason accurately and effectively about large embedded software using bounded model checking (BMC) based on Satisfiability Modulo Theories (SMT) techniques. We present three major novel contributions. First, we extend the encodings from previous SMT-based bounded model checkers to provide more accurate support for variables of finite bit width, bit-vector operations, arrays, structures, unions and pointers and thus making our approach suitable to reason about embedded software. We then provide new encodings into existing SMT theories and we show that our translations from ANSI-C programs to SMT formulas are as precise as bit-accurate procedures based on Boolean Satisfiability. Second, we develop three related approaches for model checking multi-threaded software in embedded systems. In the lazy approach, we generate all possible interleavings and call the SMT solver on each of them individually, until we either find a bug, or have systematically explored all interleavings. In the schedule recording approach, we encode all possible interleavings into one single formula and then exploit\u00a0\u2026", "num_citations": "16\n", "authors": ["1711"]}
{"title": "TXM: an agile HW/SW development methodology for building medical devices\n", "abstract": " Arterial oxygen saturation and heart rate measured by pulse oximetry is widely used to monitor critical care patients. This kind of system is classified as embedded hard real-time system and requires rigorous development methodologies to guarantee the correctness and timeliness of the application. Therefore, the proposed development methodology combines agile principles with organizational patterns and adapts them to build medical devices focusing on the issues related to the system's constraints and safety. Strong unit testing is the foundation of the proposed methodology for ensuring timeliness and correctness. Moreover, platform-based design approach is used to balance costs and time-to-market in view of performance and functionality constraints. We conclude that the proposed methodology reduces significantly the design time and cost as well as leads to better software modularity and safety.", "num_citations": "16\n", "authors": ["1711"]}
{"title": "DSVerifier-aided verification applied to attitude control software in unmanned aerial vehicles\n", "abstract": " During the last decades, model checking techniques have been applied to improve overall system reliability, in unmanned aerial vehicle (UAV) approaches. Nonetheless, there is little effort focused on applying those methods to the control-system domain, especially when it comes to the investigation of low-level implementation errors, which are related to digital controllers and hardware compatibility. The present study addresses the mentioned problems and proposes the application of a bounded model checking tool, named as Digital System Verifier (DSVerifier), to the verification of digital-system implementation issues, in order to investigate problems that emerge in digital controllers designed for UAV attitude systems. A verification methodology to search for implementation errors related to finite word-length effects (e.g., arithmetic overflows and limit cycles), in UAV attitude controllers, is presented, along with its\u00a0\u2026", "num_citations": "14\n", "authors": ["1711"]}
{"title": "ESBMC: A Bounded Model Checking Tool to Verify Qt Applications\n", "abstract": " We integrate a simplified model of the Qt framework, named as Qt operational model (QtOM), into the efficient SMT-based context-bounded model checker (ESBMC++), which results in ESBMC. In particular, ESBMC is a bounded model checking tool to verify Qt-based applications, which focuses on the verification of code properties, such as invalid memory access and containers usage, through pre- and postconditions, data usage evaluation, and simulation features. Experimental results show that ESBMC can be effectively and efficiently applied to verify Qt-based consumer electronics applications.", "num_citations": "14\n", "authors": ["1711"]}
{"title": "Planning and evaluation of UAV mission planner for intralogistics problems\n", "abstract": " We describe and evaluate the development of mission planners in intralogistics for a commercial unmanned aerial vehicle equipped with a robotic gripper in an industrial environment, which consists of an input warehouse, production lines, and a product depot. In this particular study, the planner produces the needed commands for carrying out a given mission, which includes the delivery of inputs picked up from the warehouse to the production line until the final product is delivered to the client (product depot). We propose two different approaches for mission planning: in the first approach, a simple heuristic is used to solve the mission problem, where a UAV obtains the needed inputs to produce a product from the warehouse, and then it brings the product to the respective production line and waits to finish its production; in the second approach, a technique with task scheduling (production process) is employed\u00a0\u2026", "num_citations": "13\n", "authors": ["1711"]}
{"title": "SMT-based verification applied to non-convex optimization problems\n", "abstract": " This paper presents a novel, complete, and flexible optimization algorithm, which relies on recursive executions that re-constrains a model-checking procedure based on Satisfiability Modulo Theories (SMT). This SMT-based optimization technique is able to optimize a wide range of functions, including non-linear and non-convex problems using fixed-point arithmetic. Although SMT-based optimization is not a new technique, this work is the pioneer in solving non-linear and non-convex problems based on SMT; previous applications are only able to solve integer and rational linear problems. The proposed SMT-based optimization algorithm is compared to other traditional optimization techniques. Experimental results show the efficiency and effectiveness of the proposed algorithm, which finds the optimal solution in all evaluated benchmarks, while traditional techniques are usually trapped by local minima.", "num_citations": "13\n", "authors": ["1711"]}
{"title": "Verifying fixed-point digital filters using SMT-based bounded model checking\n", "abstract": " The implementation of digital filters in processors based on fixed-point arithmetic can lead to problems related to the finite word-length. In particular, the processing of signals in such filters can produce overflows and unwanted noise caused by quantization and round off effect during the accumulative addition and multiplication operations. In this paper, we describe a new approach to verify digital filters using an off-the-shelf bounded model checker called ESBMC, which supports full C/C++ and is based on satisfiability modulo theories solvers. In particular, we are able to verify the occurrence of overflows, limit cycles, and time constraints based on a discrete-time model implemented in C. The experiments show that the proposed approach can be used to verify potential problems in fixed-point implementation of digital filters and it can thus be effective in finding realistic design errors.", "num_citations": "13\n", "authors": ["1711"]}
{"title": "Automated formal verification of stand-alone solar photovoltaic systems\n", "abstract": " With declining costs and increasing performance, the deployment of renewable energy systems is growing faster. In 2017, for the first time, the number of people without access to electricity dropped down below 1 billion, but trends on energy access likewise fall short of global goals. Particular attention is given to stand-alone solar photovoltaic systems in rural areas or where grid extension is unfeasible. Tools to evaluate electrification projects are available, but they are based on simulations that do not cover all aspects of the design-space. Automated verification using model checking has proven to be an effective technique to validate complex (state transition) systems. This paper marks the first application of software model checking to formally verify the design of a stand-alone solar photovoltaic system, including solar panel, charge controller, battery, inverter, and electric load. Our main focus is on the project\u00a0\u2026", "num_citations": "12\n", "authors": ["1711"]}
{"title": "Encoding floating-point numbers using the SMT theory in ESBMC: An empirical evaluation over the SV-COMP benchmarks\n", "abstract": " This paper describes the support for encoding C/C++ programs using the SMT theory of floating-point numbers in ESBMC: an SMT-based context-bounded model checker that provides bit-precise verification of C and C++ programs. In particular, we exploit the availability of two different SMT solvers (MathSAT and Z3) to discharge and check the verification conditions produced by our encoding using the benchmarks from the International Competition on Software Verification (SV-COMP). The experimental results show that our encoding based on MathSAT is able to outperform not only Z3, but also other existing approaches that participated in the most recent edition of SV-COMP.", "num_citations": "11\n", "authors": ["1711"]}
{"title": "A method to localize faults in concurrent C programs\n", "abstract": " We describe a new approach to localize faults in concurrent programs, which is based on bounded model checking and sequentialization techniques. The main novelty is the idea of reproducing a faulty behavior, in a sequential version of a concurrent program. In order to pinpoint faulty lines, we analyze counterexamples generated by a model checker, to the new instrumented sequential program, and search for a diagnostic value, which corresponds to actual lines in a program. This approach is useful to improve debugging processes for concurrent programs, since it tells which line should be corrected and what values lead to a successful execution. We implemented this approach as a code-to-code transformation from concurrent into non-deterministic sequential programs, which are used as inputs to existing verification tools. Experimental results show that our approach is effective and capable of identifying\u00a0\u2026", "num_citations": "11\n", "authors": ["1711"]}
{"title": "Hunting memory bugs in C programs with Map2Check\n", "abstract": " Map2Check is a tool for automatically generating and checking unit tests for C programs. The generation of unit tests is based on assertions extracted from (memory) safety properties, which are generated by the ESBMC tool. In particular, Map2Check checks for SV-COMP invalid-free, invalid-dereference, and memory-leak properties in C programs.", "num_citations": "11\n", "authors": ["1711"]}
{"title": "Verification of delta form realization in fixed-point digital controllers using bounded model checking\n", "abstract": " The extensive use of fixed-point digital controllers demands a growing effort to prevent design's errors that appear in the discrete-time domain. This paper presents a novel verification methodology that employs Bounded Model Checking (BMC) based on the Satisfiability Modulo Theories to verify the occurrence of design's errors, due to the finite word-length format, in fixed-point digital controllers. Here, the performance of digital controllers realizations that use delta-operators are compared to those that use traditional direct forms. The experimental results show that the delta form realization reduces substantially the digital controllers' fragility. Additionally, the proposed methodology can be very effective and efficient to verify real-world digital controllers, where conclusive results are obtained in nearly 95% of the benchmarks.", "num_citations": "11\n", "authors": ["1711"]}
{"title": "Counterexample guided inductive optimization based on satisfiability modulo theories\n", "abstract": " This paper describes three variants of a counterexample guided inductive optimization (CEGIO) approach based on Satisfiability Modulo Theories (SMT) solvers. In particular, CEGIO relies on iterative executions to constrain a verification procedure, in order to perform inductive generalization, based on counterexamples extracted from SMT solvers. CEGIO is able to successfully optimize a wide range of functions, including non-linear and non-convex optimization problems based on SMT solvers, in which data provided by counterexamples are employed to guide the verification engine, thus reducing the optimization domain. The present algorithms are evaluated using a large set of benchmarks typically employed for evaluating optimization techniques. Experimental results show the efficiency and effectiveness of the proposed algorithms, which find the optimal solution in all evaluated benchmarks, while traditional\u00a0\u2026", "num_citations": "10\n", "authors": ["1711"]}
{"title": "Fault localization in multi-threaded C programs using bounded model checking\n", "abstract": " Software debugging is a very time-consuming process, which is even worse for multi-threaded programs, due to the non-deterministic behavior of thread-scheduling algorithms. However, the debugging time may be greatly reduced, if automatic methods are used for localizing faults. In this study, a new method for fault localization, in multi-threaded C programs, is proposed. It transforms a multi-threaded program into a corresponding sequential one and then uses a fault-diagnosis method suitable for this type of program, in order to localize faults. The code transformation is implemented with rules and context switch information from counterexamples, which are typically generated by bounded model checkers. Experimental results show that the proposed method is effective, in such a way that sequential fault localization methods can be extended to multi-threaded programs.", "num_citations": "10\n", "authors": ["1711"]}
{"title": "Applying symbolic bounded model checking to the 2012 RERS greybox challenge\n", "abstract": " We describe the application of ESBMC, a symbolic bounded model checker for C programs, to the 2012 RERS greybox challenge. We checked the reachability properties via reachability of the error labels, and the behavioral properties via a bounded LTL model checking approach. Our approach could solve about 700 properties for the small and medium problems from the offline phase, and scored overall about 5,000 marks but still ranked last in the competition.", "num_citations": "10\n", "authors": ["1711"]}
{"title": "Verifying fragility in digital systems with uncertainties using DSVerifier v2. 0\n", "abstract": " Control-system robustness verification with respect to implementation aspects lacks automated verification approaches for checking stability and performance of uncertain control systems, when considering finite word-length (FWL) effects. Here we describe and evaluate novel verification procedures for digital systems with uncertainties, based on software model checking and satisfiability modulo theories, named as DSVerifier v2.0, which is able to check robust stability of closed-loop control systems with respect to FWL effects. In particular, we describe our verification algorithms to check for limit-cycle oscillations (LCOs), output quantization error, and robust non-fragile stability on common closed-loop associations of digital control systems (i.e., series and feedback). DSVerifier v2.0 model checks new properties of closed-loop systems (e.g., LCO), including stability and output quantization error for uncertain plant\u00a0\u2026", "num_citations": "9\n", "authors": ["1711"]}
{"title": "Survey on automated symbolic verification and its application for synthesising cyber\u2010physical systems\n", "abstract": " Dependency on the correct operation of embedded systems is rapidly growing, mainly due to their wide range of applications. Their structures are becoming more complex and currently require multi-core processors with scalable shared memory, signal-processing pipelines, and sophisticated software modules to meet increasing computational power, flexibility demands. Additionally, interaction with real-world entities and modern communication capabilities further enhance the mentioned features and give rise to the embedded and cyber-physical systems (ECPS). As a consequence, the reliability of ECPS becomes a key issue during system development. Generally, state-of-the-art verification methodologies for ECPS generate test vectors and use assertion-based verification and high-level processor models, during simulation; however, new challenges arose, such as need for meeting time and energy constraints\u00a0\u2026", "num_citations": "8\n", "authors": ["1711"]}
{"title": "ESBMC: Scalable and Precise Test Generation based on the Floating-Point Theory:(Competition Contribution)\n", "abstract": " ESBMC is an SMT-based bounded model checker for realworld C programs. Such programs often represent real numbers using the floating-points, most commonly, the IEEE floating-point standard (IEEE 754-2008). Thus, ESBMC now includes a new floating-point arithmetic encoding layer in our SMT backend, that encodes floating-point operations into bit-vector operations. In particular, ESBMC can use offthe-shelf SMT solvers that offer support for bit-vectors only to encode floating-point arithmetic.", "num_citations": "8\n", "authors": ["1711"]}
{"title": "Applying multi-core model checking to hardware-software partitioning in embedded systems\n", "abstract": " We present an alternative approach to solve the hardware and software partitioning problem, which uses Bounded Model Checking (BMC) based on Satisfiability Modulo Theories (SMT) in conjunction with a multi-core support using Open Multi-Processing. The multi-core approach allows initializing many verification instances based on processors cores numbers available to the model checker. Each instance checks for a different optimum value until the optimization problem is satisfied. The goal is to show that multi-core model-checking techniques can be effective, in particular cases, to find the optimal solution of the hardware-software partitioning problem. We compare the experimental results of our proposed approach with conventional algorithms.", "num_citations": "8\n", "authors": ["1711"]}
{"title": "Memory management test-case generation of C programs using bounded model checking\n", "abstract": " We describe a novel method to automatically generate and verify memory management test cases for unit tests, which are based on assertions extracted from safety properties typically generated by bounded model checking (BMC) tools. In particular, the proposed method checks for properties related to pointer safety, memory leaks, and invalid deallocation. To investigate our method\u2019s effectiveness, we developed a tool called Map2Check that adopts the ESBMC model checker and the CUnit testing framework. Additionally, Map2Check provides an integration of BMC tools with unit testing frameworks, which helps developers not very familiar with formal methods to verify large C programs. We use Map2Check to perform an empirical evaluation over publicly available benchmarks and compare the results to recognized tools, e.g., Valgrind\u2019s Memcheck, CBMC, LLBMC, CPAChecker, Predator, and ESBMC\u00a0\u2026", "num_citations": "8\n", "authors": ["1711"]}
{"title": "ESBMC 6.1: automated test case generation using bounded model checking\n", "abstract": " ESBMC is an SMT-based bounded model checker that provides a bit-precise verification of both C and C++ programs. Bounded model checking (BMC) was developed to provide faster results when finding property violations; BMC achieves this by limiting the number of loop unwindings and recursion depth. The technique, however, is unable to prove correctness unless all loops and recursions are fully unwound, which might not be possible for some programs (e.g., infinite loops). The version of ESBMC described here is designed to avoid the problem of guessing the number of unwindings, which leads to a property violation; it incrementally verifies the program, searching only for property violations. Once ESBMC has found a property violation, it produces a test suite that contains at least one test to expose a bug. ESBMC can correctly produce 312 test cases, which are confirmed by the test validator employed by\u00a0\u2026", "num_citations": "7\n", "authors": ["1711"]}
{"title": "Map2Check: Using Symbolic Execution and Fuzzing:(Competition Contribution)\n", "abstract": " Map2Check is a software verification tool that combines fuzzing, symbolic execution, and inductive invariants. It automatically checks safety properties in C programs by adopting source code instrumentation to monitor data (eg, memory pointers) from the program\u2019s executions using LLVM compiler infrastructure. For SV-COMP 2020, we extended Map2Check to exploit an iterative deepening approach using LibFuzzer and Klee to check for safety properties. We also use Crab-LLVM to infer program invariants based on reachability analysis. Experimental results show that Map2Check can handle a wide variety of safety properties in several intricate verification tasks from SV-COMP 2020.", "num_citations": "7\n", "authors": ["1711"]}
{"title": "SMT-based refutation of spurious bug reports in the clang static analyzer\n", "abstract": " We describe and evaluate a bug refutation extension for the Clang Static Analyzer (CSA) that addresses the limitations of the existing built-in constraint solver. In particular, we complement CSA's current heuristics for removing spurious bug reports. We encode the path constraints produced by CSA as Satisfiability Modulo Theories (SMT) problems, use SMT solvers to precisely check them for satisfiability, and remove bug reports whose associated path constraints are unsatisfiable. Our refutation extension refutes spurious bug reports in 8 out of 12 widely used open-source applications; on average, it refutes ca. 7% of all bug reports, and never refutes any true bug report. It incurs only negligible performance overheads, and on average adds 1.2% to the runtime of the full Clang/LLVM toolchain. A demonstration is available at https://www.youtube.com/watch?v=ylW5iRYNsGA.", "num_citations": "7\n", "authors": ["1711"]}
{"title": "Towards counterexample-guided k-induction for fast bug detection\n", "abstract": " Recently, the k-induction algorithm has proven to be a successful approach for both finding bugs and proving correctness. However, since the algorithm is an incremental approach, it might waste resources trying to prove incorrect programs. In this paper, we extend the k-induction algorithm to shorten the number of steps required to find a property violation. We convert the algorithm into a meet-in-the-middle bidirectional search algorithm, using the counterexample produced from over-approximating the program. The main advantage is in the reduction of the state explosion by reducing the maximum required steps from k to\u230a k/2+ 1\u230b.", "num_citations": "7\n", "authors": ["1711"]}
{"title": "Sim3tanks: a benchmark model simulator for process control and monitoring\n", "abstract": " This paper describes a simulator for the three-tank system process named Sim3Tanks. This process presents a hybrid and nonlinear behavior and it is subject to different kinds of perturbations, faults, and noises. Sim3Tanks was developed in the MATLAB/Simulink environment and can be used via graphical user interface, Simulink block diagram, and command-line. Sim3Tanks is suitable for studying and developing process control, fault detection and isolation, and fault tolerant control strategies for nonlinear multi-variable systems. In order to illustrate the potential of Sim3Tanks, four scenarios are discussed throughout this paper: PID control strategies for the level and flow rates; a fault detection algorithm based on unscented Kalman filter and generalized likelihood ratio; a fault isolation system based on Bayesian networks; and a control reconfiguration based on static virtual actuator and sensor. A video\u00a0\u2026", "num_citations": "7\n", "authors": ["1711"]}
{"title": "A platform-based software design methodology for embedded control systems: An agile toolkit\n", "abstract": " A discrete control system, with stringent hardware constraints, is effectively an embedded real-time system and hence requires a rigorous methodology to develop the software involved. The development methodology proposed in this paper adapts agile principles and patterns to support the building of embedded control systems, focusing on the issues relating to a system's constraints and safety. Strong unit testing, to ensure correctness, including the satisfaction of timing constraints, is the foundation of the proposed methodology. A platform-based design approach is used to balance costs and time-to-market in relation to performance and functionality constraints. It is concluded that the proposed methodology significantly reduces design time and costs, as well as leading to better software modularity and reliability.", "num_citations": "7\n", "authors": ["1711"]}
{"title": "An efficient floating-point bit-blasting API for verifying C programs\n", "abstract": " We describe a new SMT bit-blasting API for floating-point (FP) programs and evaluate it using different off-the-shelf SMT solvers during the verification of several C programs. The new FP API is part of the SMT backend in ESBMC, a state-of-the-art bounded model checker for C and C++. For the evaluation, we compared our FP API against the native FP APIs in Z3 and MathSAT. We show that Boolector, when using our new FP API, outperforms the solvers with native support for FP, correctly verifying more programs in less time. Experimental results also show that our FP API implemented in ESBMC is on par with other state-of-the-art software verifiers. Furthermore, when verifying programs with FP arithmetic, our new FP API produced no wrong answers.", "num_citations": "6\n", "authors": ["1711"]}
{"title": "OptCE: A Counterexample-Guided Inductive Optimization Solver\n", "abstract": " This paper presents optimization through counterexamples (OptCE), which is a verification tool developed for optimizing target functions. In particular, OptCE employs bounded model checking techniques based on boolean satisfiability and satisfiability modulo theories, which are able to obtain global minima of convex and non-convex functions. OptCE is implemented in C/C, performs all optimization steps automatically, and iteratively analyzes counterexamples, in order to inductively achieve global optimization based on a verification oracle. Experimental results show that OptCE can effectively find optimal solutions for all evaluated benchmarks, while traditional techniques are usually trapped by local minima.", "num_citations": "6\n", "authors": ["1711"]}
{"title": "Multi-core model checking and maximum satisfiability applied to hardware-software partitioning\n", "abstract": " Bounded model checking (BMC) based on satisfiability modulo theories (SMT) is well-known by its capability to verify software. However, its use as optimisation tool, to solve hardware and software (HW-SW) partitioning problems, is something new. In particular, its integration with the maximum satisfiability solver vZ tool, which provides a portfolio of approaches for solving linear optimisation problems over SMT formulas, is unprecedented. We present new alternative approaches to solve the HW-SW partitioning problem. First, we use SMT-based BMC in conjunction with a multi-core support using open multi-processing to create four variants to solve the partitioning problem. The multi-core SMT-based BMC approaches allow initialising many verification instances based on the number of available processing cores, where each instance checks a different optimum value until the optimisation problem is satisfied\u00a0\u2026", "num_citations": "6\n", "authors": ["1711"]}
{"title": "Smt-based context-bounded model checking for embedded systems: Challenges and future trends\n", "abstract": " The dependency on the correct functioning of embedded systems is rapidly growing, mainly due to their wide range of applications, such as micro-grids, automotive device control (e.g., airbag control), health care, surveillance, mobile devices, and consumer electronics. Their structures are becoming more and more complex and now require multi-core processors with scalable shared memory, in order to meet increasing computational power demands. As a consequence, reliability of embedded (distributed) software becomes a key issue during system development, which must be carefully addressed and assured. Normally, state-of-the-art verification methodologies for embedded systems generate test vectors (with constraints) and use assertion-based verification and highlevel processor models, during simulation; however, other additional challenges have been raised: the need for meeting time and energy\u00a0\u2026", "num_citations": "6\n", "authors": ["1711"]}
{"title": "Aplicando verifica\u00e7\u00e3o de modelos para o particionamento de hardware/software\n", "abstract": " Quando se realiza um coprojeto de hardware/software para sistemas embarcados, emerge o problema de se decidir qual fun\u00e7\u00e3o do sistema deve ser implementada em hardware (HW) ou em software (SW). Este tipo de problema recebe o nome de particionamento de HW/SW. Na \u00faltima d\u00e9cada, um esfor\u00e7o significante de pesquisa tem sido empregado nesta \u00e1rea. Neste artigo, s\u00e3o apresentadas duas novas abordagens para resolver o problema de particionamento de HW/SW usando a t\u00e9cnica de verifica\u00e7\u00e3o de modelos com a ferramenta ESBMC (Efficient SMT-Based Bounded Model Checker). S\u00e3o comparados os resultados obtidos com a tradicional t\u00e9cnica de programa\u00e7\u00e3o linear inteira e com o m\u00e9todo moderno de otimiza\u00e7\u00e3o por algoritmo gen\u00e9tico. O objetivo \u00e9 demonstrar, com os resultados emp\u00edricos, que as t\u00e9cnicas de verifica\u00e7\u00e3o de modelo podem ser efetivas, em casos particulares, para encontrar a solu\u00e7\u00e3o \u00f3tima do problema de particionamento HW/SW, quando comparado com t\u00e9cnicas usuais.", "num_citations": "6\n", "authors": ["1711"]}
{"title": "Gift young engineers: An extra-curricular initiative for updating computer and electrical engineering courses\n", "abstract": " The curricula of engineering courses are well defined by the central government for all Brazilian universities. Indeed, there are some mandatory determinations that must be fulfilled prior to the accreditation of any engineering course in Brazil. Modifications must be submitted for evaluation beforehand, resulting in a process that sometimes takes years to be approved. That is a secure way to guarantee that the fundamentals of each engineering program will be part of the students' carrier all over the country, and at the same time a problem when you need to introduce new technological subjects. That poses a problem when you have new demands for technological curricular components that could express the actual state of the art of modern subjects. Trying to solve these issues some professors from the Federal University of Amazonas developed a flexible extra-curricular program for electrical and computer\u00a0\u2026", "num_citations": "6\n", "authors": ["1711"]}
{"title": "Applying Scrum and Organizational Patterns to Multi-site Software Development\n", "abstract": " This paper describes a pattern language for managing multi-site software projects which aims at minimizing the main problems present on the multi-site software development context. The practices and patterns of the proposed language were first identified from the literature and adapted according to the authors\u2019 experience after running some multi-site software projects. This exercise has led to the identification of two new patterns: \"Stories Rework Subsystem\", and \"Plan Bugs On a Sustainable Pace\", as well as to an alternative application of the existing \"Inversion of Control\" pattern to the organizational context.", "num_citations": "6\n", "authors": ["1711"]}
{"title": "Incremental Bounded Model Checking of Artificial Neural Networks in CUDA\n", "abstract": " Artificial Neural networks (ANNs) are powerful computing systems employed for various applications due to their versatility to generalize and to respond to unexpected inputs/patterns. However, implementations of ANNs for safety-critical systems might lead to failures, which are scarcely predicted in the design phase as ANNs are highly parallel and their parameters are hardly interpretable. Here we develop and evaluate a novel symbolic software verification framework based on incremental bounded model checking (BMC) to check for adversarial cases and coverage methods in multi-layer perceptron (MLP). We developed and evaluated a novel symbolic software verification framework based on incremental bounded model checking (BMC) to check for adversarial cases and coverage methods in a multi-layer perceptron(MLP). Besides, we developed an efficient SMT-based Context-Bounded Model Checker for\u00a0\u2026", "num_citations": "5\n", "authors": ["1711"]}
{"title": "Verifica\u00e7\u00e3o de Kernels em Programas CUDA usando Bounded Model Checking\n", "abstract": " This paper presents an extension to the Efficient SMT-Based Context-Bounded Model Checker (ESBMC) for verifying Graphics Processing Unit (GPU) programs, called ESBMC-GPU. In particular, ESBMC-GPU is a Context-Bounded Model Checker based on the Satisfiability Modulo Theories for programs written in Compute Unified Device Architecture (CUDA). It is based on an operational model, an abstract representation of the standard CUDA libraries that conservatively approximates their semantics. With ESBMC-GPU, it is possible to verify more realistic CUDA programs than other existing approaches.Resumo. Este artigo apresenta uma extensao da ferramenta Efficient SMT-Based Context-Bounded Model Checker (ESBMC) para verificar programas que executam em unidades de processamento gr\u00e1fico (GPU), chamado de ESBMCGPU. Em especial, ESBMC-GPU \u00e9 um verificador de modelos limitado baseado nas teorias do m\u00f3dulo da satisfatibilidade para programas desenvolvidos na arquitetura de dispositivo unificado de computa\u00e7ao (CUDA). O ESBMC-GPU \u00e9 baseado em um modelo operacional, uma representa\u00e7ao abstrata das bibliotecas padroes do CUDA que conservadoramente aproxima suas sem\u00e2nticas. Com ESBMC-GPU, \u00e9 poss\u0131vel verificar mais programas CUDA reais do que outras abordagens existentes.", "num_citations": "5\n", "authors": ["1711"]}
{"title": "BMCLua: Verification of Lua programs in digital TV interactive applications\n", "abstract": " The present paper describes a novel scheme for checking for potential defects in Lua programs, by using Bounded Model Checking (BMC). Such an approach, called BMCLua, translates a Lua program into an ANSI-C one, which is then verified by the Efficient SMT-Based Bounded Model Checker (ESBMC). BMCLua is able to check for safety properties related to array bounds, division by zero, and user-specified assertions, in Lua programs. This paper marks the first application of BMC to Lua programs. The experimental results show that the performance of BMCLua is similar to that of ESBMC, in about 70% of the benchmarks used for evaluation.", "num_citations": "5\n", "authors": ["1711"]}
{"title": "Exploiting safety properties in bounded model checking for test cases generation of C programs\n", "abstract": " The use of computer-based systems in several domains such as automotive, industrial automation, and transportation has increased significantly over the last years so that software verification now plays an important role in ensuring the overall product quality. The value of the counterexample and safety properties generated by Bounded Model Checkers to create test case and to debug these systems is highly recognized. In this paper, we describe a method to integrate the bounded model checker ESBMC with the CUnit framework. This method aims to extract the safety properties generated by ESBMC to generate automatically test cases using the rich set of assertions provided by the CUnit framework. We show the effectiveness of our proposed method over publicly available benchmarks.", "num_citations": "5\n", "authors": ["1711"]}
{"title": "Mandos: A User Interaction Method in Embedded Applications for Mobile Telephony\n", "abstract": " With the intense use of applicative in mobile device, the question \"usability\" begins to invigorate strongly as a study object, it is being considered a determinant factor of the success of this segment of the mobile computation. This article proposes an improvement way in the usability of the embedded applicative in mobile devices, considering a new method of user interaction. The Mandos interaction method is based on task idea, which consists in a possible operation that could be executed in an applicative by the user and probabilities between task changes. The cited probabilities will be used for construction of the user interface to interact dynamically with the user. To validate the considered method was developed a framework, called Mandos, which propitiates functionalities to the applicative developer that uses Java technology. A case study will be presented where some prototypes of embedded applicative\u00a0\u2026", "num_citations": "5\n", "authors": ["1711"]}
{"title": "FuSeBMC: A white-box fuzzer for finding security vulnerabilities in C programs (competition contribution)\n", "abstract": " We describe and evaluate a novel white-box fuzzer for C programs named FuSeBMC, which combines fuzzing and symbolic execution, and applies Bounded Model Checking (BMC) to find security vulnerabilities in C programs. FuSeBMC explores and analyzes C programs (1) to find execution paths that lead to property violations and (2) to incrementally inject labels to guide the fuzzer and the BMC engine to produce test-cases for code coverage. FuSeBMC successfully participates in Test-Comp\u201921 and achieves first place in the Cover-Error category and second place in the Overall category.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Bounded model checking of C++ programs based on the Qt cross-platform framework (journal-first abstract)\n", "abstract": " This work proposes an abstraction of the Qt framework, named as Qt Operational Model (QtOM), which is integrated into two different verification approaches: explicit-state model checking and symbolic (bounded) model checking. The proposed methodology is the first one to formally verify Qt-based applications, which has the potential to devise new directions for software verification of portable code. The full version of this paper is published in Software Testing, Verification and Reliability, on 02 March 2017 and it is available at https://doi. org/10.1002/stvr. 1632.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Map2check using LLVM and KLEE\n", "abstract": " Map2Check is a bug hunting tool that automatically checks safety properties in C programs. It tracks memory pointers and variable assignments to check user-specified assertions, overflow, and pointer safety. Here, we extend Map2Check to: (i) simplify the program using Clang/LLVM; (ii) perform a path-based symbolic execution using the KLEE tool; and (iii) transform and instrument the code using the LLVM dynamic information flow. The SVCOMP\u201918 results show that Map2Check can be effective in generating and checking test cases related to memory management of C programs.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Counterexample-guided k-induction verification for fast bug detection\n", "abstract": " Recently, the k-induction algorithm has proven to be a successful approach for both finding bugs and proving correctness. However, since the algorithm is an incremental approach, it might waste resources trying to prove incorrect programs. In this paper, we propose to extend the k-induction algorithm in order to shorten the number of steps required to find a property violation. We convert the algorithm into a meet-in-the-middle bidirectional search algorithm, using the counterexample produced from over-approximating the program. The preliminary results show that the number of steps required to find a property violation is reduced to  and the verification time for programs with large state space is reduced considerably.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Automated Verification and Synthesis of Embedded Systems using Machine Learning\n", "abstract": " The dependency on the correct functioning of embedded systems is rapidly growing, mainly due to their wide range of applications, such as micro-grids, automotive device control, health care, surveillance, mobile devices, and consumer electronics. Their structures are becoming more and more complex and now require multi-core processors with scalable shared memory, in order to meet increasing computational power demands. As a consequence, reliability of embedded (distributed) software becomes a key issue during system development, which must be carefully addressed and assured. The present research discusses challenges, problems, and recent advances to ensure correctness and timeliness regarding embedded systems. Reliability issues, in the development of micro-grids and cyber-physical systems, are then considered, as a prominent verification and synthesis application. In particular, machine learning techniques emerge as one of the main approaches to learn reliable implementations of embedded software for achieving a correct-by-construction design.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Complementary training programme for electrical and computer engineering students through an industrial-academic collaboration\n", "abstract": " We describe the results of an industrial-academic collaboration among the Graduate Program in Electrical Engineering (PPGEE), the Electronics and Information Research Centre (CETELI), and Samsung Eletr\u00f4nica da Amaz\u00f4nia Ltda. (Samsung), which aims at training human resources for Samsung's research and development (R&D) areas. Inspired by co-operative education systems, this collaboration offers an academic experience by means of a complementary training programme (CTP), in order to train undergraduates and graduate students in electrical and computer engineering, with especial emphasis on digital television (TV), industrial automation, and mobile devices technologies. In particular, this cooperation has provided scholarships for students and financial support for professors and coordinators in addition to the construction of a new building with new laboratories, classrooms, and staff rooms, to\u00a0\u2026", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Model Checking C Programs with Loops via k-induction and Invariants\n", "abstract": " We present a novel proof by induction algorithm, which combines k-induction with invariants to model check C programs with bounded and unbounded loops. The k-induction algorithm consists of three cases: in the base case, we aim to find a counterexample with up to k loop unwindings; in the forward condition, we check whether loops have been fully unrolled and that the safety property P holds in all states reachable within k unwindings; and in the inductive step, we check that whenever P holds for k unwindings, it also holds after the next unwinding of the system. For each step of the k-induction algorithm, we infer invariants using affine constraints (i.e., polyhedral) to specify pre- and post-conditions. The algorithm was implemented in two different ways, with and without invariants using polyhedral, and the results were compared. Experimental results show that both forms can handle a wide variety of safety properties; however, the k-induction algorithm adopting polyhedral solves more verification tasks, which demonstrate an improvement of the induction algorithm effectiveness.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Verifying embedded C software with timing constraints using an untimed bounded model checker\n", "abstract": " Embedded systems are everywhere, from home appliances to critical systems such as medical devices. They usually have associated timing constraints that need to be verified. Here, we use an untimed bounded model checker to verify timing properties of embedded C programs. We describe an approach to specify discrete-time timing constraints using code annotations. The annotated code is then automatically translated to code that manipulates auxiliary timer variables and is thus suitable as input to conventional, untimed software model checkers such as ESBMC. Moreover, we can check timing constraints in the same way and at the same time as untimed system requirements, and even allow for interaction between them. We applied the proposed method in a case study, and verified timing constraints of a pulse oximeter, a noninvasive medical device that measures the oxygen saturation of arterial blood.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Bounded model checking of multi-threaded software using smt solvers\n", "abstract": " The transition from single-core to multi-core processors has made multi-threaded software an important subject in computer aided verification. Here, we describe and evaluate an extension of the ESBMC model checker to support the verification of multi-threaded software with shared variables and locks using bounded model checking (BMC) based on Satisfiability Modulo Theories (SMT). We describe three approaches to model check multi-threaded software and our modelling of the synchronization primitives of the Pthread library. In the lazy approach, we generate all possible interleavings and call the BMC procedure on each of them individually, until we either find a bug, or have systematically explored all interleavings. In the schedule recording approach, we encode all possible interleavings into one single formula and then exploit the high speed of the SMT solvers. In the underapproximation-widening approach, we reduce the state space by abstracting the number of state variables and interleavings from the proofs of unsatisfiability generated by the SMT solvers. In all three approaches, we use partial-order reduction (POR) techniques to reduce the number of interleavings explored. Experiments show that our approaches can analyze larger problems and substantially reduce the verification time compared to state-of-the-art techniques that combine classic POR methods with symbolic algorithms and others that implement the Counter-Example Guided Abstraction Refinement technique.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "Towards a semiformal development methodology for embedded systems\n", "abstract": " In recent days, the amount of functions has increased significantly in embedded products so that systems development methodologies play an important role to ensure the product\u2019s quality, cost, and time. Furthermore, this complexity coupled with constantly evolving specifications, has led to propose a semiformal development methodology to support the building of embedded real-time systems. A platform-based design approach has been used to balance costs and time-to-market in relation to performance and functionality constraints. We performed three expressive case studies and we concluded that the proposed methodology significantly reduces design time and improves software modularity and reliability.", "num_citations": "4\n", "authors": ["1711"]}
{"title": "ezRealtime: a domain-specific modeling tool for embedded hard real-time software synthesis\n", "abstract": " In this paper, we introduce the ezRealtime project, which relies on the Time Petri Net (TPN) formalism and defines a Domain-Specific Modeling (DSM) tool to provide an easy- to-use environment for specifying Embedded Hard Real-Time (EHRT) systems and for synthesizing timely and predictable scheduled C code. Therefore, this paper presents a generative programming method in order to boost code quality and improve substantially developer productivity by making use of automated software synthesis. The ezRealtime tool reads and automatically translates the system's specification to a time Petri net model through composition of building blocks with the purpose of providing a complete model of all tasks in the system. Hence, this model is used to find a feasible schedule by applying a depth-first search algorithm. Finally, the scheduled code is generated by traversing the feasible schedule, and replacing\u00a0\u2026", "num_citations": "4\n", "authors": ["1711"]}
{"title": "FuSeBMC: An Energy-Efficient Test Generator for Finding Security Vulnerabilities in C Programs\n", "abstract": " We describe and evaluate a novel approach to automated test generation that exploits fuzzing and Bounded Model Checking (BMC) engines to detect security vulnerabilities in C programs. We implement this approach in a new tool FuSeBMC that explores and analyzes the target C program by injecting labels that guide the engines to produce test cases. FuSeBMC also exploits a selective fuzzer to produce test cases for the labels that fuzzing and BMC engines could not produce test cases. Lastly, we manage each engine\u2019s execution time to improve FuSeBMC\u2019s energy consumption. We evaluate FuSeBMC by analysing the results of its participation in Test-Comp 2021 whose two main categories evaluate a tool\u2019s ability to provide code coverage and bug detection. The competition results show that FuSeBMC performs well compared to the state-of-the-art software testing tools. FuSeBMC achieved 3 awards in the\u00a0\u2026", "num_citations": "3\n", "authors": ["1711"]}
{"title": "Verification and refutation of C programs based on k-induction and invariant inference\n", "abstract": " DepthK is a source-to-source transformation tool that employs bounded model checking (BMC) to verify and falsify safety properties in single- and multi-threaded C programs, without manual annotation of loop invariants. Here, we describe and evaluate a proof-by-induction algorithm that combines k-induction with invariant inference to prove and refute safety properties. We apply two invariant generators to produce program invariants and feed these into a k-induction-based verification algorithm implemented in DepthK, which uses the efficient SMT-based context-bounded model checker (ESBMC) as sequential verification back-end. A set of C benchmarks from the International Competition on Software Verification (SV-COMP) and embedded-system applications extracted from the available literature are used to evaluate the effectiveness of the proposed approach. Experimental results show that k-induction with\u00a0\u2026", "num_citations": "3\n", "authors": ["1711"]}
{"title": "Optimal sizing of stand-alone solar PV systems via automated formal synthesis\n", "abstract": " There exist various methods and tools to size solar photovoltaic systems; however, these tools rely on simulations, which do not cover all aspects of the design space during the search for optimal solution. In prior studies in optimal sizing, the focus was always on criteria or objectives. Here, we present a new sound and automated approach to obtain optimal sizing using an unprecedented program synthesis. Our variant of counterexample guided inductive synthesis (CEGIS) approach has two phases linking the technical and cost analysis: first we synthesize a feasible candidate based on power reliability, but that may not achieve the lowest cost; second, the candidate is then verified iteratively with a lower bound cost via symbolic model checking. If the verification step does not fail, the lower bound is adjusted; and if it fails, a counterexample provides the optimal solution. Experimental results using seven case studies and commercial equipment data show that our synthesis method can produce within an acceptable run-time the optimal system sizing. We also present a comparative with a specialized simulation tool over real photovoltaic systems to show the effectiveness of our approach, which can provide a more detailed and accurate solution than that simulation tool.", "num_citations": "3\n", "authors": ["1711"]}
{"title": "Finding Security Vulnerabilities in Unmanned Aerial Vehicles Using Software Verification\n", "abstract": " The proliferation of Unmanned Aerial Vehicles (UAVs) embedded with vulnerable monolithic software has recently raised serious concerns about their security due to concurrency aspects and fragile communication links. However, verifying security in UAV software based on traditional testing remains an open challenge mainly due to scalability and deployment issues. Here we investigate software verification techniques to detect security vulnerabilities in typical UAVs. In particular, we investigate existing software analyzers and verifiers, which implement fuzzing and bounded model checking (BMC) techniques, to detect memory safety and concurrency errors. We also investigate fragility aspects related to the UAV communication link. All UAV components (e.g., position, velocity, and attitude control) heavily depend on the communication link. Our preliminary results show that fuzzing and BMC techniques can detect various software vulnerabilities, which are of particular interest to ensure security in UAVs. We were able to perform successful cyber-attacks via penetration testing against the UAV both connection and software system. As a result, we demonstrate real cyber-threats with the possibility of exploiting further security vulnerabilities in real-world UAV software in the foreseeable future.", "num_citations": "3\n", "authors": ["1711"]}
{"title": "A Power Control and Anticolision Mechanism for RFID Systems\n", "abstract": " RFID (Radio Frequency IDentification) applications require identification of large number of tags, which results in increased collisions and degradation in the performance of traditional DFSA (Dynamic Frame slot ALOHA) algorithms. This paper proposes a power control mechanism to estimate the amount of tags in RFID networks. The mechanism is based on the division of the interrogation zone in sub-areas called clusters. This division is used to interrogate in a single slot all tags of a cluster, perform measurements of RSSI and, with it, estimate the amount of tags per cluster. The mechanism is simulated and evaluated using our own simulator developed in C/C ++ programming language. We compared the results of number of slots, identification time and energy consumption with that obtained from the use of the optimal DFSA algorithm and Q algorithm of the EPCglobal standard. From the simulation results, one\u00a0\u2026", "num_citations": "3\n", "authors": ["1711"]}
{"title": "BMCLua: A Translator for Model Checking Lua Programs\n", "abstract": " Lua is a programming language designed as scripting language, which is fast, lightweight, and suitable for embedded applications. Due to its features, Lua is widely used in the development of games and interactive applications for digital TV. However, during the development phase of such applications, some errors may be introduced, such as deadlock, arithmetic overflow, and division by zero. This paper describes a novel verification approach for software written in Lua, using as backend the Efficient SMTBased Context-Bounded Model Checker (ESBMC). Such an approach, called bounded model checking - Lua (BMCLua), consists in translating Lua programs into ANSI-C source code, which is then verified with ESBMC. Experimental results show that the proposed verification methodology is effective and efficient, when verifying safety properties in Lua programs. The performed experiments have shown that\u00a0\u2026", "num_citations": "3\n", "authors": ["1711"]}
{"title": "A car racing based strategy for the dynamic voltage and frequency scaling technique\n", "abstract": " This work proposes the application of a car racing analogy to develop real-time applications with low energy consumption using the Dynamic Voltage and Frequency Scaling technique. Although several previous works had dealt with the DVFS technique, our proposed method offers two main improvements. First, it can be applied to multiple preemptable real-time tasks. Second, in our method, energy consumption optimization may be carried out even when the worst case execution path is followed. The proposed method takes into account the limited set of available frequencies, and consider both the timing and energy overheads for changing the frequency/voltage. Our simulation results indicate clearly the practical usability, efficiency, and the advantages of the proposed method.", "num_citations": "3\n", "authors": ["1711"]}
{"title": "Towards a model-driven engineering approach for developing embedded hard real-time software\n", "abstract": " Model-Driven Engineering (MDE) has been advocated as an effective way to deal with today's software complexity. MDE can be seen as an integrative approach combining existing techniques such as Domain-Specific Modeling Languages (DSML) and Transformation Engines. This paper presents the ezRealtime, an MDE-based tool that relies on the Time Petri Net (TPN) formalism and defines a DSML to provide an easy-to-use environment for specifying Embedded Hard Real-Time (EHRT) system and for synthesizing timely and predictable scheduled C code. The ezRealtime adopts the universal XML-based transfer syntax for Petri nets, named as PNML. The main idea of this work is to propose a generative programming method and tool to boost code quality and improve developer productivity with automated software synthesis. The ezRealtime tool reads and automatically translates the specification to a time\u00a0\u2026", "num_citations": "3\n", "authors": ["1711"]}
{"title": "Aplicando Padr\u00f5es de Ger\u00eancia de Configura\u00e7\u00e3o de Software em Projetos Geograficamente Distribu\u00eddos\n", "abstract": " Ger\u00eancia de Configura\u00e7\u00e3o de Software (SCM) desempenha um papel importante no desenvolvimento de projetos de software, controlando a consist\u00eancia dos artefatos ao longo do ciclo de vida do projeto. Neste artigo \u00e9 discutido como uma linguagem de padr\u00f5es de SCM conhecida foi aplicada em um projeto terceirizado de tamanho m\u00e9dio. Para cada padr\u00e3o aplicado s\u00e3o expostas as motiva\u00e7\u00f5es, contexto, for\u00e7as consideradas bem como as conseq\u00fc\u00eancias positivas e negativas. As id\u00e9ias s\u00e3o apresentadas olhando para o sistema de SCM como um sistema que evolui na medida em que os padr\u00f5es s\u00e3o aplicados. Nuances especiais, comuns ao complexo mundo da terceiriza\u00e7\u00e3o, s\u00e3o tamb\u00e9m enfatizadas.", "num_citations": "3\n", "authors": ["1711"]}
{"title": "Model checking C++ programs\n", "abstract": " In the last three decades, memory safety issues in system programming languages such as C or C++ have been one of the most significant sources of security vulnerabilities. However, there exist only a few attempts with limited success to cope with the complexity of C++ program verification. We describe and evaluate a novel verification approach based on bounded model checking (BMC) and satisfiability modulo theories (SMT) to verify C++ programs. Our verification approach analyses bounded C++ programs by encoding into SMT various sophisticated features that the C++ programming language offers, such as templates, inheritance, polymorphism, exception handling, and the Standard Template Libraries. We formalize these features within our formal verification framework using a decidable fragment of first\u2010order logic and then show how state\u2010of\u2010the\u2010art SMT solvers can efficiently handle that. We\u00a0\u2026", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Verifying Quantized Neural Networks using SMT-Based Model Checking\n", "abstract": " Artificial Neural Networks (ANNs) are being deployed on an increasing number of safety-critical applications, including autonomous cars and medical diagnosis. However, concerns about their reliability have been raised due to their black-box nature and apparent fragility to adversarial attacks. Here, we develop and evaluate a symbolic verification framework using incremental model checking (IMC) and satisfiability modulo theories (SMT) to check for vulnerabilities in ANNs. More specifically, we propose several ANN-related optimizations for IMC, including invariant inference via interval analysis and the discretization of non-linear activation functions. With this, we can provide guarantees on the safe behavior of ANNs implemented both in floating-point and fixed-point (quantized) arithmetic. In this regard, our verification approach was able to verify and produce adversarial examples for 52 test cases spanning image classification and general machine learning applications. For small- to medium-sized ANN, our approach completes most of its verification runs in minutes. Moreover, in contrast to most state-of-the-art methods, our approach is not restricted to specific choices of activation functions or non-quantized representations.", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Synthesis of solar photovoltaic systems: Optimal sizing comparison\n", "abstract": " In the current scenario, energy demand rises by 1.3% each year to 2040, and photovoltaic (PV) systems have emerged as an alternative to the fossil or nuclear fuel energy generation. The use of formal methods for PV systems is a new subject with significant research spanning only five years. Here we develop and evaluate an automated synthesis technique to obtain optimal sizing of PV systems based on Life Cycle Cost (LCC) analysis. The optimal solution is the lowest cost from a list of equipment that meets the electrical demands from a house, plus the replacement, operation, and maintenance costs over 20 years. We propose a variant of the counterexample guided inductive synthesis (CEGIS) approach with two phases linking the technical and cost analysis to obtain the PV sizing optimization. We advocate that our technique has various advantages if compared to off-the-shelf optimization tools\u00a0\u2026", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Formal non-fragile verification of step response requirements for digital state-feedback control systems\n", "abstract": " We describe and evaluate a novel approach to formally verify whether a digital control system meets specifications related to step response parameters. In particular, we obtain a state feedback controller designed for a system represented by a state-space model. Then, we analyze whether its required specifications regarding settling time and maximum overshoot are met, using both open- and closed-loop forms and considering finite-word-length (FWL) effects for the latter. We developed our verification approaches inside DSVerifier, which is a verification tool that employs bounded (and unbounded) model checking based on satisfiability modulo theories. Thus, DSVerifier checks performance requirements of digital control systems considering fragility, such as round-off and numerical quantization errors. Our approaches were also evaluated over a set of standard control-system benchmarks extracted from the\u00a0\u2026", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Dynamic and automated product derivation for consumer electronics software applications\n", "abstract": " Software Product Lines (SPL) is an efficient software engineering approach for dealing with reusable components in products that not only share common features, but also support specific functionalities that satisfy a particular market segment. This approach is interesting for the consumer electronics industry, particularly for mobile device applications. Despite having a significant common core, software applications developed for that domain have to be frequently adapted to different device features, such as operating systems and screen resolution. Thus, developers need to select proper software components to suitably compose the applications for each new device in a family of devices. In this paper, an approach that is able to customize consumer electronics software applications for different devices, in a dynamic and automated way, is presented. It results in a tool called AppSpotter that composes applications\u00a0\u2026", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Verifica\u00e7\u00e3o baseada em indu\u00e7\u00e3o matem\u00e1tica para programas C++\n", "abstract": " A utiliza\u00e7\u00e3o de sistemas embarcados, sistemas computacionais especializados para realizar uma fun\u00e7\u00e3o em sistemas maiores, eletr\u00f4nicos ou mec\u00e2nicos, vem crescendo no dia a dia das pessoas, e vem se tornando cada vez mais importante garantir a robustez desses sistemas. Existem diversas t\u00e9cnicas para garantir que um sistema seja lan\u00e7ado sem erros. Em especial, a verifica\u00e7\u00e3o formal de programas est\u00e1 se mostrando efetiva na busca por falhas. Neste trabalho, ser\u00e3o descritos a verifica\u00e7\u00e3o formal de programas C++ e a prova de corretude por indu\u00e7\u00e3o matem\u00e1tica. Ambas as t\u00e9cnicas ser\u00e3o desenvolvidas utilizando a ferramenta Efficient SMT-Based Context-Bounded Model Checker (ESBMC), um verificador de modelos que se baseia em teorias de satisfabilidade de f\u00f3rmulas proposicionais e de l\u00f3gica de primeira ordem. Os experimentos mostram que a ferramenta pode ser utilizada para verificar uma ampla gama de aplica\u00e7\u00f5es, de casos simples \u00e0 aplica\u00e7\u00f5es comerciais. A ferramenta tamb\u00e9m mostrou-se superior em compara\u00e7\u00e3o com outros verificadores na verifica\u00e7\u00e3o de programas C++, encontrando um maior n\u00famero de erros e suportando um n\u00famero superior das funcionalidades que a linguagem C++ tem a oferecer, al\u00e9m de ser capaz de provar diversas propriedades (por exemplo, la\u00e7os invariantes), utilizando a t\u00e9cnica de indu\u00e7\u00e3o matem\u00e1tica.", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Verifying Embedded C Software with Timing Constraints using an Untimed Model Checker\n", "abstract": " Embedded systems are everywhere, from home appliances to critical systems such as medical devices. They usually have associated timing constraints that need to be verified for the implementation. Here, we use an untimed bounded model checker to verify timing properties of embedded C programs. We propose an approach to specify discrete time timing constraints using code annotations. The annotated code is then automatically translated to code that manipulates auxiliary timer variables and is thus suitable as input to conventional, untimed software model checker such as ESBMC. Thus, we can check timing constraints in the same way and at the same time as untimed system requirements, and even allow for interaction between them. We applied the proposed method in a case study, and verified timing constraints of a pulse oximeter, a noninvasive medical device that measures the oxygen saturation of arterial blood.", "num_citations": "2\n", "authors": ["1711"]}
{"title": "TXM: Uma Metodologia de Desenvolvimento de HW/SWAgil para Sistemas Embacardos\n", "abstract": " Atualmente, a sociedade tem se tornando cada vez mais dependente em sistemas embarcados. Tais sistemas podem ser representados desde simples aparelhos dom\u00e9sticos at\u00e9 aeronaves. Sistemas embarcados diferem bastante da maioria dos sistemas de aplica\u00e7ao Desktop, pois devem ser altamente otimizados para o ciclo de vida, devem atender restri\u00e7oes temporais e de consumo de energia, e devem ainda tratar de limita\u00e7oes de recursos tais como tamanho e peso. Por\u00e9m, sistemas embarcados tamb\u00e9m compartilham algumas caracter\u0131sticas com aplicaca\u00e7oes Desktop tais como complexidade e incerteza. V\u00e1rias metodologias podem ser aplicadas ao desenvolvimento de sistemas embarcados. No entanto, a diversidade extrema das aplica\u00e7oes do mundo embarcado faz com que dificulte a sua generaliza\u00e7ao.Por conseguinte, esta disserta\u00e7ao de mestrado tem como objetivo adaptar uma metodologia de desenvolvimento (nomeada como TXM-The neXt Methodology) atrav\u00e9s do uso de m\u00e9todos \u00e1geis (XP e Scrum) com padroes organizacionais e adapt\u00e1-los para o desenvolvimento de sistemas embarcados de tempo real levando em considera\u00e7ao restri\u00e7oes de consumo de energia, tempo de execu\u00e7ao, tamanho de programa e mem\u00f3ria de dados. O conceito de projeto baseado em plataforma assim como a t\u00e9cnica de particionamento de hardware/software sao usadas na metodologia proposta com o intuito de assegurar que as restri\u00e7oes do sistema sejam atendidas em uma maneira iterativa e incremental e reduzir o custo e tempo de projeto do produto. Estudos de caso envolvendo projetos do ox\u0131metro de pulso, soft-starter digital e\u00a0\u2026", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Verifica\u00e7 ao de Programas C++ Baseados no Framework Multiplataforma Qt\n", "abstract": " The development process for embedded systems is getting faster and faster, which generally incurs an increase in the associated complexity. As a consequence, companies in this area usually invest a lot of resources in fast and automatic verification processes, in order to create robust systems and reduce product recall rates. Because of that, the present paper proposes a simplified version of the Qt framework, which is integrated into the Efficient SMT-Based Bounded Model Checking (ESBMC) tool, in such a way that it is able to verify actual applications that use the mentioned framework. The method proposed in this paper presents a success rate of 91.67% for the developed test suite.Resumo. O processo de desenvolvimento de sistemas embarcados vem ocorrendo de forma cada vez mais acelerada, o que resulta no aumento da sua complexidade. Como consequ\u00eancia, empresas dessa \u00e1rea normalmente investem muitos recursos em verifica\u00e7ao r\u00e1pida e autom\u00e1tica, de modo a gerar sistemas mais robustos e diminuir taxas de retorno de produto. Por essa razao, o presente trabalho propoe um conjunto de bibliotecas simplificadas, similares ao framework Qt, que estao integradas ao verificador de software Efficient SMT-Based Bounded Model Checking (ESBMC), de modo que este seja capaz de analisar aplica\u00e7oes reais que utilizam o framework mencionado. O m\u00e9todo proposto apresenta 91, 67% de acerto para a suite de teste desenvolvida.", "num_citations": "2\n", "authors": ["1711"]}
{"title": "Bounded Model Checking of Software Using Interval Methods via Contractors\n", "abstract": " Bounded model checking (BMC) is a vital technique to find property violations in programs. BMC can quickly find an execution path starting from an initial state to the bad state that refutes a given property. However, BMC techniques struggle to falsify programs that contain loops. BMC needs to unfold the program loops up to the bound k, which sometimes leads to a considerable state-space to be explored. Here, we develop an innovative software verification approach that exploits interval methods via contractors to prune the state-space exploration of programs that contain loops. In particular, this is the first work that exploits interval methods via contractors to analyze the loop variables search-space and identify where the property is guaranteed to hold and prune the domain where it holds. Experimental results show a performance boost in terms of space and time as contractors removed 99% of the search-space in some examples and made them substantially faster to verify with BMC.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Generating Adversarial Inputs Using A Black-box Differential Technique\n", "abstract": " Neural Networks (NNs) are known to be vulnerable to adversarial attacks. A malicious agent initiates these attacks by perturbing an input into another one such that the two inputs are classified differently by the NN. In this paper, we consider a special class of adversarial examples, which can exhibit not only the weakness of NN models - as do for the typical adversarial examples - but also the different behavior between two NN models. We call them difference-inducing adversarial examples or DIAEs. Specifically, we propose DAEGEN, the first black-box differential technique for adversarial input generation. DAEGEN takes as input two NN models of the same classification problem and reports on output an adversarial example. The obtained adversarial example is a DIAE, so that it represents a point-wise difference in the input space between the two NN models. Algorithmically, DAEGEN uses a local search-based optimization algorithm to find DIAEs by iteratively perturbing an input to maximize the difference of two models on predicting the input. We conduct experiments on a spectrum of benchmark datasets (e.g., MNIST, ImageNet, and Driving) and NN models (e.g., LeNet, ResNet, Dave, and VGG). Experimental results are promising. First, we compare DAEGEN with two existing white-box differential techniques (DeepXplore and DLFuzz) and find that under the same setting, DAEGEN is 1) effective, i.e., it is the only technique that succeeds in generating attacks in all cases, 2) precise, i.e., the adversarial attacks are very likely to fool machines and humans, and 3) efficient, i.e, it requires a reasonable number of classification queries. Second, we\u00a0\u2026", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Verifying Software Vulnerabilities in IoT Cryptographic Protocols\n", "abstract": " Internet of Things (IoT) is a system that consists of a large number of smart devices connected through a network. The number of these devices is increasing rapidly, which creates a massive and complex network with a vast amount of data communicated over that network. One way to protect this data in transit, i.e., to achieve data confidentiality, is to use lightweight encryption algorithms for IoT protocols. However, the design and implementation of such protocols is an error-prone task; flaws in the implementation can lead to devastating security vulnerabilities. These vulnerabilities can be exploited by an attacker and affect users' privacy. There exist various techniques to verify software and detect vulnerabilities. Bounded Model Checking (BMC) and Fuzzing are useful techniques to check the correctness of a software system concerning its specifications. Here we describe a framework called Encryption-BMC and Fuzzing (EBF) using combined BMC and fuzzing techniques. We evaluate the application of EBF verification framework on a case study, i.e., the S-MQTT protocol, to check security vulnerabilities in cryptographic protocols for IoT.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Finding Security Vulnerabilities in Network Protocol Implementations\n", "abstract": " Implementations of network protocols are often prone to vulnerabilities caused by developers' mistakes when accessing memory regions and dealing with arithmetic operations. Finding practical approaches for checking the security of network protocol implementations has proven to be a challenging problem. The main reason is that the protocol software state-space is too large to be explored. Here we propose a novel verification approach that combines fuzzing with symbolic execution to verify intricate properties in network protocol implementations. We use fuzzing for an initial exploration of the network protocol, while symbolic execution explores both the program paths and protocol states, which were uncovered by fuzzing. From this combination, we automatically generate high-coverage test input packets for a network protocol implementation. We surveyed various approaches based on fuzzing and symbolic execution to understand how these techniques can be effectively combined and then choose a suitable tool to develop further our model on top of it. In our preliminary evaluation, we used ESBMC, Map2Check, and KLEE as software verifiers and SPIKE as fuzzer to check their suitability to verify our network protocol implementations. Our experimental results show that ESBMC can be further developed within our verification framework called \\textit{FuSeBMC}, to efficiently and effectively detect intricate security vulnerabilities in network protocol implementations.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Boost the Impact of Continuous Formal Verification in Industry\n", "abstract": " Software model checking has experienced significant progress in the last two decades, however, one of its major bottlenecks for practical applications remains its scalability and adaptability. Here, we describe an approach to integrate software model checking techniques into the DevOps culture by exploiting practices such as continuous integration and regression tests. In particular, our proposed approach looks at the modifications to the software system since its last verification, and submits them to a continuous formal verification process, guided by a set of regression test cases. Our vision is to focus on the developer in order to integrate formal verification techniques into the developer workflow by using their main software development methodologies and tools.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Map2Check Using LLVM and KLEE-(Competition Contribution).\n", "abstract": " Map2Check Using LLVM and KLEE (Competition Contribution) Page 1 Map2Check Using LLVM and KLEE (Competition Contribution) Rafael Menezes,Herbert Rocha, Lucas Cordeiro and Raimundo Barreto Page 2 2 SV-COMP 2018 UFRR/UFAM/OXFORD Map2Check \u2713 Map2Check automatically generates and checks assertions from safety properties related to: \u25aa unreachability of an error location \u25aa arithmetic overflow \u25aa invalid deallocation \u25aa invalid pointers \u25aa memory leaks \u2713 Map2Check adopts source code instrumentation to: \u25aa monitor the program\u2019s executions \u25aa validate assertions with safety properties Metadata G ! call(__VERIFIER_error()) G ! overflow Page 3 Old Map2Check New Map2Check 3 SV-COMP 2018 UFRR/UFAM/OXFORD Map2Check ESBMC Map2Check VC generator Verification Clang Frontend Code Transformation Symbolic Execution Page 4 4 SV-COMP 2018 UFRR/UFAM/OXFORD \u2026", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Counterexample guided inductive optimization applied to mobile robots path planning\n", "abstract": " We describe and evaluate a novel optimization-based off-line path planning algorithm for mobile robots based on the Counterexample-Guided Inductive Optimization (CEGIO) technique. CEGIO iteratively employs counterexamples generated from Boolean Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) solvers, in order to guide the optimization process and to ensure global optimization. This paper marks the first application of CEGIO for planning mobile robot path. In particular, CEGIO has been successfully applied to obtain optimal two-dimensional paths for autonomous mobile robots using off-the-shelf SAT and SMT solvers.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Counterexample Guided Inductive Optimization Applied to Mobile Robots Path Planning (Extended Version)\n", "abstract": " We describe and evaluate a novel optimization-based off-line path planning algorithm for mobile robots based on the Counterexample-Guided Inductive Optimization (CEGIO) technique. CEGIO iteratively employs counterexamples generated from Boolean Satisfiability (SAT) and Satisfiability Modulo Theories (SMT) solvers, in order to guide the optimization process and to ensure global optimization. This paper marks the first application of CEGIO for planning mobile robot path. In particular, CEGIO has been successfully applied to obtain optimal two-dimensional paths for autonomous mobile robots using off-the-shelf SAT and SMT solvers.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Using clang as a Frontend on a Formal Verification Tool\n", "abstract": " One of the major challenges in software verification is the development and maintenance of an infrastructure that can handle real-world programs; an issue that intensifies given the ever evolving programming language standards. The C and C++ programming languages are problematic in this sense, with the standards now being updated every 3 years, after a 13 years gap between the C/C++ 98 and C/C++ 11 major releases. The increasing number of features introduces both semantic and syntactic changes, which researchers must support in their tools, reducing the amount of effort that can be spent addressing research questions. We develop ESBMC 1, an SMT-based contextbounded model checker that aims to provide bit-precise verification of both C and C++ programs. Earlier releases of ESBMC used a modified C parser written by James Roskind and a C++ parser based on OpenC++, together spanning\u00a0\u2026", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Application of Global Route-Planning Algorithms with Geodesy\n", "abstract": " Global Route-Planning Algorithms (GRPA) are required to compute paths between several points located on Earth's surface. A geodesic algorithm is employed as an auxiliary tool, increasing the precision of distance calculations. This work presents a novel simulator for GRPA, which compares and evaluates three GRPAs implemented to solve the shortest path problem for points located at different cities: A*, LPA*, and D*Lite. The performance of each algorithm is investigated with a set of experiments, which are executed to check the answers provided by the algorithms and to compare their execution time. It is shown that GRPAs implementations with consistent heuristics lead to optimal paths. The noticeable differences among those algorithms are related to the time execution after successive executions.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Model checking LTL properties over C programs with bounded traces\n", "abstract": " Context-bounded model checking has been used successfully to verify safety properties in multi-threaded systems automatically, even if they are implemented in low-level programming languages such as C. In this paper, we describe and experiment with an approach to extend context-bounded software model checking to safety and liveness properties expressed in linear-time temporal logic (LTL). Our approach checks the actual C program, rather than an extracted abstract model. It converts the LTL formulas into B\u00fcchi automata (BA) for the corresponding never claims and then further into C monitor threads, which are interleaved with the execution of the program under analysis. This combined system is then checked using the ESBMC model checker. We use an extended, four-valued LTL semantics to handle the finite traces that bounded model checking explores; we thus check the combined system several times with different acceptance criteria to derive the correct truth value. In order to mitigate the state space explosion, we use a dedicated scheduler that selects the monitor thread only after updates to global variables occurring in the LTL formula. We demonstrate our approach on the analysis of the sequential firmware of a medical device and a small multi-threaded control application.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Verifica\u00e7ao de Propriedades de Filtros Digitais Implementados com Aritm\u00e9tica de Ponto Fixo\n", "abstract": " Na \u00e1rea de processamento digital de sinais, uma das principais tarefas executadas \u00e9 o projeto de filtros digitais. Atualmente, tal procedimento \u00e9 realizado com a ajuda de ferramentas computacionais, que geralmente sup\u00f5em coeficientes de filtros representados com aritm\u00e9tica em ponto flutuante. Entretanto, durante a fase de implementa\u00e7\u00e3o, que geralmente ocorre em processadores digitais de sinais ou matrizes de portas de campo program\u00e1veis, a representa\u00e7\u00e3o dos coeficientes obtidos pode ser realizada em aritm\u00e9tica de ponto fixo ou inteira, o que muitas vezes resulta em comportamentos inesperados ou at\u00e9 mesmo em filtros inst\u00e1veis. O presente trabalho aborda esse problema e prop\u00f5e uma metodologia de avalia\u00e7\u00e3o baseada em verificadores do tipo efficient SMT-based context-bounded model checker [2],[3], com o objetivo de analisar se a quantidade de bits utilizada, na representa\u00e7\u00e3o dos coeficientes, resultar\u00e1 em um filtro com as mesmas caracter\u00edsticas especificadas na etapa de projeto. Simula\u00e7\u00f5es mostram que erros relativos \u00e0 resposta em frequ\u00eancia e overflow s\u00e3o pass\u00edveis de identifica\u00e7\u00e3o com a metodologia proposta, o que proporciona maior confiabilidade ao projeto.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "A Formal Method for Modeling, Verification and Synthesis of Embedded Reactive Systems\n", "abstract": " Embedded reactive systems are now invisible and everywhere, and are adopted, for instance, to monitor and control critical tasks in cars, airplanes, traffic, and industrial plants. However, the increasing amount of new functionalities being moved to software leads to difficulties in verifying the design correctness. In this context, we propose a novel design method called BARE Model, which is a formal abstraction to design, verify and synthesize software in embedded reactive applications. The method consists in designing the application using an extension of the well-known finite state machine, called X-machine. We thus propose to translate this model to a tabular data structure, which is a kind of state transition table augmented with memory input, memory output, and condition (or guard). This tabular structure may be automatically translated to the input of the NuSMV model checker in order to verify the system\u2019s properties. We also propose a runtime environment to execute the system (expressed as a tabular data structure) in a specific platform. In this way, we can convert the high-level specification into executable code that runs on a target platform. To show the practical usability of our proposed method, we experimented it with the Envirotrack case study. The experiment shows that the proposed method is able to not only model the system, but also to verify safety and liveness properties, and synthesize executable code of real-world applications.", "num_citations": "1\n", "authors": ["1711"]}
{"title": "Malhas de Aterramento do Sistema El\u00e9trico da Concession\u00e1ria Manaus Energia SA: Estudos de Casos\n", "abstract": " O presente trabalho faz uma abordagem generalizada sobre sistemas de aterramento, tomando-se como estudos de casos, um determinado arranjo de malha de aterramento de rede de distribui\u00e7\u00e3o a\u00e9rea de energia el\u00e9trica, da concession\u00e1ria local, analisando-se os valores t\u00edpicos de resistividade do solo, valores de resist\u00eancia de aterramento simulados e os valores reais encontrados, ap\u00f3s a implementa\u00e7\u00e3o da malha. Finaliza-se com observa\u00e7\u00f5es obtidas em campo, dos valores de resist\u00eancia de aterramento do sistema de distribui\u00e7\u00e3o e dos valores verificados nas instala\u00e7\u00f5es do consumidor.", "num_citations": "1\n", "authors": ["1711"]}