{"title": "The influence of app churn on app success and stackoverflow discussions\n", "abstract": " Gauging the success of software systems has been difficult in the past as there was no uniform measure. With mobile Application (App) Stores, users rate each App according to a common rating scheme. In this paper, we study the impact of App churn on the App success through the analysis of 154 free Android Apps that have a total of 1.2k releases. We provide a novel technique to extract Android API elements used by Apps that developers change between releases. We find that high App churn leads to lower user ratings. For example, we find that on average, per release, poorly rated Apps change 140 methods compared to the 82 methods changed by positively rated Apps. Our findings suggest that developers should not release new features at the expense of churn and user ratings. We also investigate the link between how frequently API classes and methods are changed by App developers relative to the\u00a0\u2026", "num_citations": "61\n", "authors": ["242"]}
{"title": "Leveraging informal documentation to summarize classes and methods in context\n", "abstract": " Critical information related to a software developer'scurrent task is trapped in technical developer discussions,bug reports, code reviews, and other software artefacts. Muchof this information pertains to the proper use of code elements(e.g., methods and classes) that capture vital problem domainknowledge. To understand the purpose of these code elements, software developers must either access documentation and online posts and understand the source code or peruse a substantial amount of text. In this paper, we use the context that surrounds code elements in StackOverflow posts to summarize the use and purpose of code elements. To provide focus to our investigation, we consider the generation of summaries for library identifiers discussed in StackOverflow. Our automatic summarization approach was evaluated on a sample of 100 randomly-selected library identifiers with respect to a benchmark of\u00a0\u2026", "num_citations": "35\n", "authors": ["242"]}
{"title": "Normalizing source code vocabulary to support program comprehension and software quality\n", "abstract": " The literature reports that source code lexicon plays a paramount role in program comprehension, especially when software documentation is scarce, outdated or simply not available. In source code, a significant proportion of vocabulary can be either acronyms and-or abbreviations or concatenation of terms that can not be identified using consistent mechanisms such as naming conventions. It is, therefore, essential to disambiguate concepts conveyed by identifiers to support program comprehension and reap the full benefit of Information Retrieval-based techniques (e.g., feature location and traceability) whose linguistic information (i.e., source code identifiers and comments) used across all software artifacts (e.g., requirements, design, change requests, tests, and source code) must be consistent. To this aim, we propose source code vocabulary normalization approaches that exploit contextual information to align\u00a0\u2026", "num_citations": "28\n", "authors": ["242"]}
{"title": "Investigating the Android Apps' Success: An Empirical Study\n", "abstract": " Measuring the success of software systems was not a trivial task in the past. Nowadays, mobile apps provide a uniform schema, i.e., the average ratings provided by the apps' users to gauge their success. While recent research has focused on examining the relationship between change- and fault- proneness and apps' lack of success, as well as qualitatively analyzing the reasons behind the apps' users dissatisfaction, there is little empirical evidence on the factors related to the success of mobile apps. In this paper, we explore the relationships between the mobile apps' success and a set of metrics that not only characterize the apps themselves but also the quality of the APIs used by the apps, as well as user attributes when they interact with the apps. In particular, we measure API quality in terms of bugs fixed in APIs used by apps and changes that occurred in the API methods. We examine different kinds of\u00a0\u2026", "num_citations": "11\n", "authors": ["242"]}
{"title": "Automatic Derivation of Concepts Based on the Analysis of Source Code Identifiers\n", "abstract": " The existing software engineering literature has empirically shown that a proper choice of identifiers influences software understandability and maintainability. Indeed, identifiers are developers' main up-to-date source of information and guide their cognitive processes during program understanding when the high-level documentation is scarce or outdated and when the source code is not sufficiently commented. Deriving domain terms from identifiers using high-level and domain concepts is not an easy task when naming conventions (e.g., Camel Case) are not used or strictly followed and-or when these words have been abbreviated or otherwise transformed. Our thesis is to develop an approach that overcomes the shortcomings of the existing approaches and maps identifiers to domain concepts even in the absence of naming conventions and-or the presence of abbreviations. Our approach uses a thesaurus of\u00a0\u2026", "num_citations": "5\n", "authors": ["242"]}
{"title": "Context-Aware Source Code Identifier Splitting and Expansion for Software Maintenance\n", "abstract": " La compr\u00e9hension du code source des programmes logiciels est une \u00e9tape n\u00e9cessaire pour plusieurs t\u00e2ches de compr\u00e9hension de programmes, retro-ing\u00e9nierie, ou re-documentation. Dans le code source, les informations textuelles telles que les identifiants et les commentaires repr\u00e9sentent une source d\u2019information importante. Le probl\u00e8me d\u2019extraction et d\u2019analyse des informations textuelles utilis\u00e9es dans les artefacts logiciels n\u2019a \u00e9t\u00e9 reconnu par la communaut\u00e9 du g\u00e9nie logiciel que r\u00e9cemment. Des m\u00e9thodes de recherche d\u2019information ont \u00e9t\u00e9 propos\u00e9es pour aider les t\u00e2ches de compr\u00e9hension de programmes telles que la localisation des concepts et la tra\u00e7abilit\u00e9 des exigences au code source. Afin de mieux tirer b\u00e9n\u00e9fice des approches bas\u00e9es sur la recherche d\u2019information, le langage utilis\u00e9 au niveau de tous les artefacts logiciels doit \u00eatre le m\u00eame. Ceci est d\u00fb au fait que les requ\u00eates de la recherche d\u2019information ne peuvent pas retourner des documents pertinents si le vocabulaire utilis\u00e9 dans les requ\u00eates contient des mots qui ne figurent pas au niveau du vocabulaire du code source. Malheureusement, le code source contient une proportion \u00e9lev\u00e9e de mots qui ne sont pas significatifs, eg, abr\u00e9viations, acronymes, ou concat\u00e9nation de ces types. En effet, le code source utilise un langage diff\u00e9rent de celui des autres artefacts logiciels. Cette discordance de vocabulaire provient de l\u2019hypoth\u00e8se implicite faite par les techniques de recherche de l\u2019information et du traitement de langage naturel qui supposent l\u2019utilisation du m\u00eame vocabulaire. Ainsi, la normalisation du vocabulaire du code source est un grand d\u00e9fi. La normalisation aligne\u00a0\u2026", "num_citations": "1\n", "authors": ["242"]}