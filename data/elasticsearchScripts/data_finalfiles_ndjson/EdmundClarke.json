{"title": "Design and synthesis of synchronization skeletons using branching time temporal logic\n", "abstract": " We have shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification. We believe that this approach may in the long run turn out to be quite practical. Since synchronization skeletons are, in general, quite small, the potentially exponential behavior of our algorithm need not be an insurmountable obstacle. Much additional research will be needed, however, to make the approach feasible in practice.             We have also described a model checking algorithm which can be applied to mechanically verify that a finite state concurrent program meets a particular Temporal Logic specification. We believe that practical software tools based on this technique could be developed in the near future. Indeed, we have already programmed an experimental implementation of the model checker on the DEC 11/70 at Harvard.* Certain\u00a0\u2026", "num_citations": "4636\n", "authors": ["1571"]}
{"title": "Using branching time temporal logic to synthesize synchronization skeletons\n", "abstract": " We present a method of constructing concurrent programs in which the synchronization skeleton of the program is automatically synthesized from a (branching time) temporal logic specification. The synthesis method uses a decision procedure based on the finite model property of the logic to determine satisfiability of the specification formula f. If f is satisfiable, then a model for f with a finite number of states is constructed. The synchronization skeleton of a program meeting the specification can be read from this model. If f is unsatisfiable, the specification is inconsistent.", "num_citations": "979\n", "authors": ["1571"]}
{"title": "Characterizing correctness properties of parallel programs using fixpoints\n", "abstract": " We have shown that correctness properties of parallel programs can be described using computation trees and that from these descriptions fixpoint characterizations can be generated. We have also given conditions on the form of computation tree descriptions to ensure that a correctness property can be characterized using continuous fixpoints. A consequence is that a correctness property such as inevitability under fair scheduling can be characterized as the least fixpoint of a monotonic, noncontinuous transformer, but cannot be characterized using fixpoints of continuous transformers (nor as the greatest fixpoint of a monotonic transformer of any degree of complexity lower than fair inevitability itself). Hence, currently known proof rules are not applicable (see however [FS80]). We are now investigating whether useful proof rules can exist for correctness properties having only a monotonic, noncontinuous\u00a0\u2026", "num_citations": "558\n", "authors": ["1571"]}
{"title": "Cognitive computing\n", "abstract": " Unite neuroscience, supercomputing, and nanotechnology to discover, demonstrate, and deliver the brain's core algorithms.", "num_citations": "507\n", "authors": ["1571"]}
{"title": "dReal: An SMT Solver for Nonlinear Theories over the Reals\n", "abstract": " We describe the open-source tool dReal, an SMT solver for nonlinear formulas over the reals. The tool can handle various nonlinear real functions such as polynomials, trigonometric functions, exponential functions, etc. dReal implements the framework of \u03b4-complete decision procedures: It returns either unsat or \u03b4               -sat on input formulas, where \u03b4 is a numerical error bound specified by the user. dReal also produces certificates of correctness for both \u03b4               -sat (a solution) and unsat answers (a proof of unsatisfiability).", "num_citations": "396\n", "authors": ["1571"]}
{"title": "Automatic verification of sequential circuits using temporal logic\n", "abstract": " Verifying the correctness of sequential circuits has been an important problem for a long time. But lack of any formal and efficient method of verification has prevented the creation of practical design aids for this purpose. Since all the known techniques of simulation and prototype testing are time consuming and not very reliable, there is an acute need for such tools. In this paper we describe an automatic verification system for sequential circuits in which specifications are expressed in a propositional temporal logic. In contrast to most other mechanical verification systems, our system does not require any user assistance and is quite fast\u2014experimental results show that state machines with several hundred states can be checked for correctness in a matter of seconds!", "num_citations": "319\n", "authors": ["1571"]}
{"title": "A bayesian approach to model checking biological systems\n", "abstract": " Recently, there has been considerable interest in the use of Model Checking for Systems Biology. Unfortunately, the state space of stochastic biological models is often too large for classical Model Checking techniques. For these models, a statistical approach to Model Checking has been shown to be an effective alternative. Extending our earlier work, we present the first algorithm for performing statistical Model Checking using Bayesian Sequential Hypothesis Testing. We show that our Bayesian approach outperforms current statistical Model Checking techniques, which rely on tests from Classical (aka Frequentist) statistics, by requiring fewer system simulations. Another advantage of our approach is the ability to incorporate prior Biological knowledge about the model being verified. We demonstrate our algorithm on a variety of models from the Systems Biology literature and show that it enables faster\u00a0\u2026", "num_citations": "287\n", "authors": ["1571"]}
{"title": "Computer-aided verification\n", "abstract": " Theorem proving and model checking are powerful tools that can verify the logical correctness of today's ICs or find their hidden bugs. Today, the first computer-aided verification tools are becoming commercially available. They are based on methods that in many cases can reduce the complexity of verification (without sacrificing guaranteed correctness) to such a degree that it becomes computationally feasible. Among the most powerful of these methods are symbolic model-checking and homomorphic reduction, both of which represent a complex system in terms of a compact and computationally more tractable structure. Moreover, the two can be used together with a multiplicative reduction effect, since they work independently of one another. Of special importance is the fact that they each can be implemented automatically, so the task of reduction is programmed into the computer rather than presenting a burden\u00a0\u2026", "num_citations": "287\n", "authors": ["1571"]}
{"title": "Model checking and the state explosion problem\n", "abstract": " Model checking is an automatic verification technique for hardware and software systems that are finite state or have finite state abstractions. It has been used successfully to verify computer hardware, and it is beginning to be used to verify computer software as well. As the number of state variables in the system increases, the size of the system state space grows exponentially. This is called the \u201cstate explosion problem\u201d. Much of the research in model checking over the past 30 years has involved developing techniques for dealing with this problem. In these lecture notes, we will explain how the basic model checking algorithms work and describe some recent approaches to the state explosion problem, with an emphasis on Bounded Model Checking.", "num_citations": "283\n", "authors": ["1571"]}
{"title": "The birth of model checking\n", "abstract": " \u201cWhen the time is ripe for certain things, these things appear in different places in the manner of violets coming to light in early spring.\u201d (Wolfgang Bolyai to his son Johann in urging him to claim the invention of non- Euclidean geometry without delay [Vit88]).", "num_citations": "275\n", "authors": ["1571"]}
{"title": "dReach: \u03b4-Reachability Analysis for Hybrid Systems\n", "abstract": " dReach is a bounded reachability analysis tool for nonlinear hybrid systems. It encodes reachability problems of hybrid systems to first-order formulas over real numbers, which are solved by delta-decision procedures in the SMT solver dReach. In this way, dReach is able to handle a wide range of highly nonlinear hybrid systems. It has scaled well on various realistic models from biomedical and robotics applications.", "num_citations": "269\n", "authors": ["1571"]}
{"title": "Programming language constructs for which it is impossible to obtain good Hoare axiom systems\n", "abstract": " Hoare axiom systems for establishing partial correctness of programs may fail to be complete because of (a) incompleteness of the assertion language relative to the underlying interpretation or (b) inability of the assertion language to express the mvanants of loops Cook has shown that if there IS a complete proof system for the assertion language (le all true formulas of the assertion language) and if the assertion language satisfies a natural expresstbthty condition then a sound and complete axiom system for a large subset of Algol may be devised We exhibit programming language constructs for which it ms impossible to obtain sound and complete sets of Hoare axioms even in this special sense of Cook's These constructs include (0 recursive procedures with procedure parameters in a programming language which uses static scope of ldenufiers and (u) coroutmes in a language which allows parameterless\u00a0\u2026", "num_citations": "250\n", "authors": ["1571"]}
{"title": "Compositional reasoning in model checking\n", "abstract": " The main problem in model checking that prevents it from being used for verification of large systems is the state explosion problem. This problem often arises from combining parallel processes together. Many techniques have been proposed to overcome this difficulty and, thus, increase the size of the systems that model checkers can handle. We describe several compositional model checking techniques used in practice and show a few examples demonstrating their performance.", "num_citations": "220\n", "authors": ["1571"]}
{"title": "Solving QBF with counterexample guided refinement\n", "abstract": " We propose two novel approaches for using Counterexample-Guided Abstraction Refinement (CEGAR) in Quantified Boolean Formula (QBF) solvers. The first approach develops a recursive algorithm whose search is driven by CEGAR (rather than by DPLL). The second approach employs CEGAR as an additional learning technique in an existing DPLL-based QBF solver. Experimental evaluation of the implemented prototypes shows that the CEGAR-driven solver outperforms existing solvers on a number of families in the QBF-LIB and that the DPLL solver benefits from the additional type of learning. Thus this article opens two promising avenues in QBF: CEGAR-driven solvers as an alternative to existing approaches and a novel type of learning in DPLL.", "num_citations": "192\n", "authors": ["1571"]}
{"title": "Statistical model checking for cyber-physical systems\n", "abstract": " Statistical Model Checking is useful in situations where it is either inconvenient or impossible to build a concise representation of the global transition relation. This happens frequently with cyber-physical systems: Two examples are verifying Stateflow-Simulink models and in reasoning about biochemical reactions in Systems Biology. The main problem with Statistical Model Checking is caused by rare events. We describe how Statistical Model Checking works and demonstrate the problem with rare events. We then describe how Importance Sampling with the Cross-Entropy Technique can be used to address this problem.", "num_citations": "187\n", "authors": ["1571"]}
{"title": "Automated abstraction refinement for model checking large state spaces using SAT based conflict analysis\n", "abstract": " We introduce a SAT based automatic abstraction refinement framework for model checking systems with several thousand state variables in the cone of influence of the specification. The abstract model is constructed by designating a large number of state variables as invisible. In contrast to previous work where invisible variables were treated as free inputs we describe a computationally more advantageous approach in which the abstract transition relation is approximated by pre-quantifying invisible variables during image computation. The abstract counterexamples obtained from model-checking the abstract model are symbolically simulated on the concrete system using a state-of-the-art SAT checker. If no concrete counterexample is found, a subset of the invisible variables is reintroduced into the system and the process is repeated. The main contribution of this paper are two new algorithms for\u00a0\u2026", "num_citations": "187\n", "authors": ["1571"]}
{"title": "Symbolic model checking\n", "abstract": " Symbolic model checking is a powerful formal specification and verification method that has been applied successfully in several industrial designs. Using symbolic model checking techniques it is possible to verify industrial-size finite state systems. State spaces with up to 1030 states can be exhaustively searched in minutes. Models with more than 10120 states have been verified using special techniques.             Several extensions to the original technique have been developed, making it even more powerful. Timing properties can be verified by performing a quantitative timing analysis [3, 5]. The designer can then analyze the performance of a system and gain insight in how well a system works early in the design process. Word-level model checking allows the verification of datapaths in addition to control [12]. Symmetry [8], abstraction [10, 15] and compositional reasoning [15] techniques significantly\u00a0\u2026", "num_citations": "179\n", "authors": ["1571"]}
{"title": "Hybrid decision diagrams. Overcoming the limitations of MTBDDs and BMDs\n", "abstract": " Functions that map boolean vectors into the integers are important for the design and verification of arithmetic circuits. MTBDDs and BMDs have been proposed for representing this class of functions. We discuss the relationship between these methods and describe a generalization called hybrid decision diagrams which is often much more concise. We show how to implement arithmetic operations efficiently for hybrid decision diagrams. In practice, this is one of the main limitations of BMDs since performing arithmetic operations on functions expressed in this notation can be very expensive. In order to extend symbolic model checking algorithms to handle arithmetic properties, it is essential to be able to compute the BDD for the set of variable assignments that satisfy an arithmetic relation. In our paper, we give an efficient algorithm for this purpose. Moreover, we prove that for the class of linear expressions, the time\u00a0\u2026", "num_citations": "175\n", "authors": ["1571"]}
{"title": "\u03b4-complete decision procedures for satisfiability over the reals\n", "abstract": " We introduce the notion of \u201c\u03b4-complete decision procedures\u201d for solving SMT problems over the real numbers, with the aim of handling a wide range of nonlinear functions including transcendental functions and solutions of Lipschitz-continuous ODEs. Given an SMT problem \u03d5 and a positive rational number \u03b4, a \u03b4-complete decision procedure determines either that \u03d5 is unsatisfiable, or that the \u201c\u03b4-weakening\u201d of \u03d5 is satisfiable. Here, the \u03b4-weakening of \u03d5 is a variant of \u03d5 that allows \u03b4-bounded numerical perturbations on \u03d5. We establish the existence and complexity of \u03b4-complete decision procedures for bounded SMT over reals with functions mentioned above. We propose to use \u03b4-completeness as an ideal requirement for numerically-driven decision procedures. As a concrete example, we formally analyze the DPLL framework, which integrates Interval Constraint Propagation in DPLL(T), and establish\u00a0\u2026", "num_citations": "168\n", "authors": ["1571"]}
{"title": "Expressibility results for linear-time and branching-time logics\n", "abstract": " We investigate the expressive power of linear-time and branching-time temporal logics as fragments of the logic CTL*. We give a simple characterization of those CTL* formulas that can be expressed in linear-time logic. We also give a simple method for showing that certain CTL* formulas cannot be expressed in the branching-time logic CTL. Both results are illustrated with examples.", "num_citations": "161\n", "authors": ["1571"]}
{"title": "Fast maintenance of semantic integrity assertions using redundant aggregate data\n", "abstract": " Semantic integrity assertions are predicates that define consistent database states. To enforce such assertions, a database system must prevent any update from mapping a consistent state to an inconsistent one. In this paper, we describe an enforcement method that is efficient for a large class of relational calculus assertions. The method automatically selects minima and maxima of certain sets to maintain as redundant data in the database. This redundant data is sufficient for enforcing all of the assertions in the class, yet it can be easily maintained. Correctness proofs are expressed in Hoare's program logic.", "num_citations": "154\n", "authors": ["1571"]}
{"title": "Bayesian statistical model checking with application to simulink/stateflow verification\n", "abstract": " We address the problem of model checking stochastic systems, ie~ checking whether a stochastic system satisfies a certain temporal property with a probability greater (or smaller) than a fixed threshold. In particular, we present a novel Statistical Model Checking (SMC) approach based on Bayesian statistics. We show that our approach is feasible for hybrid systems with stochastic transitions, a generalization of Simulink/Stateflow models. Standard approaches to stochastic (discrete) systems require numerical solutions for large optimization problems and quickly become infeasible with larger state spaces. Generalizations of these techniques to hybrid systems with stochastic effects are even more challenging. The SMC approach was pioneered by Younes and Simmons in the discrete and non-Bayesian case. It solves the verification problem by combining randomized sampling of system traces (which is very\u00a0\u2026", "num_citations": "152\n", "authors": ["1571"]}
{"title": "Automatic verification of asynchronous circuits using temporal logic\n", "abstract": " A method is presented for automatically verifying asynchronous sequential circuits using temporal logic specifications. The method takes a circuit desctibed in terms of Boolean gates and Muller elements, and derves a state graph that summaries all possible circuit executions resulting from any set of finite delays on the outputs of the components. The correct behaviour of the circuit is expressed in CTL, a temporal logic. This specification is checked against the state graph using a model checker program. Using this method, a timing error in a published arbiter design is discovered. A corrected arbiter is given and verified", "num_citations": "151\n", "authors": ["1571"]}
{"title": "Bayesian statistical model checking with application to Stateflow/Simulink verification\n", "abstract": " We address the problem of model checking stochastic systems, i.e., checking whether a stochastic system satisfies a certain temporal property with a probability greater (or smaller) than a fixed threshold. In particular, we present a Statistical Model Checking (SMC) approach based on Bayesian statistics. We show that our approach is feasible for a certain class of hybrid systems with stochastic transitions, a generalization of Simulink/Stateflow models. Standard approaches to stochastic discrete systems require numerical solutions for large optimization problems and quickly become infeasible with larger state spaces. Generalizations of these techniques to hybrid systems with stochastic effects are even more challenging. The SMC approach was pioneered by Younes and Simmons in the discrete and non-Bayesian case. It solves the verification problem by combining randomized sampling of system traces\u00a0\u2026", "num_citations": "147\n", "authors": ["1571"]}
{"title": "Formal verification of curved flight collision avoidance maneuvers: A case study\n", "abstract": " Aircraft collision avoidance maneuvers are important and complex applications. Curved flight exhibits nontrivial continuous behavior. In combination with the control choices during air traffic maneuvers, this yields hybrid systems with challenging interactions of discrete and continuous dynamics. As a case study illustrating the use of a new proof assistant for a logic for nonlinear hybrid systems, we analyze collision freedom of roundabout maneuvers in air traffic control, where appropriate curved flight, good timing, and compatible maneuvering are crucial for guaranteeing safe spatial separation of aircraft throughout their flight. We show that formal verification of hybrid systems can scale to curved flight maneuvers required in aircraft control applications. We introduce a fully flyable variant of the roundabout collision avoidance maneuver and verify safety properties by compositional verification.", "num_citations": "137\n", "authors": ["1571"]}
{"title": "Computing differential invariants of hybrid systems as fixedpoints\n", "abstract": " We introduce a fixedpoint algorithm for verifying safety properties of hybrid systems with differential equations whose right-hand sides are polynomials in the state variables. In order to verify nontrivial systems without solving their differential equations and without numerical errors, we use a continuous generalization of induction, for which our algorithm computes the required differential invariants. As a means for combining local differential invariants into global system invariants in a sound way, our fixedpoint algorithm works with a compositional verification logic for hybrid systems. To improve the verification power, we further introduce a saturation procedure that refines the system dynamics successively with differential invariants until safety becomes provable. By complementing our symbolic verification algorithm with a robust version of numerical falsification, we obtain a fast and sound verification\u00a0\u2026", "num_citations": "137\n", "authors": ["1571"]}
{"title": "Statistical model checking in biolab: Applications to the automated analysis of t-cell receptor signaling pathway\n", "abstract": " We present an algorithm, called BioLab, for verifying temporal properties of rule-based models of cellular signalling networks. BioLab models are encoded in the BioNetGen language, and properties are expressed as formulae in probabilistic bounded linear temporal logic. Temporal logic is a formalism for representing and reasoning about propositions qualified in terms of time. Properties are then verified using sequential hypothesis testing on executions generated using stochastic simulation. BioLab is optimal, in the sense that it generates the minimum number of executions necessary to verify the given property. BioLab also provides guarantees on the probability of it generating Type-I (ie, false-positive) and Type-II (ie, false-negative) errors. Moreover, these error bounds are pre-specified by the user. We demonstrate BioLab by verifying stochastic effects and bistability in the dynamics of the T-cell receptor\u00a0\u2026", "num_citations": "134\n", "authors": ["1571"]}
{"title": "Environment abstraction for parameterized verification\n", "abstract": " Many aspects of computer systems are naturally modeled as parameterized systems which renders their automatic verification difficult. In well-known examples such as cache coherence protocols and mutual exclusion protocols, the unbounded parameter is the number of concurrent processes which run the same distributed algorithm. In this paper, we introduce environment abstraction as a tool for the verification of such concurrent parameterized systems. Environment abstraction enriches predicate abstraction by ideas from counter abstraction; it enables us to reduce concurrent parameterized systems with unbounded variables to precise abstract finite state transition systems which can be verified by a finite state model checker. We demonstrate the feasibility of our approach by verifying the safety and liveness properties of Lamport\u2019s bakery algorithm and Szymanski\u2019s mutual exclusion algorithm. To the\u00a0\u2026", "num_citations": "134\n", "authors": ["1571"]}
{"title": "Analytica\u2014A theorem prover in Mathematica\n", "abstract": " Current automatic theorem provers, particularly those based on some variant of resolution, have concentrated on obtaining ever higher inference rates by using clever programming techniques, parallelism, etc. We believe that this approach is unlikely to lead to a useful system for actually doing mathematics. The main problem is the large amount of domain knowledge that is required for even the simplest proofs. In this paper, we describe an alternative approach that involves combining an automatic theorem prover with a symbolic computation system. The theorem prover, which we call Analytica, is able to exploit the mathematical knowledge that is built into this symbolic computation system. In addition, it can guarantee the correctness of certain steps that are made by the symbolic computation system and, therefore, prevent common errors like division by an expression that may be zero.Analytica is written in the\u00a0\u2026", "num_citations": "133\n", "authors": ["1571"]}
{"title": "Statistical model checking for Markov decision processes\n", "abstract": " Statistical Model Checking (SMC) is a computationally very efficient verification technique based on selective system sampling. One well identified shortcoming of SMC is that, unlike probabilistic model checking, it cannot be applied to systems featuring nondeterminism, such as Markov Decision Processes (MDP). We address this limitation by developing an algorithm that resolves nondeterminism probabilistically, and then uses multiple rounds of sampling and Reinforcement Learning to provably improve resolutions of nondeterminism with respect to satisfying a Bounded Linear Temporal Logic (BLTL) property. Our algorithm thus reduces an MDP to a fully probabilistic Markov chain on which SMC may be applied to give an approximate solution to the problem of checking the probabilistic BLTL property. We integrate our algorithm in a parallelised modification of the PRISM simulation framework. Extensive\u00a0\u2026", "num_citations": "132\n", "authors": ["1571"]}
{"title": "Modular translation of Statecharts to SMV\n", "abstract": " Statechart languages enjoy an increasing popularity with designers of safety-critical systems. Among the reasons for that is an intuitive graphical representation of the system under development as well as built-in simulation capabilities. Besides intuititive observation, an integrated methodology for the development of safety critical systems sometimes also requires a more formal approach to the correctness of a statechart-design. One successful method to formally prove that a given system meets its speci cation is model checking. To model-check a system, its description has to be translated into the input-language of the model checker, in case of smv 9] this is a simple and comfortable fragment of temporal logic. The speci cation is given through a CTL-formula.In this paper we illustrate the STP-approach at translating Statemate1 statecharts into smv. STP is an automatic translator for Statemate statecharts into the smv input language, we developed for General Motors in 1998. The translation presented here does not attempt to handle the maximal fragment of the Statemate language that can be model-checked. In contrast to other approaches (eg 3]), we rather focus on a representative fragment including the hierarchical structure present in statecharts. The main objective is to re ect the hierarchical structuring of statecharts as close as possible in smv. By doing so, we can obtain a fully abstract or modular translation of Statemate designs into smv: Only the information pertinent to the subchart under consideration is needed in order to perform the translation.", "num_citations": "121\n", "authors": ["1571"]}
{"title": "A language for compositional specification and verification of finite state hardware controllers\n", "abstract": " The authors consider the state machine language (SML) for describing complex finite state hardware controllers. It provides many of the standard control structures found in modern programming languages. The state tables produced by the SML compiler can be used as input to a temporal logic model checker that can automatically determine whether a specification in the logic CTL is satisfied. The authors describe extensions to SML for the design of modular controllers. These extensions allow a compositional approach to model checking which can substantially reduce its complexity. To demonstrate these methods, the authors discuss the specification and verification of a simple central-processing-unit (CPU) controller.< >", "num_citations": "115\n", "authors": ["1571"]}
{"title": "Computing quantitative characteristics of finite-state real-time systems\n", "abstract": " Presents a general method for computing quantitative information about finite-state real-time systems. We have developed algorithms that compute exact bounds on the delay between two specified events and on the number of occurrences of an event in a given interval. This technique allows us to determine performance measures such as schedulability, response time, and system load. Our algorithms produce more detailed information than traditional methods. This information leads to a better understanding of system behavior, in addition to determining its correctness. The algorithms presented in this paper are efficiently implemented using binary decision diagrams and have been incorporated into the SMV symbolic model verifier. Using this method, we have verified a model of an aircraft control system with 10/sup 15/ states. The results obtained demonstrate that our method can be successfully applied in the\u00a0\u2026", "num_citations": "114\n", "authors": ["1571"]}
{"title": "Real-time symbolic model checking for discrete time models\n", "abstract": " The BDD-based symbolic model checking algorithm given in 4.10 is extended to handle real-time properties using the bounded until operator 9. We believe that this algorithm which is based on discrete time is able to handle many real-time properties that arise in practical problems. One example of such a property is priority increasing. This is a serious problem that can make real-time systems unpredictable in subtle ways. Our work discusses this problem and presents one possible solution. The solution is formalized and verified using the modified algorithm. We also propose another extension to the model checking algorithm. Timed transition graphs are transition graphs in which events may take non-unit time to occur. The time it takes for a transition in a TTG to happen is determined by a time interval. This allows the construction of smaller and more realistic models. A symbolic model checking algorithm is given for formulas using the bounded until operator in TTG models.Descriptors:", "num_citations": "109\n", "authors": ["1571"]}
{"title": "Satisfiability modulo odes\n", "abstract": " We study SMT problems over the reals containing ordinary differential equations,. They are important for formal verification of realistic hybrid systems and embedded software. We develop \u03b4-complete algorithms for SMT formulas that are purely existentially quantified, as well as \u2203\u2200-formulas whose universal quantification is restricted to the time variables. We demonstrate scalability of the algorithms, as implemented in our open-source solver dReal, on SMT benchmarks with several hundred nonlinear ODEs and variables.", "num_citations": "103\n", "authors": ["1571"]}
{"title": "Solving QBF with counterexample guided refinement\n", "abstract": " This article puts forward the application of Counterexample Guided Abstraction Refinement (CEGAR) in solving the well-known PSPACE-complete problem of quantified Boolean formulas (QBF). The article studies the application of CEGAR in two scenarios. In the first scenario, CEGAR is used to expand quantifiers of the formula and subsequently a satisfiability (SAT) solver is applied. First it is shown how to do that for two levels of quantification and then it is generalized for arbitrary number of levels by recursion. It is also shown that these ideas can be generalized to non-prenex and non-CNF QBF solvers. In the second scenario, CEGAR is employed as an additional learning technique in an existing DPLL-based QBF solver. Experimental evaluation of the implemented prototypes shows that the CEGAR-driven solver outperforms existing solvers on a number of benchmark families and that the DPLL solver benefits\u00a0\u2026", "num_citations": "102\n", "authors": ["1571"]}
{"title": "Automated assume-guarantee reasoning for simulation conformance\n", "abstract": " We address the issue of efficiently automating assume-guarantee reasoning for simulation conformance between finite state systems and specifications. We focus on a non-circular assume-guarantee proof rule, and show that there is a weakest assumption that can be represented canonically by a deterministic tree automata (DTA). We then present an algorithm L                                            T                  that learns this DTA automatically in an incremental fashion, in time that is polynomial in the number of states in the equivalent minimal DTA. The algorithm assumes a teacher that can answer membership and candidate queries pertaining to the language of the unknown DTA. We show how the teacher can be implemented using a model checker. We have implemented this framework in the COMFORT toolkit and we report encouraging results (over an order of magnitude improvement in memory consumption) on\u00a0\u2026", "num_citations": "96\n", "authors": ["1571"]}
{"title": "Computing differential invariants of hybrid systems as fixedpoints\n", "abstract": " We introduce a fixedpoint algorithm for verifying safety properties of hybrid systems with differential equations whose right-hand sides are polynomials in the state variables. In order to verify nontrivial systems without solving their differential equations and without numerical errors, we use a continuous generalization of induction, for which our algorithm computes the required differential invariants. As a means for combining local differential invariants into global system invariants in a sound way, our fixedpoint algorithm works with a compositional verification logic for hybrid systems. With this compositional approach we exploit locality in system designs. To improve the verification power, we further introduce a saturation procedure that refines the system dynamics successively with differential invariants until safety becomes provable. By complementing our symbolic verification algorithm with a robust version of\u00a0\u2026", "num_citations": "95\n", "authors": ["1571"]}
{"title": "A parallel algorithm for constructing binary decision diagrams\n", "abstract": " A parallel algorithm for constructing binary decision diagrams is described. The algorithms treats binary decision graphs as minimal finite automata. The automation for a Boolean function with AND as its main operation (OR operation) is obtained by forming the intersection (union) of the regular sets associated with its operands. The union and intersection operations are implemented by a product construction on the minimal automata for the regular sets. After each product construction step the automaton must be reminimized. The parallel algorithm is designed so that it is possible to find the minimal representations for several Boolean operations in parallel. The level of each operation is determined. Operations at the same level can be performed in parallel without any communication between processors. If there are relatively few operations in one level, then the product generation step is divided into several\u00a0\u2026", "num_citations": "95\n", "authors": ["1571"]}
{"title": "A non-prenex, non-clausal QBF solver with game-state learning\n", "abstract": " We describe a DPLL-based solver for the problem of quantified boolean formulas (QBF) in non-prenex, non-CNF form. We make two contributions. First, we reformulate clause/cube learning, extending it to non-prenex instances. We call the resulting technique game-state learning. Second, we introduce a propagation technique using ghost literals that exploits the structure of a non-CNF instance in a manner that is symmetric between the universal and existential variables. Experimental results on the QBFLIB benchmarks indicate our approach outperforms other state-of-the-art solvers on certain benchmark families, including the tipfixpoint and tipdiam families of model checking problems.", "num_citations": "90\n", "authors": ["1571"]}
{"title": "The image computation problem in hybrid systems model checking\n", "abstract": " In this paper, we analyze limits of approximation techniques for (non-linear) continuous image computation in model checking hybrid systems. In particular, we show that even a single step of continuous image computation is not semidecidable numerically even for a very restricted class of functions. Moreover, we show that symbolic insight about derivative bounds provides sufficient additional information for approximation refinement model checking. Finally, we prove that purely numerical algorithms can perform continuous image computation with arbitrarily high probability. Using these results, we analyze the prerequisites for a safe operation of the roundabout maneuver in air traffic collision avoidance.", "num_citations": "85\n", "authors": ["1571"]}
{"title": "Verus: a tool for quantitative analysis of finite-state real-time systems\n", "abstract": " Symbolic model checking is a technique for verifying finite-state concurrent systems. Models with up to 10 30 states can often be verified in minutes. In this paper, we present a new tool to analyze real-time systems, based on this technique. We have designed a language, called Verus, for the description of real-time systems. Such a description is compiled into a state-transition graph and represented symbolically using binary decision diagrams. We have developed new algorithms for exploring the state space and computing quantitative information about the system. In addition to determining the exact bounds on the length of the time interval between two specified events, we compute the number of occurrences of an event in such an interval. This technique allows us to determine performance measures such as schedulability, response time, and system load. Our algorithms produce more detailed information than\u00a0\u2026", "num_citations": "85\n", "authors": ["1571"]}
{"title": "A unified approach for showing language containment and equivalence between various types of \u03c9-automata\n", "abstract": " We consider the language containment and equivalence problems for six different types of \u03c9-automata: B\u00fcchi, Muller, Rabin, Streett, the L-automata of Kurshan, and the \u2200-automata of Manna and Pnueli. We give a six by six matrix in which each row and column is associated with one of these types of automata. The entry in the i                  th                row and j                  th                column is the complexity of showing containment between the i                  th                type of automaton and the j                  th               . Thus, for example, we give the complexity of showing language containment and equivalence between a B\u00fcchi automaton and a Muller or Streett automaton. Our results are obtained by a uniform method that associates a formula of the logic CTL* with each type of automaton. Our algorithms use a model checking procedure for the logic with the formulas obtained from the automata. The results of our\u00a0\u2026", "num_citations": "84\n", "authors": ["1571"]}
{"title": "Delta-decidability over the reals\n", "abstract": " Given any collection F of computable functions over the reals, we show that there exists an algorithm that, given any sentence A containing only bounded quantifiers and functions in F, and any positive rational number delta, decides either \u201cA is true\u201d, or \u201ca delta-strengthening of A is false\u201d. Moreover, if F can be computed in complexity class C, then under mild assumptions, this \u201cdelta-decision problem\u201d for bounded Sigma k-sentences resides in Sigma k(C). The results stand in sharp contrast to the well-known undecidability of the general first-order theories with these functions, and serve as a theoretical basis for the use of numerical methods in decision procedures for formulas over the reals.", "num_citations": "83\n", "authors": ["1571"]}
{"title": "Counterexamples revisited: Principles, algorithms, applications\n", "abstract": " Algorithmic counterexample generation is a central feature of model checking which sets the method apart from other approaches such as theorem proving. The practical value of counterexamples to the verification engineer is evident, and for many years, counterexample generation algorithms have been employed in model checking systems, even though they had not been subject to an adequate fundamental investigation. Recent advances in model checking technology such as counterexample-guided abstraction refinement have put strong emphasis on counterexamples, and have lead to renewed interest both in fundamental and pragmatic aspects of counterexample generation. In this paper, we survey several key contributions to the subject including symbolic algorithms, results about the graph-theoretic structure of counterexamples, and applications to automated abstraction as well as software\u00a0\u2026", "num_citations": "83\n", "authors": ["1571"]}
{"title": "Efficient verification of parallel real-time systems\n", "abstract": " This paper presents an efficient model checking algorithm for one-safe time Petri nets and a timed temporal logic. The approach is based on the idea of (1) using only differences of timing variables to be able to construct a finite representation of the set of all reachable states and (2) further reducing the size of this representation by exploiting the concurrency in the net, i.e. only one of several equivalent interleavings being generated for the evaluation of the given formula. This reduction of the state space is possible, because the considered linear-time temporal logic is stuttering invariant. In this paper the concrete model checking algorithm is developed and some experimental results which demonstrate the efficiency of the method are given.", "num_citations": "83\n", "authors": ["1571"]}
{"title": "Analysis and verification of the HMGB1 signaling pathway\n", "abstract": " Recent studies have found that overexpression of the High-mobility group box-1 (HMGB1) protein, in conjunction with its receptors for advanced glycation end products (RAGEs) and toll-like receptors (TLRs), is associated with proliferation of various cancer types, including that of the breast and pancreatic. We have developed a rule-based model of crosstalk between the HMGB1 signaling pathway and other key cancer signaling pathways. The model has been simulated using both ordinary differential equations (ODEs) and discrete stochastic simulation. We have applied an automated verification technique, Statistical Model Checking, to validate interesting temporal properties of our model. Our simulations show that, if HMGB1 is overexpressed, then the oncoproteins CyclinD/E, which regulate cell proliferation, are overexpressed, while tumor suppressor proteins that regulate cell apoptosis (programmed cell death), such as p53, are repressed. Discrete, stochastic simulations show that p53 and MDM2 oscillations continue even after 10 hours, as observed by experiments. This property is not exhibited by the deterministic ODE simulation, for the chosen parameters. Moreover, the models also predict that mutations of RAS, ARF and P21 in the context of HMGB1 signaling can influence the cancer cell's fate - apoptosis or survival - through the crosstalk of different pathways.", "num_citations": "82\n", "authors": ["1571"]}
{"title": "Inferring invariants in separation logic for imperative list-processing programs\n", "abstract": " An algorithm is presented for automatically inferring loop invariants in separation logic for imperative list-processing programs. A prototype implementation for a C-like language is shown to be successful in generating loop invariants for a variety of sample programs. The programs, while relatively small, iteratively perform destructive heap operations and hence pose problems more than challenging enough to demonstrate the utility of the approach. The invariants express information not only about the shape of the heap but also conventional properties of the program data. This combination makes it possible, in principle, to solve a wider range of verification problems and makes it easier to incorporate separation logic reasoning into static analysis systems, such as software model checkers. It also can provide a component of a separation-logicbased code certification system a la proof-carrying code.", "num_citations": "80\n", "authors": ["1571"]}
{"title": "Hierarchical verification of asynchronous circuits using temporal logic\n", "abstract": " Establishing the correctness of complicated asynchronous circuit is in general quite difficult because of the high degree of nondeterminism that is inherent in such devices. Nevertheless, it is also very important in view of the cost involved in design and testing of circuits. We show how to give specifications for circuits in a branching time temporal logic and how to mechanically verify them using a simple and efficient model checker. We also show how to tackle a large and complex circuit by verifying it hierarchically.", "num_citations": "77\n", "authors": ["1571"]}
{"title": "Learning minimal separating DFA\u2019s for compositional verification\n", "abstract": " Algorithms for learning a minimal separating DFA of two disjoint regular languages have been proposed and adapted for different applications. One of the most important applications is learning minimal contextual assumptions in automated compositional verification. We propose in this paper an efficient learning algorithm, called, that learns and generates a minimal separating DFA. Our algorithm has a quadratic query complexity in the product of sizes of the minimal DFA\u2019s for the two input languages. In contrast, the most recent algorithm of Gupta et al. has an exponential query complexity in the sizes of the two DFA\u2019s. Moreover, experimental results show that our learning algorithm significantly outperforms all existing algorithms on randomly-generated example problems. We describe how our algorithm can be adapted for automated compositional verification. The adapted version is evaluated on the LTSA\u00a0\u2026", "num_citations": "74\n", "authors": ["1571"]}
{"title": "Verifying the performance of the PCI local bus using symbolic techniques\n", "abstract": " Symbolic model checking is a successful technique for checking properties of large finite-state systems. This method has been used to verify a number of real-world hardware designs; however it is not able to determine timing or performance properties directly. Since these properties are extremely important in the design of high-performance systems and in time-critical applications, we have extended model checking techniques to produce timing information. Our results allow a more detailed analysis of a model than is possible with tools that simply determine whether a property is satisfied or not. We present algorithms that determine the exact bounds on the time interval between two specified events and the number of occurrences of another event in such an interval. To demonstrate how our method works, we have modelled the PCI local bus and analyzed its temporal behavior. The results demonstrate the\u00a0\u2026", "num_citations": "73\n", "authors": ["1571"]}
{"title": "Proving ptolemy right: The environment abstraction framework for model checking concurrent systems\n", "abstract": " The parameterized verification of concurrent algorithms and protocols has been addressed by a variety of recent methods. Experience shows that there is a trade-off between techniques which are widely applicable but depend on non-trivial human guidance, and fully automated approaches which are tailored for narrow classes of applications. In this spectrum, we propose a new framework based on environment abstraction which exhibits a large degree of automation and can be easily adjusted to different fields of application. Our approach is based on two insights: First, we argue that natural abstractions for concurrent software are derived from the \u201cPtolemaic\u201d perspective of a human engineer who focuses on a single reference process. For this class of abstractions, we demonstrate soundness of abstraction under very general assumptions. Second, most protocols in given a class of protocols \u2013 for instance\u00a0\u2026", "num_citations": "71\n", "authors": ["1571"]}
{"title": "Analytica\u2013an experiment in combining theorem proving and symbolic computation\n", "abstract": " Analytica is an automatic theorem prover for theorems in elementary analysis. The prover is written in the Mathematica language and runs in the Mathematica environment. The goal of the project is to use a powerful symbolic computation system to prove theorems that are beyond the scope of previous automatic theorem provers. The theorem prover is also able to deduce the correctness of certain simplification steps that would otherwise not be performed. We describe the structure of Analytica and explain the main techniques that it uses to construct proofs. Analytica has been able to prove several nontrivial theorems. In this paper, we show how it can prove a series of lemmas that lead to the Bernstein approximation theorem.", "num_citations": "70\n", "authors": ["1571"]}
{"title": "Multi-terminal binary decision diagrams and hybrid decision diagrams\n", "abstract": " Functions that map vectors with binary values into the integers are important for the design and verification of arithmetic circuits. We demonstrate how multi-terminal binary decision diagrams (MTBDDs) can be used to represent such functions concisely. The Walsh transform and Reed-Muller transform have numerous applications in computer-aided design, but the usefulness of these techniques in practice has been limited by the size of the binary valued functions that can be transformed. We show how to compute the MTBDD representations of the Walsh transform and Reed-Muller transform for functions with several hundred variables. Bryant and Chen have proposed binary moment diagrams (BMDs) for representing the class of functions that we have considered. We discuss the relationship between these methods and describe a generalization called hybrid decision diagrams which is often much more\u00a0\u2026", "num_citations": "70\n", "authors": ["1571"]}
{"title": "Extending automated compositional verification to the full class of omega-regular languages\n", "abstract": " Recent studies have suggested the applicability of learning to automated compositional verification. However, current learning algorithms fall short when it comes to learning liveness properties. We extend the automaton synthesis paradigm for the infinitary languages by presenting an algorithm to learn an arbitrary regular set of infinite sequences (an \u03c9-regular language) over an alphabet \u03a3. Our main result is an algorithm to learn a nondeterministic B\u00fcchi automaton that recognizes an unknown \u03c9-regular language. This is done by learning a unique projection of it on \u03a3                 * using the framework suggested by Angluin for learning regular subsets of \u03a3                 *.", "num_citations": "69\n", "authors": ["1571"]}
{"title": "Verification of a safety-critical railway interlocking system with real-time constraints\n", "abstract": " Ensuring the correctness of computer systems used in life-critical applications is very difficult. The most commonly used verification methods, simulation and testing, are not exhaustive and can miss errors. This work describes an alternative verification technique based on symbolic model checking that can automatically and exhaustively search the state space of the system and verify if properties are satisfied or not. The method also provides useful quantitative timing information about the behavior of the system. We have applied this technique using the Verus tool to a complex safety-critical system designed to control medium and large-size railway stations. We have identified some anomalous behaviors in the model with serious potential consequences in the actual implementation. The fact that errors can be identified before a safety-critical system is deployed in the field not only eliminates sources of very serious\u00a0\u2026", "num_citations": "69\n", "authors": ["1571"]}
{"title": "SAT based predicate abstraction for hardware verification\n", "abstract": " Predicate abstraction is an important technique for extracting compact finite state models from large or infinite state systems. Predicate abstraction uses decision procedures to compute a model which is amenable to model checking, and has been used successfully for software verification. Little work however has been done on applying predicate abstraction to large scale finite state systems, most notably, hardware, where the decision procedures are SAT solvers. We consider predicate abstraction for hardware in the framework of Counterexample-Guided Abstraction Refinement where in the course of verification, the abstract model has to be repeatedly refined. The goal of the refinement is to eliminate spurious behavior in the abstract model which is not present in the original model, and gives rise to false negatives (spurious counterexamples).             In this paper, we present two efficient SAT-based\u00a0\u2026", "num_citations": "68\n", "authors": ["1571"]}
{"title": "ProbVerus: Probabilistic symbolic model checking\n", "abstract": " Model checking can tell us whether a system is correct; probabilistic model checking can also tell us whether a system is timely and reliable. Moreover, probabilistic model checking allows one to verify properties that may not be true with probability one, but may still hold with an acceptable probability. The challenge in developing a probabilistic model checker able to handle realistic systems is the construction of the state space and the necessity to solve huge systems of linear equations. To address this problem, we have developed ProbVerus, a tool for the formal verification of probabilistic real-time systems. ProbVerus is an implementation of probabilistic computation tree logic (PCTL) model checking using symbolic techniques. We present ProbVerus, demonstrate its use with a simple manufacturing example, and report the current status of the tool. With ProbVerus, we have been able to analyze, within\u00a0\u2026", "num_citations": "62\n", "authors": ["1571"]}
{"title": "Word level model checking\u2014avoiding the Pentium FDIV error\n", "abstract": " The highly-publicized division error in the Pentium has emphasized the importance of formal verification of arithmetic circuits. Symbolic model checking techniques based on binary decision diagrams (BDDs) have been successful inverifying control logic. However, lack of proper representation for functions that map boolean vectors into the integers has prevented this technique from being used for verifying arithmetic operations.We have developed a new technique for verifying arithmetic circuits. The new technique, called word level model checking, has been used successfully to verify circuits for division and square root computation that are based on the SRT algorithm used by the Pentium. The technique makes it possible to handle both the control logic and the data paths in the circuit. The total number of state variables exceeds 600 (which is much larger than any circuit previously handled by other symbolic\u00a0\u2026", "num_citations": "61\n", "authors": ["1571"]}
{"title": "Statistical verification of probabilistic properties with unbounded until\n", "abstract": " We consider statistical (sampling-based) solution methods for verifying probabilistic properties with unbounded until. Statistical solution methods for probabilistic verification use sample execution trajectories for a system to verify properties with some level of confidence. The main challenge with properties that are expressed using unbounded until is to ensure termination in the face of potentially infinite sample execution trajectories. We describe two alternative solution methods, each one with its own merits. The first method relies on reachability analysis, and is suitable primarily for large Markov chains where reachability analysis can be performed efficiently using symbolic data structures, but for which numerical probability computations are expensive. The second method employs a termination probability and weighted sampling. This method does not rely on any specific structure of the model, but error\u00a0\u2026", "num_citations": "59\n", "authors": ["1571"]}
{"title": "Parthenon: A parallel theorem prover for non-Horn clauses\n", "abstract": " We describe a parallel resolution theorem prover, called Parthenon, that handles full first order logic. Although there has been much work on parallel implementations of logic programming languages, Parthenon is the first general purpose theorem prover to be developed for a multiprocessor. The system is based on a modification of Warren's SRI model for or-parallelism and implements a variant of Loveland's model elimination procedure. It has been evaluated on various shared memory multiprocessors including a 16-processor Encore Multimax and IBM's 64-processor RP3. We have found that many theorem proving problems exhibit a great deal of potential parallelism. Parthenon has been able to exploit much of this parallelism, producing both good absolute run times and near-linear speedup curves in many cases.", "num_citations": "59\n", "authors": ["1571"]}
{"title": "Assume-guarantee abstraction refinement for probabilistic systems\n", "abstract": " We describe an automated technique for assume-guarantee style checking of strong simulation between a system and a specification, both expressed as non-deterministic Labeled Probabilistic Transition Systems (LPTSes). We first characterize counterexamples to strong simulation as stochastic trees and show that simpler structures are insufficient. Then, we use these trees in an abstraction refinement algorithm that computes the assumptions for assume-guarantee reasoning as conservative LPTS abstractions of some of the system components. The abstractions are automatically refined based on tree counterexamples obtained from failed simulation checks with the remaining components. We have implemented the algorithms for counterexample generation and assume-guarantee abstraction refinement and report encouraging results.", "num_citations": "58\n", "authors": ["1571"]}
{"title": "Statistical model checking of mixed-analog circuits with an application to a third order \u0394\u2212 \u03a3 modulator\n", "abstract": " In this paper, we consider verifying properties of mixed-signal circuits, i.e., circuits for which there is an interaction between analog (continuous) and digital (discrete) quantities. We follow the statistical Model Checking approach of [You05, You06] that consists of evaluating the property on a representative subset of behaviors, generated by simulation, and answering the question of whether the circuit satisfies the property with a probability greater than or equal to some value. The answer is correct up to a certain probability of error, which is pre-specified. The method automatically determines the minimal number of simulations needed to achieve the desired accuracy, thus providing a convenient way to control the trade-off between precision and computational cost. We propose a logic adapted to the specification of properties of mixed-signal circuits, in the temporal domain as well as in the frequency domain\u00a0\u2026", "num_citations": "56\n", "authors": ["1571"]}
{"title": "Effective axiomatizations of Hoare logics\n", "abstract": " For a wtde class of programming languages P and expressive interpretations I, tt is shown that there exist sound and relauvely complete Hoare logics for both partiabcorrectness and termmatton assertions. In fact, under mild assumpUons on P and I it is shown that the assertions true in I are uniformly decidable in the theory of I (Th (I)) fit\" the halting problem for P is decidable for fLmte interpretations. Moreover the set of true termination assertions is uniformly recursively enumerable m Th (1) even ff the halting problem for P~ s not dectdable for finite interpretations. Since total-correctness assertions coincide with termination assertions for deterministic programming languages, this last result unexpectedly suggests that good axiom systems for total correctness may exist for a wider spectrum of languages than is the case for partml correctness.", "num_citations": "56\n", "authors": ["1571"]}
{"title": "Design and synthesis of synchronization skeletons using branching time temporal logic\n", "abstract": " We Propose a method of constructing concurrent programs in which the synchronization skeleton of the program is automatically synthesized from a high-level (branching time) Temporal Logic specification. The synchronization skeleton is an abstraction of the actual program where detail irrelevant to synchronization is suppressed. For example, in the synchronization skeleton for a solution to the critical section problem each process\u2019s critical section may be viewed as a single node since the internal structure of the critical section is unimportant. Most solutions to synchronization problems in the literature are in fact given as synchronization skeletons. Because synchronization skeletons are in general finite state, the propositional version of Temporal Logic can be used to specify their properties.", "num_citations": "53\n", "authors": ["1571"]}
{"title": "SML-a high level language for the design and verification of finite state machines\n", "abstract": " Finite state machines are common components of VLSI circuits. Because they occur so frequently, many design tools have been written to layout finite state machines as PALs, PLAs, etc. Unfortunately, most of these tools require the user to enter the complete state transition table of the machine. If the number of states is large, this can be a difficult and error-prone process. Furthermore, large state transition tables are not easy for others to understand.In order to assist with the design of finite state machines, we have designed a programming language named SML (State Machine Language). In addition to being useful for design, SML can also be a documentation aid, since it provides a succinct notation for describing complicated finite state machines. A program written in SML can be compiled into a state transition table that can then be implemented in hardware using an appropriate design tool. The resulting state transition table can also be given to a temporal logic model checker ([2][5]) that allows certain properties of the state machine to be automatically verified. This is discussed extensively in some of our other papers ([3][4]), and will not be mentioned here.", "num_citations": "53\n", "authors": ["1571"]}
{"title": "Automated assume-guarantee reasoning through implicit learning\n", "abstract": " We propose a purely implicit solution to the contextual assumption generation problem in assume-guarantee reasoning. Instead of improving the L                 * algorithm \u2014 a learning algorithm for finite automata, our algorithm computes implicit representations of contextual assumptions by the CDNF algorithm \u2014 a learning algorithm for Boolean functions. We report three parametrized test cases where our solution outperforms the monolithic interpolation-based Model Checking algorithm.", "num_citations": "52\n", "authors": ["1571"]}
{"title": "Verifying the SRT division algorithm using theorem proving techniques\n", "abstract": " We verify the correctness of an SRT division circuit similar to the one in the Intel Pentium processor. The circuit and its correctness conditions are formalized as a set of algebraic relations on the real numbers. The main obstacle to applying theorem proving techniques for hardware verification is the need for detailed user guidance of proofs. We overcome the need for detailed proof guidance in this example by using a powerful theorem prover called Analytica. Analytica uses symbolic algebra techniques to carry out the proofs in this paper fully automatically.", "num_citations": "51\n", "authors": ["1571"]}
{"title": "Word level symbolic model checking: A new approach for verifying arithmetic circuits\n", "abstract": " The highly-publicized division error in the Pentium has emphasized the importance of formal verification of arithmetic operations. Symbolic model checking techniques based on binary decision diagrams BDDs have been successful in verifying control logic. However, lack of proper representation for functions that map boolean vectors into integers has prevented this technique from being used for verifying arithmetic circuits. We have used hybrid decision diagrams to represent the integer functions that occur in the arithmetic circuit verification. For the state variables corresponding to data bits, our representation behaves like a binary moment diagram BMD while for the state variables corresponding to control signals, it behaves like a multi-terminal BDD MTBDD. By using this representation, we are able to handle circuits with both control logic and wide data paths. We have extended the symbolic model checking system SMV so that it can also handle properties involving relationships among data words. In the original SMV system, atomic formulas could only contain state variables. In the extended system, we allow atomic formulas to be equations or inequalities between expressions as well. These expressions are represented as hybrid decision diagrams. The extended model checking system enables us to verify circuits for division and square root computation that are based on the SRT algorithm used by the Pentium. We are able to handle both the control logic and the data paths. The total number of state variables exceeds 600 which is much larger than any circuit previously checked by SMV. kar p. 3Descriptors:", "num_citations": "51\n", "authors": ["1571"]}
{"title": "Spectral transforms for extremely large Boolean functions\n", "abstract": " CiNii \u8ad6\u6587 - Spectral transforms for extremely large Boolean functions CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831\u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f\u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005 \u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 CiNii\u7a93\u53e3 \u696d\u52d9\u306e\u518d\u958b\u306b\u3064\u3044\u3066 Spectral transforms for extremely large Boolean functions CLARKE EM \u88ab \u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 CLARKE EM \u53ce\u9332\u520a\u884c\u7269 Proc. IFIP WG 10.5 Workshop on Applications of the Reed-Muller Expansion in Circuit Design Hamburg, Germany Proc. IFIP WG 10.5 Workshop on Applications of the Reed-Muller Expansion in Circuit Design Hamburg, Germany, 86-90, 1993 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 Design of Decision Diagrams with Increased Functionality of Nodes through Group Theory STANKOVIC Radomir S. , ASTOLA Jaakko \u2026", "num_citations": "50\n", "authors": ["1571"]}
{"title": "Synthesis of resource invariants for concurrent programs\n", "abstract": " Owicki and Gries have developed a proof system for conditional critical regions. In their system, logically related variables accessed by more than one process are grouped together as resources, and processes are allowed access to a resource only in a critical region for that resource. Proofs of synchronization properties are constructed by devising predicates called resource invariants which describe relationships among the variables of a resource when no process is in a critical region for the resource. In constructing proofs using the system of Owicki and Gries, the programmer is required to supply the resource invariants. Methods are developed in this paper for automatically synthesizing resource invariants. Specifically, the resource invariants of a concurrent program are characterized as least fixpoints of a functional which can be obtained from the text of the program. By the use of this fixpoint characterization\u00a0\u2026", "num_citations": "49\n", "authors": ["1571"]}
{"title": "The Verus tool: A quantitative approach to the formal verification of real-time systems\n", "abstract": " This work describes Verus, a new tool to be used in the formal verification of realtime systems. In Verus the designer specifies the system to be verified in a C-like language, and uses temporal logic model checking and quantitative timing analysis to verify its correctness. The information produced by our tool can help in verifying a real-time system in many ways. It not only assists in determining its correctness, but also provides insight into the behavior of the system. This allows for a better understanding of the system and in some cases it even suggests optimizations to the design.             We have used this tool to analyze several real-time systems of industrial complexity, such as an aircraft controller, a robotics controller and a distributed heterogeneous system. In all cases we have been able to determine the temporal correctness of the system. In several instances the results produced suggested modifications\u00a0\u2026", "num_citations": "48\n", "authors": ["1571"]}
{"title": "Is atherosclerosis fundamental to human aging? Lessons from ancient mummies\n", "abstract": " Case reports from Johan Czermak, Marc Ruffer, and others a century or more ago demonstrated ancient Egyptians had atherosclerosis three millennia ago. The Horus study team extended their findings, demonstrating that atherosclerosis was prevalent among 76 ancient Egyptian mummies and among 61 mummies from each of the ancient cultures of Peru, the American Southwest, and the Aleutian Islands. These findings challenge the assumption that atherosclerosis is a modern disease caused by present day risk factors. An extensive autopsy of an ancient Egyptian teenage male weaver named Nakht found that he was infected with four parasites: Schistosoma haematobium, Taenia species, Trichinella spiralis, and Plasmodium falciparum. Modern day patients with chronic inflammatory disease such as rheumatoid arthritis, systemic lupus erythematosus, and human immunodeficiency virus experience premature\u00a0\u2026", "num_citations": "46\n", "authors": ["1571"]}
{"title": "On simulation-based probabilistic model checking of mixed-analog circuits\n", "abstract": " In this paper, we consider verifying properties of mixed-signal circuits, i.e., circuits for which there is an interaction between analog (continuous) and digital (discrete) values. We use a simulation-based approach that consists of evaluating the property on a representative subset of behaviors and answering the question of whether the circuit satisfies the property with a probability greater than or equal to some threshold. We propose a logic adapted to the specification of properties of mixed-signal circuits in the temporal domain as well as in the frequency domain. We also demonstrate the applicability of the method on different models of \u0394\u2013\u03a3 modulators for which previous formal verification attempts were too conservative and required excessive computation time.", "num_citations": "46\n", "authors": ["1571"]}
{"title": "Why did ancient people have atherosclerosis?: from autopsies to computed tomography to potential causes\n", "abstract": " Computed tomographic findings of atherosclerosis in the ancient cultures of Egypt, Peru, the American Southwest and the Aleutian Islands challenge our understanding of the fundamental causes of atherosclerosis. Could these findings be true? Is so, what traditional risk factors might be present in these cultures that could explain this apparent paradox? The recent computed tomographic findings are consistent with multiple autopsy studies dating as far back as 1852 that demonstrate calcific atherosclerosis in ancient Egyptians and Peruvians. A nontraditional cause of atherosclerosis that could explain this burden of atherosclerosis is the microbial and parasitic inflammatory burden likely to be present in ancient cultures inherently lacking modern hygiene and antimicrobials. Patients with chronic systemic inflammatory diseases of today, including systemic lupus erythematosus, rheumatoid arthritis, and human\u00a0\u2026", "num_citations": "44\n", "authors": ["1571"]}
{"title": "SAT-based algorithms for logic minimization\n", "abstract": " We introduce a new method for two-level logic minimization. Unlike previous approaches, the new method uses a SAT solver as an underlying engine. While the overall minimization strategy of the new method is based on the operators as defined in ESPRESSO-II, our SAT-based implementation is significantly different. The new minimizer SAT-ESPRESSO was found to perform 5-20 times faster than ESPRESSO-II and 3-5 times faster than BOOM on a set of large examples.", "num_citations": "42\n", "authors": ["1571"]}
{"title": "Automatic circuit verification using temporal logic: Two new examples\n", "abstract": " Temporal logic is a formal system for reasoning about the occurrence of events in time. It belongs to die class of modal logics, originally developed by philosophers in an attempt to classify logical propositions according to their\" possibility\" or\" impossibility\". In the case of temporal logic special operators arc introduced that describe how the truth values of assertions vary with time. \u041b typical operator is G/which is true now if/is true at all future moments (/'is Globally true). As an example of how temporal logic might be used, consider the assertion that two events SL and S? do not occur simultaneously. This is naturally expressed by the formula G (-> S1 v-> S2). Pnculi [14] was apparently the first to realize that temporal logic might be useful for reasoning about concurrent programs. Later, Bochmann [4] and Owicki and Malachi [13] showed how his ideas could be extended to handle sequential circuits. Although these\u00a0\u2026", "num_citations": "40\n", "authors": ["1571"]}
{"title": "Timing analysis of industrial real-time systems\n", "abstract": " We describe a formal method for modelling real-time systems and a procedure to compute the model's timing characteristics automatically. We present algorithms that compute exact bounds on the delay between two specified events. We also describe an algorithm to count the minimum and maximum number of times an event occurs between a given starting condition and an ending condition. These algorithms are based on symbolic model checking techniques which have been successfully used to find bugs in several industrial designs. Such techniques can be used to search exhaustively state spaces with up to 10/sup 30/ states. To illustrate the usefulness of our method, we describe the timing analysis for a patient monitoring system with more than 10/sup 13/ states. We also present the timing analysis and verification for an aircraft controller. The sizes of the examples we verify demonstrate that our tool can be\u00a0\u2026", "num_citations": "39\n", "authors": ["1571"]}
{"title": "The characterization problem for Hoare logics\n", "abstract": " Research by myself and by others has shown that there are natural programming language control structures that are impossible to describe adequately by means of Hoare axioms. Specifically, we have shown that there are control structures for which it is impossible to obtain axiom systems that are sound and relatively complete in the sense of Cook. These constructs include procedures with procedure parameters under standard ALGOL 60 scope rules and coroutines in a language with parameterless recursive procedures. A natural question to ask is whether it is possible to characterize those programming languages for which sound and complete proof systems can be obtained. For a wide class of programming languages and interpretations, it can be shown that P has a sound and relatively complete proof system for every expressive interpretation iff the halting problem for language P is decidable for all finite\u00a0\u2026", "num_citations": "39\n", "authors": ["1571"]}
{"title": "Compiling path expressions into VLSI circuits\n", "abstract": " Path expressions were originally proposed by Campbell and Habermann [1] as a mechanism for process synchronization at the monitor level in software. Not unexpectedly, they also provide a useful notation for specifying the behavior of asynchronous circuits. Motivated by this potential application we investigate how to directly translate path expressions into hardware.", "num_citations": "38\n", "authors": ["1571"]}
{"title": "SAT-based compositional verification using lazy learning\n", "abstract": " A recent approach to automated assume-guarantee reasoning (AGR) for concurrent systems relies on computing environment assumptions for components using the L                 * algorithm for learning regular languages. While this approach has been investigated extensively for message passing systems, it still remains a challenge to scale the technique to large shared memory systems, mainly because the assumptions have an exponential communication alphabet size. In this paper, we propose a SAT-based methodology that employs both induction and interpolation to implement automated AGR for shared memory systems. The method is based on a new lazy approach to assumption learning, which avoids an explicit enumeration of the exponential alphabet set during learning by using symbolic alphabet clustering and iterative counterexample-driven localized partitioning. Preliminary experimental\u00a0\u2026", "num_citations": "37\n", "authors": ["1571"]}
{"title": "Learning abstractions for model checking\n", "abstract": " Learning is a process that causes a system to improve its performance through experience. Inductive learning is the process of learning by examples, ie the system learns a general rule from a set of sample instances.", "num_citations": "37\n", "authors": ["1571"]}
{"title": "Altered white matter microstructural organization in posttraumatic stress disorder across 3047 adults: results from the PGC-ENIGMA PTSD consortium\n", "abstract": " A growing number of studies have examined alterations in white matter organization in people with posttraumatic stress disorder (PTSD) using diffusion MRI (dMRI), but the results have been mixed which may be partially due to relatively small sample sizes among studies. Altered structural connectivity may be both a neurobiological vulnerability for, and a result of, PTSD. In an effort to find reliable effects, we present a multi-cohort analysis of dMRI metrics across 3047 individuals from 28 cohorts currently participating in the PGC-ENIGMA PTSD working group (a joint partnership between the Psychiatric Genomics Consortium and the Enhancing NeuroImaging Genetics through Meta-Analysis consortium). Comparing regional white matter metrics across the full brain in 1426 individuals with PTSD and 1621 controls (2174 males/873 females) between ages 18\u201383, 92% of whom were trauma-exposed, we report\u00a0\u2026", "num_citations": "36\n", "authors": ["1571"]}
{"title": "Decidability and complexity results for security protocols\n", "abstract": " Security protocols are prescribed sequences of interactions between entities designed to provide various security services across distributed systems. Security protocols are often wrong due to the extremely subtle properties they are supposed to ensure. Deciding whether or not a security protocol assures secrecy is one of the main challenge in this area.In this paper we survey the most important decidability and complexity results regarding the secrecy problem for various classes of security protocols, such as bounded protocols, finite-sessions protocols, normal protocols, and tagged protocols. All the results are developed under the same formalism. Several flawed statements claimed in the literature are corrected. Simplified proofs and reductions, as well as extensions of some known results, are also provided.", "num_citations": "36\n", "authors": ["1571"]}
{"title": "Task management in Ada\u2014A critical evaluation for real\u2010time multiprocessors\n", "abstract": " As the cost of processor hardware declines multiprocessor architectures become increasingly cost\u2010effective and represent an important area for future research. In order to exploit the full potential of multiprocessors, however, it is necessary to understand how to design software which can make effective use of the available parallelism. This paper considers the impact of multiprocessor architecture on the design of high\u2010level programming languages and, in particular, evaluates the language Ada in the light of the special requirements of realtime multiprocessor systems. We conclude that Ada does not, as currently designed, meet the needs for real\u2010time embedded systems.", "num_citations": "34\n", "authors": ["1571"]}
{"title": "Functional equivalence verification tools in high-level synthesis flows\n", "abstract": " High-level synthesis facilitates the use of formal verification methodologies that check the equivalence of the generated RTL model against the original source specification. The article provides an overview of sequential equivalence checking techniques, its challenges, and successes in real-world designs.", "num_citations": "33\n", "authors": ["1571"]}