{"title": "Dynamic software updates for real-time systems\n", "abstract": " Seamlessly updating software in running systems has recently gained momentum. Dynamically updating the software of real-time embedded systems, however, still poses numerous challenges: such systems must meet hard deadlines, cope with limited resources, and adhere to high safety standards.", "num_citations": "47\n", "authors": ["608"]}
{"title": "Comparing two model transformation approaches\n", "abstract": " For the MDA vision to become a reality, there must be a viable means to perform model-to-model transformation. In this paper, we compare and contrast two approaches to model transformation: one is a graph transformation-based approach, and the other is a relational approach, based on the QVT-Merge submission for OMG\u2019s MOF 2.0 Query/View/Transformation Request for Proposal. We apply them both to a common example, which involves transforming UML statemachines to a CSP specification, and we look at some of the concrete and conceptual differences between the approaches.", "num_citations": "37\n", "authors": ["608"]}
{"title": "Using patterns to develop consistent design constraints\n", "abstract": " Writing software is a difficult and complex task. In order to simplify this task, various programming paradigms and languages have been developed. Whereas early computers needed to be programmed in binary machine code, assembly languages [Saxon and Plette, 1962], also called second-generation programming languages, were developed to provide a more abstract interface to computer programming. Although assembly code is typically better readable than machine code, it remains unstructured and hard to understand. Modern programming paradigms such as functional programming [Bird and Wadler, 1988] or object-oriented programming [Cox, 1986], also called third-generation programming languages, abstract from low-level concepts such as CPU instructions and memory-address calculations by providing specialized syntax for various programming tasks. Examples for third-generation languages are Fortran, C, and Java. With increasing levels of abstraction, programmers can focus on the domain of a problem and on finding a solution for it, agnostic of technical details. This is one of the motivations behind the development of fourth-generation programming languages [Martin, 1982] such as SQL or PostScript, which focus on specific application domains. A recent development approach that takes these concepts to another level of abstraction is Model-Driven Engineering (MDE). In MDE, certain aspects of a system, eg, security requirements [Basin et al., 2006], are initially specified in terms of graphical models at a high level of abstraction. During the development process, these models are incrementally refined and eventually\u00a0\u2026", "num_citations": "32\n", "authors": ["608"]}
{"title": "Method for intrusion detection in industrial automation and control system\n", "abstract": " A method and system for automatic signalling an alert when a possible intrusion occurs in an industrial automation and control system, based on security events which occur in the industrial automation and control system or are externally fed into the system. The method includes the steps of:(a) determining a correlation of a first and second security event and storing the correlation in an event database, wherein the correlation includes a probability that the first security event is followed by the second security event within a normalized time period,(b) identifying a candidate event as the first security event, based on event information of the candidate event, upon occurrence of the candidate event,(c) classifying the candidate event as anomalous when the probability exceeds a predetermined threshold and no second security event follows the candidate event within the normalized time period, and (d) signalling the\u00a0\u2026", "num_citations": "27\n", "authors": ["608"]}
{"title": "Non-disruptive large-scale component updates for real-time controllers\n", "abstract": " Real-time controllers handle safety-critical environments such as power grids in a continuous way. Controllers are only updated during the same maintenance periods as the plant they control. As a consequence, old software versions are usually used longer than necessary, which can have a negative impact on performance, reliability, or security. This paper presents a solution for updating component-based controllers at runtime in a non-disruptive way - there is no \u201cbump\u201d in the control cycle. This solution allows for simultaneous updates of real-time components with arbitrarily large states. The solution is validated by demonstrating a large-scale dynamic software update on an embedded controller with a 1 kHz control cycle on RT Linux. As a corollary, we show that an arbitrary number of components can be simultaneously updated in a non-disruptive way.", "num_citations": "26\n", "authors": ["608"]}
{"title": "FASA: A software architecture and runtime framework for flexible distributed automation systems\n", "abstract": " Modern automation systems have to cope with large amounts of sensor data to be processed, stricter security requirements, heterogeneous hardware, and an increasing need for flexibility. The challenges for tomorrow\u2019s automation systems need software architectures of today\u2019s real-time controllers to evolve.This article presents FASA, a modern software architecture for next-generation automation systems. FASA provides concepts for scalable, flexible, and platform-independent real-time execution frameworks, which also provide advanced features such as software-based fault tolerance and high degrees of isolation and security. We show that FASA caters for robust execution of time-critical applications even in parallel execution environments such as multi-core processors.We present a reference implementation of FASA that controls a magnetic levitation device. This device is sensitive to any disturbance in its\u00a0\u2026", "num_citations": "25\n", "authors": ["608"]}
{"title": "CAST: Automating software tests for embedded systems\n", "abstract": " Software integration tests for embedded systems must cater for the physical process with which the systems interact and can include user input. This can make testing very time-consuming because test engineers often manually execute test specifications with many thousand lines of instructions. Furthermore, such manual tests are often imprecise because human operators cannot execute interactions at a granularity of a few milliseconds. This article presents the CAST (Computer-Aided Specification and Testing) approach to automating the testing of embedded systems, which consists of three parts: a domain-specific language, which allows test engineers to specify test cases formally with a familiar syntax, an execution engine, which allows them to run tests either automatically or interactively, and an interface, which connects the execution engine to the embedded system. We validate the proposed approach by\u00a0\u2026", "num_citations": "23\n", "authors": ["608"]}
{"title": "Dynamic analysis of upgrades in C/C++ software\n", "abstract": " Regression testing techniques are commonly used to validate the correctness of upgrades. When a regression test fails, testers must understand the erroneous behaviors that caused the failure and identify the fault that originated these erroneous behaviors. In many cases, identifying the causes of a failure is difficult and time consuming. The analysis of regression problems provides interesting opportunities to validation and verification techniques. In fact, by comparing the execution of the base version and the upgraded version of the same program it is possible to automatically deduce information about incorrect behavior of the program. In this paper we present RADAR (Regression Analysis with Diff And Recording), a dynamic analysis technique, which analyzes regression problems and automatically identifies the chain of erroneous events that lead to a failure in C/C++ programs. RADAR exploits information\u00a0\u2026", "num_citations": "20\n", "authors": ["608"]}
{"title": "Disruption-free software updates in automation systems\n", "abstract": " Automation systems must primarily be deterministic and reliable, especially in safety-critical environments. With recent trends such as mass customization or Industry 4.0, there is an increasing need for automation systems to be dynamic. Changing parts of the software of today's automation systems, however, typically requires rebooting the controller, which makes software updates a complex and costly endeavor often despised by operators. This article presents an approach to updating the software of automation systems at runtime without disrupting the system's operation. This is achieved with a combination of a component-based architecture, cyclic application execution, and a state transfer mechanism between the original and the updated version of a component. We validate our solution with a case study in which we update the control algorithm of a magnetic levitation device running at cycles of 1 kHz without\u00a0\u2026", "num_citations": "17\n", "authors": ["608"]}
{"title": "Fault-tolerant fault tolerance for component-based automation systems\n", "abstract": " To guarantee high availability, automation systems must be fault-tolerant. To this end, they must provide redundant solutions for the critical parts of the system. Classical fault tolerance patterns such as standby or N-modular redundancy provide system stability in the case of a fault. Fault tolerance is subsequently degraded or, depending on the number of deployed replicas, often even unavailable until the system has been repaired.", "num_citations": "16\n", "authors": ["608"]}
{"title": "Improving code maintainability: A case study on the impact of refactoring\n", "abstract": " It is a fact that a lot of software is written by people without a formal education in software engineering. As an example, material scientists often capture their knowledge in the form of simulation software that contains sophisticated algorithms representing complex physical concepts. Since software engineering is typically not a core skill of these scientists, there is a risk that their software becomes unmaintainable once it reaches a substantial size or structural complexity. This paper reports on a case study in which software engineers consulted magnetics researchers in refactoring their simulation software. This software had grown to 30 kloc of Java and was considered unmaintainable by the stakeholders of the research project. The case study describes the process of refactoring a system under the guidance of a software engineer with results supported by static analysis and software metrics. It shows how software\u00a0\u2026", "num_citations": "15\n", "authors": ["608"]}
{"title": "A framework for component-based real-time control applications\n", "abstract": " State-of-the-art real-time control systems execute multiple concurrent control applications using operating system mechanisms such as processes, mutexes, or message queues. Such mechanisms leave a high degree of freedom to developers but are often hard to deal with: they incur runtime overhead, eg, context switches between threads, and often require tedious and costly fine-tuning, eg, of process and thread priorities. Reuse is often made more difficult by the tight coupling of software to a given hardware or other software.In this paper, we present a software architecture and execution framework for cyclic control applications that simplifies the construction of real-time control systems while increasing predictability and reducing runtime overhead and coupling. We present the concepts of this framework as well as implementation details of our RTLinux-based prototype.", "num_citations": "14\n", "authors": ["608"]}
{"title": "Modern software architecture for embedded real-time devices: High value, little overhead\n", "abstract": " Embedded devices are often tightly constrained by CPU power and memory size. As a consequence, developers of embedded software avoid any kind of design abstractions, thinking that they imply large overhead. This results in complex designs with high coupling between the individual entities. The code of such designs is then difficult to maintain or reuse. This article presents FASAlight, a component-based software architecture for embedded devices with a focus on three main quality attributes that support maintenance and reuse: modularity, reusability, and portability. This architecture can be effectively implemented even for low-end embedded devices and only implies at worst a 14% on CPU and small overhead on memory on a device with a 120MHz ARM CPU and 128 kB of RAM.", "num_citations": "10\n", "authors": ["608"]}
{"title": "A model driven XML transformation framework for Business Performance Management model creation\n", "abstract": " As XML formats have been widely adopted for representing business documents both within and across enterprises, XML to XML translation becomes a common and critical component for business process integration. Due to limitations of popular approaches such as XSLT for XML translations, we designed a model driven development framework for XML to XML translation with the additional benefits of code re-use and strong built-in model validation. We further applied this framework to the domain of Business Performance Management (BPM), converting documents from human-readable XML format to machine-readable XMI format. Experimental evaluation indicated that XML models can have more than 75% size reduction.", "num_citations": "8\n", "authors": ["608"]}
{"title": "Migrating legacy control software to multi-core hardware\n", "abstract": " This paper reports on a case study on analyzing, structuring and re-using real-time control algorithms which represent a significant amount of intellectual property. As a starting point, legacy code written in ADA together with a Windows-based testing framework is available. The goal is to migrate the code onto a real-time multi-core platform taking advantage of technological progress. We present a tool-supported three-step approach for such legacy control software: identifying and isolating the control algorithms, preparing these algorithms and their information exchange for execution within a modern execution framework for Linux written in C++, and validating the solution by a) performing regression testing to ensure partial correctness and b) validating its real-time properties.", "num_citations": "7\n", "authors": ["608"]}
{"title": "Reconciling flexibility and robustness in industrial automation systems, and living happily ever after\n", "abstract": " Many automation systems are used in safety-critical environments, in which any nondeterministic timing behavior of the software may damage equipment or even threaten the health of people. Making software behave deterministically usually relies on hardware-bound optimizations, leaving little room for abstraction layers. This, however, has a negative impact on several important software qualities such as portability, maintainability, or scalability. As a consequence, it becomes difficult to use the same software across different platforms, scale it up or down to changing requirements, or reuse code across different families of products. In this article, we show how both flexibility and robustness can be achieved for real-time automation software. To this end, we present the mechanisms behind the component-based execution framework FASA. This framework offers a platform abstraction mechanism, which allows\u00a0\u2026", "num_citations": "6\n", "authors": ["608"]}
{"title": "Real-time research lab in the Sundom smart grid pilot\n", "abstract": " The Sundom smart grid pilot offers a unique opportunity for evaluating new kinds of smart grid technologies. In this paper, we present how we set up a research lab to determine how protection and analysis can be executed remotely. First field tests show that remote data analysis is feasible and that remote protection requires additional research.", "num_citations": "5\n", "authors": ["608"]}
{"title": "Real-time multi-core components for cyber-physical systems\n", "abstract": " Developing correct, efficient, and maintainable real-time control software for cyber-physical systems is a notoriously difficult interdisciplinary challenge. Ever more complex control algorithms and the advent of multi-core hardware in embedded systems have made this challenge even harder. Component-based software development promises to help reduce the complexity and to increase the timing predictability for time-critical software. This paper presents FASA, a component-based approach for scalable real-time systems. This approach offers a platform-independent development method with a high degree of predictability, supports multi-core systems by design, and simplifies maintenance. Two case studies validate FASA: an application handling a magnetic levitation device and an example of scalability.", "num_citations": "5\n", "authors": ["608"]}
{"title": "Automatic attack surface reduction in next-generation industrial control systems\n", "abstract": " Industrial control systems are often large and complex distributed systems and therefore expose a large potential attack surface. Effectively minimizing this attack surface requires security experts and significant manpower during engineering and maintenance of the system. This task, which is already difficult for today's control systems, will become significantly more complex for tomorrow's systems, which can reconfigure themselves dynamically, e.g., if hardware failures occur. In this article, we present a dynamic security system which can automatically minimize the attack surface of a control system's communication network. This security system is specifically designed for next-generation industrial control systems, but can also be applied in current generation systems. The presented security system adapts the necessary parameters of network and security controls according to the underlying changes in the control\u00a0\u2026", "num_citations": "5\n", "authors": ["608"]}
{"title": "Increasing Efficiency of M-out-of-N Redundancy\n", "abstract": " In industrial automation, unexpected failures often generate high direct and indirect costs. To achieve high availability, the critical parts of the system are typically redundant. M-out-of-N (MooN) redundancy is a widespread redundancy pattern because it offers low failover times. This pattern has however two major disadvantages. First, the voter, an essential entity in MooN patterns, is itself a single point of failure. Second, it introduces delay to the control process and significant network load when deployed with multiple voters. This article proposes new MooN redundancy patterns for distributed control systems. These eliminate the voter as a single point of failure and reduce the network load and delay of the MooN redundancy. For each of these patterns we introduce an algorithm, which computes a near-minimum instance for the MooN problem. We validate our solution against minimum values and present a case\u00a0\u2026", "num_citations": "5\n", "authors": ["608"]}
{"title": "Quality attribute trade-offs in industrial software systems\n", "abstract": " The main challenge of architecting modern industrial control and automation systems (ICASs) is that they need to fulfill quality attributes (QAs) traditional to real-time systems - such as timeliness and predictability - and modern software engineering - such as modularity or reusability. QAs often are conflicting, which entails difficult trade-offs. As a consequence, even the architecture of closely related ICAS products can differ substantially due to their different priorities on QAs. This article presents six essential, but partially conflicting quality attributes for ICAS and shows how the shift in priority of these QAs impacts the architecture of three functionally very similar ICAS platforms.", "num_citations": "4\n", "authors": ["608"]}
{"title": "Formalizing Relational Model Transformation Approaches\n", "abstract": " The current efforts on model transformation promise solutions for various problems in model driven software development. However, vague concepts still outnumber semantically well-defined approaches. Among the various concepts for model transformations, relational approaches seem to be the most promising. In my Ph. D. thesis, I am going to investigate the syntax and semantics of relational model transformation languages as well as computational aspects, thus giving an execution semantics to relations.", "num_citations": "4\n", "authors": ["608"]}
{"title": "Relay interface module for a distributed control system\n", "abstract": " A relay interface module that is commutatively connectable to at least one I/O device and a controller, wherein the relay interface module is configured to provide data from the I/O device to at least one controller in a distributed control system (DCS) via a communication interface. An application related to a particular I/O device may then be executed freely on any controller present in a DCS without losing real time connection with the associated I/O device. Data can be transferred from an I/O device to an associated application executed on a controller such that the real time connection between the I/O device and the application being executed is maintained.", "num_citations": "3\n", "authors": ["608"]}
{"title": "Dynamic configuration of an industrial control system\n", "abstract": " A controller module, method, and a non-transitory computer program product are disclosed for the dynamic configuration of an industrial control system, which can include a current settings receiver configured to receive current configuration and security settings of the industrial control system, a changed settings receiver configured to receive changed configuration settings of the industrial control system, a settings analyzer configured to determine, based on the current configuration and security settings and the changed configuration settings, updated configuration and security settings of the industrial control system, and a dynamic activator configured to dynamically establish at least one communication path in order to activate updated configuration and security settings of the industrial control system.", "num_citations": "3\n", "authors": ["608"]}
{"title": "Method of organizing software design decision instances\n", "abstract": " A method of organizing received decision instances based on reference architecture, including determining a respective particular project phase attribute for each of the decision instances, classifying the decision instances, determining a respective scope attribute for each of the decision instances, categorizing the decision instances in accordance with each of the respective scope attributes thereof, for all decision instances with the same categorization and with the same classification, ordering the corresponding decision instances by model elements, modeling directed links between apparently dependent decision instances, analyzing the dependent decision instances to confirm that the decision instances satisfy the apparent dependencies represented by the directed links and producing an error message if a result of the analysis is negative, and generating a real-time updateable and/or modifiable to-do list\u00a0\u2026", "num_citations": "3\n", "authors": ["608"]}
{"title": "Method and a system for online and dynamic distribution and configuration of applications in a distributed control system\n", "abstract": " Exemplary embodiments are directed to a method and system of online and dynamic distribution and configuration of applications in a Distributed Control System (DCS) of a plant. One or more applications of at least one controller of the DCS is divided into a plurality of blocks. The application is changed by managing each of the blocks. The one or more blocks is dynamically distributed to at least one other controller of the DCS. The data distributed to the at least one other controller is synchronized between the other controllers. The application associated with the distributed data is managed based on an operation schedule of the DCS.", "num_citations": "2\n", "authors": ["608"]}
{"title": "Fault tolerant industrial automation control system\n", "abstract": " A combination of a component-based automation framework, software-based redundancy patterns, and a distributed, reliable runtime manager, is able to detect host failures and to trigger a reconfiguration of the system at runtime. This combined solution maintains system operation in case a fault occurs and, in addition, automatically restores fault tolerance by using backup contingency plans, and without the need for operator intervention or immediate hardware replacement. A fault-tolerant fault tolerance mechanism is thus provided, which restores the original level of fault tolerance after a failure has occurred\u2014automatically and immediately, ie, without having to wait for a repair or replacement of the faulty entity. In short, the invention delivers increased availability or uptime of a system at reduced costs and complexity for an operator or engineer by adapting automatically to a new environment.", "num_citations": "1\n", "authors": ["608"]}
{"title": "RADAR: dynamic analysis of upgrades in C/C++ software\n", "abstract": " This chapter presents RADAR, a dynamic analysis technique, which analyzes regression problems and automatically identifies failure causes in C and C++ software.", "num_citations": "1\n", "authors": ["608"]}
{"title": "A Pattern Approach to Increasing the Maturity Level of Class Models\n", "abstract": " Class models are typically specified at a high level of abstraction and subsequently refined with textual constraints to obtain higher maturity levels. This task requires significant expertise and effort because constraints must be elicited and formalized. In this chapter, we identify typical refinement problems for class models that threaten model quality and show how a list of refinement tasks can be automatically compiled from a given model. We present constraint patterns that help to carry out these tasks semiautomatically and introduce a tool prototype for our approach.", "num_citations": "1\n", "authors": ["608"]}