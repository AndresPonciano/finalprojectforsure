{"title": "Aspect-oriented programming\n", "abstract": " We have found many programming problems for which neither procedural nor object-oriented programming techniques are sufficient to clearly capture some of the important design decisions the program must implement. This forces the implementation of those design decisions to be scattered throughout the code, resulting in \u0393\u00c7\u00a3tangled\u0393\u00c7\u00a5 code that is excessively difficult to develop and maintain. We present an analysis of why certain design decisions have been so difficult to clearly capture in actual code. We call the properties these decisions address aspects, and show that the reason they have been hard to capture is that they cross-cut the system's basic functionality. We present the basis for a new programming technique, called aspect-oriented programming, that makes it possible to clearly express programs involving such aspects, including appropriate isolation, composition and reuse of the aspect code\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "10999\n", "authors": ["40"]}
{"title": "An overview of AspectJ\n", "abstract": " AspectJ\u0393\u00e4\u00f3 is a simple and practical aspect-oriented extension to Java.. With just a few new constructs, AspectJ provides support for modular implementation of a range of crosscutting concerns. In AspectJ\u0393\u00c7\u00d6s dynamic join point model, join points are well-defined points in the execution of the program; pointcuts are collections of join points; advice are special method-like constructs that can be attached to pointcuts; and aspects are modular units of crosscutting implementation, comprising pointcuts, advice, and ordinary Java member declarations. AspectJ code is compiled into standard Java bytecode. Simple extensions to existing Java development environments make it possible to browse the crosscutting structure of aspects in the same kind of way as one browses the inheritance structure of classes. Several examples show that AspectJ is powerful, and that programs written using it are easy to understand.", "num_citations": "4456\n", "authors": ["40"]}
{"title": "The art of the metaobject protocol\n", "abstract": " The authors introduce this new approach to programming language design, describe its evolution and design principles, and present a formal specification of a metaobject protocol for CLOS. The CLOS metaobject protocol is an elegant, high-performance extension to the CommonLisp Object System. The authors, who developed the metaobject protocol and who were among the group that developed CLOS, introduce this new approach to programming language design, describe its evolution and design principles, and present a formal specification of a metaobject protocol for CLOS. Kiczales, des Rivi\u251c\u00bfres, and Bobrow show that the\" art of metaobject protocol design\" lies in creating a synthetic combination of object-oriented and reflective techniques that can be applied under existing software engineering considerations to yield a new approach to programming language design that meets a broad set of design criteria. One of the major benefits of including the metaobject protocol in programming languages is that it allows users to adjust the language to better suit their needs. Metaobject protocols also disprove the adage that adding more flexibility to a programming language reduces its performance. In presenting the principles of metaobject protocols, the authors work with actual code for a simplified implementation of CLOS and its metaobject protocol, providing an opportunity for the reader to gain hands-on experience with the design process. They also include a number of exercises that address important concerns and open issues. Gregor Kiczales and Jim des Rivi\u251c\u00bfres, are Members of the Research Staff, and Daniel Bobrow is a Research\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2168\n", "authors": ["40"]}
{"title": "Design pattern implementation in Java and AspectJ\n", "abstract": " AspectJ implementations of the GoF design patterns show modularity improvements in 17 of 23 cases. These improvements are manifested in terms of better code locality, reusability, composability, and (un) pluggability. The degree of improvement in implementation modularity varies, with the greatest improvement coming when the pattern solution structure involves crosscutting of some form, including one object playing multiple roles, many objects playing one role, or an object playing roles in multiple pattern instances.", "num_citations": "964\n", "authors": ["40"]}
{"title": "Getting started with AspectJ\n", "abstract": " C oncern about the risk of adopting new technology causes many organizations to be reluctant to do so. But simply waiting can lead to rushing to adopt the technology later, which is itself risky. Instead, this article presents a staged approach based on identifying two broad categories of aspects: development aspects facilitate tasks such as debugging, testing, and performance tuning of applications; production aspects implement functionality intended to be included in shipping applications. These categories are informal, and this ordering is not the only way to adopt AspectJ. Some developers will want to use a production aspect right away, but experience with current AspectJ users has shown this ordering allows developers to derive benefits from AOP technology quickly, while also minimizing risk.", "num_citations": "863\n", "authors": ["40"]}
{"title": "Common lisp object system specification\n", "abstract": " Introduction  The Common Lisp Object System is an object-oriented extension to Common Lisp as defined in Common Lisp: The Language, by Guy L. Steele Jr. It is based on generic functions, multiple inheritance, declarative method combination, and a meta-object protocol.    The first two chapters of this specification present a description of the standard Programmer Interface for the Common Lisp Object System. The first chapter contains a description of the concepts of the Common Lisp Object System, and the second contains a description of the functions and macros in the Common Lisp Object System Programmer Interface. The chapter \"The Common Lisp Object System Meta-Object Protocol\" describes how the Common Lisp Object System can be customized.    The fundamental objects of the Common Lisp Object System are classes, instances, generic functions, and methods.    A class object determines the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "687\n", "authors": ["40"]}
{"title": "D: A language framework for distributed programming\n", "abstract": " Two of the most important issues in distributed systems are the synchronization of concurrent threads and the application-level data transfers between execution spaces. At the design level, addressing these issues typically requires analyzing the components under a different perspective than is required to analyze the functionality. Very often, it also involves analyzing several components at the same time, because of the way those two issues cross-cut the units of functionality. At the implementation level, existing programming languages fail to provide adequate support for programming in terms of these different and cross-cutting perspectives. The result is that the programming of synchronization and remote data transfers ends up being tangled throughout the components code in more or less arbitrary ways.This thesis presents a language framework called D that untangles the implementation of synchronization schemes and remote data transfers from the implementation of the components. In the D framework there are three kinds of modules:(1) classes, which are used to implement functional components, and are clear of code dealing with the aspects;(2) coordinators, which concentrate the code for dealing with the thread synchronization aspect; and (3) portals which concentrate the code for dealing with the aspect of application-level data transfers over remote method invocations. To support this separation, D provides two aspect-specific languages: COOL, for programming the coordinators, and RIDL, for programming the portals. COOL and RIDL were designed to address the specific needs of the two kinds of aspects. COOL and RIDL can\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "448\n", "authors": ["40"]}
{"title": "CommonLoops: Merging Lisp and object-oriented programming\n", "abstract": " CommonLoops blends object-oriented programming smoothly and tightly with the procedure-oriented design of Lisp. Functions and methods are combined in a more general abstraction. Message passing is invoked via normal Lisp function call. Methods are viewed as partial descriptions of procedures. Lisp data types are integrated with object classes. With these integrations, it is easy to incrementally move a program between the procedure and object-oriented styles.One of the most important properties of CommonLoops is its extensive use of meta-objects. We discuss three kinds of meta-objects: objects for classes, objects for methods, and objects for discriminators. We argue that these meta-objects make practical both efficient implementation and experimentation with new ideas for object-oriented programming.CommonLoops' small kernel is powerful enough to implement the major object-oriented systems in\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "423\n", "authors": ["40"]}
{"title": "Beyond the black box: Open implementation\n", "abstract": " Encapsulation, informally known as black-box abstraction, is a widely known and accepted principle. It is a basic tenet of software design, underlying approaches to portability and reuse. However, many practitioners find themselves violating it in order to achieve performance requirements in a practical manner. The gap between theory and practice must be filled. Open implementation is a controversial new approach that claims to do just that. The paper provides some ideas to spark further debate on black-box abstraction.", "num_citations": "334\n", "authors": ["40"]}
{"title": "A semantics for advice and dynamic join points in aspect-oriented programming\n", "abstract": " A characteristic of aspect-oriented programming, as embodied in Aspect J, is the use of advice and point cuts to define behavior that crosscuts the structure of the rest of the code. The events during execution at which advice may execute are called join points. A pointcut is a set of join points. An advice is an action to be taken at the join points in a particular pointcut. In this model of aspect-oriented programming, join points are dynamic in that they refer to events during the flow of execution of the program.We give a denotational semantics for a minilanguage that embodies the key features of dynamic join points, pointcuts, and advice. This is the first semantics for aspect-oriented programming that handles dynamic join points and recursive procedures. It is intended as a baseline semantics against which future correctness results may be measured.", "num_citations": "310\n", "authors": ["40"]}
{"title": "Using AspectC to improve the modularity of path-specific customization in operating system code\n", "abstract": " Layered architecture in operating system code is often compromised by execution path-specific customizations such as prefetching, page replacement and scheduling strategies. Path-specific customizations are difficult to modularize in a layered architecture because they involve dynamic context passing and layer violations. Effectively they are vertically integrated slices through the layers. An initial experiment using an aspect-oriented programming language to refactor prefetching in the FreeBSD operating system kernal shows significant benefits, including easy (un) pluggability of prefetching modes, independent development of prefetching modes, and overall improved comprehensibility.", "num_citations": "292\n", "authors": ["40"]}
{"title": "Modeling crosscutting in aspect-oriented mechanisms\n", "abstract": " Modeling four aspect-oriented programming mechanisms shows the way in which each supports modular crosscutting. Comparing the models produces a clear three part characterization of what is required to support crosscutting structure: a common frame of reference that two (or more) programs can use to connect with each other and each provide their semantic contribution.", "num_citations": "265\n", "authors": ["40"]}
{"title": "Overcoming the prevalent decomposition in legacy code\n", "abstract": " The potential benefits of advanced separation of concerns (ASOC) techniques are well known and many programmers find the idea of using them appealing. For new software engineering projects these modularization mechanisms offer guidelines of how to structure the system modules. But how can legacy systems profit from them? Code related to concerns not represented in the current modularization has to be carefully identified and extracted while preserving system integrity.", "num_citations": "238\n", "authors": ["40"]}
{"title": "A compilation and optimization model for aspect-oriented programs\n", "abstract": " This paper presents a semantics-based compilation model for an aspect-oriented programming language based on its operational semantics. Using partial evaluation, the model can explain several issues in compilation processes, including how to find places in program text to insert aspect code and how to remove unnecessary run-time checks. It also illustrates optimization of calling-context sensitive pointcuts (cflow), implemented in real compilers.", "num_citations": "218\n", "authors": ["40"]}
{"title": "Open implementation design guidelines\n", "abstract": " Designing reusable software modules can be extremely difficult. The design must be balanced between being general enough to address the needs of a wide range of clients and being focused enough to truly satisfy the requirements of each specific client One area where it can be particularly difficult to strike this balance is in the implementation strategy of the module. The problem is that generalpurpose implementation strategies, tuned for a wide range of clients, aren't necessarily optimal for each specific client-this is especially an issue for modules that are intended to be reusable and yet provide high-performance.An examination of existing software systems shows that an increasingly important technique for handling this problem is to design the module's interface in such a way that the client can assist or participate in the selection of the module's implementation strategy. We call this approach open", "num_citations": "172\n", "authors": ["40"]}
{"title": "Towards a new model of abstraction in software engineering\n", "abstract": " Existing abstraction techniques lead to implementations which overly constrain their users. This happens because these techniques force the implementor to make all the decisions about how to implement the abstraction including some which would better be made by the user. The author has developed a new model of abstraction, which he calls the two-view approach; the first view is the traditional one, it provides the functionality of the abstraction, the second view allows the user to participate in some implementation decisions. This approach promises to be general enough to handle a wide range of applications.<>", "num_citations": "169\n", "authors": ["40"]}
{"title": "Back to the future: A retroactive study of aspect evolution in operating system code\n", "abstract": " The FreeBSD operating system more than doubled in size between version 2 and version 4. Many changes to primary modularity are easy to spot at a high-leveL For example, new device drivers account for 38% of the growth. Not surprisingly, changes to crosscutting concerns are more difficult to track. In order to better understand how an aspect-oriented implementation would have fared during this evolution, we introduced several aspects to version 2 code, and then rolled them forward into their subsequent incarnations in versions 3 and 4 respectively. This paper describes the impact evolution had on these concerns, and provides a comparative analysis of the changes required to evolve the tangled versus aspect-oriented implementations. Our results show that for the concerns we chose, the aspect-oriented implementation facilitated evolution in four key ways:(1) changes were better localized,(2) configurability\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "167\n", "authors": ["40"]}
{"title": "Separation of concerns with procedures, annotations, advice and pointcuts\n", "abstract": " There are numerous mechanisms for separation of concerns at the source code level. Three mechanisms that are the focus of recent attention \u0393\u00c7\u00f4 metadata annotations, pointcuts and advice \u0393\u00c7\u00f4 can be modeled together with good old-fashioned procedures as providing different kinds of bindings: procedure calls bind program points to operations, annotations bind attributes to program points; pointcuts bind sets of points to various descriptions of those sets; named pointcuts bind attributes to sets of points; and advice bind the implementation of an operation to sets of points. This model clarifies how the mechanisms work together to separate concerns, and yields guidelines to help developers use the mechanisms in practice.", "num_citations": "138\n", "authors": ["40"]}
{"title": "Role-based refactoring of crosscutting concerns\n", "abstract": " Improving the structure of code can help developers work with a software system more efficiently and more consistently. To aid developers in re-structuring the implementation of crosscutting concerns using aspect-oriented programming, we introduce a role-based refactoring approach and tool. Crosscutting concerns (CCCs) are described in terms of abstract roles, and instructions for refactoring crosscutting concerns are written in terms of those roles. To apply a refactoring, a developer maps a subset of the roles to concrete program elements; a tool can then help complete the mapping of roles to the existing program. Refactoring instructors are then applied to manipulate and modularize the concrete elements corresponding to the crosscutting concern. Evaluation of the prototype tool on a graphical editing framework suggests that the approach helps planning and executing complex CCC refactorings.", "num_citations": "136\n", "authors": ["40"]}
{"title": "Issues in the design and specification of class libraries\n", "abstract": " The design and specification of an extensible class library presents a difficult challenge: because extensibility comes from allowing the user to override parts of the implementation, more of the internal structure must be exposed to the user than in a typical procedure library. This raises issues in both how the library is designed and how its specification is written. Specification of the CLOS Metaobject Protocol required a combination of new and existing techniques to address these issues. We present those techniques, and discuss their relation to the underlying issues.", "num_citations": "131\n", "authors": ["40"]}
{"title": "RG: A case-study for aspect-oriented programming\n", "abstract": " RG is an image processing system that allows sophisticated image processing operations to be defined by composing primitive image processing filters. An implementation of RG using OOP is easy to do and quite manageable, but its performance is severely lacking. The OOP approach turns out not to be well-suited to addressing the performance problems because the performance issues we want to handle do not respect object or method boundaries and cannot be effectively addressed in a paradigm tied to those boundaries. Aspect-oriented programming is an approach designed to handle complexities arising from such cross-cutting issues. This paper presents a casestudy of how this limitation of OOP was overcome using aspect-oriented programming techniques, such that the performance problems were adequately addressed without compromising the original OOP architecture of the system.", "num_citations": "119\n", "authors": ["40"]}
{"title": "Aspect-oriented programming of sparse matrix code\n", "abstract": " The expressiveness conferred by high-level and object-oriented languages is often impaired by concerns that cross-cut a program's basic functionality. Execution time, data representation, and numerical stability are three such concerns that are of great interest to numerical analysts. Using aspect-oriented programming we have created AML, a system for sparse matrix computation that deals with these concerns separately and explicitly while preserving the expressiveness of the original functional language. The resulting code maintains the efficiency of highly tuned low-level code, yet is ten times shorter.", "num_citations": "110\n", "authors": ["40"]}
{"title": "Towards a new model of abstraction in the engineering of software\n", "abstract": " This is an abridged version of a longer paper in preparation. The eventual goal is to present, to those outside of the reflection and meta-level architectures community, the intuitions surrounding open implementations and the use of meta-level architectures, particularly metaobject protocols, to achieve them.The view of abstraction on which software engineering is based does not support the reality of practice: it suggests that abstractions hide their implementation, whereas the evidence is that this is not generally possible. This discrepancy between our basic conceptual foundations and practice appears to be at the heart of a number of portability and complexity problems.", "num_citations": "107\n", "authors": ["40"]}
{"title": "Recent Developments in AspectJ\u0393\u00e4\u00f3\n", "abstract": " This paper summarizes the latest developments in AspectJ, a general-purpose aspect-oriented programming (AOP) extension to Java. Some examples of aspects are shown. Based on our experience in designing language extensions for AOP, we also present a design space for AOP languages that may be of interest to the AOP community.", "num_citations": "104\n", "authors": ["40"]}
{"title": "Efficient method dispatch in PCL\n", "abstract": " Efficient implementation of CLOS is critical to its success as a standard. Some excellent work on Lisp Machines [3, 71 ha. 5 demonstrated clearly that CLOS can be implemented efficiently using special-purpose hardware. This paper describes a mechanism for implementing CLOS method dispatch efficiently on stock hardware, in the current generation of Common Lisp implementations. This mechanism is implemented in the newest version of PCL, a portable implementation of CLOS, and runs in more than ten Common Lisps. lPCL is designed to support development, not delivery of CLOS programs. The goal is to provide not just high runtime performance, but also rapid interactive response during development of CLOS programs. This work is based on a careful analysis of the behavior of existing CLOS programs. The method dispatch mechanism differs from previously published work in three important ways. First\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "104\n", "authors": ["40"]}
{"title": "Compilation semantics of aspect-oriented programs\n", "abstract": " This paper presents a semantics-based compilation framework for an aspect-oriented programming language based on its operational semantics model. Using partial evaluation, the framework can explain several issues in compilation processes, including how to find places in program text to insert aspect code and how to remove unnecessary run-time checks. It also illustrates optimization of calling-context sensitive pointcuts (cflow), implemented in real compilers.", "num_citations": "90\n", "authors": ["40"]}
{"title": "High-level loop fusion\n", "abstract": " A processor is provided with a software program specifying an overall computation that includes operations. Each operation implies a set of subcomputations, without explicitly specifying a control structure for carrying out the subcomputations according to a particular sequencing. The operations include a first and a second operation, and the provided software program further specifies how the first and second operations are combined in the overall computation. For example, the first and second operations can each imply, respectively, a first and a second computational loop, the first loop including the subcomputations of the first operation, the second loop including the subcomputations of the second operation. A description of possible sequencings of subcomputations of the first and second operations is provided, to be used in implementing the specified combination of the first and second operations, the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "89\n", "authors": ["40"]}
{"title": "An architecture for an open compiler\n", "abstract": " This is a progress report on an experiment to build a compile-time metaobject protocol for Scheme. The compilation setting raises issues not present in runtime oriented MOP's, due to the complexity of the domain and the coupling between di erent parts. To address the complexity of the domain, we have developed a structure that decomposes the description of an implementation into a combination of many small, partially interacting, choices. To address the coupling, we have developed a decision making process that allows implementation choices to be made by a collaboration between user interventions and default decision making.", "num_citations": "77\n", "authors": ["40"]}
{"title": "Addressing practical software development issues in AspectJ with a pointcut interface\n", "abstract": " In this paper, we consider the problems of large-scale systems, team development, and maintenance in the context of AspectJ [3] programming. To our knowledge, these topics have not been discussed in any detail in other studies. We propose a new kind of interface between aspects and base code, explain how it is used by aspects, and then discuss the expected benefits in the context of realistic software development.", "num_citations": "71\n", "authors": ["40"]}
{"title": "Metaobject protocols: Why we want them and what else they can do\n", "abstract": " Originally conceived as a neat idea that could help solve problems in the design and implementation of CLOS, the metaobject protocol framework now appears to have applicability to a wide range of problems that come up in high-level languages. This chapter sketches this wider potential, by drawing an analogy to ordinary language design, by presenting some early design principles, and by presenting an overview of three new metaobject protcols we have designed that, respectively, control the semantics of Scheme, the compilation of Scheme, and the static parallelization of Scheme programs.", "num_citations": "71\n", "authors": ["40"]}
{"title": "Avoiding confusion in metacircularity: The meta-helix\n", "abstract": " A system with a metaobject protocol (MOP) allows programmers to extend it and then use the extended system as naturally as the original non-extended one. Such metaobject protocols often use a metacircular architecture to make the extensions easier to write. Unfortunately, this use of metacircularity can lead to problems stemming from a conflation of the extended and non-extended functionalities. We present a new architecture, called the meta-helix, that preserves the advantages of metacircularity but also addresses the problems with conflation.", "num_citations": "63\n", "authors": ["40"]}
{"title": "Structuring operating system aspects: using AOP to improve OS structure modularity\n", "abstract": " A process generates a page fault by accessing an address in virtual memory (VM) that is not resident in physical memory. Page fault handling begins in the VM layer as a request for a page associated with a VM object. This request is then translated into a different representation\u0393\u00c7\u00f6a block associated with a file\u0393\u00c7\u00f6and processed by the file system (FFS). Finally, the request is passed to the disk system, where it is specified in terms of cylinders, heads, and sectors associated with the physical disk. The division of responsibilities among these layers is centered around the management of their respective representations of data.Applications associate an access behavior, typically normal or sequential, with each VM object. Prefetching uses this declared behavior to plan which pages to prefetch, and allocates physical memory pages according to this plan. Allocating pages involves VM-based synchronization, since the VM\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "61\n", "authors": ["40"]}
{"title": "The fun has just begun\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - The Fun Has Just Begun CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c4\u00ac\u00f4\u03c3\u00c5\u00fa\u00b5\u00d1\u00a1\u03c3\u00ef\u00d6\u03c0\u00fc\u00ab\u03c3\u00e5\u00ec\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa The Fun Has Just Begun KICZALES G. \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 KICZALES G. \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 Keynote Talk at International Conference on Aspect-Oriented Software Development (AOSD 2003) Keynote Talk at International Conference on Aspect-Oriented Software Development (AOSD 2003), 2003 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u03c4\u2561\u00e4\u03c0\u00fc\u2510\u03a6\u255b\u255d\u03c0\u00fc\u2510\u03c0\u00e9\u255c\u03c0\u00e2\u00f2\u03c0\u00e2\u00ea\u03c0\u00e9\u00aa\u03c0\u00e9\u00ba\u03c0\u00e9\u00f3\u0398\u00fb\u00ef\u03c4\u00d6\u2551\u00b5\u00e8\u00c7\u03a6\u00ed\u00f4\u2229\u255d\u00dc2.\u03c4\u2561\u00e4\u03c0\u00fc\u2510\u03a6\u255b\u255d\u03c0\u00fc\u2510\u03c0\u00e9\u255c\u03c0\u00e2\u00f2\u03c0\u00e2\u00ea\u03c0\u00e9\u00aa\u03c0\u00e9\u00ba\u03c0\u00e9\u00f3\u03c0\u00fc\u00ab \u03a6\u00bf\u00a1\u03a6\u00bf\u00ea\u03c0\u00e2\u00f3\u03c0\u00e2\u00e7\u03c0\u00e2\u00ac\u03c0\u00e2\u2502\u03c0\u00e9\u2591\u00b5\u00e8\u00c7\u03a6\u00ed\u00f4 \u0398\u2561\u00a3\u00b5\u20a7\u00f9\u03c3\u2591\u00dc\u0398\u00a5\u00fb \u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00e7\u00aa\u03c4\u00c9\u00e5 45(7), 682-689, 2004-07-15 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab17\u03a3\u2557\u2562 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab 7\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) 10013270593 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03a3\u255d\u00dc\u03a6\u00a1\u2591\u03a6\u2502\u00e7\u00b5\u00fb\u00d6 \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP\u03c0\u00fc\u00bd\u0393\u00c7\u00aa", "num_citations": "57\n", "authors": ["40"]}
{"title": "Aspect-oriented programming workshop report\n", "abstract": " Whereas it is generally acknowledged that code tangling reduces the quality of software and that aspect-oriented programming (AOP) is a means of addressing this problem, there is \u0393\u00c7\u00f6 as yet \u0393\u00c7\u00f6 no clear definition or characterisation of AOP. Therefore, the main goal of the ECOOP\u0393\u00c7\u00d697 AOP workshop was to identify the \u0393\u00c7\u00a3good questions\u0393\u00c7\u00a5 for exploring the idea of AOP.", "num_citations": "57\n", "authors": ["40"]}
{"title": "The common Lisp object system metaobject kernel: a status report\n", "abstract": " The metaobject kernel of the Common Lisp Object System (CLOS) comprises the classes and methods that define and implement the behavior of the system. Since CLOS is an object-oriented program itself, exposing this kernel allows people to make useful integrated extensions to CLOS without changing the behavior of the system for ordinary programs, and without unwarranted loss of efficiency. This paper is organized around the classes used to implement CLOS, describing reasons for the class organization chosen, and how these classes participate in some protocols of the system.", "num_citations": "47\n", "authors": ["40"]}
{"title": "Operating systems: why object-oriented?\n", "abstract": " The implementor of an operating system service faces inherent dilemmas in choosing implementation strategies. A new approach to operating system design is emerging in which, rather than attempting to hide these dilemmas, they are exposed to clients, using a meta-protocols. Object-oriented programming techniques play an important role in enabling meta-protocols to expose these dilemmas to the client in a principled and modular fashion.< >", "num_citations": "46\n", "authors": ["40"]}
{"title": "The need for customizable operating systems\n", "abstract": " Although modern operating systems provide powerful abstractions to application programs, they often fail to implement those abstractions in a way that provides applications programs, especially specialized application programs, with the best utilization of the physical resources of the computer system. The operating system community has implicitly recognized this problem by providing mechanisms that give client programmers more access to the physical substrate. The Mach External Pager allows clients to replace the paging mechanism. More recent work allows client replacement of the paging policy as well. Scheduler activations share the job of thread management between clients and the system. Apertos allows these and other aspects of operating system implementation to be client-controlled. Object-oriented operating systems under development also provide these kinds of control. We contend that there is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "45\n", "authors": ["40"]}
{"title": "Integrated development environment for aspect-oriented programming\n", "abstract": " A set of development tools is provided as part of an integrated development environment for supporting aspect-oriented programming such that aspects may easily be defined for embodying functionality which cross-cuts main program functionality in such a way that aspects transparently force their behavior on the main program. The editor and debugger of the integrated development environment embody functionality for accommodating this transparency.", "num_citations": "42\n", "authors": ["40"]}
{"title": "Aspect-oriented programming\n", "abstract": " Aspect-oriented programming is a promising idea that can improve the quality of software by reduce the problem of code tangling and improving the separation of concerns. At ECOOP\u0393\u00c7\u00d697, the first AOP workshop brought together a number of researchers interested in aspectorientation. At ECOOP\u0393\u00c7\u00d698, during the second AOP workshop the participants reported on progress in some research topics and raised more issues that were further discussed. This year, the ideas and concepts of AOP have been spread and adopted more widely, and, accordingly, the workshop received many submissions covering areas from design and application of aspects to design and implementation of aspect languages.", "num_citations": "42\n", "authors": ["40"]}
{"title": "Open implementation analysis and design\n", "abstract": " This paper describes a methodology for designing Open Implementations--software modules that can adapt or change their internals to accommodate the needs of different clients. Analysis techniques are used for capturing domain knowledge, user requirements, and domain properties that influence the module\u0393\u00c7\u00d6s eventual implementation. Design techniques are used for determining and refining the interfaces by which clients control the modules implementation strategies. The methodology has evolved over the past two years in several pilot projects.", "num_citations": "36\n", "authors": ["40"]}
{"title": "Open implementations and metaobject protocols\n", "abstract": " Open Implementations and Metaobject Protocols | Guide books ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksOpen Implementations and Metaobject Protocols ABSTRACT No abstract available. Index Terms 1.Open Implementations and Metaobject Protocols 1.General and reference 1.Document types 1.Reference works 2.Software and its engineering 1.Software notations and tools 1.General programming languages 1.Language types 1.Object oriented languages Comments Login options Check if you have access through your login credentials or your institution to get full access on this article. Sign in Full Access Get this in :: \u0393\u00c7\u00aa", "num_citations": "36\n", "authors": ["40"]}
{"title": "Aspect-oriented system monitoring and tracing\n", "abstract": " An aspect oriented system for implementing system monitoring and tracing is provided in which the monitoring and tracing functionality needs not be coded into the resources being monitored or traced. Rather, an aspect is provided which encapsulates the monitoring/tracing behavior. This behavior may easily and transparently be forced onto the resource by compiling the object class for the resource along with the monitoring/tracing aspect. When the monitoring/tracing is no longer needed, it is removed simply by recompiling the resource object classes without the aspect.", "num_citations": "34\n", "authors": ["40"]}
{"title": "Expressive programs through presentation extension\n", "abstract": " Most approaches to programming language extensibility have worked by pairing syntactic extension with semantic extension. We present an approach that works through a combination of presentation extension and semantic extension. We also present an architecture for this approach, an Eclipse-based implementation targeting the Java programming language, and examples that show how presentation extension, both with and without semantic extension, can make programs more expressive.", "num_citations": "32\n", "authors": ["40"]}
{"title": "Aspect-oriented programming: The fun has just begun\n", "abstract": " We are on the verge of a fundamental change in software development. A central idea in all science and engineering\u0393\u00c7\u00f4the idea of working with a system through multiple perspectives or views\u0393\u00c7\u00f4is being enabled in software development in a powerful new way. In the past, software developers have had good technology for programming at different levels of abstraction or, in other words, working with views at different levels of detail. But more recently we have learned how to program through different crosscutting views. The immediate impact of this change has been to make it possible to modularize aspects of a system\u0393\u00c7\u00d6s implementation that previously could not be modularized. This is leading to software that is significantly more flexible, adaptable, and in all likelihood more robust than what we could previously develop.But the fun has just begun. Within the framework of current AOP proposals we can see significant room for further improvement and power. Experience with AOP is leading developers and researchers to ask for and develop exciting new features. But we can also see signs of a next generation of AOP technology, that we call fluid AOP. Fluid AOP involves the ability to temporarily shift a program (or other software model) to a different structure to do some piece of work with it, and then shift it back. This is analogous to electrical engineers using the Fourier transform to make certain problems easier to solve.", "num_citations": "31\n", "authors": ["40"]}
{"title": "Fluid aop join point models\n", "abstract": " Aspect-oriented programming (AOP) allows programmers to modularize the implementation of crosscutting concerns. AspectJ and related languages achieve this with a linguistic approach, which enables different modules of the program to have a crosscutting structural relationship. In fluid AOP the development environment temporarily shifts a program to an alternative crosscutting module structure to enable specific editing or reasoning tasks. The program text can appear to have different crosscutting modularities simultaneously, as opposed to just having modules that crosscut each other. In this demonstration we show three possible fluid AOP designs, and compare their look and feel using common examples.", "num_citations": "29\n", "authors": ["40"]}
{"title": "Traces (a cut at the \u0393\u00c7\u00a3make isn't generic\u0393\u00c7\u00a5 problem)\n", "abstract": " Object-oriented techniques are a powerful tool for making a system end-programmer specializable. But, in cases where the system not only accepts objects as input, but also creates objects internally, specialization has been more difficult. This has been referred to as the \u0393\u00c7\u00a3make isn't generic problem.\u0393\u00c7\u00a5 We present a new object-oriented language concept, called traces, that we have used successfully to support specialization in cases that were previously cumbersome.             The concept of traces makes a fundamental separation between two kinds of inheritance in object-oriented languages: inheritance of default implementation \u0393\u00c7\u00f6 an aspect of code sharing; and inheritance of specialization, a sometimes static, sometimes dynamic phenomena.", "num_citations": "27\n", "authors": ["40"]}
{"title": "A new model of abstraction for operating system design\n", "abstract": " This historical basis of operating systems work has been the concept of black-box abstraction. But this traditional notion of abstraction fails to support emerging practice in the operating system community where, more and more, one seems to want to give clients access to previously internal aspects of the implementation. The authors present a new model of abstraction, dual-abstraction, and show how to think about existing work under that model. They also discuss some issues for future work that the new model makes evident.< >", "num_citations": "27\n", "authors": ["40"]}
{"title": "A semantics for advice and dynamic join points in aspect-oriented programming\n", "abstract": " A characteristic of aspect-oriented programming, as embodied in AspectJ, is the use of advice to incrementally modify the behavior of a program. An advice declaration specifies an action to be taken whenever some condition arises during the execution of the program. The condition is specified by a formula called a pointcut designator or pcd. The events during execution at which advice may be triggered are called join points. In this model of aspect-oriented programming, join points are dynamic in that they refer to events during the execution of the program. We give a denotational semantics for a minilanguage that embodies the key features of dynamic join points, pointcut designators, and advice. This is the first semantics for aspect-oriented programming that handles dynamic join points and recursive procedures. It is intended as a baseline semantics against which future correctness results may be measured.", "num_citations": "24\n", "authors": ["40"]}
{"title": "Aspect-Oriented Programming with AspectJ\u0393\u00e4\u00f3\n", "abstract": " /**==================================================================** The Apache Software License, Version 1.1* Copyright (c) 1999 The Apache Software Foundation. All rights* reserved.** Redistribution and use in source and binary forms, with or without* modification, are permitted provided that the following conditons* are met:** 1. Redistributions of source code must retain the above copyright* notice, this list of conditions and the following disclaimer.** 2. Redistributions in binary form must reproduce the above copyright* notice, this list of conditions and the following disclaimer in* the documentation and/or other materials provided with the* distribution.** 3. The end-user documentation included with the redistribution, if* any, must include the following acknowlegement:*\" This product includes software developed by the* Apache Software Foundation (http://www. apache. org/).\"* Alternately, thisacknowlegementmay appear in the software itself,* if and wherever such third-partyacknowlegementsnormally appear.** 4. The names\" The Jakarta Project\",\" Tomcat\", and\" Apache Software* Foundation\" must not be used to endorse or promote products derived* from this software without prior written permission. For written* permission, please contact apache@ apache. org.** 5. Products derived from this software may not be called\" Apache\"* nor may\" Apache\" appear in their names without prior written* permission of the Apache Group.** THIS SOFTWARE IS PROVIDED``AS IS''AND ANY EXPRESSED OR IMPLIED* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES", "num_citations": "23\n", "authors": ["40"]}
{"title": "Issues in the pragmatics of qualitative modeling: Lessons learned from a xerographics project\n", "abstract": " The photocopier is one of the most complex machines because xerography involves many types of physical phenomena. ARIA is a qualitative simulation of xerography that is intended to teach technicians the reasons behind some of the subtle problems that occur in copiers. This effort to model xerography exposed shortcomings in the techniques of qualitative modeling as applied to complex systems and helped to better understand the impact of certain basic modeling decisions.", "num_citations": "22\n", "authors": ["40"]}
{"title": "Registration-based language abstractions\n", "abstract": " Programming language innovation has been hindered by the difficulty of making changes to existing languages. A key source of difficulty is the tyrannical nature of existing approaches to realizing languages -- adding a new language construct means that any tool, document or programmer that works with the language must be prepared to deal with that construct. A registration-based approach makes it possible to define language constructs that are not tyrannical. They are instead transient -- the program appears to be written using the constructs only so long as a given programmer wants to see it that way. This approach may have the potential to greatly facilitate programming language innovation.", "num_citations": "20\n", "authors": ["40"]}
{"title": "Uniform support for modeling crosscutting structure\n", "abstract": " We propose bottom-up support for modeling crosscutting structure in UML by adding a simple join point model to the meta-model. This supports built-in crosscutting modeling constructs such as sequence diagrams. It also facilitates adding new kinds of crosscutting modeling constructs such as role bindings, inter-type declarations, and advice. A simple weaver produces a uniform representation of the crosscutting structure, which can then be displayed or analyzed in a variety of ways.", "num_citations": "20\n", "authors": ["40"]}
{"title": "Semantics-based crosscutting in AspectJ\n", "abstract": " A central issue in aspect-oriented programming is the design of mechanisms for specifying the crosscutting. Early systems used explicit enumeration of names of messages or methods [\u0393\u00c7\u00aa]. Recent versions of AspectJ go beyond this by allowing a crosscut to be described based on semantic properties of the operations involved. We intend for future versions of AspectJ to go even farther in this direction. In this short paper we describe the full range of crosscut specification mechanisms we currently plan. The paper is intended to serve as a foundation for discussion of this important issue.", "num_citations": "20\n", "authors": ["40"]}
{"title": "Exploring an Aspect-Oriented approach to OS code\n", "abstract": " Operating system code is complex. But, while substantial complexity is inherent to this domain, we believe that other complexity is caused by modularity problems. In this paper, we explore aspect-oriented programming as a means of making this kind of complexity unnecessary. We show that simple linguistic constructs can be used to modularize prefetching\u0393\u00c7\u00f4an aspect of the system that is otherwise unclear because its implementation is spread out in the code.", "num_citations": "19\n", "authors": ["40"]}
{"title": "AspectJ (tm): Aspect-oriented programming in Java\n", "abstract": " Aspect-oriented programming (AOP) gives software developers a powerful new tool for structuring the design and code of software systems. AOP simplifies development of system aspects that previously were among the most difficult to handle, including failure handling strategies, synchronization policies, change propagation, security checking, distribution, policy enforcement and many others. AOP using AspectJ makes it possible to describe, in just one place in the system, the implementation of such crosscutting aspects. This reduces development time, improves software quality, and makes software more flexible. This talk will show what it is like to design and implement with AspectJ, and what implications this has for software developers in terms of time-to-market, software quality, and product flexibility. For more info about AOP and AspectJ go to http://aspectj.org/servlets/AJSite.", "num_citations": "18\n", "authors": ["40"]}
{"title": "Illustrations of crosscutting\n", "abstract": " Crosscutting poses some challenges in terms of clean separation of concerns. Aspect-oriented programming [2] is intended to address those challenges. This position paper presents a couple of examples of situations that involve crosscutting. The first example illustrates some basic crosscutting that all technologies for advanced separation of concerns should be able to handle gracefully. We show how this example is handled using AspectJ\u0393\u00e4\u00f3 0.6 [1]. The second example shows a more complex crosscutting situation, and we present how it might be handled in a future version of AspectJ.", "num_citations": "18\n", "authors": ["40"]}
{"title": "Exploring an aspect-oriented approach to operating system code\n", "abstract": " This paper presents the initial results of our experiment using an aspect-oriented approach to simplify operating system code. The intuition behind this work is that complexity comes from crosscutting concerns. In this experiment, we re-implemented prefetching for page fault handling and file system read requests using a hypothetical language, AspectC\u0393\u00c7\u00f4a variant of AspectJ for C\u0393\u00c7\u00f4and hand-compiled the code to C. We believe that the aspect-oriented code is easier to understand, and in particular that it is easier to understand the interaction between the virtual memory and file system prefetching mechanisms.", "num_citations": "17\n", "authors": ["40"]}
{"title": "Aspect-oriented programming workshop report\n", "abstract": " Vrije Universiteit Brussel, Department of Computer Science, Programming Technology Lab, Pleinlaan 2, B-1050 Brussel, Belgium Xerox PARC, Systems and Practices Laboratory, 3333 Coyote Hill Rd, Palo Alto, CA 94304, USA University of Twente,", "num_citations": "15\n", "authors": ["40"]}
{"title": "Brittle systems will break-not bend: can aspect-oriented programming help?\n", "abstract": " As OS code moves to new settings, it must be continually reshaped. Kernel code however, is notoriously brittle--a small, seemingly localized change can break disparate parts of the system simultaneously. The problem is that the implementation of some system concerns are not modular because they naturally crosscut the system structure. Aspect-oriented programming proposes new mechanisms to enable the modular implementation of cross-cutting concerns. This paper evaluates aspect-oriented programming in the context of two crosscutting concerns in a FreeBSD 4.4 kernel--page daemon activation and disk quotas. The ways in which aspects allowed us to make these implementations modular, the impact they have on comprehensibility and configurability, and the costs associated with supporting a prototype of an aspect-oriented runtime environment are presented.", "num_citations": "14\n", "authors": ["40"]}
{"title": "Software constructs that facilitate partial evaluation of source code\n", "abstract": " A partial evaluator, or pre-compiler, for a computer program enables a user to provide, at suitable places within a program, language constructs which cause certain expressions within the program to be evaluated at runtime or at partial evaluation time. These language constructs can be used to shorten runtime, such as by avoiding unnecessary duplication of code at runtime.", "num_citations": "14\n", "authors": ["40"]}
{"title": "Lightweight virtual machine support for AspectJ\n", "abstract": " Advice weaving can be efficiently supported with only lightweight enhancements to existing Virtual Machines. Performing weaving at the Java bytecode (JBC) level while preserving appropriate metadata enables the VM to understand the AspectJ-specific semantics of the code and optimize it. This allows the overhead of advice weaving and performing non-local advice dispatch optimization to occur prior to runtime. It also allows the VM to perform optimizations that are unavailable to a bytecode level weaver.", "num_citations": "13\n", "authors": ["40"]}
{"title": "Aspect-oriented and component-based software engineering\n", "abstract": " Aspect-oriented softwarc engineering and componentbased software engineering are finding increasing interest among both researchers and practitioners. The inception and adoption of these new technologics has becn led by the drive to improve productivity, quality and rcusability and reducc maintenance overheads, impact of customisations or extensions and thc timc to market. Aspectoriented software engincering employs special abstractions known as aspects to separate crosscutting concerns throughout the software life cycle. Crosscutting concerns are features which cannot otherwise be cleanly encapsulated in one development artifact and are tangled over several artifacts. Special composition rules combine the aspects with artifacts (crosscut by features encapsulated by the aspccts) with respect to reference points in the artifacts. These referencc points are termed as, join points. Separation of crosscutting\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["40"]}
{"title": "Can AOP support extensibility in client-server architectures\n", "abstract": " Extensible client-server software requires a clear separation of core services from those that are customizable. This separation is difficult, as these customizable features tend to crosscut the primary functionality of the core services. We believe that an aspect-oriented approach to client-server architectures supports extensibility in a way that is more flexible than traditional approaches. Our experiment focuses on clients within a distributed file system that dynamically negotiate with servers for adaptive delayed-write and prefetching behaviour.", "num_citations": "13\n", "authors": ["40"]}
{"title": "A modeling framework for aspect-oriented mechanisms\n", "abstract": " A single framework can be used to model the core semantics of five aspect-oriented software development technologies. The framework models a weaving process in terms of nine key properties having to do with the languages of the input programs and the output of the weaver.Two key properties of the framework enable it to model all five mechanisms. First is that it models weaving in semantic terms, rather than simply as a source code pre-processor. Second is that it models crosscutting as a three-part relation\u0393\u00c7\u00f4two programs are said to crosscut each other with respect to a computation (or woven program) if certain conditions hold. This contrasts with descriptions of crosscutting as being solely between two programs or concerns.", "num_citations": "12\n", "authors": ["40"]}
{"title": "A machine code model for efficient advice dispatch\n", "abstract": " The primary implementations of AspectJ to date are based on a compile-or load-time weaving process that produces Java byte code. Although this implementation strategy has been crucial to the adoption of AspectJ, it faces inherent performance constraints that stem from a mismatch between Java byte code and AspectJ semantics. We discuss these mismatches and show their performance impact on advice dispatch, and we present a machine code model that can be targeted by virtual machine JIT compilers to alleviate this inefficiency. We also present an implementation based on the Jikes RVM which targets this machine code model. Performance evaluation with a set of micro benchmarks shows that our machine code model provides improved performance over translation of advice dispatch to Java byte code.", "num_citations": "11\n", "authors": ["40"]}
{"title": "What a metaobject protocol based compiler can do for lisp\n", "abstract": " A new kind of metaobject protocol, that controls the compilation of programs, allows users to participate in the compilation in a principled and modular way. Such a compiler makes it possible to program in a high-level language and still maintain control over crucial implementation issues. This result is that a number of simple and elegant Scheme programs can be compiled as efficiently as if they had been written with special purpose primitives.", "num_citations": "11\n", "authors": ["40"]}
{"title": "The scalability of AspectJ\n", "abstract": " To assess the scalability of AspectJ, we refactored concerns that crosscut over half of the plug-ins that comprise the Eclipse IDE. Eclipse is a suitable candidate for furthering other scalability studies of AspectJ because it is not only large, but also has an additional modularization mechanism typical of large systems that introduces new complexities for defining advice and aspects. We evaluated our AO refactored system quantitatively by examining changes in execution time and memory usage, as well as qualitatively by examining changes in scattering, coupling, and abstractions. We conclude that AspectJ scales well in that it can be used in large systems, but that the system may require modifications to the build and class loading procedures in order to cope with defining advice that cross system boundaries.", "num_citations": "10\n", "authors": ["40"]}
{"title": "E cient method dispatch in PCL\n", "abstract": " Efficient implementation of CLOS is critical to its success as a standard. Some excellent work on Lisp Machines [3, 7] has demonstrated clearly that CLOS can be implemented efficiently using special-purpose hardware.We describe a mechanism for implementing CLOS method dispatch efficiently on stock hardware, in the current generation of Common Lisp implementations. This mechanism is implemented in the newest version of PCL, a portable implementation of CLOS, and runs in more than ten Common Lisps. 1", "num_citations": "10\n", "authors": ["40"]}
{"title": "Aspect-Oriented Programming with Aspectj.\n", "abstract": " /**====================================================================** The Apache Software License, Version 1.1** Copyright (c) 1999 The Apache Software Foundation. All rights* reserved.** Redistribution and use in source and binary forms, with or without* modification, are permitted provided that the following conditions* are met:** 1. Redistributions of source code must retain the above copyright* notice, this list of conditions and the following disclaimer.** 2. Redistributions in binary form must reproduce the above copyright* notice, this list of conditions and the following disclaimer in* the documentation and/or other materials provided with the* distribution.** 3. The end-user documentation included with the redistribution, if* any, must include the following acknowlegement:*\" This product includes software developed by the* Apache Software Foundation (http://www. apache. org/).\"* Alternately, this acknowlegement may appear in the software itself,* if and wherever such third-party acknowlegements normally appear.** 4. The names\" The Jakarta Project\",\" Tomcat\", and\" Apache Software* Foundation\" must not be used to endorse or promote products derived* from this software without prior written permission. For written* permission, please contact apache@ apache. org.** 5. Products derived from this software may not be called\" Apache\"* nor may\" Apache\" appear in their names without prior written* permission of the Apache Group.** THIS SOFTWARE IS PROVIDED``AS IS''AND ANY EXPRESSED OR IMPLIED* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES* OF MERCHANTABILITY\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["40"]}
{"title": "Retroactive aspects: programming in the past\n", "abstract": " We present a novel approach to the problem of dynamic program analysis: writing analysis code directly into the program source, but evaluating it against a recording of the original program's execution. This approach allows developers to reason about their program in the familiar context of its actual source, and take full advantage of program semantics, data structures, and library functionality for understanding execution. It also gives them the advantage of hindsight, letting them easily analyze unexpected behavior after it has occurred. Our position is that writing offline analysis as retroactive aspects provides a unifying approach that developers will find natural and powerful.", "num_citations": "8\n", "authors": ["40"]}
{"title": "Coding issues in AspectJ\n", "abstract": " AOP [1] has been proposed as a way to write programs that elegantly implement crosscutting concerns. This paper presents initial results of an exploration into whether this is true for AspectJ [2]. During this this exploration we have written several small and medium scale systems using AspectJ.", "num_citations": "8\n", "authors": ["40"]}
{"title": "Using AspectJ for programming the detection and handling of exceptions\n", "abstract": " We took an existing framework written in Java\u0393\u00e4\u00f3, the JWAM framework, and partially reengineered some of its exception detection and handling aspects using AspectJ\u0393\u00e4\u00f3, an aspect-oriented programming extension to Java. The results of this reengineering project are reported in [5].", "num_citations": "8\n", "authors": ["40"]}
{"title": "Hilsdale\n", "abstract": " Concern about the risk of adopting new tech-nology causes many organizations to be reluc-tant to do so. But simply waiting can lead to rushing to adopt the technology later, which is itself risky. Instead, this article presents a staged approach based on identifying two broad categories of aspects: development aspects facilitate tasks such as debugging, testing, and performance tuning of applications; production aspects implement functionality intended to be included in shipping applications. These categories are informal, and this ordering is not the only way to adopt AspectJ. Some developers will want to use a production aspect right away, but experience with current AspectJ users has shown this ordering allows developers to derive benefits from AOP technology quickly, while also minimizing risk.", "num_citations": "7\n", "authors": ["40"]}
{"title": "Aspect-oriented incremental customization of middleware services\n", "abstract": " As distributed applications evolve, incremental customization of middleware services is often required; these customizations should be unpluggable, modular, and efficient. This is difficult to achieve because the customizations depend on both application-specific needs and the services provided. Although middleware allows programmers to separate application-specific functionality from lower-level details, traditional methods of customization do not allow efficient modularization.Currently, making even minor changes to customize middleware is complicated by the lack of locality. Programmers may have to compromise between the two extremes: to interpose a simple, well-localized layer of functionality between the application and middleware, or to make a large number of small, poorly localized, invasive changes to all execution points which interact with middleware services. Although the invasive approach allows a more efficient customization, it is harder to ensure consistency, more tedious to implement, and exceedingly difficult to unplug. Thus, a common approach is to add an extra layer for systemic concerns such as robustness, caching, filtering, and security. Aspect-oriented programming (AOP) offers a potential alternative between the interposition and invasive approaches by providing modular support for the implementation of crosscutting concerns. AOP enables the implementation of efficient customizations in a structured and unpluggable manner. We demonstrate this approach by comparing traditional and AOP customizations of fault tolerance in a distributed file system model, JNFS. Our results show that using AOP can reduce the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "7\n", "authors": ["40"]}
{"title": "Separation of concerns and operating systems for highly heterogeneous distributed computing\n", "abstract": " Highly heterogeneous distributed computing applications present a tremendous challenge for operating system implementors. These applications present an extremely wide range of demands and must run in an extremely wide range of environments. In order to recognize the wide range of environments, without losing the benefits of traditional modularity, we propose a separation of concerns approach to the design of operating systems for this domain. In this paper, we first discuss importance of separation of concerns particularly in highly heterogeneous distributed computing. The discussion is based on the issues we encounter when programming of distributed applications such as for networked copiers, settop boxes for cablenets, networked analyzers/oscilloscopes, or palmtop computers. We then propose a way to solve them without sacrifice of performance. This paper contributes to this workshop in the sense\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "7\n", "authors": ["40"]}
{"title": "Late binding of AspectJ advice\n", "abstract": " The non-local nature of advice applicability in AspectJ means that in many implementations small changes to aspects can require much of the program code to be scanned and possibly rewritten. This can slow down application startup, including the edit-compile-debug development cycle.             Late binding of advice has been suggested to improve the situation, at the potential cost of runtime performance. We propose and evaluate two virtual machine (VM) internal late binding approaches, that operate at whole-class and whole-method granularity.             Our evaluation shows that in VMs that allow bytecode mutation the preferred approach is to scan and rewrite methods the first time they are executed. In other VMs, whole-class scanning and rewriting at load time performs better. A separate interpreter based approach has startup performance similar to that of the whole-class approach; but micro\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["40"]}
{"title": "Apostle: A simple incremental weaver for a dynamic aspect language\n", "abstract": " This paper describes the incremental weaving implementation of Apostle, an aspect-oriented language extension to Smalltalk modelled on AspectJ. Apostle implements incremental weaving in order to make aspect-oriented programming (AOP) a natural extension of the incremental edit-run-debug cycle of Smalltalk environments. The paper analyzes build dependencies for aspect declarations, and shows that two simple dependency table structures are sufficient to produce reasonable re-weaving efficiency. The resulting incremental weaver provides re-weaving performance proportional to the change in the program.", "num_citations": "6\n", "authors": ["40"]}
{"title": "Structuring system aspects\n", "abstract": " Key elements of operating systems are crosscutting\u0393\u00c7\u00f4their implementation is necessarily spread across several core components of the system. Prefetching, for example, is a critical architectural performance optimization that amortizes the cost of going to disk by predicting and retrieving additional data with each explicit disk request. The implementation of prefetching, however, is tightly coupled with both highlevel context of the original request and low-level costs of additional retrieval. As a result, small clusters of customized prefetching code appear at both high and low levels along most execution paths that involve going to disk. This makes prefetching difficult to reason about and change, and interferes with the clarity of the primary functionality within which prefetching is embedded.Aspect-oriented programming (AOP) provides a means of tackling some of the well-known modularity problems operating systems face when implemented with procedural and OO programming alone. This paper presents the use of AOP in structuring the implementation of a subset of prefetching in the FreeBSD v3. 3 operating system.", "num_citations": "6\n", "authors": ["40"]}
{"title": "Aspect-oriented system structure\n", "abstract": " Operating system structure is important; it leads to understandable, maintainable, 'pluggable' code. But despite our best efforts, some system elements have been difficult to structure. We propose a new analysis of this problem, and a new technology that can structure these elements. Aspect-oriented programming (AOP) (G. Kiczales et al., 1997) uses linguistic mechanisms to support the separation of crosscutting elements, or aspects of the system, from primary functionality. We have developed a proof-of-concept AOP implementation of prefetching in FreeBSD (www.cs.ubc.ca/labs/spl/aspects/aspectc.html). In our implementation, we have been able to modularize prefetching.", "num_citations": "6\n", "authors": ["40"]}
{"title": "Aspectj: the language and support tools\n", "abstract": " Complex systems usually contain design units that are logically related to several objects in the system. Some examples include: tracing, propagation of interrupts, multi-object protocols, security enforcement etc. This crosscutting between those design units and the objects is a natural phenomenon. But, using traditional implementation techniques, the source code\u0393\u00c7\u00f6ie the classes\u0393\u00c7\u00f6becomes tangled with the implementation of the crosscutting concerns.", "num_citations": "6\n", "authors": ["40"]}
{"title": "Interacting with dead objects\n", "abstract": " Debugging and analyzing a snapshot of a crashed program's memory is far more difficult than working with a live program, because debuggers can no longer execute code to help make sense of the program state. We present an architecture that supports the restricted execution of ordinary code starting from the snapshot, as if the dead objects within it had been restored, but without access to their original external environment. We demonstrate the feasibility of this approach via an implementation for Java that does not require a custom virtual machine, show that it performs competitively with live execution, and use it to diagnose an unresolved memory leak in a mature mainstream application.", "num_citations": "5\n", "authors": ["40"]}
{"title": "Understanding registration-based abstractions: A quantitative user study\n", "abstract": " The adoption of programming language innovation is impeded because all program processing tools in the tool chain must support any new or altered language features. Registration-based abstractions (RBAs) were proposed to address this difficulty by allowing the editor to transiently superimpose new language abstractions on existing code. Individual programmers can choose where and when to see a new language abstraction, while at all times the underlying code remains written in the original language. Prior work demonstrated the feasibility of RBAs, but left important questions unanswered regarding how users would interact with such an approach. We asked 50 undergraduate students to answer basic program comprehension questions with and without RBAs. Our results show that participants can quickly and easily understand new abstractions without additional training, and suggest that this will extend\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["40"]}
{"title": "A simple edit-time metaobject protocol\n", "abstract": " We present a simple edit-time metaobject protocol (ETMOP) which runs as part of a code editor and enables metadata annotations to customize the rendering and editing of code. The protocol is layered, so that simple render/edit customizations are easy to implement, while more substantial customizations are still manageable.Experiments with a prototype implementation of the protocol as an Eclipse plug-in show that the ETMOP is flexible enough to allow easy customization of the rendering and editing of a number of annotations being used in current practice. The flexibility and performance of the prototype suggest that the ETMOP approach is viable and warrants further study.", "num_citations": "5\n", "authors": ["40"]}
{"title": "A simple edit-time metaobject protocol: controlling the display of metadata in programs\n", "abstract": " I will present a prototype tool that enables Java annotations to serve as an extension point for making programs more visually expressive. Thus, programmers can view and edit code in a way that more closely resembles the intention of the code, rather than the raw text. Examples that we have applied the tool to are JDBC 4.0, getters, setters and constraints, JSR 181Webservices, AspectJ, and state charts.", "num_citations": "4\n", "authors": ["40"]}
{"title": "Improving design and source code modularity using AspectJ (tutorial session)\n", "abstract": " Using only traditional techniques the implementation of concerns like exception handling, multi-object protocols, synchronization constraints, and security policies tends to be spread out in the code. The lack of modularity for these concerns makes them more difficult to develop and maintain. This tutorial shows how to use Aspect-oriented programming (AOP)[2, 3] to implement concerns like these in a concise modular way. We discuss the effect aspects have on software design and on code modularity. The concrete examples in the tutorial use AspectJ [1], a freely available aspect-oriented extension to the Java\u0393\u00e4\u00f3 programming language.", "num_citations": "4\n", "authors": ["40"]}
{"title": "Compilation Strategies as Objects\n", "abstract": " In this paper we present an overview of the metaobject protocol approach to compilation. We take the position that object orientation in a compiler can be put to effective use in opening up the compiler for modification by the user. Interestingly, the natural scopes of effect of user intervention don't respect syntactic boundaries, so we require objects that are not just elements of the abstract syntax tree. We introduce a new kind of intermediate object for the process of compilation so that user modification of compilation strategies can be carried out in a coherent manner. We give some examples of user customizations, and outline the architecture of our Scheme compiler based on these principles.", "num_citations": "4\n", "authors": ["40"]}
{"title": "we must keep going i guess\n", "abstract": " Common lisp object system specification.\" The Common Lisp Object System can be described at three levels. These levels are a set of mutually supporting facilities for use at different levels of sophistication. The first level, the programmer\u0393\u00c7\u00d6s interface, provides a convenient syntax for defining classes and methods, which is all most users need to know to construct object oriented programs in Common Lisp. The second level consists of the description of the functions that underlie the basic facilities. At this level, there is a complete separation of objects and names, with all basic operations applicable to strictly anonymous objects. This level is useful for programmers who wish to provide an alternative interface to the facilities or who are building program development environments.The third level, the Common Lisp Object System kernel (CLOS kernel), describes CLOS as an object oriented program. The Common Lisp Object System kernel comprises those classes, methods and generic functions which implement the Common Lisp Object System system described in chapters 1 and 2. The kernel classes define the data structures used, and the generic functions and methods define the basic operations of the kernel, as specialized to those kernel classes. We liken this level of description to the description of Lisp or Scheme using a metacircular interpreter written in the language. To understand the behavior requires understanding the language. The metacircular interpreter thus provides a kind of intellectual bootstrap. Because these generic functions, classes and instances comprise the metacircular interpreter, we refer to them collectively as the metaobjects of CLOS. The metaobject protocol\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["40"]}
{"title": "Aspects and/versus modularity the grand debate\n", "abstract": " Aspect-Oriented Programming (AOP) and Aspect-Oriented Software Development (AOSD) endeavor to aid programmers in the separation of concerns, specifically crosscutting concerns, as an advance in modularization. AOP does so using primarily language changes, while AOSD uses a combination of language, environment, and methodology. But the concepts of obliviousness-not universally accepted as part of AOP-and parameterization appear to contradict the well-established principles of modularity and encapsulation that David Parnas and other greats of the past laid out and on which software engineering has depended for the last 40 years. Are we moving forward with better understandings of software engineering, modularity, and design/development principles, or are we losing our way? This debate is the postscript to Friedrich Steinmann's OOPSLA Essay,\" The Paradoxical Success of Aspect-Oriented\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["40"]}
{"title": "Aspects: passing fad or new foundation?\n", "abstract": " Aspect-oriented software development (AOSD) has a lot of interest in the research community. It has also found early adopters in application development and middleware. This panel discusses the potential expansion and use of AOP into mainstream software development. This question is not just directed to the aspect research community, but also to practicing software development teams and organizations. The panel will explore the appropriate position and awareness of aspect-orientation amidst other advances in software engineering; how to prepare organizations for adoption; and what additional research and development is necessary. The panel discussion will help the OO community to understand the appropriate use of aspect-orientation. It will also highlight areas where additional efforts by AOSD researchers and professionals are required.", "num_citations": "3\n", "authors": ["40"]}
{"title": "Report on An Overview of Aspectj\n", "abstract": " AspectJ is an aspect-oriented extension to JAVA program language. It enables a different way to further and cleaner modularize all concerns of interest in a complex systems comparing with the object-oriented mechanism. The AOP approach has a number of benefits. First, it improves performance because the operations are more succinct. Second, it allows programmer to spend less time rewriting the same code. Overall, AOP enables better encapsulation of distinct procedures and promotes future interoperation. The current design and implementation of AspectJ is upward compatible, platform compatible, tool compatible and programmer compatible. All these compatibilities let AspectJ could work with the current JAVA platform without any modification to the JVM. Also it could be seamlessly integrated into existing JAVA tools, such as JBuilder, Ant Builder, and Eclipse, etc.", "num_citations": "3\n", "authors": ["40"]}
{"title": "\u2568\u00c9\u2564\u00fc\u2568\u2510\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2561 \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561\n", "abstract": " \u2568\u2510\u2564\u00c7\u2568\u2561\u2568\u2524\u2564\u00fc\u2564\u00e9\u2568\u2591\u2568\u2593\u2568\u2557\u2564\u00c5\u2568\u2561\u2568\u255d \u2568\u2591\u2568\u255c\u2568\u2591\u2568\u2557\u2568\u2555\u2568\u2556 \u2564\u00e9\u2568\u2591\u2568\u2551\u2568\u2555\u2564\u00e0 \u2564\u00e0\u2568\u2591\u2564\u00c7\u2568\u2591\u2568\u2551\u2564\u00e9\u2568\u2561\u2564\u00c7\u2568\u2555\u2564\u00fc\u2564\u00e9\u2568\u2555\u2568\u2551 \u2568\u2555 \u2568\u255c\u2568\u2591\u2568\u2556\u2564\u00ef\u2568\u2593\u2568\u2591\u2568\u2561\u2568\u255d \u2564\u00fc\u2568\u2593\u2568\u255b\u2568\u2563\u2564\u00fc\u2564\u00e9\u2568\u2593\u2568\u2591, \u2568\u2591\u2568\u2524\u2564\u00c7\u2568\u2561\u2564\u00fc\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2564\u00ef\u2568\u2561 \u2568\u2524\u2568\u2557\u2564\u00c5 \u2564\u00ec\u2564\u00e9\u2568\u2555\u2564\u00e0 \u2564\u00c7\u2568\u2561\u2564\u00ea\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2563. \u2568\u00a3\u2564\u00ef \u2568\u2510\u2568\u255b\u2568\u2551\u2568\u2591\u2568\u2562\u2568\u2561\u2568\u255d \u2564\u00e7\u2564\u00e9\u2568\u255b \u2568\u255b\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2568\u255c\u2568\u2591\u2564\u00c5 \u2568\u2510\u2564\u00c7\u2568\u2555\u2564\u00e7\u2568\u2555\u2568\u255c\u2568\u2591 \u2564\u00e9\u2564\u00c7\u2564\u00e2\u2568\u2524\u2568\u255c\u2568\u255b\u2564\u00fc\u2564\u00e9\u2568\u2561\u2568\u2563 \u2568\u2557\u2568\u2561\u2568\u2562\u2568\u2555\u2564\u00e9 \u2568\u2593 \u2568\u2510\u2568\u2561\u2564\u00c7\u2568\u2561\u2564\u00fc\u2568\u2561\u2564\u00e7\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2555 \u2564\u00e4\u2564\u00e2\u2568\u255c\u2568\u2551\u2564\u00e5\u2568\u2555\u2568\u255b\u2568\u255c\u2568\u2591\u2568\u2557\u2564\u00ee\u2568\u255c\u2568\u255b\u2564\u00fc\u2564\u00e9\u2568\u2555, \u2568\u2551\u2568\u255b\u2564\u00e9\u2568\u255b\u2564\u00c7\u2568\u2591\u2564\u00c5 \u2568\u2524\u2568\u2561\u2568\u2557\u2568\u2591\u2568\u2561\u2564\u00e9 \u2568\u255c\u2568\u2561\u2568\u2593\u2568\u255b\u2568\u2556\u2568\u255d\u2568\u255b\u2568\u2562\u2568\u255c\u2564\u00ef\u2568\u255d (\u2564\u00fc \u2568\u2555\u2564\u00fc\u2568\u2510\u2568\u255b\u2568\u2557\u2564\u00ee\u2568\u2556\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561\u2568\u255d \u2564\u00fc\u2564\u00e2\u2564\u00eb\u2568\u2561\u2564\u00fc\u2564\u00e9\u2568\u2593\u2564\u00e2\u2564\u00c4\u2564\u00eb\u2568\u2555\u2564\u00e0 \u2568\u2510\u2568\u2591\u2564\u00c7\u2568\u2591\u2568\u2524\u2568\u2555\u2568\u2502\u2568\u255d) \u2564\u00e7\u2564\u00e6\u2564\u00e9\u2568\u2551\u2568\u255b \u2568\u2555\u2568\u255c\u2568\u2551\u2568\u2591\u2568\u2510\u2564\u00fc\u2564\u00e2\u2568\u2557\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2564\u00e9\u2564\u00ee \u2564\u00e4\u2564\u00e2\u2568\u255c\u2568\u2551\u2564\u00e5\u2568\u2555\u2568\u255b\u2568\u255c\u2568\u2591\u2568\u2557\u2564\u00ee\u2568\u255c\u2568\u255b\u2564\u00fc\u2564\u00e9\u2564\u00ee. \u2568\u00c6 \u2568\u2524\u2568\u2591\u2568\u255c\u2568\u255c\u2568\u255b\u2568\u2563 \u2564\u00fc\u2564\u00e9\u2568\u2591\u2564\u00e9\u2564\u00ee\u2568\u2561 \u2568\u255d\u2564\u00ef \u2568\u2510\u2564\u00c7\u2568\u2561\u2568\u2524\u2564\u00fc\u2564\u00e9\u2568\u2591\u2568\u2593\u2568\u2555\u2568\u255d \u2568\u255b\u2564\u00fc\u2568\u255c\u2568\u255b\u2568\u2593\u2564\u00e2 \u2568\u2524\u2568\u2557\u2564\u00c5 \u2568\u255c\u2568\u255b\u2568\u2593\u2568\u255b\u2568\u2563 \u2564\u00e9\u2568\u2561\u2564\u00e0\u2568\u255c\u2568\u2555\u2568\u2551\u2568\u2555 \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2564\u00c5, \u2568\u255c\u2568\u2591\u2568\u2556\u2564\u00ef\u2568\u2593\u2568\u2591\u2568\u2561\u2568\u255d\u2568\u255b\u2568\u2563 \u2568\u2591\u2564\u00fc\u2568\u2510\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b-\u2568\u255b\u2564\u00c7\u2568\u2555\u2568\u2561\u2568\u255c\u2564\u00e9\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u255c\u2564\u00ef\u2568\u255d \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d\u2568\u2555\u2564\u00c7\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561\u2568\u255d, \u2568\u2551\u2568\u255b\u2564\u00e9\u2568\u255b\u2564\u00c7\u2568\u2591\u2564\u00c5 \u2568\u2524\u2568\u2561\u2568\u2557\u2568\u2591\u2568\u2561\u2564\u00e9 \u2568\u2593\u2568\u255b\u2568\u2556\u2568\u255d\u2568\u255b\u2568\u2562\u2568\u255c\u2564\u00ef\u2568\u255d \u2564\u00e7\u2564\u00e6\u2564\u00e9\u2568\u2551\u2568\u255b\u2568\u2561 \u2568\u2593\u2564\u00ef\u2564\u00c7\u2568\u2591\u2568\u2562\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2561 \u2564\u00fc\u2564\u00e9\u2564\u00c7\u2564\u00e2\u2568\u2551\u2564\u00e9\u2564\u00e2\u2564\u00c7\u2564\u00ef \u2568\u2510\u2564\u00c7\u2568\u255b\u2568\u2502\u2564\u00c7\u2568\u2591\u2568\u255d\u2568\u255d \u2568\u2593\u2568\u2551\u2568\u2557\u2564\u00c4\u2564\u00e7\u2568\u2591\u2564\u00c4\u2564\u00eb\u2568\u2555\u2564\u00e0 \u2568\u2593 \u2564\u00fc\u2568\u2561\u2568\u2592\u2564\u00c5 \u2564\u00e9\u2568\u2591\u2568\u2551\u2564\u00e2\u2564\u00c4\" \u2564\u00fc\u2568\u2551\u2568\u2593\u2568\u255b\u2568\u2556\u2568\u255c\u2564\u00e2\u2564\u00c4 \u2564\u00e4\u2564\u00e2\u2568\u255c\u2568\u2551\u2564\u00e5\u2568\u2555\u2568\u255b\u2568\u255c\u2568\u2591\u2568\u2557\u2564\u00ee\u2568\u255c\u2568\u255b\u2564\u00fc\u2564\u00e9\u2564\u00ee\". \u2568\u00a3\u2564\u00ef \u2568\u2510\u2568\u255b\u2568\u2551\u2568\u2591\u2568\u2562\u2568\u2561\u2568\u255d, \u2564\u00e7\u2564\u00e9\u2568\u255b \u2564\u00fc \u2568\u2510\u2568\u255b\u2568\u255d\u2568\u255b\u2564\u00eb\u2564\u00ee\u2564\u00c4 \u2568\u2510\u2564\u00c7\u2568\u2555\u2568\u255d\u2568\u2561\u2568\u255c\u2568\u2561\u2568\u255c\u2568\u2555\u2564\u00c5\" \u2568\u2591\u2564\u00fc\u2568\u2510\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255b\u2568\u2593\" \u2564\u00c7\u2568\u2561\u2568\u2591\u2568\u2557\u2568\u2555\u2568\u2556\u2568\u2591\u2564\u00e5\u2568\u2555\u2564\u00c5 \u2568\u2555\u2568\u255d\u2568\u2561\u2568\u2561\u2564\u00e9 \u2568\u255d\u2568\u255b\u2568\u2562\u2568\u2561\u2564\u00e9 \u2568\u2510\u2564\u00c7\u2568\u2555\u2568\u255b\u2568\u2592\u2564\u00c7\u2568\u2561\u2564\u00fc\u2564\u00e9\u2568\u2555 \u2568\u255c\u2568\u2561\u2568\u255b\u2568\u2592\u2564\u00e0\u2568\u255b\u2568\u2524\u2568\u2555\u2568\u255d\u2564\u00e2\u2564\u00c4 \u2568\u2555\u2568\u2556\u2568\u255b\u2568\u2557\u2564\u00c5\u2564\u00e5\u2568\u2555\u2564\u00c4, \u2568\u2557\u2568\u255b\u2568\u2502\u2568\u2555\u2564\u00e7\u2568\u255c\u2564\u00e2\u2564\u00c4 \u2568\u2551\u2568\u255b\u2568\u255d\u2568\u2510\u2568\u255b\u2568\u2556\u2568\u2555\u2564\u00e5\u2568\u2555\u2564\u00c4 \u2568\u2510\u2564\u00c7\u2568\u2555 \u2564\u00ec\u2564\u00e9\u2568\u255b\u2568\u255d \u2568\u255c\u2568\u2561 \u2568\u2555\u2564\u00fc\u2568\u2551\u2568\u2557\u2564\u00c4\u2564\u00e7\u2568\u2591\u2564\u00c5 \u2568\u2510\u2568\u255b\u2568\u2593\u2564\u00e9\u2568\u255b\u2564\u00c7\u2568\u255c\u2568\u255b\u2568\u2561 \u2568\u2555\u2564\u00fc\u2568\u2510\u2568\u255b\u2568\u2557\u2564\u00ee\u2568\u2556\u2568\u255b\u2568\u2593\u2568\u2591\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u2551\u2568\u255b\u2568\u2524\u2568\u2591 \u2568\u2591\u2564\u00fc\u2568\u2510\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255b\u2568\u2593. \u2568\u00e1\u2568\u2561\u2564\u00ea\u2568\u2561\u2568\u255c\u2568\u2555\u2568\u2561 \u2568\u2592\u2568\u2591\u2568\u2556\u2568\u2555\u2564\u00c7\u2564\u00e2\u2568\u2561\u2564\u00e9\u2564\u00fc\u2564\u00c5 \u2568\u255c\u2568\u2591 \u2564\u00fc\u2568\u2555\u2564\u00fc\u2564\u00e9\u2568\u2561\u2568\u255d\u2568\u2561, \u2568\u2551\u2568\u255b\u2564\u00e9\u2568\u255b\u2564\u00c7\u2564\u00e2\u2564\u00c4 \u2568\u255d\u2564\u00ef \u2568\u2510\u2568\u255b\u2564\u00fc\u2564\u00e9\u2564\u00c7\u2568\u255b\u2568\u2555\u2568\u2557\u2568\u2555, \u2568\u2555\u2564\u00fc\u2568\u2510\u2568\u255b\u2568\u2557\u2564\u00ee\u2568\u2556\u2564\u00e2\u2564\u00c5 \u2564\u00e9\u2568\u2561\u2564\u00e0\u2568\u255c\u2568\u2555\u2568\u2551\u2564\u00e2 \u2568\u2591\u2564\u00fc\u2568\u2510\u2568\u2561\u2568\u2551\u2564\u00e9\u2568\u255c\u2568\u255b\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["40"]}
{"title": "Tiny-clos\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - Tiny-CLOS CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6 \u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c4\u00ac\u00f4\u03c3\u00c5\u00fa\u00b5\u00d1\u00a1\u03c3\u00ef\u00d6\u03c0\u00fc\u00ab\u03c3\u00e5\u00ec\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa Tiny-CLOS KICZALES Gregor \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 KICZALES Gregor \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 ftp: parcftp.xerox.com:pub/mops/^* ftp: parcftp.xerox.com:pub/mops/^*, 1992 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 BDI\u03c0\u00e9\u00f3\u03c0\u00e2\u255d\u03c0\u00e9\u00a1\u03c0\u00e2\u00e5\u03c0\u00e9\u00bb\u03c0\u00e2\u00fc\u03c0\u00e2\u00fa\u03c0\u00e9\u00c6\u03c4\u00f6\u00bf \u03c0\u00fc\u00e4\u03c0\u00fc\u0192\u03c3\u00ea\u00e5\u00b5\u00f2\u00fa\u03a3\u2551\u2551\u03c3\u2556\u00d1\u03c4\u0192\u00d1\u03a6\u00e2\u255c\u00b5\u00ea\u00aa\u03c4\u00f2\u00d1\u0398\u00fc\u2555\u00b5\u00e8\u20a7\u00b5\u2310\u0192\u00b5\u00ba\u00ef \u03c3\u2592\u2592\u03c3\u2524\u00c4 \u03a6\u2502\u00f3\u00b5\u2593\u2557 , \u00b5\u00d1\u00f3\u03c3\u2524\u00c4 \u03a3\u2510\u00ab\u03a3\u2551\u00ee , \u03c4\u00eb\u00a2\u03c3\u2502\u2562 \u03c3\u00c6\u00ee\u03c3\u00f1\u00bd \u0398\u00a2\u2557\u03c3\u00a1\u00c9\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u0398\u00c7\u00dc\u03a3\u2510\u00ed\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u00b5\u00e8\u00c7\u03a6\u00ed\u00f4\u03c4\u00e1\u00f6\u03c4\u2310\u2562 \u03c3\u00e1\u2592\u03c3\u00e6\u00e8. SS, \u03c0\u00e9\u255c\u03c0\u00e2\u00f2\u03c0\u00e2\u00ea\u03c0\u00e9\u00aa\u03c0\u00e9\u00ba\u03c0\u00e9\u00f3\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e9\u00bf\u03c0\u00e2\u2502\u03c0\u00e9\u2563 97(629), 49-56, 1998-03-23 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab9\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 ID(NAID) 10022234522 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03c0\u00fc\u00a5\u03c0\u00fc\u00ab\u03a3\u2557\u00fb \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP\u03c3\u255d\u00f2\u03c4\u00f6\u00bf \u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 RefWorks\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 EndNote\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 Mendeley\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 Refer/BiblX\u03c0\u00fc\u00ba\u03a6\u00ed\u00bf\u03c4\u00f1\u2551 RIS\u03c0\u00fc\u00ba\u03a6\u00ed\u00bf\u03c4\u00f1\u2551 BibTeX\u03c0\u00fc\u00ba\u03c0\u00fc\u00ba| \u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["40"]}
{"title": "Interpreter Implementation of Advice Weaving\n", "abstract": " Description Implementing advice weaving using code rewriting can cause performance problems during application startup and incremental development. We present an interpreter based (non-rewriting) approach using a simple table and cache structure for matching pointcuts against dynamic join points together with a simple mechanism for calling the matched advice. An implementation in the JikesRVM, an open source research virtual machine, shows the approach is straightforward to implement. Internal micro-benchmarks show dynamic join point execution overhead of approximately 28% in the common case where no advice is applicable. Comparative micro-benchmarks with ajc load time weaving show startup time reductions equivalent to the interpreted execution of 100-117 million unadvised dynamic join points. The cache and table structures could be used during later (ie JIT time) per-method rewrite based weaving to reduce pointcut matching overhead. We conclude that it is worthwhile to develop and evaluate a complete in-VM hybrid implementation, comprising both non-rewriting and rewriting based advice weaving.", "num_citations": "2\n", "authors": ["40"]}
{"title": "Making the Code Look Like the Design-Aspects and Other Recent Work\n", "abstract": " Summary form only given. The idea that programs should clearly reflect the design decisions they embody has a long history. Higher-level languages, syntactic macros, domain-specific languages, and intentional programming are different approaches to this common goal. Recent work from several areas, including aspect-oriented programming, has significantly advanced our ability to make code expressive. At the same time, it forces us to reconsider a number of basic assumptions, including what is a program, what is a module, what is a language, and what is an editor.", "num_citations": "2\n", "authors": ["40"]}
{"title": "Aspect-Oriented Programming Radical Research in Modularity\n", "abstract": " Aspect-Oriented Programming Radical Research in Modularity Page 1 University of British Columbia Software Practices Lab Aspect-Oriented Programming Radical Research in Modularity \u252c\u2310 Copyright 2004-2006 Gregor Kiczales. All rights reserved. Gregor Kiczales Page 2 Radical Research in Modularity 2 Expressiveness \u0393\u00c7\u00f3 The code looks like the design \u0393\u00c7\u00f3 \u0393\u00c7\u00a3What\u0393\u00c7\u00d6s going on\u0393\u00c7\u00a5 is clear \u0393\u00c7\u00f3 The programmer can say what they want to Programs must be written for people to read, and only incidentally for machines to execute. [SICP, Abelson, Sussman w/Sussman ] Page 3 Radical Research in Modularity 3 Share An Emerging Debate \u0393\u00c7\u00f3 About modularity and abstraction \u0393\u00c7\u00f4 foundational concepts of the field \u0393\u00c7\u00f4 but perhaps built on invalid implicit assumptions \u0393\u00c7\u00f3 generality of hierarchy \u0393\u00c7\u00f3 dynamicity of software configurations \u0393\u00c7\u00f3 source to machine code correspondence \u0393\u00c7\u00f3 developer\u0393\u00c7\u00d6s sphere of control \u0393\u00c7\u00f3 Consider these definitions: A is a of \u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["40"]}
{"title": "Xerox Parc\n", "abstract": " Lucid, Inc. Programming language design combines the art of invention with judicious adaptation and rejection of ideas previously tried. This chapter presents aspects of the design of the Common Lisp Object System (CLOS) in the context of related ideas from many languages, providing a view of the CLOS within a broader space of designs. CLOS is the latest in a long history of additions of object-oriented extensions to Lisp. But CLOS is the first such extension that integrates the type and class systems, and provides a uniform client interface for calling ordinary functions and functions implemented in an object-oriented style. CLOS is also designed with three constraints not found in other object-oriented extensions. The first is to provide essential compatibility with other previously used objectoriented LISP facilities, such as the Symbolics Flavors system. Essential compatibility implies an easy path for transforming programs, supporting the most frequently used capabilities in such systems. The second constraint is that CLOS is to facilitate experimentation with new language features in a way that allows them to integrate but not interfere with the kernel of the system. The third is that CLOS kernel facilities are to be efficiently implementable on", "num_citations": "2\n", "authors": ["40"]}
{"title": "Learning to listen for design\n", "abstract": " In his essay, Designed as Designer, Richard Gabriel suggests that artifacts are agents of their own design. Building on Gabriel\u0393\u00c7\u00d6s position, this essay makes three observations (1) Code \u0393\u00c7\u00a3speaks\u0393\u00c7\u00a5 to the programmer through code smells, and it talks about the shape it wants to take by signalling design principle violations. By \u0393\u00c7\u00a3listening\u0393\u00c7\u00a5 to code, even a novice programmer can let the code itself signal its own emergent natural structure.(2) Seasoned programmers listen for code smells, but they hear in the language of design principles (3) Design patterns are emergent structures that naturally arise from designers listening to what the code is signaling and then responding to these signals through refactoring transformations. Rather than seeing design patterns as an educational destination, we see them as a vehicle for teaching the skill of listening. By showing novices the stories of listening to code and unfolding design\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["40"]}
{"title": "Context, perspective, and programs\n", "abstract": " Context plays a large role in our perspective on the world around us--people see things differently depending on background, role, task at hand, and many other variables.", "num_citations": "1\n", "authors": ["40"]}
{"title": "Effectiveness sans formality\n", "abstract": " \u0393\u00c7\u00f3 Goal is to draw connections and possible directions\u0393\u00c7\u00f3 breadth of topics\u0393\u00c7\u00f3 for each some of you will be more expert\u0393\u00c7\u00f3 trying to be informed; but will surely make mistakes\u0393\u00c7\u00f3 Will use work I know best as examples\u0393\u00c7\u00f3 Mylyn, AOP, Fluid AOP, DPRG, role-based refactoring\u0393\u00c7\u00f3 not claiming that these are the best examples\u0393\u00c7\u00f3 just the ones I know best", "num_citations": "1\n", "authors": ["40"]}
{"title": "The ultra challenge: software systems beyond big\n", "abstract": " How can the ultra large systems (ULS) of the future be built if they will have the complexity of trillions of lines of code, maintain continuous 24x7 operations with no downtime, and live in a hostile environment with unpredictably changing requirements? This panel will discuss and debate the challenges posed by ultra large systems in terms of their design, growth, deployment and dynamics.", "num_citations": "1\n", "authors": ["40"]}
{"title": "Data abstraction in AspectJ\n", "abstract": " The AspectJ project[1] is exploring language support to enable programmers to implement crosscutting concerns in a modular fashion. Previous work in this area has primarily examined the expressiveness of AspectJ, to further aspect-oriented programming language research. In our work we focus on critical software engineering issues related to system modularity. In particular, we want to understand how use of AspectJ interacts with the well-known data abstraction principle[2].               In this abstract, we describe some of our work in identifying the explicit and implicit ways that modules can become dependent upon design decisions of another module in AspectJ. We hope that this information will provide a useful perspective to aspect-oriented programming language designers and will help users of AspectJ make informed design decisions. Given the space constraints, we must assume that the reader is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["40"]}
{"title": "Aspect-Oriented Progrannning\n", "abstract": " We have found many programming problems for which neither procedural nor object-oriented programming techniques are sufficient to clearly capture some of the important design decisions the program must implement. This forces the implementation of those design decisions to be scattered throughout the code, resulting in \u0393\u00c7\u00a3tangled\u0393\u00c7\u00a5 code that is excessively dif\u2229\u00bc\u00fccult to develop and maintain. We present an analysis of why certain design decisions have been so difficult to clearly capture in actual code. We call the properties these decisions address aspects, and show that the reason they have been hard to capture is that they cross-cut the system\u0393\u00c7\u00d6s basic functionality. We present the basis for a new programming technique, called aspect-oriented program-ming, that makes it possible to clearly express programs involving such as-pects, including appropriate isolation, composition and reuse of the aspect code. The\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["40"]}
{"title": "Initial design concepts for quality of service\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u251c\u00actre utilis\u251c\u2310 dans le cadre d\u0393\u00c7\u00d6une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u251c\u2592alado antes, el contenido de este registro bibliogr\u251c\u00edfico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "1\n", "authors": ["40"]}
{"title": "Foil for the Workshop on Open Implementation, internet publication\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - Foil for the Workshop on Open Implementation, internet publication CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa \u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6 \u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c4\u00ac\u00f4\u03c3\u00c5\u00fa\u00b5\u00d1\u00a1\u03c3\u00ef\u00d6\u03c0\u00fc\u00ab\u03c3\u00e5\u00ec\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa Foil for the Workshop on Open Implementation, internet publication KICZALES G. \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 KICZALES G. \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 http://www.par.xerox.com http://www.par.xerox.com, 1994 Xerox PARC \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 Java\u03c0\u00e2\u00c9\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb \u03c3\u00f1\u00eb\u00b5\u00c5\u00a2\u03c0\u00fc\u00bd\u03c0\u00e9\u00ea\u03c0\u00e9\u00ef\u00b5\u00ba\u00ef\u0398\u00c7\u00e1\u03c0\u00e2\u00ac\u03c0\u00e2\u00f2\u03c0\u00e2\u00bc\u03c0\u00e9\u00bb\u03c0\u00e9\u2556\u03c0\u00e2\u00ba\u03c0\u00e2\u2502\u03c0\u00fc\u00ab\u03c3\u00ab\u0192\u03c4\u00c5\u255b \u03c3\u00ec\u00e2\u03a6\u00e6\u00eb \u00b5\u2557\u00ef , \u03c4\u00bd\u00ef\u03c3\u00e1\u00c7 \u0398\u00fc\u00f4\u00b5\u00ff\u00a1 \u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00e7\u00aa\u03c4\u00c9\u00e5\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03a6\u00ac\u00ee 42(11), 2752-2760, 2001-11-15 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab20\u03a3\u2557\u2562 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab1\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) 20000142038 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03c0\u00fc\u00a5\u03c0\u00fc\u00ab\u03a3\u2557\u00fb \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP\u03c3\u255d\u00f2\u03c4\u00f6\u00bf \u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 RefWorks\u03c0\u00fc\u00bd\u00b5\u00a2\u2555\u03c0\u00fc\u00ec\u03c3\u00e7\u2551\u03c0\u00fc\u00f9 EndNote\u03c0\u00fc\u00bd\u03c0\u00fc\u00bd/\u03c0\u00fc\u00ba\u03c0\u00fc\u00ba\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["40"]}
{"title": "Macros that Reach Out and Touch Somewhere\n", "abstract": " By providing a macro facility, languages such as Scheme and Common Lisp allow users to define new special forms as local, syntactic program transformations. This allows users to abstract away what would otherwise be repetitive or cumbersome syntax. One limitation to the power of macro facilities is that only textually local transformations can be defined\u0393\u00c7\u00f6the user cannot, for example, define a delay macro which automatically inserts calls to force at all required points in the program. In this paper, we present a new kind of macro, called a data path macro, in which transformations can take place at any point along the dataflow path that includes the macro invocation. The heart of the data path macro facility is a dataflow analysis mechanism that allows the user to easily request powerful data flow analyses.", "num_citations": "1\n", "authors": ["40"]}