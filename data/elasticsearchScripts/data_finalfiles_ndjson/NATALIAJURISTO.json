{"title": "Methontology: from ontological art towards ontological engineering\n", "abstract": " This paper does not pretend either to transform completely the ontological art in engineering or to enumerate exhaustively the complete set of works that has been reported in this area. Its goal is to clarify to readers interested in building ontologies from scratch, the activities they should perform and in which order, as well as the set of techniques to be used in each phase of the methodology. This paper only presents a set of activities that conform the ontology developmentp rocess, a life cycle to build ontologies based in evolving prototypes, and METHONTOLOGY, a well-structured methodology used to build ontologies from scratch. This paper gathers the experience of the authors on building an ontology in the domain of chemicals.", "num_citations": "2495\n", "authors": ["157"]}
{"title": "Usability basics for software developers\n", "abstract": " This tutorial examines the relationship between usability and the user interface and discusses how the usability process follows a design-evaluate-redesign cycle. It also discusses some management issues an organization must face when applying usability techniques.", "num_citations": "295\n", "authors": ["157"]}
{"title": "How do personality, team processes and task characteristics relate to job satisfaction and software quality?\n", "abstract": " This article analyses the relationships between personality, team processes, task characteristics, product quality and satisfaction in software development teams. The data analysed here were gathered from a sample of 35 teams of students (105 participants). These teams applied an adaptation of an agile methodology, eXtreme Programming (XP), to develop a software product. We found that the teams with the highest job satisfaction are precisely the ones whose members score highest for the personality factors agreeableness and conscientiousness. The satisfaction levels are also higher when the members can decide how to develop and organize their work. On the other hand, the level of satisfaction and cohesion drops the more conflict there is between the team members. Finally, the teams exhibit a significant positive correlation between the personality factor extraversion and software product quality.", "num_citations": "271\n", "authors": ["157"]}
{"title": "Are students representatives of professionals in software engineering experiments?\n", "abstract": " Background: Most of the experiments in software engineering (SE) employ students as subjects. This raises concerns about the realism of the results acquired through students and adaptability of the results to software industry. Aim: We compare students and professionals to understand how well students represent professionals as experimental subjects in SE research. Method: The comparison was made in the context of two test-driven development experiments conducted with students in an academic setting and with professionals in a software organization. We measured the code quality of several tasks implemented by both subject groups and checked whether students and professionals perform similarly in terms of code quality metrics. Results: Except for minor differences, neither of the subject groups is better than the other. Professionals produce larger, yet less complex, methods when they use their\u00a0\u2026", "num_citations": "253\n", "authors": ["157"]}
{"title": "Developing search strategies for detecting relevant experiments\n", "abstract": " Our goal is to analyze the optimality of search strategies for use in systematic reviews of software engineering experiments. Studies retrieval is an important problem in any evidence-based discipline. This question has not been examined for evidence-based software engineering as yet. We have run several searches exercising different terms denoting experiments to evaluate their recall and precision. Based on our evaluation, we propose using a high recall strategy when there are plenty of resources or the results need to be exhaustive. For any other case, we propose optimal, or even acceptable, search strategies. As a secondary goal, we have analysed trends and weaknesses in terminology used in articles reporting software engineering experiments. We have found that it is impossible for a search strategy to retrieve 100% of the experiments of interest (as happens in other experimental disciplines\u00a0\u2026", "num_citations": "192\n", "authors": ["157"]}
{"title": "Assigning people to roles in software projects\n", "abstract": " This paper is based on the premise that people's behavioural competencies or characteristics of professional conduct influence the effectiveness and efficiency with which they perform a predetermined role in the software process. We propose a capabilities\u2010oriented process model that includes traditional elements of the software process (activities, products, techniques, people and roles) and the original element of this paper (capabilities). With the aim of adding behavioural competencies to the process model, we define the capability\u2013person and capability\u2013role relationships involved in software development. Additionally, we propose two procedures that are based on each of these relationships: a procedure that can be used to determine the capabilities of the members of a development team; and a procedure that can be used to assign people to perform roles depending on their capabilities and the capabilities\u00a0\u2026", "num_citations": "187\n", "authors": ["157"]}
{"title": "Systematic review and aggregation of empirical studies on elicitation techniques\n", "abstract": " We have located the results of empirical studies on elicitation techniques and aggregated these results to gather empirically grounded evidence. Our chosen surveying methodology was systematic review, whereas we used an adaptation of comparative analysis for aggregation because meta-analysis techniques could not be applied. The review identified 564 publications from the SCOPUS, IEEEXPLORE, and ACM DL databases, as well as Google. We selected and extracted data from 26 of those publications. The selected publications contain 30 empirical studies. These studies were designed to test 43 elicitation techniques and 50 different response variables. We got 100 separate results from the experiments. The aggregation generated 17 pieces of knowledge about the interviewing, laddering, sorting, and protocol analysis elicitation techniques. We provide a set of guidelines based on the gathered pieces of\u00a0\u2026", "num_citations": "175\n", "authors": ["157"]}
{"title": "Empirical software engineering experts on the use of students and professionals in experiments\n", "abstract": " [Context] Controlled experiments are an important empirical method to generate and validate theories. Many software engineering experiments are conducted with students. It is often claimed that the use of students as participants in experiments comes at the cost of low external validity while using professionals does not. [Objective] We believe a deeper understanding is needed on the external validity of software engineering experiments conducted with students or with professionals. We aim to gain insight about the pros and cons of using students and professionals in experiments. [Method] We performed an unconventional, focus group approach and a follow-up survey. First, during a session at ISERN 2014, 65 empirical researchers, including the seven authors, argued and discussed the use of students in experiments with an open mind. Afterwards, we revisited the topic and elicited experts\u2019 opinions to\u00a0\u2026", "num_citations": "125\n", "authors": ["157"]}
{"title": "Using differences among replications of software engineering experiments to gain knowledge\n", "abstract": " In no science or engineering discipline does it make sense to speak of isolated experiments. The results of a single experiment cannot be viewed as representative of the underlying reality. The concept of experiment is closely related to replication. Experiment replication is the repetition of an experiment to double-check its results. Multiple replications of an experiment increase the credibility of its results. Software engineering has tried its hand at the identical repetition of experiments in the way of the natural sciences (physics, chemistry, etc.). After numerous attempts over the years, excepting experiments repeated by the same researchers at the same site, no exact replications have yet been achieved. One key reason for this is the complexity of the software development setting. This complexity prevents the many experimental conditions from being reproduced identically. This paper reports research into whether\u00a0\u2026", "num_citations": "110\n", "authors": ["157"]}
{"title": "Systematizing requirements elicitation technique selection\n", "abstract": " ContextThis research deals with requirements elicitation technique selection for software product requirements and the overselection of open interviews.ObjectivesThis paper proposes and validates a framework to help requirements engineers select the most adequate elicitation techniques at any time.MethodWe have explored both the existing underlying theory and the results of empirical research to build the framework. Based on this, we have deduced and put together justified proposals about the framework components. We have also had to add information not found in theoretical or empirical sources. In these cases, we drew on our own experience and expertise.ResultsA new validated approach for requirements technique selection. This new approach selects techniques other than open interview, offers a wider range of possible techniques and captures more requirements information.ConclusionsThe\u00a0\u2026", "num_citations": "109\n", "authors": ["157"]}
{"title": "A HCI technique for improving requirements elicitation\n", "abstract": " ContextTo develop usable software we need to understand the users that will interact with the system. Personas is a HCI technique that gathers information about users in order to comprehend their characteristics. This information is used to define fictitious persons on which development should focus. Personas provides an understanding of the user, often overlooked in SE developments.ObjectiveThe goal of our research is to modify Personas to readily build the technique into the requirements stage of regular SE developments.MethodWe tried to apply Cooper\u2019s version of the Personas technique and we found shortcomings in both the definition of the procedure to be enacted and the formalization of the product resulting from the execution of each step of the Personas technique. For each of these limitations (up to a total of 11), we devised an improvement to be built into Personas. We have incorporated these\u00a0\u2026", "num_citations": "86\n", "authors": ["157"]}
{"title": "The role of non-exact replications in software engineering experiments\n", "abstract": " In no science or engineering discipline does it make sense to speak of isolated experiments. The results of a single experiment cannot be viewed as representative of the underlying reality. Experiment replication is the repetition of an experiment to double-check its results. Multiple replications of an experiment increase the confidence in its results. Software engineering has tried its hand at the identical (exact) replication of experiments in the way of the natural sciences (physics, chemistry, etc.). After numerous attempts over the years, apart from experiments replicated by the same researchers at the same site, no exact replications have yet been achieved. One key reason for this is the complexity of the software development setting, which prevents the many experimental conditions from being identically reproduced. This paper reports research into whether non-exact replications can be of any use. We\u00a0\u2026", "num_citations": "78\n", "authors": ["157"]}
{"title": "Towards understanding the relationship between team climate and software quality\u2014a quasi-experimental study\n", "abstract": " This paper describes an empirical study that examined the work climate within software development teams. The question was whether the team climate in software developer teams has any relation to software product quality. We define team climate as the shared perceptions of the team\u2019s work procedures and practices. The team climate factors examined were West and Anderson\u2019s participative safety, support for innovation, team vision and task orientation. These four factors were measured before the project using the Team Selection Inventory (TSI) test to establish subject climate preferences, as well as during and after the project using the Team Climate Inventory (TCI) test, which establishes the subject\u2019s perceptions of the climate. In this quasi-experimental study, data were collected from a sample of 35 three-member developer teams in an academic setting. These teams were formed at random and\u00a0\u2026", "num_citations": "74\n", "authors": ["157"]}
{"title": "Crossover designs in software engineering experiments: Benefits and perils\n", "abstract": " In experiments with crossover design subjects apply more than one treatment. Crossover designs are widespread in software engineering experimentation: they require fewer subjects and control the variability among subjects. However, some researchers disapprove of crossover designs. The main criticisms are: the carryover threat and its troublesome analysis. Carryover is the persistence of the effect of one treatment when another treatment is applied later. It may invalidate the results of an experiment. Additionally, crossover designs are often not properly designed and/or analysed, limiting the validity of the results. In this paper, we aim to make SE researchers aware of the perils of crossover experiments and provide risk avoidance good practices. We study how another discipline (medicine) runs crossover experiments. We review the SE literature and discuss which good practices tend not to be adhered to\u00a0\u2026", "num_citations": "71\n", "authors": ["157"]}
{"title": "Functional testing, structural testing and code reading: What fault type do they each detect?\n", "abstract": " The origin of the study described here is the experiment performed by Basili and Selby, further replicated by Kamsties and Lott, and once again by Wood et al. These experiments investigated the effectiveness and efficiency of different code evaluation techniques (functional and structural testing and code reading). The working hypotheses are the same in all three experiments, although some experimental conditions were changed. The experiments described here use the experiment package elaborated by Kamsties and Lott and examine some of the questions posed as a result of these experiments. Wood et al. concluded in their replication of the original study that the relative effectiveness of the techniques depends on the program and fault type. In fact, they suggest formulating a fault taxonomy based on technique sensitivity. Our study intends to compare the relative effectiveness of the testing techniques\u00a0\u2026", "num_citations": "70\n", "authors": ["157"]}
{"title": "Study of Elicitation Techniques Adequacy\n", "abstract": " Requirements engineers can make use of a great many techniques to elicit user needs. However, there is no comprehensive practica! guide on how to select the best techniques for a particular context\u00faa! situation within a software development project. We propose a framework to support developer decisi\u00f3n making on which are the best elicitation techniques for the project at hand. Our framework identifies which elicitation technique responds better to certain project features.", "num_citations": "51\n", "authors": ["157"]}
{"title": "Integrating the personas technique into the requirements analysis activity\n", "abstract": " To develop usable systems, it is necessary to understand the users that interact with the system. The personas technique from the human-computer interaction discipline (HCI) gathers data about users, gains an understanding of their characteristics, defines fictitious personas based on this understanding and focuses on these personas throughout the software development process. The aim of our research is to build personas into routine software development following software engineering (SE) guidelines. The intention is to improve the usability of the resulting software. To achieve this aim, we first present a modification of the personas technique, called Personas*. This new technique complies with SE systematization standards. Second, we incorporate the proposed Personas* technique into the software process requirements analysis activity. The benefits to be gained from the Personas* technique are: i) it\u00a0\u2026", "num_citations": "50\n", "authors": ["157"]}
{"title": "Empirical evaluation of the effects of experience on code quality and programmer productivity: an exploratory study\n", "abstract": " Context                 There is a widespread belief in both SE and other branches of science that experience helps professionals to improve their performance. However, cases have been reported where experience not only does not have a positive influence but sometimes even degrades the performance of professionals.                                               Aim                 Determine whether years of experience influence programmer performance.                                               Method                 We have analysed 10 quasi-experiments executed both in academia with graduate and postgraduate students and in industry with professionals. The experimental task was to apply ITLD on two experimental problems and then measure external code quality and programmer productivity.                                               Results                 Programming experience gained in industry does not appear to have any effect whatsoever on\u00a0\u2026", "num_citations": "46\n", "authors": ["157"]}
{"title": "Common framework for the evaluation process of KBS and conventional software\n", "abstract": " Conventional software (CS) and knowledge-based software (KBS) validation and verification have been traditionally accepted to be radically different disciplines with nothing in common. However, the differences between CS and KBS should not stop efforts being made to develop a general framework for evaluation, covering validation and verification of both types of software. A review of the concepts of validation, verification and testing in both software engineering and knowledge engineering may lead to a better understanding of the objectives of software evaluation during software development and enable a framework for the evaluation of both CS and KBS to be proposed. This does not mean that the same techniques should be applied to both types of software. An evaluation framework should establish the types of evaluation to be conducted, when they are to be conducted and what techniques are to be used\u00a0\u2026", "num_citations": "46\n", "authors": ["157"]}
{"title": "Introducing usability\n", "abstract": " Integrating usability into the software development process is not easy or obvious. Even the companies that have usability departments have difficulty resolving conflicts between usability staff and software developers, based on the groups' different perspectives.", "num_citations": "44\n", "authors": ["157"]}
{"title": "Software engineering and knowledge engineering: Towards a common life cycle\n", "abstract": " Software and knowledge engineering are increasingly converging into a single life-cycle, as the two engineering disciplines are studied in more depth, and increasingly larger systems are developed in the two fields. In this article, the authors advocate a conical-spiral type life cycle, arranged in two dimensions (the spiral) for the development of software engineering (SE) systems and three dimensions (the conical-spiral) for the knowledge engineering (KE) life cycle. A conventional example for the overall personnel management of a company is also presented, showing how the two branches of engineering are essential and complementary in solving important problems.", "num_citations": "39\n", "authors": ["157"]}
{"title": "Reporting experiments to satisfy professionals\u2019 information needs\n", "abstract": " Although the aim of empirical software engineering is to provide evidence for selecting the appropriate technology, it appears that there is a lack of recognition of this work in industry. Results from empirical research only rarely seem to find their way to company decision makers. If information relevant for software managers is provided in reports on experiments, such reports can be considered as a source of information for them when they are faced with making decisions about the selection of software engineering technologies. To bridge this communication gap between researchers and professionals, we propose characterizing the information needs of software managers in order to show empirical software engineering researchers which information is relevant for decision-making and thus enable them to make this information available. We empirically investigated decision makers\u2019 information needs to\u00a0\u2026", "num_citations": "34\n", "authors": ["157"]}
{"title": "How to integrate usability into the software development process\n", "abstract": " Usability is increasingly recognized as a quality attribute that one has to explicitly deal with during development. Nevertheless, usability techniques, when applied, are decoupled from the software development process. The host of techniques offered by the HCI (Human-Computer Interaction) field make the task of selecting the most appropriate ones for a given project and organization a difficult task. Project managers and developers aiming to integrate usability practices into their software process have to face important challenges, as the techniques are not described in the frame of a software process as it is understood in SE (Software Engineering). Even when HCI experts (either in-house or from an external organization) are involved in the integration process, it is also a tough endeavour due to the strong differences in terminology and overall approach to software development between HCI and SE. In this\u00a0\u2026", "num_citations": "34\n", "authors": ["157"]}
{"title": "Software industry experiments: A systematic literature review\n", "abstract": " Background: There is no specialized survey of experiments conducted in the software industry. Goal: Identify the major features of software industry experiments, such as time distribution, independent and dependent variables, subject types, design types and challenges. Method: Systematic literature review, taking the form of a scoping study. Results: We have identified 10 experiments and five quasi-experiments up to July 2012. Most were run as of 2003. The main features of these studies are that they test technologies related to quality and management and analyse outcomes related to effectiveness and effort. Most experiments have a factorial design. The major challenges faced by experimenters are to minimize the cost of running the experiment for the company and to schedule the experiment so as not to interfere with production processes. Conclusion: Companies appear to be disinclined to run experiments\u00a0\u2026", "num_citations": "31\n", "authors": ["157"]}
{"title": "Effect of domain knowledge on elicitation effectiveness: an internally replicated controlled experiment\n", "abstract": " Context. Requirements elicitation is a highly communicative activity in which human interactions play a critical role. A number of analyst characteristics or skills may influence elicitation process effectiveness. Aim. Study the influence of analyst problem domain knowledge on elicitation effectiveness. Method. We executed a controlled experiment with post-graduate students. The experimental task was to elicit requirements using open interview and consolidate the elicited information immediately afterwards. We used four different problem domains about which students had different levels of knowledge. Two tasks were used in the experiment, whereas the other two were used in an internal replication of the experiment; that is, we repeated the experiment with the same subjects but with different domains. Results. Analyst problem domain knowledge has a small but statistically significant effect on the effectiveness of\u00a0\u2026", "num_citations": "30\n", "authors": ["157"]}
{"title": "Difficulties in running experiments in the software industry: Experiences from the trenches\n", "abstract": " Controlled experiments in laboratory settings are relatively commonplace in software engineering, but experiments in industry are thin on the ground. Of the few existing cases, most are 1-1 (running one experiment at one company), just a few are n-1 (running n experiments at one company) and still fewer are 1-n (running one and the same experiment at n companies). In this paper we report the difficulties that we experienced running the same experiment at several companies. We ran the same experiment in five different settings at three companies, and the results were transferred to each company so that they could exploit the resulting evidence in their decision-making process. We have found that: 1) it was relatively easy to get companies involved; 2) they did not cooperate as much as they had agreed to in the project proposal; 3) our industrial environments imposed many more constraints on the experimental\u00a0\u2026", "num_citations": "29\n", "authors": ["157"]}
{"title": "Conceptual modeling in software engineering and knowledge engineering: Concepts, Techniques and trends\n", "abstract": " Conceptual modeling is a crucial software development activity for both Software Engineering and Knowledge Engineering. Each discipline, however, has developed its own techniques for conceptual modeling, and there is no agreement about a common set of techniques that can be used in both disciplines. This chapter will describe such techniques, paying special attention to the more recent and innovative ones, as well as to the concepts shared by the techniques used in the two disciplines. The chapter will, therefore, outline the field of conceptual modeling within these two disciplines. Although the situation in the field is satisfactory, as can be inferred from the review conducted, there is still a lot of work to be done. Indeed, a series of shortcomings besetting the different techniques will be identified and an alternative perspective will be described, which points to a way of quieting such objections.", "num_citations": "26\n", "authors": ["157"]}
{"title": "Including functional usability features in a model-driven development method\n", "abstract": " The Software Engineering (SE) community has historically focused on working    with models to represent functionality and persistence, pushing interaction    modelling into the background, which has been covered by the Human Computer    Interaction (HCI) community. Recently, adequately modelling interaction, and    specifically usability, is being considered as a key factor for success in    user acceptance, making the integration of the SE and HCI communities more    necessary. If we focus on the Model-Driven Development (MDD) paradigm, we    notice that there is a lack of proposals to deal with usability features from    the very first steps of software development process. In general, usability    features are manually implemented once the code has been generated from    models. This contradicts the MDD paradigm, which claims that all the    analysts\u2019 effort must be focused on building models, and the code generation    is relegated to model to code transformations. Moreover, usability features    related to functionality may involve important changes in the system    architecture if they are not considered from the early steps. We state that    these usability features related to functionality can be represented    abstractly in a conceptual model, and their implementation can be carried out    automatically.", "num_citations": "25\n", "authors": ["157"]}
{"title": "Impact of usability on software requirements and design\n", "abstract": " Like any other quality attribute, usability imposes specific constraints on software components. We have empirically corroborated that software design and usability are related. Therefore usability features impacting design need to be considered from a functional viewpoint at requirements stage. But discovering and documenting usability features is likely to be beyond the usability knowledge of most requirements engineers, developers and users. We propose an approach based on developing specific guidelines that capitalize upon key elements recurrently intervening in the usability features elicitation and specification. Developers can use these guidelines to ask the appropriate questions and capture usability requirements information. This practice should lead to build software with higher usability.", "num_citations": "24\n", "authors": ["157"]}
{"title": "Towards an operationalization of test-driven development skills: An industrial empirical study\n", "abstract": " Context: The majority of the empirical studies on Test-driven development (TDD) are concerned with verifying or refuting the effectiveness of the technique over a traditional approach, and they tend to neglect whether the subjects possess the necessary skills to apply TDD, though they argue such skills are necessary. Objective: We evaluate a set of minimal, a priori and in process skills necessary to apply TDD. We determine whether variations in external quality (ie, number of defects) and productivity (ie, number of features implemented) can be associated with different clusters of the TDD skills\u2019 set. Method: We executed a quasi-experiment involving 30 practitioners from industry. We first grouped the participants according to their TDD skills\u2019 set (consisting of a priori experience on programming and testing as well as in-process TDD conformance) into three levels (Low-Medium-High) using k-means clustering. We\u00a0\u2026", "num_citations": "23\n", "authors": ["157"]}
{"title": "A systematic mapping study on the open source software development process\n", "abstract": " Background: There is no globally accepted open source software development process to define how open source software is developed in practice. A process description is important for coordinating all the software development activities involving both people and technology. Aim: The research question that this study sets out to answer is: What activities do open source software process models contain? The activity groups on which it focuses are Concept Exploration, Software Requirements, Design, Maintenance and Evaluation. Method: We conduct a systematic mapping study (SMS). A SMS is a form of systematic literature review that aims to identify and classify available research papers concerning a particular issue. Results: We located a total of 29 primary studies, which we categorized by the open source software project that they examine and by activity types (Concept Exploration, Software Requirements\u00a0\u2026", "num_citations": "23\n", "authors": ["157"]}
{"title": "Trends in life-cycle models for SE and KE: proposal for a spiral-conical life-cycle approach\n", "abstract": " The ten-year gap between the emergence of Software Engineering (SE) and Knowledge Engineering (KE) has led to the two disciplines developing along different methodological lines. In this paper, we point out that, after having passed through a period during which they ignored each other, followed by a competitive phase, the two disciplines have now reached a meeting point. We see the need for a life-cycle model for systems that integrate traditional and knowledge-based software. Besides, software development in the 21st century will entail open requirements and technological tools that will evolve during the life-cycle. Finally, the paper discusses a proposal for a conical-type spiral life-cycle model that seeks to meet all those needs.", "num_citations": "21\n", "authors": ["157"]}
{"title": "Findings from a multi-method study on test-driven development\n", "abstract": " ContextTest-driven development (TDD) is an iterative software development practice where unit tests are defined before production code. A number of quantitative empirical investigations have been conducted about this practice. The results are contrasting and inconclusive. In addition, previous studies fail to analyze the values, beliefs, and assumptions that inform and shape TDD.ObjectiveWe present a study designed, and conducted to understand the values, beliefs, and assumptions about TDD. Participants were novice and professional software developers.MethodWe conducted an ethnographically-informed study with 14 novice software developers, i.e., graduate students in Computer Science at the University of Basilicata, and six professional software developers (with one to 10 years work experience). The participants worked on the implementation of a new feature for an existing software written in Java. We\u00a0\u2026", "num_citations": "20\n", "authors": ["157"]}
{"title": "Students' and professionals' perceptions of test-driven development: a focus group study\n", "abstract": " We have conducted a qualitative investigation on test-driven development (TDD) with focus groups to develop insights on the opinions of developers using TDD regarding the unintuitive process involved, its claimed effects, as well as the context factors that can facilitate (or hinder) its application. In particular, we conducted two focus group sessions: one with professionals and another with Master students in Computer Science. We used thematic analysis template (TAT) method for identifying patterns, themes, and interpretations in gathered data. We obtained a number of results that can be summarized as follows:(i) applying TDD without knowing advanced unit testing techniques can be difficult;(ii) refactoring (one of the phases of TDD) is not done as often as the process requires;(iii) there is a need for live feedback to let developers understand if TDD is being applied correctly; and (iv) the usefulness of TDD hinges\u00a0\u2026", "num_citations": "20\n", "authors": ["157"]}
{"title": "Comparative analysis of meta-analysis methods: when to use which?\n", "abstract": " Background: Several meta-analysis methods can be used to quantitatively combine the results of a group of experiments, including the weighted mean difference, statistical vote counting, the parametric response ratio and the non-parametric response ratio. The software engineering community has focused on the weighted mean difference method. However, other meta-analysis methods have distinct strengths, such as being able to be used when variances are not reported. There are as yet no guidelines to indicate which method is best for use in each case Aim: Compile a set of rules that SE researchers can use to ascertain which aggregation method is best for use in the synthesis phase of a systematic review. Method: Monte Carlo simulation varying the number of experiments in the meta analyses, the number of subjects that they include, their variance and effect size. We empirically calculated the reliability and\u00a0\u2026", "num_citations": "20\n", "authors": ["157"]}
{"title": "Design and programming patterns for implementing usability functionalities in web applications\n", "abstract": " Usability is a software system quality attribute. There are usability issues that have an impact not only on the user interface but also on the core functionality of applications. In this paper, three web applications were developed to discover patterns for implementing two usability functionalities with an impact on core functionality: Abort Operation and Progress Feedback. We applied an inductive process in order to identify reusable elements to implement the selected functionalities. For communication purposes, these elements are specified as design and programming patterns (PHP, VB.NET and Java). Another two web applications were developed in order to evaluate the patterns. The evaluation explores several issues such as ease of pattern understanding and ease of pattern use, as well as the final result of the applications.We found that it is feasible to reuse the identified solutions specified as patterns. The\u00a0\u2026", "num_citations": "19\n", "authors": ["157"]}
{"title": "Design patterns in software maintenance: An experiment replication at upm-experiences with the reser'11 joint replication project\n", "abstract": " Replication of software engineering experiments is crucial for dealing with validity threats to experiments in this area. Even though the empirical software engineering community is aware of the importance of replication, the replication rate is still very low. The RESER'11 Joint Replication Project aims to tackle this problem by simultaneously running a series of several replications of the same experiment. In this article, we report the results of the replication run at the Universidad Polit\u00e9cnica de Madrid. Our results are inconsistent with the original experiment. However, we have identified possible causes for them. We also discuss our experiences (in terms of pros and cons) during the replication.", "num_citations": "19\n", "authors": ["157"]}
{"title": "Hidden evidence behind useless replications\n", "abstract": " Experiments that are run with few experimental subjects are often considered not to be very reliable and deemed, as a result, to be useless with a view to generating new knowledge. This belief is not, however, entirely correct. Today we have tools, such as metaanalysis, that we can use to aggregate small-scale experiments and output results that are equivalent to experiments run on large samples that are therefore reliable. The application of metaanalysis can overcome some of the obstacles that we come up against when running software engineering experiments (such as, for example, the practitioner availability problem).", "num_citations": "18\n", "authors": ["157"]}
{"title": "On the effectiveness of unit tests in test-driven development\n", "abstract": " Background: Writing unit tests is one of the primary activities in test-driven development. Yet, the existing reviews report few evidence supporting or refuting the effect of this development approach on test case quality. Lack of ability and skills of developers to produce sufficiently good test cases are also reported as limitations of applying test-driven development in industrial practice. Objective: We investigate the impact of test-driven development on the effectiveness of unit test cases compared to an incremental test last development in an industrial context. Method: We conducted an experiment in an industrial setting with 24 professionals. Professionals followed the two development approaches to implement the tasks. We measure unit test effectiveness in terms of mutation score. We also measure branch and method coverage of test suites to compare our results with the literature. Results: In terms of mutation score\u00a0\u2026", "num_citations": "17\n", "authors": ["157"]}
{"title": "Quantitative determination of the relationship between internal validity and bias in software engineering experiments: Consequences for systematic literature reviews\n", "abstract": " Quality assessment is one of the activities performed as part of systematic literature reviews. It is commonly accepted that a good quality experiment is bias free. Bias is considered to be related to internal validity (e.g., how adequately the experiment is planned, executed and analysed). Quality assessment is usually conducted using checklists and quality scales. It has not yet been proven, however, that quality is related to experimental bias. Aim: Identify whether there is a relationship between internal validity and bias in software engineering experiments. Method: We built a quality scale to determine the quality of the studies, which we applied to 28 experiments included in two systematic literature reviews. We proposed an objective indicator of experimental bias, which we applied to the same 28 experiments. Finally, we analysed the correlations between the quality scores and the proposed measure of bias\u00a0\u2026", "num_citations": "17\n", "authors": ["157"]}
{"title": "A longitudinal cohort study on the retainment of test-driven development\n", "abstract": " Background: Test-Driven Development (TDD) is an agile software development practice, which is claimed to boost both external quality of software products and developers' productivity.Aims: We want to study:(i) the TDD effects on the external quality of software products as well as the developers' productivity; and (ii) the retainment of TDD over a period of five months.Method: We conducted a (quantitative) longitudinal cohort study with 30 third-year undergraduate students in Computer Science at the University of Bari in Italy.Results: The use of TDD has a statistically significant effect neither on the external quality of software products nor on the developers' productivity. However, we observed that participants using TDD produced significantly more tests than those applying a non-TDD development process, and that the retainment of TDD is particularly noticeable in the amount of tests written.Conclusions: Our\u00a0\u2026", "num_citations": "13\n", "authors": ["157"]}
{"title": "Results from an ethnographically-informed study in the context of test driven development\n", "abstract": " Background: Test-driven development (TDD) is an iterative software development technique where unit tests are defined before production code. Previous studies fail to analyze the values, beliefs, and assumptions that inform and shape TDD.Aim: We designed and conducted a qualitative study to understand the values, beliefs, and assumptions of TDD. In particular, we sought to understand how novice and professional software developers, arranged in pairs (a driver and a pointer), perceive and apply TDD.Method: 14 novice software developers, ie, graduate students in Computer Science at the University of Basilicata, and six professional software developers (with one to 10 years work experience) participated in our ethnographically informed study. We asked the participants to implement a new feature for an existing software written in Java. We immersed ourselves in the context of the study, and collected data\u00a0\u2026", "num_citations": "13\n", "authors": ["157"]}
{"title": "Evidence of the presence of bias in subjective metrics: Analysis within a family of experiments\n", "abstract": " Context: Measurement is crucial and important to empirical software engineering. Although reliability and validity are two important properties warranting consideration in measurement processes, they may be influenced by random or systematic error (bias) depending on which metric is used. Aim: Check whether, the simple subjective metrics used in empirical software engineering studies are prone to bias. Method: Comparison of the reliability of a family of empirical studies on requirements elicitation that explore the same phenomenon using different design types and objective and subjective metrics. Results: The objectively measured variables (experience and knowledge) tend to achieve more reliable results, whereas subjective metrics using Likert scales (expertise and familiarity) tend to be influenced by systematic error or bias. Conclusions: Studies that predominantly use variables measured subjectively, like\u00a0\u2026", "num_citations": "13\n", "authors": ["157"]}
{"title": "A controlled experiment with novice developers on the impact of task description granularity on software quality in test-driven development\n", "abstract": " Background: Test-Driven Development (TDD) is an iterative software development process characterized by test-code-refactor cycle. TDD recommends that developers work on small and manageable tasks at each iteration. However, the ability to break tasks into small work items effectively is a learned skill that improves with experience. In experimental studies of TDD, the granularity of task descriptions is an overlooked factor. In particular, providing a more granular task description in terms of a set of sub-tasks versus providing a coarser-grained, generic description. Objective: We aim to investigate the impact of task description granularity on the outcome of TDD, as implemented by novice developers, with respect to software quality, as measured by functional correctness and functional completeness. Method: We conducted a one-factor crossover experiment with 48 graduate students in an academic environment\u00a0\u2026", "num_citations": "12\n", "authors": ["157"]}
{"title": "Need for sleep: the impact of a night of sleep deprivation on novice developers\u2019 performance\n", "abstract": " We present a quasi-experiment to investigate whether, and to what extent, sleep deprivation impacts the performance of novice software developers using the agile practice of test-first development (TFD). We recruited 45 undergraduates, and asked them to tackle a programming task. Among the participants, 23 agreed to stay awake the night before carrying out the task, while 22 slept normally. We analyzed the quality (i.e., the functional correctness) of the implementations delivered by the participants in both groups, their engagement in writing source code (i.e., the amount of activities performed in the IDE while tackling the programming task) and ability to apply TFD (i.e., the extent to which a participant is able to apply this practice). By comparing the two groups of participants, we found that a single night of sleep deprivation leads to a reduction of 50 percent in the quality of the implementations. There is notable\u00a0\u2026", "num_citations": "12\n", "authors": ["157"]}
{"title": "Content and structure of laboratory packages for software engineering experiments\n", "abstract": " ContextExperiment replications play a central role in the scientific method. Although software engineering experimentation has matured a great deal, the number of experiment replications is still relatively small. Software engineering experiments are composed of complex concepts, procedures and artefacts. Laboratory packages are a means of transferring knowledge among researchers to facilitate experiment replications.ObjectiveThis paper investigates the experiment replication process to find out what information is needed to successfully replicate an experiment. Our objective is to propose the content and structure of laboratory packages for software engineering experiments.MethodWe evaluated seven replications of three different families of experiments. Each replication had a different experimenter who was, at the time, unfamiliar with the experiment. During the first iterations of the study, we identified\u00a0\u2026", "num_citations": "12\n", "authors": ["157"]}
{"title": "Formal justification in object-oriented modelling: A linguistic approach\n", "abstract": " When software engineers set out to build a system, they usually have the informal idea that there is a relation between the linguistic world and the conceptual world. In this paper, we present a formalisation of this empirical relation, defining an intermediate mapping of the components of the linguistic and conceptual worlds to their mathematical representations. This process outputs a justified correspondence between natural language, used as a means of communication between users and software engineers, and conceptual models, employed by software engineers as a first step towards building a system. In other words, our aim is to show how the equivalence of the linguistic and conceptual representations of a requirement can be established in a formal and justified manner.", "num_citations": "11\n", "authors": ["157"]}
{"title": "The effect of noise on software engineers' performance\n", "abstract": " Background: Noise, defined as an unwanted sound, is one of the commonest factors that could affect people's performance in their daily work activities. The software engineering research community has marginally investigated the effects of noise on software engineers' performance.Aims: We studied if noise affects software engineers' performance in:(i) comprehending functional requirements and (ii) fixing faults in source code.Method: We conducted two experiments with final-year undergraduate students in Computer Science. In the first experiment, we asked 55 students to comprehend functional requirements exposing them or not to noise, while in the second experiment 42 students were asked to fix faults in Java code.Results: The participants in the second experiment, when exposed to noise, had significantly worse performance in fixing faults in source code. On the other hand, we did not observe any\u00a0\u2026", "num_citations": "10\n", "authors": ["157"]}
{"title": "Towards a Joint Life-Cycle for Software and Knowledge Engineering\n", "abstract": " As software engineering and knowledge engineering are studied in more depth and increasingly larger systems are developed in the field of knowledge engineering both disciplines are converging into a single life-cycle. In this paper, we propose a conicalspiral type life cycle, arranged in two dimensions (the spiral) for the development of classical software systems and three dimensions (the conical-spiral) for the knowledge engineering life cycle.To arrive at this convergence, a brief history of Software Engineering is presented, and the peculiarities of Knowledge-Based Systems are showed. Then, an example is presented to show how the two branches of engineering are essential in solving important problems and the possible integration of software engineering and knowledge engineering is discussed. Finally, a proposal of integrator life-cycle is explained", "num_citations": "10\n", "authors": ["157"]}
{"title": "Statistical errors in software engineering experiments: A preliminary literature review\n", "abstract": " Background: Statistical concepts and techniques are often applied incorrectly, even in mature disciplines such as medicine or psychology. Surprisingly, there are very few works that study statistical problems in software engineering (SE). Aim: Assess the existence of statistical errors in SE experiments. Method: Compile the most common statistical errors in experimental disciplines. Survey experiments published in ICSE to assess whether errors occur in high quality SE publications. Results: The same errors as identified in others disciplines were found in ICSE experiments, where 30 of the reviewed papers included several error types such as: a) missing statistical hypotheses, b) missing sample size calculation, c) failure to assess statistical test assumptions, and d) uncorrected multiple testing. This rather large error rate is greater for research papers where experiments are confined to the validation section. The\u00a0\u2026", "num_citations": "9\n", "authors": ["157"]}
{"title": "Contextual attributes impacting the effectiveness of requirements elicitation Techniques: Mapping theoretical and empirical research\n", "abstract": " Background: Software engineers can utilise a myriad of elicitation techniques to capture relevant information in order to specify requirements. The effectiveness of these techniques varies depending on the context in which the elicitation takes place. So, it is important to identify the attributes that represent this context. Objective: This paper aims to match theoretical to empirical research on contextual attributes that influence elicitation technique effectiveness. Method: We conduct a systematic mapping study to identify proposed attributes (by theoretical works) and attributes studied empirically. Then we map empirical results with theoretical proposals. Results: 60% of theoretically proposed attributes have been studied empirically. There seems to be some degree of coordination between theory and empiricism. However, there is empirical confirmation of the impact of only a third of the theoretically proposed attributes\u00a0\u2026", "num_citations": "9\n", "authors": ["157"]}
{"title": "Reusable solutions for implementing usability functionalities\n", "abstract": " Usability is a software system quality attribute. Although software engineers originally considered usability to be related exclusively to the user interface, it was later found to affect the core functionality of software applications. As of then, proposals for addressing usability at different stages of the software development cycle were researched. The objective of this paper is to present three reusable solutions at detailed design and programming level in order to effectively implement the Abort Operation, Progress Feedback and Preferences usability functionalities in web applications. To do this, an inductive research method was applied. We developed three web applications including the above usability functionalities as case studies. We looked for commonalities across the implementations in order to induce a general solution. The elements common to all three developed applications include: application scenarios\u00a0\u2026", "num_citations": "9\n", "authors": ["157"]}
{"title": "Estudio experimental de la efectividad de la entrevista abierta frente a la entrevista independiente de contexto\n", "abstract": " OBJETIVO: Estudiar la efectividad relativa de las t\u00e9cnicas de entrevista abierta y entrevista independiente de contexto en la identificaci\u00f3n de requisitos para sistemas software. M\u00c9TODO: Experimento controlado ensayando dos factores:\u201ctipo de entrevista\u201d(abierta e independiente de contexto) y \u201ctipo de problema\u201d(identificaci\u00f3n de requisitos para dos sistemas software distintos). Debido al reducido n\u00famero de sujetos experimentales, se ha utilizado un dise\u00f1o de medidas repetidas dentro de los sujetos. RESULTADOS: El poder estad\u00edstico del estudio es en general insuficiente, pero hemos podido constatar que el tipo de problema posee efectos significativos en la efectividad del proceso de relevamiento de requisitos. La experiencia del analista juega tambi\u00e9n un papel importante. El tipo de entrevista utilizada afecta en mucha menor medida. CONCLUSIONES: Es necesario comprender mejor qu\u00e9 es un problema de relevamiento de requisitos. Esto nos permitir\u00e1 dise\u00f1ar estrategias m\u00e1s eficaces para una identificaci\u00f3n certera de los requisitos del software.", "num_citations": "9\n", "authors": ["157"]}
{"title": "The risk of using the Q heterogeneity estimator for software engineering experiments\n", "abstract": " All meta-analyses should include a heterogeneity analysis. Even so, it is not easy to decide whether a set of studies are homogeneous or heterogeneous because of the low statistical power of the statistics used (usually the Q test). Objective: Determine a set of rules enabling SE researchers to find out, based on the characteristics of the experiments to be aggregated, whether or not it is feasible to accurately detect heterogeneity. Method: Evaluate the statistical power of heterogeneity detection methods using a Monte Carlo simulation process. Results: The Q test is not powerful when the meta-analysis contains up to a total of about 200 experimental subjects and the effect size difference is less than 1. Conclusions: The Q test cannot be used as a decision-making criterion for meta-analysis in small sample settings like SE. Random effects models should be used instead of fixed effects models. Caution should be\u00a0\u2026", "num_citations": "8\n", "authors": ["157"]}
{"title": "Structuring the knowledge-based systems evaluation process\n", "abstract": " Knowledge-based systems (KBS) evaluation is still an obscure issue for practitioners who need to plan, control and conduct the evaluation process. This situation can be partly put down to the fact that there are no general models or frameworks for KBS evaluation. This means that engineers cannot plan the evaluation process and that it is difficult to place individual research contributions within the overall evaluation process. This paper provides an in-depth discussion of the types of evaluation to be conducted on a KBS, including what and how to evaluate.", "num_citations": "7\n", "authors": ["157"]}
{"title": "Applying Metrics to Machine-Learning Tools: A Knowledge Engineering Approach\n", "abstract": " The field of knowledge engineering has been one of the most visible successes of AI to date. Knowledge acquisition is the main bottleneck in the knowledge engineer's work. Machine-learning tools have contributed positively to the process of trying to eliminate or open up this bottleneck, but how do we know whether the field is progressing? How can we determine the progress made in any of its branches? How can we be sure of an advance and take advantage of it? This article proposes a benchmark as a classificatory, comparative, and metric criterion for machine-learning tools. The benchmark centers on the knowledge engineering viewpoint, covering some of the characteristics the knowledge engineer wants to find in a machine-learning tool. The proposed model has been applied to a set of machine-learning tools, comparing expected and obtained results. Experimentation validated the model and led to interesting results.", "num_citations": "7\n", "authors": ["157"]}
{"title": "A procedure and guidelines for analyzing groups of software engineering replications\n", "abstract": " Context: Researchers from different groups and institutions are collaborating on building groups of experiments by means of replication (i.e., conducting groups of replications). Disparate aggregation techniques are being applied to analyze groups of replications. The application of unsuitable techniques to aggregate replication results may undermine the potential of groups of replications to provide in-depth insights from experiment results. Objectives: Provide an analysis procedure with a set of embedded guidelines to aggregate software engineering (SE) replication results. Method: We compare the characteristics of groups of replications for SE and other mature experimental disciplines such as medicine and pharmacology. In view of their differences, the limitations with regard to the joint data analysis of groups of SE replications and the guidelines provided in mature experimental disciplines to analyze groups of\u00a0\u2026", "num_citations": "6\n", "authors": ["157"]}
{"title": "Does the performance of TDD hold across software companies and premises? A group of industrial experiments on TDD\n", "abstract": " Test-Driven Development (TDD) has been claimed to increase external software quality. However, the extent to which TDD increases external quality has been seldom studied in industrial experiments. We conduct four industrial experiments in two different companies to evaluate the performance of TDD on external quality. We study whether the performance of TDD holds across the premises of the same company and across companies. We identify participant-level characteristics impacting results. Iterative-Test Last (ITL), the reverse approach of TDD, outperforms TDD in three out of four premises. ITL outperforms TDD in both companies. The larger the experience with unit testing and testing tools, the larger the difference in performance between ITL and TDD (in favour of ITL). Technological environment (i.e., programming language and testing tool) seems not to impact results. Evaluating participant-level\u00a0\u2026", "num_citations": "6\n", "authors": ["157"]}
{"title": "A systematic mapping study on testing technique experiments: has the situation changed since 2000?\n", "abstract": " Context: Juristo et al.[7] published a literature review about testing technique experiments. The goal was to provide a picture of which techniques and aspects of techniques had been studied experimentally, and try to compile a body of knowledge on testing techniques. Goal: In this paper, we extend Juristo et al.'s study to cover the years from 2000 (where it ended) until 2013. Method: We have performed a systematic mapping study. Results: The situation in testing experimentation has not changed since Juristo et al.'s study. Conclusions: The research field has the same shortcomings.", "num_citations": "6\n", "authors": ["157"]}
{"title": "An agile-based integrated framework for mobile application development considering ilities\n", "abstract": " The development of mobile apps during the last decade has had a significant increase in its share of the software market. While there are specific characteristics that separate it from traditional software development, there is a lack of guidance on issues encountered during the mobile software development process. With the aim of defining a mobile application development framework that considers the specific characteristics of developing mobile apps, we started by carrying out a systematic mapping study of the software development process for mobile applications, then we administered a survey and completed a qualitative study with industry experts. These studies allowed us to identify the main trends in the software process for mobile apps, and to uncover the main challenges for app development. We have organized the findings in a framework that integrates the specific challenges of mobile development\u00a0\u2026", "num_citations": "5\n", "authors": ["157"]}
{"title": "Introducing usability in a conceptual modeling-based software development process\n", "abstract": " Usability plays an important role to satisfy users\u2019 needs. There are many recommendations in the HCI literature on how to improve software usability. Our research focuses on such recommendations that affect the system architecture rather than just the interface. However, improving software usability in aspects that affect architecture increases the analyst\u2019s workload and development complexity. This paper proposes a solution based on model-driven development. We propose representing functional usability mechanisms abstractly by means of conceptual primitives. The analyst will use these primitives to incorporate functional usability features at the early stages of the development process. Following the model-driven development paradigm, these features are then automatically transformed into subsequent steps of development, a practice that is hidden from the analyst.", "num_citations": "5\n", "authors": ["157"]}
{"title": "Avoiding \"We Can't Change THAT!\": Software Architecture & Usability\n", "abstract": " The usability analyses or user test data are in; the development team is poised to respond. The software had been carefully modularized so that modifications to the UI would be fast and easy. When the usability problems are presented, someone around the table exclaims,\u201cOh, no, we can\u2019t change THAT!\u201d The requested modification or feature reaches too far in to the architecture of the system to allow economically viable and timely changes to be made. Even when the functionality is right, even when the UI is separated from that functionality, architectural decisions made early in development have precluded the implementation of a usable system. The members of the design team are frustrated and disappointed that despite their best efforts, despite following current best practice, they must ship a product that is far less useable than they know it could be. This scenario need not be played out if usability concerns are considered during the earliest design decisions of a system, that is, during the architectural design, just as concerns for performance, availability, security, modifiability, and other quality attributes are considered. The relationships between these attributes and architectural decisions are relatively well understood and taught routinely in software architecture courses. However, the prevailing wisdom in the last 20 years has been that usability had no architectural role except through modifiability; design the UI to be easily modified and usability will be realized through iterative design, analysis and testing. Separation of the user interface has been quite effective, and is commonly used in practice, but it has problems. First, there are many\u00a0\u2026", "num_citations": "5\n", "authors": ["157"]}
{"title": "Knowledge-based system for generating administrative grant alternatives applying the IDEAL methodology\n", "abstract": " In this paper, we analyze how regulations are arranged and implemented in a knowledge-based system (KBS) to provide for ease of use, modification and addition of new regulations. The IDEAL methodology was used to achieve this objective. Different common agricultural policy (CAP) grants to which farmers in Spain are entitled were considered to validate the model. The system is a query system and the end users are specialists from the Agricultural Extension Services (AES). The system has been implemented using the tool Kappa-PC, V. 2.3. The prototype was developed jointly with the Universidad Polit\u00e9cnica de Madrid's Departments of Artificial Intelligence, Rural Projects and Planning and Mathematics Applied to Agronomy and the Castile and Le\u00f3n Government's Provincial Agriculture Office in Segovia.", "num_citations": "5\n", "authors": ["157"]}
{"title": "Researcher Bias in Software Engineering Experiments: a Qualitative Investigation\n", "abstract": " Researcher Bias (RB) occurs when researchers influence the results of an empirical study based on their expectations. RB might be due to the use of Questionable Research Practices (QRPs). In research fields like medicine, blinding techniques have been applied to counteract RB. We conducted an explorative qualitative survey to investigate RB in Software Engineering (SE) experiments, with respect to: (i) QRPs potentially leading to RB, (ii) causes behind RB, and (iii) possible actions to counteract RB including blinding techniques. Data collection was based on semi-structured interviews. We interviewed nine active experts in the empirical SE community. We then analyzed the transcripts of these interviews through thematic analysis. We found that some QRPs are acceptable in certain cases. Also, it appears that the presence of RB is perceived in SE and, to counteract RB, a number of solutions have been\u00a0\u2026", "num_citations": "4\n", "authors": ["157"]}
{"title": "Comparing techniques for aggregating interrelated replications in software engineering\n", "abstract": " Context: Researchers from different groups and institutions are collaborating towards the construction of groups of interrelated replications. Applying unsuitable techniques to aggregate interrelated replications' results may impact the reliability of joint conclusions.Objectives: Comparing the advantages and disadvantages of the techniques applied to aggregate interrelated replications' results in Software Engineering (SE).Method: We conducted a literature review to identify the techniques applied to aggregate interrelated replications' results in SE. We analyze a prototypical group of interrelated replications in SE with the techniques that we identified. We check whether the advantages and disadvantages of each technique---according to mature experimental disciplines such as medicine---materialize in the SE context.Results: Narrative synthesis and Aggregation of p-values do not take advantage of all the\u00a0\u2026", "num_citations": "4\n", "authors": ["157"]}
{"title": "Experiences conducting experiments in industry: the ESEIL FiDiPro project\n", "abstract": " The Experimental Software Engineering Industry Laboratory (ESEIL) project funded by the Finland Distinguished Professor Programme (FiDiPro) kicked off in January 2013. The aim of this research is to gain insight into whether experiments in the software industry can play the role of clinical trials in medicine, that is, field test laboratory findings, acting as the last link in the experimental chain. Besides this research goal, we believe that companies can benefit from the conducted experiments by applying the resulting evidence in their decision-making processes.", "num_citations": "4\n", "authors": ["157"]}
{"title": "Effectiveness for detecting faults within and outside the scope of testing techniques: a controlled experiment\n", "abstract": " Software testing techniques generate test cases according to different strategies. These strategies focus on specific software aspects. This suggests that, although techniques are capable of detecting very wide-ranging faults, there may be faults that they are unable to detect. In other words, a testing technique\u2019s detection strategy might determine the faults that are within and outside its scope. This paper studies how two testing techniques (equivalence partitioning and branch testing) behave towards the faults that are within and outside their scope. To do this, we study each technique\u2019s test generation strategy. This way we are able to identify which faults fall within and outside its scope. Then we run a controlled experiment in which students apply the techniques on different programs that have been seeded with faults within and outside each technique\u2019s scope. We analyse the techniques\u2019 capability to detect faults within their scope and faults outside their scope. Subjects do not apply techniques strictly in conformance with their strategy. Equivalence partitioning and branch testing are similarly effective for faults within their scope. Branch testing is more effective than equivalence partitioning at detecting faults outside its scope. Therefore testing technique effectiveness depends on the type of faults. It is advisable, with a view to effective validation and verification, to use a combination of techniques.", "num_citations": "4\n", "authors": ["157"]}
{"title": "Software Engineering and Knowledge Engineering\n", "abstract": " Software Engineering and Knowledge Engineering \u00d7 Close The Infona portal uses cookies, ie strings of text saved by a browser on the user's device. The portal can access those files and use them to remember the user's data, such as their chosen settings (screen view, interface language, etc.), or their login data. By using the Infona portal the user accepts automatic saving and using this information for portal operation purposes. More information on the subject can be found in the Privacy Policy and Terms of Service. By closing this window the user confirms that they have read the information on cookie usage, and they accept the privacy policy and the way cookies are used by the portal. You can change the cookie settings in your browser. I accept Polski English Login or register account remember me Password recovery INFONA - science communication portal INFONA Search advanced search Browse series \u00d7 and \u2026", "num_citations": "4\n", "authors": ["157"]}
{"title": "Methodological proposal for modelling and implementing regulation application problems in a knowledge-based system\n", "abstract": " In this paper, a methodology is proposed for designing and constructing a knowledge-based system (KBS) in order to generate and evaluate administrative grants. The methodology is applied to the Common Agricultural Policy regulations covering Spanish farmers for validation. The proposed methodology facilitates the development of applications of this type from preliminary problem analysis to application implementation and maintenance. This methodology is well adapted to the characteristics of the knowledge-based software under development: open requirements and diverse computational models. It constitutes a complete guide for the knowledge engineer in producing and maintaining an automated solution to a real-world problem, as the methodology is not only declarative (i.e. indicates what to do) but also procedural (i.e. indicates how to do it). The KBS demonstrator built is a query system for use by\u00a0\u2026", "num_citations": "4\n", "authors": ["157"]}
{"title": "An expert system in the domain of software technology transfer\n", "abstract": " In this paper, we discuss all of the steps needed to build an expert system (ES) in the domain of technology transfer into an organization. Firstly, there is an introduction about the domain and the problems involved in software technology transfer (TT) into an organization, followed by a description of the usefulness of an advisory and planning ES to guide an inexperienced change agent in such activities. Secondly, we discuss the methodology-based construction of the ES and show the different phases and stages of the process. We detail a knowledge acquisition method used to both elicit knowledge and organize that knowledge as a task model. The conceptualization phase, closely linked with the above knowledge structuring step, establishes the concepts, relations and functions handled by TT. The result is a set of individualized tasks that make up a complete transfer plan. As regards formalization, system\u00a0\u2026", "num_citations": "4\n", "authors": ["157"]}
{"title": "Comparing the results of replications in software engineering\n", "abstract": " ObjectiveStudy how to assess the (dis) similarity of the results of SE replications when they are compared to verify the results of previous experiments and understand how to identify whether contextual variables are influencing results.MethodWe run simulations to learn how different ways of comparing replication results behave when verifying the results of previous experiments. We illustrate how to deal with context-induced changes. To do this, we analyze three groups of replications from our own research on test-driven development and testing techniques.ResultsThe direct comparison of p-values and effect sizes does not appear to be suitable for verifying the results of previous experiments and examining the variables possibly affecting the results in software engineering. Analytical methods such as meta-analysis should be used to assess the similarity of software engineering replication results and identify\u00a0\u2026", "num_citations": "3\n", "authors": ["157"]}
{"title": "A software engineering experiments to value mde in testing. learning lessons\n", "abstract": " Controlled experiments are commonly used to evaluate Software Engineering methods, processes and tools. Validating results of Software Engineering research in industrial settings is a direct way to obtain feedback about its value. However, few software engineering experiments are running in industry. The lack of communication between companies and research teams does not make the necessary cooperation among them possible. This paper presents our experiences when running an experiment dealing with Early Testing at the University of Seville. It also introduces the strategy we followed to obtain the participation of 97 practitioners from 32 different software companies. Such strategy is pointed out as a set of guidelines to successfully involve this large number of companies and practitioners.", "num_citations": "3\n", "authors": ["157"]}
{"title": "Towards understanding replication of software engineering experiments\n", "abstract": " Summary form only given. To consolidate a body of knowledge built upon evidence, experimental results have to be extensively verified. Experiments need replication at other times and under other conditions before they can produce an established piece of knowledge. Several replications need to be run to strengthen the evidence. Most SE experiments have not been replicated. If an experiment is not replicated, there is no way to distinguish whether results were produced by chance (the observed event occurred accidentally), results are artifactual (the event occurred because of the experimental configuration but does not exist in reality) or results conform to a pattern existing in reality. The immaturity of experimental SE knowledge has been an obstacle to replication. Context differences usually oblige SE experimenters to adapt experiments for replication. As key experimental conditions are yet unknown, slight\u00a0\u2026", "num_citations": "3\n", "authors": ["157"]}
{"title": "In search of requirements analyst characteristics that influence requirements elicitation effectiveness: A quasi-experiment\n", "abstract": " Context: Elicitation effectiveness depends on non-well-understood analyst\u2019s skills and abilities. Identifying which analysts\u2019 characteristics have stronger influence on elicitation may help to improve requirements quality. Objective: Identify the analysts\u2019 characteristics that influence on the elicitation effectiveness. Method: We analyzed the impact of: the analyst\u2019s experience in interviews, elicitation and requirements; their academic qualifications, the familiarity with problem domain and the time spent during the elicitation session in the effectiveness of the elicitation and subsequent consolidation of requirements, using a quasi-experiment. Results: The knowledge of the problem domain, the analysts\u2019 academic qualifications and the elicitation time do not appear to influence the effectiveness of the elicitation sessions. The analyst\u2019s experience exerts a slight negative influence on the effectiveness of the elicitation session. The analyst\u2019s experience and familiarity with problem domain adversely affect the consolidation process. Finally, the analyst\u2019s academic qualifications have a strong positive impact (statistically significant) on the effectiveness of the consolidation process. Conclusions: Although the evidence is still scarce, it seems the analyst's confidence on his own experience may be harmful in some cases. Specific training in software requirements may yield much higher gains than non-specific analyst experience.", "num_citations": "3\n", "authors": ["157"]}
{"title": "Increasing validity through replication: an illustrative TDD case\n", "abstract": " Context: Software Engineering (SE) experiments suffer from threats to validity that may impact their results. Replication allows researchers building on top of previous experiments' weaknesses and increasing the reliability of the findings. Objective: Illustrating the benefits of replication to increase the reliability of the findings and uncover moderator variables. Method: We replicate an experiment on Test-Driven-Development (TDD) and address some of its threats to validity and those of a previous replication. We compare the replications' results and hypothesize on plausible moderators impacting results. Results: Differences across TDD replications' results might be due to the operationalization of the response variables, the allocation of subjects to treatments, the allowance to work outside the laboratory, the provision of stubs, or the task. Conclusion: Replications allow examining the robustness of the findings, hypothesizing on plausible moderators influencing results, and strengthening the evidence obtained.", "num_citations": "2\n", "authors": ["157"]}
{"title": "Improving Development Practices through Experimentation: An Industrial TDD Case\n", "abstract": " Test-Driven Development (TDD), an agile development approach that enforces the construction of software systems by means of successive micro-iterative testing coding cycles, has been widely claimed to increase external software quality. In view of this, some managers at Paf-a Nordic gaming entertainment company-were interested in knowing how would TDD perform at their premises. Eventually, if TDD outperformed their traditional way of coding (i.e., YW, short for Your Way), it would be possible to switch to TDD considering the empirical evidence achieved at the company level. We conduct an experiment at Paf to evaluate the performance of TDD, YW and the reverse approach of TDD (i.e., ITL, short for Iterative-Test Last) on external quality. TDD outperforms YW and ITL at Paf. Despite the encouraging results, we cannot recommend Paf to immediately adopt TDD as the difference in performance between YW\u00a0\u2026", "num_citations": "2\n", "authors": ["157"]}
{"title": "Moving beyond the mean: Analyzing variance in software engineering experiments\n", "abstract": " Software Engineering (SE) experiments are traditionally analyzed with statistical tests (e.g., t-tests, ANOVAs, etc.) that assume equally spread data across groups (i.e., the homogeneity of variances assumption). Differences across groups\u2019 variances in SE are not seen as an opportunity to gain insights on technology performance, but instead, as a hindrance to analyze the data. We have studied the role of variance in mature experimental disciplines such as medicine. We illustrate the extent to which variance may inform on technology performance by means of simulation. We analyze a real-life industrial experiment on Test-Driven Development (TDD) where variance may impact technology desirability. Evaluating the performance of technologies just based on means\u2014as traditionally done in SE\u2014may be misleading. Technologies that make developers obtain similar performance (i.e., technologies with\u00a0\u2026", "num_citations": "2\n", "authors": ["157"]}
{"title": "Does subject type influence software engineering experiment results?\n", "abstract": " Context: A key issue when dealing with the generalization threat of software engineering experiments is to use different subject types. Objective: In this paper, we aim to investigate which subject types are used in experiments and their impact on results. Method: We have performed a systematic mapping study by manually searching experiments published from January 2014 to June 2016 in six leading software engineering conferences and journals. Results: Out of the 833 papers published in the period covered, we have identified 93 papers reporting experiments with subjects. Of these, 27 papers report experiments that have two subject types (professionals and students). We have studied the impact of subject type on the results of experiments reported in 11 of these papers. Conclusion: We have observed contradictory results. Only in some cases subject type influences experimental results. This suggests that\u00a0\u2026", "num_citations": "2\n", "authors": ["157"]}
{"title": "Once is not enough: Why we need replication\n", "abstract": " Imagine you land on an uncharted planet where no human has been before. For one reason or another, you are unable to leave the spaceship to explore the unknown, and you can only gather information about the planet through the spaceship windows. You look out and see a strange being: an alien of a shape, size, and color that you could have never imagined. You are extremely surprised, and you carry on looking at it in order to unlock the mystery and form an idea of what sort of thing you have in your sights. Are you sure that what your eyes are seeing (and your brain is perceiving) through the window really is a true likeness of the outside world? What if the food you had to eat last night had gone off? What if you are seeing things, and there really is nothing out there? What would you do to make sure?", "num_citations": "2\n", "authors": ["157"]}
{"title": "Challenges of Evaluating the Quality of Software Engineering Experiments\n", "abstract": " Good-quality experiments are free of bias. Bias is considered to be related to internal validity (e.g., how well experiments are planned, designed, executed, and analysed). Quality scales and expert opinion are two approaches for assessing the quality of experiments. Aim: Identify whether there is a relationship between bias and quality scale and expert opinion predictions in SE experiments. Method: We used a quality scale to determine the quality of 35 experiments from three systematic literature reviews. We used two different procedures (effect size and response ratio) to calculate the bias in diverse response variables for the above experiments. Experienced researchers assessed the quality of these experiments. We analysed the correlations between the quality scores, bias and expert opinion. Results: The relationship between quality scales, expert opinion and bias depends on the technology exercised\u00a0\u2026", "num_citations": "2\n", "authors": ["157"]}
{"title": "Ingenier\u00eda del Conocimiento\n", "abstract": " \u2022 Ser capaz de tener un conocimiento profundo de los principios fundamentales y modelos de la computaci\u00f3n y saberlos aplicar para interpretar, seleccionar, valorar, modelar, y crear nuevos conceptos, teor\u00edas, usos y desarrollos tecnol\u00f3gicos relacionados con la inform\u00e1tica.\u2022 Ser capaz de evaluar la complejidad computacional de un problema, conocer estrategias algor\u00edtmicas que puedan conducir a su resoluci\u00f3n y recomendar, desarrollar e implementar aquella que garantice el mejor rendimiento de acuerdo con los requisitos establecidos.\u2022 Ser capaz de conocer los fundamentos, paradigmas y t\u00e9cnicas propias de los sistemas inteligentes y analizar, dise\u00f1ar y construir sistemas, servicios y aplicaciones inform\u00e1ticas que utilicen dichas t\u00e9cnicas en cualquier \u00e1mbito de aplicaci\u00f3n.", "num_citations": "2\n", "authors": ["157"]}
{"title": "A prototype knowledge-based tool for software engineering adoption and implementation\n", "abstract": " This paper describes work that explores how tools can help change agents in software organizations incorporate new software engineering tools and methods more effectively. A prototype expert system was built to assist change agents in gathering information and planning tasks in a software engineering adoption and implementation effort. The knowledge engineering process for this system helped to integrate and translate research and practice from software engineering technology adoption and implementation within the field of technology transfer and diffusion of innovation for software change agents.", "num_citations": "2\n", "authors": ["157"]}
{"title": "Studying test-driven development and its retainment over a six-month time span\n", "abstract": " In this paper, we investigate the effect of TDD, as compared to a non-TDD approach, as well as its retainment (or retention) over a time span of (about) six months. To pursue these objectives, we conducted a (quantitative) longitudinal cohort study with 30 novice developers (i.e., third-year undergraduate students in Computer Science). We observed that TDD affects neither the external quality of software products nor developers\u2019 productivity. However, we observed that the participants applying TDD produced significantly more tests, with a higher fault-detection capability, than those using a non-TDD approach. As for the retainment of TDD, we found that TDD is retained by novice developers for at least six months.", "num_citations": "1\n", "authors": ["157"]}
{"title": "Poster: The effect of noise on requirements comprehension\n", "abstract": " We conducted a controlled experiment with 55 final-year undergraduate students in Computer Science. We asked them to comprehend functional requirements exposing them or not to noise. We did not observe any effect of noise on requirements comprehension.", "num_citations": "1\n", "authors": ["157"]}
{"title": "Analyzing software engineering experiments: everything you always wanted to know but were afraid to ask\n", "abstract": " Experimentation is a key issue in science and engineering. But it is one of software engineering's stumbling blocks. Quite a lot of experiments are run nowadays, but it is a risky business. Software engineering has some special features, leading to some experimentation issues being conceived of differently than in other disciplines. The aim of this technical briefing is to help participants to avoid common pitfalls when analyzing the results of software engineering experiments. The technical briefing is not intended as a data analysis course, because there is already plenty of literature on this subject. It reviews several issues that we have identified in published SE experiments.", "num_citations": "1\n", "authors": ["157"]}
{"title": "Proposal of a quasi-experiment for studying the effect of experience on elicitation effectiveness\n", "abstract": " We plan to perform a quasi experiment to evaluate the effect of experience on requirements elicitation. Researchers will play the role of customers, whereas participants will perform the role of analysts. Analysts will hold a 60 minute interview and will then be given 25 minutes to write up a report of their findings. Participant effectiveness will be compared with available data series on the effectiveness of novice analysts that we have collected previously.", "num_citations": "1\n", "authors": ["157"]}
{"title": "Product-Focused Software Process Improvement: 13th International Conference, PROFES 2012, Madrid, Spain, June 13-15, 2012, Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 13 International Conference on Product-Focused Software Process Improvement, PROFES 2012, held in Madrid, Spain, in June 2012. The 21 revised full papers presented together with 3 short papers and 4 workshop and tutorial papers were carefully reviewed and selected from 49 submissions. The papers are organized in topical sections on process focused software process improvement, open-source agile and lean practices, product and process measurements and estimation, distributed and global software development, quality assessment, and empirical studies.", "num_citations": "1\n", "authors": ["157"]}
{"title": "Do Testers' Preferences Have an Impact on Effectiveness?\n", "abstract": " Both verification and validation aim to improve the quality of software products during the development process. They use techniques like formal methods, symbolic execution, formal reviews, testing techniques, etc. Technique effectiveness depends not only on project size and complexity but also on the experience of the subject responsible for testing. We have looked at whether the opinions and preferences of subjects match the number of detected defects. Opinions and preferences can influence the decisions that testers have to make. In this paper, we present a piece of research that has explored this aspect by comparing the opinions of subjects (qualitative aspects) with the quantitative results. To do this, we use qualitative methods applied to a quantitative study of code evaluation technique effectiveness.", "num_citations": "1\n", "authors": ["157"]}
{"title": "Requirements Engineering Research: A Microcosm of International Economic Trends\n", "abstract": " A major goal of requirements engineering (RE) research is to improve society\u2019s knowledge and practice of the RE discipline so as to positively impact society\u2019s ability to build new, ever more effective software systems. Since software systems now permeate almost every aspect of society, success in constructing such systems should benefit the economies of countries utilizing them. This paper begins to explore this new field of research, namely the macro-economic implications of RE research. Specifically, the present paper analyzes RE research publication trends (as a surrogate for RE research activity) by country and geographical region, and then compares those trends to key economic indicators. These analyses identified some very interesting correlations between publication trends and the economic indicators, encouraging us to explore the nature of these relationships in future research.", "num_citations": "1\n", "authors": ["157"]}
{"title": "How much can you learn? A new learning metric\n", "abstract": " 2. MethodAll processes have a method. Where research is involved in the process, the method becomes necessary and will raise the possibilities of final success. The method utilized is basically composed of the following steps:", "num_citations": "1\n", "authors": ["157"]}
{"title": "M\u00e9todo de construcci\u00f3n del n\u00facleo de una base de conocimientos a partir de un modelo de clasificaci\u00f3n documental\n", "abstract": " There is a problem during knowledge acquisition that produces low efficiency in this process, an increase of costs and possibly a bad methodical arrangement. This matter isthe bad structured, and that's why bad used, task of collecting \u00a1nformation from the general documentation of the domain. This paper suggests to go through the needs before proposed. The main idea of this thesis, is the definition of degrees of knowledge that can be located in written documentation and, its equivalence with degrees of knowledge related to a knowledge base. In other words, the key is to get a conversi\u00f3n from the textual structures of a document to the cognitive structures of a knowledge base.---ABSTRACT---Existe un problema durante la fase de adquisici\u00f3n de conocimiento que origina una baja eficiencia de la misma, un encarecimiento de costes, y posiblemente una mala ordenaci\u00f3n metodol\u00f3gica de todo el proceso. Este problema no es otro que el mal estructurado, y por tanto mal aprovechado, proceso de captaci\u00f3n de conocimiento a partir de la documentaci\u00f3n general del dominio de trabajo. La idea base de este trabajo es la definici\u00f3n de los grados de conocimiento que pueden encontrarse en documentos escritos y, su equivalencia con los grados de conocimiento que pueden aparecer en una base de conocimientos. Es decir, se pretende establecer una conversi\u00f3n desde las estructuras presentes en un documento a las estructuras conceptuales propias de una base de conocimientos.", "num_citations": "1\n", "authors": ["157"]}