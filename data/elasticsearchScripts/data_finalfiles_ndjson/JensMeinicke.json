{"title": "Faster variational execution with transparent bytecode transformation\n", "abstract": " Variational execution is a novel dynamic analysis technique for exploring highly configurable systems and accurately tracking information flow. It is able to efficiently analyze many configurations by aggressively sharing redundancies of program executions. The idea of variational execution has been demonstrated to be effective in exploring variations in the program, especially when the configuration space grows out of control. Existing implementations of variational execution often require heavy lifting of the runtime interpreter, which is painstaking and error-prone. Furthermore, the performance of this approach is suboptimal. For example, the state-of-the-art variational execution interpreter for Java, VarexJ, slows down executions by 100 to 800 times over a single execution for small to medium size Java programs. Instead of modifying existing JVMs, we propose to transform existing bytecode to make it variational\u00a0\u2026", "num_citations": "21\n", "authors": ["1831"]}
{"title": "A Choice of Variational Stacks: Exploring Variational Data Structures\n", "abstract": " Many applications require not only representing variability in software and data, but also computing with it. To do so efficiently requires variational data structures that make the variability explicit in the underlying data and the operations used to manipulate it. Variational data structures have been developed ad hoc for many applications, but there is little general understanding of how to design them or what tradeoffs exist among them. In this paper, we strive for a more systematic exploration and analysis of a variational data structure. We want to know how different design decisions affect the performance and scalability of a variational data structure, and what properties of the underlying data and operation sequences need to be considered. Specifically, we study several alternative designs of a variational stack, a data structure that supports efficiently representing and computing with multiple variants of a plain stack\u00a0\u2026", "num_citations": "12\n", "authors": ["1831"]}
{"title": "VarexJ: A Variability-Aware Interpreter for Java Applications\n", "abstract": " Many modern software systems can be customized to fulfill specific customer needs. Customization improves quality, extensibility, and usability. However, customization also comes with challenges for software analyses, because of the configuration space explosion. To analyze all configurations in isolation is expensive and often impractical. A main goal of current research on configurable systems is to provide new techniques to analyze all configurations. For some static analyses, such as type safety, this is already feasible by considering variability internally. When testing configurable software usually sampling strategies are used to test a subset of all configurations. These approaches might miss faults that are only contained in specific configurations and require redundant calculations. In this work, we use an approach where several configurations can be executed at once, while redundant calculations can be avoided, and thus effort for testing can be reduced. Based on previous work on variability-aware execution, we discuss how a Java Virtual Machine can be lifted to handle variability internally to execute all combinations of configuration options simultaneously. Specifically, we lifted the interpreter of Java Pathfinder. We show the variability-aware interpreter reduces time for testing of all configurations by orders of magnitude compared to testing of all program variants. We applied the interpreter to 10 configurable programs and gain a speed-up of up to 2,843 compared to brute-force execution. Variability-aware execution can lead to a new way of testing and analyzing configurable systems.", "num_citations": "11\n", "authors": ["1831"]}
{"title": "Beyond testing configurable systems: applying variational execution to automatic program repair and higher order mutation testing\n", "abstract": " Generate-and-validate automatic program repair and higher order mutation testing often use search-based techniques to find optimal or good enough solutions in huge search spaces. As search spaces continue to grow, finding solutions that require interactions of multiple changes can become challenging. To tackle the huge search space, we propose to use variational execution. Variational execution has been shown to be effective in exhaustively exploring variations and identifying interactions in a huge but often finite configuration space. The key idea is to encode alternatives in the search space as variations and use variational execution as a black-box technique to generate useful insights so that existing search heuristics can be informed. We show that this idea is promising and identify criteria for problems in which variational execution is a promising tool, which may be useful to identify further applications.", "num_citations": "9\n", "authors": ["1831"]}
{"title": "JML-Based Verification for Feature-Oriented Programming\n", "abstract": " A software product line is a set of similar software products sharing a common code base. The usage of software product lines in safety-critical systems increases, but their analysis has not gained much attention so far. Generation and verification of a certain product can be done efficiently, but analysis of all products requires a large effort. This work is based on an approach to efficiently verify a whole software product line. At this approach a metaproduct represents all products of a software product line. It can be verified efficiently with the same results as to verify each product individually. However, currently this metaproduct has to be written manually, which requires high effort and is an error prone task. Based on a feature-oriented extension of Java and the Java Modeling Language we provide a tool to automatically generate a metaproduct. The metaproduct can be used to verify all products of the product line without the need to generate them. We show that our approach saved about 94% of verification time and is able to save nearly the complete time for generation. Our approach provides a solution to verify software product lines for which it is practically impossible to generate all products.", "num_citations": "8\n", "authors": ["1831"]}