{"title": "Model transformation modularization as a many-objective optimization problem\n", "abstract": " Model transformation programs are iteratively refined, restructured, and evolved due to many reasons such as fixing bugs and adapting existing transformation rules to new metamodels version. Thus, modular design is a desirable property for model transformations as it can significantly improve their evolution, comprehensibility, maintainability, reusability, and thus, their overall quality. Although language support for modularization of model transformations is emerging, model transformations are created as monolithic artifacts containing a huge number of rules. To the best of our knowledge, the problem of automatically modularizing model transformation programs was not addressed before in the current literature. These programs written in transformation languages, such as ATL, are implemented as one main module including a huge number of rules. To tackle this problem and improve the quality and\u00a0\u2026", "num_citations": "62\n", "authors": ["553"]}
{"title": "Search-based detection of high-level model changes\n", "abstract": " Software models are iteratively refined, restructured and evolved. The detection and analysis of changes applied between two versions of a model are one of the most important tasks during evolution and maintenance activities. In this paper, we propose an approach to detect high-level model changes in terms of refactorings. Our approach takes as input an exhaustive list of possible refactorings, the initial model and revised model, and generates as output a list of detected changes representing a sequence of refactorings. A solution is defined as a combination of refactorings that should maximize as much as possible the similarity between the expected revised model and the generated model after applying the refactoring sequence on the initial model. Due to the huge number of possible refactoring combinations, a heuristic method is used to explore the space of possible solutions. To this end, we used and\u00a0\u2026", "num_citations": "57\n", "authors": ["553"]}
{"title": "Multi-objective code-smells detection using good and bad design examples\n", "abstract": " Code-smells are identified, in general, by using a set of detection rules. These rules are manually defined to identify the key symptoms that characterize a code-smell using combinations of mainly quantitative (metrics), structural, and/or lexical information. We propose in this work to consider the problem of code-smell detection as a multi-objective problem where examples of code-smells and well-designed code are used to generate detection rules. To this end, we use multi-objective genetic programming (MOGP) to find the best combination of metrics that maximizes the detection of code-smell examples and minimizes the detection of well-designed code examples. We evaluated our proposal on seven large open-source systems and found that, on average, most of the different five code-smell types were detected with an average of 87\u00a0% of precision and 92\u00a0% of recall. Statistical analysis of our experiments\u00a0\u2026", "num_citations": "56\n", "authors": ["553"]}
{"title": "Multi-view refactoring of class and activity diagrams using a multi-objective evolutionary algorithm\n", "abstract": " To improve the quality of software systems, one of the widely used techniques is refactoring defined as the process of improving the design of an existing system by changing its internal structure without altering the external behavior. The majority of existing refactoring work focuses mainly on the source code level. The suggestion of refactorings at the model level is more challenging due to the difficulty to evaluate: (a) the impact of the suggested refactorings applied to a diagram on other related diagrams to improve the overall system quality, (b) their feasibility, and (c) interdiagram consistency. We propose, in this paper, a novel framework that enables software designers to apply refactoring at the model level. To this end, we used a multi-objective evolutionary algorithm to find a trade-off between improving the quality of class and activity diagrams. The proposed multi-objective approach provides a multi\u00a0\u2026", "num_citations": "56\n", "authors": ["553"]}
{"title": "Model refactoring using interactive genetic algorithm\n", "abstract": " Refactoring aims at improving the quality of design while preserving its semantic. Providing an automatic support for refactoring is a challenging problem. This problem can be considered as an optimization problem where the goal is to find appropriate refactoring suggestions using a set of refactoring examples. However, some of the refactorings proposed using this approach do not necessarily make sense depending on the context and the semantic of the system under analysis. This paper proposes an approach that tackles this problem by adapting the Interactive Genetic Algorithm (IGA) which enables to interact with users and integrate their feedbacks into a classic GA. The proposed algorithm uses a fitness function that combines the structural similarity between the analyzed design model and models from a base of examples, and the designers\u2019 ratings of the refactorings proposed during execution of\u00a0\u2026", "num_citations": "52\n", "authors": ["553"]}
{"title": "On the use of design defect examples to detect model refactoring opportunities\n", "abstract": " Design defects are symptoms of design decay, which can lead to several maintenance problems. To detect these defects, most of existing research is based on the definition of rules that represent a combination of software metrics. These rules are sometimes not enough to detect design defects since it is difficult to find the best threshold values; the rules do not take into consideration the programming context, and it is challenging to find the best combination of metrics. As an alternative, we propose in this paper to identify design defects using a genetic algorithm based on the similarity/distance between the system under study and a set of defect examples without the need to define detection rules. We tested our approach on four open-source systems to identify three potential design defects. The results of our experiments confirm the effectiveness of the proposed approach.", "num_citations": "50\n", "authors": ["553"]}
{"title": "Searching models, modeling search: On the synergies of SBSE and MDE\n", "abstract": " In the past years, several researchers applied search-based optimization algorithms successfully in the software engineering domain to obtain automatically near-optimal solutions to complex problems posing huge solution spaces. More recently, such algorithms have also been proven useful for solving problems in model engineering. However, applying search-based optimization algorithms to problems in model engineering efficiently and effectively is a challenging endeavor demanding for expertize in both, search-based algorithms as well as model engineering formalisms and techniques. In this paper, we report on our experiences in applying such search-based algorithms for model engineering problems and propose a model-driven approach to ease the adoption of search-based algorithms for the area of model engineering.", "num_citations": "49\n", "authors": ["553"]}
{"title": "What you like in design use to correct bad-smells\n", "abstract": " Over the past decades, many techniques and tools have been developed to support maintenance activities in order to improve software quality. One of the most efficient ones is software refactoring to eliminate bad-smells. A majority of existing work propose \u201cstandard\u201d refactoring solutions that can be applied by hand for each kind of defect. However, it is difficult to prove or ensure the generality of these solutions to any kind of bad-smells or software codes. In this paper, we propose an approach to correct bad-smells using well-designed code. We use genetic algorithms to generate correction solutions defined as a combination of refactoring operations that maximize, as much as possible, the similarity between the corrected bad-smells and examples of well-designed code. We report the results of an evaluation of our approach using four open-source projects. Our proposal achieved high correction scores by\u00a0\u2026", "num_citations": "47\n", "authors": ["553"]}
{"title": "Detecting model refactoring opportunities using heuristic search\n", "abstract": " Model-driven engineering (MDE) is an approach to software development where the primary focus is on models. To improve their quality, models continually evolve due, for example, to the detection of \u201cbad design practices\u201d, called design defects. Presence of these defects in a model suggests refactoring opportunities. Most of the research work that tackle the problem of detecting and correcting defects, concentrate on source code. However, detecting defects at the model level and during the design process can be of great value to designers in particular within an MDE process. In this paper, we propose an automated approach to detect model refactoring opportunities related to various types of design defects. Using Genetic Programming, our approach allows automatic generation of rules to detect defects, thus relieving the designer from a fastidious manual rule definition task. We evaluate our approach by finding three potential design defect types in two large class diagrams. For all these models, we succeed in detecting the majority of expected defects.", "num_citations": "45\n", "authors": ["553"]}
{"title": "Model refactoring using examples: a search\u2010based approach\n", "abstract": " One of the important challenges in model\u2010driven engineering is how to improve the quality of the models' design in order to help designers understand them. Refactoring represents an efficient technique to improve the quality of a design while preserving its behavior. Most of existing work on model refactoring relies on declarative rules to detect refactoring opportunities and to apply the appropriate refactorings. However, a complete specification of refactoring opportunities requires a huge number of rules. In this paper, we consider the refactoring mechanism as a combinatorial optimization problem where the goal is to find good refactoring suggestions starting from a small set of refactoring examples applied to similar contexts. Our approach, named model refactoring by example, takes as input an initial model to refactor, a set of structural metrics calculated on both initial model and models in the base of examples\u00a0\u2026", "num_citations": "38\n", "authors": ["553"]}
{"title": "Regression testing for model transformations: A multi-objective approach\n", "abstract": " In current model-driven engineering practices, metamodels are modified followed by an update of transformation rules. Next, the updated transformation mechanism should be validated to ensure quality and robustness. Model transformation testing is a recently proposed effective technique used to validate transformation mechanisms. In this paper, a more efficient approach to model transformation testing is proposed by refactoring the existing test case models, employed to test previous metamodel and transformation mechanism versions, to cover new changes. To this end, a multi-objective optimization algorithm is employed to generate test case models that maximizes the coverage of the new metamodel while minimizing the number of test case model refactorings as well as test case model elements that have become invalid due to the new changes. Validation results on a widely used transformation\u00a0\u2026", "num_citations": "31\n", "authors": ["553"]}
{"title": "Reducing interactive refactoring effort via clustering-based multi-objective search\n", "abstract": " Refactoring is nowadays widely adopted in the industry because bad design decisions can be very costly and extremely risky. On the one hand, automated refactoring does not always lead to the desired design. On the other hand, manual refactoring is error-prone, time-consuming and not practical for radical changes. Thus, recent research trends in the field focused on integrating developers feedback into automated refactoring recommendations because developers understand the problem domain intuitively and may have a clear target design in mind. However, this interactive process can be repetitive, expensive, and tedious since developers must evaluate recommended refactorings, and adapt them to the targeted design especially in large systems where the number of possible strategies can grow exponentially. In this paper, we propose an interactive approach combining the use of multi-objective and\u00a0\u2026", "num_citations": "26\n", "authors": ["553"]}
{"title": "An introduction to modern software quality assurance\n", "abstract": " Software quality was at one time restricted to ensuring that a completed software product conformed to its explicitly stated requirements. For several years now, meeting customer expectations (both implicit and explicit) has become an important aspect of software quality assurance (SQA). The news media is filled with reports of failed software systems. Most of these failures can be traced to defects that could have been detected with better attention to the management of software quality. Modern end-users expect software products to be reliable, secure, and safe. Pressure to produce software systems faster has never been greater and agile methods have been proposed to accommodate uncertain and changing user requirements. It is clear that quality cannot be added to an evolving system just before its release. This chapter will look at SQA practices that are capable of accommodating change and still provide\u00a0\u2026", "num_citations": "24\n", "authors": ["553"]}
{"title": "Search-based model merging\n", "abstract": " In Model-Driven Engineering (MDE) adequate means for collaborative modeling among multiple team members is crucial for large projects. To this end, several approaches exist to identify the operations applied in parallel, to detect conflicts among them, as well as to construct a merged model by incorporating all non-conflicting operations. Conflicts often denote situations where the application of one operation disables the applicability of another operation. Whether one operation disables the other, however, often depends on their application order. To obtain a merged model that maximizes the combined effect of all parallel operations, we propose an automated approach for finding the optimal merging sequence that maximizes the number of successfully applied operations. Therefore, we adapted and used a heuristic search algorithm to explore the huge search space of all possible operation sequences. The\u00a0\u2026", "num_citations": "23\n", "authors": ["553"]}
{"title": "Automated refactoring of ATL model transformations: a search-based approach\n", "abstract": " Model transformation programs evolve through a process of continuous change. However, this process may weaken the design of the transformation programs and make it unnecessarily complex, leading to increased fault-proneness. Refactoring improves the software design while preserving overall functionality and behavior. However, very few studies addressed the problem of refactoring model transformation programs. These existing studies provided an entirely manual or semi-automated refactoring support to transformation languages such as ATL. In this paper, we propose a fully-automated search-based approach to refactor model transformations based on a multi-objective algorithm that recommends the best refactoring sequence (eg extract rule, merge rules, etc.) optimizing a set of ATL-based quality metrics (eg number of rules, coupling, etc.). To validate our approach, we apply it to a comprehensive\u00a0\u2026", "num_citations": "22\n", "authors": ["553"]}
{"title": "Search-based requirements traceability recovery: A multi-objective approach\n", "abstract": " Software systems nowadays are complex and difficult to maintain due to the necessity of continuous change and adaptation. One of the challenges in software maintenance is keeping requirements traceability up to date automatically. The process of generating requirements traceability is time-consuming and error-prone. Currently, most available tools do not support the automated recovery of traceability links. In some situations, companies accumulate the history of changes from past maintenance experiences. In this paper, we consider requirements traceability recovery as a multi objective search problem in which we seek to assign each requirement to one or many software elements (code elements, API documentation, and comments) by taking into account the recency of change, the frequency of change, and the semantic similarity between the description of the requirement and the software element. We use\u00a0\u2026", "num_citations": "19\n", "authors": ["553"]}
{"title": "Model transformation testing: a bi\u2010level search\u2010based software engineering approach\n", "abstract": " The process of writing model transformations is a complex and error\u2010prone one. Thus, efficient techniques and tools for validating model transformations are needed. One of them is model transformation testing. The generation of test cases for model transformations is mainly based on metamodel and rules coverage criteria. In this paper, we propose to treat model transformation testing as a bi\u2010level optimization problem to combine the generation of test cases with mutation testing. In our adaptation, the upper\u2010level problem generates a set of test cases that maximizes the coverage of metamodels and errors introduced by the lower level to the transformation rules. The lower level maximizes the number of generated errors in the rules that cannot be detected by the test cases produced by the upper level. The main advantage of our bi\u2010level formulation is that the evaluation of test cases is not limited to the coverage of\u00a0\u2026", "num_citations": "19\n", "authors": ["553"]}
{"title": "On the use of time series and search based software engineering for refactoring recommendation\n", "abstract": " To improve the quality of software systems, one of the widely used techniques is refactoring, defined as the process of improving the design of an existing system by changing its internal structure without altering the external behavior. The majority of existing refactoring works do not consider the impact of recommended refactorings on the quality of future releases of a system. In this paper, we propose to combine the use of search-based software engineering with time series to recommend good refactoring strategies in order to manage technical debt. We used a multi-objective algorithm to generate refactoring solutions that maximize the correction of important quality issues and minimize the effort. For these two fitness functions, we adapted time series forecasting to estimate the impact of the generated refactorings solution on future next releases of the system by predicting the evolution of the remaining code smells\u00a0\u2026", "num_citations": "17\n", "authors": ["553"]}
{"title": "RefBot: intelligent software refactoring bot\n", "abstract": " The adoption of refactoring techniques for continuous integration received much less attention from the research community comparing to root-canal refactoring to fix the quality issues in the whole system. Several recent empirical studies show that developers, in practice, are applying refactoring incrementally when they are fixing bugs or adding new features. There is an urgent need for refactoring tools that can support continuous integration and some recent development processes such as DevOps that are based on rapid releases. Furthermore, several studies show that manual refactoring is expensive and existing automated refactoring tools are challenging to configure and integrate into the development pipelines with significant disruption cost. In this paper, we propose, for the first time, an intelligent software refactoring bot, called RefBot. Integrated into the version control system (e.g. GitHub), our bot\u00a0\u2026", "num_citations": "15\n", "authors": ["553"]}
{"title": "A new design defects classification: marrying detection and correction\n", "abstract": " Previous work classify design defects based on symptoms (long methods, large classes, long parameter lists, etc.), and treat separately detection and correction steps. This paper introduces a new classification of defects using correction possibilities. Thus, correcting different code fragments appending to specific defect category need, approximately, the same refactoring operations to apply. To this end, we use genetic programming to generate new form of classification rules combining detection and correction steps. We report the results of our validation using different open-source systems. Our proposal achieved high precision and recall correction scores.", "num_citations": "14\n", "authors": ["553"]}
{"title": "Integrated strategy of vehicle routing and maintenance\n", "abstract": " This paper deals with the Vehicle Routing Problem (VRP) considering specific situations of transcontinental transportation where heavy vehicles travel over long distances between cities in a difficult environment favoring a non-negligible probability of failure of critical components. Hence, these transportation vehicles are subject to random breakdowns and repairs of random duration, which can obviously delay deliveries. A preventive maintenance (PM) policy is proposed which suggests performing PM actions (generally preventive replacement of the critical component) when reaching selected customers (cities). The purpose of this work is to determine simultaneously the optimal delivery sequence and the optimal sequence of PM actions (i.e. the customers cities at which PM should be performed) in order to minimize the expected total cost per time unit, considering penalties on late arrival and maintenance costs\u00a0\u2026", "num_citations": "13\n", "authors": ["553"]}
{"title": "Model refactoring by example: A multi\u2010objective search based software engineering approach\n", "abstract": " Declarative rules are frequently used in model refactoring in order to detect refactoring opportunities and to apply the appropriate ones. However, a large number of rules is required to obtain a complete specification of refactoring opportunities. Companies usually have accumulated examples of refactorings from past maintenance experiences. Based on these observations, we consider the model refactoring problem as a multi objective problem by suggesting refactoring sequences that aim to maximize both structural and textual similarity between a given model (the model to be refactored) and a set of poorly designed models in the base of examples (models that have undergone some refactorings) and minimize the structural similarity between a given model and a set of well\u2010designed models in the base of examples (models that do not need any refactoring). To this end, we use the Non\u2010dominated Sorting\u00a0\u2026", "num_citations": "11\n", "authors": ["553"]}
{"title": "Test Cases Generation for Model Transformations from Structural Information.\n", "abstract": " Most of existing approaches for test cases generation to transformation mechanisms use a main criterion which is the coverage of source and target metamodel elements. However, this criterion is not sufficient in a real-world scenario. In fact, test-cases generated to cover meta-model elements cannot detect some transformation errors due to model-scalability reasons. These generated test cases are simple and different, in general, from source models that are used in an industrial setting. To make the situation worse, source models cannot be provided by industrial companies due to security/confidentiality reasons. Instead of real data (source models), corporations can provide structural information about their source models (eg number of classes, number of relationships, etc.). We propose a search-based approach for generating test cases based on the coverage of structural information in addition to meta-models coverage. The validation results on a transformation mechanism used by an industrial partner confirm the effectiveness of our approach.", "num_citations": "11\n", "authors": ["553"]}
{"title": "Example-based design defects detection and correction\n", "abstract": " Software design defects often lead to bugs, runtime errors and software maintenance difficulties. They should be systematically prevented, found, removed or fixed all along the software lifecycle (development and maintenance stages). However, detecting and fixing these defects is still, to some extent, a difficult, time-consuming and manual process. In this paper, we propose a two-step automated approach to detect and then to correct various types of design defects in source code. Using Genetic Programming, our approach allows automatic generation of rules to detect defects, thus relieving the designer from a fastidious manual rule definition task. Using a Genetic Algorithm, correction solutions are found by combining refactoring operations in such a way to minimize the number of detected defects. We evaluate our approach by finding and fixing potential defects in six open-source systems. For all these systems, we succeed in detecting, in average, more than 76% of known defects, a better result when compared to a state-of-the-art approach, where the detection rules are manually or semi-automatically specified. The proposed corrections fix, in average, more than 74% of detected defects.", "num_citations": "11\n", "authors": ["553"]}
{"title": "Web service design defects detection: A bi-level multi-objective approach\n", "abstract": " Context: Web services frequently evolve to integrate new features, update existing operations and fix errors to meet the new requirements of subscribers. While this evolution is critical, it may have a negative impact on the quality of services (QoS) such as reduced cohesion, increased coupling, poor response time and availability, etc. Thus, the design of services could become hard to maintain and extend in future releases. Recent studies addressed the problem of web service design antipatterns detection, also called design defects, by either manually defining detection rules, as combination of quality metrics, or generating them automatically from a set of defect examples. The manual definition of these rules is time-consuming and difficult due to the subjective nature of design issues, especially to find the right thresholds value. The efficiency of the generated rules, using automated approaches, will depend on the\u00a0\u2026", "num_citations": "9\n", "authors": ["553"]}
{"title": "Interactive refactoring documentation bot\n", "abstract": " The documentation of code changes is significantly important but developers ignore it, most of the time, due to the pressure of the deadlines. While developers may document the most important features modification or bugs fixing, recent empirical studies show that the documentation of quality improvements and/or refactoring is often omitted or not accurately described. However, the automated or semi-automated documentation of refactorings has not been yet explored despite the extensive work on the remaining steps of refactoring including the detection, prioritization and recommendation. In this paper, we propose a semi-automated refactoring documentation bot that helps developers to interactively check and validate the documentation of the refactorings and/or quality improvements at the file level for each opened pull-request before being reviewed or merged to the master. The bot starts by checking the\u00a0\u2026", "num_citations": "9\n", "authors": ["553"]}
{"title": "Less is More: From Multi-objective to Mono-objective Refactoring via Developer's Knowledge Extraction\n", "abstract": " Refactoring studies either aggregated quality metrics to evaluate possible code changes or treated them separately to find trade-offs. For the first category of work, it is challenging to define upfront the weights for the quality objectives since developers are not able to express them upfront. For the second category of work, the number of possible trade-offs between quality objectives is large which makes developers reluctant to look at many refactoring solutions. In this paper, we propose, for the first time, a way to convert multi-objective search into a mono-objective one after interacting with the developer to identify a good refactoring solution based on his preferences. The first step consists of using a multi-objective search to generate different possible refactoring strategies by finding a trade-off between several conflicting quality attributes. Then, an unsupervised learning algorithm clusters the different trade-off\u00a0\u2026", "num_citations": "7\n", "authors": ["553"]}
{"title": "Search-based requirements traceability recovery\n", "abstract": " Several software maintenance tasks, such as regression testing, require that the requirements traceability should be up-to-date. Generating requirements traceability consumes a lot of time and is error-prone. Currently most available tools do not offer the automated recovery of traceability links. In the approach presented in this paper, we formulate requirements traceability recovery as a search problem using Genetic Algorithms. Our approach takes as input the software system and a requirement set and produces a set of traces between the classes of the system and the requirements introduced in the input as output. A solution consists of assigning each requirement to one or many classes of the system that should maximize as much as possible the textual similarity between the description of the requirements and the name of code elements, API documentation, and comments. The validation results on\u00a0\u2026", "num_citations": "7\n", "authors": ["553"]}
{"title": "Transformation by example\n", "abstract": " Model transformations take as input a source model and generate as output a target model. The source and target models conform to given meta-models. We distinguish between two transformation categories. Exogenous transformations are transformations between models expressed using different languages, and the whole source model is transformed. Endogenous transformations are transformations between models expressed in the same language. For endogenous transformations, two steps are needed: identifying the source model elements to transform and then applying the transformation on them. In this thesis, we propose three principal contributions. The first contribution aims to automate model transformations. The process is seen as an optimization problem where different transformation possibilities are evaluated and, for each possibility, a quality is associated depending on its conformity with a reference set of examples. This first contribution can be applied to exogenous as well as endogenous transformation (after determining the source model elements to transform). The second contribution is related precisely to the detection of elements concerned with endogenous transformations. In this context, we present a new technique for design defect detection. The detection is based on the notion that the more a code deviates from good practice, the more likely it is bad. Taking inspiration from artificial immune systems, we generate a set of detectors that characterize the ways in which a code can diverge from good practices. We then use these detectors to determine how far the code in the assessed systems deviates from normality\u00a0\u2026", "num_citations": "7\n", "authors": ["553"]}
{"title": "Simplifying model transformation chains by rule composition\n", "abstract": " Many model transformation problems require different intermediate transformation steps, e.g., when platform-specific models (PSM) are generated from platform-independent models (PIM). This requires the presence of several intermediate meta-models between those of the PIM and the PSM. Thus, for achieving the final PSM, a chain of transformation is needed. The solution proposed in this paper is to investigate whether it is possible to generate a single transformation from a chain of transformations, solely involving the initial PIM and final PSM meta-models. The presented work focuses on the composition of algebraic graph transformations at the rule level. Moreover, we discuss about the translation of transformations implemented in dedicated model-to-model transformation languages to algebraic graph transformation specifications. We apply the automatic procedure for composing rules in the context\u00a0\u2026", "num_citations": "6\n", "authors": ["553"]}
{"title": "NSGA-II as feature selection technique and AdaBoost classifier for COVID-19 prediction using patient\u2019s symptoms\n", "abstract": " Nowadays, humanity is facing one of the most dangerous pandemics known as COVID-19. Due to its high inter-person contagiousness, COVID-19 is rapidly spreading across the world. Positive patients are often suffering from different symptoms that can vary from mild to severe including cough, fever, sore throat, and body aches. In more dire cases, infected patients can experience severe symptoms that can cause breathing difficulties which lead to stern organ failure and die. The medical corps all over the world are overloaded because of the exponentially myriad number of contagions. Therefore, screening for the disease becomes overwrought with the limited tools of test. Additionally, test results may take a long time to acquire, leaving behind a higher potential for the prevalence of the virus among other individuals by the patients. To reduce the chances of infection, we suggest a prediction model that\u00a0\u2026", "num_citations": "4\n", "authors": ["553"]}
{"title": "Recommending refactorings via commit message analysis\n", "abstract": " ContextThe purpose of software restructuring, or refactoring, is to improve software quality and developer productivity.ObjectivePrior studies have relied mainly on static and dynamic analysis of code to detect and recommend refactoring opportunities, such as code smells. Once identified, these smells are fixed by applying refactorings which then improve a set of quality metrics. While this approach has value and has shown promising results, many detected refactoring opportunities may not be related to a developer\u2019s current context and intention. Recent studies have shown that while developers document their refactoring intentions, they may miss relevant refactorings aligned with their rationale.MethodIn this paper, we first identify refactoring opportunities by analyzing developer commit messages and check the quality improvements in the changed files, then we distill this knowledge into usable context-driven\u00a0\u2026", "num_citations": "4\n", "authors": ["553"]}
{"title": "Understanding the correlation between code smells and software bugs\n", "abstract": " Bug predictions helps software quality assurance team to determine the effort required to test the software application. Anti-patterns and code smells can greatly influence the quality of the code. Refactoring can be a solution to remove the negative impact of these anti-patterns. In this paper, we explored the influence of code smells on the code and severity of bugs reported on multiple versions of the projects such as BIRT, Aspect J and SWT. We evaluated the correlation between the different code smells and severity of the bugs reported on these classes. This can help the quality assurance specialists and project managers assess the testing effort required based on the code smells detected. This can prove beneficial to the developers to restructure or refactor before deploying the code in the test environment. On the other hand, the testing team can concentrate on the bug prediction models, testing plan and assess the number of resources needed to perform testing. The empirical validation of our work found a strong correlation between several types of code smells and software bugs based on three large open source projects.", "num_citations": "4\n", "authors": ["553"]}
{"title": "Improving Web Services Design Quality Using Dimensionality Reduction Techniques\n", "abstract": " In this paper, we propose a dimensionality reduction approach based on PCA-NSGAII to address the Web services modularization problem. Our approach aims at finding the best reduced set of objectives (e.g. quality metrics) that can generate near optimal modularization solutions to fix quality issues in Web services interface. The algorithm starts with a large number of Web service quality metrics as objectives that are reduced based on the correlation between them. This correlation is identified during the execution of the multi-objective algorithm by mining the execution traces of the generated solutions and their evaluations. We evaluated our approach on a set of 22 real world Web services, provided by Amazon and Yahoo. Statistical analysis of our experiments shows that our dimensionality reduction Web services interface modularization approach performed significantly better than the state-of-the-art\u00a0\u2026", "num_citations": "3\n", "authors": ["553"]}
{"title": "WIP: Introducing active learning in a software engineering course\n", "abstract": " Many courses offered by the College of Engineering and Computer Science (CECS) rely heavily on lectures as the primary vehicle of instruction. This is even true of courses that should emphasize student project work. Many computing (CS, IS, SE, CE) students are turned off by this sterile delivery of material prior to beginning their senior capstone projects. We have noticed gaps in students\u2019 software engineering abilities when they begin their capstone projects. It is not always the case that students were not exposed to the necessary concepts in previous courses, but rather they that were not asked to apply these skills in project settings. In the past, instructors (and employers) have relied on just-in-time learning to fill in these holes. Many engineering educators regard experiential learning as the best way to train the next generation of engineers. This requires engineering programs to go beyond simply offering industry-based capstone courses and internships. It is our belief that introducing active learning opportunities prior to the senior year can improve software engineering education at the undergraduate level. This will also increase the pool of new professionals with practical software engineering knowledge and skills.", "num_citations": "3\n", "authors": ["553"]}
{"title": "Rules and helpers dependencies in ATL--technical report\n", "abstract": " In this technical report we explain the different types of dependencies that can take place in ATL model transformations and exemplify them in a running example. Besides, we explain in detail how we use a static types extraction in order to obtain information of the dependencies.", "num_citations": "3\n", "authors": ["553"]}
{"title": "Considering dependencies between bug reports to improve bugs triage\n", "abstract": " Software development teams need to deal with several open reports of critical bugs to be addressed urgently and simultaneously. The management of these bugs is a complex problem due to the limited resources and the deadlines-pressure. Most of the existing studies treated bug reports in isolation when assigning them to developers. Thus, developers may spend considerable cognitive efforts moving between completely unrelated bug reports thus not sharing any common files to be inspected. In this paper, we propose an automated bugs triage approach based on the dependencies between the open bug reports. Our approach starts by localizing the files to be inspected for each of the pending bug reports. We defined the dependency between two bug reports as the number of common files to be inspected to localize the bugs. Then, we adopted multi-objective search to rank the bug reports for programmers\u00a0\u2026", "num_citations": "2\n", "authors": ["553"]}
{"title": "Multi-objective code reviewer recommendations: balancing expertise, availability and collaborations\n", "abstract": " Modern Code review is one of the most critical tasks in software maintenance and evolution. A rigorous code review leads to fewer bugs and reduced overall maintenance costs. Most existing studies focus on automatically identifying the most qualified reviewers, based on their expertise, to review pull-up requests. However, the management of code reviews is a complex problem in practice due to a project\u2019s limited resources, including the availability of peer reviewers. Furthermore, the history of collaborations between developers and reviewers could affect the quality of the reviews, in positive or negative ways. In this paper, we formulate the recommendation of code reviewers as a multi-objective search problem to balance the conflicting objectives of expertise, availability, and history of collaborations. Our validation confirms the effectiveness of our multi-objective approach on 9 open source projects by making\u00a0\u2026", "num_citations": "2\n", "authors": ["553"]}
{"title": "Improving Adaptation rules Quality Using Genetic Programming\n", "abstract": " Personalized Information System (PIS) aims to provide tailored services to users in various contexts. The aim of such system is to help users find relevant content easier and faster. To achieve such behaviour, the system needs a user model providing information about users, e.g., about their interests, skills, background and custom information while ensuring their adaptation to the needs and preferences of each user. This system is able to learn about the preferences of individual users and to tailor the content, interface, and behaviour to the user preferences. In fact, the diversity of contexts and the proliferation of profiles make personalization a very sophisticated process. Personalization is a major challenge for the information system. In fact, its quality and its adaptation to the user's preferences represent a key of success of these systems. In this context, this paper presents a personalized method based on the\u00a0\u2026", "num_citations": "2\n", "authors": ["553"]}
{"title": "Nautilus: An Interactive Plug and Play Search Based Software Engineering Framework\n", "abstract": " Several Software Engineering problems are complex and encompass a great number of objectives to be handled. However, practitioners may face several challenges to adopt existing metaheuristic search for their problems due to the lack of background, or some difficult choices such as the change operators, and parameters tuning. Nautilus Framework allows practitioners developing and experimenting several multi- and many-objectives evolutionary algorithms guided (or not) by human participation in few steps with a minimum required background in coding and search-based algorithms. A case study illustrates its benefits, which can also be used to support the construction of AI solutions guided by human decisions.", "num_citations": "1\n", "authors": ["553"]}
{"title": "Enabling decision and objective space exploration for interactive multi-objective refactoring\n", "abstract": " Due to the conflicting nature of quality measures, there are always multiple refactoring options to fix quality issues. Thus, interaction with developers is critical to inject their preferences. While several interactive techniques have been proposed, developers still need to examine large numbers of possible refactorings, which makes the interaction time-consuming. Furthermore, existing interactive tools are limited to the \"objective space\" to show developers the impacts of refactorings on quality attributes. However, the \"decision space\" is also important since developers may want to focus on specific code locations. In this paper, we propose an interactive approach that enables developers to pinpoint their preference simultaneously in the objective (quality metrics) and decision (code location) spaces. Developers may be interested in looking at refactoring strategies that can improve a specific quality attribute, such as\u00a0\u2026", "num_citations": "1\n", "authors": ["553"]}
{"title": "Interactive and Dynamic Multi-Objective Refactoring Recommendations\n", "abstract": " Successful software products evolve through a process of continual change. However, this process may weaken the design of the software and make it unnecessarily complex, leading to significantly reduced productivity and increased fault-proneness. Refactoring improves the software design while preserving overall functionality and behavior, and is an important technique in managing the growing complexity of software systems. Most of the existing work on software refactoring uses either an entirely manual or a fully automated approach. Manual refactoring is time-consuming, error-prone and unsuitable for large-scale, radical refactoring. On the other hand, fully automated refactoring yields a static list of refactorings which, when applied, leads to a new and often hard to comprehend design. Furthermore, it is difficult to merge these refactorings with other changes performed in parallel by developers. In this paper, we propose a refactoring recommendation approach that dynamically adapts and interactively suggests refactorings to developers and takes their feedback into consideration. Our approach uses NSGA-II to find a set of good refactoring solutions that improve software quality while minimizing the deviation from the initial design. These refactoring solutions are then analyzed to extract interesting common features between them such as the frequently occurring refactorings in the best non-dominated solutions. Based on this analysis, the refactorings are ranked and suggested to the developer in an interactive fashion as a sequence of transformations. The developer can approve, modify or reject each of the recommended refactorings, and\u00a0\u2026", "num_citations": "1\n", "authors": ["553"]}
{"title": "refactoring Support for Variability-intensive Systems\n", "abstract": " Several studies show that programmers are postponing software maintenance activities that improve software quality, even while seeking high-quality source code for themselves when updating existing projects. High-quality source code can be characterized using several quality attributes, but maintaining this high level of quality is expensive. One reason is that time and monetary pressures force programmers to neglect to enhance the quality of their source code while enhancing existing systems with new features or fixing bugs. Code smells represent symptoms of poor implementation choices. For instance, a Blob has several symptoms such as a large class, high number of methods, low cohesion and high coupling. Code smells are frequent in variability-intensive software systems since their requirements change extensively over time, and developers have limited time to meet the deadlines and provide new\u00a0\u2026", "num_citations": "1\n", "authors": ["553"]}
{"title": "Detecting Refactorings among Multiple Web Service Releases: A Heuristic-Based Approach\n", "abstract": " A Web service interface is considered as a contract between Web service providers and their subscribers. The subscribers do not have access to the source code of the services but only to the interface containing a set of operations. However, the interface may change over time to meet new requirements. These changes affect the implementation of the subscribers' software. Thus, these clients need to understand the changes introduced to the previous releases of the Web services to co-evolve their own implementation to support the new release. Current studies are limited to the detection of only atomic changes (e.g. add and delete) and not able to detect complex/composite refactorings (merge operations, extract operation, etc.). In this paper, we propose to consider structural and textual similarities, based on a genetic algorithm, when analyzing the evolution of Web services to detect complex changes applied\u00a0\u2026", "num_citations": "1\n", "authors": ["553"]}
{"title": "Multi-View Model Refactoring using a Multi-Objective Evolutionary Algorithm\n", "abstract": " To improve the quality of software systems, one of the widely used techniques is refactoring defined as the process of improving the design of existing system by changing its internal structure without altering the external behavior. The majority of existing refactoring works focus mainly on the source code level. The suggestion of refactorings at the model level is more challenging due to the difficulty to evaluate: a) the impact of the suggested refactorings applied to a diagram on other related diagrams to improve the overall system quality, b) their feasibility, and c) interdiagram consistency. We propose, in this paper, a novel framework that enables software designers to apply refactoring at the model level. To this end, we used a multiobjective evolutionary algorithm to find a trade-off between improving the quality of different diagrams at the same time such as class diagrams and activity diagrams. The proposed multi-objective approach provides a multi-view for software designers to evaluate the impact of suggested refactorings applied to class diagrams on related activity diagrams in order to evaluate the overall quality, and check their feasibility and behavior preservation. The statistical evaluation performed on models extracted from four open source systems confirms the efficiency of our approach.", "num_citations": "1\n", "authors": ["553"]}