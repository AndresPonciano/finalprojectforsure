{"title": "Semistructured Merge in Revision Control Systems.\n", "abstract": " Revision control systems are a major means to manage versions and variants of today\u2019s software systems. An ongoing problem in these systems is how to resolve conflicts when merging independently developed revisions. Unstructured revision control systems are purely text-based and solve conflicts based on textual similarity. Structured revision control systems are tailored to specific languages and use language-specific knowledge for conflict resolution. We propose semistructured revision control systems to inherit the strengths of both classes of systems: generality and expressiveness. The idea is to provide structural information of the underlying software artifacts in the form of annotated grammars, which is motivated by recent work on software product lines. This way, a wide variety of languages can be supported and the information provided can assist the resolution of conflicts. We have implemented a preliminary tool and report on our experience with merging Java artifacts. We believe that drawing a connection between revision control systems and product lines has benefits for both fields.", "num_citations": "16\n", "authors": ["1531"]}
{"title": "Analysis and Transformation of Configurable Systems\n", "abstract": " Static analysis tools and transformation engines for source code belong to the standard equipment of a software developer. Their use simplifies a developer\u2019s everyday work of maintaining and evolving software systems significantly and, hence, accounts for much of a developer\u2019s programming efficiency and programming productivity. This is also beneficial from a financial point of view, as programming errors are early detected and avoided in the the development process, thus the use of static analysis tools reduces the overall software-development costs considerably.In practice, software systems are often developed as configurable systems to account for different requirements of application scenarios and use cases. To implement configurable systems, developers often use compile-time implementation techniques, such as preprocessors, by using# ifdef directives. Configuration options control the inclusion and exclusion of# ifdef-annotated source code and their selection/deselection serve as an input for generating tailor-made system variants on demand. Existing configurable systems, such as the LINUX kernel, often provide thousands of configuration options, forming a huge configuration space with billions of system variants.", "num_citations": "7\n", "authors": ["1531"]}
{"title": "Untersuchung der Anwendung erweiterter Programmierparadigmen f\u00fcr die Programmierung eingebetteter Systeme\n", "abstract": " Software-Entwicklung vermehrte Einsatz eingebetteter Systeme zu einem erheblichen Anteil von ca. 50% an den Produktionskosten in den zuvor genannten Anwendungsgebieten [HKM+ 05]. Einen entscheidenden Beitrag leistet hierbei die Software der Systeme. Laut Bollow et al.[BHK02] und Krishan [Kri05] nimmt ihr Umfang und ihre Komplexit\u00e4t fortw\u00e4hrend zu. Der Grund liegt in den zus\u00e4tzlichen Anforderungen, die eingebettete Systeme mittlerweile erf\u00fcllen m\u00fcssen und deren Umsetzung vermehrt in Software erfolgt. Bestehende Ressourcenbeschr\u00e4nkungen der eingesetzten Hardware f\u00fchren in diesem Zusammenhang h\u00e4ufig zu aufwendigen Neuentwicklungen oder Anpassungen, die die Kosten zus\u00e4tzlich steigern.", "num_citations": "3\n", "authors": ["1531"]}