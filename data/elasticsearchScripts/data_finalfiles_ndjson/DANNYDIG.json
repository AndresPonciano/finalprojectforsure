{"title": "A type and effect system for deterministic parallel Java\n", "abstract": " Today's shared-memory parallel programming models are complex and error-prone. While many parallel programs are intended to be deterministic, unanticipated thread interleavings can lead to subtle bugs and nondeterministic semantics. In this paper, we demonstrate that a practical type and effect system can simplify parallel programming by guaranteeing deterministic semantics with modular, compile-time type checking even in a rich, concurrent object-oriented language such as Java. We describe an object-oriented type and effect system that provides several new capabilities over previous systems for expressing deterministic parallel algorithms. We also describe a language called Deterministic Parallel Java (DPJ) that incorporates the new type system features, and we show that a core subset of DPJ is sound. We describe an experimental validation showing thatDPJ can express a wide range of realistic\u00a0\u2026", "num_citations": "435\n", "authors": ["293"]}
{"title": "How do APIs evolve? A story of refactoring\n", "abstract": " Frameworks and libraries change their APIs. Migrating an application to the new API is tedious and disrupts the development process. Although some tools and ideas have been proposed to solve the evolution of APIs, most updates are done manually. To better understand the requirements for migration tools, we studied the API changes of four frameworks and one library. We discovered that the changes that break existing applications are not random, but tend to fall into particular categories. Over 80% of these changes are refactorings. This suggests that refactoring\u2010based migration tools should be used to update applications. Copyright \u00a9 2006 John Wiley & Sons, Ltd.", "num_citations": "301\n", "authors": ["293"]}
{"title": "The role of refactorings in API evolution\n", "abstract": " Frameworks and libraries change their APIs. Migrating an application to the new API is tedious and disrupts the development process. Although some tools and ideas have been proposed to solve the evolution of APIs, most updates are done manually. To better understand the requirements for migration tools we studied the API changes of three frameworks and one library. We discovered that the changes that break existing applications are not random, but they tend to fall into particular categories. Over 80% of these changes are refactorings. This suggests that refactoring-based migration tools should be used to update applications.", "num_citations": "196\n", "authors": ["293"]}
{"title": "Refactoring sequential Java code for concurrency via concurrent libraries\n", "abstract": " Parallelizing existing sequential programs to run efficiently on multicores is hard. The Java 5 package java.util.concurrent (j.u.c.) supports writing concurrent programs: much of the complexity of writing thread-safe and scalable programs is hidden in the library. To use this package, programmers still need to reengineer existing code. This is tedious because it requires changing many lines of code, is error-prone because programmers can use the wrong APIs, and is omission-prone because programmers can miss opportunities to use the enhanced APIs. This paper presents our tool, Concurrencer, that enables programmers to refactor sequential code into parallel code that uses three j.u.c. concurrent utilities. Concurrencer does not require any program annotations. Its transformations span multiple, non-adjacent, program statements. A find-and-replace tool can not perform such transformations, which require\u00a0\u2026", "num_citations": "182\n", "authors": ["293"]}
{"title": "Refactoring-aware configuration management for object-oriented programs\n", "abstract": " Current text based software configuration management (SCM) systems have trouble with refactorings. Refactorings result in global changes and lead to merge conflicts. A refactoring-aware SCM system reduces merge conflicts, preserves program history better and makes it easier to understand program evolution. This paper describes MolhadoRef a refactoring-aware SCM system and the merge algorithm at its core. MolhadoRef records change operations (refactorings and edits) used to produce one version, and replays them when merging versions. Since refactorings are change operations with well defined semantics, MolhadoRef treats them intelligently. A case-study shows that MolhadoRef solves automatically more merge conflicts than CVS while resulting in fewer merge errors.", "num_citations": "149\n", "authors": ["293"]}
{"title": "API code recommendation using statistical learning from fine-grained changes\n", "abstract": " Learning and remembering how to use APIs is difficult. While code-completion tools can recommend API methods, browsing a long list of API method names and their documentation is tedious. Moreover, users can easily be overwhelmed with too much information. We present a novel API recommendation approach that taps into the predictive power of repetitive code changes to provide relevant API recommendations for developers. Our approach and tool, APIREC, is based on statistical learning from fine-grained code changes and from the context in which those changes were made. Our empirical evaluation shows that APIREC correctly recommends an API call in the first position 59% of the time, and it recommends the correct API call in the top five positions 77% of the time. This is a significant improvement over the state-of-the-art approaches by 30-160% for top-1 accuracy, and 10-30% for top-5 accuracy\u00a0\u2026", "num_citations": "135\n", "authors": ["293"]}
{"title": "Mining fine-grained code changes to detect unknown change patterns\n", "abstract": " Identifying repetitive code changes benefits developers, tool builders, and researchers. Tool builders can automate the popular code changes, thus improving the productivity of developers. Researchers can better understand the practice of code evolution, advancing existing code assistance tools and benefiting developers even further. Unfortunately, existing research either predominantly uses coarse-grained Version Control System (VCS) snapshots as the primary source of code evolution data or considers only a small subset of program transformations of a single kind-refactorings.", "num_citations": "121\n", "authors": ["293"]}
{"title": "How do centralized and distributed version control systems impact software changes?\n", "abstract": " Distributed Version Control Systems (DVCS) have seen an increase in popularity relative to traditional Centralized Version Control Systems (CVCS). Yet we know little on whether developers are benefitting from the extra power of DVCS. Without such knowledge, researchers, developers, tool builders, and team managers are in the danger of making wrong assumptions.", "num_citations": "117\n", "authors": ["293"]}
{"title": "How do developers use parallel libraries?\n", "abstract": " Parallel programming is hard. The industry leaders hope to convert the hard problem of using parallelism into the easier problem of using a parallel library. Yet, we know little about how programmers adopt these libraries in practice. Without such knowledge, other programmers cannot educate themselves about the state of the practice, library designers are unaware of API misusage, researchers make wrong assumptions, and tool vendors do not support common usage of library constructs.", "num_citations": "95\n", "authors": ["293"]}
{"title": "A refactoring approach to parallelism\n", "abstract": " In the multicore era, a major programming task will be to make programs more parallel. This is tedious because it requires changing many lines of code; it's also error-prone and nontrivial because programmers need to ensure noninterference of parallel operations. Fortunately, interactive refactoring tools can help reduce the analysis and transformation burden. The author describes how refactoring tools can improve programmer productivity, program performance, and program portability. The article also describes a toolset that supports several refactorings for making programs thread-safe, threading sequential programs for throughput, and improving scalability of parallel programs.", "num_citations": "95\n", "authors": ["293"]}
{"title": "Retrofitting concurrency for android applications through refactoring\n", "abstract": " Running compute-intensive or blocking I/O operations in the UI event thread of smartphone apps can severely degrade responsiveness. Despite the fact that Android supports writing concurrent code via AsyncTask, we know little about how developers use AsyncTask to improve responsiveness. To understand how AsyncTask is used/underused/misused in practice, we rst conduct a formative study using a corpus of top 104 most popular open-source Android apps comprising 1.34 M SLOC. Our study shows that even though half of the apps use AsyncTask, there are hundreds of places where they missed opportunities to encapsulate long-running operations in AsyncTask. Second, 46% of the usages are manually refactored. However, the refactored code contains concurrency bugs (such as data races) and performance bugs (concurrent code still executes sequentially). Inspired by these ndings, we designed\u00a0\u2026", "num_citations": "90\n", "authors": ["293"]}
{"title": "Effective software merging in the presence of object-oriented refactorings\n", "abstract": " Current text based Software Configuration Management (SCM) systems have trouble with refactorings. Refactorings result in global changes which lead to merge conflicts. A refactoring-aware SCM system reduces merge conflicts. This paper describes MolhadoRef, a refactoring-aware SCM system and the merge algorithm at its core. MolhadoRef records change operations (refactorings and edits) used to produce one version, and replays them when merging versions. Since refactorings are change operations with well defined semantics, MolhadoRef treats them intelligently. A case study and a controlled experiment show that MolhadoRef automatically solves more merge conflicts than CVS while resulting in fewer merge errors.", "num_citations": "90\n", "authors": ["293"]}
{"title": "ReBA refactoring-aware binary adaptation of evolving libraries\n", "abstract": " Although in theory the APIs of software libraries and frameworks should be stable, they change in practice. This forces clients of the library API to change as well, making software maintenance expensive. Changing a client might not even be an option if its source code is missing or certain policies forbid its change. By giving a library both the old and the new API, clients can be shielded from API changes and can run with the new version of the library.", "num_citations": "87\n", "authors": ["293"]}
{"title": "Refactoring meets spreadsheet formulas\n", "abstract": " The number of end-users who write spreadsheet programs is at least an order of magnitude larger than the number of trained programmers who write professional software. We studied a corpus of 3691 spreadsheets and we found that their formulas are riddled with the same smells that plague professional software: hardcoded constants, duplicated expressions, unnecessary complexity, and unsanitized input. These make spreadsheets difficult to read and expensive to maintain. Like automated refactoring in the object-oriented domain, spreadsheet refactoring can be transformative. In this paper we present seven refactorings for spreadsheet formulas implemented in RefBook, a plugin for Microsoft Excel. To evaluate the usefulness of RefBook, we employed three kinds of empirical methods. First, we conducted a User Survey with 28 Excel users to find out whether they preferred the refactored formulas. Second, we\u00a0\u2026", "num_citations": "72\n", "authors": ["293"]}
{"title": "Study and refactoring of android asynchronous programming (t)\n", "abstract": " To avoid unresponsiveness, a core part of mobile development is asynchronous programming. Android providesseveral async constructs that developers can use. However, developers can still use the inappropriate async constructs, which result in memory leaks, lost results, and wasted energy. Fortunately, refactoring tools can eliminate these problems by transforming async code to use the appropriate constructs. In this paper we conducted a formative study on a corpusof 611 widely-used Android apps to map the asynchronouslandscape of Android apps, understand how developers retrofit asynchrony, and learn about barriers encountered by developers. Based on this study, we designed, implemented, and evaluated ASYNCDROID, a refactoring tool which enables Android developers to transform existing improperly-used async constructs into correct constructs. Our empirical evaluation shows that\u00a0\u2026", "num_citations": "69\n", "authors": ["293"]}
{"title": "Relooper: refactoring for loop parallelism in Java\n", "abstract": " In the multicore era, sequential programs need to be refactored for parallelism. The next version of Java provides ParallelArray, an array datastructure that supports parallel operations over the array elements. For example, one can apply a procedure to each element, or reduce all elements to a new element in parallel. Refactoring an array to a ParallelArray requires (i) analyzing whether the loop iterations are safe for parallel execution, and (ii) replacing loops with the equivalent parallel operations. When done manually, these tasks are non-trivial and time-consuming. This demo presents ReLooper, an Eclipse-based refactoring tool, that performs these tasks automatically. Preliminary experience with refactoring real programs shows that ReLooper is useful.", "num_citations": "69\n", "authors": ["293"]}
{"title": "Crossing the gap from imperative to functional programming through refactoring\n", "abstract": " Java 8 introduces two functional features: lambda expressions and functional operations like map or filter that apply a lambda expression over the elements of a Collection. Refactoring existing code to use these new features enables explicit but unobtrusive parallelism and makes the code more succinct. However, refactoring is tedious: it requires changing many lines of code. It is also error-prone: the programmer must reason about the control-, data-flow, and side-effects. Fortunately, refactorings can be automated. We designed and implemented LambdaFicator, a tool which automates two refactorings. The first refactoring converts anonymous inner classes to lambda expressions. The second refactoring converts for loops that iterate over Collections to functional operations that use lambda expressions. Using 9 open-source projects, we have applied these two refactorings 1263 and 1709 times, respectively. The\u00a0\u2026", "num_citations": "61\n", "authors": ["293"]}
{"title": "Software history under the lens: A study on why and how developers examine it\n", "abstract": " Despite software history being indispensable for developers, there is little empirical knowledge about how they examine software history. Without such knowledge, researchers and tool builders are in danger of making wrong assumptions and building inadequate tools. In this paper we present an in-depth empirical study about the motivations developers have for examining software history, the strategies they use, and the challenges they encounter. To learn these, we interviewed 14 experienced developers from industry, and then extended our findings by surveying 217 developers. We found that history does not begin with the latest commit but with uncommitted changes. Moreover, we found that developers had different motivations for examining recent and old history. Based on these findings we propose 3-LENS HISTORY, a novel unified model for reasoning about software history.", "num_citations": "58\n", "authors": ["293"]}
{"title": "Practical static race detection for java parallel loops\n", "abstract": " Despite significant progress in recent years, the important problem of static race detection remains open. Previous techniques took a general approach and looked for races by analyzing the effects induced by low-level concurrency constructs (eg, java. lang. Thread). But constructs and libraries for expressing parallelism at a higher level (eg, fork-join, futures, parallel loops) are becoming available in all major programming languages.", "num_citations": "43\n", "authors": ["293"]}
{"title": "LAMBDAFICATOR: from imperative to functional programming through automated refactoring\n", "abstract": " Java 8 introduces two functional features: lambda expressions and functional operations like map or filter that apply a lambda expression over the elements of a Collection. Refactoring existing code to use these new features enables explicit but unobtrusive parallelism and makes the code more succinct. However, refactoring is tedious (it requires changing many lines of code) and error-prone (the programmer must reason about the control-flow, data-flow, and side-effects). Fortunately, these refactorings can be automated. We present LambdaFicator, a tool which automates two refactorings. The first refactoring converts anonymous inner classes to lambda expressions. The second refactoring converts for loops that iterate over Collections to functional operations that use lambda expressions. In 9 open-source projects we have applied these two refactorings 1263 and 1595 times, respectively. The results show that\u00a0\u2026", "num_citations": "43\n", "authors": ["293"]}
{"title": "Transformation for class immutability\n", "abstract": " It is common for object-oriented programs to have both mutable and immutable classes. Immutable classes simplify programing because the programmer does not have to reason about side-effects. Sometimes programmers write immutable classes from scratch, other times they transform mutable into immutable classes. To transform a mutable class, programmers must find all methods that mutate its transitive state and all objects that can enter or escape the state of the class. The analyses are non-trivial and the rewriting is tedious. Fortunately, this can be automated.", "num_citations": "43\n", "authors": ["293"]}
{"title": "Improving refactoring speed by 10x\n", "abstract": " Refactoring engines are standard tools in today's Integrated Development Environments (IDEs). They allow programmers to perform one refactoring at a time, but programmers need more. Most design patterns in the Gang-of-Four text can be written as a refactoring script--a programmatic sequence of refactorings. In this paper, we present R3, a new Java refactoring engine that supports refactoring scripts. It builds a main-memory, non-persistent database to encode Java entity declarations (eg, packages, classes, methods), their containment relationships, and language features such as inheritance and modifiers. Unlike classical refactoring engines that modify Abstract Syntax Trees (ASTs), R3 refactorings modify only the database; refactored code is produced only when pretty-printing ASTs that reference database changes. R3 performs comparable precondition checks to those of the Eclipse Java Development\u00a0\u2026", "num_citations": "42\n", "authors": ["293"]}
{"title": "Check-then-act misuse of java concurrent collections\n", "abstract": " Concurrent collections provide thread-safe, highly-scalable operations, and are widely used in practice. However, programmers can misuse these concurrent collections when composing two operations where a check on the collection (such as non-emptiness) precedes an action (such as removing an entry). Unless the whole composition is atomic, the program contains an atomicity violation bug. In this paper we present the first empirical study of CHECK-THEN-ACT idioms of Java concurrent collections in a large corpus of open-source applications. We catalog nine commonly misused CHECK-THEN-ACT idioms and show the correct usage. We quantitatively and qualitatively analyze 28 widely-used open source Java projects that use Java concurrency collections - comprising 6.4M lines of code. We classify the commonly used idioms, the ones that are the most error-prone, and the evolution of the programs with\u00a0\u2026", "num_citations": "41\n", "authors": ["293"]}
{"title": "Software practitioner perspectives on merge conflicts and resolutions\n", "abstract": " Merge conflicts occur when software practitioners need to work in parallel and are inevitable in software development. Tool builders and researchers have focused on the prevention and resolution of merge conflicts, but there is little empirical knowledge about how practitioners actually approach and perform merge conflict resolution. Without such knowledge, tool builders might be building on wrong assumptions and researchers might miss opportunities for improving the state of the art.We conducted semi-structured interviews of 10 software practitioners across 7 organizations, including both open-source and commercial projects. We identify the key concepts and perceptions from practitioners, which we then validated via a survey of 162 additional practitioners.We find that practitioners are directly impacted by their perception of the complexity of the conflicting code, and may alter the timeline in which to resolve\u00a0\u2026", "num_citations": "40\n", "authors": ["293"]}
{"title": "Gathering refactoring data: a comparison of four methods\n", "abstract": " Those of us who seek to build better refactoring tools need empirical data collected from real refactoring sessions. The literature reports on different methods for capturing this data, but little is known about how the method of data capture affects the quality of the results. This paper describes 4 methods for drawing conclusions about how programmers refactor, characterizes the assumptions made by each, and presents a family of experiments to test those assumptions. We hope that the results of the experiments will help future researchers choose a data-collection method appropriate to the question that they want to investigate.", "num_citations": "39\n", "authors": ["293"]}
{"title": "RefactoringMiner 2.0\n", "abstract": " Refactoring detection is crucial for a variety of applications and tasks: (i) empirical studies about code evolution, (ii) tools for library API migration, (iii) code reviews and change comprehension. However, recent research has questioned the accuracy of the state-of-the-art refactoring mining tools, which poses threats to the reliability of the detected refactorings. Moreover, the majority of refactoring mining tools depend on code similarity thresholds. Finding universal threshold values that can work well for all projects, regardless of their architectural style, application domain, and development practices is extremely challenging. Therefore, in a previous work [1], we introduced the first refactoring mining tool that does not require any code similarity thresholds to operate. In this work, we extend our tool to support low-level refactorings that take place within the body of methods. To evaluate our tool, we created one of the\u00a0\u2026", "num_citations": "35\n", "authors": ["293"]}
{"title": "How do programs become more concurrent: a story of program transformations\n", "abstract": " In the multi-core era, programmers need to resort to parallelism if they want to improve program performance. Thus, a major maintenance task will be to make sequential programs more concurrent. Must concurrency be designed into a program, or can it be retrofitted later? What are the most common transformations to retrofit concurrency into sequential programs? Are these transformations random, or do they belong to certain categories? How can we automate these transformations?", "num_citations": "34\n", "authors": ["293"]}
{"title": "Bumblebee: a refactoring environment for spreadsheet formulas\n", "abstract": " Spreadsheets are widely used in industry. It is estimated that end-user programmers outnumber regular programmers by a factor of 5. However, spreadsheets are error-prone: several reports exist of companies that have lost big sums of money due to spreadsheet errors. In previous work, spreadsheet smells have proven to be the cause of some of these errors. To that end, we have developed a tool that can apply refactorings to spreadsheet formulas, implementing our previous work on spreadsheet refactoring, which showed that spreadsheet formula smells are very common and that refactorings for them are widely applicable and that refactoring them with a tool is both quicker and less error-prone. Our new tool Bumblebee is able to execute refactorings originating from both these papers, by means of an extensible syntax, and can furthermore apply refactorings on entire groups of formulas, thus improving upon the\u00a0\u2026", "num_citations": "33\n", "authors": ["293"]}
{"title": "Graph-based mining of in-the-wild, fine-grained, semantic code change patterns\n", "abstract": " Prior research exploited the repetitiveness of code changes to enable several tasks such as code completion, bug-fix recommendation, library adaption, etc. These and other novel applications require accurate detection of semantic changes, but the state-of-the-art methods are limited to algorithms that detect specific kinds of changes at the syntactic level. Existing algorithms relying on syntactic similarity have lower accuracy, and cannot effectively detect semantic change patterns. We introduce a novel graph-based mining approach, CPatMiner, to detect previously unknown repetitive changes in the wild, by mining fine-grained semantic code change patterns from a large number of repositories. To overcome unique challenges such as detecting meaningful change patterns and scaling to large repositories, we rely on fine-grained change graphs to capture program dependencies. We evaluate CPatMiner by mining\u00a0\u2026", "num_citations": "25\n", "authors": ["293"]}
{"title": "Automated upgrading of component-based applications\n", "abstract": " Frameworks and libraries change their APIs. Migrating an application to the new API is tedious and disrupts the development process. Although some tools and ideas have been proposed to solve the evolution of APIs, most updates are done manually. Our study of the API changes in five components revealed that over 80% of the changes that break existing applications are caused by refactorings. This suggests that refactoring-based migration tools should be used to effectively upgrade applications. We propose an approach that is both automated and safe, without any overhead on the component producers. First, component refactorings are automatically detected (either inferred or recorded), then they are incorporated into applications by replaying.", "num_citations": "23\n", "authors": ["293"]}
{"title": "Scripting parametric refactorings in Java to retrofit design patterns\n", "abstract": " Retrofitting design patterns into a program by hand is tedious and error-prone. A programmer must distinguish refactorings that are provided by an Integrated Development Environment (IDE) from those that must be realized manually, determine a precise sequence of refactorings to apply, and perform this sequence repetitively to a laborious degree. We designed, implemented, and evaluated Reflective Refactoring (R 2 ), a Java package to automate the creation of classical design patterns (Visitor, Abstract Factory, etc.), their inverses, and variants. We encoded 18 out of 23 Gang-of-Four design patterns as R 2  scripts and explain why the remaining are inappropriate for refactoring engines. We evaluate the productivity and scalability of R 2  with a case study of 6 real-world applications. In one case, R 2  automatically created a Visitor with 276 visit methods by invoking 554 Eclipse refactorings in 10 minutes - an\u00a0\u2026", "num_citations": "21\n", "authors": ["293"]}
{"title": "Molhadoref: a refactoring-aware software configuration management tool\n", "abstract": " Refactoring tools allow programmers to change their source code quicker than before. However, the complexity of these changes cause versioning tools that operate at a file level to lose the history of entities and be unable to merge refactored entities. This problem can be solved by semantic, operation-based SCM with persistent IDs. We propose that versioning tools be aware of program entities and refactoring operations. We present MolhadoRef, our prototype, which uses these techniques to ensure that it never loses history. MolhadoRef can successfully merge edit and refactoring operations which were performed on different development branches.", "num_citations": "16\n", "authors": ["293"]}
{"title": "Pegboard: a framework for developing mobile applications\n", "abstract": " Tool support for mobile application development can significantly improve programmer productivity and software quality. Pegboard is a novel tooling framework that extends the Eclipse integrated development environment to support the development of mobile distributed applications. Its extensible design supports multiple application models and the orchestration of external tooling components throughout the development cycle. In this paper we describe Pegboard's architecture and implementation, and show how it improves the development experience through organization, visualization, simplification and guidance. We also discuss insights gained from interviewing software developers, including early users of Pegboard.", "num_citations": "16\n", "authors": ["293"]}
{"title": "Bringing the HPC Programmer\u2019s IDE into the 21st Century through Refactoring\n", "abstract": " Programming tools for High Performance Computing are lagging behind the tools that have improved the productivity of desktop programmers. The increasing complexity of HPC codes, the growing number of cores that they must utilize, their long life-span, and the plethora of desirable source code optimizations and hardware platforms make HPC codes hard to maintain. Refactoring tools can enable HPC programmers to explore the space of performance optimizations and parallel constructs safely and efficiently. This position paper presents our view on how HPC programming tools should evolve, a growing catalog of refactorings for HPC programmers, and reports on our initial effort to automate some of these refactorings.", "num_citations": "15\n", "authors": ["293"]}
{"title": "The life-cycle of merge conflicts: processes, barriers, and strategies\n", "abstract": " Merge conflicts occur when developers make concurrent changes to the same part of the code. They are an inevitable and disruptive aspect of collaborative software development. Thus tool builders and researchers have focused on the prevention and automatic resolution of merge conflicts. However, there is little empirical knowledge about how developers actually monitor for merge conflicts and plan, perform, and evaluate resolutions. Without such knowledge, tool builders might be building on the wrong assumptions and researchers might miss opportunities for improving the state of the art. We conducted semi-structured interviews with 10 software developers across 7 organizations, including both open-source and commercial projects. We identify key processes, techniques, and perceptions from developers, which we extend and validate via two surveys, a Barriers Survey and a Processes Survey, of 162 and\u00a0\u2026", "num_citations": "14\n", "authors": ["293"]}
{"title": "Effective techniques for static race detection in java parallel loops\n", "abstract": " Despite significant progress in recent years, the important problem of static race detection remains open. Previous techniques took a general approach and looked for races by analyzing the effects induced by low-level concurrency constructs (eg, java. lang. Thread). But constructs and libraries for expressing parallelism at a higher level (eg, fork-join, futures, parallel loops) are becoming available in all major programming languages. We claim that specializing an analysis to take advantage of the extra semantic information provided by the use of these constructs and libraries improves precision and scalability. We present IteRace, a set of techniques that are specialized to use the intrinsic thread, safety, and dataflow structure of collections and of the new loop parallelism mechanism introduced in Java 8. Our evaluation shows that IteRace is fast and precise enough to be practical. It scales to programs of hundreds of\u00a0\u2026", "num_citations": "14\n", "authors": ["293"]}
{"title": "Refactoring-aware software configuration management\n", "abstract": " Refactoring tools allow programmers to change source code much quicker than before. However, the complexity of these changes cause versioning tools that operate at a file level to lose the history of components. This problem can be solved by semantic, operation-based SCM with persistent IDs. We propose that versioning tools be aware of the pro- gram entities and the refactoring operations. MolhadoRef, our prototype, uses these techniques to ensure that it never loses history.", "num_citations": "14\n", "authors": ["293"]}
{"title": "Converting parallel code from low-level abstractions to higher-level abstractions\n", "abstract": " Parallel libraries continuously evolve from low-level to higher-level abstractions. However, developers are not up-to-date with these higher-level abstractions, thus their parallel code might be hard to read, slow, and unscalable. Using a corpus of 880 open-source C# applications, we found that developers still use the old Thread and ThreadPool abstractions in 62% of the cases when they use parallel abstractions. Converting code to higher-level abstractions is (i) tedious and (ii) error-prone. e.g., it can harm performance and silence the uncaught exceptions.               We present two automated migration tools, Taskifier and Simplifier that work for C# code. The first tool transforms old style Thread and ThreadPool abstractions to Task abstractions. The second tool transforms code with Task abstractions into higher-level design patterns. Using our code corpus, we have applied these tools 3026 and 405 times\u00a0\u2026", "num_citations": "13\n", "authors": ["293"]}
{"title": "ReLooper: Refactoring for loop parallelism\n", "abstract": " In the multicore era, sequential programs need to be refactored for parallelism. The next version of Java provides ParallelArray, an array data structure that supports parallel operations over the array elements. For example, one can apply a procedure to each element, or reduce all elements to a new element in parallel. Refactoring an array to a ParallelArray requires (i) analyzing whether the loop iterations are safe for parallel execution, and (ii) replacing loops with the equivalent parallel operations. When done manually, these tasks are non-trivial and time-consuming. We present ReLooper, an Eclipse-based refactoring tool, that performs these tasks automatically. Experience with refactoring real programs shows that ReLooper is useful: it reduces the burden of analyzing and rewriting parallel loops, and it is fast enough to be used interactively.", "num_citations": "13\n", "authors": ["293"]}
{"title": "A study and toolkit of CHECK\u2010THEN\u2010ACT idioms of Java concurrent collections\n", "abstract": " Concurrent collections are widely used in concurrent programs. However, programmers can misuse these concurrent collections when composing two operations where a check on the collection (e.g., collection contains an element) precedes an action (e.g., inserting an element). Unless the whole composition is atomic, the program contains an atomicity violation bug. This paper presents an extensive empirical study of CHECK\u2010THEN\u2010ACT idioms of Java (Oracle Corporation, Redwood, CA, USA) concurrent collections. We analyze 28 widely used open\u2010source Java projects (comprising 6.4 million lines of code) that use Java concurrent collections. We study the correct and incorrect use of idioms and the evolution of the programs with respect to idioms. Our tool, CTADETECTOR, detects and corrects misused idioms. CTADETECTOR discovered 60 bugs that were confirmed and fixed by developers. This shows that\u00a0\u2026", "num_citations": "11\n", "authors": ["293"]}
{"title": "Using refactorings to automatically update component-based applications\n", "abstract": " Frameworks and libraries change their APIs during evolution. Migrating an application to the new API is tedious and disrupts the development process. Although some tools and techniques have been proposed to solve the evolution of APIs, most updates are done manually. Our goal is to reduce the burden of reuse on maintenance by reducing the cost of adapting to change. We studied the API changes of three frameworks and one library and discovered that over 80% of the changes the break existing applications are refactorings. This suggests that refactoring-based migration tools should be used to effectively update applications. We propose a methodology to automatically and safely update component-based applications with no overhead on the component producers.", "num_citations": "11\n", "authors": ["293"]}
{"title": "dReAM: Dynamic refactoring-aware automated migration of Java online applications\n", "abstract": " Refactorings in software components (eg, libraries and frameworks) can change the APIs of the components. In order to use the latest version of a component, applications that reuse those APIs need to be updated. This is traditionally done manually, which is error-prone, tedious, and disruptive. The problem is exacerbated for long-running applications (eg, servers) that cannot be shut down, updated, and restarted. This paper presents a practical approach and our tool, dReAM, to automatically and safely update running applications without restarting them. At the core lies a practical representation of programs to efficiently validate the composition of refactorings and other API changes from both component and application. If dReAM finds that there are no conflicts between component and application API changes, the behavior of the application is preserved with respect to the semantics of these API changes. To apply these API changes at runtime, dReAM extends Jikes, a popular JVM. Experiments and a case study of Jigsaw web server shows that the performance overhead imposed by our update tool is less than 5% and the time to apply the update is minimal. Moreover, dReAM is non-intrusive for the current development process: application and component developers do not need to write any annotations nor do they need to compile their programs in a special way.", "num_citations": "10\n", "authors": ["293"]}
{"title": "Refactoring for asynchronous execution on mobile devices\n", "abstract": " To improve responsiveness, developers often use asynchronous programming. In the post-PC era, asynchronous programming is even more in demand because mobile and wearable devices have limited resources and access the network excessively. One current development task is refactoring long-running, blocking synchronous code (for example, accessing the Web, a cloud, a database, or a file system) into nonblocking asynchronous code. This article describes the refactorings that improve responsiveness, along with the obstacles of using asynchrony. It also discusses the challenges of retrofitting asynchrony and presents program analyses and transformations and a growing, practical toolset and resources for retrofitting asynchrony. This article is part of a special issue on Refactoring.", "num_citations": "9\n", "authors": ["293"]}
{"title": "Tddviz: Using software changes to understand conformance to test driven development\n", "abstract": " A bad software development process leads to wasted effort and inferior products. In order to improve a software process, it must be first understood. Our unique approach in this paper uses code and test changes to understand conformance to the Test Driven Development (TDD) process.We designed and implemented TDDViz, a tool that supports developers in better understanding how they conform to TDD. TDDViz supports this understanding by providing novel visualizations of developers\u2019 TDD process. To enable TDDViz\u2019s visualizations, we developed a novel automatic inferencer that identifies the phases that make up the TDD process solely based on code and test changes. We evaluate TDDViz using two complementary methods: a controlled experiment with 35 participants to evaluate the visualization, and a case study with 2601 TDD Sessions to evaluate the inference algorithm. The controlled experiment shows that, in comparison to existing visualizations, participants performed significantly better when using TDDViz to answer questions about code evolution. In addition, the case study shows that the inferencing algorithm in TDDViz infers TDD phases with an accuracy (F-measure) of 87%.", "num_citations": "8\n", "authors": ["293"]}
{"title": "Refactoring java software product lines\n", "abstract": " Refactoring is a staple of Object-Oriented (OO) program development. It should be a staple of OO Software Product Line (SPL) development too. X15 is the first tool to support the refactoring of Java SPL codebases. X15 (1) uses Java custom annotations to encode variability in feature-based Java SPLs,(2) projects a view of an SPL product (a program that corresponds to a legal SPL configuration), and (3) allows programmers to edit and refactor the product, propagating changes back to the SPL codebase. Case studies apply 2316 refactorings in 8 public Java SPLs and show that X15 is as efficient, expressive, and scalable as a state-of-the-art feature-unaware Java refactoring engine.", "num_citations": "7\n", "authors": ["293"]}
{"title": "Mining continuous code changes to detect frequent program transformations\n", "abstract": " Identifying repetitive code changes benefits developers, tool builders, and researchers. Tool builders can automate the popular code changes, thus improving the productivity of developers. Researchers would better understand the practice of code evolution, advancing existing code assistance tools even further. Developers would particularly benefit if such tools can learn and support repetitive code changes that are in progress. Unfortunately, the existing tools that aim at detecting frequent code change patterns predominantly focus on analyzing the static source code of an application rather than dynamic code changes, and thus, they can not learn from the changes on-the-fly.  We present the first approach that identifies previously unknown frequent code change patterns from a continuous sequence of code changes. Our novel algorithm effectively handles two major challenges that distinguish continuous code change pattern mining from the existing data mining techniques: overlapping transactions and transactions containing multiple instances of the same item kind. We evaluated our algorithm on 1,520 hours of code development collected from 23 developers, and showed that it is effective, useful, and scales to big amounts of data. We analyzed some of the mined code change patterns and discovered ten popular kinds of high-level program transformations.", "num_citations": "7\n", "authors": ["293"]}
{"title": "ReBA a tool for generating binary adapters for evolving java libraries\n", "abstract": " Although in theory the APIs of software libraries and frameworks should be stable, they change in practice. This forces clients of the library API to change as well, making software maintenance expensive. Changing a client might not even be an option if its source code is missing or certain policies forbid its change. By giving a library both the old and the new API, clients can be shielded from API changes and can run with the new version of the library.", "num_citations": "7\n", "authors": ["293"]}
{"title": "Assessing the benefits of computational offloading in mobile-cloud applications\n", "abstract": " This paper presents the results of a formative study conducted to determine the effects of computation offloading in mobile applications by comparing \u201capplication performance\u201d(chiefly energy consumption and response time). The study examined two general execution scenarios:(1) computation is performed locally on a mobile device, and (2) when it is offloaded entirely to the cloud. The study also carefully considered the underlying network characteristics as an important factor affecting the performance. More specifically, we refactored two mobile applications to offload their computationally intensive functionality to execute in the cloud. We then profiled these applications under different network conditions, and carefully measured \u201capplication performance\u201d in each case. The results were not as conclusive as we had expected. On fast networks, offloading is almost always beneficial. However, on slower networks\u00a0\u2026", "num_citations": "6\n", "authors": ["293"]}
{"title": "MolhadoRef: a refactoring-aware infrastructure for OO programs\n", "abstract": " Refactoring tools allow programmers to change source code much quicker than before. However, the complexity of these changes cause versioning tools that operate at a file level to lose the history of components. This problem can be solved by semantic, operation-based SCM with persistent IDs. We propose that versioning tools be aware of the program entities and the refactoring operations. MolhadoRef uses these techniques to ensure that it never loses history.", "num_citations": "6\n", "authors": ["293"]}
{"title": "Understanding type changes in java\n", "abstract": " Developers frequently change the type of a program element and update all its references for performance, security, concurrency, library migration, or better maintainability. Despite type changes being a common program transformation, it is the least automated and the least studied. With this knowledge gap, researchers miss opportunities to improve the state of the art in automation for software evolution, tool builders do not invest resources where automation is most needed, language and library designers can-not make informed decisions when introducing new types, and developers fail to use common practices when changing types. To fill this gap, we present the first large-scale and most fine-grained empirical study on type changes in Java. We develop state-of-the-art tools to statically mine 297,543 type changes and their subsequent code adaptations from a diverse corpus of 129 Java projects containing 416\u00a0\u2026", "num_citations": "5\n", "authors": ["293"]}
{"title": "X15: A tool for refactoring java software product lines\n", "abstract": " X15 is the first tool that can apply common object-oriented refactorings to Java Software Product Lines (SPLs). X15 is also the first tool that programmers can write custom scripts (to call refactorings programmatically) to retrofit design patterns into Java SPLs. We motivate and illustrate X15's unique capabilities in this paper.", "num_citations": "5\n", "authors": ["293"]}
{"title": "Refactoring for immutability\n", "abstract": " It is common for Object-Oriented programs to contain mutable and immutable classes. Immutable classes simplify sequential programing because the programmer does not have to reason about side-effects. Immutable classes also simplify parallel programming because they are embarrassingly thread-safe. Sometimes programmers write immutable classes from scratch, other times they refactor mutable into immutable classes. To refactor a mutable class, programmers must find (i) all methods that mutate its transitive state and (ii) all objects that can enter or escape the state of the class. The programmer must also update client code to use the class in an immutable fashion. The analysis is non-trivial and the rewriting is tedious. Fortunately, this can be automated.  We present Immutator, a technique and tool that enables the programmer to safely refactor a mutable class into an immutable class. Immutator also repairs client code to use the refactored class in an immutable fashion. Experience with refactoring several open-source programs shows that Immutator is useful: (i) it reduces the burden of making classes immutable, (ii) is fast enough to be used interactively, and (iii) is much safer than manual refactorings performed by open-source developers.", "num_citations": "5\n", "authors": ["293"]}
{"title": "Concurrencer: A tool for retrofitting concurrency into sequential Java applications via concurrent libraries\n", "abstract": " Parallelizing existing sequential programs to run efficiently on multicores is hard. The Java 5 package java.util.concurrent (j.u.c.) supports writing concurrent programs. To use this package, programmers still need to refactor existing code. This is tedious, error-prone, and omission-prone. This demo presents our tool, CONCURRENCER, which enables programmers to refactor sequential code into parallel code that uses j.u.c. concurrent utilities. CONCURRENCER does not require any program annotations, although the transformations span several, non-adjacent, program statements and use custom program analysis. A find-and-replace tool can not perform such transformations. Empirical evaluation shows that CONCURRENCER refactors code effectively: CONCURRENCER correctly identifies and applies transformations that some open-source developers overlooked, and the converted code exhibits good speedup.", "num_citations": "5\n", "authors": ["293"]}
{"title": "Inferring method effect summaries for deterministic parallel java\n", "abstract": " In the multicores era, parallel programming will become mainstream. However, the dominant model of concurrency is based on threads that share memory. Programming in this model is too error prone due to nondeterministic thread interleaving. A deterministic-by-default model like the one used in Deterministic Parallel Java (DPJ) can make parallel programming synonymous with programming. DPJ\u2019s type system guarantees that a parallel program is deterministic. In order to benefit from the advantages of a deterministic parallel model, the DPJ programmer needs to write annotations that specify the shared data and the side-effects of methods. Manually writing such annotations is tedious. We developed an Eclipse plugin, DPJizer, that alleviates the burden of writing such annotations. Given a program annotated with shared-data information, DPJizer infers the side-effects as method effect summaries. Preliminary experience with inferring effect annotations in real programs shows that DPJizer is useful and effective: DPJizer correctly inferred all annotations, and DPJizer is more precise than a human.", "num_citations": "5\n", "authors": ["293"]}
{"title": "Refactoring-aware configuration management system for object-oriented programs\n", "abstract": " Current text based Software Configuration Management (SCM) systems have trouble with refactorings. Refactorings result in global changes and lead to merge conflicts. A refactoring-aware SCM system reduces merge conflicts, preserves program history better and makes it easier to understand program evolution. This paper describes MolhadoRef, a refactoring-aware SCM system and the merge algorithm at its core.", "num_citations": "5\n", "authors": ["293"]}
{"title": "Analysis and transformations in support of android privacy\n", "abstract": " To protect user\u2019s privacy and system\u2019s integrity, mobile platforms use permission models to control accesses to protected resources such as GPS location, Contacts, etc. The previous major version of Android used a static permission model, which compromised the security and privacy of apps. Android 6 overhauled its permission model to ask permissions at runtime which reduces the risk of permission abuse. However, migrating to the runtime permission model requires significant effort from the app developers. In this paper we first present a large-scale formative study to understand how app developers use and migrate to the new permission model. Inspired by these findings, we designed, implemented, and evaluated a tool suite that (i) recommends locations where to insert permission requests and (ii) automatically inserts all the permission-related code. Our empirical evaluations on a diverse corpus of real-world apps show that our tools are highly applicable and accurate.", "num_citations": "4\n", "authors": ["293"]}
{"title": "Are web applications ready for parallelism?\n", "abstract": " In recent years, web applications have become pervasive. Their backbone is JavaScript, the only programming language supported by all major web browsers. Most browsers run on desktop or mobile devices with parallel hardware. However, JavaScript is by design sequential, and current web applications make little use of hardware parallelism. Are web applications ready to exploit parallel hardware? We answer the question in two steps: First, we survey 174 web developers about the potential and challenges of using parallelism. Then, we study the performance and computation shape of a set of web applications that are representative for the emerging web. Our findings indicate that emerging web applications do have latent data parallelism, and JavaScript developers' programming style is not a significant impediment to exploiting this parallelism.", "num_citations": "4\n", "authors": ["293"]}
{"title": "1st Workshop on Refactoring Tools (WRT'07)\n", "abstract": " 1st Workshop on Refactoring Tools (WRT'07) 1st Workshop on Refactoring Tools (WRT'07) Proceedings July 31, 2007, TU Berlin, Germany Danny Dig, Michael Cebulla (Eds.) Bericht-Nr. 2007\u20138 ISSN 1436-9915 Forschungsberichte der Fakult\u00e4t IV\u2013Elektrotechnik und Informatik Page 2 Page 3 i Table of Contents WRT\u201907 Organization\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. v Proceedings\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2022 KABA: Automated Refactoring for Improved Cohesion\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 1 G. Snelting, M. Streckenbach (Universitat Passau) \u2022 Automation of Refactoring and Refactoring Suggestions for TTCN-3 Test Suites. The TRex TTCN-3 Refactoring and Metrics Tool\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026 3 H. Neukirchen, B. Zeiss (University of Gottingen) \u2022 A visual interface for type-related refactorings\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 5 P. Mayer (Ludwig-Maximilians-Universit\u00e4t), A. Mei\u00dfner (in Hagen), F(\u2026", "num_citations": "4\n", "authors": ["293"]}
{"title": "Understanding Software-2.0: a study of machine learning library usage and evolution\n", "abstract": " Enabled by a rich ecosystem of Machine Learning (ML) libraries, programming using learned models, ie, Software-2.0, has gained substantial adoption. However, we do not know what challenges developers encounter when they use ML libraries. With this knowledge gap, researchers miss opportunities to contribute to new research directions, tool builders do not invest resources where automation is most needed, library designers cannot make informed decisions when releasing ML library versions, and developers fail to use common practices when using ML libraries. We present the first large-scale quantitative and qualitative empirical study to shed light on how developers in Software-2.0 use ML libraries, and how this evolution affects their code. Particularly, using static analysis we perform a longitudinal study of 3,340 top-rated open-source projects with 46,110 contributors. To further understand the\u00a0\u2026", "num_citations": "3\n", "authors": ["293"]}
{"title": "Improving responsiveness in mobile apps via refactoring for asynchrony (invited talk)\n", "abstract": " One contemporary development task is refactoring long-running, blocking synchronous code (eg, accessing the web, database, or file system) into non-blocking asynchronous code. Asynchronous programming is in demand today because responsiveness is especially important on mobile devices. While major programming languages make asynchronous programming possible, they do not make it easy. In this invited talk we present our growing refactoring toolset that enables Android and Windows Phone developers to retrofit asynchrony. There are several challenges that our toolset addresses: reasoning about a programming model which inverts the flow of control, determining non-interference of asynchronous operations with the main thread of execution, converting from legacy callback-based idioms to the newer style, etc. Our empirical evaluation shows that our toolset is (i) highly applicable,(ii) accurate,(iii\u00a0\u2026", "num_citations": "3\n", "authors": ["293"]}
{"title": "A practical tutorial on refactoring for parallelism\n", "abstract": " For several decades, programmers have relied on Moore's Law to improve the performance of their software applications. From now on, programmers need to program the multicores if they want to deliver efficient code. In the multicore era, a major maintenance task will be to make sequential programs more parallel. What are the most common transformations to retrofit parallelism into sequential programs? This tutorial equips today's programmers to be ready for tomorrow's task. It presents the process for parallelizing sequential applications and presents several refactorings for (i) making programs thread-safe, (ii) threading sequential applications, and (iii) improving scalability of parallel programs. The tutorial also presents the state of the practice libraries for parallelism in the desktop computing, and helps programmers understand the trade-offs between programmability, scalability, and portability of parallel\u00a0\u2026", "num_citations": "3\n", "authors": ["293"]}
{"title": "Lessons from the exponential growth of refactoring research in the last decade\n", "abstract": " In the last decade refactoring research has seen exponential growth. I will attempt to map this vast landscape and the advances that the community has made by answering questions such as who does what, when, where, why, and how. I will muse on some of the factors contributing to the growth of the field (e.g., refactoring the definition of refactoring to include other artifacts besides source code), the adoption of research into industry, and the lessons that we learned along this journey. This talk will present the value of prioritizing the important tasks, yet often the difficult ones. Several cases studies will show that everything worth doing is uphill all the way. This will inspire and equip you so that you can make a difference, with people who make a difference, at a time when it makes a difference.", "num_citations": "2\n", "authors": ["293"]}
{"title": "The landscape of refactoring research in the last decade (keynote)\n", "abstract": " In the last decade refactoring research has seen an exponential growth. I will attempt to map this vast landscape and the advances that the community has made by answering questions such as who does what, when, where, with who, why, and how. I will muse on some of the factors contributing to the growth of the field, the adoption of research into industry, and the lessons that we learned along this journey. This will inspire and equip you so that you can make a difference, with people who make a difference, at a time when it makes a difference.", "num_citations": "2\n", "authors": ["293"]}
{"title": "Scripting refactorings in java to introduce design patterns\n", "abstract": " Introducing design patterns into a program by hand is tedious and error-prone. Refactorings help but manual tasks still remain: you must understand available refactorings, determine a precise sequence of refactorings to invoke, and perform these tasks repetitively to a laborious degree. We present Reflective Refactoring (\uace0 2), a Java package to automate the introduction of classical design patterns (Visitor, Abstract Factory, etc), their inverses and variants. We encoded 78% of classical design patterns as \uace0 2 scripts. In one application, \uace0 2 automatically created a visitor with 276 visit methods by invoking 554 Eclipse refactorings in a few minutes\u2013an achievement that could not be done manually. We demonstrate the generality and scalability of \uace0 2, illustrate its productivity potential, and explain why refactoring speed and correctness are critical issues for scripting in next-generation refactoring engines.", "num_citations": "2\n", "authors": ["293"]}
{"title": "A type and effect system for deterministic parallelism in object-oriented languages\n", "abstract": " We describe a type and effect system for ensuring deterministic semantics in a concurrent object-oriented language. Our system provides several new capabilities over previous work, including support for linear arrays (important in parallel update traversals), flexible effect specifications and subtyping (important for, e.g., tree-based algorithms), dynamic partitioning into subarrays (important for divide-and-conquer algorithms), and a novel invocation effect for handling higher-level commutative operations such as set insert. We informally describe the key type system features, formally define a core subset of our system, and explain the steps leading to the key soundness result, i.e., that the type and effect annotations allow us to reason soundly about parallel noninterference between sections of code. Finally, we describe our experience with using the system to express realistic parallel algorithms, which validates the importance of the new type system features.", "num_citations": "2\n", "authors": ["293"]}
{"title": "The changing landscape of refactoring research in the last decade: keynote of the 2nd international workshop on API usage and evolution (WAPI'18)\n", "abstract": " In the last decade refactoring research has seen exponential growth. I will attempt to map this vast landscape and the advances that the community has made by answering questions such as who does what, when, where, why, and how. I will muse on some of the factors contributing to the growth of the field, the adoption of research into industry, and the lessons that we learned along this journey. This will inspire and equip you so that you can make a difference, with people who make a difference, at a time when it makes a difference.", "num_citations": "1\n", "authors": ["293"]}
{"title": "Design pattern refactoring by pretty-printing\n", "abstract": " Most design patterns in the Gang-of-Four text can be written as a refactoring script\u2013a programmatic sequence of refactorings. R3 is a new Java refactoring engine based on prettyprinting. It builds a main-memory, non-persistent database to encode containment relationships among Java entity declarations (eg, packages, classes, methods), language features such as inheritance and modifiers, and precondition checks for each declaration. R3 design pattern scripts modify the database and do not modify Abstract Syntax Trees (ASTs). While classical refactoring engines transform source code or ASTs directly, R3 produces refactored code by displaying the contents of the modified database when pretty-printing ASTs. R3 performs comparable precondition checks and code changes to that of the Eclipse Java Development Tools (JDT) refactorings but R3\u2019s codebase is about half the size of JDT refactorings and runs an\u00a0\u2026", "num_citations": "1\n", "authors": ["293"]}
{"title": "How Mobile Affects Business Processes? The Research Perspective\n", "abstract": " During the MobileDeli'14 workshop held at the SPLASH'14 conference we facilitated a panel, comprised of four distinguished, senior participants from industry. They started by presenting their position with respect to a set of predefined questions, and then we opened the floor to questions from the audience", "num_citations": "1\n", "authors": ["293"]}
{"title": "The Future of Refactoring (Dagstuhl Seminar 14211)\n", "abstract": " This report documents the program and the outcomes of Dagstuhl Seminar 14211 on\" The Future of Refactoring.\" Over the past decade, refactoring has become firmly established as an essential part of industrial software development. At the same time, academic interest in refactoring has grown at a fast pace, resulting in a large body of literature on many different aspects of refactoring. The aim of this seminar was to provide a forum for refactoring researchers and practitioners to discuss what has been achieved, get to know each others' work, and plan future collaboration. This report presents abstracts of the participants' talks and summaries of breakout sessions, and introduces some joint projects that were started as a result of the seminar.", "num_citations": "1\n", "authors": ["293"]}
{"title": "Can undergraduates script their own refactorings?\n", "abstract": " We present a status report on a project to build a refactoring engine whose primary goal is to allow undergraduate students to write classical and neo-classical refactorings (pull-up, class partitioning) and design patterns (visitor, framework) as parameterized refactoring scripts in Java. We explain the first step of our work that creates a reflection-like interface to expose the structure of an Eclipse JDT application as Java objects; methods of these objects are refactorings. Doing so hides the complexity of JDT refactoring code and tools, so that refactoring scripts can be written as compact Java methods. We present preliminary performance results of scripting JDT refactorings and sketch the next steps of our work.", "num_citations": "1\n", "authors": ["293"]}
{"title": "Bumblebee: A transformation environment for spreadsheet formulas\n", "abstract": " Spreadsheets are widely used in industry. It is estimated that end-user programmers outnumber regular programmers by a factor of 5. However, spreadsheets are error-prone: several reports exist of companies which have lost money because of spreadsheet errors. We assert that a contributing factor to these problems is the difficulty of consistent editing of spreadsheet formulas.In this paper, we observe the occurrence of copy-equivalent regions in spreadsheets, non-connected regions with similar formulas within one spreadsheet. These regions occur frequently in practice. Therefore, we design a strategy to consistently transform them, by presenting a grammar with which formula transformations can be described. We implemented these transformations in our tool BumbleBee, which is an Excel add-in that consistently applies transformations to spreadsheet formulas.", "num_citations": "1\n", "authors": ["293"]}
{"title": "The 2nd workshop on refactoring tools (WRT'08)\n", "abstract": " Refactoring is the process of applying behavior-preserving transformations to a program with the objective of improving the program's design. A specific refactoring is identified by a name (eg, Extract Method), a set of preconditions, and a set of specific transformations that need to be performed. Tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial and non-local program analysis, and applying the transformations may affect many locations in the program. In recent years, the emergence of light-weight programming methodologies such as Extreme Programming has generated a great amount of interest in refactoring, and refactoring support has become a required feature in modern-day IDEs. Until now, there has not been a suitable forum for discussions among researchers and developers of such tools. This full-day event on refactoring tools\u00a0\u2026", "num_citations": "1\n", "authors": ["293"]}
{"title": "Refactoring-aware software merging and configuration management\n", "abstract": " Refactoring tools allow programmers to change their source code quicker than before. However, the complexity of these changes cause versioning tools that operate at a file level to lose the history of entities and be unable to merge refactored entities. This problem can be solved by semantic, operation-based SCM with persistent IDs. MolhadoRef, our proto-type, can successfully merge edit and refactoring operations which were performed on different development branches, preserves program history better and makes it easier to understand program evolution.", "num_citations": "1\n", "authors": ["293"]}