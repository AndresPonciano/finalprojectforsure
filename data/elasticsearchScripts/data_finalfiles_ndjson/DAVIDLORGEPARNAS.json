{"title": "On the criteria to be used in decomposing systems into modules\n", "abstract": " This paper discusses modularization as a mechanism for improving the flexibility and comprehensibility of a system while allowing the shortening of its development time. The effectiveness of a \u0393\u00c7\u00a3modularization\u0393\u00c7\u00a5 is dependent upon the criteria used in dividing the system into modules. A system design problem is presented and both a conventional and unconventional decomposition are described. It is shown that the unconventional decompositions have distinct advantages for the goals outlined. The criteria used in arriving at the decompositions are discussed. The unconventional decomposition, if implemented with the conventional assumption that a module consists of one or more subroutines, will be less efficient in most cases. An alternative approach to implementation which does not have this effect is sketched.", "num_citations": "7178\n", "authors": ["41"]}
{"title": "On the design and development of program families\n", "abstract": " Program families are defined (analogously to hardware families) as sets of programs whose common properties are so extensive that it is advantageous to study the common properties of the programs before analyzing individual members. The assumption that, if one is to develop a set of similar programs over a period of time, one should consider the set as a whole while developing the first three approaches to the development, is discussed. A conventional approach called \"sequential development\" is compared to \"stepwise refinement\" and \"specification of information hiding modules.\" A more detailed comparison of the two methods is then made. By means of several examples it is demonstrated that the two methods are based on the same concepts but bring complementary advantages.", "num_citations": "1326\n", "authors": ["41"]}
{"title": "Designing software for ease of extension and contraction\n", "abstract": " Designing software to be extensible and easily contracted is discussed as a special case of design for change. A number of ways that extension and contraction problems manifest themselves in current software are explained. Four steps in the design of software that is more flexible are then discussed. The most critical step is the design of a software structure called the \" uses\" relation. Some criteria for design decisions are given and illustrated using a small example. It is shown that the identification of minimal subsets and minimal extensions can lead to software that can be tailored to the needs of a broad variety of users.", "num_citations": "1298\n", "authors": ["41"]}
{"title": "A rational design process: How and why to fake it\n", "abstract": " Many have sought a software design process that allows a program to be derived systematically from a precise statement of requirements. It is proposed that, although designing a real product in that way will not be successful, it is possible to produce documentation that makes it appear that the software was designed by such a process. The ideal process and the documentation that it requires are described. The authors explain why one should attempt to design according to the ideal process and why one should produce the documentation that would have been produced by that process. The contents of each of the required documents are outlined.", "num_citations": "1158\n", "authors": ["41"]}
{"title": "A technique for software module specification with examples\n", "abstract": " This paper presents an approach to writing specifications for parts of software systems. The main goal is to provide specifications sufficiently precise and complete that other pieces of software can be written to interact with the piece specified without additional information. The secondary goal is to include in the specification no more information than necessary to meet the first goal. The technique is illustrated by means of a variety of examples from a tutorial system.", "num_citations": "1029\n", "authors": ["41"]}
{"title": "Concurrent control with \u0393\u00c7\u00a3readers\u0393\u00c7\u00a5 and \u0393\u00c7\u00a3writers\u0393\u00c7\u00a5\n", "abstract": " The problem of the mutual exclusion of several independent processes from simultaneous access to a \u0393\u00c7\u00a3critical section\u0393\u00c7\u00a5 is discussed for the case where there are two distinct classes of processes known as \u0393\u00c7\u00a3readers\u0393\u00c7\u00a5 and \u0393\u00c7\u00a3writers.\u0393\u00c7\u00a5 The \u0393\u00c7\u00a3readers\u0393\u00c7\u00a5 may share the section with each other, but the \u0393\u00c7\u00a3writers\u0393\u00c7\u00a5 must have exclusive access. Two solutions are presented: one for the case where we wish minimum delay for the readers; the other for the case where we wish writing to take place as early as possible.", "num_citations": "758\n", "authors": ["41"]}
{"title": "Functional documents for computer systems\n", "abstract": " Although software documentation standards often go into great detail about the format of documents, describing such details as paragraph numbering and section headings, they fail to give precise descriptions of the information to be contained in the documents. This paper does the opposite; it defines the contents of documents without specifying their format or the notation to be used in them.We describe documents such as the \u0393\u00c7\u00a3System Requirements Document\u0393\u00c7\u00a5, the \u0393\u00c7\u00a3System Design Document\u0393\u00c7\u00a5, the \u0393\u00c7\u00a3Software Requirements Document\u0393\u00c7\u00a5, the \u0393\u00c7\u00a3Software Behaviour Specification\u0393\u00c7\u00a5, the \u0393\u00c7\u00a3Module Interface Specification\u0393\u00c7\u00a5, and the \u0393\u00c7\u00a3Module Internal Design Document\u0393\u00c7\u00a5 as representations of one or more mathematical relations. By describing those relations, we specify what information should be contained in each document.", "num_citations": "696\n", "authors": ["41"]}
{"title": "Scheduling processes with release times, deadlines, precedence and exclusion relations\n", "abstract": " An algorithm that finds an optimal schedule on a single processor for a given set of processes is presented. Each process starts executing after its release time and completes its computation before its deadline and a given set of precedence relations and exclusion relations defined on ordered pairs of process segments are satisfied. This algorithm can be applied to the important and previously unsolved problem of automated pre-run-time scheduling of processes with arbitrary precedence and exclusion in hard-real-time systems.< >", "num_citations": "549\n", "authors": ["41"]}
{"title": "Software aspects of strategic defense systems\n", "abstract": " A former member of the SDIO Panel on Computing in Support of Battle Management explains why he believes the \u0393\u00c7\u00a3Star Wars\u0393\u00c7\u00a5 effort will not achieve its stated goals.", "num_citations": "546\n", "authors": ["41"]}
{"title": "Evaluation of safety-critical software\n", "abstract": " Methods and approaches for testing the reliability and trustworthiness of software remain among the most controversial issues facing this age of high technology. The authors present some of the crucial questions faced by software programmers and eventual users.", "num_citations": "488\n", "authors": ["41"]}
{"title": "Information distribution aspects of design methodology\n", "abstract": " The role of documentation in the design and implementation of complex systems is explored, resulting in suggestions in sharp contrast with current practice. The concept of system structure is studied by examining the meaning of the phrase\" connections between modules11. It is shown that several system design goals (each suggesting a partial time ordering of the decisions) may be inconsistent. Some properties of programmers are discussed. System documentation, which makes all information accessible to anyone working on the project, is discussed. The thesis that such information\" broadcasting11 is harmful, that it is helpful if most system information is hidden from most programmers, is supported by use of the above mentioned considerations as well as by examples. An information hiding technique of documentation is exhibited in the appendix.IFIP CLASSIFICATION: 3 Language of Oral Presentation; English Statement of Originality: In the opinion of the author the paper contains a number of conclusions which have not been discussed or published elsewhere. No paper similar in scope to this paper is being presented for publication elsewhere.", "num_citations": "462\n", "authors": ["41"]}
{"title": "On satisfying timing constraints in hard-real-time systems\n", "abstract": " The authors explain why pre-run-time scheduling is essential if one wishes to guarantee that timing constraints will be satisfied in a large complex hard-real-time system. They examine some of the major concerns in pre-run-time scheduling and consider what formulations of mathematical scheduling problems can be used to address those concerns. This work provides a guide to the available algorithms.< >", "num_citations": "349\n", "authors": ["41"]}
{"title": "On the use of transition diagrams in the design of a user interface for an interactive computer system\n", "abstract": " This paper deals with what might be called the top level design of an interactive computer system. It examines some problems which arise in trying to specify what the user interface of such a system should be. It proposes a concept\u0393\u00c7\u00f6the terminal state\u0393\u00c7\u00f6and a notation\u0393\u00c7\u00f6the terminal state transition diagram\u0393\u00c7\u00f6which make the design of the top level somewhat easier. It also proposes a user interface in which the notion of terminal state is explicit. This user interface seems to provide a great improvement in flexibility and case of adding subsystems to a general purpose system.", "num_citations": "294\n", "authors": ["41"]}
{"title": "Software engineering programs are not computer science programs\n", "abstract": " Software Engineering programs have become a source of contention in many universities. Computer Science departments, many of which have used that phrase to describe individual courses for decades, claim SE as part of their discipline. Yet some engineering faculties claim it as a new specialty among the engineering disciplines. This article discusses the differences between traditional CS programs and most engineering programs, and argues that we need SE programs that follow the traditional engineering approach to professional education.", "num_citations": "292\n", "authors": ["41"]}
{"title": "Software requirements for the A-7E aircraft\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - Software Requirements for the A-7E Aircraft CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592 \u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5 \u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c4\u00ac\u00f4\u03c3\u00c5\u00fa\u00b5\u00d1\u00a1\u03c3\u00ef\u00d6 \u03c0\u00fc\u00ab\u03c3\u00e5\u00ec\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa Software Requirements for the A-7E Aircraft HENINGER KL \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 HENINGER KL \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 NRL Memorandum Report 3876, Naval Research Laboratory NRL Memorandum Report 3876, Naval Research Laboratory, 1978 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u03c3\u255c\u2563\u03c3\u00eb\u2593\u03c0\u00fc\u00bd\u03c3\u0192\u2551\u03c0\u00fc\u00d1\u03c0\u00fc\u00c5\u03c0\u00e9\u00f3\u03c0\u00e2\u00f9\u03c0\u00e2\u00ac\u03c0\u00e9\u2592\u03c0\u00e2\u255d\u03c0\u00e9\u2556\u03c0\u00e2\u00ba\u03c0\u00e2\u2502\u03c0\u00fc\u00ab\u00b5\u00ee\u00bb\u03a6\u00ea\u20a7\u03c0\u00fc\u00e4\u03c3\u00ea\u2562\u03c3\u255b\u00ed \u03c3\u00a5\u00e9\u03a3\u2555\u00ef \u03c3\u00fb\u00e4\u03c3\u255c\u00aa , \u03a3\u2551\u00f2\u03c3\u00e7\u2551\u03c3\u00c5\u00fa \u03c3\u00f4\u2593\u03c3\u00f1\u00bd , \u03a3\u255c\u00c9\u03a6\u00f9\u00f1 \u00b5\u00fb\u00e7\u00b5\u00ff\u00c4 , \u00b5\u2591\u2524\u0398\u00e7\u00c4 \u03c3\u2510\u00e1\u03c3\u00eb\u00e7 \u0398\u00a2\u2557\u03c3\u00a1\u00c9\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u0398\u00c7\u00dc\u03a3\u2510\u00ed\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03a6\u00ac\u00ee. B, \u0398\u00c7\u00dc\u03a3\u2510\u00ed 00082(00005), 972-980, 1999-05-25 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab19\u03a3\u2557\u2562 \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf \u00b5\u00fb\u00e7\u03c4\u00ee\u00ab2\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) 10000088142 \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03c0\u00fc\u00a5\u03c0\u00fc\u00ab\u03a3\u2557\u00fb \u03c0\u00e2\u00e7\u03c0\u00e2\u255d\u03c0\u00e9\u2510\u00b5\u00c5\u00c9\u03a3\u255b\u00a2\u03c3\u00e0\u00e2 CJP/(\u0393\u00c7\u00aa", "num_citations": "277\n", "authors": ["41"]}
{"title": "Wikipedia risks\n", "abstract": " Wikipedia risks Page 1 152 December 2005/Vol. 48, No. 12 COMMUNICATIONS OF THE ACM The Wikipedia (WP; en.wikipedia.org/wiki/) applies the wiki technology (from a Hawai- ian word for \u0393\u00c7\u00a3quick\u0393\u00c7\u00a5) to the encyclopedia, a venerable form of knowledge organization and dissemination. Wikipedia provides a fast and flexible way for anyone to create and edit encyclopedia articles without the delay and intervention of a formal editor or review process. The WP\u0393\u00c7\u00d6s over 750,000 articles are written and edited by volunteers. WP founder Jimmy Wales believes WP\u0393\u00c7\u00d6s free, open, and largely unregulated process will evolve toward an Encyclop\u251c\u00aadia Britannica or better quality. But will this process actually yield a reliable, authoritative reference encompassing the entire range of human knowledge? Opinions are mixed. WP claims to be the most popular reference site on the Internet. It has been hailed as the quintessence of the \u0393\u00c7\u00a3,, \u0393\u00c7\u00aa", "num_citations": "270\n", "authors": ["41"]}
{"title": "On a \u0393\u00c7\u00a3buzzword\u0393\u00c7\u00a5: hierarchical structure\n", "abstract": " This paper discusses the use of the term \u0393\u00c7\u00a3hierarchically structured\u0393\u00c7\u00a5 to describe the design of operating systems. Although the various uses of this term are often considered to be closely related, close examination of the use of the term shows that it has a number of quite different meanings. For example, one can find two different senses of \u0393\u00c7\u00a3hierarchy\u0393\u00c7\u00a5 in a single operating system [Dijkstra 68a*] and [Habermann 67]. An understanding of the different meanings of the term is essential, if a designer wishes to apply recent work in software engineering and design methodology. This paper attempts to provide such an understanding.", "num_citations": "260\n", "authors": ["41"]}
{"title": "Assessment of safety-critical software in nuclear power plants.\n", "abstract": " This paper outlines an approach to the design, documentation, and evaluation of computer systems. We believe that this approach allows the use of software in many safety-critical applications because it enables the systematic comparison of the program behaviour with the engineering specifications of the computer system. Many of the ideas in this paper have been used by the Atomic Energy Control Board of Canada (AECB) in their safety assessment of the software for the shutdown systems of the Darlington Nuclear Power Generating Station. The main elements of this approach are: a) Formal Documentation of Software Requirements: Most of the details of a complex environment can be ignored by system implementors and reviewers if they are given a complete and precise statement of the behavioural requirements for the computer system. We describe five mathematical relations that specify the requirements for the software in a computerised control system. b) Design and Documentation of the Modular Structure: Complexity caused by interactions between separately written components can be reduced by applying \u0393\u00c7\u00a3Information Hiding\u0393\u00c7\u00a5(also known as Data Abstraction, Abstract Data Types, and Object-Oriented Programming), provided that the interfaces are precisely, and completely, documented. c) Program Function Documentation: Software executions are lengthy sequences of state changes described by complex algorithms. The effects of these execution sequences can be precisely specified and documented using tabular representations of the program functions discussed by Mills and others. Further, large programs can be\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "246\n", "authors": ["41"]}
{"title": "Using test oracles generated from program documentation\n", "abstract": " The paper illustrates how software can be described precisely using LD-relations, how these descriptions can be presented in a readable manner using tabular notations, and one way such descriptions can be used to test programs. The authors describe an algorithm that can be used to generate a test oracle from program documentation, and present the results of using a tool based on it to help test part of a commercial network management application. The results demonstrate that these methods can be effective at detecting errors and greatly increase the speed and accuracy of test evaluation when compared with manual evaluation. Such oracles can be used for unit testing, in situ testing, constructing self-checking software, and ensuring consistency between code and documentation.", "num_citations": "228\n", "authors": ["41"]}
{"title": "Education for computing professionals\n", "abstract": " The author examines the state of computer science education and discusses the trend whereby computer science graduates are ending up in engineering jobs. He questions whether this back door to engineering is in the best interests of the students, their employers, and society. He argues that computer science programs must return to a classical engineering approach that emphasizes fundamentals.< >", "num_citations": "219\n", "authors": ["41"]}
{"title": "Tabular representation of relations\n", "abstract": " Multi-dimensional mathematical expressions, called tables, have proven to be useful for documenting digital systems. This paper describes 10 classes of tables, giving their syntax and semantics. Several abbreviations that can be useful in tables are introduced. Simple examples are provided.", "num_citations": "201\n", "authors": ["41"]}
{"title": "Using assertions about traces to write abstract specifications for software modules\n", "abstract": " A specification for a software module is a statement of the requirements that the final programs must meet. In this paper we concentrate on that portion of the specification that describes the interface between the module being specified and other programs (or persons) that will interact with that module. Because of the complexity of software products, it is advantageous to be able to evaluate the design of this interface without reference to any possible implementations. The first sections of this paper present an approach to the writing of black box specifications, that takes advantage of Guttag's work on abstract specification [9]. Then we illustrate it on a number of small examples, and discuss checking the completeness of a specification. Finally we describe a case history of a module design. Although the module is a simple one, the early specifications (written using an earlier notation) contained design flaws that\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "154\n", "authors": ["41"]}
{"title": "Tabular representations in relational documents\n", "abstract": " In this chapter the use of relations, represented as tables, for documenting the requirements and behaviour of software is motivated and explained. A formal model of tabular expressions, defining the meaning of a large class of tabular forms, is presented. Finally, we discuss the transformation of tabular expressions from one form to another, and illustrate some useful transformations.", "num_citations": "152\n", "authors": ["41"]}
{"title": "Precise documentation of well-structured programs\n", "abstract": " Describes a new form of program documentation that is precise, systematic and readable. This documentation comprises a set of displays supplemented by a lexicon and an index. Each display presents a program fragment in such a way that its correctness can be examined without looking at any other display. Each display has three parts: (1) the specification of the program presented in the display, (2) the program itself, and (3) the specifications of programs invoked by this program. The displays are intended to be used by software engineers as a reference document during inspection and maintenance. This paper also introduces a specification technique that is a refinement of H.D. Mills's (1975) functional approach to program documentation and verification; programs are specified and described in tabular form.< >", "num_citations": "150\n", "authors": ["41"]}
{"title": "Software Requirements for the A-7E Aircraft.\n", "abstract": " The Software Cost Reduction SCR research project introduced a new approach to specifying requirements for real-time embedded systems. The principles were applied in the development of the Software Requirements of the A-7E Aircraft, as an example of the use of the approach. The system software requirements specification document comprises the first product in a series of products which the SCR methodology produces, The methodology is intended to be adaptable for various types of systems. Specification properties which it supports include 1 conciseness, 2 preciseness, 3 aids to completeness, 4 avoidance of redundancy, 5 descriptions of all externally visible behavior, 6 ease of change, 7 good reference tool, 8 record of fundamental assumptions which might otherwise be only implicit, 9 record of responses to error conditions, 10 specification of constraints on the system, and 11 separation of concerns that is, a division of the information into distinct, independent parts.Descriptors:", "num_citations": "146\n", "authors": ["41"]}
{"title": "On synchronization in hard-real-time systems\n", "abstract": " The design of software for hard-real-time systems is usually difficult to change because of the constraints imposed by the need to meet absolute real-time deadlines on processors with limited capacity. Nevertheless, a new approach involving a trio of ideas appears to be helpful for those who build software for such complex applications.", "num_citations": "145\n", "authors": ["41"]}
{"title": "Predicate logic for software engineering\n", "abstract": " The interpretations of logical expressions found in most introductory textbooks are not suitable for use in software engineering applications because they do not deal with partial functions. More advanced papers and texts deal with partial functions in a variety of complex ways. This paper proposes a very simple change to the classic interpretation of predicate expressions, one that defines their value for all values of all variables, yet is almost identical to the standard definitions. It then illustrates the application of this interpretation in software documentation.< >", "num_citations": "142\n", "authors": ["41"]}
{"title": "Priority scheduling versus pre-run-time scheduling\n", "abstract": " Builders of real-time systems often use priority scheduling in their systems without considering alternatives. This paper examines one alternative, pre-run-time scheduling, and show that when it can be applied it has significant advantages when compared to priority scheduling schemes.", "num_citations": "136\n", "authors": ["41"]}
{"title": "Documentation for safety critical software\n", "abstract": " The authors review some of the fundamental difficulties presented by the design and the validation of software for safety critical applications. They suggest that software formal documentation techniques ameliorate the problems described. The principles behind a method of documenting both requirements and software design are presented. The methods have been used by the Atomic Energy Control Board of Canada in its safety assessment of the shutdown software of the Darlington generating station (D.L. Parnas et al., 1991). The method is illustrated by applying it to a small portion of the safety feature actuation system of a PWR nuclear reactor.< >", "num_citations": "126\n", "authors": ["41"]}
{"title": "Stop the numbers game\n", "abstract": " Counting papers slows the rate of scientific progress.", "num_citations": "124\n", "authors": ["41"]}
{"title": "Precise documentation: The key to better software\n", "abstract": " The prime cause of the sorry \u0393\u00c7\u00a3state of the art\u0393\u00c7\u00a5 in software development is our failure to produce good design documentation. Poor documentation is the cause of many errors and reduces efficiency in every phase of a software product\u0393\u00c7\u00d6s development and use. Most software developers believe that \u0393\u00c7\u00a3documentation\u0393\u00c7\u00a5 refers to a collection of wordy, unstructured, introductory descriptions, thousands of pages that nobody wanted to write and nobody trusts. In contrast, Engineers in more traditional disciplines think of precise blueprints, circuit diagrams, and mathematical specifications of component properties. Software developers do not know how to produce precise documents for software. Software developments also think that documentation is something written after the software has been developed. In other fields of Engineering much of the documentation is written before and during the development. It\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "123\n", "authors": ["41"]}
{"title": "The role of inspection in software quality assurance\n", "abstract": " Due to the complexity of the code, software is released with many errors. In response, both software practitioners and software researchers need to improve the reputation of the software. Inspection is the only way to improve the quality of software. Inspection methods can be more effective but success depends on having a sound and systematic procedure for conducting the inspection. The Workshop on Inspection in Software Engineering (WISE), a satellite event of the 2001 Computer Aided Verification (CAV '01) Conference, brought together researchers, practitioners, and regulators in the hope of finding effective approaches to software inspection. The workshop included invited lectures and paper presentations in the form of panel discussions on all aspects of software inspection. Submissions explained how practitioners and researchers were performing inspections, discussed the relevance of inspections\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "123\n", "authors": ["41"]}
{"title": "A procedure for designing abstract interfaces for device interface modules\n", "abstract": " This paper describes the abstract interface principl~: and shows how it can be applied in the design ol device interface modules. The purpose of this principle is to reduce maintenance costs for embedded real-time software by facilitating the adaptation of the software to altered hardware interfaces. This principle has been applied in the Naval Research Laboratory's redesign of the flight software for the Navy's A-7 aircraft. This paper discusse~ a design approach based on the abstract interface principle and presents solutions to interest~. ng problems encountered in the A-7 redesign. The specification document for the A-7 device interface modules is available on request; it provides a fully worked out example of the design approach discussed in this paper.", "num_citations": "123\n", "authors": ["41"]}
{"title": "Really rethinking'formal methods'\n", "abstract": " There is also a disturbing gap between software development and traditional engineering disciplines. Software developers often identify themselves as engineers, but their education and way of working are not at all like those of traditional engineers. Engineering programs teach basic science, applicable mathematics, and how to apply mathematics to predict the behavior of products. Most computer science departments teach technology (which is often of fleeting value in our rapidly changing field) and abstract mathematics that the students do not learn to apply.Twenty years ago, I heard a wise and experienced toplevel manager complain that his software developers and his other engineers spoke such different \u0393\u00c7\u00a3languages\u0393\u00c7\u00a5 and thought in such different ways that it was difficult for them to work together. That gap is still with us.", "num_citations": "116\n", "authors": ["41"]}
{"title": "Response to undesired events in software systems\n", "abstract": " This paper discusses an approach to handling run-time errors in software systems. It is often assumed that in programs which can be proven correct, errors will not be a problem. This paper is predicated on the assumption that, even with correct programs, undesired events at run-time will continue to be a problem. Routines to respond to these undesired events (UEs) must be provided in reliable systems.", "num_citations": "113\n", "authors": ["41"]}
{"title": "Using documentation as a software design medium\n", "abstract": " This article describes a software design method based on the principles of separation of concerns and information hiding. The principle of separation of concerns is used to structure the design documentation, and information hiding is used to guide the internal design of the software. Separation of concerns requires that design information be divided into clearly distinct and relatively independent documents. The design documents are the main products of the initial design phase, and are carefully structured to (i) expose open issues, (ii) express design decisions, and (iii) ensure that information is recorded in a way that allows it to be readily retrieved later. Information hiding is used to design software that is easy to change. We have applied many elements of the design method to the development of the No. 2 Service Evaluation System (SES), a multiprocessor data acquisition and transaction system. Our\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "112\n", "authors": ["41"]}
{"title": "Generating a test oracle from program documentation: work in progress\n", "abstract": " A fundamental assumption of software testing is that there is some mechanism, an oracle, that will determine whether or not the results of a test execution are correct. In practice this is often done by comparing the output, either automatically or manually, to some pre-calculated, presumably correct, output [17]. However, if the program is formally documented it is possible to use the specification to determine the success or failure of a test execution, as in [1], for example. This paper discusses ongoing work to produce a tool that will generate a test oracle from formal program documentation.", "num_citations": "111\n", "authors": ["41"]}
{"title": "Use of the concept of transparency in the design of hierarchically structured systems\n", "abstract": " This paper deals with the design of hierarchically structured programming systems. It develops a method for evaluating the cost of requiring programmers to work with an abstraction of a real machine. A number of examples from hardware and software are given as illustrations of the method.", "num_citations": "111\n", "authors": ["41"]}
{"title": "A generalized control structure and its formal definition\n", "abstract": " A new programming language control structure as well as an improved approach to a formal definition of programming languages are presented. The control structure can replace both iteration and conditional structures. Because it is a semantic generalization of those structures, a single statement using the new control structure can implement the functions of loops, conditionals, and also programs that would require several conventional constructs. As a consequence of this increased capability, it is possible to write algorithms that are simpler, more efficient, and more clearly correct than those that can be written with earlier structured-programming control structures. In order to provide a precise definition of the new constructs, a new version of relational semantics, called LD-relations is presented. An algebra of these relations is developed and used to define the meaning of the new constructs. A short discussion of\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "108\n", "authors": ["41"]}
{"title": "The influence of software structure on reliability\n", "abstract": " This paper assumes software structure to be characterized by the interfaces between subsystems or modules. Reliability is considered to be a measure of the extent to which the system can be expected to deliver usable services when those services are demanded. It is argued that reliability and correctness (in the sense used in current computer literature) are not synonyms. The differences suggest techniques by which the reliability of software can be improved even while the production of correct software remains beyond our reach. In general, the techniques involve considering certain unpleasant facts of life at an early stage in the design process, the stage where the structure is determined, rather than later. An appendix gives some specific examples of questions which, if they are thoughtfully considered early in the design, can lead to more reliable systems.", "num_citations": "101\n", "authors": ["41"]}
{"title": "Documentation of requirements for computer systems\n", "abstract": " A functional approach to specifying the requirements of a computer system is discussed. The method allows system requirements to be documented, whether the system is implemented using a computer and peripheral devices, or, for example, relays and analog components. The method is a refinement of the method used in the A-7 aircraft software requirements model document. The approach is illustrated with examples derived from a software requirements document for a water level monitoring system.< >", "num_citations": "100\n", "authors": ["41"]}
{"title": "Requirements-based monitors for real-time systems\n", "abstract": " Before designing safety- or mission-critical real-time systems, a specification of the required behavior of the system should be produced and reviewed by domain experts. After the system has been implemented, it should be thoroughly tested to ensure that it behaves correctly. This is best done using a monitor, a system that observes the behavior of a target system and reports if that behavior is consistent with the requirements. Such a monitor can be used both as an oracle during testing and as a supervisor during operation. Monitors should be based on the documented requirements of the system. If the target system is required to monitor or control real-valued quantities, then the requirements, which are expressed in terms of the monitored and controlled quantities, will allow a range of behaviors to account for errors and imprecision in observation and control of these quantities. Even if the controlled variables are\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "95\n", "authors": ["41"]}
{"title": "On satisfying timing constraints in hard-real-time systems\n", "abstract": " We explain why pre-run-time scheduling is essential if we wish to guarantee that timing constraints will be satisfied in alarge complex hard-real-time system. We examine some of the major concerns in pre-run-time scheduling and consider what formulations of mathematical scheduling problems can be used to address those concerns. A purpose of this paper is to provide a guide to the available algorithms.", "num_citations": "92\n", "authors": ["41"]}
{"title": "A rational design process: How and why to fake it\n", "abstract": " Software Engineers have been searching for the ideal software development process: a process in which programs are derived from specifications in the same way that lemmas and theorems are derived from axioms in published proofs. After explaining why we can never achieve it, this paper describes such a process. The process is described in terms of a sequence of documents that should be produced on the way to producing the software. We show that such documents can serve several purposes. They provide a basis for preliminary design review, serve as reference material during the coding, and guide the maintenance programmer in his work. We discuss how these documents can be constructed using the same principles that should guide the software design. The resulting documentation is worth much more than the \"afterthought\" documentation that is usually produced. If we take the care to keep\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "89\n", "authors": ["41"]}
{"title": "Software engineering (extended abstract) an unconsummated marriage\n", "abstract": " When the first conference on \u0393\u00c7\u00a3Software Engineering\u0393\u00c7\u00a5 was held, under NATO sponsorship three decades ago in Munich, the vast majority of Engineers ignored it. Electrical Engineers were obviously interested in building computers, but they regarded programming those computers as something to be done by others, often scientists who wanted the numerical results, or mathematicians who were interested in numerical methods. Programming was not viewed as engineering, but as a trivial task, akin to using a calculator. An engineer might have to perform such a task in order to get numerical results needed for some other task, but their real job was the other task.The organisers of the first Software Engineering conferences saw things differently. Knowing that the engineering profession has always been very protective of its legal right to control tire use of the word \u0393\u00c7\u00ffengineei\u0393\u00c7\u00d6, they chose the title of the conference to\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "86\n", "authors": ["41"]}
{"title": "A debate on teaching computing science\n", "abstract": " t the ACM Computer Science Conference last February, Edsger Dijkstra gave an invited talk A called \u0393\u00c7\u00a3On the Cruelty of Really Teaching Computing Science.\u0393\u00c7\u00a5 He challenged some of the basic assumptions on which our curricula are based and provoked a lot of discussion. The editors of Comwunications received several recommendations to publish his talk in these pages. His comments brought into the foreground some of the background of controversy that surrounds the issue of what belongs in the core of a computer science curriculum. To give full airing to the controversy, we invited Dijkstra to engage in a debate with selected colleagues, each of whom would contribute a short critique of his position, with Dijkstra himself making a closing statement. He graciously accepted this offer. We invited people from a variety of specialties, backgrounds, and interpretations to provide their comments. David Parnas is a noted\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "74\n", "authors": ["41"]}
{"title": "The real risks of artificial intelligence\n", "abstract": " Incidents from the early days of AI research are instructive in the current AI environment.", "num_citations": "72\n", "authors": ["41"]}
{"title": "Use of abstract interfaces in the development of software for embedded computer systems\n", "abstract": " This report describes a procedure for designing computer systems that are developed specifically to be a component of a more complex system. Two significant characteristics of such design problems are the following the computer system interface is determined by factors outside the control of the computer system designer, and the specifications of that interface are likely to change throughout the life cycle of the system. The purpose of the procedure described in this report is to reduce maintenance costs by means of a software organization that insulates most of the programs from changes in the interface. The procedure is based on the systematic compilation of an assumption list. The assumption list describes those aspects of the interface that future users and other knowledgeable persons consider essential and therefore stable. Other aspects of the interface are ignored. An abstract interface is designed on the basis of this assumption list. A specification of the abstract interface is used to procure the major components of the system. This report explains the principles behind the procedure and illustrates its use. The success of the procedure is primarily limited by the ability of designers and future users to compile an accurate list of assumptions. A side benefit of the procedure is simpler, better structured software. Successful application of the procedure should result in both increased reliability and reduced lift-cycle costs.Descriptors:", "num_citations": "72\n", "authors": ["41"]}
{"title": "A-7E Software Module Guide.\n", "abstract": " This document describes the basic organization of NRLs version of the A-7E onboard flight software. The report describes a structure in which modules have been designed in accordance with the Information Hiding Principle. Because of the larger number of modules that result when this principle is applied, the modules are arranged in a hierarchy. The hierarchy should simplify the task of a maintenance programmer assigned to make a specific modification. The document also describes the principles used in the design of the software. It is intended to be useful both as a guide to the A-7E software and as a model for those developing other software systems. AuthorDescriptors:", "num_citations": "69\n", "authors": ["41"]}
{"title": "Simulating the behavior of software modules by trace rewriting\n", "abstract": " The trace assertion method is a module interface specification method based on the finite state machine model. To support this method, we plan to develop a specification simulation tool, a trace simulator, that symbolically interprets trace assertions of trace specifications and simulates the externally observable behavior of the modules specified. We first present the trace assertion method. Then we formally define trace rewriting systems and show how trace rewriting, a technique similar to term rewriting, can be applied to implement trace simulation.< >", "num_citations": "65\n", "authors": ["41"]}
{"title": "Inspection of Safety-Critical Software Using Program-Function Tables.\n", "abstract": " Software whose failure could cause serious damage or loss of life must be carefully inspected before it enters service. To be confident that we have considered all cases and possible event sequences, we must follow a systematic procedure based on a sound mathematical model. This paper describes our experience with such a procedure.", "num_citations": "63\n", "authors": ["41"]}
{"title": "Software engineering or methods for the multi-person construction of multi-version programs\n", "abstract": " This talk will describe some methods which have been used to produce a family of related software products using many relatively unskilled programmers. The primary topics of the talk will be:                                    1.                                         An interpretation of the word \"structure\" with regard to software;                                                                        2.                                         Criteria to be used in decomposing software into modules;                                                                        3.                                         Problems and techniques with regard to software module specifications.                                                                 The talk will be introductory in nature emphasizing the desired properties of well engineered software systems and providing an overview of new methods which have proven useful in achieving those properties.", "num_citations": "55\n", "authors": ["41"]}
{"title": "SODAS and a methodology for system design\n", "abstract": " SODAS (Structure Oriented Description And Simulation) is a simulation language and compiler being designed at Carnegie Tech for use as a tool by the designers of computer systems. The structure of the language and its translator reflect a definition of\" system\" and a methodology for\" system design.\" It is the purpose of this paper to present the proposed methodology and language.", "num_citations": "54\n", "authors": ["41"]}
{"title": "On a solution to the cigarette smoker's problem (without conditional statements)\n", "abstract": " This report discusses a problem first introduced by Patil, who has claimed that the cigarette smoker's problem cannot be solved using the P and V operations introduced by Dijkstra unless conditional statements are used. An examination of Patil's proof shows that he has established this claim only under strong restrictions on the use of P and V. These restrictions eliminate programming techniques used by Dijkstra and others since the first introduction of the semaphore concept. This paper contains a solution to the problem. It also discusses the need for the generalized operators suggested by Patil.", "num_citations": "51\n", "authors": ["41"]}
{"title": "Some software engineering principles\n", "abstract": " Some software engineering principles | Software fundamentals ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware fundamentals: collected papers by David L. ParnasSome software engineering principles chapter Some software engineering principles Share on Author: David Lorge Parnas profile image David L. Parnas View Profile Authors Info & Affiliations Publication: Software fundamentals: collected papers by David L. ParnasMay 2001 Pages 257\u0393\u00c7\u00f4266 2citation 0 Downloads Metrics Total Citations2 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been and to\u0393\u00c7\u00aa", "num_citations": "50\n", "authors": ["41"]}
{"title": "Defining the meaning of tabular mathematical expressions\n", "abstract": " Mathematical expressions in tabular form (also called \u0393\u00c7\u00a3tabular expressions\u0393\u00c7\u00a5 or \u0393\u00c7\u00a3tables\u0393\u00c7\u00a5) have been shown to be useful for documenting and analysing software systems. They are usually easier to read than conventional mathematical expressions but are no less precise. They can be used wherever mathematical expressions are used. To avoid misunderstandings, and to support users with trustworthy tools, the meaning of these expressions must be fully defined.This paper presents a new method for defining the meaning of tabular expressions. Each definition of an expression type names the expression\u0393\u00c7\u00d6s constituents, and provides a restriction schema and one or more evaluation schemas. The restriction schema defines the class of well-formed expressions of the type. An evaluation schema maps a well-formed tabular expression of the type to a mathematical expression of a previously defined type. Since the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "49\n", "authors": ["41"]}
{"title": "Using traces to write abstract specifications for software modules\n", "abstract": " A specification for a software module is a statement of the requirements that the final programs must meet. In this paper we concentrate on that portion of the specification that describes the interface between the module being specified and other programs (or persons) that will interact with that module. Because of the complexity of software products, it is advantageous to be able to evaluate the design of this interface without reference to any possible irrplementations. The first sections of this paper present a new approach to the writing of black box specifications, illustrate it on a number of small examples, and discuss checking the comfleteness of a specification. section VIII is a case history of a module design. Although the module is a simple one, the early specifications (writ ten using an earlier notation) contained design flaws that were not detected in spite of the involvement of several persons in a series of discussions about the module. These errors are easily recognized using the method introduced in this paper.We are concerned with the building of software products that are so large that we cannot manage the task unless_we reduce it to a series of small tasks. We further assume that each of the subtasks (which we call modules) will focus on one portion of the design and hide the details of that aspect of the design from t. he rest of the system. This has become known as the\" information hiding principle,\" encapsulation, data abstraction, etc.[1, 2, 3]. The design process will only go smoothly if the inter-module interfaces are precisely defined. Ideally, the interface description states only the reguirements that the component must satis. fy and does\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "47\n", "authors": ["41"]}
{"title": "Some theorems we should prove\n", "abstract": " Mathematical techniques can be used to produce precise, provably complete documentation for computer systems. However, such documents are highly detailed; oversights and other errors arc quite common. To detect the \u0393\u00c7\u00a3early\u0393\u00c7\u00a5 errors in a document, one must attempt to prove certain simple theorems. This paper gives some examples of such theorems.", "num_citations": "45\n", "authors": ["41"]}
{"title": "Some hypotheses about the\" uses\" hierarchy for operating systems\n", "abstract": " The research group BS I (Betriebssysteme= Operating Systems) at the Technical University Darmstadt is seeking design decisions which can be common to a broad family of operating systems [1]. Because such design decisions as resource allocation algorithms and data representations tend to be hardware, conguration, or application dependent, our eorts have focused on structural decisions. Our research procedure consists of two clearly distinguished stages. In the rst stage we use\\theoretical\" methods (eg mathematical models, the study of existing systems, etc.) to formulate a set of hypotheses about the structure of an operating system family. In the second stage, an experimental system will be built for the purpose of testing these hypotheses and suggesting revisions of them. This report describes our current working hypotheses. Evaluation of these hypotheses is now in progress. Although this work is the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "45\n", "authors": ["41"]}
{"title": "Disciplined methods of software specification: a case study\n", "abstract": " We describe our experience applying tabular mathematical approaches to software specifications. Our purpose is to show alternative approaches to writing tabular specifications and to help practitioners who want to apply such methods by allowing them to pick the best one for their problem. The object for the case study is software used by Dell Products for testing the functionality of the keyboards on notebook computers. Starting from informal documents, we developed a variety of tabular representations of finite state machine specifications and tabular trace specifications. We found that the discipline required by these methods raised issues that had never been considered and resulted in documents that were both more complete and much clearer. The various tabular representations are compared from a user's point of view, i.e., clarity, consistency, unambiguity, completeness, suitability, etc.", "num_citations": "41\n", "authors": ["41"]}
{"title": "The secret history of information hiding\n", "abstract": " The concept of \u0393\u00c7\u00a3information-hiding\u0393\u00c7\u00a5 as a software design principle is widely accepted in academic circles. Many successful designs can be seen as successful applications of abstraction or information hiding. On the other hand, most industrial software developers do not apply the idea and many consider it unrealistic. This paper describes how the idea developed, discusses difficulties in its application, and speculates on why it has not been completely successful.", "num_citations": "41\n", "authors": ["41"]}
{"title": "Response to detected errors in well-structured programs\n", "abstract": " This paper discusses an approach to handling run time errors in wellstructured programs. It is often assumed that in well-structured programs which can be proven correct errors will not be a problem. This paper is predicated on the assumption that run time errors will continue to be a problem.", "num_citations": "41\n", "authors": ["41"]}
{"title": "Specification of software component requirements using the trace function method\n", "abstract": " This paper describes the application of the Trace Function Method to specify the requirements of a software component. We illustrate the method on a software component of a telecommunications system that was developed by Ericsson. Beginning with incomplete informal descriptions, we analysed the requirements of the system and wrote a description that contains all pertinent information in one easily used reference document. The resulting documentation is more compact and complete than traditional software documentation and provides precise information that will be useful for testing and inspection.", "num_citations": "39\n", "authors": ["41"]}
{"title": "Document based rational software development\n", "abstract": " A software development process can be considered rational if each design decision can be justified based on given facts and design decisions that were made, reviewed, and accepted earlier. This paper describes a set of documents that can serve as a \u0393\u00c7\u00a3knowledge base\u0393\u00c7\u00a5 for more rational software development. Each of these documents can be viewed as a place where the decisions made in one phase of a software development can be recorded for those who work in the next phase. These documents make it possible to develop software in a rational and reviewable way. We describe why each document is needed, how it should be organized, and how the information in the whole set of documents can be represented in a precise, checkable, and accessible way. We illustrate the approach with a detailed discussion of one of these documents, module interface documentation.", "num_citations": "38\n", "authors": ["41"]}
{"title": "Why software jewels are rare\n", "abstract": " A software jewel is a well structured program written in a consistent style, developed so that each component is simple and organized, and designed so that the product is easy to change. Despite helpful articles and many textbooks on software design, software jewels remain rare. Most of the software we see or buy is ugly, unreliable, hard to change. I discuss why the recipes of the masters have not led to more elegant commercial software and then provide some advice for those who would like to produce better software.", "num_citations": "38\n", "authors": ["41"]}
{"title": "A formal approach to computer systems requirements documentation\n", "abstract": " This paper demonstrates how the extended duration calculus", "num_citations": "38\n", "authors": ["41"]}
{"title": "\u0393\u00c7\u00a3Formal methods\u0393\u00c7\u00a5 technology transfer will fail\n", "abstract": " For formal methods technology transfer to succeed, we must do two things: (1) integrate formal methods into basic university programming courses, and (2) improve the methods until they are better suited for practical application. Formal methods cannot be an \u0393\u00c7\u00a3add-on\u0393\u00c7\u00a5 that is taught after programmers acquire bad habits, and they must produce documents that are easier to read than the programs that they describe.", "num_citations": "37\n", "authors": ["41"]}
{"title": "Software engineering principles\n", "abstract": " Software engineering, the construction of useful programs, usually involves seve;ral people and programs that will be maintained in several versions. This paper discusses the technical problems that arise from the need to co-ordinate many people in the construction of families of similar, but not identical, programs. The problems that we discuss include using documentation as a software design medium; writing software requirements documents that are complete and precise; the meaning of \"structure\" in software design; the decomposition of programming projects into work assignments (modules); precise specification of the work assignments (modules); designing systems so that they are easily contracted or extended; designing abstract interfaces for modules; applying the concept of co-operating sequential processes; specifying and summarizing the behaviour of programs. This paper is intended to provide an\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "37\n", "authors": ["41"]}
{"title": "Inspection\u0393\u00c7\u00d6s role in software quality assurance\n", "abstract": " Authorized licensed use limited to: University of Limerick. Downloaded on May 19, 2009 at 06: 23 from IEEE Xplore. Restrictions apply. proofs, but their success depends on having a sound, systematic procedure. Tools that support this procedure are also important. The Workshop on Inspection in Software Engineering (WISE), a satellite event of the 2001 Computer Aided Verification Conference (CAV 01), brought together researchers, practitioners, and regulators in the hope of finding new, more effective software inspection approaches. Submissions described how practitioners and researchers were performing inspections, discussed inspections\u0393\u00c7\u00d6 relevance, provided evidence of how refinement of the inspection process and computer-aided tool support can improve inspections, and explained how careful software design could make inspections more effective. The best ideas from the workshop have been distilled into pairs of articles appearing in linked special issues of IEEE Software and IEEE Transactions on Software Engineering.", "num_citations": "35\n", "authors": ["41"]}
{"title": "Abstract Interface Specifications for A-7E Device Interface Module\n", "abstract": " The Operational Flight Program (OFP) for the Navy's A-7 aircraft is considered a successful program: it works reliably. However it is expensive to maintain because it has problems typical of much DoD software:* it barely meets its time and space limitations,* it is not fully understood by the maintenance personnel,* it is poorly documented, and* it is difficult to change.Although various software engineering techniques have been proposed to deal with such problems, there is a widespread reluctance to modify or abandon current techniques which, despite the problems mentioned above, are the basis for many acceptable programs such as the A-7 OFP. Two reasons for this reluctance are:", "num_citations": "35\n", "authors": ["41"]}
{"title": "A language for describing the functions of synchronous systems\n", "abstract": " Before the design of a system is started, the exact function desired of it should be specified. It is suggested that a computer-oriented language be used for this purpose. The inadequacies of the standard programming languages for the description of systems are discussed, and a dialect of ALGOL which is suitable for describing synchronous systems is introduced. These descriptions can be used for simulation and automatic design of the system described, in addition to communicating system specifications.", "num_citations": "35\n", "authors": ["41"]}
{"title": "Some conclusions from an experiment in software engineering techniques\n", "abstract": " In two earlier reports we have suggested some techniques to be used producing software with many programmers. The techniques were especially suitable for software which would exist in many versions due to modifications in methods or applications. These techniques have been taught in an undergraduate course and used in an experimental project in that course. The purpose of this report is to describe the results that have been obtained and to discuss some conclusions which we have reached. The experiment was completely uncontrolled, the programmers generally inexperienced and poor, and the programming system used was not designed for the task. The numerical data presented below have no real value. We include them primarily as an illustration of the type of result that can be obtained by use of the techniques described in the earlier reports. We consider these results a drastic improvement over\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "34\n", "authors": ["41"]}
{"title": "Comments on\" A comparison of two synchronizing concepts by PB Hansen\"\n", "abstract": " Comments on \"A comparison of two synchronizing concepts by PB Hansen\" | Acta Informatica ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Acta Informatica Periodical Home Latest Issue Archive Authors Affiliations Award Winners More HomeBrowse by TitlePeriodicalsActa InformaticaVol. , No. Comments on \"A comparison of two synchronizing concepts by PB Hansen\" article Comments on \"A comparison of two synchronizing concepts by PB Hansen\" Share on Authors: Pierre Jacques Courtois profile image PJ Courtois MBLE Research Laboratory, Brussels, Belgium MBLE Research Laboratory, Brussels, Belgium View Profile , F Heymans profile image F. Heymans MBLE Research Laboratory, Brussels\u0393\u00c7\u00aa", "num_citations": "33\n", "authors": ["41"]}
{"title": "MATHEMATICAL-DESCRIPTION AND SPECIFICATION OF SOFTWARE\n", "abstract": " Techniques for precise descriptions of programs can be of great practical significance if they are simple. We argue that thinking in terms of ''semantics'' is misleading and present a simple mathematical model for complete descriptions of program effects.", "num_citations": "32\n", "authors": ["41"]}
{"title": "A Standard Organization for Specifying Abstract Interfaces.\n", "abstract": " NRLs Software Cost Reduction project is demonstrating the feasibility of applying advanced software engineering techniques to complex real time systems to simplify maintenance. To demonstrate the principles, the onboard software for the Navys A 7E aircraft is being redesigned and reimplemented. The project is producing a set of model procedures and documents that can be followed by designers and producers of other software systems.Descriptors:", "num_citations": "30\n", "authors": ["41"]}
{"title": "Pre-run-time scheduling of processes with exclusion relations on nested or overlapping critical sections\n", "abstract": " Nested or overlapping critical sections in processes frequently occur in many hard-real-time system applications. For a pre-run time schedule, the ability to schedule such processes can often significantly increase the chances of finding a feasible schedule. The authors study the properties of exclusion relations defined on nested or overlapping critical sections. An algorithm is presented that is able to systematically search for a feasible schedule that satisfies a given set of release times, deadline constraints, and precedence and exclusion relations, where the exclusion relations are defined on critical sections that may nest within or overlap with each other.< >", "num_citations": "29\n", "authors": ["41"]}
{"title": "The non-problem of nested monitor calls\n", "abstract": " A monitor is a set of programs that keep track of~ regulate, or control the usage of some resource [2]. This term was used with this meaning at least as early as the late 50's. Hoare [3] and~ rinch-Hansen [4] have introduced linguistic constructs intended to ease the construction of such sets cf~ rograms. lit is important not to confuse one linguistic construct with the mechanism that is to be i~ ple mented.Lister states\" One of the fundamental attributes of a monitor is that executions of its procedures are mutually exclusive in time. This restriction is a necessary condition for ensuring the integrity of the data and resources administered by a monitors\" In fact, mutual exclusion is not fundamental to the monitor concept; it is an i=~ lementation technique chosen hy Hoare and Brinch-Hansen (apparently in the belief that this was the simplest mechanism by which programmers could ensure the integrity of their data). Ensuring the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "29\n", "authors": ["41"]}
{"title": "Design and specification of the minimal subset of an operating system family\n", "abstract": " The authors are engaged in a project to produce a precise description of a design for a family of operating systems. The design decisions ue being expressed by means of formal module specifications. In an attempt to write a concise specification of one of the most critical modules, a \"virtual memory mechanism,\" some previously discussed specification techniques proved to be inadequate. The specification was much too large. Through a series of improvements in both the design and the specification techniques we have achieved a much more compact description. This paper begins with the motivation for the design, explains the problems discovered in earlier approaches, and describes the improvements that were made. Finally, the design and its specification are explained.", "num_citations": "29\n", "authors": ["41"]}
{"title": "Availability evaluation of hardware/software systems with several recovery procedures\n", "abstract": " The use of several distinct recovery procedures is one of the techniques that can be used to ensure high availability and fault-tolerance of computer systems. This method has been applied to telecommunications systems and usually uses redundant hardware and special recovery software to restore the system after hardware and software failures. We propose a simple practical analytical approach to availability evaluation of systems with several recovery procedures based on a new 'segregated failures' model. To illustrate this method, it is applied to availability evaluation of a Lucent Technologies Reliable Clustered Computing application. Detailed numerical results are provided and the impact of various types of failures and coverage factors on down time is analysed.", "num_citations": "27\n", "authors": ["41"]}
{"title": "No silver bullet\" reloaded: retrospective on\" essence and accidents of software engineering\n", "abstract": " Twenty years after the paper No Silver Bullet: Essence and Accidents of Software Engineering by Frederick P. Brooks first appeared in IEEE Computer in April 1987 (following its 1986 publication in Information Processing, ISBN 0444-7077-3) does the premise hold that the complexity of software is not accidental? How have the\" hopes for silver\" which included high-level language advances, object-oriented programming, artificial intelligence, expert systems, great designers, etc.-evolved? Panelists will discuss what has changed and/or stayed the same in the past twenty years-and the paper's influence on the community.", "num_citations": "26\n", "authors": ["41"]}
{"title": "The limits of empirical studies of software engineering\n", "abstract": " Some advocates of empirical studies of software engineering appear to be claiming that empirical studies alone can tell us how we should do software development. This paper argues that what can be learned from empirical studies, while important, is very limited. Mathematical studies and empirical studies must be seen as mutually supportive ways to increase our knowledge of software development methods. The role of empirical studies should be limited to confirming that what works in theory can actually be used (and useful) in practice.", "num_citations": "26\n", "authors": ["41"]}
{"title": "Successful software engineering research\n", "abstract": " Rumination about what makes research successful is a strong indication that a researcher will not continue to do successful research. Nonetheless, the invitation to publish a short article in SEN on the occasion of being honoured by receiving SIGSOFT's \"Outstanding Research Award\" has led me to reflect on what I have done. I have been active in research on software design for more than 35 years; perhaps this is the time to pause and look back. I also want to look forward; I have some concerns about the direction being taken by many researchers in the software community and would like to offer them my (possibly unwelcome) advice.", "num_citations": "26\n", "authors": ["41"]}
{"title": "Teaching programming as engineering\n", "abstract": " In spite of unheralded advances in computer hardware and software, most of today's introductory programming courses are much like courses taught 30 years ago. Although the programming languages have changed, we continue to equate teaching programming with teaching the syntax and semantics of programming languages. This paper describes a different approach being taken in the Faculty of Engineering at McMaster University. Our course emphasises program design rather than language syntax, insisting that the program design is something distinct from the detailed code. It allows students a choice of programming languages for use in their laboratory work. Students learn a mathematical model of programming and are taught to use that model to understand program design, analysis, and documentation. Considerable effort is spent on teaching the students how to apply what they see as \u0393\u00c7\u00a3theory\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "26\n", "authors": ["41"]}
{"title": "Using information about functions in selecting test cases\n", "abstract": " We consider the problem of generating a set of test cases from a black box specification. We focus on stress testing, i.e. picking test cases that seem most likely to reveal program bugs. Our approach assumes that so-called interesting points, i.e. points in a function's domain where properties change, e.g. maxima, are likely to reveal any problems and examine how we can determine the interesting points for a function defined by a complex expression if we know the interesting points for the functions named in that expression.", "num_citations": "25\n", "authors": ["41"]}
{"title": "Precise description and specification of software\n", "abstract": " Precise description and specification of software | Proceedings of the second international conference on Mathematics of dependable systems II ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsMDS '95Precise description and specification of software Article Precise description and specification of software Share on Author: DL Parnas View Profile Authors Info & Affiliations Publication: MDS '95: Proceedings of the second international conference on Mathematics of dependable systems IIFebruary 1998 Pages 1\u0393\u00c7\u00f414 1citation 0 Downloads Metrics Total Citations1 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation '\u0393\u00c7\u00aa", "num_citations": "24\n", "authors": ["41"]}
{"title": "Table transformation tools: Why and how\n", "abstract": " The paper describes a prototype tool for inverting tabular representations of mathematical functions, providing the motivation for its construction, some discussion of its use, and a sketch of its implementation. Table transformation tools of the type discussed, are intended to be useful in the documentation of complex computer systems.", "num_citations": "24\n", "authors": ["41"]}
{"title": "SDI: A violation of professional responsibility\n", "abstract": " In May of 1985 I was asked by the Strategic Defense Initiative Organization, the group within the Office of the U.S. Secretary of Defense that is responsible for the \u0393\u00c7\u00a3Star Wars\u0393\u00c7\u00a5 program, to serve on a $1000/day advisory panel, the Sdio Panel on Computing in Support of Battle Management. The panel was to make recommendations about a research and development program to solve the computational problems inherent in space-based defense systems.", "num_citations": "24\n", "authors": ["41"]}
{"title": "Risks of undisciplined development\n", "abstract": " An illustration of the problems caused by a lack of discipline in software development and our failure to apply what is known in the field.", "num_citations": "23\n", "authors": ["41"]}
{"title": "More on simulation languages and design methodology for computer systems\n", "abstract": " In an earlier paper we attempted to set forth (1) a design methodology for computer systems which made heavy use of simulation and (2) a simulation language intended to facilitate the use of the design methodology presented. The basic justification for the design methodology presented an old precept from engineering design: a problem must be defined before it is solved. The result was a methodology which laid great stress on specifying the behavior of a system or a component in a system before producing the design. The simulation language, SODAS, was designed to allow a design to proceed in a hierarchical way, treating any system as a set of components, specifying the behavior of those components, then treating the components themselves as systems. By means of the SODAS language it was to be possible to evaluate the design at any stage in its development without excess effort.", "num_citations": "23\n", "authors": ["41"]}
{"title": "A course on software engineering techniques\n", "abstract": " This is a report on a course entitled,\u0393\u00c7\u00a3Software Engineering Methods\u0393\u00c7\u00a5, which I have taught to undergraduate students at the Carnegie-Mellon University twice during the 1970-71 academic year. The course is \u0393\u00c7\u00a3project oriented\u0393\u00c7\u00a5 and aims to educate by providing experience in the use of the techniques taught.", "num_citations": "20\n", "authors": ["41"]}
{"title": "The design of the virtual memory aspects of a virtual machine\n", "abstract": " This paper discusses the design of a virtual memory mechanism for use as the first level of an operating system. The virtual memory mechanism provides a virtual machine which retains many of the properties of the host computer system. An implementation on the PDP-11/45 is briefly described.", "num_citations": "18\n", "authors": ["41"]}
{"title": "Comment on deadlock preventive method\n", "abstract": " Carnegie-Mellon University find it a bit misleading to apply the appellation\" permanent blocking\" to a condition which under fortuitous circumstances might resolve itself. We prefer the term\" indefinite postponement.\" The algorithm given by Holt in the final section of his paper is unnecessarily cautious and is likely to delay the resolution of the\" indefinite postponement condition.\" There is no need to restrict granting of requests to the first process in the safe sequence found. Safe requests by any process preceding Pi in the sequence should always be granted. Certain requests may be granted to those after Pi in the sequence without postponing the grant for P~.", "num_citations": "18\n", "authors": ["41"]}
{"title": "On simulating networks of parallel processes in which simultaneous events may occur\n", "abstract": " The following resolutions were passed at the ASA X3.4 Common Programming Languages Subcommittee during the thirty-third meeting held February 20, 1964 at CEIR, Beverly Hills, California.", "num_citations": "18\n", "authors": ["41"]}
{"title": "Precise documentation of critical software\n", "abstract": " This experience and research based paper discusses the reasons that software cannot be trusted and then explains how the use of greatly improved documentation can make software more trustworthy. It shows how tabular expressions can be used to prepare software documents that are both precise and easily used by developers, inspectors, and testers. The paper reviews a number of \"tried and true\" ideas and illustrates some new refinements in the methods that resulted from recent research. It is intended both to tell developers of techniques available to them and to suggest new research areas.", "num_citations": "17\n", "authors": ["41"]}
{"title": "Requirements Documentation: Why a Formal Basis is Essential.\n", "abstract": " Unless you have a complete and precise description of your product\u0393\u00c7\u00d6s requirements, it is very unlikely that you will satisfy those requirements. A requirements document that is incomplete or inconsistent can do a great deal of damage by misleading the developers.A collection of statements in English or some other natural language cannot be checked for completeness and will not be precise. Even if you translate a requirements statement into a mathematical language, you can only show that the result of the translation is complete and unambiguous; the original may still be faulty.", "num_citations": "17\n", "authors": ["41"]}
{"title": "Software engineering-missing in action: A personal perspective\n", "abstract": " Although a huge number of articles have been written about software development and many interesting ideas have been proposed, researchers and practitioners have failed to create a new engineering discipline focused on building software-intensive systems.", "num_citations": "16\n", "authors": ["41"]}
{"title": "Software design\n", "abstract": " Software design | Software fundamentals ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware fundamentals: collected papers by David L. ParnasSoftware design chapter Software design Share on Authors: David Lorge Parnas profile image David Lorge Parnas View Profile , P Eng profile image P. Eng View Profile Authors Info & Affiliations Publication: Software fundamentals: collected papers by David L. ParnasMay 2001 Pages 137\u0393\u00c7\u00f4142 1citation 0 Downloads Metrics Total Citations1 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and : \u0393\u00c7\u00aa", "num_citations": "16\n", "authors": ["41"]}
{"title": "On ICSE's \u0393\u00c7\u00a3most influential\u0393\u00c7\u00a5 papers\n", "abstract": " The International Conference on Software Engineering has established a tradition of looking back 10 conferences and selecting papers that have stood the test of time. The remarks below were prepared in connection an acceptance speech at ICSE 17 where two colleagues and I received the award for the best paper of ICSE 7.", "num_citations": "16\n", "authors": ["41"]}
{"title": "A comparison of tabular expression-based testing strategies\n", "abstract": " Tabular expressions have been proposed as a notation to document mathematically precise but readable software specifications. One of the many roles of such documentation is to guide testers. This paper 1) explores the application of four testing strategies (the partition strategy, decision table-based testing, the basic meaningful impact strategy, and fault-based testing) to tabular expression-based specifications, and 2) compares the strategies on a mathematical basis through formal and precise definitions of the subsumption relationship. We also compare these strategies through experimental studies. These results will help researchers improve current methods and will enable testers to select appropriate testing strategies for tabular expression-based specifications.", "num_citations": "15\n", "authors": ["41"]}
{"title": "Software engineering: Multi-person development of multi-version programs\n", "abstract": " A brief description of the early days of \u0393\u00c7\u00a3Software Engineering\u0393\u00c7\u00a5 precedes a discussion of the various meanings that have been proposed for that term. The differences between Software Engineering and Programming are described by discussing the tasks beyond programming that are expected to be performed by Software Engineers. Legislators and Educators are challenged to take steps to make Software Development a profession by establishing entrance standards for professionals and quality standards for products.", "num_citations": "13\n", "authors": ["41"]}
{"title": "Licensing software engineers in Canada\n", "abstract": " \u0393\u00c7\u00f3 The engineering regulators were so accustomed to thinking about physical products they did not recognize that software was replacing other technologies in critical products. Only recently have authorities recognized their legal mandate, and their duty to enhance public safety, required they regulate the use of engineering titles by software developers.\u0393\u00c7\u00f3 Computer science was identified as a research area by people who were trained in science and mathematics, not engineering. They seem to have been unaware of the structure of the engineering profession and were unaware of the need to identify a \u0393\u00c7\u00a3core body of knowledge\u0393\u00c7\u00a5 and to establish educational and ethical standards for developers. Computer scientists have treated \u0393\u00c7\u00a3software engineering\u0393\u00c7\u00a5 as an area of research, not as a profession. Most scientific fields are not regulated because scientists rarely provide services directly to the public the way engineers do.\u0393\u00c7\u00f3\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["41"]}
{"title": "On a \u0393\u00c7\u00ffbuzzword\u0393\u00c7\u00d6: Hierarchical structure\n", "abstract": " This paper discusses the use of the term \u0393\u00c7\u00a3hierarchically structured\u0393\u00c7\u00a5 to describe the design of operating systems. Although the various uses of this term are often considered to the be closely related, close examination of the use of the term shows that it has a number of quite different meanings. For example, one can find two different senses of \u0393\u00c7\u00a3hierarchy\u0393\u00c7\u00a5 in a single operating system [3] and [6]. An understanding of the different meanings of the term is essential, if a designer wishes to apply recent work in Software Engineering and Design Methodology. This paper attempts to provide such an understanding.", "num_citations": "13\n", "authors": ["41"]}
{"title": "Requirements-based monitors for real-time systems\n", "abstract": " Before designing safety-or mission-critical real-time systems, a specification of the required behaviour of the system should be produced and reviewed by domain experts. After the system has been implemented, it should be thoroughly tested to ensure that it behaves correctly. This is best done using a monitor, a system that observes the behaviour of a target system and reports if that behaviour is consistent with the requirements. Such a monitor can be used both as an oracle during testing and as a supervisor during operation. Monitors should be based on the documented requirements of the system.", "num_citations": "13\n", "authors": ["41"]}
{"title": "Inspection procedures for critical programs that model physical phenomena\n", "abstract": " This paper addresses the problem of assuring the accuracy and trustworthiness of computer programs that are based on models of physical phenomena. It begins by explaining why such programs can be critical to safety, health, and property. After a quick review of what is known about software inspection, it presents a classification of the possible sources of error in these programs. Subsequently, the paper outlines an inspection procedure that would find these errors. The final section of the paper illustrates the concepts using a simple example, a program that might be used to predict contaminant diffusion.", "num_citations": "13\n", "authors": ["41"]}
{"title": "Fighting complexity\n", "abstract": " A system can be considered complex if its shortest useful description is relatively long. The length of the shortest descriptions indicates the amount of information required to understand the product. Software systems are almost always perceived as complex and software engineering researchers are all studying ways to deal with complexity. The fact that we must work with these systems in spite of the fact that they are difficult to understand has many practical consequences.\u0393\u00c7\u00a3Cut and try\u0393\u00c7\u00a5, a development philosophy considered unprofessional in other areas of engineering, has become the norm in software development.There are three approaches to dealing with complexity. One approach is to provide tools that help people to find the information that they need; another is to reduce the amount of information that a programmer or user will need, the third is revise the product in a way that reduces its complexity. The first\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "13\n", "authors": ["41"]}
{"title": "Trace rewriting systems\n", "abstract": " We first describe a finite state machine based module interface specification method \u0393\u00c7\u00f6 trace assertion method. Then, viewing trace assertions in a trace specification as defining an equivalence relation among traces, we define a trace rewriting system from the specification. Such a trace rewriting system resembles some aspects of string rewriting, membership conditional rewriting and priority rewriting. We prove that a proper trace rewriting system is both terminating and confluent and compare trace rewriting systems with term rewriting systems.", "num_citations": "13\n", "authors": ["41"]}
{"title": "Software product lines: what to do when enumeration won't work\n", "abstract": " The history of research on the development of program-families is briefly reviewed. Two distinct problems, configuration-management and family-design are identified. It is explained that, while software configuration-management is not fundamentally different from configurationmanagement for other products, in practice, inadequate attention to family-design exacerbates all problems associated with developing and maintaining program families. It is suggested that although enumeration is useable for configuration-management, product-line design by enumeration is not generally feasible. An alternative approach, family member characterization using abstract documentation, is discussed. This approach is practical for family-design and can make configuration-management easier. The advantages of designing an interface in terms of programs over an interface expressed as a data structure using conventions such as XML are also discussed.", "num_citations": "12\n", "authors": ["41"]}
{"title": "Segregated failures model for availability evaluation of fault-tolerant systems\n", "abstract": " This paper presents a method of estimating the availability of fault-tolerant computer systems with several recovery procedures. A segregated failures model has been proposed recently for this purpose. This paper provides further analysis and extension of this model. The segregated failures model is compared with a Markov chain model and is extended for the situation when the coverage factor is unknown and failure escalation rates must be used instead. This situation is illustrated in detail by estimating availability of a Lucent Technologies Reliable Clustered Computing architecture. For this example, numeric values are provided for availability indexes and the contribution of each recovery procedure to total system availability is analysed.", "num_citations": "12\n", "authors": ["41"]}
{"title": "Significant event simulation\n", "abstract": " This paper compares a new method of simulation organization, called the significant event method, with an old one, called the clock pulse method, using as examples two automobile traffic models. The significant event method is found to be more efficient than the clock pulse method at low levels of system interaction and less efficient at high levels. A simple mathematical model for the trade-off in the relative running time of the two methods is developed. The model aids in choosing between the two simulation methods for a particular experiment. It is concluded that the significant event method can be of value in the simulation of some systems when computational efficiency is of sufficient importance.", "num_citations": "12\n", "authors": ["41"]}
{"title": "Documenting and verifying systems assembled from components\n", "abstract": " This paper presents an approach to the problem of documenting the design of a network of components and verifying that its structure is complete and consistent, (i.e., that the components, functioning together, will satisfy the requirements of the complete product), before the components are implemented. Our approach differs from others in that both hardware and software components are viewed as hardware-like devices in which an output value can change instantaneously when input values change and all components operate synchronously rather than in sequence.We define what we mean by completeness and consistency and illustrate how the documents can be used to verify a design before it is implemented.", "num_citations": "11\n", "authors": ["41"]}
{"title": "Software aspects of strategic defense systems\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - Software aspects of Strategic Defense Systems CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4\u00b5\u00e2\u00e0\u03c3\u00e1\u2592 \u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5\u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee \u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii Research\u03c0\u00e2\u00f9\u03c0\u00e2\u00bc \u03c4\u00eb\u00ea\u03c0\u00fc\u00ab\u03c3\u00e0\u00bc\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa Software aspects of Strategic Defense Systems PARNAS DL \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 PARNAS DL \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 Software Fundamentals : Collected Papers by David L. Parnas Software Fundamentals : Collected Papers by David L. Parnas, 497-518, 2001 Addison Wesley \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u03a3\u2551\u00ee\u03c0\u00fc\u00f1\u03c0\u00fc\u00ab\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5 : \u0398\u00ff\u2593\u03c4\u00e8\u00bb\u03c0\u00fc\u00ab\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5\u03c0\u00fc\u00bf\u00b5\u00e8\u2561\u00b5\u00e8\u00f9\u03c0\u00fc\u00ab\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5 \u03c3\u2592\u2592\u00b5\u00e1\u2563 \u03a3\u2510\u00ed\u03a3\u2551\u00ee , \u00b5\u00a5\u00e6\u03c3\u2592\u2592 \u03c3\u00e4\u00ac\u03c3\u00a1\u00c9 \u0398\u00a2\u2557\u03c3\u00a1\u00c9\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u0398\u00c7\u00dc\u03a3\u2510\u00ed\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u00b5\u00e8\u00c7\u03a6\u00ed\u00f4\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u03c3\u00e1\u2592\u03c3\u00e6\u00e8. SITE, \u00b5\u00e8\u00c7\u03a6\u00ed\u00f4\u03c0\u00fc\u00bf\u03c4\u00f1\u255b\u03a3\u255d\u00dc\u03c0\u00e2\u2557\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5 : IEICE technical report 102(235), 11-13, 2002-07-18 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab23\u03a3\u2557\u2562 Tweet \u03c3\u00c9\u00e4\u03c4\u00bf\u00ab\u03c0\u00e9\u2502\u03c0\u00e2\u255d\u03c0\u00e2\u00eb NII\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7ID(NAID) \u03a6\u2502\u00e7\u00b5\u00fb\u00d6\u03c4\u00bf\u00ab\u03c3\u00ea\u00d1 \u03c0\u00fc\u00ab/\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["41"]}
{"title": "An easily extensible toolset for tabular mathematical expressions\n", "abstract": " We describe the design of an open ended set of tools for manipulating multi-dimensional tabular expressions. The heart of the toolset is a set of modules that makes it possible to add new tools to the toolset without having detailed knowledge of the other tools. This set of modules, the Tool Integration Framework, supports new and existing tools by providing abstract communication interfaces. The framework that we describe has proven to be a practical approach to building an extensible set of tools.", "num_citations": "11\n", "authors": ["41"]}
{"title": "Applying Mathematical Software Documentation: an Experience Report\n", "abstract": " Those who do not use \"formal methods\" for developing software (and they remain the overwhelming majority of software developers) often claim that mathematical software development can only be used by highly educated people, and on especially well-written programs. We counter this claim by reporting on some recent experience. An undergraduate engineering student who had no previous exposure to mathematical software documentation techniques was asked to use a new method to document a program that had been written for photonics and microwave development, but did not always work as required; the author had departed and the program's owners were not able to find the problem. The student was not asked to change the program, just to provide precise documentation. However, the process of documentation revealed several errors and, after they were corrected, the program was left in working\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "11\n", "authors": ["41"]}
{"title": "Less restrictive constructs for structured programs\n", "abstract": " The syntax and formal semantics of new control constructs that resemble Dijkstra\u0393\u00c7\u00d6s guarded commands [1] is given. Like programs built using the standard \u0393\u00c7\u00a3structured programming\u0393\u00c7\u00a5 constructs, programs built using these constructs are easily parsed into a hierarchy of components and the meaning of the constructed program is a simple function of the semantics of its components. Program structures that were previously considered heretical by advocates of structured programs, such as multiple-entrance programs and side-effects in Boolean expressions, are shown not to complicate either the syntax and semantics. The use of the new constructs is illustrated on some small examples.", "num_citations": "11\n", "authors": ["41"]}
{"title": "On the Combinatorial Complexity of Context-free Grammars.\n", "abstract": " One of the difficulties in the analysis of context-free grammars (and therefore languages) is the strong combinato-rial nature of the mechanism, A measure of this complexity is suggested here. It involves labeling the productions and considering the sequences of labels that correspond to valid derivations. This gives rise to a language and the type of this language is used to categorize the grammar. Results relate these categories to others in troduced in the literature and to the generation capacity of the class.", "num_citations": "11\n", "authors": ["41"]}
{"title": "On documenting the requirements for computer programs based on models of physical phenomena\n", "abstract": " Programs for use by Scientists and Engineers are usually embodiments of mathematical models of physical phenomena. Complete and accurate models are usually quite complex because they must deal with the wide-variety of situations that can arise in the real-world. Informal descriptions of these models are often incomplete, imprecise, and, inaccurate and are not suitable for specifying what is required of a software package. This paper presents an approach to writing requirements documents for such programs. It demonstrates how tabular notation can make precise mathematical expressions more readable. It also shows how we can document systems in which the user is given some control of the computational method to be used.", "num_citations": "10\n", "authors": ["41"]}
{"title": "Software aging\n", "abstract": " Software aging | Software fundamentals ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware fundamentals: collected papers by David L. ParnasSoftware aging chapter Software aging Share on Author: David Lorge Parnas profile image David Lorge Parnas View Profile Authors Info & Affiliations Publication: Software fundamentals: collected papers by David L. ParnasMay 2001 Pages 551\u0393\u00c7\u00f4567 1citation 0 Downloads Metrics Total Citations1 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully added and will be sent to: You will be notified whenever a \u0393\u00c7\u00aa", "num_citations": "9\n", "authors": ["41"]}
{"title": "Requirements capture, documentation, and validation\n", "abstract": " The goal of the workshop, namely to bring together software engineering researchers from academia and software engineers from industry to compare the state of industrial practice and academic research for capturing, documenting and validating software requirements, has been reached.", "num_citations": "9\n", "authors": ["41"]}
{"title": "A logic for describing, not verifying, software\n", "abstract": " An important perquisite for verification of the correctness of software is the ability to write mathematically precise documents that can be read by practitioners and advanced users. Without such documents, we won't know what properties we should verify. Tabular expressions, in which predicate expressions may appear, have been found useful for this purpose. We frequently use partial functions in our tabular documentation. Conventional interpretations of expressions that describe predicates are not appropriate for our application because they do not deal with partial functions. Experience with this documentation has led us to choose a logic in which predicates are total but functions remain partial. We have found that this particular interpretation results in simpler expressions and is easily understood by practitioners.", "num_citations": "9\n", "authors": ["41"]}
{"title": "The Professional Responsibilities of Software Engineers.\n", "abstract": " Registered Engineers are expected to be aware of their responsibilities as professionals. Those who practice Software Engineering often enter that profession without either an engineering education or professional registration. This paper discusses professional responsibilities and ways to improve the level of professionalism among software developers.", "num_citations": "9\n", "authors": ["41"]}
{"title": "Goals for software engineering student education\n", "abstract": " Viewpoint\u0393\u00c7\u00a5 in the last SEEd column. Perhaps there are a few letters to the editor. By the way, I would like to complement Will Tracz SEN editor. He does an excellent job pulling each issue of SEN together, and we are indebted to the time and effort he contributes to making SEN very readable and informative.The theme of this column follows that of the last \u0393\u00c7\u00a3Educating Software Engineers.\u0393\u00c7\u00a5 As software engineers we have individual and collective views regarding how software engineers should be educated and could make a fairly comprehensive list of bullet points of the goals of software engineering education.", "num_citations": "8\n", "authors": ["41"]}
{"title": "A rational design process: How and why to fake it\n", "abstract": " A rational design process | Software fundamentals ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware fundamentals: collected papers by David L. ParnasA rational design process: how and why to fake it chapter A rational design process: how and why to fake it Share on Authors: David Lorge Parnas profile image David Lorge Parnas View Profile , Paul Charles Clements profile image Paul C. Clements View Profile Authors Info & Affiliations Publication: Software fundamentals: collected papers by David L. ParnasMay 2001 Pages 355\u0393\u00c7\u00f4368 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 6 ! \u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["41"]}
{"title": "Interface Specifications for the SCR (A-7E) Application Data Types Module.\n", "abstract": " This report describes the programmer interface to a set of avionics-oriented abstract data types implemented in software. The Application Data Types module is part of NRLs Software Cost Reduction SCR project, to demonstrate the feasibility of applying advanced software engineering techniques to complex real-time systems to simplify maintenance. The Application Data Types module allows operations on data independent of the representation. In the case of numeric abstract types, which represent physical quantities such as speed or distance, arithmetic operations may be performed independent of the units of physical measure. This allows the rest of the application software to remain unchanged even when representation decisions change about these data. These report contains the abstract interface specifications for all the facilities provided to users by this module. Itr serves as development and maintenance documentation for the SCR software design, and it is also intended as a model for other people interested in applying the abstract interface approach on other software projects.Descriptors:", "num_citations": "8\n", "authors": ["41"]}
{"title": "On the need for fewer restrictions in changing compile-time environments\n", "abstract": " Compilers for current programming languages enforce rigid restrictions on changes, during the compilation of a statement, in the set of associations between names and declarations, that is, on changes in the compile-time environment of the statement. These restrictions inhibit the writing of well-structured, modular programs, because such programs tend to require frequent switching between the environments associated with different modules. With current compilers, arbitrary switching of environments must be handled by means of macros at compile time or deferred until run time. Conventional macros are difficult to use in situations where it is desirable that the macro writer and the macro user be ignorant about each other's programs. When deferred until run time, frequent switching of environments becomes costly owing to the overhead associated with subroutine calls. In order to encourage the\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "8\n", "authors": ["41"]}
{"title": "Structured programming: A minor part of software engineering\n", "abstract": " Software Engineering is discussed as a branch of Engineering specialising in software intensive products. The process of developing good software is discussed and it is argued that writing programs, though obviously an essential step in the process, is only a small part of Software Engineering.", "num_citations": "7\n", "authors": ["41"]}
{"title": "The tabular method for relational documentation\n", "abstract": " The basic mathematical laws of relations can be presented and verified using compact abstract notation. However, descriptions of specific relations, such as those that arise in describing software, must be done in terms of a a state representation. When conventional notation is used, the expressions can be complex and hard to use. This tutorial presented and explained tabular notation that has been found useful in practical software development. It also described a set of prototype tools that make it easier to apply relational methods in software development.", "num_citations": "7\n", "authors": ["41"]}
{"title": "The history of software engineering\n", "abstract": " In August 1996 about a dozen historians met with about a dozen computer scientists to discuss the history of software engineering. The term software engineering has been deliberately chosen as being provocative at the 1968 NATO Conference on Software Engineering. This notion was meant to imply that software manufacture should be based on the types of theoretical foundations and practical disciplines that are established in the traditional branches of engineering. This need was motivated by the so-called software crisis. Ever since, the debate whether such a crisis exists has continued within the software engineering community. It is a crucial question, because if the answer is yes, software engineering may not be called an engineering discipline yet. If the answer were no, the question would be, what is it that constitutes this discipline.It turned out at the seminar that there may or may not be a software crisis, but there is definitely what might be called an identity crisis. A strong indicator for this phenomenon is the fact that after more than 30 years computer scientists are investigating the history of other established branches of engineering to find out (or to define?) what should be done to turn software engineering into a sound engineering discipline. In this endeavor, historians were regarded to be some kind of universal problem solvers who were called in whenever a general answer to some fundamental question was needed.", "num_citations": "7\n", "authors": ["41"]}
{"title": "Rapid prototyping by means of abstract module specifications written as trace axioms\n", "abstract": " In this paper we discuss the use of a form of abstract specifications for software modules called trace axioms or trace assertions. Specifications written in this form precisely describe the external behavior of the module and can be automatically tested for consistancy and completeness. Errors revealed by the testing process can be rapidly corrected by a man-machine interactive process. These specifications could then be interpreted or compiled to form a rapid prototype of the final system.", "num_citations": "7\n", "authors": ["41"]}
{"title": "Sequential equivalents of parallel processes\n", "abstract": " This paper introduces the problem of finding a sequential process equivalent to a system of interacting discrete parallel processes. Under the assumption that the sequential process is to be composed exclusively of executions of the individual\" parallel\" processes in a predetermined sequence, a method of deriving optimal sequential processes is presented. Applications to the design of simulation systems and picture processing programs are discussed. Examples are taken from logic design and picture processing.", "num_citations": "7\n", "authors": ["41"]}
{"title": "The use of mathematics in software quality assurance\n", "abstract": " The use of mathematics for documenting, inspecting, and testing software is explained and illustrated. Three measures of software quality are described and discussed. Then three distinct complementary approaches to software quality assurance are presented. A case study, the testing and inspection of a safety-critical system, is discussed in detail.", "num_citations": "6\n", "authors": ["41"]}
{"title": "The risks of stopping too soon\n", "abstract": " Good software design is never easy, but stopping too soon makes the job more difficult.", "num_citations": "6\n", "authors": ["41"]}
{"title": "Fault propagation in tabular expression-based specifications\n", "abstract": " Tabular expressions have been used in industry for many years to precisely document software in a readable notation. In this paper, we propose a fault-based testing technique that traces the propagation of faults from the expression in each cell of a tabular expression to the output of the program under test. The technique has been formalized in the form of abstract test case constraints also represented by tabular expressions, so that it can be easily applied and automated.", "num_citations": "6\n", "authors": ["41"]}
{"title": "Computer systems availability evaluation using a segregated failures model\n", "abstract": " This paper presents the segregated failures model (SFM) of availability of fault\u0393\u00c7\u00c9tolerant computer systems with several recovery procedures. This model is compared with a Markov chain model and its advantages are explained. The basic model is then extended for the situation when the coverage factor is unknown and the failure escalation rates must be used instead. A simple practical analytical approach to availability evaluation is provided and illustrated in detail by estimating the availability of two versions of a reliable clustered computing architecture. For these examples, numeric values of availability indexes are computed and the contribution of each recovery procedure to total system availability is analysed. Copyright \u252c\u2310 2008 John Wiley & Sons, Ltd.", "num_citations": "6\n", "authors": ["41"]}
{"title": "Tabular expressions and total functional programming\n", "abstract": " Tabular expressions are a multidimensional structured notation for complex mathematical definitions of relations or functions. They have been found useful for documenting imperative programs by stating the function or relation that describes the black-box behaviour of those programs. Tools are needed to increase the practicality of this approach to documentation. In order to create tools to check and evaluate tabular expressions, we have investigated functional programming as an implementation paradigm that reflects the semantics of these mathematical expressions faithfully. We explain why and how the restriction to total functions improves the semantic correspondence substantially, and describe the basic design and capabilities of our total functional programming tools for tabular expressions. We demonstrate the practical advantages of totality by giving examples for the especially easy and effective\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["41"]}
{"title": "Basic science for software developers\n", "abstract": " Every Engineer must understand the properties of the materials that they use. Whether it be concrete, steel, or electronic components, the materials available are limited in their capabilities and an Engineer cannot be sure that a product is \u0393\u00c7\u00a3fit for use\u0393\u00c7\u00a5 unless those limitations are known and have been taken into consideration. The properties of physical products can be divided into two classes:(1) technological properties, such as rigidity, which apply to specific products and will change with new developments,(2) fundamental properties, such as Maxwell\u0393\u00c7\u00d6s laws or Newton\u0393\u00c7\u00d6s laws, which will not change with improved technology.In many cases technological properties are expressed in terms of numerical parameters and the parameter values appear in product descriptions. This makes these limitations concrete and meaningful to pragmatic developers. It is the responsibility of engineering educators to make sure that students understand the technological properties, know how to express them, know how to determine them for any specific product, and know how to take them into account when designing or evaluating a product. However, it is also the responsibility of educators to make sure that students understand the fundamental limitations of the materials that they use. It is for this reason, that accredited engineering programs are required to include a specified amount of basic science (see [9]). Explaining the relevance of basic science to Engineers is a difficult job; technological limitations are used to compare products; in contrast, fundamental limitations are never mentioned in comparisons because they apply to all competing products. As a result\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "6\n", "authors": ["41"]}
{"title": "Evaluation of automated testing coverage: a case study of wireless secure connection software testing\n", "abstract": " We describe our experience applying tabular mathematical approaches to software specifications. Our purpose is to show alternative approaches to writing tabular specifications and to help practitioners who want to apply...", "num_citations": "6\n", "authors": ["41"]}
{"title": "Module Interface Documentation-Using the Trace Function Method (TFM)\n", "abstract": " A new approach to the professional documentation (description or specification) of interfaces for information hiding components, the Trace Function Method (TFM), is described. The motivation and design assumptions behind the method are explained. The concepts of event, event descriptor, and trace are introduced. Basic functions on event descriptors and traces are defined. The method is illustrated on a variety simple examples. trace function 1/34 21 01 2006 19: 03", "num_citations": "6\n", "authors": ["41"]}
{"title": "Why software developers should be licensed\n", "abstract": " Over the last few decades, software has been replacing mechanical, electrical and electronic components in traditional engineering products. It has also become a critical component in medical devices, chemical plants, buildings and aircraft. Software is regularly used to design critical products, the effectiveness and safety of which can depend on the correctness of that software.", "num_citations": "6\n", "authors": ["41"]}
{"title": "Estimating Software Reliability Using Inverse Sampling\n", "abstract": " This paper addresses one of the perpetual questions faced by software developers, How much testing is enough testing?\". Software testing accounts for a substantial portion of software development costs, but releasing software with unacceptable reliability is also very costly. We begin with a discussion of how classical notions of reliability can be applied to deterministic software and explain that the reliability of a software is as much a function of the way that it is used as of quality of the software. We then illustrate how simple operational profiles can be used to characterize usage patterns. Finally, we show how the reliability requirements can be used to determine how much testing is necessary and whether or not the software is acceptable. Using the method of inverse sampling, also called negative binomial sampling, we develop an efficient statistical procedure for quantifying the reliability of a piece of software. The procedure allows substantial reductions in the average number of executions run over the traditional binomial testing. Other issues such as the calculation of upper confidence bounds for software failure rate under both binomial and negative binomial sampling are also addressed. The results obtained are illustrated numerically and graphically on several cases arising in practice. Some issues for further work, namely the use of sequential testing, the computer implementation of the methods developed and the testing of continuously-run software, are also discussed.", "num_citations": "6\n", "authors": ["41"]}
{"title": "Warum ich an SDI nicht mitarbeite: Eine Auffassung beruflicher Verantwortung\n", "abstract": " Im Mai 1985 lud mich das Amerikanische Verteidigungsministerium zur Mitarbeit ein in einem Beratungsausschu\u251c\u0192 f\u251c\u255dr das Programm \u0393\u00c7\u20a7Krieg der Sterne\u0393\u00c7\u00a3 (Strategische Verteidigungs-initiative, kurz SDI). Mir wurde gesagt, da\u251c\u0192 SDI ein Weg aus dem R\u251c\u255dstungswettlauf sei. SDI sollte Nuklearwaffen unwirksam machen, weil sie im Flug vernichtet werden k\u251c\u2562nnten. Durch SDI sollte unsere Angst vor Nuklearwaffen ein Ende haben. Doch schon zwei Monate sp\u251c\u00f1ter trat ich von dem Beratungsausschu\u251c\u0192 zur\u251c\u255dck. Der vorliegende Beitrag dient der Begr\u251c\u255dndung meiner Opposition gegen dieses Programm.", "num_citations": "6\n", "authors": ["41"]}
{"title": "Point/counterpoint\n", "abstract": " The need for empirical research into the practicality and efficacy of software development methods is obvious but most published papers have inadequate experimental design. The assumption that what programmers do is \"natural,\" and somehow right or practical, needs to be questioned seriously. Human beings haven't evolved by natural selection to be good programmers. There are people alive today who worked on the first electronic computers. Further, almost all of today's programmers learned from earlier programmers; either they were explicitly taught or they observed how the programmers that preceded them had done their work. If those pioneers were wrong, the methods that we now perceive as natural or intuitive will also be wrong. We can't simply conclude that what we observe in projects today is the best way to do something.", "num_citations": "5\n", "authors": ["41"]}
{"title": "Which is riskier: OS diversity or OS monopoly?\n", "abstract": " Which is riskier Page 1 112 August 2007/Vol. 50, No. 8 COMMUNICATIONS OF THE ACM It is computer science \u0393\u00c7\u00a3folk wisdom\u0393\u00c7\u00a5 that our com- puter systems, particularly the networks, are unnecessarily vulnerable because so many of our systems are either made by Microsoft, highly dependent on Microsoft software, or required to interact with Microsoft software. Many see this as a single point of failure, an Achilles\u0393\u00c7\u00d6 heel. Analogies are drawn to situations such as many people concentrated in a dangerous area, large quantities of hazardous materials stored in one place, or systems reliant on a single power source. Many propose that we can decrease our vulnerability by insisting on the use of non-Windows operating systems\u0393\u00c7\u00f6thereby increasing diversity. In this column, I question that view. Diversity, when combined with redundancy, is a well-established approach to increasing the reliability of safety-critical systems. For \u0393\u00c7\u00d6\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "A family of mathematical methods for professional software documentation\n", "abstract": " The movement to integrate mathematically based software development methods is a predictable response to the fact that none of the many methods available seems sufficient to do the whole job (whatever that may be) on its own. This talk argues that integrating separately developed methods is not the most fruitful possible approach. Instead we propose a family of methods, based on a common model, designed to be complementary and mutually supportive.               The method family being developed at the Software Quality Research Lab at the University of Limerick is characterised by two major decisions:               \u0393\u00c7\u00f4 Software developers must prepare and maintain a set of documents whose content (not format) is specified by the relational model presented in [3].               \u0393\u00c7\u00f4 The relations are represented using mathematical expressions in tabular form. [5].               This talk will motivate these decisions\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "Document driven disciplined development of software\n", "abstract": " It is no accident that the branches of engineering are called \"disciplines\". Every properly educated engineer has learned that the design of quality products requires discipline and a willingness to follow standard procedures. Engineers understand that they must produce a specified set of documents and perform a variety of analyses whose results must be included in the documents. Engineers who do these things are less likely to produce a defective product. In many jurisdictions, engineers who fail to follow the standard discipline may be considered to have been negligent. Software development should not be different but most developers have not been taught the appropriate discipline and neither their employers nor the customers know what to demand. At the heart of the problem is our failure to agree on a set of documents that contain analyzable descriptions and specifications. We begin with highly simplified\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "Software inspections we can trust\n", "abstract": " Software is devilishly hard to inspect. Serious errors can escape attention for years. Consequently, many are hesitant to employ software in safety-critical applications and developers and users are finding the correction of software errors to be an increasingly burdensome cost. This talk describes a procedure for inspecting software that consistently finds subtle errors in software that is believed to be correct. The procedure is based on four key principles:  * All reviewers actively use the code. * Reviewers exploit the hierarchical structure of the code rather than proceeding sequentially through the code. * Reviewers focus on small sections of code, producing precise summaries that are used when inspecting other sections. The summaries provide the links between the sections. * Reviewers proceed systematically so that no case, and no section of the program, gets overlooked.  The inspectors produce and review mathematical documents. The mathematics allows them to check for complete coverage; tabular notation allows the work to proceed systematically in small steps.", "num_citations": "5\n", "authors": ["41"]}
{"title": "Parnas on Parnas: A life of indecision\n", "abstract": " As a student at the Bronx High School of Science in New York, I was clearly on the engineering side. I found both challenge and satisfaction in making calculations that could be tested against reality by building a device. I wasn't satisfied with having something rigkt'fin theory;\" I wanted to see it work. I loved designing, building, and testing electronic equipment, obtained a government license as a\" Radio Engineer,\" and later worked in rac, io,~ ations.In 1957 1 entered a1~ engineering school, Carnegie Institute of Technology, but chose to study science (physics); I thought that studying science would be the way to learn the truth about the universe. Two years later I realized that the truth being sought by rr: y teachers was an extra decimal place of precision in the estimated weight of electrons. I was left cold by discussions of un~ estable, or difficult to test, theories. I was lured to Engineering by a teacher, Everard M\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "Precisely annotated hierarchical pictures of programs\n", "abstract": " In 1974, EW Dijkstra, criticising the use of pictures of programs, said,\u0393\u00c7\u00a3Whenever someone draws a picture to explain a program, it is a sign that something is not understood\u0393\u00c7\u00a5[2]. On hearing of this statement W. Bartussek responded with,\u0393\u00c7\u00a3Yes, a picture is what you draw when you are trying to understand something or trying to help someone understand it\u0393\u00c7\u00a5[1]. These two, superficially equivalent, statements demonstrate the broad range of opinions among programming experts about pictures of programs. The following opinions are, in our opinion, all accurate and relevant.\u0393\u00c7\u00f3 Pictures clearly do help people to get an understanding of the basic structure of the program in their initial study of a program, or in finding their way through a large program to the sections that are of interest to them.\u0393\u00c7\u00f3 Many diagrammatic representations of programs are buzz-diagrams, pictures that do not have a precise meaning. When dealing with programs, lack of precision can be dangerous and expensive.", "num_citations": "5\n", "authors": ["41"]}
{"title": "Professional responsibility to blow the whistle on SDI\n", "abstract": " Professional responsibility to blow the whistle on SDI | Computers, ethics, & society ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksComputers, ethics, & societyProfessional responsibility to blow the whistle on SDI chapter Professional responsibility to blow the whistle on SDI Share on Author: David Lorge Parnas profile image David Lorge Parnas View Profile Authors Info & Affiliations Publication: Computers, ethics, & societyJanuary 1990 Pages 359\u0393\u00c7\u00f4372 2citation 0 Downloads Metrics Total Citations2 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has been successfully .\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "Documentation of communications services and protocols\n", "abstract": " Documentation of Communications Services and Protocols | Proceedings of the IFIP TC/WG6.1 Second International Conference on Formal Description Techniques for Distributed Systems and Communication Protocols ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsFORTE '89Documentation of Communications Services and Protocols Article Documentation of Communications Services and Protocols Share on Author: David Lorge Parnas profile image David Lorge Parnas View Profile Authors Info & Affiliations Publication: FORTE '89: Proceedings of the IFIP TC/WG6.Second International Conference on Formal for and \u0393\u00c7\u00f40'\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "On the uses of synchronization in hard-real-time systems\n", "abstract": " This paper presents an improved approach to the design of software for hard-real-time systems. The software for such systems is usually difficult to change because of constraints imposed by the need to meet absolute deadlines on processors with limited memory capacity. Dijkstra and others have shown that the concept of cooperating sequential processes can be used to improve the structure of software when concurrency is present. However, their techniques do not (1) deal with real-time deadlines, (2) are not efficient in their use of processor time and memory, and (3) do not allow simple efficient synchronization in the complex situations that arise in typical embedded systems. This paper presents a number of refinements to the basic concept that allow its use in hard-real-time embedded software. The three key ideas are, (1) a multi-level approach that allows convenient synchronization without a penalty in real\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "Another view of the Dijkstra-dMLP controversy\n", "abstract": " Another view of the Dijkstra-dMLP controversy Page 1 ACM SIGSOFT, SOFTWARE ENGINEERING NOTES, Vol . 3, No . 4, October 1978 Page 20 ************************************************ * * Another View of the Dijkstra-dMLP Controversy * * David L . Parnas * ************************************************ * The correspondence between Professor Dijkstra on one side and Professors deMillo, Lipton, and Perlis (dMLP) on the other side is distressing because both sides hold to such extreme positions that convergence on the truth, whic h both are seeking, is not possible . dMLP claim that program proving Trust fail oomplete l,y in its primary purpose, that of increasing our level of confidence in the correct functioning of a program . Their most cogent argument is that the social processes that lea d to correctness in mathematics will be absent in program proving. Dijkstra (and others) have insisted that program s are and . \u0393\u00c7\u00aa", "num_citations": "5\n", "authors": ["41"]}
{"title": "Information streams sharing a finite buffer: other solutions\n", "abstract": " The problem as stated by Dijkstra [I] involves N information streams, each with a producer and a consumer. The buffer portions in these information streams are of fixed length and are allocated from a buffer pool con taining \u0393\u00c7\u00a3tot\u0393\u00c7\u00a5 portions. The number allocated to stream1 at any time is recorded in the shared variable n1. So that streams not impair each other\u0393\u00c7\u00d6s progress even under extreme conditions, a fixed number r~> 0 of portions is re served for the operation of the ith stream. At anytime, the number of buffer portions which remain (available for allocation to any stream) is recorded in the shared variable f:", "num_citations": "5\n", "authors": ["41"]}
{"title": "On a solution to the cigarette smokers' problem\n", "abstract": " This report discusses a problem first introduced by Patil [l]. Patil has presented a proof that the problem cannot be solved using the P and V operations introduced by Dijkstra [3] unless conditional statements are used. This report contains a solution to the problem as defined by Patil and shows that Patil1 s proof overlooks important capabilities for P and V which were used by Dijkstra in his original report. This report also discusses the need for the generalized operators suggested by Patil.", "num_citations": "5\n", "authors": ["41"]}
{"title": "From Requirements to Architecture.\n", "abstract": " This paper discusses the importance of requirements documents and the reasons that the requirements documentation methods commonly applied in industrial software development are inadequate. The use of functional methods and tabular expressions for producing precise requirements documentation is explained and illustrated. This includes:", "num_citations": "4\n", "authors": ["41"]}
{"title": "Tabular expression-based testing strategies: A comparison\n", "abstract": " Tabular expressions were proposed as a documentation tool that can be used to document software precisely and unambiguously. This paper explores the applications of four testing strategies in tabular expression-based specifications and further compares the strategies on a mathematical basis.", "num_citations": "4\n", "authors": ["41"]}
{"title": "Component Interface Documentation: What do we Need and Why do we Need it?\n", "abstract": " For many decades, project managers and \u0393\u00c7\u00a3software architects\u0393\u00c7\u00a5 have complained that they have no precise way to tell a programmer what a product or component must do. unless they have an existing program with the desired function. Even using an existing program to say what you want will be unsatisfactory if the program at hand has properties that are not required. Moreover, the code tells you what the what the code does, not what it was intended to do.Even when a program already exists, asking the users to read the code to find out what it will do in all cases is often inappropriate. There may be some people who use the program and either cannot, or should not, read the code. Even when the code is available it may be complex, making it difficult and time consuming to read. Using the code to answer questions can have cost and delay implications, especially when the code is being developed further or \u0393\u00c7\u00a3maintained\u0393\u00c7\u00a5. Participants in large projects often observe that without precise interface descriptions, the integration of separately written components is an arduous, costly, and time-consuming task. It can only be achieved by an iterative \u0393\u00c7\u00a3cut and try\u0393\u00c7\u00a5 process.", "num_citations": "4\n", "authors": ["41"]}
{"title": "Language-free mathematical methods for software design extended abstract\n", "abstract": " One of the many mistakes made in the early days of Computer Science was using the term\"'language\" to describe things like FORTRAN, C, Modula, ADA, or ML In normal usage,\" language\" denotes a set of signals, symbols and conventions for formulating, communicating, and recording facts (or ideas) between people. With the possible exception of ALGOL-60, which was originally designed for communication between people, that description does not fit the things that we call programming languages.Natural languages grow by an exception handling process; when users (speakers, writers) feel that a language is incapable of expressing some thought, a new word or phrase-type is added. When the need arises, nouns are\" verbed\" and meanings generalised or specialised. The set of conventions and rules that results from this type of process is complex and lacking in conceptual integrity. Unfortunately, this is\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["41"]}
{"title": "Correction to \u0393\u00c7\u00a3a rational design process: How and why to fake it\u0393\u00c7\u00a5\n", "abstract": " A careful reader, Max Stern of Teradata Corporation, has brought to our attention two errors in the above paper. 1  On page 253 in the second paragraph under point 4) the text reads, \u0393\u00c7\u00a3A purely digital or purely hybrid computer is a special case of this general module.\u0393\u00c7\u00a5 It should read, \u0393\u00c7\u00a3A purely digital or purely analog computer is a special case of this general model.\u0393\u00c7\u00a5", "num_citations": "4\n", "authors": ["41"]}
{"title": "The Parnas papers\n", "abstract": " People familiar with both software engineering and older engineering disciplines observe that the state of the art in software is significantly behind that in other areas of engineering. When most engineering products have been completed, tested and sold, it is reasonable to expect that the product design is correct and that it will work reliably. With software products, it is usual to find that the software has major\" bugs\" and does not work reliably for some users. These problems may persist for several versions and sometimes worsen as the software is\" improved\". While most products come with an express or implied warranty, software products often carry a specific disclaimer of warranty. The lay public, familiar with only a few incidents of software failure, may regard them as exceptions caused by exceptionally inept programmers. Those of us who are software professionals, know better; the most competent\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "4\n", "authors": ["41"]}
{"title": "Designing software for ease of extension and contraction\n", "abstract": " Designing software to be extensible and easily contracted is discussed as a special case of design for change. A number of ways that extension and contraction problems manifest themselves in current software are explained. Four steps in the design of software that is more \u2229\u00bc\u00e9exible are then discussed. The most critical step is the design of a software structure called the \u0393\u00c7\u00a3uses\u0393\u00c7\u00a5 relation. Some criteria for design decisions are given and illustrated using a small example. It is shown that the identi\u2229\u00bc\u00fccation of minimal subsets and minimal extensions can lead to software that can be tailored to the needs of a broad variety of users.", "num_citations": "4\n", "authors": ["41"]}
{"title": "Implementation Languages for Real\u0393\u00ea\u00c6 Time Systems\u0393\u00c7\u00f6II. Language Design\u0393\u00c7\u00f6General Comments\n", "abstract": " Implementation Languages for Real\u0393\u00ea\u00c6Time Systems \u0393\u00c7\u00f6 II. Language Design \u0393\u00c7\u00f6 General Comments - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Stats Export BibTeX EndNote RefWorks Report icon Report Implementation Languages for Real\u0393\u00ea\u00c6Time Systems \u0393\u00c7\u00f6 II. Language Design \u0393\u00c7\u00f6 General Comments Actions Email \u251c\u00f9 Email this record Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional information to be included . \u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["41"]}
{"title": "Consistency of networks of components\n", "abstract": " In this paper, we present an approach to describing a network of components and checking whether the network is complete and consistent, ie whether the components can work together properly. This model will be the basis of a procedure for checking the correctness of a network of fully specified components on the basis of their interface specifications and a description of the way that the components are connected. Our approach is different from others in that each component is viewed as a hardware-like device in which an output value can change instantaneously when input values change and all components operate synchronously rather than in sequence.", "num_citations": "3\n", "authors": ["41"]}
{"title": "Resolving dilemmas in software engineering education\n", "abstract": " Anyone developing a Software Engineering curriculum is faced with several dilemmas: Should it emphasize fundamental principles or current technology? Should it teach about a wide variety of approaches or how to use a few important methods? When discussing how the software industry does things, should we teach that this is what to do or what not to do? How should we balance \"Core Engineering' vs. \"Software Engineering' This talk will discuss one set of answers to these questions and outline a curriculum that implements them.", "num_citations": "3\n", "authors": ["41"]}
{"title": "Teaching programming as engineering\n", "abstract": " Teaching programming as engineering | Software fundamentals ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware fundamentals: collected papers by David L. ParnasTeaching programming as engineering chapter Teaching programming as engineering Share on Author: David Lorge Parnas profile image David Lorge Parnas View Profile Authors Info & Affiliations Publication: Software fundamentals: collected papers by David L. ParnasMay 2001 Pages 579\u0393\u00c7\u00f4592 1citation 0 Downloads Metrics Total Citations1 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert has and .\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["41"]}
{"title": "Who taught me about software engineering research?\n", "abstract": " I am honoured and grateful to have received the ACM-SIGSOFT Outstanding Researcher Award for 1998 and want to express my thanks. I am obviously grateful to the members of the award committee, but I also want to thank four of the people who taught me how to do research.None of the four was educated as a computer scientist. Two taught engineering and had little to do with computers; the other two were mathematicians who turned to computing. The four were Everard M. Williams, long-time Head of the Department of Electrical Engineering at Carnegie Institute of Technology (now Carnegie Mellon), Alan J. Perlis, founding Head of Carnegie's Computer Science Department and the first winner of the Turing prize, Leo A. Finzi, an internationally known Electrical Engineering researcher, and Harlan Mills a mathematician best known for the work he did while an IBM Fellow. Since all have passed away, I can only\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["41"]}
{"title": "On the computational complexity of the maximum trade problem\n", "abstract": " Consider a computer assisted trading system in which the needs and the products of the traders are compared by a computer system and the trading proceeds without attaching a dollar price to each commodity. In such a system the computer serves as an \u0393\u00c7\u00a3intelligent\u0393\u00c7\u00a5 communication link between traders, enhancing the ability of producers and consumers to exchange goods. In this paper, we examine one computational aspect of such computerized trading schemes: Given a list of trading proposals (each proposal specifying the quantities of the commodities to be traded), how should one arrange the trades so that the maximum number of trades can be made in the market? We show that this maximum trade problem is computationally hard; it is NP-complete (Nondeterministic Polynomial Time Complete). We then describe some related open questions and potential solutions.", "num_citations": "3\n", "authors": ["41"]}
{"title": "A final comment regarding \u0393\u00c7\u00ffAn alternative control structure and its formal definition\u0393\u00c7\u00d6\n", "abstract": " Meaning is explicitly assigned only to programs in which a guard is only true in states within the competence set of the program that it limits. In other words, for the program g\u0393\u00e5\u00c6 p, g must not be true in any state where p might not terminate. Although this seems reasonable at first glance, it requires that guards test the truth of conditions that can be proven true in the context in which the limited program appears. For example, if we had a guard for a square-root program, it would have to check that an argument is not negative even if it appeared at a point in the program where the argument would always be positive. Programs without such unnecessary tests are meaningless according to the formal semantics given in the paper. Several such \u0393\u00c7\u00a3meaningless\u0393\u00c7\u00a5 programs appear in the paper.The restriction was introduced because of a fundamental limitation on implementations of lists as defined in the paper. Implementations\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "3\n", "authors": ["41"]}
{"title": "Building reliable software in BLOWHARD\n", "abstract": " This note is written as a position paper for a panel discussion at a conference entitled\" Language Design for Reliable Software\". The position that it presents is that improvements in software reliability are best obtained by studying software design not by designing new languages.", "num_citations": "3\n", "authors": ["41"]}
{"title": "A RECOMMENDATION ON METHODOLOGY IN COMPUTER GRAPHICS.\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u251c\u00actre utilis\u251c\u2310 dans le cadre d\u0393\u00c7\u00d6une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u251c\u2592alado antes, el contenido de este registro bibliogr\u251c\u00edfico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "3\n", "authors": ["41"]}
{"title": "Use of the concept of transparency in the design of hierarchically structured systems\n", "abstract": " The paper deals with the design of hierarchically structured programing systems. It develops a method for evaluating the cost of requiring programmers to work with an abstraction of a real machine. A number of examples from hardward and software are given as illustrations of the method.Descriptors:", "num_citations": "3\n", "authors": ["41"]}
{"title": "The Application of Modelling to System Development and Design\n", "abstract": " This paper discusses the use of modelling in the design and development of computer systems. It begins with a definition of model'and then discusses a number of ways in which models can be useful in the process of developirg a system.", "num_citations": "3\n", "authors": ["41"]}
{"title": "On the preliminary report of C3S\n", "abstract": " AXLE is introduced in this paper as a new language for string transformation. Its two main concepts are: the assertion table and the imperative table. Maybe it would have been useful to relate these ideas to already existing ones: An assertion table is apparently nothing but a context free grammar and an imperative table is a Markov algorithm. The extension of the latter to include explicit transfer orders is inessential since it has been proved that for each scheme with explicit transfers there exists an equivalent normal algorithm. Moreover, the combination of a context-free grammar and a normal algorithm was introduced by van Wij ngaarden [2, 3] in an even more general language which has the possibility of intermixing rules from the assertion table and the imperative table and adding new rules at run time. This language was used in [1] to give a formal description of syntax and semantics of ALGOL 60. t:~ EFERENCES:", "num_citations": "3\n", "authors": ["41"]}
{"title": "Software structures: A careful look\n", "abstract": " In the half century since Edsger Dijkstra published \u0393\u00c7\u00a3The Structure of the `THE'-Multiprogramming System,\u0393\u00c7\u00a5 it has become clear that the ability to design a software system's structure is at least as important as the ability to design efficient algorithms or write code in a particular programming language. Although the word \u0393\u00c7\u00a3structure\u0393\u00c7\u00a5 appeared in the paper's title and was used seven more times, Dijkstra never defined the term. Closer examination revealed that he was discussing at least three distinct structures. His failure to define \u0393\u00c7\u00a3structure,\u0393\u00c7\u00a5 or to clearly distinguish the structures that were important in his software, has led many to confuse those structures. This article aims to clarify what those structures are, their differences, and each one's importance.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Implementation Languages for Real\u0393\u00ea\u00c6 Time Systems\u0393\u00c7\u00f6I. Standardisation\u0393\u00c7\u00f6its Implementation and Acceptance\n", "abstract": " Implementation Languages for Real\u0393\u00ea\u00c6Time Systems \u0393\u00c7\u00f6 I. Standardisation \u0393\u00c7\u00f6 its Implementation and Acceptance - ORA - Oxford University Research Archive Logos Header links Search History Bookmarks 0 New Search Deposit Help Footer links Deposit Agreements Disclaimer Privacy Policy Cookies Accessibility Statement Take-down Policy Copyright API Contact Skip to main NEW SEARCH Deposit HELP 0 Back to Search CONTACT Name Email Comment Send message Actions Authors Bibliographic Details Stats Export BibTeX EndNote RefWorks Report icon Report Implementation Languages for Real\u0393\u00ea\u00c6Time Systems \u0393\u00c7\u00f6 I. Standardisation \u0393\u00c7\u00f6 its Implementation and Acceptance Actions Email \u251c\u00f9 Email this record Send the bibliographic details of this record to your email address. Your Email Please enter the email address that the record information will be sent to. Your message (optional) Please add any additional to \u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["41"]}
{"title": "How engineering mathematics can improve software\n", "abstract": " For many decades computer science researchers have promised that the\" Formal Methods\" developed by computer scientists would bring about a drastic improvement in the quality and cost of software. That improvement has not materialized. We review the reasons for this failure. We then explain the difference between the notations that are used in formal methods and the mathematics that is essential in other areas of Engineering. Finally, we illustrate the ways that Engineering Mathematics can be useful in software projects", "num_citations": "2\n", "authors": ["41"]}
{"title": "A family of computer systems for delivering individualized advice\n", "abstract": " We describe a prototype framework for a family of individualized-advice systems (IAS). The purpose of an individualized-advice system is to select the most relevant material from a large set of potentially useful documents and present the documents selected to someone seeking advice.IAS systems should not be viewed as applications of artificial intelligence, language recognition, or machine learning. Instead, they are a way to organize a large knowledge base so that the relevant documents can be retrieved. An IAS allows Subject Matter Specialists (SMSs) to classify documents and uses the classification information in the retrieval. The effectiveness of an IAS depends on the ability of the SMS to classify the documents accurately.We illustrate the use of the prototype framework with a detailed description of an application in the area of early childhood development, a prototype system, which we call \u0393\u00c7\u00a3Interactive\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["41"]}
{"title": "Requirements documentation: a systematic approach\n", "abstract": " Unless you have a complete and precise description of a product's requirements, it is very unlikely that those requirements will be satisfied. An incomplete or inconsistent requirements document can mislead developers. A collection of statements in English, or some other natural language, cannot be checked for completeness and will not be precise. Even if you translate an informal requirements statement into a mathematical language, and show that the result is complete and unambiguous, the original may still be faulty. This talk describes a sound procedure for documenting requirements - one that lets you know when your document is complete and consistent. Documents produced by following this procedure can be reviewed by potential users and specialists and can serve as the input to tools that generate prototypes and monitors.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Documentation based software testing\n", "abstract": " Testing is sometimes viewed as an add on step in software development - something you do to demonstrate that the product is ready for use. Test planning is often postponed until the development is near its end. This results in incomplete testing, ambiguous test results, and the release of products of doubtful quality. After reviewing fundamental software testing issues, we describe a document-driven testing approach in which test plans and test result evaluation are done with the aid of documentation prepared throughout the design process. The policies about testing, and response to test results are determined in advance and high quality standards can be enforced on a project.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Design through documentation: the path to software quality\n", "abstract": " In traditional engineering design, preparation of a sequence of documents precedes the actual construction begins. Each document is used for review and analysis and, after revision, serves as input to the next phase in the development. When errors are discovered or changes are required, the design documents previously approved are updated and reviewed again. Each new document is reviewed against the previous documents. Whenever a document is revised, those based on it are reviewed and revised if necessary. In software design this approach is rarely properly applied. Practitioners seem unable or willing to write the precise documents that would be required. Instead, they write vague statements that cannot be subject to rigorous analysis and are of little value to those making the next decisions. We will provide precise definitions of a set of software documents and how these documents can be produced as part of an improved software development process.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Two positions on licensing\n", "abstract": " The papers in this book comprise the proceedings of the meeting mentioned on the cover and title page. They reflect the authors\u0393\u00c7\u00d6 opinions and, in the interests of timely dissemination, are published as presented and without change. Their inclusion in this publication does not necessarily constitute endorsement by the editors, the IEEE Computer Society Press, or the Institute of Electrical and Electonics Engineers, Inc.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Invited Talk: A Software Engineering Program of Lasting Value\n", "abstract": " Engineering educators have long recognised that it is their obligation to prepare students for a professional career that may last 40 years in rapidly changing fields. Good engineering educators know that they must focus on fundamental ideas and teach students how to apply those ideas. Thus, although I studied Electrical Engineering at a time when semiconductor research was considered useless theory by many of my teachers, most of my textbooks are still valid and still useful. In contrast, most of the computer books on my shelves are out-of-date and irrelevant.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Teaching for Change\n", "abstract": " A perennial concern of those who teach about computers is the rapid change that we see in our field. The hardware and software that dominated the field just four years ago are not even considered interesting today. When we think about our students, we must wonder how we can teach anything that will be relevant when they graduate-or five years later. While the pace of change in computing is unprecedented, the problem of teaching engineers in rapidly changing fields is not. When I received my electrical engineering education in the late 60\u0393\u00c7\u00d6s, my teachers were as concerned about rapid change as we are today. When I entered engineering, the \u0393\u00c7\u00a3real world\u0393\u00c7\u00a5 was vacuum tubes, and some people told me that semiconductor physics was \u0393\u00c7\u00a3useless theory.\u0393\u00c7\u00a5 The wise members of the faculty recognized that what we taught had to be useful now, as well as in the future. Today, teaching in an engineering environment once\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["41"]}
{"title": "Table Tool System Developer's Guide\n", "abstract": " We describe the design of an open ended set of tools for manipulating multi\u0393\u00c7\u00f4dimensional tabular expressions. The heart of the toolset is a tool integration framework that makes it possible to add new tools to the toolset without having detailed knowledge of the existing tools. This set of modules supports new and existing tools by providing abstract communication interfaces. The framework has proven to be an excellent approach to integrating research prototypes.", "num_citations": "2\n", "authors": ["41"]}
{"title": "The Future of Formal Methods in Industry\n", "abstract": " The Future of Formal Methods in Industry | Proceedings of the 9th International Conference of Z Usres on The Z Formal Specification Notation ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsZUM '95The Future of Formal Methods in Industry ARTICLE The Future of Formal Methods in Industry Share on Authors: Anthony Hall profile image Anthony Hall View Profile , David Lorge Parnas profile image David Lorge Parnas View Profile , Nico Plat profile image Nico Plat View Profile , John M Rushby profile image John M. Rushby View Profile , Chris T Sennett profile image Chris T. Sennett View Profile Authors Info & Affiliations : ''.\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["41"]}
{"title": "ACM forum; readers argue teaching methods\n", "abstract": " David Gries argues rather forcefully for changes in the methods used to train software engineers. The majority of the article advocates increasing the amount of mathematics taught to undergraduate students. I, too, have a suggestion about how to improve the curriculum.Gries's ideas reflect his background as a professor with a Ph. D. in mathematics. My suggestion reflects my background as simply a programmer who writes many thousands of lines of code per year.", "num_citations": "2\n", "authors": ["41"]}
{"title": "SDI: Two Views of Professional Responsibility\n", "abstract": " INTRODUCTION was asked by the US Secretar 1.000 (US) In May of 1985 I was asked by the Strategic Defense InitiativeOrganization, the group within the Office of the US Secretary of Defense that is responsible for the \u0393\u00c7\u00a3Star Wars\u0393\u00c7\u00a5 program, to serve on a $1,000 (US)/day advisory panel, the SDIO Panel on Computing in Support of Battle Management. The panel was to make recommendations about a research and development program to solve the computational problems inherent in space-based defense systems.", "num_citations": "2\n", "authors": ["41"]}
{"title": "A program holder module\n", "abstract": " This paper describes a mechanism for holding a program in syntactic form. This mechanism can be useful to any program which processes programs: in program verification, automatic programming, and specialized text editing. In this case the program holder is used to form the basis for a syntax-driven text editor. Formal specifications for the program holder are also given.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Window: a formally-specified graphics-based text editor\n", "abstract": " WINDOW is a formally-specified text editing program which exploits the graphics capabilities of crt terminals [1]. Terminal screens are divided into several\" windows\". Each window displays text from any of a number of simultaneously open fifes. Through the notion of linked\" pointers\", operations upon one file may invoke corresponding operations upon other files.", "num_citations": "2\n", "authors": ["41"]}
{"title": "Sample Man-Machine Interface Specification: A Graphics Based Line Editor\n", "abstract": " The pages which follow are intended to serve two distinct purposes. Primarily they were intended as an example of a precise specification of a man-machine interface. In addition, however, the object specified is also of interest. It is a text editing system which is designed to take advantage of properties of an interactive graphics terminal which are not held by typewriter-like terminals. I shall introduce each of these aspects separately.", "num_citations": "2\n", "authors": ["41"]}
{"title": "State table analysis of programs in an algo-like language\n", "abstract": " SFD-ALCGOL 1, 2 is an ALGOL-like language intended to describe the functiong of synchronous systems. The/unction of a system is the response of its output to any input sequence. This function can be described by an algorithm. The algorithm need not be the one actually used by the system; it need only be equivalent. ALGOL is suitable for such a purpose except that it cannot express timing, specify input restrictions, or indicate which variables are input/output variables. SFD-ALGOL is identical to ALGOL-60 except for a few added declarations and an extra type of statement grouping known as a time block. The time block consists of statements enclosed within a time begin and the corresponding end, and is interpreted to mean that all actions indicated within it occur in the span of one clock pulse. Further details of SFD-ALGOL can be found in~, a complete specification is supplied in 1. b. The object language\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "2\n", "authors": ["41"]}
{"title": "Software engineering: a profession in waiting\n", "abstract": " Accreditation authorities were created because the licensing authorities, realizing that the education of an applicant for a license is a key determinant of the applicant\u0393\u00c7\u00d6s capabilities, found it more efficient to evaluate programs than to evaluate the education of each applicant. Accreditation also helps prospective students to pick a program that is likely to bring them closer to their career goals.", "num_citations": "1\n", "authors": ["41"]}
{"title": "Connecting good theory to good practice: Software documentation: A case study\n", "abstract": " The motto that appeared on my slides for many years,\u0393\u00c7\u00a3connecting theory to practice\u0393\u00c7\u00a5, is like motherhood; nobody dares to oppose it, at most half of us could actually do it, and many are actively trying to prevent it. Over many decades, I have been fascinated by Computer Science theory and software development practice but disappointed by both.", "num_citations": "1\n", "authors": ["41"]}
{"title": "Decomposition of software into components\n", "abstract": " Most software products are too large to be completed by a single person in a short period. To make the development manageable, the software must be divided into components that can be developed (and later maintained) separately. Each component will be a work assignment for a team or individual. It is often thought that this decomposition is a management decision, determined primarily by the talent available. This lecture explains that the decomposition is a critical design decision to be made on the basis of simple technical criteria, which will be stated and illustrated. The result is a very unconventional, but easily maintained, design.", "num_citations": "1\n", "authors": ["41"]}
{"title": "Improving software quality-the sqrl approach\n", "abstract": " This paper provides an introduction to the Software Quality Research Laboratory at the University of Limerick.", "num_citations": "1\n", "authors": ["41"]}
{"title": "Description and specification\n", "abstract": " Description and specification | Software fundamentals ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksSoftware fundamentals: collected papers by David L. ParnasDescription and specification chapter Description and specification Share on Authors: David Lorge Parnas profile image David Lorge Parnas View Profile , P Eng profile image P. Eng View Profile Authors Info & Affiliations Publication: Software fundamentals: collected papers by David L. ParnasMay 2001 Pages 1\u0393\u00c7\u00f46 0citation 0 Downloads Metrics Total Citations0 Total Downloads0 Last 12 Months0 Last 6 weeks0 Get Citation Alerts New Citation Alert added! This alert to.\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["41"]}
{"title": "Computers: Boon or bane?\n", "abstract": " Predicting the long-term effects of computers is both difficult and easy: we wont get it right, but we won t see ourselves proven wrong. Rather than try, we present some alternatives allowing readers to make their own predictions.* Computers play an increasing role in enabling and mediating communication between people. They have great potential for improving communication, but there is a real risk they will simply overload us, keeping us from really communicating. We already receive far more information than we can process. A lot of it is noise. Will computers help us to communicate or will they interfere?", "num_citations": "1\n", "authors": ["41"]}
{"title": "The professional responsibilities of software engineers\n", "abstract": " CiNii \u03a6\u00bd\u00fb\u00b5\u00fb\u00e7 - The professional responsibilities of software engineers CiNii \u03c3\u00a2\u255c\u03c4\u00bd\u00ef\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00a1\u00aa\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u00b5\u00eb\u00c7 \u03c3\u00a1\u00aa\u03a6\u00ed\u00f4 \u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c0\u00e2\u00e8\u03c0\u00e2\u00f4\u03c0\u00e9\u2593\u03c0\u00e2\u255d\u03c0\u00e9\u2510[\u03c0\u00e9\u2561\u03c0\u00e9\u00f1\u03c0\u00e2\u00ef\u03c0\u00e9\u00fa] \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u03c3\u00f1\u00ba\u03c3\u00a1\u00aa\u03c3\u00a2\u2502\u00b5\u00a2\u2555\u0398\u00f1\u00bf\u03c0\u00fc\u00ab\u00b5\u00a3\u00bc\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00f9\u00d1\u00b5\u00a3\u00bc\u03c0\u00fc\u00ab\u03c3\u00ec\u00dc\u03c3\u00fa\u00bd\u03a6\u00bd\u00fb\u00b5\u00fb\u00e7\u03c0\u00e9\u00c6\u03c0\u00fc\u00f2\u03c0\u00fc\u00ee\u03c0\u00fc\u00d6 \u00b5\u00fb\u2591\u03a6\u00aa\u00c5 \u03c4\u00d6\u2557\u0398\u00ee\u2593 \u03c0\u00e2\u00a1\u03c0\u00e9\u2591\u03c0\u00e9\u00f1\u03c0\u00e2\u2502 English \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u03c0\u00fc\u00d6\u03c0\u00fc\u2563\u03c0\u00fc\u00aa \u00b5\u00a3\u00bc\u00b5\u00fb\u00e7\u03c0\u00fc\u00e9\u03c0\u00e9\u00e8 \u0398\u00fb\u00eb\u03c0\u00fc\u00ff\u03c0\u00e9\u00ef \u03c0\u00e9\u2510\u03c0\u00e9\u00f1\u03c0\u00e2\u00ea\u03c0\u00e2\u00bd \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u03c3\u00c9\u00ec \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0ID \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0\u00b5\u00eb\u00c7\u03c3\u2592\u20a7 \u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310\u03c3\u00c9\u00ec ISSN \u03c3\u2556\u2557\u03c3\u00c5\u2556\u03c0\u00e2\u00dc\u03c0\u00e2\u255d\u03c0\u00e9\u2555 \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03a6\u00c7\u00e0 \u03c3\u00c5\u00e9\u03a6\u00c7\u00e2\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab \u03c3\u00e7\u2551\u03c4\u00eb\u00ea\u03c3\u2563\u2524 \u03c3\u2563\u2524\u03c0\u00fc\u00ef\u03c0\u00e9\u00eb \u03c3\u2563\u2524\u03c0\u00fc\u255b\u03c0\u00fc\u00ba \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 \u00b5\u00f1\u00a3\u03c4\u2524\u00f3 CiNii\u03c0\u00fc\u00ab\u03c0\u00e9\u2561\u03c0\u00e2\u255d\u03c0\u00e2\u00f4\u03c0\u00e9\u2563 \u03c0\u00fc\u00bd\u0398\u00fb\u00f3\u03c0\u00fc\u00d6\u03c0\u00e9\u00ef\u03c0\u00e9\u00f3\u03c0\u00e2\u2502\u03c0\u00e9\u2592\u03c0\u00e2\u255d\u03c0\u00e2\u00ea\u03c0\u00e9\u00c6\u03c3\u00ab\u0192\u00b5\u00fb\u255c\u03a3\u2555\u00a1\u03c0\u00fc\u00ba\u03c0\u00fc\u00d6\u2229\u255d\u00ea11/11(\u00b5\u2591\u2524)-12/23(\u00b5\u2591\u2524)\u2229\u255d\u00eb CiNii Research\u03c0\u00e2\u00f9\u03c0\u00e2\u00bc\u03c4\u00eb\u00ea\u03c0\u00fc\u00ab\u03c3\u00e0\u00bc\u0398\u00fb\u00ef\u03c0\u00fc\u00bd\u03c0\u00fc\u00f1\u03c0\u00fc\u00e4\u03c0\u00fc\u00aa The professional responsibilities of software engineers PARNAS DL \u03a6\u00f3\u00bd\u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562 \u03a6\u00e6\u00f9\u03a6\u00c7\u00e0 PARNAS DL \u03c3\u00c5\u00c4\u0398\u00ee\u2593\u03c3\u00ea\u00e8\u03a6\u00ed\u00ee\u03c4\u00eb\u2310 Software Fundamentals : Collected Papers by David L. Parnas Software Fundamentals : Collected Papers by David L. Parnas, 537-548, 2001 Addison Wesley \u03a6\u00f3\u00bd \u03c3\u255d\u00f2\u03c4\u00f6\u00bf\u00b5\u00fb\u00e7\u03c4\u00ee\u00ab: 1\u03a3\u2557\u2562\u03a3\u2555\u00a1 1-1\u03a3\u2557\u2562\u03c0\u00e9\u00c6 \u03a6\u00ed\u00bf\u03c4\u00f1\u2551 1 \u03a3\u2551\u00ee\u03c0\u00fc\u00f1\u03c0\u00fc\u00ab\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5 : \u0398\u00ff\u2593\u03c4\u00e8\u00bb\u03c0\u00fc\u00ab\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5\u03c0\u00fc\u00bf\u00b5\u00e8\u2561\u00b5\u00e8\u00f9\u03c0\u00fc\u00ab\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5 \u03c3\u2592\u2592\u00b5\u00e1\u2563 \u03a3\u2510\u00ed\u03a3\u2551\u00ee , \u00b5\u00a5\u00e6\u03c3\u2592\u2592 \u03c3\u00e4\u00ac\u03c3\u00a1\u00c9 \u0398\u00a2\u2557\u03c3\u00a1\u00c9\u00b5\u00e2\u00e0\u03c3\u00e1\u2592\u0398\u00c7\u00dc\u03a3\u2510\u00ed\u03c3\u00a1\u00aa\u03a3\u255d\u00dc\u00b5\u00e8\u00c7\u03a6\u00ed\u00f4\u03c4\u00e1\u00f6\u03c4\u2310\u2562\u03c3\u00e1\u2592\u03c3\u00e6\u00e8. SITE, \u00b5\u00e8\u00c7\u03a6\u00ed\u00f4\u03c0\u00fc\u00bf\u03c4\u00f1\u255b\u03a3\u255d\u00dc\u03c0\u00e2\u2557\u03c3\u00c7\u00bd\u03c4\u00c9\u00e5 : IEICE technical report 102(), -/\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["41"]}
{"title": "Inside risks: ten myths about Y2K inspections\n", "abstract": " Inside risks: ten myths about Y2K inspections Page 1 128 May 1999/Vol. 42, No. 5 COMMUNICATIONS OF THE ACM A s I write this, the alarmist reports about Y2K are being replaced with more comforting statements. Repeatedly, I hear, \u0393\u00c7\u00a3We have met the enemy and fixed the bugs.\u0393\u00c7\u00a5 I would find such statements comforting if I had not heard them before when they were untrue. How often have you seen a product, presumably well-tested, sent to users full of errors? By some estimates, 70% of first fixes are not correct. Why should these fixes, made to old code by programmers who are not familiar with the systems, have a better success rate? The Y2K mistake would never have been made if programmers had been properly prepared for their profession. There were many ways to avoid the problem without using more memory. Some of these were taught 30 years ago and are included in software design textbooks. The this \u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["41"]}
{"title": "Engineering Mathematics\n", "abstract": " CONCLUSIONFor formal methods to change the practice, we must take this pragmatic attitude into account. It does no good (and immense harm) to promote formality as an either/or proposition. There are various levels of formality, from purely descriptive to deep, deductive analysis, that can be applied at the various life cycle stages. We must be careful to provide a balanced treatment, where current and future practitioners learn the advantages and limitations, as well as the benefits and costs, of greater formality.", "num_citations": "1\n", "authors": ["41"]}
{"title": "The impact of money-free computer assisted barter systems\n", "abstract": " Background:In his article, Dr. Parnas discusses Computer Assisted Barter Systems (CABS). These are systems where people can trade goods and services without the use of money. Dr. Parnas believes that CABS will be beneficial to society, and if used in a widespread manner, can help eliminate many of the ills that money brings to society.", "num_citations": "1\n", "authors": ["41"]}
{"title": "Lastig gepreek uit nuenen\n", "abstract": " Conclusion sDijkstra's papers applying mathematical discipline to programming have improved the programs of everyone who has taken hi s advice seriously. However, taking his SEN\" contribution\" seriously would lead us astray. Europeans have had great insights abou t the development of elegant programs, but Americans do quite well at producing useful programs. To achieve the best of both worlds, programs that are both elegant and useful, we dare not ignore either side.", "num_citations": "1\n", "authors": ["41"]}
{"title": "Evaluation criteria for abstract machines with unknown applications\n", "abstract": " The joint Navy/Army Computer Family Architecture (CFA) project has been based on finding an abstract design for a computer which can then be implemented to fit a wide variety of environmental and application demands. The approach is unquestionably useful in our effort to make DoD software procurement more rational and DoD software more reliable. It must be recognized, however, that the decision selecting an abstract design on the basis of unspecified application needs, makes the hardware selection much more difficult. We have no hope of obtaining objective comparative data by running benchmarks and measuring the time required. Even more abstract measures such as instruction counts and memory cycle counts can be interpreted only as'~ ints\" and not as comparable measurements. Even on the fairly conventionally designed 370 series where all instruction sets are identicalthe best code sequence\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["41"]}
{"title": "A paradigm for software module specification with examples\n", "abstract": " This paper presents a method for writing specifications of parts of software systems. The main goal is to provide specifications sufficiently precise and complete that other pieces of software can be written to interact with the piece specified without additional information. The secondary goal is to include in the specification no more information than necessary to meet the first goal. The technique is illustrated by means of a variety of examples from a tutorial system.", "num_citations": "1\n", "authors": ["41"]}
{"title": "Letters to the editor: on improving the quality of our technical meetings\n", "abstract": " EDITOR: Over the relatively few years that I have been attending Joint Computer Conferences and ACM national conferences there has been an undercurrent of dissatisfaction with the quality and nature of the average technical paper presented at those conferences. There has been a tendency for the\" People Who Have Real Work to Do\"(PWHRWD) members of the societies to blame the lack of relevance on the presence of academic interests while the academic interests have blamed the relatively low quality of the papers on the presence of the PWHRWD. Contrary to these feelings, I am certain that an objective analysis will show that both groups are dissatisfied and that both groups have contributed irrelevant and low quality papers to the conferences. While most of the negative comments have been made in private conversation, more recent conferences, especially this year's SJCC, have seen public\u252c\u00e1\u0393\u00c7\u00aa", "num_citations": "1\n", "authors": ["41"]}
{"title": "l, turnooucrron\n", "abstract": " 3. Methods of detecting errors in design decisions shortly after they are made [l, 2, 3, 5. 8, 9]. 4. Speci\u2229\u00bc\u00fccation techniques (12, 13]. 5. Tools for system designers [l, 2, 3, 10, 11]. This paper emphasizes another topic named \u0393\u00c7\u00a3information distribution\u0393\u00c7\u00a5. Design and development are a series of decisions. Each decision results in informa tion about the system which can be used in making later decisions. We eventually want to discuss the distribution of that information among those working on the system and to deal with its organization in documentation. To prepare for this discussion we deal \u2229\u00bc\u00fcrst with (l) the concept of system structure,(2) constraints on the order of decisions, and (3) some observed characteristics of good programmers.", "num_citations": "1\n", "authors": ["41"]}
{"title": "TEACHING THE COOPERATIVE PRODUCTION OF PROGRAMS\n", "abstract": " This is a report on a course entitled\" Software Engineering Methods\", which has been taught to undergraduate students at the Carnegie-Mellon University during the last two academic years. The course is\" project oriented\" and aims to educate by providing experience in the use of techniques. This report describes both the structure of the course and some of the material taught.", "num_citations": "1\n", "authors": ["41"]}