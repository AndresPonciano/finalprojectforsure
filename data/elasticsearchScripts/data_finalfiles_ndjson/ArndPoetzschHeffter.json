{"title": "JCoBox: Generalizing active objects to concurrent components\n", "abstract": " Concurrency in object-oriented languages is still waiting for a satisfactory solution. For many application areas, standard mechanisms like threads and locks are too low level and have shown to be error-prone and not modular enough. Lately the actor paradigm has regained attention as a possible solution to concurrency in OOLs.               We propose JCoBox: a Java extension with an actor-like concurrency model based on the notion of concurrently running object groups, so-called coboxes. Communication is based on asynchronous method calls with standard objects as targets. Cooperative multi-tasking within coboxes allows for combining active and reactive behavior in a simple and safe way. Futures and promises lead to a data-driven synchronization of tasks.               This paper describes the concurrency model, the formal semantics, and the implementation of JCoBox, and shows that the performance\u00a0\u2026", "num_citations": "166\n", "authors": ["1758"]}
{"title": "Using data groups to specify and check side effects\n", "abstract": " Reasoning precisely about the side effects of procedure calls is important to many program analyses. This paper introduces a technique for specifying and statically checking the side effects of methods in an object-oriented language. The technique uses data groups, which abstract over variables that are not in scope, and limits program behavior by two alias-confining restrictions, pivot uniqueness and owner exclusion. The technique is shown to achieve modular soundness and is simpler than previous attempts at solving this problem.", "num_citations": "140\n", "authors": ["1758"]}
{"title": "Specification and verification of object-oriented programs\n", "abstract": " Interface specifications should express program properties in a formal, declarative, and implementation {independent way. To achieve implementation {independency, interface specifications have to support data abstraction. Program verification should enable to prove implementations correct wrt such interface specifications. The presented work bridges the gap between existing specification and verification techniques for object {oriented programs. The integration is done within a formal framework for interface specifications and programming language semantics. Interface specification techniques are enhanced to support the specification of data structure sharing and destructive updating of shared variables. These extensions are necessary for the specification of real life software libraries. Moreover this generalization is needed for intermediate steps in correctness proofs. For verification, Hoare logic is extended to capture recursive classes and subtyping. Based on this extended logic, techniques are presented for proving typing properties, class and method invariants. The new techniques are developed as a foundation for programming environments supporting specification and verification of programs. A major application will be the specification and verification of reusable class libraries. That is one of the reasons why the work focuses on object-oriented languages, even though the techniques are applicable to other imperative languages as well.", "num_citations": "131\n", "authors": ["1758"]}
{"title": "Universes: A Type Systems for Alias and Dependency Control\n", "abstract": " Universes Anmelden mirmycoremods institutional repository Toggle navigation Suche Erweitert Experte Browsen nach Einrichtung nach Dokumenttyp nach Sachgruppe nach Personen Registrierung Registrierung 0 Merkliste \u00f6ffnen Start Informatik-Berichte Universes auf die Merkliste Abbrechen Buch (Monographie) 2001 Alle Rechte vorbehalten Ver\u00f6ffentlicht Universes : A Type Systems for Alias and Dependency Control M\u00fcller, Peter GND ; Poetzsch-Heffter, Arnd Vorschau Dateien Metadaten In Serie: Informatik-Berichte Vol. 279 Datum der Ver\u00f6ffentlichung: 2001 URN: urn:nbn:de:hbz:708-dh4065 Sprache: Englisch Umfang: 25 Seiten Erscheinungsort: Hagen Verlag: FernUniversit\u00e4t in Hagen DDC-Sachgruppe der DNB: 004 Informatik Einrichtung: Fakult\u00e4t f\u00fcr Mathematik und Informatik Zitieren Zitierform: M\u00fcller , Peter / Poetzsch-Heffter , Arnd: Universes. A Type Systems for Alias and Dependency Control. Hagen \u2026", "num_citations": "107\n", "authors": ["1758"]}
{"title": "An architecture for interactive program provers\n", "abstract": " Formal specification and verification techniques can improve the quality of programs by enabling the analysis and proof of semantic program properties. This paper describes the modular architecture of an interactive program prover that we are currently developing for a Java subset. In particular, it discusses the integration of a programming language-specific prover component with a general purpose theorem prover.", "num_citations": "82\n", "authors": ["1758"]}
{"title": "Modular specification and verification techniques for object-oriented software components\n", "abstract": " Component-based software development means reusing prefabricated components, adapting them to particular needs, and combining them to larger components or applications. Reusing components developed by other companies leads to a demand for high-level component specifications and for certification of the component qual-ity. Most quality levels beyond syntactic and type correctness need techniques for formal specification and verification.Component-based software development requires that the specification and verification techniques can handle modularity and adaptability. Modularity means that specifications need to support abstraction from encapsulated implementation aspects, that they remain valid under composition, and that they are sufficiently expressive for verifying properties of composed programs from the specifications of their components. Adaptability means that the programming and specification framework support techniques to adapt existing components to the needs and in-", "num_citations": "77\n", "authors": ["1758"]}
{"title": "Logical foundations for typed object-oriented languages\n", "abstract": " This paper presents logical foundations for the most important object-oriented language features, including abstract types, dynamic binding, subtyping, and inheritance. These foundations are introduced along with an object-oriented kernel language. We show how object environments of such languages can be formalized in an algebraic way. Based on this foundation, we develop a Hoare-style logic for formal verification of object-oriented programs.", "num_citations": "68\n", "authors": ["1758"]}
{"title": "A type system for controlling representation exposure in Java\n", "abstract": " \u00cbharing mutable objects is typical for object-oriented programs. As a direct consequence of the concept of object identities, it is one of the fundamentals of the OO-programming model. Furthermore, OO-programs gain much of their efficiency through sharing and destructive updates. However, uncontrolled sharing leads to serious problems: Usually several objects work together to represent larger components such as windows, parsers, dictionaries, etc. Current OO-languages do not prevent references to objects of such components from leaking outside the components' boundaries, a phenomenon called rep exposure. Thus, arbitrary objects can use these references to manipulate the internal state of components without using their explicit interface. These manipulations can effect both the abstract value of components and their invariants. This makes OO-programs very hard to reason about. Furthermore, in systems with uncontrolled sharing, basically every object can interact with any other object. Therefore, such systems lack a modular structure and are difficult to maintain.In this extended abstract, we present a type system for Java and similar languages that enforces a hierarchical partitioning of the object store into so-called universes and controls references between universes. The universe type system provides support for preventing rep exposure while retaining a flexible sharing model. It is easy to apply and guarantees an invariant that is strong enough for modular verification. Our type system is related to ownership types ([CPN98]), balloon types ([Alm97]), and islands ([Hog91]). However, it is capable of specifying certain implementation\u00a0\u2026", "num_citations": "42\n", "authors": ["1758"]}
{"title": "Prototyping realistic programming languages based on formal specifications\n", "abstract": " The specification of realistic programming languages is difficult and expensive. One approach to make language specification more attractive is the development of techniques and systems for the generation of language\u2013specific software from specifications. To contribute to this approach, a tool\u2013based framework with the following features is presented: It supports new techniques to specify more language aspects in a static fashion. This improves the efficiency of generated software. It provides powerful interfaces to generated software components. This facilitates the use of these components as parts of language\u2013specific software. It has a rather simple formal semantics. In the framework, static semantics is defined by a very general attribution technique enabling e.g. the specification of flow graphs. The dynamic semantics is defined by evolving algebra rules, a technique that has been successfully applied\u00a0\u2026", "num_citations": "39\n", "authors": ["1758"]}
{"title": "Konzepte objektorientierter Programmierung: Mit einer Einf\u0158hrung in Java\n", "abstract": " Das Buch bietet eine kompakte Einf\u0158hrung in die Konzepte objektorientierter Programmierung. Es erl\u0144utert das Objekt-und Klassenkonzept, beschreibt Kapselungstechniken und geht detailliert auf Subtyping und Vererbung ein. Software-Wiederverwendung in Form von Bibliotheksbausteinen und Programmger\u0158sten (Frameworks) wird am Beispiel der Verarbeitung von Str\u00f7 men und der Konstruktion graphischer Bedienoberfl\u0144chen behandelt. Dar\u0158ber hinaus wird auf wichtige Konzepte der parallelen und verteilten Programmierung eingegangen und der praktische Zusammenhang zur Objektorientierung hergestellt.-Jedes objektorientierte Konzept wird zun\u0144chst unabh\u0144ngig von einer Programmiersprache eingef\u0158hrt. Anschlie\u2580 end wird seine konkrete Umsetzung in Java erl\u0144utert. Zum Teil werden auch Realisierungsvarianten in anderen objektorientierten Sprachen vorgestellt. Aus praktischer Sicht ergibt sich damit insgesamt eine konzeptionell strukturierte Einf\u0158hrung in die Sprache Java und ihre Standardbibliothek.", "num_citations": "33\n", "authors": ["1758"]}
{"title": "Formal specification and verification of crdts\n", "abstract": " Convergent Replicated Data Types (CRDTs) can be used as basic building blocks for storing and managing replicated data in a distributed system. They provide high availability and performance, and they guarantee eventual consistency. In this paper, we develop a formal framework for the analysis and verification of CRDTs. We investigate and compare the three currently used specification techniques for CRDTs and formalize them based on an abstract model for managing replicated data in distributed systems. We show how CRDT implementations can be expressed in our framework and present a general strategy for verifying CRDTs. Finally, we report on our experiences in using the framework for the verification of important existing CRDT implementations. The framework and the proofs were developed within the interactive theorem prover Isabelle/HOL.", "num_citations": "27\n", "authors": ["1758"]}
{"title": "Towards proof generating compilers\n", "abstract": " Correctness of compilation is important for the reliability of software. New techniques to guarantee correctness do not verify the compiler itself, but check for each compiled program whether it is correctly translated. Following these ideas, we developed an approach in which checking is realized as proof checking within a formal specification and verification framework. Based on formal specifications of source and target language and a translation predicate, compilers produce, in addition to the target program c, a proof that c is correct w.r.t. its source program. This proof can be checked independently of the compiler by the framework. Thus, it can be used as a translation certificate.The paper describes the overall approach and applies it to a simple translation scenario. Specification and verification is done within the theorem prover Isabelle/HOL. To show the flexibility of the approach, we present two different proof\u00a0\u2026", "num_citations": "27\n", "authors": ["1758"]}