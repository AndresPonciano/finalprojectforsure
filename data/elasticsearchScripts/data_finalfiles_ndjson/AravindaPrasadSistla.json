{"title": "Modeling and querying moving objects\n", "abstract": " We propose a data model for representing moving objects in database systems. It is called the Moving Objects Spatio-Temporal (MOST) data model. We also propose Future Temporal Logic (FTL) as the query language for the MOST model, and devise an algorithm for processing FTL queries in MOST.", "num_citations": "929\n", "authors": ["1584"]}
{"title": "Updating and querying databases that track mobile units\n", "abstract": " In this paper, we consider databases representing information about moving objects (e.g., vehicles), particularly their location. We address the problems of updating and querying such databases. Specifically, the update problem is to determine when the location of a moving object in the database (namely its database location) should be updated. We answer this question by proposing an information cost model that captures uncertainty, deviation, and communication. Then we analyze dead-reckoning policies, namely policies that update the database location whenever the distance between the actual location and the database location exceeds a given threshold, x. Dead-reckoning is the prevalent approach in military applications, and our cost model enables us to determine the threshold x. We propose several dead-reckoning policies and we compare their performance by simulation.               Then we\u00a0\u2026", "num_citations": "590\n", "authors": ["1584"]}
{"title": "Symmetry and model checking\n", "abstract": " We show how to exploit symmetry in model checking for concurrent systems containing many identical or isomorphic components. We focus in particular on those composed of many isomorphic processes. In many cases we are able to obtain significant, even exponential, savings in the complexity of model checking.", "num_citations": "513\n", "authors": ["1584"]}
{"title": "Reasoning about systems with many processes\n", "abstract": " Methods are given for automatically verifying temporal properties of concurrent systems containing an arbitrary number of finite-state processes that communicate using CCS actions. TWo models of systems are considered. Systems in the first model consist of a unique control process and an arbitrary number of user processes with identical definitions. For this model, a decision procedure to check whether all the executions of a process satisfy a given specification is presented. This algorithm runs in time double exponential in the sizes of the control and the user process definitions. It is also proven that it is decidable whether all the fair executions of a process satisfy a given specification. The second model is a special case of the first. In  this model, all the processes have identical definitions. For this model, an efficient decision procedure is presented that checks if every execution of a process satisfies a given\u00a0\u2026", "num_citations": "507\n", "authors": ["1584"]}
{"title": "On model-checking for fragments of \u03bc-calculus\n", "abstract": " In this paper we considered two different fragments of \u03bc-calculus, logics L 1 and L 2. We gave model checking algorithms for logics L 1 and L 2 which are of complexity O(m 2 n) where m is the length of the formula and n is the size of the structure. We have shown that the logic L 2 is as expressive as ECTL* given in [13]. In additions to these results, we have shown that the model checking problem for the \u03bc-calculus is equivalent to the non-emptiness problem of parity tree automata.             It will be interesting to investigate if there is a model checking algorithm for the logics L 1 and L 2 which is only of complexity O(mn) instead of O(m 2 n. Of course, determining if the model checking problem for the full \u03bc-calculus is in P or not, is also an open problem.", "num_citations": "406\n", "authors": ["1584"]}
{"title": "Deciding full branching time logic\n", "abstract": " In this paper the full branching time logic (CTL*) is studied. It has basic modalities consisting of a path quantifier, either A (\u201cfor all paths\u201d) of E (\u201cfor some path\u201d), followed by an arbitrary linear time assertion composed of unrestricted combinations of the usual linear temporal operators F (\u201csometime\u201d), G (\u201calways\u201d), X (\u201cnexttime\u201d), and U (\u201cuntil\u201d). It is shown that the problem of determining if a CTL* formula is satisfiable in a structure generated by a binary relation is decidable in triple exponential time. The decision procedure exploits the special structure of the finite state \u03c9-automata for linear temporal formulae which allows them to be determinized with only a single exponential blowup in size. Also the expressive power of tree automata is compared with that of CTL* augmented by quantified auxillary propositions.", "num_citations": "349\n", "authors": ["1584"]}
{"title": "Efficient distributed recovery using message logging\n", "abstract": " Distributed computer systems offer the potential advantages of increased availability and reliability over centralized systems. In order to realize these advantages, we must develop recovery procedures to cope with node failures. For this, the recovery procedures must ensure that the external behavior of the system is unaffected by the failures, that is, that the external behavior of the failure prone system is same as that of a failure free system. Achieving this goal is complicated by the fact that a node failure causes a process to lose the contents of its volatile store and hence its state.In this paper, we give a precise definition of the recovery problem using the I/O automaton model and present several algorithms to solve this problem. The outline of a formal proof of one of the algorithms is included. Like many of the standard recovery procedures in the literature, we use the following two techniques: whenever a node\u00a0\u2026", "num_citations": "274\n", "authors": ["1584"]}
{"title": "Safety, liveness and fairness in temporal logic\n", "abstract": " In this paper we present syntactic characterization of temporal formulas that express various properties of interest in the verification of concurrent programs. Such a characterization helps us in choosing the right techniques for proving correctness with respect to these properties. The properties that we consider include safety properties, liveness properties and fairness properties. We also present algorithms for checking if a given temporal formula expresses any of these properties.", "num_citations": "271\n", "authors": ["1584"]}
{"title": "Quantitative temporal reasoning\n", "abstract": " A substantially large class of programs operate in distributed and real-time environments, and an integral part of their correctness specification requires the expression of time-critical properties that relate the occurrence of events of the system. We focus on the formal specification and reasoning about the correctness of such programs. We popose a system of temporal logic, RTCTL (Real-Time Computation Tree Logic), that allows the melding of qualitative temporal assertions together with real-time constraints to permit specification and reasoning at the twin levels of abstraction: qualitative and quantitative. We show that several practically useful correctness properties of temporal systems, which need to express timing as an essential part of their functionality requirements, can be expressed in RTCTL. We also develop a model-checking algorithm for RTCTL whose complexity is linear in the size of the RTCTL\u00a0\u2026", "num_citations": "269\n", "authors": ["1584"]}
{"title": "Querying the uncertain position of moving objects\n", "abstract": " In this paper we propose a data model for representing moving objects with uncertain positions in database systems. It is called the Moving Objects Spatio-Temporal (MOST) data model. We also propose Future Temporal Logic (FTL) as the query language for the MOST model, and devise an algorithm for processing FTL queries in MOST.", "num_citations": "243\n", "authors": ["1584"]}
{"title": "Quantitative temporal reasoning\n", "abstract": " A substantially large class of programs operate in distributed and real-time environments, and an integral part of their correctness specification requires the expression of time-critical properties that relate the occurrence of events of the system. We focus on the formal specification and reasoning about the correctness of such programs. We propose a system of temporal logic, RTCTL (Real-Time Computation Tree Logic), that allows the melding of qualitative temporal assertions together with real-time constraints to permit specification and reasoning at the twin levels of abstraction: qualitative and quantitative. We argue that many practically useful correctness properties of temporal systems, which need to express timing as an essential part of their functionality requirements, can be expressed in RTCTL. We develop a model-checking algorithm for RTCTL whose complexity is linear in the size of the RTCTL\u00a0\u2026", "num_citations": "181\n", "authors": ["1584"]}
{"title": "On model checking for the \u03bc-calculus and its fragments\n", "abstract": " In this paper, we consider the model checking problem for the \u03bc-calculus and show that it is succinctly equivalent to the non-emptiness problem of finite-state automata on infinite binary trees with the parity acceptance condition. We also present efficient model checking algorithms for two rich subclasses of the \u03bc-calculus formulas and relate their expressive power to well-known extensions of branching time temporal logics.", "num_citations": "138\n", "authors": ["1584"]}
{"title": "Temporal triggers in active databases\n", "abstract": " In this paper we propose two languages, called Future Temporal Logic (FTL) and Past Temporal Logic (PTL), for specifying temporal triggers. Some examples of trigger conditions that can be specified in our language are the following: \"The value of a certain attribute increases by more than 10% in 10 minutes,\" \"A tuple that satisfies a certain predicate is added to the database at least 10 minutes before another tuple, satisfying a different condition, is added to the database.\" Such triggers are important for monitor and control applications. In addition to the languages, we present algorithms for processing the trigger conditions specified in these languages, namely, procedures for determining when the trigger conditions are satisfied. These methods can be added as a \"temporal\" component to an existing database management systems. A preliminary prototype of the temporal component that uses the FTL language\u00a0\u2026", "num_citations": "124\n", "authors": ["1584"]}
{"title": "Utilizing symmetry when model-checking under fairness assumptions: an automata-theoretic approach\n", "abstract": " One useful technique for combating the state explosion problem is to exploit symmetry when performing temporal logic model checking. In previous work it is shown how, using some basic notions of group theory, symmetry may be exploited for the full range of correctness properties expressible in the very expressive temporal logic CTL*. Surprisingly, while fairness properties are readily expressible in CTL*, these methods are not powerful enough to admit any amelioration of state explosion, when fairness assumptions are involved. We show that it is nonetheless possible to handle fairness efficiently by trading some group theory for automata theory. Our automata-theoretic approach depends on detecting fair paths subtly encoded in a quotient  structure whose arcs are annotated with permutations, by using a threaded structure that reflects coordinate shifts caused by the permutations.", "num_citations": "123\n", "authors": ["1584"]}
{"title": "SMC: a symmetry-based model checker for verification of safety and liveness properties\n", "abstract": " The article presents the SMC system. SMC can be used for checking safety and liveness properties of concurrent programs under different fairness assumptions. It is based on explicit state enumeration. It combats the state explosion by exploiting symmetries of the input concurrent program, usually present in the form of identical processes, in two different ways. Firstly, it reduces the number of explored states by identifying those states that are equivalent under the symmetries of the system; this is called process symmetry. Secondly, it reduces the number of edges explored from each state, in0  the  reduced state graph, by exploiting the symmetry of a single state; this is called state symmetry. SMC works in an on-the-fly manner;  it constructs the reduced state graph as and when it is needed. This method facilitates early termination, speeds up model checking, and reduces memory requirements. We employed SMC to\u00a0\u2026", "num_citations": "119\n", "authors": ["1584"]}
{"title": "Temporal conditions and integrity constraints in active database systems\n", "abstract": " In this paper, we present a unified formalism, based on Past Temporal Logic, for specifying conditions and events in the rules for active database system. This language permits specification of many time varying properties of database systems. It also permits specification of temporal aggregates. We present an efficient incremental algorithm for detecting conditions specified in this language. The given algorithm, for a subclass of the logic, was implemented on top of Sybase.", "num_citations": "112\n", "authors": ["1584"]}
{"title": "Reasoning About Spatial Relationships in Picture Retrieval Systems.\n", "abstract": " In this paper, we consider various spatial relationships that are of general interest in pictorial database systems. We present a set of rules that allow us to deduce new relationships from a given set of relationships. A deductive mechanism using these rules can be used in query processing systems that retrieve pictures by content. The given set of rules are shown to be sound, ie the deductions are logically correct. The rules are also shown to be complete for three dimensional systems, ie every relationship which is implied by a given consistent set of relationships F is deducible from F using the given rules. In addition, we show that the given set of rules is incomplete for two dimensional systems.", "num_citations": "112\n", "authors": ["1584"]}
{"title": "Theoretical issues in the design and verification of distributed systems\n", "abstract": " With the rapid decrease in the cost of hardware distributed computing is finding wider application. The parallelism inherent in distributed processing makes it much more difficult to design reliable systems. Many software development techniques such as hierarchical design and exaustive testing used for large sequential programs are no longer adequate because of the high degree of nondeterminism present in parallelism. This thesis addresses the two aspects of correctness and performance in the design of distributed and concurrent systems.", "num_citations": "108\n", "authors": ["1584"]}
{"title": "Databases for tracking mobile units in real time\n", "abstract": " In this paper we consider databases representing information about moving objects (e.g. vehicles), particularly their location. We address the problems of updating and querying such databases. Specifically, the update problem is to determine when the location of a moving object in the database (namely its database location) should be updated. We answer this question by proposing an information cost model that captures uncertainty, deviation, and communication. Then we analyze dead-reckoning policies, namely policies that update the database location whenever the distance between the actual location and the database location exceeds a given threshold, x. Dead-reckoning is the prevalent approach in military applications, and our cost model enables us to determine the threshold x. Then we consider the problem of processing range queries in the database, and we propose a probabilistic algorithm\u00a0\u2026", "num_citations": "100\n", "authors": ["1584"]}
{"title": "Stop word and related problems in web interface integration\n", "abstract": " The goal of recent research projects on integrating Web databases has been to enable uniform access to the large amount of data behind query interfaces. Among the tasks addressed are: source discovery, query interface extraction, schema matching, etc. There are also a number of tasks that are commonly ignored or assumed to be apriori solved either manually or by some oracle. These tasks include (1) finding the set of stop words and (2) handling occurrences of \"semantic enrichment words\" within labels. These two subproblems have a direct impact on determining the synonymy and hyponymy relationships between labels. In (1), a word like \"from\" is a stop word in general but it is a content word in domains such as Airline and Real Estate. We formulate the stop word problem, prove its complexity and provide an approximation algorithm. In (2), we study the impact of words like AND and OR on establishing\u00a0\u2026", "num_citations": "89\n", "authors": ["1584"]}
{"title": "Preventing information leaks through shadow executions\n", "abstract": " A concern about personal information confidentiality typically arises when any desktop application communicates to the external network, for example, to its producer's server for obtaining software version updates. We address this confidentiality concern of end users by an approach called shadow execution. A key property of shadow execution is that it allows applications to successfully communicate over the network while disallowing any information leaks. We describe the design and implementation of this approach for Windows applications. Experiments with our prototype implementation indicate that shadow execution allows applications to execute without inhibiting any behaviors, has acceptable performance overheads while preventing any information leaks.", "num_citations": "85\n", "authors": ["1584"]}
{"title": "Minimization of communication cost through caching in mobile environments\n", "abstract": " Users of mobile computers will soon have online access to a large number of databases via wireless networks. Because of limited bandwidth, wireless communication is more expensive than wire communication. In this paper, we present and analyze various static and dynamic data allocation methods. The objective is to optimize the communication cost between a mobile computer and the stationary computer that stores the online database. Analysis is performed in two cost models. One is connection (or time) based, as in cellular telephones, where the user is charged per minute of connection. The other is message based, as in packet radio networks, where the user is charged per message. Our analysis addresses both the average case and the worst case for determining the best allocation method.", "num_citations": "81\n", "authors": ["1584"]}
{"title": "A multiprocess network logic with temporal and spatial modalities\n", "abstract": " A modal logic which can be used to formally reason about synchronous fixed connection multiprocess networks such as of VLSI is introduced. The logic has both temporal and spatial modal operators. The various temporal modal operators can be used to relate the properties of the current state of a given process with properties of succeeding states of the same process. The spatial modal operators are useful to relate the properties of the current state of a given process with properties of the current state of neighboring processes. Many interesting properties of multiprocessor networks can be elegantly expressed in our logic. Examples of the diverse applications of the logic to packet routing, firing squad problems, systolic algorithms, and distributed system are given. Also some results in the decidability and complexity issues of this logic are presented.", "num_citations": "77\n", "authors": ["1584"]}
{"title": "On characterization of safety and liveness properties in temporal logic\n", "abstract": " Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission.", "num_citations": "62\n", "authors": ["1584"]}
{"title": "On-the-fly model checking under fairness that exploits symmetry\n", "abstract": " An on-the-fly algorithm, for model checking under fairness, is presented. The algorithm utilizes symmetry in the program to reduce the state space, and employs new novel techniques that make the on-the-fly modelchecking feasible. The algorithm uses state symmetry and eliminates paralle edges in the reachability graph. Experimental results, demonstrating dramatic reductions in both the running time and memory usage, are presented.", "num_citations": "59\n", "authors": ["1584"]}
{"title": "Utilizing symmetry when model checking under fairness assumptions: An automata-theoretic approach\n", "abstract": " One useful technique for combating the state explosion problem is to exploit symmetry [ID93, CFJ93, ES93] when performing temporal logic model checking [CE81, CES86]. In [CFJ93] [ES93] it is shown how, using some basic notions of group theory, symmetry may be exploited for the full range of correctness properties expressible in the very expressive temporal logic CTL*. Surprisingly, while fairness properties are readily expressible in CTL*, these methods are not powerful enough to admit any amelioration of state explosion, when fairness assumptions are involved. We show that it is nonetheless possible to handle fairness efficiently by trading some group theory for automata theory. Our automata-theoretic approach [VW86] depends on detecting fair paths subtly encoded in a permutation annotated quotient structure, using a threaded structure to \u201cphysically\u201d reflect coordinate permutations.", "num_citations": "52\n", "authors": ["1584"]}
{"title": "Similarity based retrieval of pictures using indices on spatial relationships\n", "abstract": " The paper presents (i) two similarity based methods for retrieval of pictures using indices on spatial relationships;(ii) efficient al-gorithms for the deduction and reduction of spatial relationships, which are used for computation of similarity values;(iii) identification of a desirable property for spatial similarity functions and the construction of such a function.", "num_citations": "51\n", "authors": ["1584"]}
{"title": "An economic model for resource exchange in mobile peer to peer networks\n", "abstract": " Consider an urban area with hundreds of thousands of vehicles. Drivers and passengers in these vehicles are interested in information relevant to their trip. For example, a driver would like his/her vehicle to continuously display on a map the available parking spaces around the current location. Or, the driver may be interested in the traffic conditions (e.g. average speed) one mile ahead. In this paper we examine the dissemination of information about resources in mobile peer-to-peer networks, where vehicles and sensors communicate with each other via short-range wireless transmission. Each disseminated resource represents information about a spatial-temporal event, such as the availability of a parking slot at a particular time. We propose an opportunistic dissemination paradigm, in which a moving object transmits the resources it carries to encountered vehicles and obtains new resources in exchange. We\u00a0\u2026", "num_citations": "50\n", "authors": ["1584"]}
{"title": "On-the-fly model checking under fairness that exploits symmetry\n", "abstract": " An on-the-fly algorithm for model checking under fairness is presented. The algorithm utilizes symmetry in the program to reduce the state space, and employs novel techniques that make the on-the-fly model checking feasible. The algorithm uses state symmetry and eliminates parallel edges in the reachability graph. Experimental results demonstrating dramatic reductions in both the running time and memory usage are presented.", "num_citations": "44\n", "authors": ["1584"]}
{"title": "Theoretical analysis of a directional stability-based clustering algorithm for VANETs\n", "abstract": " Clustering has the potential to reduce redundant messaging in MANETs and provide an efficient hierarchical network structure. However, it takes time to form and maintain a cluster structure which also requires additional control overhead. In this paper, we aim to analyze a distributed DIrectional Stability-based Clustering Algorithm (DISCA) designed for VANETs, which takes direction, mobility features, and leadership duration into consideration. We provide insights on the theoretical analysis of DISCA and show that the overhead incurred by DISCA is bound by a constant per node per time step, avoiding expensive reclustering chain reactions.", "num_citations": "43\n", "authors": ["1584"]}
{"title": "Opportunistic data dissemination in mobile peer-to-peer networks\n", "abstract": " In this paper we examine the dissemination of availability reports about resources in mobile peer-to-peer networks, where moving objects communicate with each other via short-range wireless transmission. Each disseminated report represents an observed spatial-temporal event, and the relevance of the report to a moving object decays as the age of the reported resource and the distance from its location increase. We propose an opportunistic approach, in which an object propagates the reports it carries (namely the information that it has about these resources) to encountered objects and obtains new reports in exchange. Least relevant reports are discarded after each exchange so as to limit the communication data volume of future exchanges. Our theoretical and experimental analysis indicates that the opportunistic dissemination algorithm automatically limits the global distribution of a report to a\u00a0\u2026", "num_citations": "43\n", "authors": ["1584"]}
{"title": "Monitorability of stochastic dynamical systems\n", "abstract": " Monitoring is an important run time correctness checking mechanism. This paper introduces the notions of monitorability and strong monitorability for partially observable stochastic systems, and gives necessary and sufficient conditions characterizing them. It also presents important decidability and complexity results for checking these properties for finite state systems. Furthermore, it presents general monitoring techniques for the case when systems are modeled as quantized probabilistic hybrid automata, and the properties are specified as safety or liveness automata. Experimental results showing the effectiveness of the methods are given.", "num_citations": "36\n", "authors": ["1584"]}
{"title": "Similarity based retrieval of videos\n", "abstract": " The authors propose a language, called Hierarchical Temporal Logic (HTL), for specifying queries on video databases. The language is based on the hierarchical as well as temporal nature of video data. They give similarity based semantics for the logic, and give efficient methods for computing similarity values for subclasses of HTL formulas. Experimental results, indicating the effectiveness of the methods, are presented.", "num_citations": "36\n", "authors": ["1584"]}
{"title": "Automatically preparing safe SQL queries\n", "abstract": " We present the first sound program source transformation approach for automatically transforming the code of a legacy web application to employ PREPARE statements in place of unsafe SQL queries. Our approach therefore opens the way for eradicating the SQL injection threat vector from legacy web applications.", "num_citations": "35\n", "authors": ["1584"]}
{"title": "Reasoning about qualitative spatial relationships\n", "abstract": " In this paper, we consider various spatial relationships that are of general interest in pictorial database systems and other applications. We present a set of rules that allow us to deduce new relationships from a given set of relationships. A deductive mechanism using these rules can be used in query-processing systems that retrieve pictures by content. The given set of rules is shown to be sound; that is, the deductions are logically correct. The rules are also shown to be complete for three-dimensional systems; that is, every relationship that is implied by a given consistent set of relationships F is deducible from F using the given rules. In addition, we show that the given set of rules is incomplete for two-dimensional systems. We also present efficient algorithms for the deduction and reduction problems. The deduction problem consists of computing all the relationships deducible from a given set, while the\u00a0\u2026", "num_citations": "33\n", "authors": ["1584"]}
{"title": "Parametrized verification of linear networks using automata as invariants\n", "abstract": " In this paper we proposed a formalism based on automata on two dimensional strings for specifying inductive invariants for proving correctness of families of linear and circular networks. We proved our inductive approach to be sound and complete (semantical completeness). We have illustrated our approach by simple examples.             We have also given the inductive approach for verification of parametrized systems under fairness. In this case, we use generalized Buchi automata (or Streett automata) as inductive invariants. For this case, we have proved the soundness theorem.             As part of future work, it will be interesting to automate the different parts of the induction based approach and apply them to real practical examples. It will also be interesting to extend our approach to networks defined by context free grammars [SG89]. Further more, it will also be interesting to investigate logic based\u00a0\u2026", "num_citations": "33\n", "authors": ["1584"]}
{"title": "Using temporal logic for automatic verification of finite state systems\n", "abstract": " Temporal logic has been extensively investigated for proving properties of programs-particularly for programs that involve nondeterminism or concurrency ([9], [11], [12]). However, most of the verification techniques developed so far involve manual construction of proofs, a task that may require a good deal of ingenuity and is usually quite tedious. In a series of papers ([1], [5], [6], [10]) we have argued that proof construction is unnecessary in the case of finite state systems and can be replaced by a model theoretic approach which will mechanically determine if the system meets a specification expressed in a propositional temporal logic. In this paper we survey that work and give a detailed example of how our approach might be used in verifying a finite state hardware controller.", "num_citations": "33\n", "authors": ["1584"]}
{"title": "Runtime monitoring of stochastic cyber-physical systems with hybrid state\n", "abstract": " Correct functioning of cyber-physical systems is of critical importance. This is more so in the case of safety critical systems such as in medical, automotive and many other applications. Since verification of correctness, in general, is infeasible and testing is not exhaustive, it is of critical importance to monitor such system during their operation and detect erroneous behaviors to be acted on. A distinguishing property of cyber-physical systems is that they are described by a mixture of integer-valued and real-valued variables. As a result, approaches that assume countable number of states are not applicable for runtime monitoring of such systems. This paper proposes a formalism, called Extended Hidden Markov systems, for specifying behavior of systems with such hybrid state. Using measure theory, it exactly characterizes when such systems are monitorable with respect to a given property. It also presents\u00a0\u2026", "num_citations": "32\n", "authors": ["1584"]}
{"title": "Reasoning in a restricted temporal logic\n", "abstract": " We consider RTL, a linear time propositional temporal logic whose only modalities are the [formula] (eventually) operator and its dual [formula] (always). Although less expressive than the full temporal logic, RTL is the fragment of temporal logic that is used most often and in many verification systems. Indeed, many properties of distributed systems discussed in the literature are RTL properties. Another advantage of RTL over the full temporal logic is in the decidability procedure; while deciding satisfiability of a formula in full temporal logic is a PSPACE complete procedure, doing so for an RTL formula is in NP. We characterize the class of \u03c9-regular languages that are definable in RTL and show simple translations between \u03c9-regular sets and RTL formulae that define them. We explore the applications of RTL in reasoning about communication systems. Finally, we relate variants of RTL (when interpreted over a real\u00a0\u2026", "num_citations": "30\n", "authors": ["1584"]}
{"title": "Distributed algorithms for ensuring fair interprocess communicatons\n", "abstract": " Message passing is one of the primary methods of information exchange between communicating processes. Many programming languages (eg, CSP, ADA) provide interprocess communication through a rendezvous in which a sender (receiver) process waits until the receiver (sender) is ready to receive (send) a message; thus there is no buffering of messages. Many of these languages also allow non-deterministic constructs by which a process may wait to communication with any of a set of other processes. In this paper we consider the problem of ensuring different fairness properties in such a system of processes. In a natural model we prove a simple lower bound on the time complexity to ensure weak fairness and present near optimal algorithms in special cases. We also give new efficient algorithms to ensure strong fairness.", "num_citations": "29\n", "authors": ["1584"]}
{"title": "On verifying that a concurrent program satisfies a nondeterministic specification\n", "abstract": " The problem of proving that a concurrent program satisfies a specification given by an infinite-state nondeterministic \u03c9-automation is considered. This problem is shown to be \u03a012-complete when the program and the correctness specification are effectively presented. As a consequence, no current proof system is complete for this problem. It also seems unlikely that a complete practical proof system can be developed for this problem.", "num_citations": "28\n", "authors": ["1584"]}
{"title": "Computer Aided Verification: 12th International Conference, CAV 2000 Chicago, IL, USA, July 15-19, 2000 Proceedings\n", "abstract": " This volume contains the proceedings of the 12th International Conference on Computer Aided Veri? cation (CAV 2000) held in Chicago, Illinois, USA during 15-19 July 2000. The CAV conferences are devoted to the advancement of the theory and practice of formal methods for hardware and software veri? cation. The con-rence covers the spectrum from theoretical foundations to concrete applications, with an emphasis on veri? cation algorithms, methods, and tools together with techniques for their implementation. The conference has traditionally drawn contributions from both researchers and practitioners in academia and industry. This year 91 regular research papers were submitted out of which 35 were-cepted, while 14 brief tool papers were submitted, out of which 9 were accepted for presentation. CAV included two invited talks and a panel discussion. CAV also included a tutorial day with two invited tutorials. Many industrial companies have shown a serious interest in CAV, ranging from using the presented technologies in their business to developing and m-keting their own formal veri? cation tools. We are very proud of the support we receive from industry. CAV 2000 was sponsored by a number of generous andforward-lookingcompaniesandorganizationsincluding: CadenceDesign-stems, IBM Research, Intel, Lucent Technologies, Mentor Graphics, the Minerva Center for Veri? cation of Reactive Systems, Siemens, and Synopsys. TheCAVconferencewasfoundedbyitsSteeringCommittee: EdmundClarke (CMU), Bob Kurshan (Bell Labs), Amir Pnueli (Weizmann), and Joseph Sifakis (Verimag).", "num_citations": "26\n", "authors": ["1584"]}
{"title": "The complexity of propositional temporal logic\n", "abstract": " CiNii \u8ad6\u6587 - The Complexity of Propositional Temporal Logic CiNii \u56fd\u7acb\u60c5\u5831\u5b66\u7814\u7a76\u6240 \u5b66\u8853\u60c5\u5831 \u30ca\u30d3\u30b2\u30fc\u30bf[\u30b5\u30a4\u30cb\u30a3] \u65e5\u672c\u306e\u8ad6\u6587\u3092\u3055\u304c\u3059 \u5927\u5b66\u56f3\u66f8\u9928\u306e\u672c\u3092\u3055\u304c\u3059 \u65e5\u672c\u306e\u535a\u58eb\u8ad6\u6587\u3092\u3055\u304c\u3059 \u65b0\u898f \u767b\u9332 \u30ed\u30b0\u30a4\u30f3 English \u691c\u7d22 \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u3059\u3079\u3066 \u672c\u6587\u3042\u308a \u9589\u3058\u308b \u30bf\u30a4\u30c8\u30eb \u8457\u8005\u540d \u8457\u8005ID \u8457\u8005\u6240\u5c5e \u520a\u884c\u7269\u540d ISSN \u5dfb\u53f7\u30da\u30fc\u30b8 \u51fa\u7248\u8005 \u53c2\u8003\u6587\u732e \u51fa\u7248\u5e74 \u5e74\u304b\u3089 \u5e74\u307e\u3067 \u691c\u7d22 \u691c\u7d22 \u691c\u7d22 The Complexity of Propositional Temporal Logic SISTLA AP \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6 \u8457\u8005 SISTLA AP \u53ce\u9332\u520a\u884c\u7269 J. ACM J. ACM 32(3), 733-749, 1985 \u88ab\u5f15\u7528\u6587\u732e: 1\u4ef6\u4e2d 1-1\u4ef6\u3092 \u8868\u793a 1 \u5f62\u5f0f\u7684\u8a2d\u8a08\u691c\u8a3c\u306e\u305f\u3081\u306e \u5206\u5c90\u6642\u9593\u6b63\u5247\u6642\u76f8\u8ad6\u7406 \u6ff1\u53e3 \u6e05\u6cbb , \u5e73\u77f3 \u88d5\u5b9f , \u77e2\u5cf6 \u8129\u4e09 \u60c5\u5831\u51e6\u7406\u5b66\u4f1a\u8ad6\u6587\u8a8c 33(4), 405-414, 1992-04-15 \u53c2\u8003\u6587\u732e17\u4ef6 \u88ab\u5f15\u7528\u6587\u732e1\u4ef6 Tweet \u5404\u7a2e\u30b3\u30fc\u30c9 NII\u8ad6\u6587ID(NAID) 80002534448 \u8cc7\u6599\u7a2e\u5225 \u96d1\u8a8c\u8ad6\u6587 \u30c7\u30fc\u30bf\u63d0\u4f9b\u5143 CJP\u5f15\u7528 \u66f8\u304d\u51fa\u3057 RefWorks\u306b\u66f8\u304d\u51fa\u3057 EndNote\u306b\u66f8\u304d\u51fa\u3057 Mendeley\u306b\u66f8\u304d\u51fa\u3057 Refer/BiblX\u3067\u8868\u793a RIS\u3067\u8868\u793a BibTeX\u3067\u8868\u793a TSV\u3067\u8868\u793a \u554f\u984c\u306e\u6307\u6458 \u30da\u30fc\u30b8\u2026", "num_citations": "25\n", "authors": ["1584"]}
{"title": "Monitoring the Full Range of \u03c9-Regular Properties of Stochastic Systems\n", "abstract": " We present highly accurate deterministic, probabilistic and hybrid methods for monitoring the full range of \u03c9-regular properties, specified as Streett automata, of stochastic systems modeled as Hidden Markov Chains. The deterministic algorithms employ timeouts that are set dynamically to achieve desired accuracy. The probabilistic algorithms employ coin tossing and can give highly accurate monitors when the system behavior is not known. The hybrid algorithms combine both these techniques. The monitoring algorithms have been implemented as a tool. The tool takes a high level description of an application with probabilities and also a Streett automaton that specifies the property to be monitored. It generates a monitor for monitoring computations of the application. Experimental results comparing the effectiveness of the different algorithms are presented.", "num_citations": "24\n", "authors": ["1584"]}
{"title": "Monitoring temporal properties of stochastic systems\n", "abstract": " We present highly accurate deterministic and randomized methods for monitoring temporal properties of stochastic systems. The deterministic algorithms employ timeouts that are set dynamically to achieve desired accuracy. The randomized algorithms employ coin tossing and can give highly accurate monitors when the system behavior is not known.", "num_citations": "24\n", "authors": ["1584"]}
{"title": "Analysis of dynamic policies\n", "abstract": " The paper considers the problem of modeling and analyzing dynamic policies in Trust Management Systems. It presents a general frame work and a specification language FCTL for specifying properties in such systems. Various important security properties such as simple safety, liveness, role containment can all be elegantly specified in this logic. It presents upper and lower bounds for checking classes of formulas specified in this logic for dynamic systems specified in the RT0 Role based Trust Management System.", "num_citations": "22\n", "authors": ["1584"]}
{"title": "Modeling and verification of a real life protocol using symbolic model checking\n", "abstract": " As the computing systems have grown in size and complexity it has become necessary to develop automated methods for checking the correctness of such systems. Temporal logic modelchecking [2] is one of such automated methods for verifying properties of finite state systems. The practical applicability of the original modelchecking system was limited due to the state explosion problem. Recently many techniques have been developed to overcome the state explosion problem. One of the methods that has been finding much application is symbolic modelchecking [1, 8, 3, 6]. The symbolic modelchecking approach, implemented as the SMV system, uses BDDs for symbolically representing sets of states and the transition relation. This approach allowed the possibility of handling systems with extremely large state spaces.In this paper, we show how symbolic modelchecking has been used to verify a real life\u00a0\u2026", "num_citations": "22\n", "authors": ["1584"]}
{"title": "SMC: A symmetry based model checker for verification of liveness properties\n", "abstract": " In this paper, we describe SMC (Symmetry based Model checker) for verification of liveness properties. This system is based on the symmetry based state space reduction techniques presented in [ES93, ES95]. The input to the system consists of a concurrent program given as a set of processes specified as transition systems. It also takes as input a Buchi automaton on infinite strings that accepts all the incorrect computations, ie, the automaton accepts the complement of the correctness property. The system checks if there exists a fair computation of the program that is accepted by the automaton, ie, if there exists an incorrect computation. If such a computation exists it outputs a\" YES\" answer, otherwise it terminates with a\" NO\" answer indicating that the program satisfies the correctness property.The model checker explores the global state space to check for the existence of incorrect computations. It exploits\u00a0\u2026", "num_citations": "21\n", "authors": ["1584"]}
{"title": "Employing symmetry reductions in model checking\n", "abstract": " This paper presents a survey of research work that has been done over the last decade on exploiting symmetry in model checking of concurrent systems. It describes the techniques based on Quotient Structures, Annotated Quotient Structures and Guarded Quotient Structures. It also briefly describes some of the implemented systems.", "num_citations": "18\n", "authors": ["1584"]}
{"title": "Proving correctness with respect to nondeterministic safety specifications\n", "abstract": " Recently there has been much interest in using automata for specifying the behavior of concurrent and distributed systems at different levels of abstraction. When systems are thus specified, it is often necessary to show that a lower level specification implements a higher level specification. Here a specification given by an automaton L is said to implement a specification given by an automaton H if all the sequences of external actions that L permits are also permitted by I!?. Many different apprr---&es have been proposed [1, 2, 4-6, 9-111 for proving that a specification L implements another specification H. All these approaches use one of the following techniques to prove safety properties-simulation relations [S], possibility mappings [9, lS] and refinement mappings [l]. Such mappings and relations together with well-founded induction are used to prove liveness properties.", "num_citations": "18\n", "authors": ["1584"]}
{"title": "Deciding branching time logic: A triple exponential decision procedure for CTL\n", "abstract": " In this paper we study the full branching time logic CTL* defined in [EH83]. It subsumes a number of logics described in the literature including the systems of [LAS0],[GPSS80],[BMP81],[EH82], ICES83], as well as the Computation Tree Logic of [CE81]. In CTL* we allow a path quantifier, either A (mfor all paths=} or E (mfor some pathsm}, to prefix an assertion composed of arbitrary combinations of the usual linear time operators G (lalwaysU}, F {Jsometime~), X {= nexttime~}, and U (until=). In particular, we consider the problem of deciding if a given CTL* formula f0 is satisfiable in a structure generated by a binary relation (cf.[EM81]}. For some time no such decision procedure for CTL* of elementary complexity was known (cf.[EH83]) although recently several other researchers ([PS83],[VW83],[Wo82]) have announced four or five exponential decision procedures. We show that CTL* is decidable in triple exponential time.", "num_citations": "17\n", "authors": ["1584"]}
{"title": "Language based policy analysis in a SPKI Trust Management System\n", "abstract": " SPKI/SDSI is a standard for issuing authorization and name certificates. SPKI/SDSI can be used to implement a Trust Management System, where the policy for resource access is distributively specified by multiple trusted entities. Agents in the system need a formal mechanism for understanding the current state of policy. We present a first order temporal logic, called FTPL for specifying properties of a given SPKI/SDSI policy state. We also present algorithms to check if a SPKI/SDSI policy state satisfies a property specified in FTPL.", "num_citations": "16\n", "authors": ["1584"]}
{"title": "CMV: Automatic verification of complete mediation for Java Virtual Machines\n", "abstract": " Runtime monitoring systems play an important role in system security, and verification efforts that ensure that these systems satisfy certain desirable security properties are growing in importance. One such security property is complete mediation, which requires that sensitive operations are performed by a piece of code only after the monitoring system authorizes these actions. In this paper, we describe a verification technique that is designed to check for the satisfaction of this property directly on code from Java standard libraries. We describe a tool CMV that implements this technique and automatically checks shrink-wrapped Java bytecode for the complete mediation property. Experimental results on running our tool over several thousands of lines of bytecode from the Java libraries suggest that our approach is scalable, and leads to a very significant reduction in human efforts required for system verification.", "num_citations": "15\n", "authors": ["1584"]}
{"title": "Applications of a transportation information architecture\n", "abstract": " Basic research in information management, software architecture, human factors, traffic prediction and transportation planning is necessary to manage the integration of millions of disparate computers and sensors, in a high mobility environment, into a collaborative system. This system then enable solutions to a set of transportation problems ranging from autonomous real-time routing and navigation, to autonomous driving, to inferring driving patterns via data mining. In this paper, this information architecture is discussed together with several innovative applications.", "num_citations": "15\n", "authors": ["1584"]}
{"title": "Automatic temporal verification of buffer systems\n", "abstract": " In this paper we have presented a formal model for processes that communicate through fifo message buffers and have given a sound automatic proof system for verifying RTL definable properties of such systems. The proof method is modular. Although our method is not complete, we feel, as illustrated by the example, that it can be applied to some practical examples. Theorem 3.1 holds for any fragment L of temporal logic as long as the formulae in L do not distinguish between two computations one of which is a stuttered extension of the other. In this case, we can use our approach for proving properties given by formulae in L as long as the theory of fifo buffers in the logic L is decidable.", "num_citations": "15\n", "authors": ["1584"]}
{"title": "Distinguishing hidden Markov chains\n", "abstract": " Hidden Markov Chains (HMCs) are commonly used mathematical models of probabilistic systems. They are employed in various fields such as speech recognition, signal processing, and biological sequence analysis. Motivated by applications in stochastic runtime verification, we consider the problem of distinguishing two given HMCs based on a single observation sequence that one of the HMCs generates. More precisely, given two HMCs and an observation sequence, a distinguishing algorithm is expected to identify the HMC that generates the observation sequence. Two HMCs are called distinguishable if for every \u03b5> 0 there is a distinguishing algorithm whose error probability is less than \u03b5. We show that one can decide in polynomial time whether two HMCs are distinguishable. Further, we present and analyze two distinguishing algorithms for distinguishable HMCs. The first algorithm makes a decision after\u00a0\u2026", "num_citations": "13\n", "authors": ["1584"]}
{"title": "Model Check What You Can, Runtime Verify the Rest.\n", "abstract": " Model checking and runtime verification are pillars of formal verification but for the most part are used independently. In this position paper we argue that the formal verification community would be well-served by developing theory, algorithms, implementations, and applications that combine model checking and runtime verification into a single, seamless technology. This technology would allow system developers to carefully choose the appropriate balance between offline verification of expressive properties (model checking) and online verification of important parts of the system\u2019s state space (runtime verification). We present several realistic examples where such technology appears necessary and a preliminary formalization of the idea.", "num_citations": "13\n", "authors": ["1584"]}
{"title": "Incremental verification of architecture specification language for real-time systems\n", "abstract": " The concept of software architecture has recently emerged as a new way to improve our ability to effectively construct large scale software systems. However, there is no formal architecture specification language available to model and analyze temporal properties of complex real-time systems. In this paper, an object-oriented logic-based architecture specification language for real-time systems is discussed. Representation of the temporal properties and timing constraints, and their integration with the language to model real-time concurrent systems is given. Architecture based specification languages enable the construction of large system architectures and provide a means of testing and validation. In general, checking the timing constraints of real-time systems is done by applying model checking to the constraint expressed as a formula in temporal logic. The complexity of such a formal method depends on the\u00a0\u2026", "num_citations": "13\n", "authors": ["1584"]}
{"title": "Continuous nearest-neighbor queries with location uncertainty\n", "abstract": " In this paper, we consider the problem of evaluating the continuous query of finding the  nearest objects with respect to a given point object  among a set of  moving point-objects. The query returns a sequence of answer-pairs, namely pairs of the form  such that  is a time interval and  is the set of objects that are closest to  during . When there is uncertainty associated with the locations of the moving objects,  is the set of all the objects that are possibly the  nearest neighbors. We analyze the lower bound and the upper bound on the maximum number of answer-pairs, for the certain case and the uncertain case, respectively. Then, we consider two different types of algorithms. The first is off-line algorithms that compute a priori all the answer-pairs. The second type is on-line algorithms that at any time return the current answer-pair. We present algorithms for the certain case and the uncertain\u00a0\u2026", "num_citations": "12\n", "authors": ["1584"]}
{"title": "Apparatus for enhancing web application security and method therefor\n", "abstract": " A system that incorporates teachings of the present disclosure may include, for example, constructing a symbolic representation from a portion of a web application that generates a plurality of structured query language (SQL) queries, parsing the symbolic representation into a plurality of trees, and adapting the web application with PREPARE statements according to the plurality of trees. Additional embodiments are disclosed.", "num_citations": "12\n", "authors": ["1584"]}
{"title": "Monitoring off-the-shelf components\n", "abstract": " Software is being developed from off-the-shelf third party components. The interface specification of such a component may be under specified or may not fully match the user requirement. In this paper, we address the problem of customizing such components to particular users. We achieve this by constructing a monitor that monitors the component and detects any bad behaviors.             Construction of such monitors essentially involves synthesizing safety properties that imply a given property that is obtained from the interface specifications of the component and the goal specification of the user. We present various methods for synthesizing such safety properties when the given property is given by an automaton or a temporal logic formula. We show that our methods are sound and complete. These results are extensions of the results given in [11].", "num_citations": "12\n", "authors": ["1584"]}
{"title": "Query processing in a video retrieval system\n", "abstract": " A.P. Sistla et al. (1997) designed a similarity-based video retrieval system. Queries were specified in a language called the Hierarchical Temporal Language (HTL). In this paper, we present several extensions of HTL. These extensions include queries that can have the negation operator and any other logical and temporal operators such as disjunction. Efficient algorithms for processing queries in the extended language are also presented.", "num_citations": "12\n", "authors": ["1584"]}
{"title": "Model checking parameterized systems\n", "abstract": " We consider the model-checking problem for a particular class of parameterized systems: systems that consist of arbitrary numbers of components. The task is to show correctness regardless of the number of components. The term parameterized refers to the fact that the size of the system is a parameter of the verification problem. Examples of parameterized systems include mutual exclusion algorithms, bus protocols, networking protocols, cache coherence protocols, web services, and sensor networks. In this chapter, we will give four examples of techniques that have been used (among many others) for the verification of parameterized systems.", "num_citations": "11\n", "authors": ["1584"]}
{"title": "Similarity based retrieval from sequence databases using automata as queries\n", "abstract": " Similarity based retrieval from sequence databases is of importance in many applications such as time-series, video and textual databases. In this paper, automata based formalisms are introduced for specifying queries over such databases. Various measures defining the distance of a database sequence from an automaton are defined. Efficient methods for similarity based retrieval are presented for each of the distance measures. These methods answer nearest neighbor queries (ie retrieval of k closest subsequences), or range queries (ie, retrieval of all sequences with in a given distance).", "num_citations": "11\n", "authors": ["1584"]}
{"title": "Towards a theory of cost management for digital libraries and electronic commerce\n", "abstract": " One of the features that distinguishes digital libraries from traditional databases is new cost models for client access to intellectual property. Clients will pay for accessing data items in digital libraries, and we believe that optimizing these costs will be as important as optimizing performance in traditional databases. In this article we discuss cost models and protocols for accessing digital libraries, with the objective of determining the minimum cost protocol for each model. We expect that in the future information appliances will come equipped with a cost optimizer, in the same way that computers today come with a built-in operating system. This article makes the initial steps towards a thery and practice of intellectual property cost management.", "num_citations": "11\n", "authors": ["1584"]}
{"title": "Qn the Eventuality Operator in Temporal Logic\n", "abstract": " We consider RTL, a linear time propositional temporal logic whose only modalities are the O (eventually) operator and its dual\u2014\u2014-El (always). Although less expressive than the full temporal logic, RTL is the fragment of temporal logic that is used most often and in many veri\ufb01cation systems. Indeed, most properties of distributed systems discussed in the literature are RTL properties. Another advantage of RTL over the full temporal logic is in the decidability procedure; while deciding satis\ufb01ability of a formula in full temporal logic is a PSPACE complete procedure, doing that for an RTL formula is in co-NP. We characterize the class of w-regular languages that are de\ufb01nable in RTL and show simple translations between w-regular sets and RTL formu~ lae that de\ufb01ne them. We explore the applications of RTL in reasoning about communication systems and the relationship between RTL and several fragments of Interval\u00a0\u2026", "num_citations": "11\n", "authors": ["1584"]}
{"title": "Swipe: eager erasure of sensitive data in large scale systems software\n", "abstract": " We describe SWIPE, an approach to reduce the life time of sensitive, memory resident data in large scale applications written in C. In contrast to prior approaches that used a delayed or lazy approach to the problem of erasing sensitive data, SWIPE uses a novel eager erasure approach that minimizes the risk of accidental sensitive data leakage. SWIPE achieves this by transforming a legacy C program to include additional instructions that erase sensitive data immediately after its intended use. SWIPE is guided by a highly-scalable static analysis technique that precisely identifies the locations to introduce erase instructions in the original program. The programs transformed using SWIPE enjoy several additional benefits: minimization of leaks that arise due to data dependencies; erasure of sensitive data with minimal developer guidance; and negligible performance overheads.", "num_citations": "10\n", "authors": ["1584"]}
{"title": "Taps: Automatically preparing safe sql queries\n", "abstract": " We present the first sound program transformation approach for automatically transforming the code of a legacy web application to employ PREPARE statements in place of unsafe SQL queries. Our approach therefore opens the way for eradicating the SQL injection threat vector from legacy web applications. This extended abstract is based on our paper [4] that appeared in the Financial Cryptography and Data Security (FC'2010) conference.", "num_citations": "10\n", "authors": ["1584"]}
{"title": "Temporal conditions with retroactive and proactive updates\n", "abstract": " In this paper, we extend the temporal rule language introduced in [1] to support pro- and retro- active updates. Such updates may cause the time when a condition is satisfied to differ from the time when it is detected. We enrich the rule language by providing a set of alternative actions in each rule; this allows execution of one of the alternative actions depending on the difference between condition-satisfaction time and detection time. We identify a subset of the temporal condition language PTL [1], called decomposable PTL, that is amenable to more efficient evaluation. We present an evaluation algorithm for decomposable PTL. We also describe the implementation of the system on top of the Sybase DBMS.", "num_citations": "10\n", "authors": ["1584"]}
{"title": "Retrieval of pictures using approximate matching\n", "abstract": " In this paper, we describe a general-purpose picture retrieval system based on approximate matching. This system accommodates pictorial databases for a broad class of applications. It consists of tools for handling the following aspects\u2014user interfaces, reasoning about spatial relationships, computing degrees of similarity between queries and pictures. We briefly describe the model that is used for representing pictures/queries, the user interface, the system for reasoning about spatial relationships, and the methods employed for computation of similarities of pictures with respect to queries.", "num_citations": "10\n", "authors": ["1584"]}
{"title": "Triggers on database histories\n", "abstract": " Modern systems, such as traffic control, securities trading and communication networks, are increasingly dependent on real-time software applications for monitor and control. At the center of such applications usually lies an active database, that represents the status of the system. This database is continuously updated by (often remote) sensors, and the software is expected to respond to predefined conditions. Often these conditions refer to the evolution of the database state over time (ie the database history). For example, in securities trading, the system may be requested to alert a trader when the value of a particular stock (given as a database attribute A) increases by more than 10% in 15 minutes. We call such conditions temporal triggers, ie triggers on the evolution of the database state over time. Furthermore, one may want to specify temporal triggers that also involve external events (such as transaction-begin, transaction-commit, invocation of an object method, etc.) in addition to the database history. The following temporal trigger is one such example\u2014the value of attribute A increases by more than 10% from the time when transaction X commits to the time when transaction Y starts. Existing database management systems, prototypes, and proposed languages, do not provide the capability for specifying temporal triggers. In most of them, the condition part of a rule (in Hipac 1] terminology a rule is an event-condition-action triple) refers to either the current database state, or to the transition from one database state to the next, but not to the complete database history.", "num_citations": "10\n", "authors": ["1584"]}
{"title": "Answer-pairs and processing of continuous nearest-neighbor queries\n", "abstract": " We consider the problem of evaluating the continuous query of finding the k nearest objects with respect to a given moving point-object O q among a set of n moving point-objects. The query returns a sequence of answer-pairs, namely pairs of the form (I, S) such that I is a time interval and S is the set of objects that are closest to O q during I. Existing work on this problem lacks complexity analysis due to limited understanding of the maximum number of answer-pairs. In this paper we analyze the lower bound and the upper bound on the maximum number of answer-pairs. Then we consider two different types of algorithms. The first is off-line algorithms that compute a priori all the answer-pairs. The second type is on-line algorithms that at any time return the current answer-pair. We present the algorithms and analyze their complexity using the maximum number of answer-pairs.", "num_citations": "9\n", "authors": ["1584"]}
{"title": "An architecture for consumer-oriented online database services\n", "abstract": " We introduce an architecture for online database services oriented towards consumers. We identify two types of costs-access cost and communication cost. We demonstrate that dynamic allocation of data can minimize these costs. We do so by presenting efficient algorithms based on dynamic allocation; these algorithms optimize access and communication costs for various cost models, access patterns, and retrieval protocols.", "num_citations": "9\n", "authors": ["1584"]}
{"title": "Can message buffers be characterized in linear temporal logic?\n", "abstract": " Exchange of information between executing processes is one of the primary reasons for process interaction. Many distributed systems implement explicit message passing primitives to facilitate intercommunication. Typically, a process executes a write command to pass a message to another process, and the target process accepts the message by executing a read command. The semantics of write and read may differ considerably depending on the methods used for storing or buffering messages that have been sent but not yet accepted by the receiving process.", "num_citations": "9\n", "authors": ["1584"]}
{"title": "Timely monitoring of partially observable stochastic systems\n", "abstract": " Ensuring the correct behavior of cyber physical systems at run time is of critical importance for their safe deployment. Any malfunctioning of such systems should be detected in a timely manner for further actions. This paper addresses the issue of how quickly a monitor raises an alarm after the occurrence of a failure in cyber physical systems. Towards this end, it introduces a class of systems called exponentially converging monitorable systems. The paper shows that failures in these systems can be detected fast by employing the traditional threshold monitors. It shows that the expected failure detection time for exponentially converging monitorable systems has logarithmic relationship with the inverse of the chosen threshold value. The paper identifies well defined natural classes of these systems. Experimental results are presented that confirm the theoretical results on the relationship between the failure detection\u00a0\u2026", "num_citations": "8\n", "authors": ["1584"]}
{"title": "The TranQuyl language for data management in intelligent transportation\n", "abstract": " Intelligent Transportation Systems envision a networked environment consisting of vehicles, the infrastructure, and hand-held devices (e.g., smart-phones). The environment will enable numerous safety, mobility, and environmental improvement applications. For example, drivers can be warned of dangers in their local environment or when risking to leave their lane. Furthermore, their visibility range can be expanded by providing highly up-to-date information from areas that are currently invisible. For another example, the road weather\u2014up-to-the-minute visibility, precipitation, and pavement condition information\u2014can be provided at high spatial resolution.Intelligent Transportation efforts are currently being undertaken throughout the world. In addition to the IntelliDrive initiative of the US Department of Transportation, similar efforts exist in Europe, Japan, and China. But these efforts are largely decoupled from, and\u00a0\u2026", "num_citations": "6\n", "authors": ["1584"]}
{"title": "Checking extended CTL properties using guarded quotient structures\n", "abstract": " We extend CTL logic to a logic called COUNT CTL (CCTL) for specifying properties of concurrent programs with large number of processes. We present a model checking algorithm for symmetric or partially symmetric systems when their correctness specification is given in CCTL. The model-checking algorithm employs Guarded Quotient Structures introduced by Sistla and Godefroid (Lecture Notes in Comput. Sci., vol.\u00a02102, 2001). The GQS structures can be succinct representations for the reachability graphs of partially symmetric or even asymmetric systems. Our algorithm exploits state symmetries for fast evaluation. The algorithm is top down in nature, and automatically incorporates formula decomposition and sub-formula tracking.", "num_citations": "5\n", "authors": ["1584"]}
{"title": "Model checking failure-prone open systems using probabilistic automata\n", "abstract": " We consider finite-state Hierarchical Probabilistic Automata (HPA) to model failure-prone open systems. In an HPA, its states are stratified into a fixed number of levels. A k-HPA is an HPA with  levels and it can be used to model open systems where up\u00a0to k failures can occur. In this paper, we present a new forward algorithm that checks universality of a 1-HPA. This algorithm runs much faster than an earlier backward algorithm. We present the implementation and experimental results for verifying abstracted failure-prone web applications. We also prove a theoretical result showing that the problem of checking emptiness and universality for 2-HPA is undecidable answering an open question.", "num_citations": "4\n", "authors": ["1584"]}
{"title": "Weblog: A declarative language for secure web development\n", "abstract": " WEBLOG is a declarative language for web application development designed to automatically eliminate several security vulnerabilities common to today's web applications. In this paper, we introduce Weblog, detail the security vulnerabilities it eliminates, and discuss how those vulnerabilities are eliminated. We then evaluate Weblog's ability to build and secure real-world applications by comparing traditional implementations of 3 existing small-to medium-size web applications to Weblog implementations.", "num_citations": "4\n", "authors": ["1584"]}
{"title": "Symmetry reductions in model-checking\n", "abstract": " Symmetries occur in different forms in concurrent programs. Such symmetries are induced by processes that behave similarly, and also by data items which are treated similarly by the processes. The talk will present three different methods, based on symmetry reductions, in containing the state explosion problem in model checking. The first method considers the symmetries in the program as well the formula. In this method we first construct a quotient structure, corresponding to the reachable part of the global state graph, and then check the satisfaction of the formula in the quotient structure using the traditional model checking algorithms. This method is primarily useful in checking safety properties. The second method considers only the symmetries in the program and is based on the construction of Annotated Quotient Structure (AQS). The AQS is like the quotient structure excepting that the edges carry\u00a0\u2026", "num_citations": "4\n", "authors": ["1584"]}
{"title": "Minimizing lifetime of sensitive data in concurrent programs\n", "abstract": " The prolonged lifetime of sensitive data (such as passwords) in applications gives rise to several security risks. A promising approach is to erase sensitive data in an\" eager fashion\", ie, as soon as its use is no longer required in the application. This approach of minimizing the lifetime of sensitive data has been applied to sequential programs. In this short paper, we present an extension of the this approach to concurrent programs where the interleaving of threads makes such eager erasures a challenging research problem.", "num_citations": "3\n", "authors": ["1584"]}
{"title": "Combining static analysis and model checking for systems employing commutative functions\n", "abstract": " The two main hindrances for a wider application of the model checking approach for verification of concurrent and distributed systems are the state explosion problem and its limitation in handling infinite state systems. We consider a class of infinite state systems given by certain types of Transition Diagrams (TDs), called simple TDs, that employ commutative functions for updating variables. For such systems, we presented model checking methods that combine bi-simulation reductions with static analysis. The new methods are extensions of earlier methods where static analysis was not employed. These methods can be applied to a wider class of systems.", "num_citations": "3\n", "authors": ["1584"]}
{"title": "Proceedings of the 12th International Conference on Computer Aided Verification\n", "abstract": " Proceedings of the 12th International Conference on Computer Aided Verification | Guide Proceedings ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleProceedingsCAV '00 Export Citation Select Citation format Download citation Copy citation Categories Journals Magazines Books Proceedings SIGs Conferences Collections People About About ACM Digital Library Subscription Information Author Guidelines Using ACM Digital Library All Holdings within the ACM Digital Library ACM Computing Classification System Join Join ACM Join SIGs Subscribe to Publications Institutions and Libraries Connect Contact Facebook Twitter Linkedin \u2026", "num_citations": "3\n", "authors": ["1584"]}
{"title": "Decision-theoretic monitoring of cyber-physical systems\n", "abstract": " Runtime monitoring has been proposed as an alternative to formal verification for safety critical systems. This paper introduces a decision-theoretic view of runtime monitoring. We formulate the monitoring problem as a Partially Observable Markov Decision Process (POMDP). Furthermore, we adopt a Partially Observable Monte-Carlo Planning (POMCP) to compute an approximate optimal policy of the monitoring POMDP. We show how to construct the POMCP for the monitoring problem and demonstrate experimentally that it can be effectively applied even when some of the state-space variables are continuous, the case where many other POMDP solvers fail. Experimental results on a mobile robot system show the effectiveness of the proposed POMDP-monitor.", "num_citations": "2\n", "authors": ["1584"]}
{"title": "Deics: Data erasure in concurrent software\n", "abstract": " A well known tenet for ensuring unauthorized leaks of sensitive data such as passwords and cryptographic keys is to erase (\u201czeroize\u201d) them after their intended use in any program. Prior work on minimizing sensitive data lifetimes has focused exclusively on sequential programs. In this work, we address the problem of data lifetime minimization for concurrent programs. We develop a new algorithm that precisely anticipates when to introduce these erasures, and develop an implementation of this algorithm in a tool called DEICS. Through an experimental evaluation, we show that DEICS is able to reduce lifetimes of shared sensitive data in several concurrent applications (over 100k lines of code combined) with minimal performance overheads.", "num_citations": "2\n", "authors": ["1584"]}
{"title": "Model checking of systems employing commutative functions\n", "abstract": " The paper presents methods for model checking a class of possibly infinite state concurrent programs using various types of bi-simulation reductions. The proposed methods work for the class of programs in which the functions that update the variables are mutually commutative. A number of bi-simulation relations are presented for such systems. Explicit state model checking methods that employ on-the-fly reductions with respect to these bi-simulations are given. Some of these methods have been implemented and have been used to verify some well known protocols that employ integer variables.", "num_citations": "2\n", "authors": ["1584"]}
{"title": "Research activities in database management and information retrieval at University of Illinois at Chicago\n", "abstract": " There are 6 active researchers in the areas of database management, data mining and information retrieval at the Department of Computer Science, University of Illinois at Chicago. In this article, the works of Isabel Cruz, Ashfaq Khokhar, Bing Liu, Prasad Sistla, Ouri Wolfson and Clement Yu are sketched.", "num_citations": "1\n", "authors": ["1584"]}
{"title": "Formal methods in concurrent and distributed systems\n", "abstract": " The project investigates methods for automated analysis and verification of concurrent programs. The project performed research in two different areas--(1) Model-checking based verification for systems with fixed number of processes,(2) Parameterized verification, ie verification of systems with an arbitrary number of processes. As part of work work on model-checking, the project developed symmetry based techniques for combating the state explosion problem. State explosion is the major bottleneck in applying model-checking to the real world examples; it occurs due to the exponential blow up in the size of the state space with the number of processes in the system. The project developed various techniques, based on exploiting the symmetry in the concurrent program, for reducing the size of the state space to be explored. Using these techniques, the project developed a model checking system called SMC.", "num_citations": "1\n", "authors": ["1584"]}
{"title": "An incremental verification algorithm for real-time systems\n", "abstract": " We present an incremental algorithm for model checking the real-time systems against the requirements specified in the real-time extension of modal mu-calculus. Using this algorithm, we avoid the repeated construction and analysis of the whole state-space during the course of evolution of the system from time to time. We use a finite representation of the system, like most other algorithms on real-time systems. We construct and update a graph (called TSG) that is derived from the region graph and the formula.  This allows us to halt the construction of this graph when enough nodes have been explored to determine the truth of the formula. TSG is minimal in the sense of partitioning the infinite state space into regions and it expresses a relation on the set of regions of the partition. We use the structure of the formula to derive this partition. When a change is applied to the timed automaton of the system, we find a new\u00a0\u2026", "num_citations": "1\n", "authors": ["1584"]}
{"title": "Domino: Databases for moving objects tracking\n", "abstract": " 1. BACKGROUNDConsider a database that represents information about moving objects and their location. For example, for a database representing the location of taxi-cabs a typical query may be: retrieve the free cabs that are currently within 1 mile of 33 N. Michigan Ave., Chicago (to pick-up a customer); or for a trucking company database a typical query may be: retrieve the trucks that are currently within 1 mile of truck ABT312 (which needs assistance); or for a database representing the current location of objects in a battlefield a typical query may be: retrieve the friendly helicopters that are in a given region, or, retrieve the friendly helicopters that are expected to enter the region within the next 10 minutes. The queries may originate from the moving objects, or from stationary users. We will refer to applications with the above characteristics as moving-objects-database (MOD) applications, and to queries as the\u00a0\u2026", "num_citations": "1\n", "authors": ["1584"]}
{"title": "Deciding Full Branching Time Logic\n", "abstract": " In this paper the full branching time logic (CTL*) is studied. It has basic modalities consisting of a path quantifier, either A (\" for all paths\") off (\" for some path\"), followed by an arbitrary linear time assertion composed of unrestricted combinations of the usual linear temporal operators F (\" sometime\"), G (\" always\"), X (\" nexttime\"), and U (\" until\"). It is shown that the problem of determining if a CTL* formula is satisfiable in a structure generated by a binary relation is decidable in triple exponential time. The decision procedure exploits the special structure of the finite state co-automata for linear temporal formulae which allows them to be determinized with only a single exponential blowup in size. Also the expressive power of tree automata is compared with that of CTL* augmented by quantified auxiliary propositions. f 1984 Academic Press, Inc.", "num_citations": "1\n", "authors": ["1584"]}