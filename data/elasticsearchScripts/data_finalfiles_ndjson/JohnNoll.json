{"title": "Toward virtual community knowledge evolution\n", "abstract": " This paper puts forth a vision and an architecture for a community knowledge evolution system. We propose augmenting a multimedia document repository (digital library) with innovative knowledge evolution support, including computer-mediated communications, community process support, decision support, advanced hypermedia features, and conceptual knowledge structures. These tools, and the techniques developed around them, would enable members of a virtual community to learn from, contribute to, and collectively build upon the community's knowledge and improve many member tasks. The resulting Collaborative Knowledge Evolution Support System (CKESS) would provide an enhanced digital library infrastructure serving as an ever-evolving repository of the community's knowledge, which members would actively use in everyday tasks and regularly update.", "num_citations": "252\n", "authors": ["911"]}
{"title": "Distributed indexing: A scalable mechanism for distributed information retrieval\n", "abstract": " Peter B. Danzig, Jongsuk Ahn, John Nell, Katia Obraczka Computer Science Department University of Southern California Los Angeles, California 90089-0782 danzig@ usc. eduDespite blossoming computer network bandwidths aud the emergence of hypertext and CD-ROM databases, little progress has been made towards uniting the world\u2019s library-style bibliographic databases. While a few advanced distributed retrieval systems can broadcast a query to hundreds of participating databases, experience shows that local users almost always clog library ret rieval systems. Hence broadcast remote queries will clog nearly every system. The premise of this work is that broadcast-based systems do not scale to world-wide systems. This project describes an indexing scheme that will permit thorough yet efficient searches of millions of retrieval systems. Our architecture will work with an arbitrary number of indexing\u00a0\u2026", "num_citations": "78\n", "authors": ["911"]}
{"title": "Requirements elicitation in open source software development: a case study\n", "abstract": " A growing body of empirical research has examined large, successful open source software projects such as the Linux kernel, Apache web server, and Mozilla web browser. Do these results extend to small open source efforts involving a handful of developers? A study of the OpenEMR open source electronic medical record project was conducted, with the goal of understanding how requirements are elicited, documented, agreed, and validated in a small open source software project The results show that the majority of features are asserted by developers, based on either their personal experience, or knowledge of users' needs. Relatively few were requested directly by users. Validation and documentation took the form of informal discussions via the project's developer mailing list. These results are consistent with an earlier study of the Firefox web browser, suggesting that there is a common open source\u00a0\u2026", "num_citations": "45\n", "authors": ["911"]}
{"title": "Virtual community knowledge evolution\n", "abstract": " Puts forth a vision and a possible architecture for a community knowledge evolution system. We propose augmenting a multimedia document repository (digital library) with innovative knowledge evolution support, including computer-mediated communications, community process support, decision support, advanced hypermedia features and conceptual knowledge structures. These tools and the techniques developed around them would enable members of a virtual community to learn from, contribute to, and collectively build upon the community's knowledge and improve many member tasks. The resulting collaborative knowledge evolution support system (CKESS) would provide an enhanced digital library infrastructure serving as an ever-evolving repository of the community's knowledge, which members would actively use in everyday tasks and regularly update.", "num_citations": "36\n", "authors": ["911"]}
{"title": "Requirements acquisition in open source development: Firefox 2.0\n", "abstract": " Open Source Software Development appears to depart radically from conventional notions of software engineering. In particular, requirements for Open Source projects seem to be asserted rather than elicited.               This paper examines features of the latest major release of the Firefox web browser in attempt to understand how prevalent this phenomenon is. Using archives of mailing lists and issue tracking databases, these features were traced from first mention to release, to determine the process by which requirements are proposed, adopted, and implemented in Firefox. The results confirm the importance of user participation as developers of open source products.", "num_citations": "32\n", "authors": ["911"]}
{"title": "Comparing extreme programming to traditional development for student projects: A case study\n", "abstract": " We conducted an experiment attempting to compare XP with a traditional approach to student software engineering projects. We tasked two groups of student teams with producing a simple room reservation system, one group following a traditional development process, the other using XP. We observed little actual difference between the products delivered by either process. However, in our opinion this is due to certain deficiencies in the way XP was realized in this instance, rather than fundamental flaws in the process itself.", "num_citations": "23\n", "authors": ["911"]}
{"title": "Tool support for iterative software process modeling\n", "abstract": " To formalize a process, its important aspects must be extracted and described in a model. This model is often written in a formal language so that the process itself can be automated. Since models are often developed iteratively, this language should support this iterative development cycle. However, many existing languages do not. In this paper, we use an existing high-level process modeling language and present a tool that we have developed for supporting iterative development. We have used our tool to develop and refine a process model of distributed software development for NetBeans.", "num_citations": "16\n", "authors": ["911"]}
{"title": "GSD Sim: A global software development game\n", "abstract": " Context: Software development is often characterised as a \"wicked problem\" due to changing requirements and the realization that the problem to be solved is not really understood until a solution is created. global software development (GSD) introduces a host of additional complexities to software development as a result of global distance (geographic separation, timezone differences, and language and cultural gaps). Problem: A common approach to teaching software engineering concepts is to have students form teams to create a software product, this allow them to experience the problems first hand. However, this approach is much more difficult for GSD, due to the need to have distributed project teams. Approach: We developed a serious game, called \"GSD Sim\", that allows players to manage a globally distributed software project. Players allocate teams of programmers to different locations around the world\u00a0\u2026", "num_citations": "14\n", "authors": ["911"]}
{"title": "What constitutes open source? A study of the vista electronic medical record software\n", "abstract": " Strictly speaking, Open Source Software is any program that is covered by an Open Source Software license. However, the notion of Open Source Software Development conjures images of high-quality, market dominating products developed by armies of volunteer programmers, who work only for the joy of programming. Certainly, banner projects like Apache, the Linux kernel, and Mozilla/Firefox resemble this notion, even if they do employ significant numbers of paid programmers.               This paper examines three Open Source Software projects related to the Vista Electronic Medical Record system developed and maintained by the U.S. Department of Veterans Affairs and released to the public domain. While all three claim to be \u201cOpen Source\u201d projects, there is considerable deviation from the strong community-oriented model that Linux, Apache, and Mozilla represent.", "num_citations": "14\n", "authors": ["911"]}
{"title": "Innovation in open source software development: A tale of two features\n", "abstract": " Open Source Software Development appears to depart radically from conventional notions of software engineering. In particular, requirements for Open Source projects seem to be asserted rather than elicited.               This paper examines two features of selected open source products: \u201ctabbed browsing\u201d as realized in the Firefox web browser, and \u201cedge magnetism\u201d found in the Gnome desktop environment\u2019s Metacity window manager. Using archives of mailing lists and issue tracking databases, these features were traced from first mention to release, in attempt to discover the process by which requirements are proposed, adopted, and implemented in their respective Open Source projects. The results confirm the importance of user participation in Open Source projects.", "num_citations": "14\n", "authors": ["911"]}
{"title": "The design of evolutionary process modeling languages\n", "abstract": " To formalize a software process, its important aspects must be extracted as a model. Many processes are used repeatedly, and the ability to automate a process is also desired. One approach is to use a notation that already exists, such as a programming language, and extend it. However, the intricacies and restrictions the programming language places on the ability to succinctly and clearly describe a process can be problematic. An alternative approach is to develop a language specifically for describing processes. A significant disadvantage of this approach, however, is the lack of tool support for ensuring model correctness. We discuss a high-level language that encourages evolutionary model development and describe a tool for performing model verification. We have used our language and tool on the NetBeans model for distributed software development.", "num_citations": "12\n", "authors": ["911"]}
{"title": "Automated validation and verification of process models\n", "abstract": " In process programming, processes are modeled as pieces of software, and a process programming language is used to specify the process. Such a language resembles a conventional programming language, providing constructs such as iteration and selection. This approach allows models to be simulated and enacted easily. However, it also suffers from the same problems that plague traditional programming, such as the question of whether the program itself is semantically correct or contains errors. We present an automated approach for detecting errors in such process models. Our approach is based on static code analysis techniques. We have developed a tool to analyze processes modeled using PML and have subsequently successfully redesigned models using our tool.", "num_citations": "12\n", "authors": ["911"]}
{"title": "Flexible process enactment using low-fidelity models\n", "abstract": " Attempts to extend process management to support dynamic, knowledge intensive activities have not been as successful as workflow for routine business processes. In part this is due to the dynamic nature of knowledge-intensive work: the tasks performed change continuously in response to the knowledge developed by those tasks. Also, knowledge work involves significant informal communications, which are difficult to capture.", "num_citations": "12\n", "authors": ["911"]}
{"title": "Modeling coordination as resource flow: An object-based approach\n", "abstract": " Workflow management systems provide guidance to individuals performing tasks in an organization. This is typically achieved via a central workflow engine that executes descriptions of organizational processes in order to guide and coordinate activities of individuals in the organization.In this paper, we present a process modeling approach in which processes are modeled as independent \u201cprocess fragments\u201d that represent activities performed by a single actor. Each fragment is a specification of the control flow from one activity to the next, that leads to the completion of a task. Coordination among concurrent activities performed by different actors is modeled as resource flow: dependencies among coordinated activities are represented by the resources shared by concurrent activities. This allows processes performed by autonomous process performers distributed across a network to be coordinated without sacrificing individual autonomy.", "num_citations": "6\n", "authors": ["911"]}
{"title": "Software object management in heterogeneous, autonomous environments: a hypertext approach\n", "abstract": " Software development in the future will conducted by\" virtual enterprises\", consisting of loosely-coupled, widely distributed autonomous development teams.", "num_citations": "5\n", "authors": ["911"]}
{"title": "UTP semantics for shared-state, concurrent, context-sensitive process models\n", "abstract": " Process Modelling Language (PML) is a notationfor describing software development and business processes. It takes the form of a shared-state concurrent imperative language describing tasks asactivities that require resources to startand provide resources when they complete. Its syntax covers sequential composition, parallelism, iteration and choice, but without explicit iteration and choice conditions. It is intended to support a range of context-sensitive interpretations, from a rough guide for intended behaviour, to being very prescriptive about the order in which tasks must occur. We are using Unifying Theories of Programming (UTP) to modelthis range of semantic interpretations, with formal links between them, typically of the nature of a refinement. We address a number of challenges that arise when trying to developa compositional semantics for PML and its shared-state concurrent underpinnings, most notably\u00a0\u2026", "num_citations": "4\n", "authors": ["911"]}
{"title": "Automated acceptance testing vs. quality: A case study of an open source project\n", "abstract": " Automated accept testing is an emerging practice that is claimed to yield many benefits to software development projects, among which is higher quality of the software product itself. Yet there is little empirically grounded evidence to support such claims. In this paper an open source software project was studied to explore the link between automated acceptance testing and the quality of code. The findings of our study show that such link cannot be established readily. Further investigation is needed and our study provides a practical way to conduct such studies.", "num_citations": "4\n", "authors": ["911"]}
{"title": "A peer-to-peer architecture for workflow in virtual enterprises\n", "abstract": " Workflow technology seeks to support or automate the performance of organizational processes. When the organization is a virtual enterprise, the conventional client-server workflow architecture is not suitable: virtual enterprises lack centralized resources and administration to support server installations. Further, virtual enterprise participants can be highly autonomous and heterogeneous. A workflow system to support virtual enterprises must account for autonomy and heterogeneity, as well as wide geographic distribution. This paper proposes a peer-to-peer architecture for deploying workflow in virtual enterprises engaged in knowledge-intensive activities. It views a virtual enterprise as a loosely coupled organization of autonomous, distributed actors supported by individual workflow nodes that enact local processes to guide the actor, and share events to coordinate activities with other members of the organization.", "num_citations": "4\n", "authors": ["911"]}
{"title": "Automated Checking of Software Process Models\n", "abstract": " Using the process programming concept, processes are modeled as pieces of software. A process programming language is used to formally specify the process. Such a language resembles a conventional programming language, typically providing constructs such as iteration and selection. One advantage of this approach is that a process model once coded can be simulated or enacted easily.However, this approach also suffers from the same problems that plague traditional programming tasks, such as the question of whether the program itself is meaningful (ie, semantically correct) or contains errors. Such program errors are the result of a miscoding of the model or of an error in the model itself.", "num_citations": "4\n", "authors": ["911"]}
{"title": "Process enactment: A foundation for managing knowledge intensive work processes\n", "abstract": " Attempts to extend process management to support dynamic, knowledge intensive activities have not been as successful as workflow for routine business processes. In part this is due to the dynamic nature of knowledge-intensive work: the tasks performed change continuously in response to the knowledge developed by those tasks. Also, knowledge work involves significant informal communications, which are difficult to capture.", "num_citations": "3\n", "authors": ["911"]}
{"title": "Teaching global software development through game design\n", "abstract": " In order to be prepared for careers in todays global economy, software engineering students need to understand the issues, methods, and practices associated with Global Software Development (GSD). One approach to teaching GSD is to conduct a GSD project class involving student teams from different institutions in different countries. This approach has the advantage of giving students first-hand experience with the barriers to collaboration and other issues faced by software development teams engaged in GSD. However, this approach is resource-intensive and requires cooperation among institutions. This paper presents an alternate approach based on game design, where students learn GSD concepts by developing a GSD simulation game. Following this approach, students learn about GSD through implementing a game engine that simulates the effects of global distance on a distributed software project\u00a0\u2026", "num_citations": "2\n", "authors": ["911"]}
{"title": "A Survey of Empirical Studies of Extreme Programming\n", "abstract": " Is Extreme Programming an effective software development methodology? Is it better than traditional methodologies? This paper attempts to answer these questions by looking at existing empirical studies of Extreme Programming. The studies examined show varied adoption of XP practices, great satisfaction with XP on the part of developers, and numerous successes. There were also few reports of failures, indicating a need for further study. As a result, it appears that XP is more than a fad, but additional experiments will be required before it can be called a proven methodology.", "num_citations": "2\n", "authors": ["911"]}
{"title": "Software Process\n", "abstract": " 2\" Gold plating. Fixed requirements specifications in advance of design tended to encourage software gold-plating. Users asked about their requirements would frequently reason,\u2018I don\u2019t know if I\u2019ll need this feature or not, but I might as well specify it just in case.\u2019", "num_citations": "2\n", "authors": ["911"]}
{"title": "Innovation in Open Source Software Development\n", "abstract": " Open Source Software Development appears to depart radically from conventional notions of software engineering. In particular, requirements for Open Source projects seem to be asserted rather than elicited. This paper examines two Open Source projects, tracing selected new features from first mention to release, to discover exactly how new requirements are proposed, adopted, and implemented.", "num_citations": "1\n", "authors": ["911"]}
{"title": "An Evaluation of Iterative Development for Software Engineering Course Projects\n", "abstract": " Software produced by student project teams in software engineering courses often exhibits low quality; despite the amount of effort devoted to such projects, it is not unusual for them to produce no working software. Educators are increasingly looking to iterative models such as the Unified Process or Agile development. Do these approaches produce better quality? Twenty seven student software products were examined to see if software produced via iterative development with short iterations had suporior quality to that produced following a courser grained \u201cstaged release\u201d process. The results show no significant difference in quality. Rather, the most significant factor seems to be team size, with larger teams producing better software. This indicates that the choice of development model for software project courses can be based solely on pedagogical considerations, without impact on final project quality.", "num_citations": "1\n", "authors": ["911"]}
{"title": "Process state inference for support of knowledge intensivework.\n", "abstract": " Different actors may do the same work in different ways, depending on their preferences and level of expertise. The nature and amount of process support required also varies with the knowledge level of the actors: novice actors may require guidance at each and every stage of the process, while experts like to have a free hand and need guidance only when in doubt.We describe a descriptive enactment approach, whereby guidance is provided only when asked, rather than actively prescribing a list of actions at every stage of the process. The enactment mechanism also infers the state of the process by examining the state of products created or modified during the execution of the process; therefore, the actor does not have to notify the system of every action he does while performing the process, but the system can still keep track of process progress so that appropriate guidance can be provided when needed.", "num_citations": "1\n", "authors": ["911"]}