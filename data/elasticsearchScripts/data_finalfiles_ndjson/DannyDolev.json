{"title": "On the security of public key protocols\n", "abstract": " Recently the use of public key encryption to provide secure network communication has received considerable attention. Such public key systems are usually effective against passive eavesdroppers, who merely tap the lines and try to decipher the message. It has been pointed out, however, that an improperly designed protocol could be vulnerable to an active saboteur, one who may impersonate another user or alter the message being transmitted. Several models are formulated in which the security of protocols can be discussed precisely. Algorithms and characterizations that can be used to determine protocol security in these models are given.", "num_citations": "5902\n", "authors": ["490"]}
{"title": "Nonmalleable cryptography\n", "abstract": " The notion of nonmalleable cryptography, an extension of semantically secure cryptography, is defined. Informally, in the context of encryption the additional requirement is that given the ciphertext it is impossible to generate a different ciphertext so that the respective plaintexts are related. The same concept makes sense in the contexts of string commitment and zero-knowledge proofs of possession of knowledge. Nonmalleable schemes for each of these three problems are presented. The schemes do not assume a trusted center; a user need not know anything about the number or identity of other system users.  Our cryptosystem is the first proven to be secure against a strong type of chosen ciphertext attack proposed by Rackoff and Simon, in which the attacker knows the ciphertext she wishes to break and can query the decryption oracle on any ciphertext other than the target.", "num_citations": "1881\n", "authors": ["490"]}
{"title": "On the minimal synchronism needed for distributed consensus\n", "abstract": " Reaching agreement is a primitive of distributed computing. Whereas this poses no problem in an ideal, failure-free environment, it imposes certain constraints on the capabilities of an actual system: A system is viable only if it permits the existence of consensus protocols tolerant to some number of failures. Fischer et al. have shown that in a completely asynchronous model, even one failure cannot be tolerated. In this paper their work is extended: Several critical system parameters, including various synchrony conditions, are identified and how varying these affects the number of faults that can be tolerated is examined. The proofs expose general heuristic principles that explain why consensus is possible in certain models but not possible in others.", "num_citations": "910\n", "authors": ["490"]}
{"title": "Atomic broadcast: From simple message diffusion to Byzantine agreement\n", "abstract": " In distributed systems subject to random communication delays and component failures, atomic broadcast can be used to implement the abstraction of synchronous replicated storage, a distributed storage that displays the same contents at every correct processor as of any clock time. This paper presents a systematic derivation of a family of atomic broadcast protocols that are tolerant of increasingly general failure classes: omission failures, timing failures, and authentication-detectable Byzantine failures. The protocols work for arbitrary point-to-point network topologies, and can tolerate any number of link and process failures up to network partitioning. After proving their correctness, we also prove two lower bounds that show that the protocols provide in many cases the best possible termination times.", "num_citations": "784\n", "authors": ["490"]}
{"title": "Sharing memory robustly in message-passing systems\n", "abstract": " Emulators that translate algorithms from the shared-memory model to two different message-passing models are presented. Both are achieved by implementing a wait-free, atomic, single-writer multi-reader register in unreliable, asynchronous networks. The two message-passing models considered are a complete network with processor failures and an arbitrary network with dynamic link failures.These results make it possible to view the shared-memory model as a higher-level language for designing algorithms in asynchronous distributed systems. Any wait-free algorithm based on atomic, single-writer multi-reader registers can be automatically emulated in message-passing systems, provided that at least a majority of the processors are not faulty and remain connected. The overhead introduced by these emulations is polynomial in the number of processors in the system.Immediate new results are obtained by\u00a0\u2026", "num_citations": "709\n", "authors": ["490"]}
{"title": "The Byzantine generals strike again\n", "abstract": " Can unanimity be achieved in an unreliable distributed system? This problem was named the \u201cByzantine Generals Problem\u201d by L. Lamport, R. Shostak, and M. Pease (Technical Report 54, Computer Science Laboratory, SRI International, March 1980). The results obtained in the present paper prove that unanimity is achievable in any distributed system if and only if the number of faulty processors in the system is: (1) less than one-third of the total number of processors; and (2) less than one-half of the connectivity of the system's network. In cases where unanimity is achievable, algorithms for obtaining it are given. This result forms a complete characterization of networks in the light of the Byzantine Problem.", "num_citations": "665\n", "authors": ["490"]}
{"title": "Atomic snapshots of shared memory\n", "abstract": " This paper introduces a general formulation of atomic snapshot memory, a shared memory partitioned into words written (updated) by individual processes, or instantaneously read (scanned) in its entirety. This paper presents three wait-free implementations of atomic snapshot memory. The first implementation in this paper uses unbounded (integer) fields in these registers, and is particularly easy to understand. The second implementation uses bounded registers. Its correctness proof follows the ideas of the unbounded implementation. Both constructions implement a single-writer snapshot memory, in which each word may be updated by only one process, from single-writer, n-reader registers. The third algorithm implements a multi-writer snapshot memory from atomic n-writer, n-reader registers, again echoing key ideas from the earlier constructions. All operations require \u0398(n2) reads and writes to the component\u00a0\u2026", "num_citations": "664\n", "authors": ["490"]}
{"title": "Transis: A communication sub-system for high availability\n", "abstract": " This paper describes Transis, a communication sub-system for high availability. Transis is a transport layer package that supports a variety of reliable multicast message passing services between processors. It provides highly tuned multicast and control services for scalable systems with arbitrary topology. The communication domain comprises of a set of processors that can initiate multicast messages to a chosen subset. Transis delivers them reliably and maintains the membership of connected processors automatically, in the presence of arbitrary communication delays, of message losses and of processor failures and joins. The contribution of this paper is in providing an aggregate de nition of communication and control services over broadcast domains. The main bene t is the e cient implementation of these services using the broadcast capability. In addition, the membership algorithm has a novel approach in handling partitions and remerging; in allowing the regular ow of messages to continue; and in operating symmetrically and spontaneously.", "num_citations": "664\n", "authors": ["490"]}
{"title": "Authenticated algorithms for Byzantine agreement\n", "abstract": " Reaching agreement in a distributed system in the presence of faulty processors is a central issue for reliable computer systems. Using an authentication protocol, one can limit the undetected behavior of faulty processors to a simple failure to relay messages to all intended targets. In this paper we show that, in spite of such an ability to limit faulty behavior, and no matter what message types or protocols are allowed, reaching (Byzantine) agreement requires at least  phases or rounds of information exchange, where t is an upper bound on the number of faulty processors. We present algorithms for reaching agreement based on authentication that require a total number of messages sent by correctly operating processors that is polynomial in both t and the number of processors, n. The best algorithm uses only  phases and  messages.", "num_citations": "644\n", "authors": ["490"]}
{"title": "Reaching approximate agreement in the presence of faults\n", "abstract": " This paper considers a variant of the Byzantine Generals problem, in which processes start with arbitrary real values rather than Boolean values or values from some bounded range, and in which approximate, rather than exact, agreement is the desired goal. Algorithms are presented to reach approximate agreement in asynchronous, as well as synchronous systems. The asynchronous agreement algorithm is an interesting contrast to a result of Fischer et al, who show that exact agreement with guaranteed termination is not attainable in an asynchronous system with as few as one faulty process. The algorithms work by successive approximation, with a provable convergence rate that depends on the ratio between the number of faulty processes and the total number of processes. Lower bounds on the convergence rate for algorithms of this form are proved, and the algorithms presented are shown to be optimal.", "num_citations": "573\n", "authors": ["490"]}
{"title": "The Transis approach to high availability cluster communication\n", "abstract": " \u2022 Tackling network partitions and providing tools for recovery from them. Transis was designed to support partitionable operation, in which multiple network components that are (temporarily) disconnected from each other operate autonomously. When network partitions occur, as in \u201cWiredville\u201d and in more complicated situations, Transis provides enhanced facilities for an application programmer to construct applications that operate consistently in multiple components of a partitioned network, and to merge these components gracefully upon recovery.\u2022 Meeting the needs of a large network through a hierarchical communication structure, with gateways selectively filtering messages among domains.\u2022 Exploiting the available network multicast within each local-area network (LAN) and providing fast cluster communication. Transis has an efficient protocol for reliable multicast, derived from the Trans protocol [16], that\u00a0\u2026", "num_citations": "510\n", "authors": ["490"]}
{"title": "Perfectly secure message transmission\n", "abstract": " This paper studies the problem of perfectly secure communication in general network in which processors and communication lines may be faulty. Lower bounds are obtained on the connectivity required for successful secure communication. Efficient algorithms are obtained that operate with this connectivity and rely on no complexity-theoretic assumptions. These are the first algorithms for secure communication in a general network to simultaneously achieve the three goals of perfect secrecy, perfect resiliency, and worst-case time linear in the diameter of the network.", "num_citations": "506\n", "authors": ["490"]}
{"title": "Distributed computing meets game theory: robust mechanisms for rational secret sharing and multiparty computation\n", "abstract": " We study k-resilient Nash equilibria, joint strategies where no member of a coalition C of size up to k can do better, even if the whole coalition defects. We show that such k-resilient Nash equilibria exist for secret sharing and multiparty computation, provided that players prefer to get the information than not to get it. Our results hold even if there are only 2 players, so we can do multiparty computation with only two rational agents. We extend our results so that they hold even in the presence of up to t players with\" unexpected\" utilities. Finally, we show that our techniques can be used to simulate games with mediators by games without mediators.", "num_citations": "419\n", "authors": ["490"]}
{"title": "Renaming in an asynchronous environment\n", "abstract": " This paper is concerned with the solvability of the problem of processor renaming in unreliable, completely asynchronous distributed systems. Fischer et al. prove in [8] that \u201cnontrivial consensus\u201d cannot be attained in such systems, even when only a single, benign processor failure is possible. In contrast, this paper shows that problems of processor renaming can be solved even in the presence of up to t < n/2 faulty processors, contradicting the widely held belief that no nontrivial problem can be solved in such a system. The problems deal with renaming processors so as to reduce the size of the initial name space. When only uniqueness of the new names is required, we present a lower bound of n + 1 on the size of the new name space, and a renaming algorithm that establishes an upper bound on n + t. If the new names are required also to preserve the original order, a tight bound of 2\u2032(n - t + 1) - 1 is obtained.", "num_citations": "369\n", "authors": ["490"]}
{"title": "An O (n log n) unidirectional distributed algorithm for extrema finding in a circle\n", "abstract": " In this paper we present algorithms, which given a circular arrangement of n uniquely numbered processes, determine the maximum number in a distributive manner. We begin with a simple unidirectional algorithm, in which the number of messages passed is bounded by 2 n log n + O(n). By making several improvements to the simple algorithm, we obtain a unidirectional algorithm in which the number of messages passed is bounded by 1.5nlogn + O(n). These algorithms disprove Hirschberg and Sinclair's conjecture that O(n2) is a lower bound on the number of messages passed in undirectional algorithms for this problem. At the end of the paper we indicate how our methods can be used to improve an algorithm due to Peterson, to obtain a unidirectional algorithm using at most 1.356nlogn + O(n) messages. This is the best bound so far on the number of messages passed in both the bidirectional and\u00a0\u2026", "num_citations": "318\n", "authors": ["490"]}
{"title": "Early stopping in Byzantine agreement\n", "abstract": " Two different kinds of Byzantine Agreement for distributed systems with processor faults are defined and compared. The first is required when coordinated actions may be performed by each participant at different times. This kind is called Simultaneous Byzantine Agreement (SBA). This paper deals with the number of rounds of message exchange required to reach Byzantine Agreement of either kind (BA). If an algorithm allows its participants to reach Byzantine agreement in every execution in which at most t participants are faulty, then the algorithm is said to tolerate t faults. It is well known that any BA algorithm that tolerates t faults (with t < n - 1 where n denotes  the total  number of processors) must run at least t + 1 rounds in some execution. However, it might be supposed that in executions where the number f of actual faults is small compared to t, the number of rounds could be correspondingly small. A corollary\u00a0\u2026", "num_citations": "294\n", "authors": ["490"]}
{"title": "On the possibility and impossibility of achieving clock synchronization\n", "abstract": " It is known that clock synchronization can be achieved in the presence of faulty processors as long as the nonfaulty processors are connected, provided that some authentication technique is used. Without authentication the number of faults that can be tolerated has been an open question. Here we show that if we restrict logical clocks to running within some linear functions of real time, then clock synchronization is impossible without authentication when one-third or more of the processors are faulty. We also provide a lower bound on the closeness to which simultaneity can be achieved in the network as a function of the transmission and processing delay properties of the network.", "num_citations": "277\n", "authors": ["490"]}
{"title": "Bounds on information exchange for Byzantine agreement\n", "abstract": " Byzantine Agreement has become increasingly important in establishing distributed properties when errors may exist in the systems. Recent polynomial algorithms for reaching Byzantine Agreement provide us with feasible solutions for obtaining coordination and synchronization in distributed systems. In this paper the amount of information exchange necessary to ensure Byzantine Agreement is studied. This is measured by the total number of messages the participating processors have to send in the worst case. In algorithms that use a signature scheme, the number of signatures appended to messages are also counted. First it is shown that \u03a9(nt) is a lower bound for the number of signatures for any algorithm using authentication, where n denotes the number of processors and t the upper bound on the number of faults the algorithm is supposed to handle. For algorithms that reach Byzantine Agreement without\u00a0\u2026", "num_citations": "264\n", "authors": ["490"]}
{"title": "Fault-tolerant clock synchronization\n", "abstract": " This paper gives two simple efficient distributed algorithms: one for keeping clocks in a network synchronized and one for allowing new processors to join the network with their clocks synchronized. The algorithms tolerate both link and node failures of any type. The algorithm for maintaining synchronization will work for arbitrary networks (rather than just completely connected networks) and tolerates any number of processor or communication link faults as long as the correct processors remain connected by fault-free paths. It thus represents an improvement over other clock synchronization algorithms such as [LM1, LM2, LL1]. Our algorithm for allowing new processors to join requires that more than half the processors be correct, a requirement which is provably necessary.", "num_citations": "234\n", "authors": ["490"]}
{"title": "Shifting gears: Changing algorithms on the fly to expedite Byzantine agreement\n", "abstract": " We describe several new algorithms for Byzantine agreement. The first of these is a simplification of the original exponential-time Byzantine agreement algorithm due to Pease, Shostak, and Lamport, and is of comparable complexity to their algorithm. However, its proof is very intuitively appealing. A technique of shifting between algorithms for solving the Byzantine agreement problem is then studied. We present two families of algorithms obtained by applying a shift operator to our first algorithm. These families obtain the same rounds to message length trade-off as do Coan's families but do not require the exponential local computation time (and space) of his algorithms. We also describe a modification of an O (n)-resilient algorithm for Byzantine agreement of Dolev, Reischuk, and Strong. Finally, we obtain a hybrid algorithm that dominates all our others, by beginning execution of an algorithm in one family, first\u00a0\u2026", "num_citations": "205\n", "authors": ["490"]}
{"title": "Polynomial algorithms for multiple processor agreement\n", "abstract": " Reaching agreement in a distributed system while handling malfunctioning behavior is a central issue for reliable computer systems. All previous algorithms for reaching the agreement required an exponential number of messages to be sent, with or without authentication. We give polynomial algorithms for reaching (Byzantine) agreement, both with and without the use of authentication protocols. We also prove that no matter what kind of information is exchanged, there is no way to reach agreement with fewer than t+ 1 rounds of exchange, where t is the upper bound on the number of faults.", "num_citations": "196\n", "authors": ["490"]}
{"title": "An efficient algorithm for Byzantine agreement without authentication\n", "abstract": " Byzantine Agreement involves a system of n processes, of which some t may be faulty. The problem is for the correct processes to agree on a binary value sent by a transmitter that may itself be one of the n processes. If the transmitter sends the same value to each process, then all correct processes must agree on that value, but in any case, they must agree on some value. An explicit solution not using authentication for n = 3t + 1 processes is given, using 2t + 3 rounds and O(t3 log t) message bits. This solution is easily extended to the general case of n \u2a7e 3t + 1 to give a solution using 2t + 3 rounds and O(nt + t3 log t) message bits.", "num_citations": "176\n", "authors": ["490"]}
{"title": "On the security of ping-pong protocols\n", "abstract": " Consider the class of protocols, for two participants, in which the initiator applies a sequence of operators to a message M and sends it to the other participant; in each step, one of the participants applies a sequence of operators to the message received last, and sends it back. This \u201cping-pong\u2253 action continues several times, using sequences of operators as specified by the protocol. The set of operators may include public-key encryptions and decryptions. An O(n3) algorithm which determines the security of a given protocol (of length n) is presented. This is an improvement of the algorithm of Dolev and Yao (IEEE Trans. Inform. Theory IT-30 (2) (1983), 198208).", "num_citations": "175\n", "authors": ["490"]}
{"title": "LLS: a locality aware location service for mobile ad hoc networks\n", "abstract": " Coping with mobility and dynamism is one of the biggest challenges in ad hoc networks. An essential requirement for such networks is a service that can establish communication sessions between mobile nodes whose location is unknown. A location service for ad hoc networks is a distributed algorithm that allows any source node s to know the location of any destination node t, simply by knowing t's network identifier. A location service has a locality aware lookup algorithm if the cost of locating destination t from source s is proportional to the cost of the minimal cost path between s and t. A location service has a locality aware publish algorithm if the cost of updating the location service due to a node moving from x to y is proportional to the distance between x and y. In this paper we present LLS, the first location service for the Unit Disk Graph model whose lookup and publish algorithms have worst case locality\u00a0\u2026", "num_citations": "163\n", "authors": ["490"]}
{"title": "Membership algorithms for multicast communication groups\n", "abstract": " We introduce a membership protocol that maintains the set of currently connected machines in an asynchronous and dynamic environment. The protocol handles both failures and joining of machines. It operates within a multicast communication sub-system.             It is well known that solving the membership problem in an asynchronous environment when faults may be present is impossible. In order to circumvent this difficulty, our approach rarely extracts from the membership live (but not active) machines unjustfully. The benefit is that our procotol always terminates within a finite time. In addition, if a machine is inadvertently taken out of the membership, it can rejoin it right away using the membership protocol.             Despite the asynchrony, configuration changes are logically synchronized with all the regular messages in the system, and appear virtually synchronous to the application layer.             The\u00a0\u2026", "num_citations": "150\n", "authors": ["490"]}
{"title": "A new look at fault tolerant network routing\n", "abstract": " Consider a communication network G in which a limited number of link and/or node faults F might occur. A routing \u03c1 for the network (a fixed path between each pair of nodes) must be chosen without any knowledge of which components might become faulty. Choosing a good routing corresponds to bounding the diameter of the surviving route graph R (G, \u03c1)/F, where two nonfaulty nodes are joined by an edge if there are no faults on the route between them. We prove a number of results concerning the diameter of surviving route graphs. We show that if \u03c1 is a minimal length routing, then the diameter of R (G, \u03c1)/F can be on the order of the number of nodes of G, even if F consists of only a single node. However, if G is the n-dimensional cube, the diameter of R (G, \u03c1)/F\u2264 3 for any minimal length routing \u03c1 and any set of faults F with| F|< n. We also show that if F consists only of edges and does not disconnect G, then the\u00a0\u2026", "num_citations": "134\n", "authors": ["490"]}
{"title": "Group communication specifications: A comprehensive study\n", "abstract": " View-oriented group communication is an important and widely used building block for many distributed applications. Much current research has been dedicated to specifying the semantics and services of {\\em view-oriented Group Communication Systems (GCSs)}. However, the guarantees of different GCSs are formulated using varying terminologies and modeling techniques, and the specifications vary in their rigor. This makes it difficult to analyze and compare the different systems. This paper provides a comprehensive set of clear and rigorous specifications, which may be combined to represent the guarantees of most existing GCSs. In the light of these specifications, over thirty published GCS specifications are surveyed. Thus, the specifications serve as a unifying framework for the classification, analysis and comparison of group communication systems. The survey also discusses over a dozen different applications of group communication systems, shedding light on the usefulness of the presented specifications. Defining meaningful GCSs is challenging; such systems typically run in asynchronous environments in which agreement problems that resemble the services provided by group communication services are not solvable. Therefore, many of the suggested specifications turned out to be too trivial, and in particular, solvable by weaker algorithms than the actual implementations. In this paper, the non-triviality issues are addressed by guaranteeing conditional liveness and by using external failure detectors. The resulting specifications are non-trivial on one hand, and allow implementation on the other. This paper is aimed at both system\u00a0\u2026", "num_citations": "133\n", "authors": ["490"]}
{"title": "Efficient message passing interface (MPI) for parallel computing on clusters of workstations\n", "abstract": " Parallel computing on clusters of workstations and personal computers has very high potential, since it leverages existing hardware and software. Parallel programming environments offer the user a convenient way to express parallel computation and communication. In fact, recently, a Message Passing Interface (MPI) has been proposed as an industrial standard for writing \u201cportable\u201d message-passing parallel programs. The communication part of MPI consists of the usual point-to-point communication as well as collective communication. However, existing implementations of programming environments for clusters are built on top of a point-to-point communication layer (send and receive) over local area networks (LANs) and, as a result, suffer from poor performance in the collective communication part. In this paper, we present an efficient design and implementation of the collective communication part in MPI that\u00a0\u2026", "num_citations": "129\n", "authors": ["490"]}
{"title": "Early delivery totally ordered multicast in asynchronous environments\n", "abstract": " The authors present the construction of a multicast service, called agreed multicast, that guarantees that messages arrive reliably and in the same total-order to all their destinations. ToTo, a novel protocol, implements the agreed multicast service of Transis, a communication subsystem for the High Availability project, currently developed at the Hebrew University of Jerusalem. This service is desired in distributed systems, and supports high level coordination among groups of processes in distributed applications. The ToTo protocol is genuinely symmetric and fairly simple for implementing. It provides early delivery latency, and requires as little as n/2 messages for forming agreement on the order of delivery. Experimental results show up to O(log (n)) speedup over previous protocols, which matches the authors' prediction of the expected speedup. Using the Transis membership service, ToTo can operate in a dynamic\u00a0\u2026", "num_citations": "115\n", "authors": ["490"]}
{"title": "Achievable cases in an asynchronous environment\n", "abstract": " The paper deals with achievability of fault tolerant goals in a completely asynchronous distributed system. Fischer, Lynch, and Paterson [FLP] proved that in such a system \"nontrivial agreement\" cannot be achieved even in the (possible) presence of a single \"benign\" fault. In contrast, we exhibit two pairs of goals that are achievable even in the presence of up to t \u226a n/2 faulty processors, contradicting the widely held assumption that no nontrivial goals are attainable in such a system. The first pair deals with renaming processors so as to reduce the size of the initial name space. When only uniqueness is required of the new names, we present a lower bound of n + 1 on the size of the new name space, and a renaming algorithm which establishes an upper bound of n + t. In case the new names are required also to preserve the original order, a tight bound of 2t(n- t + 1) - 1 is obtained. The second pair of goals deals with\u00a0\u2026", "num_citations": "111\n", "authors": ["490"]}
{"title": "Planar embedding of planar graphs\n", "abstract": " Planar embedding with minimal area of graphs on an integer grid is an interesting problem in VLSI Very Large Scale Integrated theory. Valiant gave an algorithm to construct a planar embeddding for trees in linear area he also proved that there are planar graphs that require quadratic area. We fill in a spectrum between Valiants results by showing that an N-node planar graphs has a planar embedding with area 0NF, where F is a bound on the path length from any node to the exterior face. In particular, an outerplanar graph can be embedded without crossovers in linear area. This bound is tight, up to constant factors for any N and F, there exist graphs requiring omegaNF area for planar embedding. Also, finding a minimal embedding area is shown to be Nu-complete for forests, and hence for more general types of graphs. authorDescriptors:", "num_citations": "107\n", "authors": ["490"]}
{"title": "Cheating husbands and other stories: a case study of knowledge, action, and communication\n", "abstract": " The relationship between knowledge and action is a fundamental one: a processor in a computer network (or a robot or a person, for that matter) should base its actions on the knowledge (or information) it has. One of the main uses of communication is passing around information that may eventually be required by the receiver in order to decide upon subsequent actions. Understanding the relationship between knowledge, action, and communication is fundamental to the design of computer network protocols, intelligent robots, etc. By looking at a number of variants of thecheating husbands puzzle, we illustrate the subtle relationship between knowledge, communication, and action in a distributed environment.", "num_citations": "103\n", "authors": ["490"]}
{"title": "Gaussian belief propagation solver for systems of linear equations\n", "abstract": " The canonical problem of solving a system of linear equations arises in numerous contexts in information theory, communication theory, and related fields. In this contribution, we develop a solution based upon Gaussian belief propagation (GaBP) that does not involve direct matrix inversion. The iterative nature of our approach allows for a distributed message-passing implementation of the solution algorithm. We also address some properties of the GaBP solver, including convergence, exactness, its max-product version and relation to classical solution methods. The application example of decorrelation in CDMA is used to demonstrate the faster convergence rate of the proposed solver in comparison to conventional linear-algebraic iterative solution methods.", "num_citations": "101\n", "authors": ["490"]}
{"title": "Optimal wiring between rectangles\n", "abstract": " We consider the problem of wiring together two parallel rows of points under a variety of conditions. The options include whether we allow the rows to slide relative to one another, whether we use only rectilinear wires or arbitrary wires, and whether we can use wires in one layer or several layers. In almost all of these combinations of conditions, we can provide a polynomial-time algorithm to minimize the distance between the parallel rows of points. We also compare two fundamentally different wiring approaches, where one and two layers are used. We show that although the theoretical model implies that there can be great gains for the two-layer strategy, even in cases where no crossovers are required, when we consider typical design rules for laying out VLSI circuits there is no substantial advantage to the two-layer approach over the one-layer approach.", "num_citations": "100\n", "authors": ["490"]}
{"title": "Dynamic fault-tolerant clock synchronization\n", "abstract": " This paper gives two simple efficient distributed algorithms: one for keeping clocks in a network synchronized and one for allowing new processors to join the network with their clocks synchronized. Assuming a fault-tolerant authentication protocol, the algorithms tolerate both link and processor failures of any type. The algorithm for maintaining synchronization works for arbitrary networks (rather than just completely connected networks) and tolerates any number of processor or communication link faults as long as the correct processors remain connected by fault-free paths. It thus represents an improvement over other clock synchronization algorithms such as those of Lamport and Melliar Smith and Welch and Lynch, although, unlike them, it does require an authentication protocol to handle Byzantine faults. Our algorithm for allowing new processors to join requires that more than half the processors be correct, a\u00a0\u2026", "num_citations": "99\n", "authors": ["490"]}
{"title": "Superconcentrators, generalizers and generalized connectors with limited depth\n", "abstract": " We show that the minimum possible size of an n-superconcentrator with depth 2k\u2265 4 is \u03b8 (n\u03bb (k, n)), where \u03bb (k,.) is the inverse of a certain function at the k-th level of the primitive recursive hierarchy. It follows that the minimum possible depth of an n-superconcentrator with linear size is \u03b8 (\u03b2 (n)), where \u03b2 is the inverse of a function growing more rapidly than any primitive recursive function. Similar results hold for generalizers.", "num_citations": "97\n", "authors": ["490"]}
{"title": "Shared-memory vs. message-passing in an asynchronous distributed environment\n", "abstract": " Shared-memory vs. message-passing in an asynchronous distributed environment | Proceedings of the eighth annual ACM Symposium on Principles of distributed computing ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search podc Conference Proceedings Upcoming Events Authors Affiliations Award Winners More HomeConferencesPODCProceedingsPODC '89Shared-memory vs. message-passing in an asynchronous distributed environment Article Shared-memory vs. message-passing in an asynchronous distributed environment Share on Authors: A. Bas-Noy View Profile , D. Dolev View Profile Authors Info & Affiliations PODC '89: Proceedings of the eighth annual ACM Symposium on Principles of 307:'\u2026", "num_citations": "93\n", "authors": ["490"]}
{"title": "Bounded concurrrent time-stamp systems are constructible\n", "abstract": " Concurrent time stamping is at the heart of solutions to some of the most fundamental problems in distributed computing. Based on concurrent-time-stamp-systems, elegant and simple solutions to core problems such as \u0192c\u0192s-mutual-exclusion, construction of a multi-reader-multi-writer atomic register, probabilistic consensus,\u2026 were developed. Unfortunately, the only known implementation of a concurrent time stamp system has been theoretically unsatisfying, since it requires unbounded size time-stamps, in other words, unbounded memory. Not knowing if bounded concurrent-time-stamp-systems are at all constructible, researchers were led to constructing complicated problem-specific solutions to replace the simple unbounded ones. In this work, for the first time, a bounded implementation of a concurrent-time-stamp-system is presented. It provides a modular unbounded-to-bounded transformation of the simple\u00a0\u2026", "num_citations": "93\n", "authors": ["490"]}
{"title": "A framework for partitionable membership service\n", "abstract": " ArI informal summary of our specification is provided in Figure 1. In the figure, a local view is a list of machines reported to a member through a view installation event; messages are multicasi to all members. For more details, see [1], and the Transis home page http://www. cs. huji. ac. il/papers/transis/transis. html.", "num_citations": "92\n", "authors": ["490"]}
{"title": "Unanimity in an unknown and unreliable environment\n", "abstract": " Can unanimity be achieved in an unknown and unreliable distributed system? We analyze two extreme models of networks: one in which all the routes of communication are known, and the other in which not even the topology of the network is known. We prove that independently of the model, unanimity is achievable if and only if the number of faulty processors in the system is 1. less than one half of the connectivity of the system's network, and 2. less than one third of the total number of processors. In cases where unanimity is achievable, an algorithm to obtain it is given.", "num_citations": "92\n", "authors": ["490"]}
{"title": "Robust and E cient Replication using Group Communication\n", "abstract": " We present a new architecture and algorithm for distributed replicated database systems. The replication algorithm operates in the presence of message omission faults, processor crashes and recoveries, and network partitions and remerges. The architecture exploits a group communication service to minimize communication costs and to eliminate forced disk writes in the critical path, while preserving complete and consistent operation. End-to-end agreement is required only after a change in the membership of the connected servers, rather than on a per action basis.The updates are globally ordered and, if the system has partitioned, they are applied to the database when they become known to the primary component of the partitioned system. An application may, however, read data and initiate updates at any time, even in a component that is not the primary component. This approach renders replication more e cient and more scalable and, therefore, applicable to many more systems.", "num_citations": "91\n", "authors": ["490"]}
{"title": "Bounds for width two branching programs\n", "abstract": " Branching programs have been studied as a fundamental model for space bounded computations and, in particular, as a model in which to try to establish nontrivial space lower bounds and time-space trade-offs. At present, there still do not exist any results for single output functions. We consider a class of severely constrained programs (those having width 2) and establish characterizations as well as lower bounds for some Boolean functions computable within this model.", "num_citations": "89\n", "authors": ["490"]}
{"title": "\u201cTri, Tri again\u201d: Finding Triangles and Small Subgraphs in a Distributed Setting\n", "abstract": " Let G\u2009=\u2009(V,E) be an n-vertex graph and M                                    d                  a d-vertex graph, for some constant d. Is M                                    d                  a subgraph of G? We consider this problem in a model where all n processes are connected to all other processes, and each message contains up to  bits. A simple deterministic algorithm that requires  communication rounds is presented. For the special case that M                                    d                  is a triangle, we present a probabilistic algorithm that requires an expected  rounds of communication, where t is the number of triangles in the graph, and  with high probability.               We also present deterministic algorithms that are specially suited for sparse graphs. In graphs of maximum degree \u0394, we can test for arbitrary subgraphs of diameter D in  rounds. For triangles, we devise an\u00a0\u2026", "num_citations": "84\n", "authors": ["490"]}
{"title": "Bounded concurrent time-stamping\n", "abstract": " We introduce concurrent time-stamping, a paradigm that allows processes to temporally order concurrent events in an asynchronous shared-memory system. Concurrent time-stamp systems are powerful tools for concurrency control, serving as the basis for solutions to coordination problems such as mutual exclusion, -exclusion, randomized consensus, and multiwriter multireader atomic registers. Unfortunately, all previously known methods for implementing concurrent time-stamp systems have been theoretically unsatisfying since they require unbounded-size time-stamps---in other words, unbounded-size memory.This work presents the first bounded implementation of a concurrent time-stamp system, providing a modular unbounded-to-bounded transformation of the simple unbounded solutions to problems such as those mentioned above. It allows solutions to two formerly open problems, the bounded-probabilistic\u00a0\u2026", "num_citations": "84\n", "authors": ["490"]}
{"title": "Increasing the resilience of atomic commit, at no additional cost\n", "abstract": " This paper presents a new atomic commitment protocol, Enhanced Three Phase Commit(E3PC), that always allows a quorum in the system to make progress. Previously suggested quorum-based protocols(e, g. the quorum-based Three Phase Commit(3PC)[Ske82]) allow a quorum to make progress in case of one failure. If failures cascade, however, and the quorum in the system is \u201clost\u201d(i, e. at a given time no quorum component exists, eg because of a total crash), a quorum can later become connected and still remain blocked. With our protocol, a connected quorum never blocks. E3PC is based on the quorumbased 3PC [Ske82], and it does not require more time or communication than 3PC. The principles demonstrated in this paper can be used to increase the resilience of a variety of distributed services, eg, replicated database systems, by ensuring that aquorum will always be able to make progress.", "num_citations": "84\n", "authors": ["490"]}
{"title": "Steward: Scaling Byzantine fault-tolerant replication to wide area networks\n", "abstract": " This paper presents the first hierarchical byzantine fault-tolerant replication architecture suitable to systems that span multiple wide-area sites. The architecture confines the effects of any malicious replica to its local site, reduces message complexity of wide-area communication, and allows read-only queries to be performed locally within a site for the price of additional standard hardware. We present proofs that our algorithm provides safety and liveness properties. A prototype implementation is evaluated over several network topologies and is compared with a flat byzantine fault-tolerant approach. The experimental results show considerable improvement over flat byzantine replication algorithms, bringing the performance of byzantine replication closer to existing benign fault-tolerant replication techniques over wide area networks.", "num_citations": "83\n", "authors": ["490"]}
{"title": "Implementing a caching service for distributed CORBA objects\n", "abstract": " This paper discusses the implementation of CASCADE, a distributed caching service for CORBA objects. Our caching service is fully CORBA compliant, and supports caching of active objects, which include both data and code. It is specifically designed to operate over the Internet by employing a dynamically built cache hierarchy. The service architecture is highly configurable with regard to a broad spectrum of application parameters. The main benefits of CASCADE are enhanced availability and service predictability, as well as easy dynamic code deployment and consistency maintenance.", "num_citations": "81\n", "authors": ["490"]}
{"title": "Efficient fault-tolerant routings in networks\n", "abstract": " We analyze the problem of constructing a network with a given number of nodes which has a fixed routing and which is highly fault tolerant. A construction is presented which forms a \u201cproduct route graph\u201d from two or more constituent \u201croute graphs.\u201d The analysis involves the surviving route graph, which consists of all nonfaulty nodes in the network with two nodes being connected by a directed edge iff the route from the first to the second is still intact after a set of component failures. The diameter of the surviving route graph is a measure of the worst-case performance degradation caused by the faults. The number of faults tolerated, the diameter, and the degree of the product graph are related in a simple way to the corresponding parameters of the constituent graphs. In addition, there is a \u201cpadding theorem\u201d which allows one to add nodes to a graph and to extend a previous routing.", "num_citations": "79\n", "authors": ["490"]}
{"title": "Scaling byzantine fault-tolerant replication towide area networks\n", "abstract": " This paper presents the first hierarchical Byzantine fault-tolerant replication architecture suitable to systems that span multiple wide area sites. The architecture confines the effects of any malicious replica to its local site, reduces message complexity of wide area communication, and allows read-only queries to be performed locally within a site for the price of additional hardware. A prototype implementation is evaluated over several network topologies and is compared with a flat Byzantine fault-tolerant approach", "num_citations": "78\n", "authors": ["490"]}
{"title": "A bounded first-in, first-enabled solution to the l-exclusion problem\n", "abstract": " This article presents a solution to the first-come, first-enabled \u2113-exclusion problem of Fischer et al. [1979]. Unlike their solution, this solution does not use powerful read-modify-write synchronization primitives and requires only bounded shared memory. Use of the concurrent timestamp system of Dolev and Shavir [1989] is key in solving the problem within bounded shared memory.", "num_citations": "76\n", "authors": ["490"]}
{"title": "An asynchronous membership protocol that tolerates partitions\n", "abstract": " This paper presents a membership protocol for maintaining the set of operational and connected machines in agreement. The protocol operates in an asynchronous environment prone to crash failures, omission failures and network partitions. The protocol is suitable for systems with machines that communicate via broadcast (or multicast) messages. It supports continued operation with partitions and provides the mechanism for merging of partitions. The principles of the protocol presented here have been successfully incorporated into the Transis system 3, 2], the Totem system 4], and the Horus system 29].The membership protocol presented here is integrated in the communication system, such that the noti cations of membership changes are delivered to the application among the stream of regular messages. Changes to the membership are coordinated with the delivery of regular messages in the system. This valuable approach was presented in 7, 9] in the context of a primary-partition system, and is extended here for partitionable systems. Its importance is in providing the distributed application builder with a virtually synchronous programming environment. This approach is suitable for many environments today, all of them supporting various forms of multicast communication among machines and among process groups.", "num_citations": "76\n", "authors": ["490"]}
{"title": "Enhancing RSSI-based tracking accuracy in wireless sensor networks\n", "abstract": " In recent years, the demand for high-precision tracking systems has significantly increased in the field of Wireless Sensor Network (WSN). A new tracking system based on exploitation of Received Signal Strength Indicator (RSSI) measurements in WSN is proposed. The proposed system is designed in particular for WSNs that are deployed in close proximity and can transmit data at a high transmission rate. The close proximity and an optimized transmit power level enable accurate conversion of RSSI measurements to range estimates. Having an adequate transmission rate enables spatial-temporal correlation between consecutive RSSI measurements. In addition, advanced statistical and signal processing methods are used to mitigate channel distortion and to compensate for packet loss. The system is evaluated in indoor conditions and achieves tracking resolution of a few centimeters which is compatible with\u00a0\u2026", "num_citations": "75\n", "authors": ["490"]}
{"title": "Internet resiliency to attacks and failures under BGP policy routing\n", "abstract": " We investigate the resiliency of the Internet at the Autonomous System (AS) level to failures and attacks, under the real constraint of business agreements between the ASs. The agreements impose policies that govern routing in the AS level, and thus the resulting topology graph is directed, and thus the reachability between Ases is not transitive. We show, using partial views obtained from the Internet, that the Internet\u2019s resiliency to a deliberate attack is much smaller than previously found, and its reachability is also somewhat lower under random failures. We use different metrics to measure resiliency, and also investigate the effect of added backup connectivity on the resiliency.", "num_citations": "72\n", "authors": ["490"]}
{"title": "Profile scheduling of opposing forests and level orders\n", "abstract": " The question of existence of a schedule of a given length for n unit length tasks on n identical processors subject to precedence constraints is known to be NP-complete [Ullman, J. Comput. System Sci., 10 (1976), pp. 384\u2013393]. For a fixed value of m we present polynomial algorithms to find an optimal schedule for two families of precedence graphs: level orders and opposing forests. In the case of opposing forest our algorithm is a considerable improvement over the algorithm presented in [Garey et al., SIAM J. Alg. Disc. Meth., 4 (1983), pp. 72\u201393].", "num_citations": "72\n", "authors": ["490"]}
{"title": "Method for achieving multiple processor agreement optimized for no faults\n", "abstract": " An originating processor broadcasts a value in a message with its unforgeable signature to all n active processors, including itself. Receiving processors in the network pass such a message on with their own unforgeable signatures to all active processors, including themselves. If the number of signatures and phases is the same at each processor after the first two successive passings, then agreement as to the value with no fault is indicated, otherwise if after two passings,(t+ 1) signatures have been collected, then these are signed and sent in the third passing, and in any case, each processor continues the steps of repeatedly sending messages when received, and appending its signature until t+ 2 passings have occurred. At that time, a processor will agree to the value if at least (t+ 1) signatures append the message, otherwise a default value is adopted, t (n/2) being a reliability measure.", "num_citations": "70\n", "authors": ["490"]}
{"title": "'Eventual'is earlier than'immediate'\n", "abstract": " Two different notions of Byzantine Agreement - immediate and eventually - are defined depending on whether the agreement involves an action to be performed synchronously or not. The lower bounds for time complexity depend on what kind of agreement has to be achieved. All previous algorithms to reach Byzantine Agreement ensure immediate agreement. We present two algorithms that in many cases reach the second type of agreement faster than previously known algorithms showing that there actually is a difference between the two notions: Eventual Byzantine Agreement can be reached earlier than Immediate.", "num_citations": "70\n", "authors": ["490"]}
{"title": "Lower bounds on implementing robust and resilient mediators\n", "abstract": " We provide new and tight lower bounds on the ability of players to implement equilibria using cheap talk, that is, just allowing communication among the players. One of our main results is that, in general, it is impossible to implement three-player Nash equilibria in a bounded number of rounds. We also give the first rigorous connection between Byzantine agreement lower bounds and lower bounds on implementation. To this end we consider a number of variants of Byzantine agreement and introduce reduction arguments. We also give lower bounds on the running time of two player implementations. All our results extended to lower bounds on (k,t)-robust equilibria, a solution concept that tolerates deviations by coalitions of size up to k and deviations by up to t players with unknown utilities (who may be malicious).", "num_citations": "68\n", "authors": ["490"]}
{"title": "On multicast trees: structure and size estimation\n", "abstract": " This work presents a thorough investigation of the structure of multicast trees cut from the Internet and power-law topologies. Based on both generated topologies and real Internet data, we characterize the structure of such trees and show that they obey the rank-degree power law; that most high degree tree nodes are concentrated in a low diameter neighborhood; and that the sub-tree size also obeys a power law. Our most surprising empirical finding suggests that there is a linear ratio between the number of high degree network nodes, namely nodes whose tree degree is higher than some constant, and the number of leaf nodes in the multicast tree (clients). We also derive this ratio analytically. Based on this finding, we develop the Fast Algorithm, that estimates the number of clients, and show that it converges faster than one round trip delay from the root to a randomly selected client", "num_citations": "66\n", "authors": ["490"]}
{"title": "Self-stabilizing pulse synchronization inspired by biological pacemaker networks\n", "abstract": " We define the \u201cPulse Synchronization\u201d problem that requires nodes to achieve tight synchronization of regular pulse events, in the settings of distributed computing systems. Pulse-coupled synchronization is a phenomenon displayed by a large variety of biological systems, typically overcoming a high level of noise. Inspired by such biological models, a robust and self-stabilizing pulse synchronization algorithm for distributed computer systems is presented. The algorithm attains near optimal synchronization tightness while tolerating up to a third of the nodes exhibiting Byzantine behavior concurrently. We propose that pulse synchronization algorithms can be suitable for a variety of distributed tasks that require tight synchronization but which can tolerate a bound variation in the regularity of the synchronized pulse invocations.", "num_citations": "66\n", "authors": ["490"]}
{"title": "The distributed firing squad problem\n", "abstract": " The distributed firing squad problem is defined in the context of a synchronous distributed system where the correct processors operate in lock-step synchrony but do not share a global clock. If one or more correct processors receive a command to start a firing squad synchronization, then at some future time all correct processors must \u201cfire\u201d (formally, enter a special state) at exactly the same step. For various fault models, upper and lower bounds are proved on the number of faulty processors that can be tolerated and on the number of rounds of communication required between the reception of the start command and firing. For example, if a firing squad protocol is resilient to t fail-stop faults, then at least  rounds are necessary and sufficient. For the case of Byzantine faults with authentication where the faulty processors can take steps in between the synchronous steps of the correct processors, the firing squad problem can be\u00a0\u2026", "num_citations": "66\n", "authors": ["490"]}
{"title": "High performance string matching algorithm for a network intrusion prevention system (nips)\n", "abstract": " Intrusion detection systems (IDS) were developed to identify and report attacks in the late 1990s, as hacker attacks and network worms began to affect the Internet. Traditional IDS technologies detect hostile traffic and send alerts but do nothing to stop the attacks. Network intrusion prevention systems (NIPS) are deployed in-line with the network segment being protected. As the traffic passes through the NIPS, it is inspected for the presence of an attack. Like viruses, most intruder activities have some sort of signatures. Therefore, a pattern-matching algorithm resides at the heart of the NIPS. When an attack is identified, the NIPS blocks the offending data. There is an alleged trade-off between the accuracy of detection and algorithmic efficiency. Both are paramount in ensuring that legitimate traffic is not delayed or disrupted as it flows through the device. For this reason, the pattern-matching algorithm must be able to\u00a0\u2026", "num_citations": "65\n", "authors": ["490"]}
{"title": "Method and system for selectable consistency level maintenance in a resilent database system\n", "abstract": " In a resilient database system which includes a journaled database which is implemented at one or more locations within a distributed data processing system, multiple diverse consistency levels are specified which each detail a level of consistency to be maintained between a primary database and a replica database. A user is then permitted to select a particular level of consistency for each replica database. Thereafter, each update to a record within the primary database is utilized to initiate an update to the corresponding record within each replica database in a manner which is consistent with the selected level of consistency for that replica database. In this manner, a replica database which is fully consistent with the primary database may be provided for seamless switchover in the event of a primary database failure, while a second replica database may be provided to respond to queries by applications which\u00a0\u2026", "num_citations": "64\n", "authors": ["490"]}
{"title": "An almost-surely terminating polynomial protocol for asynchronous byzantine agreement with optimal resilience\n", "abstract": " Consider an asynchronous system with private channels and n processes, up to t of which may be faulty. We settle a longstanding open question by providing a Byzantine agreement protocol that simultaneously achieves three properties:(optimal) resilience: it works as long as n> 3t;(almost-sure) termination: with probability one, all nonfaulty processes terminate;(polynomial) efficiency: the expected computation time, memory consumption, message size, and number of messages sent are all polynomial in n. Earlier protocols have achieved only two of these three properties. In particular, the protocol of Bracha is not polynomially efficient, the protocol of Feldman and Micali is not optimally resilient, and the protocol of Canetti and Rabin does not have almost-sure termination. Our protocol utilizes a new primitive called shunning (asynchronous) verifiable secret sharing (SVSS), which ensures, roughly speaking, that\u00a0\u2026", "num_citations": "61\n", "authors": ["490"]}
{"title": "Optimal resilience asynchronous approximate agreement\n", "abstract": " Consider an asynchronous system where each process begins with an arbitrary real value. Given some fixed \u03b5>\u20090, an approximate agreement algorithm must have all non-faulty processes decide on values that are at most \u03b5 from each other and are in the range of the initial values of the non-faulty processes.               Previous constructions solved asynchronous approximate agreement only when there were at least 5t+1 processes, t of which may be Byzantine. In this paper we close an open problem raised by Dolev et al. in 1983. We present a deterministic optimal resilience approximate agreement algorithm that can tolerate any t Byzantine faults while requiring only 3t+1 processes.               The algorithm\u2019s rate of convergence and total message complexity are efficiently bounded as a function of the range of the initial values of the non-faulty processes. All previous asynchronous algorithms that are resilient\u00a0\u2026", "num_citations": "61\n", "authors": ["490"]}
{"title": "Stability and electronic structure of phosphorus nanotubes\n", "abstract": " First-principles density-functional theory (DFT) calculations of single-walled phosphorus nanotubes constructed from the black-phosphorus (bP) layered allotrope show that their strain energies per atom for radii above 0.6 nm are comparable to the strain energies predicted for experimentally observed single-walled carbon nanotubes with radii of 0.5 nm. Our DFT calculations further predict that the nanotube structures are energetically more stable than the corresponding strips for radii larger than 0.55 nm, suggesting that the synthesis of phosphorus nanotubes (PNTs) could be possible. We find that polarized basis sets including d functions are necessary for accurate treatment of the strain energy, and these basis sets lead to strain energies per atom substantially larger than DFT strain energies of single-walled carbon nanotubes at similar diameters. We have also found that all the PNTs studied are semiconducting\u00a0\u2026", "num_citations": "61\n", "authors": ["490"]}
{"title": "Bounded polynomial randomized consensus\n", "abstract": " In [A&3], Abrahamson presented a solution to the randomized consensus problem of Chor, Israeli and Li [CIL87], without assuming the existence of an atomic coin flip operation. This elegant algorithm uses unbounded memory, and has expected exponential running time. In [AH89], Aspens and Herlihy provide a breakthrough polynomial-time algorithm. However, it too is based on the use of unbounded memory. In this paper, we present a solution to the randomized consensus problem, that is bounded in space and runs in polynomial expected time.", "num_citations": "60\n", "authors": ["490"]}
{"title": "Toward a non-atomic era: l-exclusion as a test case\n", "abstract": " Most of the research in concurrency control has been based on the existence of strong synchronization primitives such as test and set. Following Lamport, recent research promoting the use of weaker primitives,\u201csafe\u201d rather than \u201catomic,\u201d has resulted in construction of atomic registers from safe ones, in the belief that they would be useful tools for process synchronization. We argue that the properties provided by atomic operations may be too powerful, masking core difficulties of problems and leading to inefficiency. We therefore advocate a different approach, to skip the intermediate step of achieving atomicity, and solve problems directly from safe registers. Though it has been shown that \u201ctest and set\u201d cannot be implemented from safe registers, we show how to achieve a fair solution to l-exclusion, a classical concurrency control problem previously solved assuming a very powerful form of atomic \u201ctest and set\u201d. We\u00a0\u2026", "num_citations": "59\n", "authors": ["490"]}
{"title": "Efficient clustering for improving network performance in wireless sensor networks\n", "abstract": " Clustering is an important mechanism in large multi-hop wireless sensor networks for obtaining scalability, reducing energy consumption and achieving better network performance. Most of the research in this area has focused on energy-efficient solutions, but has not thoroughly analyzed the network performance, e.g. in terms of data collection rate and time.               The main objective of this paper is to provide a useful fully-distributed inference algorithm for clustering, based on belief propagation. The algorithm selects cluster heads, based on a unique set of global and local parameters, which finally achieves, under the energy constraints, improved network performance. Evaluation of the algorithm implementation shows an increase in throughput in more than 40% compared to HEED scheme. This advantage is expressed in terms of network reliability, data collection quality and transmission cost.", "num_citations": "58\n", "authors": ["490"]}
{"title": "Byzantine agreement\n", "abstract": " Byzantine Agreement is a paradigm for problems of reliable consistency and synchronization in distributed systems. This paper is a survey of recent work on algorithms and requirements for reaching Byzantine Agreement. The name Byzantine is applied to this work because no assumption is made about the behavior of faulty components except to quantify the maximum number of independent failures handled. Thus algorithms for Byzantine Agreement set a new standard for reliability and availability of distributed systems in an environment of potentially unreliable components. While there are many open questions and much implementation work still remains, the materials surveyed here have established that this standard can be met in an efficient and economical way and that such standards should be sought in all areas of distributed systems.", "num_citations": "56\n", "authors": ["490"]}
{"title": "The separation for general single-layer wiring barriers\n", "abstract": " The problems of placement and routing in integrated circuit design have been gaining increasing attention as fabrication technology advances. Although a variety of those the problems have been proven to be.NP-hard, progress is being made on restricted versions. Tompa, for example, gives a quadratic solution to a particular single layer routing problem ([T]). This paper gives efficient algorithms for finding the separation and the offset in contexts which include his model.", "num_citations": "55\n", "authors": ["490"]}
{"title": "An adaptive totally ordered multicast protocol that tolerates partitions\n", "abstract": " In this paper we present a novel algorithm that implements a totally ordewd multicast primitive for a Totally Ordered Group Communication Service (TO-GCS). TO-GCS is a powerful infrastructure for building distributed fault-tolerant applications, such as totally ordered broadcast, consistent object replication, distributed shared memory, Computer Supported Cooperative Work (CSCW) applications and distributed monitoring and display applications. Our algorithm is adaptive, ie, it is able to dynamically alter the message delivery order in response to changes in the transmission rates of the pticipating processes. This compensates for diffexnces among paaicipant transmission rates and therefore minimizes fluctuations in message delivery latency. Our algorithm is thus useful for soft Eal-time environments where sharp fluctuations in message delivery latency are not acceptable. Our solution provides well-defined\u00a0\u2026", "num_citations": "54\n", "authors": ["490"]}
{"title": "Fixing convergence of Gaussian belief propagation\n", "abstract": " Gaussian belief propagation (GaBP) is an iterative message-passing algorithm for inference in Gaussian graphical models. It is known that when GaBP converges it converges to the correct MAP estimate of the Gaussian random vector and simple sufficient conditions for its convergence have been established. In this paper we develop a double-loop algorithm for forcing convergence of GaBP. Our method computes the correct MAP estimate even in cases where standard GaBP would not have converged. We further extend this construction to compute least-squares solutions of over-constrained linear systems. We believe that our construction has numerous applications, since the GaBP algorithm is linked to solution of linear systems of equations, which is a fundamental problem in computer science and engineering. As a case study, we discuss the linear detection problem. We show that using our new construction\u00a0\u2026", "num_citations": "52\n", "authors": ["490"]}
{"title": "Synchronous Byzantine Agreement with Expected O(1) Rounds, Expected  Communication, and Optimal Resilience\n", "abstract": " We present new protocols for Byzantine agreement in the synchronous and authenticated setting, tolerating the optimal number of f faults among  parties. Our protocols achieve an expected O(1) round complexity and an expected  communication complexity. The exact round complexity in expectation is 10 for a static adversary and 16 for a strongly rushing adaptive adversary. For comparison, previous protocols in the same setting require expected 29 rounds.", "num_citations": "51\n", "authors": ["490"]}
{"title": "Distributed large scale network utility maximization\n", "abstract": " Recent work by Zymnis et al. proposes an efficient primal-dual interior-point method, using a truncated Newton method, for solving the network utility maximization (NUM) problem. This method has shown superior performance relative to the traditional dual-decomposition approach. Other recent work by Bickson et al. shows how to compute efficiently and distributively the Newton step, which is the main computational bottleneck of the Newton method, utilizing the Gaussian belief propagation algorithm. In the current work, we combine both approaches to create an efficient distributed algorithm for solving the NUM problem. Unlike the work of Zymnis, which uses a centralized approach, our new algorithm is easily distributed. Using an empirical evaluation we show that our new method outperforms previous approaches, including the truncated Newton method and dual-decomposition methods. As an additional\u00a0\u2026", "num_citations": "51\n", "authors": ["490"]}
{"title": "Gaussian belief propagation based multiuser detection\n", "abstract": " In this work, we present a novel construction for solving the linear multiuser detection problem using the Gaussian Belief Propagation algorithm. Our algorithm yields an efficient, iterative and distributed implementation of the MMSE detector. Compared to our previous formulation, the new algorithm offers a reduction in memory requirements, the number of computational steps, and the number of messages passed. We prove that a detection method recently proposed by Montanari et al. is an instance of ours, and we provide new convergence results applicable to both.", "num_citations": "51\n", "authors": ["490"]}
{"title": "Linear time byzantine self-stabilizing clock synchronization\n", "abstract": " Awareness of the need for robustness in distributed systems increases as distributed systems become an integral part of day-to-day systems. Tolerating Byzantine faults and possessing self-stabilizing features are sensible and important requirements of distributed systems in general, and of a fundamental task such as clock synchronization in particular. There are efficient solutions for Byzantine non-stabilizing clock synchronization as well as for non-Byzantine self-stabilizing clock synchronization. In contrast, current Byzantine self-stabilizing clock synchronization algorithms have exponential convergence time and are thus impractical. We present a linear time Byzantine self-stabilizing clock synchronization algorithm, which thus makes this task feasible. Our deterministic clock synchronization algorithm is based on the observation that all clock synchronization algorithms require events for re-synchronizing\u00a0\u2026", "num_citations": "51\n", "authors": ["490"]}
{"title": "Scheduling precedence graphs of bounded height\n", "abstract": " The existence of a schedule for a partially ordered set of unit length tasks on m identical processors is known to be NP-complete (J. D. Ullman, NP-complete scheduling problems, J. Comput. System Sci., 10 (1975), 384\u2013393). The problem remains NP-complete even if we restrict the precedence graph to be of height bounded by a constant. (J. K. Lenkstra and A. H. G. Rinnooy Kan, Complexity of scheduling under precedence constraints, Operations Res., 26 (1978), 22\u201335; D. Dolev and M. K. Warmuth, \u201cScheduling Flat Graphs,\u201d IBM Research Report RJ 3398, 1982). In these NP-completeness proofs the upper bound on the number of available processors varies with the problem instance. We present a polynomial algorithm for the case where the upper bound on the number of available processors and the height of the precedence graph are both constants.", "num_citations": "51\n", "authors": ["490"]}
{"title": "Searching complex networks efficiently with minimal information\n", "abstract": " The ability to perform an efficient search in a complex network is of great importance in real-world systems. We suggest a method for searching for nodes when the source does not possess full information about the shortest path to the destination. By assigning new short names to nodes we are able to reduce significantly the amount of information stored at the nodes, such that the required memory needed scales only logarithmically with the network size; yet we succeed in finding the destination node through paths very close in distance to the shortest ones. The method is shown to perform particularly well on scale-free networks, exploiting its unique characteristics. This, together with other properties, makes our method extremely useful for realistic systems such as the Internet.", "num_citations": "50\n", "authors": ["490"]}
{"title": "Scheduling flat graphs\n", "abstract": " The problem of scheduling a partially ordered set of unit length tasks on m identical processors is known to be NP-complete. There are efficient algorithms for only a few special cases of this problem. In this paper we analyze the effect of the structure of the precedence graph and the availability of the processors on the construction of optimal schedules. We prove that to find an optimal schedule it suffices to consider at each step only initial tasks which belong to the  highest components of the precedence graph. This result reduces the number of cases we have to check during the construction of an optimal schedule. Our method leads to polynomial algorithms if the number of processors is fixed and the precedence graph has a certain form. In particular, if the precedence graph contains only intrees and outtrees, this result leads to linear algorithms for finding an optimal schedule on two or three processors.", "num_citations": "50\n", "authors": ["490"]}
{"title": "Group communication as an infrastructure for distributed system management\n", "abstract": " In the past, system management tools for computer systems were oriented towards managing a single computer with, possibly, many users. When the networked system concept became widespread, centralized solutions such as the Network Information Service (NIS) were developed to help the system manager to control a network of workstations. Today, when many sites contain hundreds of workstations, these solutions may no longer be adequate. This paper proposes the usage of techniques, developed for group communication and database replication, for distributed cluster management. We show how group communication can be exploited to provide three classes of frequently needed operations: simultaneous execution of the same operation in a group of workstations; software installation in multiple workstations; and consistent network table management (improving the consistency of NIS).", "num_citations": "49\n", "authors": ["490"]}
{"title": "CONGRESS: connection-oriented group address resolution services\n", "abstract": " This paper presents CONGRESS: a connection-oriented group- address resolution service, and its applications. CONGRESS is an efficient native ATM protocol for resolution and management of multicast group addresses in an ATM WAN. It complements the native ATM multicast mechanisms. CONGRESS resolves multicast group addresses and maintains their membership for applications. It is not designed to handle the applications' data-exchange. Applications can use the resolved addresses returned by CONGRESS, in order to implement a many-to-many communication model. CONGRESS employs hierarchically organized servers in order to be scalable. CONGRESS' hierarchy is naturally mapped onto the ATM private network to network interface peer group hierarchy. CONGRESS communication overhead for management of a single multicast group is linear in the size of the group. Apart from facilitating\u00a0\u2026", "num_citations": "48\n", "authors": ["490"]}
{"title": "Distributed commit with bounded waiting\n", "abstract": " Two-Phase Commit and other distributed commit protocols provide a method to commit changes while preserving consistency in a distributed database. These protocols can cope with various failures occurring in the system. But in case of failure they do not guarantee termination (of protocol processing) within a given time: sometimes the protocol requires waiting for a failed processor to be returned to operation. It happens that a straightforward use of timeouts in a distributed system is fraught with unexpected peril and does not provide an easy solution to the problem. In this paper we will combine Byzantine Agreement with Two-Phase Commit, using observations of Lamport to provide a method to cope with failure within a given time bound. An extra benefit of this combination of ideas is that it handles undetected and transient faults as well as the more usual system or processor down faults handled by other distributed commit protocols.", "num_citations": "48\n", "authors": ["490"]}
{"title": "Anonymous time synchronization method\n", "abstract": " A method is provided for synchronizing a local time maintained at a node within a network architecture with a reference time. Bursts of synchronization messages containing reference time stamps are transmitted over a network or communication link according to a predetermined protocol. A node to be synchronized receives and time stamps the messages. Thus, times according to a first time scale and a second time scale are obtained, and the protocol defines temporal relationships between certain ones of the times. In accordance with the predetermined protocol, the node determines a difference between a first time according to one of the time scales and a time related to second and third times according to the other time scale. The node then updates its local time based on the difference between the first time and the related time. This synchronization method provides a well-defined upper bound of\u00a0\u2026", "num_citations": "47\n", "authors": ["490"]}
{"title": "Communication complexity of byzantine agreement, revisited\n", "abstract": " As Byzantine Agreement (BA) protocols find application in large-scale decentralized cryptocurrencies, an increasingly important problem is to design BA protocols with improved communication complexity. A few existing works have shown how to achieve subquadratic BA under an adaptive adversary. Intriguingly, they all make a common relaxation about the adaptivity of the attacker, that is, if an honest node sends a message and then gets corrupted in some round, the adversary cannot erase the message that was already sent-henceforth we say that such an adversary cannot perform\" after-the-fact removal\". By contrast, many (super-) quadratic BA protocols in the literature can tolerate after-the-fact removal. In this paper, we first prove that disallowing after-the-fact removal is necessary for achieving subquadratic-communication BA.", "num_citations": "46\n", "authors": ["490"]}
{"title": "Distributed protocols for leader election: A game-theoretic perspective\n", "abstract": " We do a game-theoretic analysis of leader election, under the assumption that each agent prefers to have some leader than to have no leader at all. We show that it is possible to obtain a fair Nash equilibrium, where each agent has an equal probability of being elected leader, in a completely connected network, in a bidirectional ring, and a unidirectional ring, in the synchronous setting. In the asynchronous setting, Nash equilibrium is not quite the right solution concept. Rather, we must consider ex post Nash equilibrium; this means that we have a Nash equilibrium no matter what a scheduling adversary does. We show that ex post Nash equilibrium is attainable in the asynchronous setting in all the networks we consider, using a protocol with bounded running time. However, in the asynchronous setting, we require that n\u2009>\u20092. We can get a fair \u03b5-Nash equilibrium if n\u2009=\u20092 in the asynchronous setting, under\u00a0\u2026", "num_citations": "46\n", "authors": ["490"]}
{"title": "Flipping coins in many pockets (Byzantine agreement on uniformly random values)\n", "abstract": " It was recently shown by Michael Rabin that a sequence of random 0-1 values, prepared and distributed by a trusted \"dealer,\" can be used to achieve Byzantine agreement in constant expected time in a network of processors. A natural question is whether it is possible to generate these values uniformly at random within the network. In this paper we present a cryptography based protocol for agreernent on a 0-1 randona value, if less than half of the processors are faulty. In fact the protocol allows uniform sampling from any finite set, and thus solves the problem of choosing a network leader uniformly at random. The protocol is usable both when all the communication is via \"broadcast,\" in which case it needs three rounds of information exchange, and when each pair of processors communicate on a private line, in which case it needs 3t + 3 rounds, where t is the number of faulty proccssors. The protocol remains valid\u00a0\u2026", "num_citations": "46\n", "authors": ["490"]}
{"title": "Asynchronous byzantine consensus\n", "abstract": " Reaching agreement in an asynchronous environment is essential to guarantee consistency in distributed data processing. All previous asynchronous protocols were either probabilistic or they assumed a fail-stop mode of failure. The deterministic protocol presented in this paper reaches a Strong Byzantine Agreement in a system of asynchronous processors; and therefore can sustain arbitrary faults. In our model, processors can be completely asynchronous, though the communication network has the property that a message being sent by a correctly operating processor to a set of processors will reach its destinations within a predetermined period \u0394. Additional results presented in the paper prove that in the above model one cannot reach a consensus within a bounded time. A correctly operating processor should wait to receive messages from other processors before making a decision. This result holds also for\u00a0\u2026", "num_citations": "46\n", "authors": ["490"]}
{"title": "A highly available application in the Transis environment\n", "abstract": " This paper presents a typical replicated application in a distributed system. The application was developed on top of Transis, a reliable and efficient transport layer protocol. The basic properties of the protocol and the advantages of using Transis as the transport layer are discussed. The algorithms used in this application can lead to better solutions in the area of distributed transaction systems and replicated databases.", "num_citations": "44\n", "authors": ["490"]}
{"title": "Membership algorithms in broadcast domains\n", "abstract": " This paper describes a membership protocol that maintains a consistent membership view within a set of connected machines. The protocol operates within an asynchronous environment with arbitrary crash faults. It is well known that solving the membership problem in an asynchronous environment when faults may be present is impossible. In order to circumvent this di culty, our approach rarely extracts from the membership live (but not active) machines unjustfully. The bene t is that our procotol always terminates within a nite time. In addition, if a machine is inadvertently taken out of the membership, it can re-join it right away using the join protocol. Despite the asynchrony, the protocol provides virtually synchronous con guration changes to the application layer.All of the previous membership algorithms handle the joining of single machines only, whereas the protocol presented here supports partitions and re-merges. When partitions and re-merging occur, the protocol provides the application with exact information about the status of the system, yet does not disrupt the regular ow of messages in the system.", "num_citations": "44\n", "authors": ["490"]}
{"title": "The design of the Transis system\n", "abstract": " Transis is a high availability distributed system, being developed in the Hebrew University. It supports reliable group communication for high availability applications. The system provides enhanced services for information dissemination and replication in a dynamic environment where machines may crash, for arbitrarily long periods, and may recover; where the network may partition and re-merge. Transis contains novel protocols for reliable message delivery, it optimizes the performance for existing network hardware, and offers a variety of different handles to upper applications. The paper presents the experience gained in the design and the implementation of the Transis communication subsystem.", "num_citations": "43\n", "authors": ["490"]}
{"title": "Tapping into the fountain of CPUs: on operating system support for programmable devices\n", "abstract": " The constant race for faster and more powerful CPUs is drawing to a close. No longer is it feasible to significantly increase the speed of the CPU without paying a crushing penalty in power consumption and production costs. Instead of increasing single thread performance, the industry is turning to multiple CPU threads or cores (such as SMT and CMP) and heterogeneous CPU architectures (such as the Cell Broadband Engine). While this is a step in the right direction, in every modern PC there is a wealth of untapped compute resources. The NIC has a CPU; the disk controller is programmable; some high-end graphics adaptersare already more powerful than host CPUs. Some of these CPUs can perform some functions more efficiently than the host CPUs. Our operating systems and programming abstractions should be expanded to let applications tap into these computational resources and make the best use of\u00a0\u2026", "num_citations": "40\n", "authors": ["490"]}
{"title": "Enhanced calibration technique for RSSI-based ranging in body area networks\n", "abstract": " Indoor positioning systems based on Received Signal Strength Indicator (RSSI) in Wireless Sensor Networks (WSNs) are commonly used. The position accuracy in these systems is highly affected by the wireless medium variability, and therefore, a precise calibration is necessary to translate the power measurements to corresponding distance between each pair of nodes. In this paper, we propose a calibration scheme that is tailored to Body Area Networks (BANs) applications. The a priori knowledge about the environment conditions in these applications can increase the accuracy of the localization system, improve its robustness to interference, and reduce the number of RSSI measurements which are required for the calibration process compared to the traditional calibration methods. We define a criterion to obtain the calibration scheme using different a priori knowledge for both the mapping table and the path\u00a0\u2026", "num_citations": "39\n", "authors": ["490"]}
{"title": "Linear detection via belief propagation\n", "abstract": " In this paper, the paradigm of linear detection is reformulated as a Gaussian belief propagation (GaBP) scheme, without resorting to direct matrix inversion. The derived iterative framework allows for a distributive message-passing implementation of this important class of sub-optimal tractable estimators. The properties of GaBP-based linear detection are addressed, while its faster convergence, in comparison with conventional iterative solution methods, is demonstrated experimentally.", "num_citations": "38\n", "authors": ["490"]}
{"title": "Consensus under unreliable transmission\n", "abstract": " Under many circumstances, a correct processor in a distributed system can reach a general consensus before performing some unique tasks. Notable examples include the two-phase commitment in a distributed database system, the whereabouts of a replicated file in a distributed environment, and a landing task controlled by a flight path finding system. Such a unanimity problem, as studied by Lamport [4, 6], is called Byzantine Agreement (BA)[2, 4, 6, 8]. A closely related sub-problem, the Consensus problem, has been extensively studied [5, 7, 9] as well. In light of the above developments, this study attempts to derive a solution to the Consensus problem. Defining such a problem involves making all correct processors in an n-processor fully connected network to reach a common agreement. Each processor selects an initial value and, then, communicates with other processors by exchanging messages. The\u00a0\u2026", "num_citations": "38\n", "authors": ["490"]}
{"title": "Computer program product for use with a network node for performing anonymous time synchronization in a network\n", "abstract": " A computer program product, such as a floppy disk with pre-recorded software, is provided. The computer program product is for use with a computer or processing system which is to function as a node within a network. Synchronization of a local time maintained at the node with a reference time is facilitated through execution of the prerecorded software by the node. Bursts of synchronization messages containing reference time stamps are transmitted over the network, or over a communication link, according to a predetermined protocol. The node receives and time stamps the messages. Thus, times according to a first time scale and a second time scale are obtained. The protocol defines temporal relationships between certain ones of the times. In accordance with the protocol, the node determines a difference between a first time according to one of the time scales and a time related to second and third times\u00a0\u2026", "num_citations": "38\n", "authors": ["490"]}
{"title": "Continuous close-proximity rssi-based tracking in wireless sensor networks\n", "abstract": " In this paper we develop a continuous high-precision tracking system based on Received Signal Strength Indicator(RSSI) measurements for small ranges. The proposed system uses minimal number of sensor nodes with RSSI capabilities to track a moving object in close-proximity and high transmission rate. The close-proximity enables conversion of RSSI measurements to range estimates and the high transmission rate enables continuous tracking of the moving object. The RSSI-based tracking system includes calibration, range estimation, location estimation and refinement. We use advanced statistical and signal processing methods to mitigate channel distortion and packet loss. The system is evaluated in indoor settings and achieves tracking resolution of few centimeters. Therefore, it becomes the motion trackers of notice in many applications.", "num_citations": "37\n", "authors": ["490"]}
{"title": "Multiparty communication complexity\n", "abstract": " \u041b given Boolean function has its input distributed among many parties. The aim is to determine which parties to talk to and what information to exchange with each of them in order to evaluate the function while minimizing the total communication. This paper shows that it is possible to obtain the Boolean answer deterministically with only a polynomial increase in communication with respect to the information lower bound given by the nondeterministic communication complexity of the function.", "num_citations": "36\n", "authors": ["490"]}
{"title": "Self-stabilizing byzantine digital clock synchronization\n", "abstract": " We present a scheme that achieves self-stabilizing Byzantine digital clock synchronization assuming a \u201csynchronous\u201d system. This synchronicity is established by the assumption of a common \u201cbeat\u201d delivered with a regularity in the order of the network message delay, thus enabling the nodes to execute in lock-step. The system can be subjected to severe transient failures with a permanent presence of Byzantine nodes. Our algorithm guarantees eventually synchronized digital clock counters, i.e. common increasing integer counters associated with each beat. We then show how to achieve regular clock synchronization, progressing at real-time rate and with high granularity, from the synchronized digital clock counters.               There is one previous self-stabilizing Byzantine clock synchronization algorithm, which also converges in linear time (relying on an underlying pulse mechanism), but it requires to\u00a0\u2026", "num_citations": "35\n", "authors": ["490"]}
{"title": "Neighborhood preserving hashing and approximate queries\n", "abstract": " Let  be a dictionary. We look for efficient data structures and algorithms to solve the following  approximate query problem: Given a query  list all words  that are close to u in Hamming distance.The problem reduces to the following combinatorial problem: Hash the vertices of the n-dimensional hypercube into buckets so that (1) the c-neighborhood of each vertex is mapped into at most k buckets and (2) no bucket is too large.Lower and upper bounds are given for the tradeoff between k and the size of the largest bucket. These results are used to derive bounds for the approximate query problem.", "num_citations": "35\n", "authors": ["490"]}
{"title": "Efficient synchronous byzantine consensus\n", "abstract": " We present new protocols for Byzantine state machine replication and Byzantine agreement in the synchronous and authenticated setting. The celebrated PBFT state machine replication protocol tolerates  Byzantine faults in an asynchronous setting using  replicas, and has since been studied or deployed by numerous works. In this work, we improve the Byzantine fault tolerance threshold to  by utilizing a relaxed synchrony assumption. We present a synchronous state machine replication protocol that commits a decision every 3 rounds in the common case. The key challenge is to ensure quorum intersection at one honest replica. Our solution is to rely on the synchrony assumption to form a post-commit quorum of size , which intersects at  replicas with any pre-commit quorums of size . Our protocol also solves synchronous authenticated Byzantine agreement in expected 8 rounds. The best previous solution (Katz and Koo, 2006) requires expected 24 rounds. Our protocols may be applied to build Byzantine fault tolerant systems or improve cryptographic protocols such as cryptocurrencies when synchrony can be assumed.", "num_citations": "33\n", "authors": ["490"]}
{"title": "On self-stabilizing synchronous actions despite byzantine attacks\n", "abstract": " Consider a distributed network of n nodes that is connected to a global source of \u201cbeats\u201d. All nodes receive the \u201cbeats\u201d simultaneously, and operate in lock-step. A scheme that produces a \u201cpulse\u201d every Cycle beats is shown. That is, the nodes agree on \u201cspecial beats\u201d, which are spaced Cycle beats apart. Given such a scheme, a clock synchronization algorithm is built. The \u201cpulsing\u201d scheme is self-stabilized despite any transient faults and the continuous presence of up to                  Byzantin nodes. Therefore, the clock synchronization built on top of the \u201cpulse\u201d is highly fault tolerant. In addition, a highly fault tolerant general stabilizer algorithm is constructed on top of the \u201cpulse\u201d mechanism.               Previous clock synchronization solutions, operating in the exact same model as this one, either support  and converge in linear time, or support  and have exponential convergence time that also\u00a0\u2026", "num_citations": "33\n", "authors": ["490"]}
{"title": "Asynchronous resource discovery\n", "abstract": " Consider a dynamic, large-scale communication infrastructure (e.g., the Internet) where nodes (e.g., in a peer-to-peer system) can communicate only with nodes whose id (e.g., IP address) are known to them. One of the basic building blocks of such a distributed system is resource discovery\u2014efficiently discovering the ids of the nodes that currently exist in the system. We present both upper and lower bounds for the Resource Discovery problem. For the original problem raised by Harchol-Balter, Leighton, and Lewin [M. Harchol-Balter, T. Leighton, D. Lewin, Resource discovery in distributed networks, in: Proceedings of the Eighteenth Annual ACM Symposium on Principles of Distributed Computing, ACM Press, 1999, pp. 229\u2013237] we present an \u03a9(n\u00a0log\u00a0n) message complexity lower bound for asynchronous networks whose size is unknown. For this model, we give an asymptotically message optimal algorithm that\u00a0\u2026", "num_citations": "33\n", "authors": ["490"]}
{"title": "Efficient state transfer in partitionable environments\n", "abstract": " Object replication is one of the most useful techniques in distributed computing because it facilitates fault-tolerance and increases the availability of distributed services. Consistent replication is the focus of traditional distributed database applications as well as of Computer Supported Cooperative Work applications. Other applications that can take advantage of consistent object replication are those operating in a mobile environment. However, in asynchronous environments prone to machines and communication link failures, disconnected replicas may find themselves with different states. The State Transfer problem is to bring such replicas to a consistent state when they re-connect again. Our work presents an efficient State Transfer layer that may serve as a building block in consistent object replication protocols. The traditional Virtual Synchrony model does not provide sufficient services and guarantees in order to implement the State Transfer layer efficiently. Our solution i...", "num_citations": "31\n", "authors": ["490"]}
{"title": "Self-stabilization of byzantine protocols\n", "abstract": " Awareness of the need for robustness in distributed systems increases as distributed systems become integral parts of day-to-day systems. Self-stabilizing while tolerating ongoing Byzantine faults are wishful properties of a distributed system. Many distributed tasks (e.g. clock synchronization) possess efficient non-stabilizing solutions tolerating Byzantine faults or conversely non-Byzantine but self-stabilizing solutions. In contrast, designing algorithms that self-stabilize while at the same time tolerating an eventual fraction of permanent Byzantine failures present a special challenge due to the \u201cambition\u201d of malicious nodes to hamper stabilization if the systems tries to recover from a corrupted state. This difficulty might be indicated by the remarkably few algorithms that are resilient to both fault models. We present the first scheme that takes a Byzantine distributed algorithm and produces its self-stabilizing\u00a0\u2026", "num_citations": "30\n", "authors": ["490"]}
{"title": "Consensus algorithms with one-bit messages\n", "abstract": " Three main parameters characterize the efficiency of algorithms that solve the Consensus Problem: the ratio between the total number of processors and the maximum number of faulty processors (n andt, respectively), the number of rounds, and the upper bound on the size of any message. In this paper we present a trade-off between the number of faulty processors and the number of rounds by exhibiting a family of algorithms in which processors communicate by one-bit messages. Letk be a positive integer and lets=t 1/k . The family includes algorithms where the number of processors is less than  , and the number of rounds is less than  . This family is based on a very simple algorithm with the following complexity: (2t+1)(t+1) processors,t+1 rounds, and one-bit message size.", "num_citations": "30\n", "authors": ["490"]}
{"title": "A gaussian belief propagation solver for large scale support vector machines\n", "abstract": " Support vector machines (SVMs) are an extremely successful type of classification and regression algorithms. Building an SVM entails solving a constrained convex quadratic programming problem, which is quadratic in the number of training samples. We introduce an efficient parallel implementation of an support vector regression solver, based on the Gaussian Belief Propagation algorithm (GaBP). In this paper, we demonstrate that methods from the complex system domain could be utilized for performing efficient distributed computation. We compare the proposed algorithm to previously proposed distributed and single-node SVM solvers. Our comparison shows that the proposed algorithm is just as accurate as these solvers, while being significantly faster, especially for large datasets. We demonstrate scalability of the proposed algorithm to up to 1,024 computing nodes and hundreds of thousands of data points using an IBM Blue Gene supercomputer. As far as we know, our work is the largest parallel implementation of belief propagation ever done, demonstrating the applicability of this algorithm for large scale distributed computing systems.", "num_citations": "28\n", "authors": ["490"]}
{"title": "Byzantine self-stabilizing pulse in a bounded-delay model\n", "abstract": " \u201cPulse Synchronization\u201d intends to invoke a recurring distributed event at the different nodes, of a distributed system as simultaneously as possible and with a frequency that matches a predetermined regularity. This paper shows how to achieve that goal when the system is facing both transient and permanent (Byzantine) failures.             Byzantine nodes might incessantly try to de-synchronize the correct nodes. Transient failures might throw the system into an arbitrary state in which correct nodes have no common notion what-so-ever, such as time or round numbers, and thus cannot use any aspect of their own local states to infer anything about the states of other correct nodes. The algorithm we present here guarantees that eventually all correct nodes will invoke their pulses within a very short time interval of each other and will do so regularly.             The problem of pulse synchronization was recently solved\u00a0\u2026", "num_citations": "28\n", "authors": ["490"]}
{"title": "Highly available cluster: A case study\n", "abstract": " The methodology and design of a system that provides highly available data in a cluster is presented. A highly available cluster consists of multiple machines interconnected by a common bus. Data is replicated at a primary and one or more backup machines. Data is accessed at the primary, using a location independent mechanism that ensures data integrity. If the primary copy of the data fails, access is recovered by switching to a backup copy. Switchover is transparent to the application, hence called seamless switchover. The fault model is fail-stop. The entire cluster is resilient to at least single failures. Designating data as highly available is selective in scope, and the overhead of replication and recovery is incurred only by applications that access highly available data. An experimental prototype was implemented using IBM AS/400 machines and a high-speed bus with fiber-optic links.< >", "num_citations": "28\n", "authors": ["490"]}
{"title": "Finding the neighborhood of a query in a dictionary\n", "abstract": " Many applications require the retrieval of all words from a fixed dictionary D, that are 'close' to some input string. The paper defines a theoretical framework to study the performance of algorithms for this problem, and provides a basic algorithmic approach. It is shown that a certain class of algorithms, D-oblivious algorithms, can not be optimal both in space and time. This is done by proving a lower bound on the tradeoff between the space and time complexities of D-oblivious algorithms. Several algorithms for this problem are presented, and their performance is compared to that of Ispell, the standard speller of Unix. On the Webster English dictionary the algorithms are shown to be faster than 'Ispell' by a significant factor, while incurring only a small cost in space.< >", "num_citations": "28\n", "authors": ["490"]}
{"title": "Processing system for use as a network node for performing anonymous time synchronization in a network\n", "abstract": " A network node, such as a computer or processing system, is provided, for use within a network, the node including program code for synchronizing a local time maintained at the node with a reference time. Bursts of synchronization messages containing reference time stamps are transmitted over the network, or over a communication link, according to a predetermined protocol. The node receives and time stamps the messages. Thus, times according to a first time scale and a second time scale are obtained. The protocol defines temporal relationships between certain ones of the times. In accordance with the protocol, the node determines a difference between a first time according to one of the time scales and a time related to second and third times according to the other time scale. The node then updates its local time based on the difference. This synchronization method provides a well-defined upper bound of\u00a0\u2026", "num_citations": "26\n", "authors": ["490"]}
{"title": "On linear area embedding of planar graphs\n", "abstract": " Planar embedding with minimal area of graphs on an integer grid is one of the major issues in VLSI. Valiant V gave an algorithm to construct a planar embedding for trees in linear area he also proved that there are planar graphs that require quadratic area. We give an algorithm to embed outerplanar graphs in linear area. We extend this algorithm to work for every planar graph that has the following property for every vertex there exists a path of length less than K to the exterior face, where K is a constant. Finally, finding a minimal embedding area is shown to be NP-complete for forests, and hence more general types of graphs. AuthorDescriptors:", "num_citations": "26\n", "authors": ["490"]}
{"title": "Synchronous counting and computational algorithm design\n", "abstract": " Consider a complete communication network on n nodes. In synchronous 2-counting, the nodes receive a common clock pulse and they have to agree on which pulses are \u201codd\u201d and which are \u201ceven\u201d. Furthermore, the solution needs to be self-stabilising (reaching correct operation from any initial state) and tolerate f Byzantine failures (nodes that send arbitrary misinformation). Prior algorithms either require a source of random bits or a large number of states per node. In this work, we give fast state-optimal deterministic algorithms for the first non-trivial case f= 1. To obtain these algorithms, we develop and evaluate two different techniques for algorithm synthesis. Both are based on casting the synthesis problem as a propositional satisfiability (SAT) problem; a direct encoding is efficient for synthesising time-optimal algorithms, while an approach based on counter-example guided abstraction refinement discovers non\u00a0\u2026", "num_citations": "25\n", "authors": ["490"]}
{"title": "Fault-tolerant algorithms for tick-generation in asynchronous logic: Robust pulse generation\n", "abstract": " Today\u2019s hardware technology presents a new challenge in designing robust systems. Deep submicron VLSI technology introduces transient and permanent faults that were never considered in low-level system designs in the past. Still, robustness of that part of the system is crucial and needs to be guaranteed for any successful product. Distributed systems, on the other hand, have been dealing with similar issues for decades. However, neither the basic abstractions nor the complexity of contemporary fault-tolerant distributed algorithms match the peculiarities of hardware implementations. This article is intended to be part of an attempt striving to bridge over this gap between theory and practice for the clock synchronization problem. Solving this task sufficiently well will allow to build an ultra-robust high-precision clocking system for hardware designs like systems-on-chips in critical applications. As our first building\u00a0\u2026", "num_citations": "25\n", "authors": ["490"]}
{"title": "A partial equivalence between shared-memory and message-passing in an asynchronous fail-stop distributed environment\n", "abstract": " This paper presents a schematic algorithm for distributed systems. This schematic algorithm uses a \u201cblack-box\u201d procedure for communication, the output of which must meet two requirements: a global-order requirement and a deadlock-free requirement. This algorithm is valid in any distributed system model that can provide such a communication procedure that complies with these requirements. Two such models exist in an asynchronous fail-stop environment: one in the shared-memory model and one in the message-passing model. The implementation of the block-box procedure in these models enables us to translate existing algorithms between the two models whenever these algorithms are based on the schematic algorithm.               We demonstrate this idea in two ways. First, we present a randomized algorithm for the consensus problem in the message-passing model based on the algorithm of\u00a0\u2026", "num_citations": "24\n", "authors": ["490"]}
{"title": "Families of consensus algorithms\n", "abstract": " Three main parameters characterize the efficiency of algorithms that solve the Consensus Problem. The ratio between the total number of processors and the maximum number of faulty processors (n and t, respectively), the number of rounds, and the size of any single message. Lower bounds exist for each one of the three. In this paper we present two families of algorithms, each achieving the lower bound for one parameter and a trade-off between the other two. The first family includes algorithms where, given an integer k, the algorithm always requires the minimal possible number of rounds (t+1), with n=k(3t+1) processors and messages of size at most t               O(t/k). To the second family belong algorithms in which all messages are of one bit size, the number of processors is t                                O((k+1)/k)                and the number of rounds is t+t                                O               ((k\u22121)/k). These two families are\u00a0\u2026", "num_citations": "24\n", "authors": ["490"]}
{"title": "A simple model for agreement in distributed systems\n", "abstract": " The goal of our research into fault tolerant algorithms has been to discover and prove the best results possible in any environment consisting of processing elements that communicate by means of messages via some communication medium. Thus, rather than settle for the existence of a practical algorithm that accomplishes some task, we explore the whole range of practical and impractical algorithms that could exist, attempting to establish trade-offs and lower bounds that explain why some problems are inherently more difficult to solve than others.Rather than settle for with algorithms that tolerate a single fault of a type that is deemed likely to occur~ the ultimate aim of our explorations is to provide the best possible multiple fault tolerant algorithms and to provide families of solutions to various problems, so that the best solution for each context is available. Thus we are not satisfied with tolerating a single or a simple\u00a0\u2026", "num_citations": "23\n", "authors": ["490"]}
{"title": "Peer-to-peer secure multi-party numerical computation\n", "abstract": " We propose an efficient framework for enabling secure multi-party numerical computations in a Peer-to-Peer network. This problem arises in a range of applications such as collaborative filtering, distributed computation of trust and reputation, monitoring and numerous other tasks, where the computing nodes would like to preserve the privacy of their inputs while performing a joint computation of a certain function. Although there is a rich literature in the field of distributed systems security concerning secure multi-party computation, in practice it is hard to deploy those methods in very large scale Peer-to-Peer networks. In this work, we examine several possible approaches and discuss their feasibility. Among the possible approaches, we identify a single approach which is both scalable and theoretically secure. An additional novel contribution is that we show how to compute the neighborhood based collaborative\u00a0\u2026", "num_citations": "22\n", "authors": ["490"]}
{"title": "Atomic broadcast in a real-time environment\n", "abstract": " This paper presents a model for real-time distributed systems that is intermediate in complexity between the simple, perfectly synchronous model in which there are rounds of communication exchange among processors in a completely connected network and an asynchronous model in which there is no reasonable upper bound on the time required for transmission and processing of messages. In this model algorithms are described for atomic broadcast that can be used to update synchronous replicated storage, a distributed storage that displays the same contents at every correct processor as of any clock time. The algorithms are all based on a simple communication paradigm and differ only in the additional checking required to tolerate different classes of failures.", "num_citations": "22\n", "authors": ["490"]}
{"title": "Distributed Kalman filter via Gaussian belief propagation\n", "abstract": " Recent result shows how to compute distributively and efficiently the linear MMSE for the multiuser detection problem, using the Gaussian BP algorithm. In the current work, we extend this construction, and show that operating this algorithm twice on the matching inputs, has several interesting interpretations. First, we show equivalence to computing one iteration of the Kalman filter. Second, we show that the Kalman filter is a special case of the Gaussian information bottleneck algorithm, when the weight parameter beta = 1. Third, we discuss the relation to the Affine-scaling interior-point method and show it is a special case of Kalman filter. Besides of the theoretical interest of this linking estimation, compression/clustering and optimization, we allow a single distributed implementation of those algorithms, which is a highly practical and important task in sensor and mobile ad-hoc networks. Application to numerous\u00a0\u2026", "num_citations": "21\n", "authors": ["490"]}
{"title": "Self-stabilizing byzantine agreement\n", "abstract": " Byzantine agreement algorithms typically assume implicit initial state consistency and synchronization among the correct nodes and then operate in coordinated rounds of information exchange to reach agreement based on the input values. The implicit initial assumptions enable correct nodes to infer about the progression of the algorithm at other nodes from their local state. This paper considers a more severe fault model than permanent Byzantine failures, one in which the system can in addition be subject to severe transient failures that can temporarily throw the system out of its assumption boundaries. When the system eventually returns to behave according to the presumed assumptions it may be in an arbitrary state in which any synchronization among the nodes might be lost, and each node may be at an arbitrary state. We present a self-stabilizing Byzantine agreement algorithm that reaches agreement\u00a0\u2026", "num_citations": "21\n", "authors": ["490"]}
{"title": "Total ordering of messages in broadcast domains\n", "abstract": " This paper presents the construction of a multicast service, called agreed multicast, that guarantees that messages arrive reliably and in the same total-order to all their destinations. ToTo, a novel family of protocols, implement the agreed multicast service of Transis, a communication sub-system for the High Availability project, currently developed at the Hebrew University of Jerusalem. This service is desired in distributed systems, and supports high level coordination among groups of processes in distributed applications. The ToTo protocols are genuinely symmetric. They are fairly simple and do not bear a signi cant processing burden. The cost of symmetric total ordering protocols can be measured by the number of messages from di erent machines needed to agree on the next set of messages to be delivered in total order. The ToTo protocols provide early delivery latency, and require as little as n2 messages for delivery. Thus, we optimize the time that elapses from the point a message is ready to be sent until it is ready to be delivered at the sender machine. Experimental results match our prediction performance-model, and prove up to O (log (n)) speedup over previous protocols.", "num_citations": "21\n", "authors": ["490"]}
{"title": "Fault identification via nonparametric belief propagation\n", "abstract": " We consider the problem of identifying a pattern of faults from a set of noisy linear measurements. Unfortunately, maximum a posteriori (MAP) probability estimation of the fault pattern is computationally intractable. To solve the fault identification problem, we propose a nonparametric belief propagation (NBP) approach. We show empirically that our belief propagation solver is more accurate than recent state-of-the-art algorithms including interior point methods and semidefinite programming. Our superior performance is explained by the fact that we take into account both the binary nature of the individual faults and the sparsity of the fault pattern arising from their rarity.", "num_citations": "20\n", "authors": ["490"]}
{"title": "Belief propagation in wireless sensor networks-a practical approach\n", "abstract": " Distributed inference schemes for detection, estimation and learning comprise an attractive approach to Wireless Sensor Networks (WSNs), because of properties such as asynchronous operation and robustness in the face of failures.             Belief Propagation (BP) is a method for distributed inference which provides accurate results with rapid convergence properties. However, applying a BP algorithm to WSN is challenging. Many papers that proposed using BP for WSNs do not consider all of the constraints which these networks impose.             This paper presents a framework that implements both localized and data-centric approaches to improve the effectiveness and the robustness of this algorithm in the WSN environment. The proposed solution is empirically evaluated, as applied to the clustering problem, and it can be easily extended to suit many other applications that use BP as an underlying algorithm.", "num_citations": "20\n", "authors": ["490"]}
{"title": "Evaluating total order algorithms in WAN\n", "abstract": " Agreed message delivery is an important service in distributed systems, especially when dealing with fault-tolerant applications. This work studies factors influencing protocols that provide global order in Wide Area Networks. Performance evaluation in real network conditions was conducted in order to compare two recently published algorithms. It was found that loss rate and variations in message propagation time have a significant impact on the performance of the algorithms. 1", "num_citations": "20\n", "authors": ["490"]}
{"title": "Rigorously modeling self-stabilizing fault-tolerant circuits: An ultra-robust clocking scheme for systems-on-chip\n", "abstract": " We present the first implementation of a distributed clock generation scheme for Systems-on-Chip that recovers from an unbounded number of arbitrary transient faults despite a large number of arbitrary permanent faults. We devise self-stabilizing hardware building blocks and a hybrid synchronous/asynchronous state machine enabling metastability-free transitions of the algorithm's states. We provide a comprehensive modeling approach that permits to prove, given correctness of the constructed low-level building blocks, the high-level properties of the synchronization algorithm (which have been established in a more abstract model). We believe this approach to be of interest in its own right, since this is the first technique permitting to mathematically verify, at manageable complexity, high-level properties of a fault-prone system in terms of its very basic components. We evaluate a prototype implementation, which\u00a0\u2026", "num_citations": "19\n", "authors": ["490"]}
{"title": "Polynomial linear programming with Gaussian belief propagation\n", "abstract": " Interior-point methods are state-of-the-art algorithms for solving linear programming (LP) problems with polynomial complexity. Specifically, the Karmarkar algorithm typically solves LP problems in time O(n 3.5 ), where n is the number of unknown variables. Karmarkar's celebrated algorithm is known to be an instance of the log-barrier method using the Newton iteration. The main computational overhead of this method is in inverting the Hessian matrix of the Newton iteration. In this contribution, we propose the application of the Gaussian belief propagation (GaBP) algorithm as part of an efficient and distributed LP solver that exploits the sparse and symmetric structure of the Hessian matrix and avoids the need for direct matrix inversion. This approach shifts the computation from realm of linear algebra to that of probabilistic inference on graphical models, thus applying GaBP as an efficient inference engine. Our\u00a0\u2026", "num_citations": "19\n", "authors": ["490"]}
{"title": "Accounting mechanism for membership size-dependent pricing of multicast traffic\n", "abstract": " A number of schemes for membership size-dependent pricing of multicast traffic have been proposed recently. The enabling accounting technology, however, is lagging behind. Retaining an exact count of the active receivers is very difficult. To target an accounting mechanism, we suggest novel monitoring algorithms that combine a hierarchical control structure with event-driven monitoring. The efficiency and tradeoffs of the proposed solutions are thoroughly studied through simulations using both synthetic, and real MBone workloads. As we show, depending on the workload and the required accuracy, we can reduce the monitoring traffic by factor of 2 to 10 compared to other known alternatives.", "num_citations": "19\n", "authors": ["490"]}
{"title": "New latency bounds for atomic broadcast\n", "abstract": " Tighter bounds are provided on the time required to reach agreement in a distributed system as a function of the failure model. After describing the model of a distributed system that is a context for this work the authors define several failure classes. They define a partial order on classes of failures that involves whether there is a latency penalty in converting from tolerance of one failure class to another. In this setting they distinguish clock and timing failures, showing that there can be a penalty in converting from timing failure tolerance to clock failure tolerance. The authors leave open the exact expression for the optimal latency for timing failure tolerant atomic broadcast, though it is conjectured that there is some penalty in converting from omission failure tolerance to timing failure tolerance.< >", "num_citations": "19\n", "authors": ["490"]}
{"title": "Tomography of scale-free networks and shortest path trees\n", "abstract": " In this paper we model the tomography of scale-free networks by studying the structure of layers around an arbitrary network node. We find, both analytically and empirically, that the distance distribution of all nodes from a specific network node consists of two regimes. The first is characterized by rapid growth, and the second decays exponentially. We also show analytically that the nodes degree distribution at each layer exhibits a power-law tail with an exponential cutoff. We obtain similar empirical results for the layers surrounding the root of shortest path trees cut from such networks, as well as the Internet.", "num_citations": "18\n", "authors": ["490"]}
{"title": "Correcting faults in write-once memory\n", "abstract": " We consider codes for write-once memory in tile presence of stuck-agO and stuebat--1 faults. Such fault.-tolerant codes generally require less redundancy than error-correcting codes, as faults detected during the writing process can affect subsequent behavior of that process. We present pointer codes, which use part of a codeword to point to faults in other parts of the codeword. A pointer code can encode n-bit messages in the presence of f faults with only f (log 2 n+ o (1)) redundancy. We derive a lower bound on the redundancy of such a fault-tolerant code of slightly less than f log n. We also examine some models where all stuck-at inforIlmtion is known in advance, and analyze the expected redundancy of pointer codes.", "num_citations": "18\n", "authors": ["490"]}
{"title": "High performance pattern matching\n", "abstract": " An apparatus having a content-addressable memory (CAM) that stores a plurality of entries comprising portions of a plurality of patterns; a memory that stores a shift value corresponding to each of the entries; and a controller that generates a first key based on a received string, applies the first key to the CAM to select an entry of the CAM, retrieves the shift value from the memory corresponding to the selected entry, in response to the shift value being equal to a predetermined value, identifies an initial match, and in response to the initial match corresponding to a first pattern of the plurality of patterns that is larger than the entries of the CAM, applies adjacent keys based on the received string to the CAM, and declares a complete match when each of the corresponding shift values from the memory is equal to the predetermined value.", "num_citations": "17\n", "authors": ["490"]}
{"title": "High-performance pattern matching\n", "abstract": " Apparatus having corresponding methods and computer programs, to detect a pattern in a string, comprises a memory circuit to store W-character segments of the pattern, where each segment comprises a fragment of the pattern; a key circuit to generate W-character keys each including a fragment of the string; a comparison circuit to compare the keys and the segments; where, when a segment matches a key, the comparison circuit indicates an initial match between the pattern and the string; and where, when one of the segments matches only a L-character fragment of one of the keys, wherein L< W, the key circuit generates a new key including the L-character fragment and a K-character fragment of the string including K= W\u2212 L consecutive characters from the string that are adjacent to the L matching characters in the string.", "num_citations": "17\n", "authors": ["490"]}
{"title": "A low density lattice decoder via non-parametric belief propagation\n", "abstract": " The recent work of Sommer, Feder and Shalvi presented a new family of codes called low density lattice codes (LDLC) that can be decoded efficiently and approach the capacity of the AWGN channel. A linear time iterative decoding scheme which is based on a message-passing formulation on a factor graph is given. In the current work we report our theoretical findings regarding the relation between the LDLC decoder and belief propagation. We show that the LDLC decoder is an instance of non-parametric belief propagation and further connect it to the Gaussian belief propagation algorithm. Our new results enable borrowing knowledge from the non-parametric and Gaussian belief propagation domains into the LDLC domain. Specifically, we give more general convergence conditions for convergence of the LDLC decoder (under the same assumptions of the original LDLC convergence analysis). We discuss how\u00a0\u2026", "num_citations": "17\n", "authors": ["490"]}
{"title": "Determinism vs. nondeterminism in multiparty communication complexity\n", "abstract": " A given Boolean function has its input distributed among many parties. The aim is to determine which parties to talk to and what information to exchange in order to evaluate the function while minimizing the total communication. This paper shows that it is possible to evaluate the Boolean function deterministically with only a polynomial increase in communication and number of parties accessed with respect to the information lower bound given by the nondeterministic communication complexity of the function.", "num_citations": "17\n", "authors": ["490"]}
{"title": "The parallel complexity of scheduling with precedence constraints\n", "abstract": " We study the problem of parallel computation of a schedule for a system of n unit-length tasks on m identical machines, when the tasks are related by a set of precedence constraints. We present NC algorithms for computing an optimal schedule in the case where m, the number of available machines, does not vary with time and the precedence constraints are represented by a collection of outtrees. The algorithms run on an exclusive read, exclusive write (EREW) PRAM. Their complexities are O (log n) and O ((log n) 2) parallel time using O (n 2) and O (n) processors, respectively. The schedule computed by our algorithms is a height-priority schedule. As a complementary result we show that it is very unlikely that computing such a schedule is in NC when any of the above conditions is significantly relaxed. We prove that the problem is P-complete under logspace reductions when the precedence constraints are a\u00a0\u2026", "num_citations": "17\n", "authors": ["490"]}
{"title": "Self-stabilizing byzantine pulse synchronization\n", "abstract": " The ``Pulse Synchronization'' problem can be loosely described as targeting to invoke a recurring distributed event as simultaneously as possible at the different nodes and with a frequency that is as regular as possible. This target becomes surprisingly subtle and difficult to achieve when facing both transient and permanent failures. In this paper we present an algorithm for pulse synchronization that self-stabilizes while at the same time tolerating a permanent presence of Byzantine faults. The Byzantine nodes might incessantly try to de-synchronize the correct nodes. Transient failures might throw the system into an arbitrary state in which correct nodes have no common notion what-so-ever, such as time or round numbers, and can thus not infer anything from their own local states upon the state of other correct nodes. The presented algorithm grants nodes the ability to infer that eventually all correct nodes will invoke their pulses within a very short time interval of each other and will do so regularly. Pulse synchronization has previously been shown to be a powerful tool for designing general self-stabilizing Byzantine algorithms and is hitherto the only method that provides for the general design of efficient practical protocols in the confluence of these two fault models. The difficulty, in general, to design any algorithm in this fault model may be indicated by the remarkably few algorithms resilient to both fault models. The few published self-stabilizing Byzantine algorithms are typically complicated and sometimes converge from an arbitrary initial state only after exponential or super exponential time.", "num_citations": "16\n", "authors": ["490"]}
{"title": "Fault tolerance in the cardiac ganglion of the lobster\n", "abstract": " Considerations of fault tolerance play a key role in designing networks of distributed computers. Surprisingly, no such analysis has been carried out for networks of `distributed neurons'. We suggest here that as in distributed computer networks, the structure and properties of neuronal networks are designed to tolerate possible faults that may naturally occur in the network.", "num_citations": "16\n", "authors": ["490"]}
{"title": "Byzantine agreement with optimal early stopping, optimal resilience and polynomial complexity\n", "abstract": " We provide the first protocol that solves Byzantine agreement with optimal early stopping (min {f+ 2, t+ 1} rounds) and optimal resilience (n> 3t) using polynomial message size and computation.", "num_citations": "15\n", "authors": ["490"]}
{"title": "Compiler aided ticket scheduling of tasks in a computing system\n", "abstract": " A method of scheduling tasks for execution in a computer system includes determining a dynamic worst case execution time for a non-periodic task. The dynamic worst case execution time is based on an actual execution path of the non-periodic task. An available time period is also determined, wherein the available time period is an amount of time available for execution of the non-periodic task. The non-periodic task is scheduled for execution if the dynamic worst case execution time is less than the available time period.", "num_citations": "15\n", "authors": ["490"]}
{"title": "Cooperative and reliable packet-forwarding on top of AODV\n", "abstract": " Cooperative and reliable packet forwarding presents a formidable challenge in mobile ad hoc networks (MANET), due to special network characteristics; e.g., mobility, dynamic topology and absence of centralized management. Lack of cooperation, due to misbehavior caused by selfishness or malice, may severely degrade the performance of the network. Previous studies, relying on reputation systems, have demonstrated solutions designed for Dynamic Source Routing (DSR) protocol. This paper highlights various aspects of cooperation enforcement and reliability, when AODV is the underlying protocol. Furthermore, it presents a scalable protocol that combines a reputation system with AODV that addresses reputation fading, second-chance, robustness against liars and load balancing.", "num_citations": "15\n", "authors": ["490"]}
{"title": "System for secure and private communication in a triple-connected network\n", "abstract": " An apparatus and method for secure and private communications in a triple-connected processor network. Communication of a message over at least three data paths is achieved by transmitting the message in coded form over the data paths, determining whether the message is correctly received, and if the message is not correctly received, identifying a non-faulty data path, testing remaining data paths to identify a faulty data path, and transmitting the message in coded form over remaining non-faulty data paths.", "num_citations": "15\n", "authors": ["490"]}
{"title": "Some geometry for general river routing\n", "abstract": " Efficient solutions are given to compute the optimal placement for a pair of VLSI modules interconnected by river routing. Specifically, let the (perpendicular) distance between the two modules be the separation, and call the (transverse) displacement the offset. This paper principally considers the separation problem: Given an offset and a wiring rule, find the minimum separation permitting a legal wiring. The design rules might use wires which are exclusively rectilinear, polygonal with a finite number of slopes, or possibly restricted to some other class of shapes such as circular arcs plus linear pieces.Techniques are developed which unify a variety of different placement problems, and give efficient solutions under extremely general conditions. The advantage of these generalizations is not only their theoretical framework; the results extend naturally to more precise models of real river routing, and the theory is\u00a0\u2026", "num_citations": "15\n", "authors": ["490"]}
{"title": "Peer-to-peer secure multi-party numerical computation facing malicious adversaries\n", "abstract": " We propose an efficient framework for enabling secure multi-party numerical computations in a Peer-to-Peer network. This problem arises in a range of applications such as collaborative filtering, distributed computation of trust and reputation, monitoring and other tasks, where the computing nodes are expected to preserve the privacy of their inputs while performing a joint computation of a certain function. Although there is a rich literature in the field of distributed systems security concerning secure multi-party computation, in practice it is hard to deploy those methods in very large scale Peer-to-Peer networks. In this work, we try to bridge the gap between theoretical algorithms in the security domain, and a practical Peer-to-Peer deployment. We consider two security models. The first is the semi-honest model where peers correctly follow the protocol, but try to reveal private information. We provide three\u00a0\u2026", "num_citations": "14\n", "authors": ["490"]}
{"title": "LiteLoad: Content unaware routing for localizing P2P protocols\n", "abstract": " In today's extensive worldwide Internet traffic, some 60% of network congestion is caused by Peer to Peer sessions. Consequently ISPs are facing many challenges like: paying for the added traffic requirement, poor customer satisfaction due to degraded broadband experience, purchasing costly backbone links and upstream bandwidth and having difficulty to effectively control P2P traffic with conventional devices. Existing solutions such as caching and indexing of P2P content are controversial as their legality is uncertain due to copyright violation, and therefore hardly being installed by ISPs. In addition these solutions are not capable to handle existing encrypted protocols that are on the rise in popular P2P networks. Other solutions that employ traffic shaping and blocking degrade the downloading throughput and cause end users to switch ISPs for a better service. LiteLoad discerns patterns of user\u00a0\u2026", "num_citations": "14\n", "authors": ["490"]}
{"title": "Accelerating distributed computing applications using a network offloading framework\n", "abstract": " During the last two decades, a considerable amount of academic research has been conducted in the field of distributed computing. Typically, distributed applications require frequent network communication, which becomes a dominate factor in the overall runtime overhead. The recent proliferation of programmable peripheral devices for computer systems may be utilized in order to improve the performance of such applications. Offloading application-specific network functions to peripheral devices can improve performance and reduce host CPU utilization. Due to the peculiarities of each particular device and the difficulty of programming an outboard CPU, the need for an abstracted offloading framework is apparent. This paper proposes a novel offloading framework, called HYDRA that enables utilization of such devices. The framework enables an application developer to design the offloading aspects of the\u00a0\u2026", "num_citations": "14\n", "authors": ["490"]}
{"title": "Transport layer end-to-end error correcting\n", "abstract": " In this paper we study the advantages and disadvantages of incorporating error correction schemes inside the TCP transport layer protocol. We show that under some circumstances, this scheme achieves better performance than that of retransmission schemes, and, in particular, the TCP-SACK scheme. We analyze the performance of both schemes and discuss the circumstances under which the error correction scheme is favorable.", "num_citations": "14\n", "authors": ["490"]}
{"title": "Observable clock synchronization extended abstract\n", "abstract": " While the synchronization of time-o!-day clocks ordinarily requires information f70w in both directions between the clocks, this information need not j70w directlp via messages. However, to take advantage of indirect information fiow, we have to make a number of complex assumptions about the behavior of the communication medium. To facilitate the verification of such assumptions, ute develop a relativistic theory of observable ciock synchronization that does not use or depend an a Newtonian framework or real time. Within the contezt of this theory, we focus on the problem of es-timating the time on a remote clock. We generalize the concept of rapport to capture the situation when such an estimate is suficient for clock synchronization purposes. With a single property, called the Observable Drifi Property, we characterize the information flow required for obtaining rapport. We compare our reiativized and oilservable\u00a0\u2026", "num_citations": "14\n", "authors": ["490"]}
{"title": "Distributed protocols for leader election: a game-theoretic perspective\n", "abstract": " We do a game-theoretic analysis of leader election, under the assumption that each agent prefers to have some leader than no leader at all. We show that it is possible to obtain a fair Nash equilibrium, where each agent has an equal probability of being elected leader, in a completely connected network, in a bidirectional ring, and a unidirectional ring, in the synchronous setting. In the asynchronous setting, Nash equilibrium is not quite the right solution concept. Rather, we must consider ex post Nash equilibrium; this means that we have a Nash equilibrium no matter what a scheduling adversary does. We show that ex post Nash equilibrium is attainable in the asynchronous setting in all the networks we consider, using a protocol with bounded running time. However, in the asynchronous setting, we require that n > 2. We show that we can get a fair ex post \u03b5-Nash equilibrium if n=2 in the asynchronous setting under\u00a0\u2026", "num_citations": "13\n", "authors": ["490"]}
{"title": "Preventing (Network) Time Travel with Chronos.\n", "abstract": " The Network Time Protocol (NTP) synchronizes time across computer systems over the Internet. Unfortunately, NTP is highly vulnerable to \u201ctime shifting attacks\u201d, in which the attacker\u2019s goal is to shift forward/backward the local time at an NTP client. NTP\u2019s security vulnerabilities have severe implications for time-sensitive applications and for security mechanisms, including TLS certificates, DNS and DNSSEC, RPKI, Kerberos, BitCoin, and beyond. While technically NTP supports cryptographic authentication, it is very rarely used in practice and, worse yet, timeshifting attacks on NTP are possible even if all NTP communications are encrypted and authenticated.We present Chronos, a new NTP client that achieves good synchronization even in the presence of powerful attackers who are in direct control of a large number of NTP servers. Importantly, Chronos is backwards compatible with legacy NTP and involves no changes whatsoever to NTP servers. Chronos leverages ideas from distributed computing literature on clock synchronization in the presence of adversarial (Byzantine) behavior. A Chronos client iteratively \u201ccrowdsources\u201d time queries across multiple NTP servers and applies a provably secure algorithm for eliminating \u201csuspicious\u201d responses and averaging over the remaining responses. Chronos is carefully engineered to minimize communication overhead so as to avoid overloading NTP servers.", "num_citations": "13\n", "authors": ["490"]}
{"title": "HEX: Scaling honeycombs is easier than scaling clock trees\n", "abstract": " We argue that a hexagonal grid with simple intermediate nodes is a robust alternative to buffered clock trees typically used for clock distribution in VLSI circuits, multi-core processors, and other applications that require accurate synchronization: Our HEX grid is Byzantine fault-tolerant, self-stabilizing, and seamlessly integrates with multiple synchronized clock sources, as used in multi-synchronous Globally Synchronous Locally Asynchronous (GALS) architectures. Moreover, HEX guarantees a small clock skew between neighbors even for wire delays that are only moderately balanced. We provide both a theoretical analysis of the worst-case skew and simulation results that demonstrate a very small average skew.", "num_citations": "13\n", "authors": ["490"]}
{"title": "Early-deciding consensus is expensive\n", "abstract": " In consensus, the n nodes of a distributed system seek to take a consistent decision on some output, despite up to t of them crashing or even failing maliciously, ie, behaving\" Byzantine''. It is known that it is impossible to guarantee that synchronous, deterministic algorithms consistently decide on an output in fewer than f+ 1 rounds in executions in which the actual number of faults is f\u2264 t. This even holds if faults are crash-only, and in this case the bound can be matched precisely. However, the question of whether this can be done efficiently, ie, with little communication, so far has not been addressed.", "num_citations": "13\n", "authors": ["490"]}
{"title": "Fault-tolerant clock synchronization\n", "abstract": " This paper gives two simple efficient distributed algorithms: one for keeping clocks in a network synchronized and one for allowing new processors to join the network with their clocks synchronized. Assuming a fault-tolerant authentication protocol, the algorithms tolerate both link and processor failures of any type. The algorithm for maintaining synchronization works for arbitra~ networks (rather than just completely connected networks) and tolerates any number of processor or communication link faults as long as the correct processors remain connected by fault-free paths. It thus represents an improvement over other clock synchronization algorithms such as those of Lamport and Melliar-Smith [1985] and Welch and Lynch [1988], although, unlike them, it does require an authentication protocol to handle Byzantine faults. Our algorithm for allowing new processors to join requires that more than half the processors be correct, a requirement that is provably necessa~.", "num_citations": "13\n", "authors": ["490"]}
{"title": "Method and system for linear processing of an input using Gaussian belief propagation\n", "abstract": " Methods and systems for processing an input. An input vector y is received that represents a noisy observation of Ax, where A is a data matrix and x is a data vector of unknown variables. Data vector x is recovered from the received input vector y via an iterative method. The recovering comprises determining an inference of a vector of marginal means over a graph G, where the graph G is of a joint Gaussian probability density function p (x) associated with noise in the received input vector y.", "num_citations": "12\n", "authors": ["490"]}
{"title": "Collabrium: Active traffic pattern prediction for boosting P2P collaboration\n", "abstract": " Emerging large scale Internet applications such as IPTV, VOD and file sharing base their infrastructure on P2P technology. Yet, the characteristic fluctational throughput of source peers affect the QOS of such applications which might be reflected by a reduced download rate in file sharing or even worse - annoying freezes in a streaming service. A significant factor for the unstable supply of source peers is the behavior of other processes running on the source peer that consume bandwidth resources. In this paper we present Collabrium - a collaborative solution that employs a machine learning approach to actively predict load in the uplink of source peers and alert their clients to replace their source. Experiments on home machines demonstrated successful predictions of upcoming loads and Collabrium learned the behavior of popular heavy bandwidth consuming protocols such as eMule & BitTorrent correctly with\u00a0\u2026", "num_citations": "11\n", "authors": ["490"]}
{"title": "Modified belief propagation algorithm for energy saving in wireless and sensor networks\n", "abstract": " In this paper we develop a simple variant of the belief propagation (BP) algorithm targeted towards reducing the communication cost of broadcast supporting networks such as sensor networks. Our modified algorithm can be proven to achieve identical computation results on each node, while at the same time significantly reducing the number of transmitted messages. Furthermore, the number of computation steps in each node is not increased. We pay in additional storage space, as each node saves the last message received from each of his neighbors.Many recent works in the field of sensor networks use the BP algorithm for solving various problems. Our variant could be easily applied to any of these proposed systems, thus improving energy consumption and running time. One of the important issues in sensor networks is how to minimize of the sensors\u2019 energy consumption, reducing the number of transmitted messages by a large factor significantly improves the energy consumption. Another advantage of our algorithm is a decrease in the number of transmission slots needed, since in wireless environment acquiring a transmission slot can be costly in terms of time and power.", "num_citations": "11\n", "authors": ["490"]}
{"title": "Fault-tolerant critical section management in asynchronous environments\n", "abstract": " The paper deals with the problem of managing a fault-tolerant critical section in a completely asynchronous distributed network. The existence of a solution to this problem should be contrasted with a basic result of Fischer, Lynch, and Paterson, proving that in a completely asynchronous network, \u201cnontrivial agreement\u201d cannot be achieved even when only a single \u201cbenign\u201d processor failure is possible. We present solutions to several versions of the critical section problem in this model. Denote by t the maximum number of possible faulty processors. Processors are allowed to fail while in the critical section, and therefore the critical section must have at least t + 1 slots. In the case where the slots are identical we present two algorithms which require t + 1 slots. The first is very simple, but requires every non-faulty processor to use the critical section infinitely often. The second solution allows non-faulty processors to quit\u00a0\u2026", "num_citations": "11\n", "authors": ["490"]}
{"title": "\" Offizielle\" elektronische Version der Publikation (entsprechend ihrem Digital Object Identifier-DOI)\n", "abstract": " Publikationseintrag [Zur\u00fcck] Zeitschriftenartikel: M. Triska, N. Musliu: \"An Effective Greedy Heuristic for the Social Golfer Problem\"; Annals of Operations Research, 194 (2012), 1; S. 413 - 425. Kurzfassung englisch: The Social Golfer Problem (SGP) is a combinatorial optimization problem that exhibits a lot of symmetry and has recently attracted significant attention. In this paper, we present a new greedy heuristic for the SGP, based on the intuitive concept of freedom among players. We use this heuristic in a complete backtracking search, and match the best current results of constraint solvers for several SGP instances with a much simpler method. We then use the main idea of the heuristic to construct initial configurations for a metaheuristic approach, and show that this significantly improves results obtained by local search alone. In particular, our method is the first metaheuristic technique that can solve the original . is :\u2026", "num_citations": "10\n", "authors": ["490"]}
{"title": "The Byzantine generals\n", "abstract": " The Byzantine generals | Concurrency control and reliability in distributed systems ACM Digital Library home ACM home Google, Inc. (search) Advanced Search Browse About Sign in Register Advanced Search Journals Magazines Proceedings Books SIGs Conferences People More Search ACM Digital Library SearchSearch Advanced Search Browse Browse Digital Library Collections More HomeBrowse by TitleBooksConcurrency control and reliability in distributed systemsThe Byzantine generals chapter The Byzantine generals Share on Authors: Danny Dolev profile image Danny Dolev View Profile , Leslie Lamport profile image Leslie Lamport View Profile , Marshall C , III Pease profile image Marshall Pease View Profile , Robert E. Shostak profile image Robert Shostak View Profile Authors Info & Affiliations Publication: Concurrency control and reliability in distributed systemsJuly 1987 Pages 348\u2013369 1citation \u2026", "num_citations": "10\n", "authors": ["490"]}
{"title": "Gaussian belief propagation for solving systems of linear equations: Theory and application\n", "abstract": " The canonical problem of solving a system of linear equations arises in numerous contexts in information theory, communication theory, and related fields. In this contribution, we develop a solution based upon Gaussian belief propagation (GaBP) that does not involve direct matrix inversion. The iterative nature of our approach allows for a distributed message-passing implementation of the solution algorithm. We address the properties of the GaBP solver, including convergence, exactness, computational complexity, message-passing efficiency and its relation to classical solution methods. We use numerical examples and applications, like linear detection, to illustrate these properties through the use of computer simulations. This empirical study demonstrates the attractiveness (e.g., faster convergence rate) of the proposed GaBP solver in comparison to conventional linear-algebraic iterative solution methods.", "num_citations": "9\n", "authors": ["490"]}
{"title": "Constant-space localized byzantine consensus\n", "abstract": " Adding Byzantin tolerance to large scale distributed systems is considered non-practical. The time, message and space requirements are very high. Recently, researches have investigated the broadcast problem in the presence of a f                                    l                 -local Byzantin adversary. The local adversary cannot control more than f                                    l                  neighbors of any given node. This paper proves sufficient conditions as to when the synchronous Byzantin                 consensus problem can be solved in the presence of a f                                    l                 -local adversary.               Moreover, we show that for a family of graphs, the Byzantin consensus problem can be solved using a relatively small number of messages, and with time complexity proportional to the diameter of the network. Specifically, for a family of bounded-degree graphs with logarithmic diameter, O(logn) time and O(n logn\u00a0\u2026", "num_citations": "9\n", "authors": ["490"]}
{"title": "The design of Xpand: A group communication system for wide area networks\n", "abstract": " Group communication systems (GCSs) are now widely recognized as powerful building blocks for supporting consistency and fault-tolerance in distributed applications. In this paper we present a novel GCS called Xpand. The main objective of the Xpand design is to address the needs of a wide spectrum of collaborative wide area network applications without compromising the semantics of traditional GCSs to the extent possible. In order to achieve this goal Xpand introduces a separation between strong and weak service levels, a scalable failure detection, an external infrastructure for membership maintenance and hierarchical engine for message reliability.", "num_citations": "9\n", "authors": ["490"]}
{"title": "Scheduling wide graphs\n", "abstract": " The problem of scheduting a partially ordered set of unit length tasks on 111, identical processors is known to be UP-complete. There are efficient algorithms for only few special cases of this problem. In this paper we explore the relation8 between the structure of the precedence graph (the partial order) and optimal schedules. We prove that in finding an optimal schedule for certain systems it sumces to consider at each step high roots which belong to at most the m-1 highest components of the precedence graph. This result reduces the number of cases we have to check during the construction of an optimal schedule. Our method may lead to the development of linear scheduling algorithms for many practical cases and to better bounds for complex algorithms. In particular, in the case the precedence graph contains only inforest and outforest components, this result leads to efBcient algorithms for obtaining an optimal schedule on two or three processors.", "num_citations": "9\n", "authors": ["490"]}
{"title": "Life\u2010threatening course of pemphigus vulgaris complicated by sepsis caused by azathioprine\u2010induced bone marrow suppression, successfully managed with combination therapy\n", "abstract": " Severe forms of pemphigus vulgaris (PV) that are resistant to standard treatment present a life\u2010threatening disease with a mortality of 5\u201310%. The treatment is usually individualized. The most popular procedures used today include intravenous applications of immunoglobulins and rituximab. Currently the common use of pulse corticosteroids, often in first\u2010line treatment, is being neglected. This particular case documented the severity of the disease and also the need for combined and comprehensive care, in which corticosteroid pulse therapy still plays an important role.", "num_citations": "8\n", "authors": ["490"]}
{"title": "Ocd: Obsessive consensus disorder (or repetitive consensus)\n", "abstract": " Consider a distributed system S of sensors, where the goal is to continuously output an agreed reading. The input readings of non-faulty sensors may change over time; and some of the sensors may be faulty (Byzantine). Thus, the system is required to repeatedly perform consensus on the input values.", "num_citations": "8\n", "authors": ["490"]}
{"title": "One algorithm to match them all: on a generic NIPS pattern matching algorithm\n", "abstract": " Today's network intrusion prevention systems (NIPS) provide an important defense mechanism against security threats. The detection of network attacks utilizes a highspeed pattern matching algorithm that can be implemented in either hardware or software. Adapting a software-based pattern matching algorithm to hardware-based device is a complicated task. This paper presents a cost effective multi-pattern matching algorithm based on Field Programmable Gate Arrays (FPGAs) and standard RAM. The algorithm achieves line-rate speed, which is several orders of magnitude faster than the current state of the art, while attaining similar accuracy of detection. The algorithm can be easily adapted to operate in hardware-based NIPS and attain even higher speed by utilizing a TCAM memory.", "num_citations": "8\n", "authors": ["490"]}
{"title": "On a NIC\u2019s operating system, schedulers and high-performance networking applications\n", "abstract": " Two critical issues impact the overall performance of Linux clusters based on Intel servers: inter-process communication latency and data throughput. Underlying both of these performance challenges is the inefficient use of computational power and server CPU cycles to process the network protocols. Today\u2019s modern high-end Network Interface Cards (NICs) are equipped with an onboard CPU. In most cases, these CPU\u2019s are only used by the vendor and are operated by a proprietary OS, which makes them inaccessible to the HPC application developer. In this paper we present a design and implementation of a framework for building high-performance networking applications. The framework consists of an embedded NIC Operating System with a specialized scheduler. The main challenge in developing such a scheduler is the lack of a preemption mechanism in most high-end NICs. Our scheduler\u00a0\u2026", "num_citations": "8\n", "authors": ["490"]}
{"title": "On distributed algorithms in a broadcast domain\n", "abstract": " This paper studies the usage of broadcast communication in distributed services. The approach taken is practical: all the algorithms are asynchronous, and tolerate realistic faults. We study four problems in a broadcast domain: clock synchronization, reliable and ordered broadcast, membership, and file replication. The clock synchronization algorithm shows for the first time how to utilize broadcast communication for synchronization. The master synchronizes any number of slaves while incurring a constant load. The approach taken in the file replication tool uses snooping in order to enhance the availability of file systems, at almost no cost.", "num_citations": "8\n", "authors": ["490"]}
{"title": "Method and means for leader choosing on a token ring system\n", "abstract": " In a token ring transmission system, token loss causes selection of a leader terminal, which issues a new token. The leader terminal is chosen by selecting and storing a leadership selection reference value and then generating a succession of terminal identification signals and transferring them on the token ring transmission system. Each terminal receives the succession of signals and iteratively compares the terminal identification signals sequentially with the leadership reference signal. Each time a terminal identification signal exceeds the magnitude of the leadership reference signal, the leadership reference value is replaced with the value of the terminal identification signal. The first terminal detecting equality of a terminal identification signal with its leadership selection reference signal assumes leadership and issues a token.", "num_citations": "8\n", "authors": ["490"]}
{"title": "Optimal algorithms for structural assembly\n", "abstract": " In many VLSI design systems (Johannsen 1979), a common problem is to connect terminals (considered as points on the facing sides of two adjacent rectangles) in a designated order. We shall generally assume that there are no crossovers\u2014ie, that the order is the same for both rectangles. Wire placement can be optimized by putting the rectangles as close to each other as possible. One seemingly promising way to minimize the separation is to use several layers for the wiring. Two-or threelayer wirings clearly are more general, and are necessary when the terminals of the two rectangles need not be connected to order. However, single-layer wiring is often used, because of the area lost when wires are run between two or more layers. Figure 1 shows the wiring problem: to draw a wire from each P\u00a1(a terminal on the lower row) to the corresponding Q\u00a1(a terminal on the upper row), such that no two wires ever come\u00a0\u2026", "num_citations": "8\n", "authors": ["490"]}
{"title": "Implementing mediators with asynchronous cheap talk\n", "abstract": " A mediator can help non-cooperative agents obtain an equilibrium that may otherwise not be possible. We study the ability of players to obtain the same equilibrium without a mediator, using only cheap talk, that is, nonbinding pre-play communication. Previous work has considered this problem in a synchronous setting. Here we consider the effect of asynchrony on the problem, and provide upper bounds for implementing mediators. Considering asynchronous environments introduces new subtleties, including exactly what solution concept is most appropriate and determining what move is played if the cheap talk goes on forever. Different results are obtained depending on whether the move after such\" infinite play''is under the control of the players or part of the description of the game.", "num_citations": "7\n", "authors": ["490"]}
{"title": "Compact routing messages in self-healing trees\n", "abstract": " Existing compact routing schemes, eg, Thorup and Zwick [4] and Chechik [6] often have no means to tolerate failures, once the system has been set up and started. This paper presents, to our knowledge, the first self-healing compact routing scheme. Besides, our schemes are developed for low memory nodes and are compact schemes, meaning they require only O (log 2\u2061 n) bits memory. We introduce two algorithms of independent interest: The first is CompactFT, a novel compact version of the self-healing algorithm Forgiving Tree of Hayes et al.[7] that uses only O (log\u2061 n) bits local memory. The second algorithm (CompactFTZ) combines CompactFT with Thorup\u2013Zwick's tree-based compact routing scheme [4] to produce a compact self-healing routing scheme. In the self-healing model, the adversary deletes nodes one at a time and the affected nodes self-heal locally by adding few edges. We introduce the\u00a0\u2026", "num_citations": "7\n", "authors": ["490"]}
{"title": "An optimal self-stabilizing firing squad\n", "abstract": " Consider a fully connected network where up to t processes may crash and all processes start in an arbitrary memory state. The self-stabilizing firing squad problem consists of eventually guaranteeing simultaneous response to an external input. This is modeled by requiring that the noncrashed processes \u201cfire\u201d simultaneously if some correct process received an external \u201cgo\u201d input, and that they only fire as a response to some process receiving such an input. This paper presents FireSquad, the first self-stabilizing firing squad algorithm. A firing squad algorithm facilitates the use of algorithms that need to start in the same round. It allows a smooth transition between algorithms whose executions need to be disjoint. The FireSquad algorithm combines two forms of fault-tolerance properties: self-stabilization to allow recovery from arbitrary transient errors and resilience to crash failures to handle permanent ones. The\u00a0\u2026", "num_citations": "7\n", "authors": ["490"]}
{"title": "Delay fast packets (dfp): Prevention of dns cache poisoning\n", "abstract": " The Domain Name System (DNS) protocol is used as a naming system for computers, services, or any other network resource. This paper presents a solution for the cache poisoning attack in which the attacker inserts incorrect data into the DNS cache. In order to successfully poison the cache, the attacker response must beat the real response in the race back to the local DNS server. In our model, we assume an eavesdropping attacker that can construct a response that is identical to the legal response. The primary aim of our solution is to construct a normal profile of the round trip time from when the request is sent until the arrival of the response, and then to search for anomalies of the constructed profile. In order to poison the cache of a DNS server, the attacker has to know the source port and the Transaction ID (TID) of the request. As far as we know, all current solutions which do not change the protocol\u00a0\u2026", "num_citations": "7\n", "authors": ["490"]}
{"title": "A data-centric approach for scalable state machine replication\n", "abstract": " Data replication is a key design principle for achieving reliability, high-availability, survivability and load balancing in distributed computing systems. The common denominator of all existing replication systems is the need to keep replicas consistent. The main paradigm for supporting replicated data is active replication, in which replicas execute the same sequence of methods on the object in order to remain consistent. This paradigm led to the definition of State Machine Replication (SMR) [29.8], [29.13]. The necessary building block of SMR is an engine that delivers operations at each site in the same total order without gaps, thus keeping the replica states consistent.", "num_citations": "7\n", "authors": ["490"]}
{"title": "A decentralized high performance time service architecture\n", "abstract": " A time service is a means by which users, applications, etc. obtain values associated with some measurement of elapsed time from some agreed on event. In a relativistic world, time services are necessarily imperfect, there being no such thing as simultaneity. In this paper we discuss an architecture for delivering required time services to a collection of heterogeneous machines communicating over a wide area network consisting of multiply connected and overlapping local area networks with various communication media. The primary building block of our architecture is a logical clock. We explain how logical clock objects simplify the treatment and resolution of a number of problems associated with time services. Having used logical clock objects to decouple clock synchronization problems from problems associated with smoothness and conformity to political time, we provide a straightforward master-slave algorithm for clock synchronization and show how to transform it into an eavesdropping algorithm that takes advantage of the broadcast nature of most local area networks to dramatically reduce message overhead. Finally, we show how to integrate eavesdropping and regular clock synchronization algorithms into a fault tolerant network time service that tolerates and coordinates multiple master clocks or external sources of time.", "num_citations": "7\n", "authors": ["490"]}
{"title": "PCODE: an efficient and reliable collective communication protocol for unreliable broadcast domain\n", "abstract": " Existing programming environments for clusters are typically built on top of a point-to-point communication layer (send and receive) over local area networks (LANs) and, as a result, suffer from poor performance in the collective communication part. For example, a broadcast that is implemented using a TCP/IP protocol (which is a point-to-point protocol) over a LAN is obviously an efficient as it is not utilizing the fact that the LAN is a broadcast medium. We have observed that the main difference between a distributed computing paradigm and a message passing parallel computing paradigm is that, in a distributed environment the activity of every processor is independent while in a parallel environment the collection of the user-communication layers in the processors can be modeled as a single global program. We have formalized the requirements by defining the notion of a correct global program. This notion\u00a0\u2026", "num_citations": "7\n", "authors": ["490"]}
{"title": "Experience with RAPID prototypes\n", "abstract": " The goals of the RAPID environment are: firstly to make the programming of distributed protocols simple without restricting the protocol relevant choices of the programmer; secondly to provide encapsulation and reusability that are at least as powerful as those offered by object oriented programming; and thirdly to provide for different styles of programming that make RAPID an easy transitional programming environment between older and lower level languages and C. The environment provides and is programmed in the RAPID-FL subset of the functional language FL. Although the full power of FL is available to the programmer, a very small number of concepts need to be learned to program in RAPID-FL. Moreover, restriction to RAPID-FL means that one can have the safety of a functional language combined with reasonable uses of assignment. RAPID makes storage management trivial and reduces the\u00a0\u2026", "num_citations": "7\n", "authors": ["490"]}
{"title": "Path-regular Graphs.\n", "abstract": " A graph is vertex-edge-path-regular if a list of shortest paths, allowing multiple copies of paths, exists where every pair of vertices are the endvertices of the same number of paths and each vertex edge occurs in the same number of paths of the list. The dependencies and independencies between the various path-regularity, regularity of degree, and symmetry properties are investigated. We show that every connected vertex-edge-symmetric graph is vertex-edge-path-regular, but not conversely. We show that the product of any two vertex-path-regular graphs is vertex-path-regular but not conversely, and the iterated product GxGx... xG is edge-path-regular if and only if G is edge-path-regular. An interpretation of path-regular graphs is given regarding the efficient design of concurrent communication networks. AuthorDescriptors:", "num_citations": "7\n", "authors": ["490"]}
{"title": "On the role of helper peers in P2P networks\n", "abstract": " Recent studies in peer-to-peer (P2P) networks present surprising new designs that rely on helper peers. Helper peers, sometimes named as Feeders or Support peers are nodes that do not function as direct consumers or providers of content but are used to collaborate with other peers in the network for a growing variety of benefits. In File Sharing networks for instance, due to frequent joins, leaves and the characteristic fluctuating throughput of source peers, clients usually download at an unstable rate. In addition, existing P2P protocols tend to ignore source peers that have relatively low bandwidth to offer and practically miss a potentially huge resource. By employing helper peers that are optimal for availability and throughput stability with the downloading client, it is possible to provide a maximal stable throughput even with extremely weak and unstable sources.Other interesting examples of helper peers in file sharing demonstrated how to integrate helper peers in order to increase the number of sources under flash crowds situations, how to solve the last chunk problem and how to bypass fairness rules for better download rates. In P2P streaming networks such as live IPTV and VOD, helper peers can contribute in preventing glitches and expanding the dissemination of packets, as well as synchronizing and ordering frames for the clients.", "num_citations": "6\n", "authors": ["490"]}
{"title": "Probabilistic fair queuing\n", "abstract": " Packet scheduling constitutes the core problem in efficient fair allocation of bandwidth to competing flows. To date, numerous algorithms for packet scheduling have been suggested and tested. However, only a few of them are currently deployed. One of the key reasons for rarity of applied packet scheduling methods lies in the complexity of their implementation. This paper describes a family of randomized algorithms for packet scheduling. These algorithms are simple to implement and require small amounts of computation time. Specifically we present an O(1) probabilistic weighted fair queuing algorithm that emits packets from flows with an improved delay jitter. Experimental results of the proposed randomized algorithms suggest that the randomized approach is a viable alternative to the currently deployed deterministic fair queuing algorithms.", "num_citations": "6\n", "authors": ["490"]}
{"title": "Method and apparatus for managing communications\n", "abstract": " The present invention provides a method and an apparatus for managing communications arriving from or to a node connected to a specified portion of a network. Some embodiments relate to an apparatus for managing communications arriving from or to a node connected to a specified portion of a network, including an external link identifier, a pool of addresses and an address replacement module. The external link identifier is configured to identify a message which is configured to enable requested content to be exchanged between the node and at least one other node which is external to the specified portion of the network. The pool of addresses is adapted to implement content insensitive criteria for determining which addresses to include in the pool. The address replacement module is adapted to implement a content insensitive replacement policy for determining whether an address included in the\u00a0\u2026", "num_citations": "5\n", "authors": ["490"]}
{"title": "Distributed sensor selection using a truncated Newton method\n", "abstract": " We propose a new distributed algorithm for computing a truncated Newton method, where the main diagonal of the Hessian is computed using belief propagation. As a case study for this approach, we examine the sensor selection problem, a Boolean convex optimization problem. We form two distributed algorithms. The first algorithm is a distributed version of the interior point method by Joshi and Boyd, and the second algorithm is an order of magnitude faster approximation. As an example application we discuss distributed anomaly detection in networks. We demonstrate the applicability of our solution using both synthetic data and real traffic logs collected from the Abilene Internet backbone.", "num_citations": "5\n", "authors": ["490"]}
{"title": "Collabory: A collaborative throughput stabilizer & accelerator for p2p protocols\n", "abstract": " Common peer-to-peer (P2P) file sharing clients usually download at an unstable rate and hardly exploit the available bandwidth offered by low rate sources. The characteristic fluctuational throughput of the source peers might be caused by user behavior factors such as running other bandwidth consuming tasks, throttling of download speed by P2P software or even termination of the source.In this paper we propose Collabory - a solution for stabilizing and accelerating the download speed rate in existing P2P networks. We introduce a new role: \"feeders\" - peers that collaboratively aggregate the downloads from multiple sources into a single, stable stream served to the downloading peer. We show that the solution utilizes source nodes with an extremely low and unstable throughput without reducing the download rate of the downloading peer.Measurements in a test suite expressed a major increase in download\u00a0\u2026", "num_citations": "5\n", "authors": ["490"]}
{"title": "Hydra: A novel framework for making high-performance computing offload capable\n", "abstract": " The proliferation of programmable peripheral devices for computer systems opens new possibilities for academic research that will influence system designs in the near future. Programmability is a key feature that enables application-specific extensions to improve performance and offer new features. Increasing transistor density and decreasing cost provide excess computational power in devices such as disk controllers, network interfaces and video cards. This paper proposes an innovative programming model and runtime support that enables utilization of such devices by providing a generic code offloading framework. The framework enables an application developer to design the offloading aspects of the application by specifying an \"offloading layout\", which is enforced by the runtime during application deployment. The framework also provides the necessary development tools and programming constructs for\u00a0\u2026", "num_citations": "5\n", "authors": ["490"]}
{"title": "Off-piste QoS-aware routing protocol\n", "abstract": " QoS-aware routing protocols have been the focus of much attention in the past decade. This is due to the interesting challenges posed by the problem of QoS routing, in the absence of precise information - or even partial and altogether imprecise information. We present a new QoS-aware routing protocol, OPsAR, which achieves very good performance results at a very reasonable cost, in terms of memory and messages, OPsAR is based on the multi-path routing approach, but constrains the number of paths used and leverages on previous resource reservation attempts. Every reservation attempt - successful or not - results in an update to the knowledge-state recorded at all the nodes that had participated in those attempts. This knowledge helps in avoiding network bottlenecks and coping with congested path when they are encountered. We present extensive simulation results and even compare ourselves\u00a0\u2026", "num_citations": "5\n", "authors": ["490"]}
{"title": "TCP-friendly many-to-many end-to-end congestion control\n", "abstract": " The paper addresses the issue of TCP-friendly congestion control mechanism for many-to-many communication environment. Lack of congestion control inhibits deployment of WAN applications that involve collaboration of groups of processes in the Internet environment. Recent efforts targeted unicast WAN congestion control (TFRC). We extend that approach to multicast many-to-many applications that operate using a middleware framework. Our congestion control mechanism was implemented within a group communication middleware and tested in a multi-continent environment. The measurements have proved the proposed approach to be robust, efficient and TCP-friendly, as well as to provide fairness among processes that compete for shared resources.", "num_citations": "5\n", "authors": ["490"]}
{"title": "On the tomography of networks and multicast trees\n", "abstract": " In this paper we model the tomography of scale free networks by studying the structure of layers around an arbitrary network node. We find, both analytically and empirically, that the distance distribution of all nodes from a specific network node consists of two regimes. The first is characterized by rapid growth, and the second decays exponentially. We also show that the nodes degree distribution at each layer is a power law with an exponential cut-off. We obtain similar results for the layers surrounding the root of multicast trees cut from such networks, as well as the Internet. All of our results were obtained both analytically and on empirical Interenet data.", "num_citations": "5\n", "authors": ["490"]}
{"title": "Ad hoc membership for scalable applications\n", "abstract": " The paper describes an ad hoc approach realized in a practical distributed transport layer called Xpand [1] to improve the message transmission service over a WAN. The current technology focuses on applications that require strong semantics. The ad hoc membership approach increases the asynchrony of handling both control and message flows in order to overcome membership changes with minimal effect on ongoing streams of messages. This approach is beneficial for a variety of applications. Its implementation is expandable to address stronger semantics for applications that need them.", "num_citations": "5\n", "authors": ["490"]}
{"title": "IMSS: IP Multicast Shortcut Service\n", "abstract": " We present IMSS: IP Multicast Shortcut Service for ATM networks. IMSS pursues the \"short cut\" routing paradigm in order to exploit the underlying ATM QoS and native routing mechanisms in the optimal way. IMSS is built on top of CONGRESS (Connection Oriented Group-Address Resolution Service). CONGRESS is an efficient native ATM protocol for resolution and management of multicast group addresses in a large ATM cloud. CONGRESS resolves multicast group addresses and maintains their membership for applications. It is not designed to handle the applications' data exchange. An IMSS extension at a multicast router uses the group membership information that it receives from CONGRESS in order to open ATM connections that bypass (\"shortcut\") the IP routing mechanism.", "num_citations": "5\n", "authors": ["490"]}
{"title": "Revisiting asynchronous fault tolerant computation with optimal resilience\n", "abstract": " The celebrated result of Fischer, Lynch and Paterson is the fundamental lower bound for asynchronous fault tolerant computation: any 1-crash resilient asynchronous agreement protocol must have some (possibly measure zero) probability of not terminating. In 1994, Ben-Or, Kelmer and Rabin published a proof-sketch of a lesser known lower bound for asynchronous fault tolerant computation with optimal resilience against a Byzantine adversary: if n\u2264 4t then any t-resilient asynchronous verifiable secret sharing protocol must have some non-zero probability of not terminating.", "num_citations": "4\n", "authors": ["490"]}
{"title": "Some garbage in-some garbage out: Asynchronous t-byzantine as asynchronous benign t-resilient system with fixed t-trojan-horse inputs\n", "abstract": " We show that asynchronous  faults Byzantine system is equivalent to asynchronous -resilient system, where unbeknownst to all, the private inputs of at most  processors were altered and installed by a malicious oracle. The immediate ramification is that dealing with asynchronous Byzantine systems does not call for new topological methods, as was recently employed by various researchers: Asynchronous Byzantine is a standard asynchronous system with an input caveat. It also shows that two recent independent investigations of vector -agreement in the Byzantine model, and then in the fail-stop model, one was superfluous - in these problems the change of  inputs allowed in the Byzantine has no effect compared to the fail-stop case. This result was motivated by the aim of casting any asynchronous system as a synchronous system where all processors are correct and it is the communication substrate in the form of message-adversary that misbehaves. Thus, in addition, we get such a characterization for the asynchronous Byzantine system.", "num_citations": "4\n", "authors": ["490"]}
{"title": "Fault-tolerant distributed systems in hardware\n", "abstract": " Very large-scale integrated (VLSI) circuits bear several similarities with the systems studied by the distributed computing community:", "num_citations": "4\n", "authors": ["490"]}
{"title": "Distributed sensor selection via gaussian belief propagation\n", "abstract": " The sensor selection problem is a boolean convex optimization problem; given m sensor measurements we aim at finding k< m measurements that minimizes the logarithm of the volume of the \u03b7-confidence ellipsoid, which is a measure of the uncertainty in the data. This problem is known to be NP-hard. Recent work by Joshi and Boyd proposes a centralized solution of the relaxed sensor selection problem using an efficient interior point method. In this work we extend the previous construction forming two distributed algorithms. The first algorithm is a distributed version of the interior point method by Joshi and Boyd, and the second algorithm is an order of magnitude faster approximation. As an example application we discuss distributed anomaly detection in networks. We demonstrate the applicability of our solution using both synthetic data and real traffic logs collected from the Abilene Internet backbone.", "num_citations": "4\n", "authors": ["490"]}
{"title": "An integrated architecture for the scalable delivery of semi-dynamic web content\n", "abstract": " The competition on clients attention requires sites to update their content frequently. As a result, a large percentage of Web pages are semi-dynamic, i.e., change quite often and stay static between changes. The cost of maintaining consistency for such pages discourages caching solutions. We suggest here an integrated architecture for the scalable delivery of frequently changing hot pages. Our scheme enables sites to dynamically select whether to cyclically multicast a hot page or to unicast it, and to switch between multicast and unicast mechanisms in a transparent way. Our scheme defines a new protocol, called h.t.t.p.m. In addition, it uses currently deployed protocols, and dynamically directs browsers seeking for a URL to multicast channels, while using existing DNS mechanisms. Thus, we enable sites to deliver content to a growing number of users at less cost and during denial of service attacks, while\u00a0\u2026", "num_citations": "4\n", "authors": ["490"]}
{"title": "SPADE: Statistical Packet Acceptance Defense Engine\n", "abstract": " A security engine should detect network traffic attacks at line-speed. \"Learning\" capabilities can help detecting new and unknown threats even before a vulnerability is exploited. The principal way for achieving this goal is to model anticipated network traffic behavior, and to use this model for identifying anomalies. This paper focuses on denial of service (DoS) attacks and distributed DoS (DDoS). Our goal is detecting and preventing of attacks. The main challenges include minimizing the false-positive rate and the memory consumption. SPADE: a Statistical Packet Acceptance Defense Engine is presented. SPADE is an accurate engine that uses an hierarchical adaptive structure to detect suspicious traffic using a relatively small memory footprint, therefore can be easily applied on hardware. SPADE is based on the assumption that during DoS/DDoS attacks, a significant portion of the traffic that is seen belongs to the\u00a0\u2026", "num_citations": "3\n", "authors": ["490"]}
{"title": "Mulan: Multi-level adaptive network filter\n", "abstract": " A security engine should detect network traffic attacks at line-speed. When an attack is detected, a good security engine should screen away the offending packets and continue to forward all other traffic. Anomaly detection engines must protect the network from new and unknown threats before the vulnerability is discovered and an attack is launched. Thus, the engine should integrate intelligent \u201clearning\u201d capabilities. The principal way for achieving this goal is to model anticipated network traffic behavior, and to use this model for identifying anomalies.               The scope of this research focuses primarily on denial of service (DoS) attacks and distributed DoS (DDoS). Our goal is detection and prevention of attacks. The main challenges include minimizing the false-positive rate and the memory consumption. In this paper, we present the mulan-filter. The mulan (MUlti-Level Adaptive Network) filter is an\u00a0\u2026", "num_citations": "3\n", "authors": ["490"]}
{"title": "Maxtream: Stabilizing P2P streaming by active prediction of behavior patterns\n", "abstract": " In theory, peer-to-peer (P2P) based streaming designs and simulations provide a promising alternative to server based streaming systems both in cost and scalability. In practice however, implementations of P2P based IPTV and VOD failed to provide a satisfying QoS as the characteristic fluctuational throughput of a peer's uplink leads to frequent annoying hiccups, substantial delays and latency for those who download from it. A significant factor for the unstable throughput of peers' uplink is the behavior of other processes running on the source peer that consume bandwidth resources.In this paper we propose Maxtream - a machine learning based solution that actively predicts load in the uplink of streaming peers and coordinates source peers exchanges between peers that suffer from buffer under run and peers that enjoy satisfactory buffer size for coping with future problems.Simulation and experiments have\u00a0\u2026", "num_citations": "3\n", "authors": ["490"]}
{"title": "Efficient peer-to-peer content distribution\n", "abstract": " We consider the problem of distributing data to a large and dynamic network of nodes. We formalize the next-step problem, which is intuitively the next action that each peer in the content distribution network should take, where an action is the transfer of one file part from a neighboring node.We formulate the next-step problem as an integer programming problem and use a probabilistic graphical model in order to find the most probable network state using inference. Each node takes the most probable action calculated locally. For running inference, we use the max-product belief propagation algorithm, a decentralized message-passing algorithm.", "num_citations": "3\n", "authors": ["490"]}
{"title": "Wire-speed total order\n", "abstract": " Many distributed systems may be limited in their performance by the number of transactions they are able to support per unit of time. In order to achieve fault tolerance and to boost a system's performance, active state machine replication is frequently used. It employs total ordering service to keep the state of replicas synchronized. In this paper, we present an architecture that enables a drastic increase in the number of ordered transactions in a cluster, using off-the-shelf network equipment. Performance supporting nearly one million ordered transactions per second has been achieved, which substantiates our claim", "num_citations": "3\n", "authors": ["490"]}
{"title": "Facilitating efficient and reliable monitoring through HAMSA\n", "abstract": " Monitoring is a fundamental building block of any network management system. It is needed to ensure that the network operates within the required parameters, and to account for user activities and resource consumption.               In the SNMP paradigm, network management systems have been structured using a two-tier architecture with managers being thick clients, and the target agents being thin servers. This architecture may be unreliable in times since it depends on the management station having an access to the targets. Network distance between the manager and the network elements also imposes high overhead traffic, large processing overheads, and long control loops. To overcome these drawbacks, distributed network management architectures based on a middleware layer were proposed. However, such approaches suffer both from the need to modify network elements, and the high (and\u00a0\u2026", "num_citations": "3\n", "authors": ["490"]}
{"title": "Hierarchical Bandwidth Sharing made Simple\n", "abstract": " The purpose of this paper is to develop simple yet general mechanisms that will enable hardware developers to offer flexible and powerful tools to address various QoS requirements. Our aim is to find the balance between the complexity of the tool and its expressive power. We found that using some simple mechanisms one can obtain the balance and is able to express the versatility of many QoS services.", "num_citations": "3\n", "authors": ["490"]}
{"title": "A quorum based approach to CORBA fault-tolerance\n", "abstract": " this paper we propose an approach based on quorum replication for providing fault-tolerance in middlewares compliant with the Common Object Request Broker Architecture (CORBA)[OMG99].", "num_citations": "3\n", "authors": ["490"]}
{"title": "The Design and Implementation of Lansis/E\n", "abstract": " Transis is a group communication system developed in the Hebrew University. It is a monolithic system written in the C programming language. Lansis is a subsystem of Transis containing its basic algorithms and data structures. Ensemble is a novel group communication system developed in Cornell. It has a modern design stressing exibility and modularity. The code is layered, written in a veri able, machine independent, functional language| OCAML. The Ensemble infrastructure supports tracing, debugging and semi-automatic optimization. This thesis presents the uni cation of Lansis and Ensemble in the form of the Lansis/E system. We redesigned Lansis structure and implemented it in the form of a set of Ensemble protocols. Thus, we achieved simple, robust, exible, extendable, portable code. Lansis was enhanced to support a stronger application programming model| Strong Virtual Synchrony. The user can now intermix Lansis and Ensemble protocols, further, new protocols may be added to the system using a framework we de ned. Such protocols would bene t from full interoperability with existing Lansis/E and Ensemble protocols", "num_citations": "3\n", "authors": ["490"]}
{"title": "Warm backup using snooping\n", "abstract": " Local area networks use a broadcast media to transfer messages between hosts. This allows for network snooping by unlisted parties. This paper proposes a novel way for cheaply replicating services in a local area network via snooping. We present a tool for the warm backup of files that employs network snooping for data dissemination. The tool allows for a selective replication of files in the system. The use of snooping significantly reduces the overhead of file replication. Operations on non-replicated files suffer only a slight overhead.< >", "num_citations": "3\n", "authors": ["490"]}
{"title": "Fault-tolerant critical section management in asynchronous networks\n", "abstract": " The topic of the paper is managing a fault-tolerant critical section in a completely asynchronous distributed network. Assume that processors may fail while using the critical section and therefore the critical section must have at least t+1 slots. (t is the maximum number of possible faulty processors).             There are several possibilities for defining a priority rule that achieves fairness among the processors. In [FLBB] processor p has a higher priority than processor q if p asked to access the critical section \u201cbefore\u201d q. In [ABDKPR] p has a higher priority than q if p used the critical section less than q. The drawback of the first rule (that motivated the second rule) is that a \u201cfast\u201d processor could use the critical section much more than a \u201cslow processor\u201d. The drawback of the second rule is that processors should use the critical section infinitely often in order to prevent deadlock. In this paper we modify the second rule\u00a0\u2026", "num_citations": "3\n", "authors": ["490"]}
{"title": "A message-passing solver for linear systems\n", "abstract": " We develop an efficient distributed message-passing solution for systems of linear equations based upon Gaussian belief propagation that does not involve direct matrix inversion.Solving a system of linear equations Ax= b is one of the most fundamental problems in algebra, with countless applications in the mathematical sciences and engineering. Given the observation vector b\u2208 Rn, n\u2208 N\u2217, and the data matrix A\u2208 Rn\u00d7 n, a unique solution, x= x\u2217\u2208 Rn, exists if and only if the data matrix A is full rank. In this contribution we concentrate on the popular case where the data matrices, A, are also symmetric.", "num_citations": "2\n", "authors": ["490"]}
{"title": "Indexing data-oriented overlay networks using belief propagation\n", "abstract": " In this paper we discuss the problem of data-oriented partitioning in large-scale overlay networks, as required by peer-topeer databases or by peer-to-peer information retrieval. The goal is to partition a large set of nodes into k partitions with the additional requirement of meeting certain load-balancing constraints without global knowledge of the network\u2019s parameters, ie, the desired number of partitions and the partition distribution function are not known in advance and change dynamically as the network evolves. This key problem in large-scale decentralized systems has so far received only very limited attention. The novel contributions described in the following are (1) the definition of a distributed algorithm for local estimation of the partitioning distribution function, which does not preclude the network\u2019s topology, and (2) a distributed method for performing the actual partitioning. As additional advantages, the algorithms do not require global knowledge and are completely decentralized, thus suitable for Peer-topeer networks. Both algorithms are based on the max-product belief propagation algorithm and give exact results on trees, and sufficiently accurate approximations on graphs containing cycles. We show the accuracy of the proposed algorithms in terms of the number of nodes per partition and the good load balancing of partitions in the network by simulation. Our algorithms are scalable and the accuracy of the partitioning improves with larger network sizes. Having shown the efficiency of our proposed algorithms, we discuss a natural application for our algorithm in the data-oriented P2P system P-Grid (http://www. p-grid. org/). Using P-Grid\u00a0\u2026", "num_citations": "2\n", "authors": ["490"]}
{"title": "Self-stabilizing byzantine token circulation\n", "abstract": " There is an abundance of writing about Token Circulation (or leader election). Much of the work is dedicated to self-stabilizing Token Circulation, ever since the publishing of Dijkstra\u2019s seminal paper. Few of the papers focus on the Byzantine fault model and, to the best of our knowledge, there is no self-stabilizing Token Circulation algorithm that tolerates Byzantine faults. In this paper, we present an elegant selfstabilizing Byzantine Token Circulation algorithm that has comparably good time and message complexities. It has optimal fairness and every node holds the token 1/n part of the time in the long run, where n is the number of nodes in the network. Our protocol is based on a tight Byzantine self-stabilizing pulse synchronization procedure. The synchronized pulses are used as events for initializing Byzantine consensus on the id of the next node to hold the token. When the system performs well the time complexity of our scheme is minimal, merely two communication rounds. When the system converges to a desired state following a chaotic situation the additional overhead is that of Byzantine consensus (O (f), where f is the actual number of faulty nodes).", "num_citations": "2\n", "authors": ["490"]}
{"title": "Claudiu Danilov\n", "abstract": " Claudiu Danilov - publications Research Teaching Publications Released Software About me nice places Claudiu Danilov Assistant Research Scientist Johns Hopkins University Department of Computer Science Office: 313 NEB Phone: 410-516-5562, Fax: 410-516-6134 E-mail: claudiu at cs.jhu.edu http://www.cs.jhu.edu/~claudiu Recent Publications An Overlay Architecture for High Quality VoIP Streams To appear in the IEEE Transactions on Multimedia. Yair Amir, Claudiu Danilov, Stuart Goose, David Hedqvist, Andreas Terzis. Fast Handoff for Seamless Wireless Mesh Networks In Proceedings of the International Conference on Mobile Systems Applications and Services (MobiSys 2006), pages 83-95, Uppsala, Sweden, June 2006. Yair Amir, Claudiu Danilov, Michael Hilsdale, Raluca Musaloiu-Elefteri, Nilo Rivera. Scaling Byzantine Fault-Tolerant Replication to Wide Area Networks In Proceedings of the on and (-\u2026", "num_citations": "2\n", "authors": ["490"]}
{"title": "Hierarchical reactive monitoring of multicast membership size\n", "abstract": " Knowing the number of active receivers in a multicast group is very important and useful for many applications. Retaining an exact count of the multicast group size is a very difficult task. Fortunately, estimating the group size rather than finding it exactly may be sufficient for applications like pricing. In particular, it may suffice to know at any given moment that the number of receivers in the group is between some predefined bounds, thresholds. This estimation is disseminated to the multicast ISPs worldwide. The ISPs then locally compute the price of transmitting a unit of bandwidth to the group, and present this price to senders in their domain.This paper concentrates on the algorithmic aspects of retaining multicast group size estimation for the purposes of accounting and pricing. We suggest novel network-level algorithms that combine a hierarchical control structure with a reactive (event-driven) monitoring mechanism in order to conserve network traffic and cope with the problem of feedback implosion.", "num_citations": "2\n", "authors": ["490"]}
{"title": "Towards highly available three-tier monitoring applications\n", "abstract": " Numerous important network management applications such as usage-based accounting, trend analysis, performance management, fault management, and others perform application-specific network monitoring tasks as part of their activities. This paper presents a work in progress that is aimed at providing a maximally transparent infrastructure increasing the availability of such management applications by improving the failure behavior of their constituent monitoring components.", "num_citations": "2\n", "authors": ["490"]}
{"title": "IP-SENATE: IP multicast SErvice for Non-broadcast Access networking TEchnology\n", "abstract": " In this paper we present an e cient implementation of IP multicast over ATM, called ip-senate: IP multicast SErvice for Non-broadcast Access networking TEchnology built on top of congress (CONnection oriented Group-address RESolution Service). Congress is an e cient native ATM protocol for resolution and management of multicast group addresses in a large ATM cloud. It complements the native ATM multicast mechanisms. Congress resolves multicast group addresses and maintains their membership for applications. It is not designed to handle the applications' dataexchange. Applications may use the resolved addresses returned by congress, in order to implement a many-to-many communication model (multicast group). Ip-senateis a proposal for an alternative implementation of IP multicast over ATM WAN using congress as an infrastructure. Ip-senate pursues the\\cut-through\" routing paradigm in order to exploit the underlying ATM QoS and native routing mechanisms in an optimal way.Ip-senate organizes IP multicast routers into logical groups, where each group corresponds to some class D IP address and contains routers that have members of this IP multicast group or senders to it in their domain. The resolution and management of these multicast router groups is performed through congress. An ip-senate extension at a multicast router uses the group membership information that it receives from congress, in order to open ATM connections that bypass (\\cut-through\") the IP routing mechanism. These connections either directly fan out to other multicast routers, or go through some intermediate multicast routers acting as multicast servers\u00a0\u2026", "num_citations": "2\n", "authors": ["490"]}
{"title": "Relationship between burst properties and sensitivity to input: a theoretical analysis\n", "abstract": " This paper examines the sensitivity of endogenous bursters to a brief input pulse. The interneurons of the lobster cardiac ganglion were selected as a case study. Using a mathematical model specifically developed for the neurons in the cardiac ganglion of the lobster (Av-Ron et al., 1993), we show a tight link between burst characteristics and certain other parameters. We show that cells with different burst properties differ in their sensitivity to an input of a brief pulse. Irrespective of these differences, all cells display a bimodal response to a brief pulse applied during the quiescent period. During the first three-quarters of the quiescent period, they respond by producing a single spike at most. During the remaining one-quarter, the brief pulse can initiate the cells' intrinsic burst. Our predictions fit experimental results obtained by Tazaki and Cooke (1979). The results obtained herein are discussed with respect to fault tolerance considerations.", "num_citations": "2\n", "authors": ["490"]}
{"title": "Theory and practice in distributed systems\n", "abstract": " Various protocols used in practical distributed systems that circumvent theoretical impossibility results have been presented. We have described similar issues that arise when one compares practical solutions to real distributed systems. Topics of interest for future research have been discussed.", "num_citations": "2\n", "authors": ["490"]}
{"title": "PCODE: efficient parallel computing over distributed environments\n", "abstract": " Parallel computing on clusters of workstations and personal computers has very high potential, since it leverages existing hardware and software. In fact, there are a number of existing commercial parallel programming environments that can run on top of clusters of workstations, for example, PVM, IBM PPE and EXPRESS by Parasoft. Parallel programming environments offer the user a convenient way for expressing parallel computation and communication. The communication part consists of the usual pointto-point communication as well as collective communication. However, existing programming environments for clusters are built on top of a point-to-point communication layer (send and receive) over local area networks(LAN.) and, as a result, suffer from poor communication performance. For example, a broadcast that is implemented using a TCP/IP protocol(which is a \u201creliable\u201d point-to-point protocol) over a\u00a0\u2026", "num_citations": "2\n", "authors": ["490"]}
{"title": "On safety and timeliness in distributed data management (preliminary report)\n", "abstract": " When partitions may occur with a positive probability there is no way to guarantee safety and timely operation. In most cases the probability of partition is small even though some components may be inoperative for long periods of time. Blocking prevents transient faults from causing a loss of consistency in the rare instances of partition. Much as we would like a truly nonblocking coordination protocol, Theorem 3.2 implies that guaranteed eventual communication is not enough to guarantee safety without blocking in an asynchronous environment, and Corollary 4.2 says that even in a synchronous environment, any safe atomic commit protocol is blocking.", "num_citations": "2\n", "authors": ["490"]}
{"title": "On the Security of Multi-Party Protocols in Distributed Systems\n", "abstract": " Security of protocols for network communication has received considerable attention in recent years. We concentrate on ensuring the security of cryptographic protocols in distributed systems.             In a distributed system, beyond eavesdropping, a saboteur may impersonate another user or alter messages being sent. A saboteur who is also a user may send conflicting messages or use other illegal messages in order to uncover secret information.             The problem we address, in its most general form, is: \u201cgiven a multi-party protocol which is provably secure when all the participants monitor every message being sent, can the protocol be modified to be secure in a distributed system?\u201d             We use the Byzantine Agreement, Crusader Agreement, and other specific checks to improve protocols by making them secure in a general distributed network. We examine the trade-off between detection of faulty\u00a0\u2026", "num_citations": "2\n", "authors": ["490"]}
{"title": "A comparative study of synchronization by parallel control systems\n", "abstract": " During recent years, an understanding of p arallel processing has j I been recognized as being essential to the e ffic ie nt use of th ird- j; generation computer systems and in the planning and development of j future systems. Many methods of synchronization between concurrent processes have been defined. There Is no precise way to evaluate j i# j these various models and to compare the fam ilies of synchornization|: prim itives, although much research has been done, and a sig n ifican t I amount of e ffo rt has been invested in solving this problem.", "num_citations": "2\n", "authors": ["490"]}
{"title": "Commutation relations of slices characterize some synchronization primitives\n", "abstract": " 3. ResultsLemma 1. Let@ b $ e 4 VRS on E, 7r= n (@ T&en a $ r* su= &Jy, PETr, poB: Tr.(0 (mu: factorization is unique b&t/3 can be empty.)", "num_citations": "2\n", "authors": ["490"]}
{"title": "Fault-tolerant Algorithms for Tick-Generation in Asynchronous Logic: Robust Pulse Generation [Extended Abstract]\u22c6\n", "abstract": " The advances of deep submicron VLSI technology pose new challenges in designing robust systems, which can in principle be addressed by approaches established in fault-tolerant distributed systems research. This paper is the first step in an attempt to develop a very robust high-precision clocking system for hardware designs like systemson-chip for critical applications. It is devoted to the design and the correctness proof of a novel Byzantine fault-tolerant self-stabilizing pulse synchronization protocol, which facilitates a direct implementation in standard asynchronous digital logic. Despite the severe implementation constraints, it offers optimal resilience and smaller complexity than all existing pulse synchronization protocols.", "num_citations": "2\n", "authors": ["490"]}
{"title": "A secure selection and filtering mechanism for the network time protocol version 4\n", "abstract": " A Secure Selection and Filtering Mechanism for the Network Time Protocol Version 4 Page 1 A Secure Selection and Filtering Mechanism for the Network Time Protocol Version 4 draft-schiff-ntp-chronos-02 Neta Rozen Schiff, Danny Dolev, Tal Mizrahi, Michael Schapira Page 2 Reminder: Threat Model The attacker: \u2022 Controls a large fraction of the NTP servers in the pool (say, \u00bc) \u2022 Capable of both deciding the content of NTP responses and timing when responses arrive at the client \u2022 Malicious NTP server NTP server NTP server client \u2026\u2026. Page 3 Reminder: Chronos Architecture Chronos\u2019 design combines several ingredients: \u2022 Rely on many NTP servers \u27a2 Generate a large server pool (hundreds) per client \u27a2Eg, by repeatedly resolving NTP pool hostnames and storing returned IPs \u27a2 Sets a very high threshold for a MitM attacker \u2022 Query few servers \u27a2 Randomly query a small fraction of the servers in the pool (eg, 10-\u2026", "num_citations": "1\n", "authors": ["490"]}
{"title": "Preventing (network) time travel with chronos\n", "abstract": " The Network Time Protocol (NTP) synchronizes time across computer systems over the Internet. Unfortunately, NTP is highly vulnerable to\" time shifting attacks\", in which the attacker's goal is to shift forward/backward the local time at an NTP client. This has severe implications for the correctness and safety of time-sensitive applications and for security mechanisms. Importantly, time shifting attacks on NTP are possible even if all NTP communications are encrypted and authenticated.", "num_citations": "1\n", "authors": ["490"]}
{"title": "LogMemcached: an RDMA based continuous cache replication\n", "abstract": " One of the advantages of cloud computing is its ability to quickly scale out services to meet demand. A common technique to mitigate the increasing load in these services is to deploy a cache.", "num_citations": "1\n", "authors": ["490"]}
{"title": "Stateless computation\n", "abstract": " We present and explore a model of stateless and self-stabilizing distributed computation, inspired by real-world applications such as routing on today's Internet. Processors in our model do not have an internal state, but rather interact by repeatedly mapping incoming messages (\" labels\") to outgoing messages and output values. While seemingly too restrictive to be of interest, stateless computation encompasses both classical game-theoretic notions of strategic interaction and a broad range of practical applications (eg, Internet protocols, circuits, diffusion of technologies in social networks). Our main technical contribution is a general impossibility result for stateless self-stabilization in our model, showing that even modest asynchrony (with wait times that are linear in the number of processors) can prevent a stateless protocol from reaching a stable global configuration. Furthermore, we present hardness results for\u00a0\u2026", "num_citations": "1\n", "authors": ["490"]}
{"title": "Synchronous Hybrid Message-Adversary\n", "abstract": " The theory of distributed computing, lagging in its development behind practice, has been biased in its modelling by employing mechanisms within the model mimicking reality. Reality means, processors can fail. But theory is about predicting consequences of reality, hence if we capture reality by \"artificial models,\" but those nevertheless make analysis simpler, we should pursue the artificial models. Recently the idea was advocated to analyze distributed systems and view processors as infallible. It is the message delivery substrate that causes problems. This view not only can effectively emulate reality, but above all seems to allow to view any past models as \\emph{synchronous} models. Synchronous models are easier to analyze than asynchronous ones. Furthermore, it gives rise to models we haven't contemplated in the past. One such model, presented here, is the Hybrid Message-Adversary. We motivate this model through the need to analyze Byzantine faults. The Hybrid model exhibits a phenomenon not seen in the past.", "num_citations": "1\n", "authors": ["490"]}
{"title": "Distributed fault identification via non-parametric belief propagation\n", "abstract": " We consider the problem of estimating a pattern of faults, represented as a binary vector, from a set of measurements. Maximum a posteriori probability (MAP) estimation of the fault pattern leads to a difficult combinatorial optimization problem. Following recent success of the belief propagation framework in the related compressive sensing and low density lattice decoding domains, we propose a novel relaxation of the problem using non-parametric belief propagation (NBP) for creating a distributed solution. We show empirically that our NBP solver has the highest accuracy relative to seven related algorithms, including a recent interior point algorithm by Zymnis et al As far as we know, this is the first work that links NBP to the solution of interior point methods.", "num_citations": "1\n", "authors": ["490"]}
{"title": "Self-stabilizing numerical iterative computation\n", "abstract": " Many challenging tasks in sensor networks, including sensor calibration, ranking of nodes, monitoring, event region detection, collaborative filtering, collaborative signal processing, etc., can be formulated as a problem of solving a linear system of equations. Several recent works propose different distributed algorithms for solving these problems, usually by using linear iterative numerical methods. In this work, we extend the settings of the above approaches, by adding another dimension to the problem. Specifically, we are interested in self-stabilizing algorithms, that continuously run and converge to a solution from any initial state. This aspect of the problem is highly important due to the dynamic nature of the network and the frequent changes in the measured environment. In this paper, we link together algorithms from two different domains. On the one hand, we use the rich linear algebra literature of linear iterative\u00a0\u2026", "num_citations": "1\n", "authors": ["490"]}
{"title": "On Implementing Robust and Resilient Mediators\n", "abstract": " We consider games that have (k, t)-robust equilibria when played with a mediator, where an equilibrium is (k, t)-robust if it tolerates deviations by coalitions of size up to k and deviations by up to t players with unknown utilities. We matching lower bounds and upper bounds on the ability to implement such mediators using cheap talk (that is, just allowing communication among the players). The bounds depend on (a) the relationship between k, t and n, the total number of players in the system;(b) whether players know the exact utilities of other players;(c) whether there are broadcast channels or just point-to-point channels;(d) whether cryptography is available; and (e) whether the game has a (k+ t)-punishment strategy; that is, a strategy that, if used by all but at most k+ t players, guarantees that every player gets a worse outcome than they do with the equilibrium strategy.", "num_citations": "1\n", "authors": ["490"]}
{"title": "Century papers at the first quarter-century milestone\n", "abstract": " My talk intends to look back at the first 25 years of PODC to surface issues regarding its potential impact in light of the extensive spread out of Distributed Computing. Distributed computing expands to a level that no one anticipated even few years ago. In the near future distributed computing will be part of every aspect of our life--from monitoring personal health to environment tracking, from communication to commuting and will be applied from within a chip through a multi-cpu machine to a virtual globally spanned machine. Society will be completely depended on the ability to continuously provide services at one level or another. The various systems will interact and will never be in a steady state. Are we ready to address such issues? Is the tool-box PODC have developed over the last quarter century will help the community to address the challenges of such systems. When PODC was founded there were skeptics\u00a0\u2026", "num_citations": "1\n", "authors": ["490"]}
{"title": "Brief announcement: linear time byzantine self-stabilizing clock synchronization\n", "abstract": " We present the first self-stabilizing Byzantine clock synchronization algorithm that has linear convergence time.", "num_citations": "1\n", "authors": ["490"]}
{"title": "Rate allocation protocol using competitive pricing for improving performance of multicast sessions\n", "abstract": " Rate allocation using the Max-Min fairness criterion may highly discriminate against multicast and long unicast sessions and may lead to sever network underutilization. In this paper, we present a solution for rate allocation that is based on competitive pricing. The resultant allocation increases fairness towards multicast sessions and improves network utilization considerably. The solution requires no re-routing of sessions. The economy on which we base our solution is simple enough, enabling its implementation for practical use. We present a distributed asynchronous protocol suitable for the ATM ABR service, which achieves the economy's allocation efficiently and with short convergence time.", "num_citations": "1\n", "authors": ["490"]}
{"title": "Bounded Concurrent Time-Stamp Systems Are Constructible\n", "abstract": " Concurrent time stamping is at the heart of solu-tions to some of the most fundamental problems in distributed computing. Based on concurrenttime-stamp-systems, elegant and simple solu-tions to core problems such as/c/s-mutualexclusion, construction of a multi-reader-multiwriter atomic register, probabilistic consensus,... were developed. Unfortunately, the only known implementation of a concurrent time stamp sys-tem has been theoretically unsatisfying, since it requires unbounded size time-stamps, in other words, unbounded memory. Not knowing if bounded concurrent-time-stamp-systems are at all constructive, researchers were led to con-structing complicated problem-specific solutions to replace the simple unbounded ones. In this work, for the first time, a bounded implemen-tation of a concurrent-time-stamp-system is pre-", "num_citations": "1\n", "authors": ["490"]}
{"title": "Finding safe paths in a faulty environment\n", "abstract": " This paper addresses the problem of finding safe paths through a network, some of whose nodes may be faulty. By a safe path we mean one between two nodes that does not contain any faulty node. The kinds of faults that concern us are not limited to those that may cause a failure of a node or link, but include those that may cause a node to distort messages in arbitrary ways. Furthermore, we want a distributed algorithm to allow the network itself to discover suitable paths without depending on a central controller for the analysis. More broadly, we assume that each node has only local knowledge of the network structure.", "num_citations": "1\n", "authors": ["490"]}
{"title": "Coordination Problems in Distributed Systems\n", "abstract": " In this paper we provide a framework for understanding and comparing various lower bounds and impossibility results concerning the solution to coordination problems like atomic commit for distributed transactions and other consensus problems. The key to our treatment is the distinction between information that is transferred by (datagram) messages and information that can be deduced from the existence of other synchronization mechanisms. We provide an axiomatic theory of distributed systems in which such distinctions can be made; and, in the context of this theory, we describe a single paradigm involving the isolation of one process from the effects of another process in a distributed system. Using this paradigm we obtain several well known impossibility results including the impossibility of a synchronous system with a safe and timely (nonblocking) atomic commit in the presence of a possible communication partition, the impossibility of an asynchronous system that reaches consensus in the presence of at most one crash fault, and the impossibility of a solution to the Chinese Generals' Problem. We explain how these impossibility results imply the impossibility of a nonblocking consensus or atomic commit in a synchronous or asynchronous system in which all faults are eventually repaired but synchronous communication is not guaranteed.Having established this family of limits on distributed systems, we discuss the feasibility of achieving with high probability goals that are impossible to guarantee. We suggest a family of simple atomic commit protocols that guarantee safety (consistency of data) and provide timeliness (absence of blocking\u00a0\u2026", "num_citations": "1\n", "authors": ["490"]}