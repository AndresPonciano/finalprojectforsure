{"title": "On Non-Functional Requirements\n", "abstract": " Although the term 'non-functional requirement' has been in use for more than 20 years, there is still no consensus in the requirements engineering community what non-functional requirements are and how we should elicit, document, and validate them. On the other hand, there is a unanimous consensus that non-functional requirements are important and can be critical for the success of a project. This paper surveys the existing definitions of the term, highlights and discusses the problems with the current definitions, and contributes concepts for overcoming these problems.", "num_citations": "906\n", "authors": ["1478"]}
{"title": "An Integrated Formal Model of Scenarios Based on Statecharts\n", "abstract": " State automata are an attractive means for formally representing scenarios. Scenarios describe how users interact with a system. However, the current approaches treat every scenario as a separate entity.             This paper introduces a statechart-based model that allows the formal composition of all scenarios of a system into an integrated, consistent model of external system behavior. The scenarios remain visible as building blocks in the model. The meaning of the integrated model is derived from the meanings of the constituent scenarios and from the semantics of the composition rules.             The paper defines the composition rules and shows their application. The capabilities for analyzing and verifying the model are demonstrated. An extension of the scenario model to a general system model is sketched.", "num_citations": "197\n", "authors": ["1478"]}
{"title": "Problems and Deficiencies of UML as a Requirements Specification Language\n", "abstract": " In recent years, UML has become a standard language for modeling software requirements and design. We investigate the suitability of UML as a semiformal requirements specification language. Using the Teleservices and Remote Medical Care (TRMCS) case study as an example, we identify and demonstrate various problems and deficiencies of UML, particularly concerning use case models and system decomposition. We also investigate whether and how the deficiencies can be overcome and how potential alternatives could look.", "num_citations": "188\n", "authors": ["1478"]}
{"title": "Rethinking the Notion of Non-Functional Requirements\n", "abstract": " Requirements standards and textbooks typically classify requirements into functional requirements on the one hand and attributes or non-functional requirements on the other hand. In this classification, requirements given in terms of required operations and/or data are considered to be functional, while performance requirements and quality requirements (such as requirements about security, reliability, maintainability, etc.) are classified as nonfunctional.In this paper, we present arguments why this notion of non-functional requirements is flawed and present a new classification of requirements which is based on four facets: kind (eg function, performance, or constraint), representation (eg operational, quantitative or qualitative), satisfaction (hard or soft), and role (eg prescriptive or assumptive). We define the facets, discuss typical combinations of facets and argue why such a faceted classification of requirements is better than the traditional notion of functional and non-functional requirements.", "num_citations": "157\n", "authors": ["1478"]}
{"title": "A Scenario-Based Approach to Validating and Testing Software Systems Using Statecharts\n", "abstract": " Scenarios (Use cases) are used to describe the functionality and behavior of a (software) system in a user-centered perspective. As scenarios form a kind of abstract level test cases for the system under development, the idea to use them to derive test cases for system test is quite intriguing. Yet in practice scenarios from the analysis phase are seldom used to create concrete system test cases. In this paper we present a procedure to create scenarios in the analysis phase and use those scenarios in system test to systematically determine test cases. This is done by formalization of scenarios into statecharts, annotation of statecharts with helpful information for test case creation/generation and by path traversal in the statecharts to determine concrete test cases.", "num_citations": "113\n", "authors": ["1478"]}
{"title": "Improving the Quality of Requirements with Scenarios\n", "abstract": " The classical notion of requirements quality is problematic in practice. Hence the importance of some qualities, in particular completeness and unambiguity, has to be rethought. Scenarios, the description of requirements as sequences of interactions, prove to be a key concept for writing requirements specifications that are oriented towards such a modified set of qualities.In this paper, the potential of scenarios for improving the quality of requirements is discussed. Furthermore, a concept for systematically representing both single scenarios and the structure and relationships in a set of scenarios is presented. Using an example, the positive impact of this style of representation on the quality of the requirements is demonstrated.", "num_citations": "105\n", "authors": ["1478"]}
{"title": "A Classification of Stereotypes for Object-Oriented Modeling Languages\n", "abstract": " The Unified Modeling Language UML and the Open Modeling Language both have introduced stereotypes as a new means for user-defined extensions of a given base language. Stereotypes are a very powerful feature. They allow modifications ranging from slight notational changes up to the redefinition of the base language. However, the power of stereotypes entails risk. Badly designed stereotypes can do harm to a modeling language. In order to exploit the benefits of stereotypes and to avoid their risks, a better understanding of the nature and the properties of stereotypes is necessary.               In this paper, we define a framework that classifies stereotypes according to their expressive power. We identify specific properties and typical applications for stereotypes in each of our four categories and illustrate them with examples. For each category, we discuss strengths and weaknesses of stereotypes and\u00a0\u2026", "num_citations": "105\n", "authors": ["1478"]}
{"title": "Object-oriented modeling with ADORA\n", "abstract": " In this paper, we present the Adora approach to object-oriented modeling of software (Adora stands for analysis and description of requirements and architecture). The main features of Adora that distinguish it from other approaches like UML are the use of abstract objects (instead of classes) as the basis of the model, a systematic hierarchical decomposition of the modeled system and the integration of all aspects of the system in one coherent model. The paper introduces the concepts of Adora and the rationale behind them, gives an overview of the language, sketches a novel concept for visualizing the model hierarchy with a tool and reports the results of a validation experiment for the Adora language.", "num_citations": "94\n", "authors": ["1478"]}
{"title": "A Little Bird Told Me: Mining Tweets for Requirements and Software Evolution\n", "abstract": " Twitter is one of the most popular social networks. Previous research found that users employ Twitter to communicate about software applications via short messages, commonly referred to as tweets, and that these tweets can be useful for requirements engineering and software evolution. However, due to their large number---in the range of thousands per day for popular applications---a manual analysis is unfeasible.In this work we present ALERTme, an approach to automatically classify, group and rank tweets about software applications. We apply machine learning techniques for automatically classifying tweets requesting improvements, topic modeling for grouping semantically related tweets and a weighted function for ranking tweets according to specific attributes, such as content category, sentiment and number of retweets. We ran our approach on 68,108 collected tweets from three software applications and\u00a0\u2026", "num_citations": "93\n", "authors": ["1478"]}
{"title": "Runtime Adaptation of Applications through Dynamic Recomposition of Components\n", "abstract": " Software applications executing in highly dynamic environments are faced with the challenge of frequent and usually unpredictable changes in their execution environment. In order to cope with this challenge effectively, the applications need to adapt to these changes dynamically. CASA (Contract-based Adaptive Software Architecture) provides a framework for enabling dynamic adaptation of applications, in response to changes in their execution environment. One of the principle adaptation mechanisms employed in the CASA framework is dynamic recomposition of application components. In this paper, we discuss implementation issues related to the approach for dynamic recomposition of application components in CASA.", "num_citations": "88\n", "authors": ["1478"]}
{"title": "SCENT: A Method Employing Scenarios to Systematically Derive Test Cases for System Test\n", "abstract": " Software plays an ever increasing role in nowadays systems in most any application domain\u2013be it in the financial area (banking, insurance), public services, communication, management, embedded control systems or in process control and production processes (CIM). To achieve the goals of short time to market, best use of resources and thus meet target cost and schedule, a trend to release software that has not been tested properly can be detected. But as soon as persons health or life may be affected, software has to be thoroughly tested. Safety critical software has to be dependable in all critical functions, because a failure could lead to catastrophic consequences, such as serious injury, loss of life or property. Software testing is a critical element in assuring correct functioning of critical functions and helps establish confidence in a systems reliability. The cost of system failure is a motivating force to test a system thoroughly, extensively and in a well-planned, systematic fashion. Manufacturers of high security or high availability systems can not afford to have systems out that do not adhere to given quality criteria.Thus, it is a major concern and goal to produce and deliver software of high and predictable quality in time and meeting cost restrictions. The timely delivery of complex good quality software depends on several critical factors, among them requirements validation and system test are prominent ones and they are widely recognized as particularly important issues1. In requirements validation the requirements captured in a specification are tried to see if they adequately and completely state the needs of the users. In system test on the\u00a0\u2026", "num_citations": "87\n", "authors": ["1478"]}
{"title": "A Risk-Based, Value-Oriented Approach to Quality Requirements\n", "abstract": " When quality requirements are elicited from stakeholders, they're often stated qualitatively, such as \"the response time must be fast\" or \"we need a highly available system\". However, qualitatively represented requirements are ambiguous and thus difficult to verify. The value-oriented approach to specifying quality requirements uses a range of potential representations chosen on the basis of assessing risk instead of quantifying everything.", "num_citations": "86\n", "authors": ["1478"]}
{"title": "A Lightweight Approach to Consistency of Scenarios and Class Models\n", "abstract": " Today, object-oriented requirements specifications typically combine a scenario (or use case) model and a class model for expressing functional requirements. With any such combination, the problem of consistency between these two models arises. We present a lightweight approach to consistency between a scenario model and a class model. We assume semi-formal, loosely coupled models that are complementary: scenarios model the external system behavior; the class model specifies the internal, state-dependent functionality, that cannot be expressed easily in a scenario (but is required to specify external behavior properly). We achieve consistency by minimizing overlap between the two models and by systematically cross-referencing corresponding information. We give a set of rules that can be used both for developing a consistent specification and for checking the consistency of a completed\u00a0\u2026", "num_citations": "81\n", "authors": ["1478"]}
{"title": "Using popular social network sites to support requirements elicitation, prioritization and negotiation\n", "abstract": " Social networks have changed our daily life and they have the potential to significantly influence and support Requirements Engineering (RE) activities. Social network-based RE approaches will allow us to overcome limitations of traditional approaches and allow end users to play a more prominent role in RE. They are key stakeholders in many software projects. However, involving end users is challenging, particularly when they are not within organizational reach. The goal of our work is to increase end user involvement in RE. In this paper we present an approach where we harness a social network to perform RE activities such as elicitation, prioritization and negotiation. Our approach was applied in three studies where students used Facebook to actively participate in RE activities of different projects. Although there are limitations, the results show that a popular social network site can support distributed RE.", "num_citations": "80\n", "authors": ["1478"]}
{"title": "Using Dependency Charts to Improve Scenario-Based Testing\n", "abstract": " Scenarios (use cases) are used in many modern software engineering methods for capturing requirements and specifying a system. Yet prominent and renowned approaches like the UML (Unified Modeling Language [1]) are missing a concept for modeling dependencies and relations between scenarios and offer only little support for the management and description of scenarios and inter-scenario relationships. Furthermore, analysis scenarios are hardly ever used in testing, even though scenarios form a kind of abstract test cases.In this paper we introduce a new kind of chart and a notation to model dependencies between scenarios. We call it dependency chart. We introduce a method to use scenarios and dependency charts in testing to support testers to systematically develop test cases for system test.", "num_citations": "78\n", "authors": ["1478"]}
{"title": "A Glossary of Requirements Engineering Terminology\n", "abstract": " When looking for definitions of terms in Requirements Engineering, one can find definitions for almost any term by searching the web. However, such searching requires effort and the quality of the results is unpredictable. Frequently, definitions found in different sources are inconsistent with each other. Existing glossaries in Requirements Engineering textbooks mostly focus on the topics covered in these books. Systematic translations of terminology into major languages other than English are missing completely. This glossary aims at collecting the existing knowledge on Requirements Engineering terminology and defining the core terminology carefully and consistently. In cases where more than one definition is in use or where terms are defined differently when viewed from different perspectives, multiple definitions or perspectives are included. For terms having both a general meaning and a specific meaning in\u00a0\u2026", "num_citations": "64\n", "authors": ["1478"]}
{"title": "FlexiSketch: A Mobile Sketching Tool for Software Modeling\n", "abstract": " Although most software engineers have access to various modeling tools, they often use paper and pencil to sketch ideas and to support modeling activities. This is particularly true when they are working in the field, for example gathering requirements from stakeholders. Sketches documented on paper very often need to be re-modeled in order to allow further processing \u2013 an error-prone and time-consuming task. The aim of our work is to better integrate these early sketching and modeling activities into the overall software engineering process. We have prototyped FlexiSketch, a mobile application that supports freeform, flexible, in-situ modeling and allows software engineers to annotate their models. Apart from the application and the underlying conceptual solution we also present the results of initial experiments. Those suggest that the tool supports freeform sketching similar to paper and pencil, and that\u00a0\u2026", "num_citations": "63\n", "authors": ["1478"]}
{"title": "Statecharts For Requirements Specification\u2013As Simple As Possible, As Rich As Needed\n", "abstract": " Statecharts have evolved into a widely used instrument for specifying system behavior and interaction. Several variants of statecharts have been developed, for example, Harel's original statecharts, UML state machines or derived concepts such as the state machines in RSML.", "num_citations": "56\n", "authors": ["1478"]}
{"title": "A Practical Approach to Validating and Testing Software Systems using Scenarios\n", "abstract": " . Scenarios (Use cases) are a means to capture a system's functionality and behavior in a user-centered perspective. Thus they are used in most modern objectoriented software development methods to help elicit and document user requirements. Scenarios also form a kind of abstract level test cases for the system under development. Yet they are seldom used to derive concrete system test cases. In this paper we present a procedure to use scenarios in a defined way to systematically derive test cases for system test. This is done by formalization of natural language scenarios into statecharts, annotation of statecharts with helpful information for test case creation/generation and by path traversal in the statecharts to determine concrete test cases. 1. Introduction In developing a software system, validation and verification are recognized as vital activities. They are especially valuable when applied early in the development process, as errors found during the specification and...", "num_citations": "54\n", "authors": ["1478"]}
{"title": "How Cloud Providers Elicit Consumer Requirements: An Exploratory Study of Nineteen Companies\n", "abstract": " Requirements elicitation is widely seen as a crucial step towards delivering successful software. In the context of emerging cloud systems, the question is whether and how the elicitation process differs from that used for traditional systems, and if the current methods suffice. We interviewed 19 cloud providers to gain an in-depth understanding of the state of practice with regard to the adoption and implementation of existing elicitation methods. The results of this exploratory study show that, whereas a few cloud providers try to implement and adapt traditional methods, the large majority uses ad-hoc approaches for identifying consumer needs. There are various causes for this situation, ranging from consumer reachability issues and previous failed attempts, to a complete lack of development strategy. The study suggests that only a small number of the current techniques can be applied successfully in cloud systems\u00a0\u2026", "num_citations": "48\n", "authors": ["1478"]}
{"title": "FLEXISKETCH TEAM: Collaborative Sketching and Notation Creation on the Fly\n", "abstract": " When software engineers collaborate, they frequently use whiteboards or paper for sketching diagrams. This is fast and flexible, but the resulting diagrams cannot be interpreted by software modeling tools. We present FLEXISKETCH TEAM, a tool solution consisting of a significantly extended version of our previous, single-user FLEXISKETCH tool for Android devices and a new desktop tool. Our solution for collaborative, model-based sketching of free-form diagrams allows users to define and re-use diagramming notations on the fly. Several users can work simultaneously on the same model sketch with multiple tablets. The desktop tool provides a shared view of the drawing canvas which can be projected onto an electronic whiteboard. Preliminary results from an exploratory study show that our tool motivates meeting participants to actively take part in sketching as well as defining ad-hoc notations.", "num_citations": "45\n", "authors": ["1478"]}
{"title": "Tool Support for the Navigation in Graphical Models\n", "abstract": " Graphical models are omnipresent in the software engineering field, but most current graphical modeling languages do not scale with the increasing size and complexity of today's systems. The navigation in the diagrams becomes a major problem especially if different aspects of the system are scattered over multiple, only loosely coupled diagrams.", "num_citations": "35\n", "authors": ["1478"]}
{"title": "An Improved Fisheye Zoom Algorithm for Visualizing and Editing Hierarchical Models\n", "abstract": " Hierarchical decomposition is an important means for organizing and understanding large requirements and design models. Fisheye zoom visualization is an attractive means for viewing, navigating and editing such hierarchical models, because local detail and its surrounding global context can be displayed in a single view. However, existing fisheye view approaches have deficiencies in terms of layout stability when model nodes are zoomed-in and zoomed-out. Furthermore, most of them do not support model editing (moving, adding and deleting nodes) well. In this paper, we present an improved fisheye zoom algorithm which supports viewing and manipulating hierarchical models. Our algorithm solves the problem of having a user-editable layout which is nevertheless stable under multiple zooming operations. Furthermore, it supports multiple focal points, and runs in real-time.", "num_citations": "35\n", "authors": ["1478"]}
{"title": "A Framework for Dynamically Adaptive Applications in a Self-Organized Mobile Network Environment\n", "abstract": " Self-organized mobile networks present a challenging environment for the execution of software applications, due to their dynamic topologies and consistently changing resource conditions. In view of the above, a desirable property for software applications to be run over these networks is their ability to dynamically adapt to changing execution environments. The contract-based adaptive software architecture (CASA) provides a framework for the development of adaptive applications that are able to adapt their functionality and/or performance dynamically in response to runtime changes in their execution environments. The approach of the CASA framework is to decouple application code from any assumptions about resource availability, while enabling the application to execute under varying resource conditions. The CASA framework relies on specifying adaptation behavior of applications in application contracts\u00a0\u2026", "num_citations": "35\n", "authors": ["1478"]}
{"title": "Modeling and Managing Tacit Product Line Requirements Knowledge\n", "abstract": " The success of very large product lines systems with globally distributed stakeholders often builds significantly on the implicit knowledge of individuals. Final products are typically built by integrating numerous detailed specifications of subsystems. But how exactly all these parts can and need to be integrated to build valid end products is often left unspecified and to numerous discussions, reviews and the expertise of senior architects and product managers. Building a highlevel product line requirements model that explicitly and formally specifies common and variable requirements, their precise integration semantics and the constraints for selecting variable features helps significantly to manage this crucial and often tacit requirements knowledge. Based on an industrial exemplar we motivate and demonstrate such an approach and discuss our early findings regarding knowledge and rationale management in\u00a0\u2026", "num_citations": "33\n", "authors": ["1478"]}
{"title": "The CASA Approach to Autonomic Applications\n", "abstract": " In today\u2019s world of highly dynamic computing en-vironments, autonomic applications are the need of the hour. By an autonomic application, we mean an application that is able to adapt to changes in its execution environment dynamically and transparently. CASA (Contract-based Adaptive Software Architecture) provides a framework for enabling the development and operation of autonomic applications. CASA helps in significantly reducing the complexity involved in developing autonomic applications by separating the adaptation concerns of an application from its business concerns. CASA further provides a runtime system for dealing with the adaptation concerns. In order to meet the adaptation needs of a broad and diverse set of applications, CASA supports adaptation at various levels of an application\u2013from lower-level services to application code. In CASA, the adaptation policy of every application is defined in a so-called application contract, which is external to the application and is specified using an XML-based language, thereby facilitating changes in the adaptation policy at runtime.", "num_citations": "33\n", "authors": ["1478"]}
{"title": "The ADORA Approach to Object-Oriented Modeling of Software\n", "abstract": " In this paper, we present the ADORA approach to object-oriented modeling of software (ADORA stands for Analysis and Description of Requirements and Architecture). The main features of ADORA that distinguish it from other approaches like UML are the use of abstract objects (instead of classes) as the basis of the model, a systematic hierarchical decomposition of the modeled system and the integration of all aspects of the system in one coherent model. The paper introduces the concepts of ADORA and the rationale behind them, gives an overview of the language, and reports the results of a validation experiment for the ADORA language.", "num_citations": "33\n", "authors": ["1478"]}
{"title": "Scenario-Driven Modeling and Validation of Requirements Models\n", "abstract": " Requirements models for large systems typically cannot be developed in a single step, but evolve in a sequence of iterations. We have developed such an iterative modeling process which is based on the interactive simulation of yet incomplete and semi-formal models. Missing parts are completed interactively by the user simulating the model. We start by modeling type scenarios (ie use cases) and simulate these interactively before having specified any system behavior. Such simulation runs yield exemplary system behavior in form of message sequence charts (MSCs). The modeler can then generalize this recorded partial behavior into statecharts. The resulting model is simulated again,(i) for validating that the modeled behavior matches the previously recorded behavior, and (ii) for recording new yet unspecified behavior in a next iteration step. Thus, recording MSCs by playing-through the scenarios and\u00a0\u2026", "num_citations": "31\n", "authors": ["1478"]}
{"title": "A Survey of Simulation Tools for Requirements Engineering\n", "abstract": " Validation of requirements specifications is undoubtly an integral and indispensable part of requirements engineering. Validation is the process of checking whether requirements specifications meet the intentions and expectations of the stakeholders. One approach to support the process of validation is based on simulation/execution and animation of system (behaviour) models that are derived from initial requirements specifications. However, the benefit of executable models is determined by the capabilities of the corresponding simulation tools. This paper presents a survey on simulation and animation capabilities of ten modern software/system engineering tools.", "num_citations": "29\n", "authors": ["1478"]}
{"title": "Sketching and Notation Creation with FlexiSketch Team: Evaluating a New Means for Collaborative Requirements Elicitation\n", "abstract": " Whiteboards and paper allow for any kind of notations and are easy to use. Requirements engineers love to use them in creative requirements elicitation and design sessions. However, the resulting diagram sketches cannot be interpreted by software modeling tools. We have developed FlexiSketch as an alternative to whiteboards in previous work. It is a mobile tool for model-based sketching of free-form diagrams that allows the definition and re-use of diagramming notations on the fly. The latest version of the tool, called FlexiSketch Team, supports collaboration with multiple tablets and an electronic whiteboard, such that several users can work simultaneously on the same model sketch. In this paper we present an exploratory study about how novice and experienced engineers sketch and define ad-hoc notations collaboratively in early requirements elicitation sessions when supported by our tool. Results show\u00a0\u2026", "num_citations": "27\n", "authors": ["1478"]}
{"title": "Visualizing Product Line Domain Variability by Aspect-Oriented Modeling\n", "abstract": " Modeling variability is a core problem in software product line engineering. The relationship between variability and commonality in a software product line bears strong similarities to the relationship between crosscutting concerns and core concerns in aspect-oriented modeling. So modeling variability with aspect-oriented techniques is an obvious idea which has been exploited before to some extent. In this paper, we propose a new approach to modeling and visualizing variability by a combination of aspect-oriented variability modeling with table-based modeling of configuration possibilities and constraints. As a modeling language, we use a slightly extended version of the ADORA language. Our main contributions are a visual, integrated model comprising both the commonality and the variability of the product line and a novel mechanism for synthesizing products from this model based on the aspect weaving\u00a0\u2026", "num_citations": "27\n", "authors": ["1478"]}
{"title": "Rigorous EBNF-Based Definition for a Graphic Modeling Language\n", "abstract": " Today, the syntax of visual specification languages such as UML is typically defined using meta-modelling techniques. However, this kind of syntax definition has drawbacks. In particular, graphic meta-models are not powerful enough, so they must be augmented by a textual constraint language. As an alternative, we present a text-based technique for the syntax definition of a graphic specification language. We exploit the fact that in a graphic specification language, most syntactic features are independent of the layout of the graph. So we map the graphic elements to textual ones and define the context-free syntax of this textual language in EBNF. Using our mapping, this grammar also defines the syntax of the graphic language. Simple spatial and context-sensitive constraints are then added by attributing the context-free grammar. Finally, for handling complex structural and dynamic information in the syntax, we\u00a0\u2026", "num_citations": "26\n", "authors": ["1478"]}
{"title": "An exploratory study on handling requirements and acceptance test documentation in industry\n", "abstract": " With the emergence and spread of agile processes, the practices of writing and maintaining documentation have drastically changed in the last decade. In this work, we performed a qualitative study to explore the current practices for managing two related types of software documentation: requirements and acceptance tests. We interviewed twenty practitioners from seventeen business units in fifteen companies to investigate the companies' practices for writing, maintaining and linking requirements and acceptance test documentation. The study yields interesting and partially unexpected results. For example, we had expected that tests would be more extensively documented than requirements, while we found a strong linear correlation between the number of requirements and tests in our sample. We also found that technical people are usually not involved in the requirements engineering activities, which often\u00a0\u2026", "num_citations": "25\n", "authors": ["1478"]}
{"title": "Very Lightweight Requirements Modeling\n", "abstract": " We argue for the creation and use of a very lightweight requirements modeling language as an alternative to textual and pictorial requirements specifications.", "num_citations": "25\n", "authors": ["1478"]}
{"title": "Modellierung in der Lehre an Hochschulen: Thesen und Erfahrungen\n", "abstract": " Nicht erst seit Modellierung zum Modewort geworden ist, ist Modellierung ein wichtiges Thema in der Informatikausbildung. Dieser Beitrag beleuchtet in zw\u00f6lf Thesen das Warum, Was, Wie viel, Wo, Wann und Wie von Modellierung in der Lehre im Rahmen informatikbezogener Studieng\u00e4nge. Die Thesen basieren auf der Erfahrung des Verfassers mit einer seit \u00fcber zehn Jahren gehaltenen Modellierungsvorlesung an der Universit\u00e4t Z\u00fcrich sowie dem Gedankenaustausch mit anderen Hochschullehrerinnen und -lehrern im Rahmen der GI-Workshopreihe ,,Modellierung\u201c. Zus\u00e4tzlich liefert eine Befragung von Absolventinnen und Absolventen an der Universit\u00e4t Z\u00fcrich empirische Evidenz f\u00fcr eine Reihe der Thesen.", "num_citations": "25\n", "authors": ["1478"]}
{"title": "Evolution of Requirements Models by Simulation\n", "abstract": " Simulation is a common means for validating requirements models. Simulating formal models is state-of-the-art. However, requirements models usually are not formal for two reasons. Firstly, a formal model cannot be generated in one step. Requirements are vague in the beginning and are refined stepwise towards a more formal representation. Secondly, requirements are changing, thus leading to a continuously evolving model. Hence, a requirements model will be complete and formal only at the end of the modeling process, if at all. If we want to use simulation as a means of continuous validation during the process of requirements evolution, the simulation technique employed must be capable of dealing with semi-formal, incomplete models. We present an approach how we can handle partial models during simulation and use simulation to support evolution of these models. Our approach transfers the ideas of\u00a0\u2026", "num_citations": "25\n", "authors": ["1478"]}
{"title": "CASA\u2013A Contract-Based Adaptive Software Architecture Framework\n", "abstract": " Traditionally, applications are developed with an implicit reliance on the stability of their execution environment and available resources, while little or no support is provided for the runtime adaptation of application behavior in case of any instability encountered. But such an approach proves futile for more dynamic environments, such as those encountered in self-organized mobile networks, wherein any form of reliance on the runtime computing environment of an application would be highly optimistic. The Contract-based Adaptive Software Architecture (CASA) framework, described in this paper, addresses the need to equip an application with the ability to dynamically adapt itself in response to changes in its execution environment. This implies that an application is able to meet its functional and/or non-functional commitments even when its runtime computing environment changes. The framework builds on the idea of specifying resource requirements and adaptation behavior of applications in application contracts.", "num_citations": "25\n", "authors": ["1478"]}
{"title": "An Effective Layout Adaptation Technique for a Graphical Modeling Tool\n", "abstract": " Editing graphic models always entails layout problems. Inserting and deleting items requires tedious manual work for shifting existing items and rearranging the diagram layout. Hence, techniques that automatically expand a diagram when space is required for insertion and contract it when free space becomes available are highly desirable. Existing layout generation algorithms are no good solution for that problem: they may completely rearrange a diagram after an editing operation, while users want to preserve the overall visual appearance of a diagram. We have developed a technique which automatically expands or contracts a diagram layout when items are inserted or removed while preserving its overall shape, i.e. the positions of the items relative to each other Our technique has been implemented in a prototype tool. We are using it not just for simplifying editing, but primarily for implementing an aspect\u00a0\u2026", "num_citations": "24\n", "authors": ["1478"]}
{"title": "On the State of the Art in Requirements-based Validation and Test of Software\n", "abstract": " Validation of requirements and verification of software are crucial activities in the software development process since they essentially determine the quality of the software product and account for a big part of the overall development cost and use of resources. Only these activities can ensure that user requirements-whether they be explicit or only implicit-are met. This report overviews current methods and approaches towards validation of requirements and requirements-based testing.", "num_citations": "24\n", "authors": ["1478"]}
{"title": "Semi-Automatic Generation of Metamodels from Model Sketches\n", "abstract": " Traditionally, metamodeling is an upfront activity performed by experts for defining modeling languages. Modeling tools then typically restrict modelers to using only constructs defined in the metamodel. This is inappropriate when users want to sketch graphical models without any restrictions and only later assign meanings to the sketched elements. Upfront metamodeling also complicates the creation of domain-specific languages, as it requires experts with both domain and metamodeling expertise. In this paper we present a new approach that supports modelers in creating metamodels for diagrams they have sketched or are currently sketching. Metamodels are defined in a semi-automatic, interactive way by annotating diagram elements and automated model analysis. Our approach requires no metamodeling expertise and supports the co-evolution of models and meta-models.", "num_citations": "23\n", "authors": ["1478"]}
{"title": "FlexiSketch: a lightweight sketching and metamodeling approach for end-users\n", "abstract": " Engineers commonly use paper and whiteboards to sketch and discuss ideas in early phases of requirements elicitation and software modeling. These physical media foster creativity because they are quick to use and do not restrict in any way the form in which content can be drawn. If the sketched information needs to be reused later on, however, engineers have to spend extra effort for preserving the information in a form that can be processed by a software modeling tool. While saving information in a machine-readable way comes for free with formal software modeling tools, they typically anticipate the use of specific, predefined modeling languages and therefore hamper creativity. To combine the advantages of informal and formal tools, we have developed a flexible tool-supported modeling approach that augments a sketching environment with lightweight metamodeling capabilities. Users can create\u00a0\u2026", "num_citations": "22\n", "authors": ["1478"]}
{"title": "A Visualization Concept for Hierarchical Object Models\n", "abstract": " Most current object modeling methods and tools have weaknesses both in the concepts of hierarchical decomposition and in the visualization of these hierarchies. Some methods do not support hierarchical decomposition at all. Those methods which do employ tools that provide explosive zoom as the only means for the visualization of hierarchies. The authors present an approach for the visualization of hierarchical object models based on the notion of fisheye views. This concept integrates local detail and global context of a view in the same diagram and eases navigation in hierarchical structures without offending the principle of abstraction. The work is part of an effort to create a method and language called ADORA that provides strong support for hierarchical decomposition.", "num_citations": "22\n", "authors": ["1478"]}
{"title": "Prioritizing user feedback from Twitter: A survey report\n", "abstract": " Twitter messages (tweets) contain important information for software and requirements evolution, such as feature requests, bug reports and feature shortcoming descriptions. For this reason, Twitter is an important source for crowd-based requirements engineering and software evolution. However, a manual analysis of this information is unfeasible due to the large number of tweets, its unstructured nature and varying quality. Therefore, automatic analysis techniques are needed for, e.g., summarizing, classifying and prioritizing tweets. In this work we present a survey with 84 software engineering practitioners and researchers that studies the tweet attributes that are most telling of tweet priority when performing software evolution tasks. We believe that our results can be used to implement mechanisms for prioritizing user feedback with social components. Thus, it can be helpful for enhancing crowd-based\u00a0\u2026", "num_citations": "21\n", "authors": ["1478"]}
{"title": "Supporting Stepwise, Incremental Product Derivation in Product Line Requirements Engineering\n", "abstract": " Deriving products from a software product line is difficult, particularly when there are many constraints in the variability of the product line. Understanding the impact of variability binding decisions (i.e. of selecting or dismissing features) is a particular challenge: (i) the decisions taken must not violate any variability constraint, and (ii) the effects and consequences of every variability decision need to be understood well. This problem can be reduced significantly with good support both for variability specification and decision making. We have developed an extension of the \\textsc{Adora} language and tool which is capable of modeling and visualizing both the functionality and the variability of a product line in a single model and provides automated reasoning on the variability space. In this paper we describe how our approach supports stepwise, incremental derivation of a product requirements specification from a product line specification. We visualize what has been derived so far, automatically re-evaluate the variability constraints and propagate the results as restrictions on the remaining product derivation options. We demonstrate our approach by showing a sequence of product derivation steps in an example from the industrial automation domain. We claim that our approach both improves the efficiency and quality of the derivation process.", "num_citations": "21\n", "authors": ["1478"]}
{"title": "Human-Friendly Line Routing for Hierarchical Diagrams\n", "abstract": " Hierarchical diagrams are well-suited for visualizing the structure and decomposition of complex systems. However, the current tools poorly support modeling, visualization and navigation of hierarchical models. Especially the line routing algorithms are poorly suited for hierarchical models: for example, they produce lines that run across nodes or overlap with other lines. In this paper, we present a novel algorithm for line routing in hierarchical models. In particular, our algorithm produces an esthetically appealing layout, routes in real-time, and preserves the secondary notation of the diagrams as far as possible", "num_citations": "20\n", "authors": ["1478"]}
{"title": "Software Engineering I\n", "abstract": " Dieses Skript ist als Grundlage f\u00fcr eine zweist\u00fcndige Einf\u00fchrungsvorlesung in das Gebiet des Software Engineerings an der Universit\u00e4t Z\u00fcrich konzipiert. Aufgrund seiner Stellung im Informatik-Curriculum an der Universit\u00e4t Z\u00fcrich liegen die Schwerpunkte auf den Management-Aspekten des Software Engineerings sowie auf Spezifikation und Entwurf von Software. Detailentwurf, Realisierung und Testen werden nur summarisch behandelt. Die letzteren drei Themen werden an der Universit\u00e4t Z\u00fcrich in der Grundausbildung im Programmieren eingef\u00fchrt und sp\u00e4ter in der Kernvorlesung Software Engineering, welche auf der Einf\u00fchrungsvorlesung aufbaut, vertieft.Zu diesem Skript ist ein Lernzielkatalog erh\u00e4ltlich, aus dem ersichtlich ist, welche Teile des Skripts Bestandteil der Vorpr\u00fcfung in Informatik f\u00fcr Studierende der Wirtschaftsinformatik und der Wirtschaftswissenschaften an der Universit\u00e4t Z\u00fcrich sind. Das Skript\u00a0\u2026", "num_citations": "19\n", "authors": ["1478"]}
{"title": "User Feedback in the App Store: A Cross-Cultural Study\n", "abstract": " App stores allow globally distributed users to submit user feedback, in the form of user reviews, about the apps they download. Previous research has found that many of these reviews contain valuable information for software evolution, such as bug reports or feature requests, and has designed approaches for automatically extracting this information. However, the diversity of the feedback submitted by users from diverse cultural backgrounds and the consequences this diversity might imply have not been studied so far. In this paper, we report on a cross-cultural study where we investigated cultural differences in app store reviews and identified correlations to cultural dimensions taken from a well-established cultural model. We analyzed 2,560 app reviews written by users from eight countries with diverse national culture. We contribute evidence about the influence of cultural factors on characteristics of app reviews\u00a0\u2026", "num_citations": "18\n", "authors": ["1478"]}
{"title": "Hierarchische Zerlegung in objektorientierten Spezifikationsmodellen\n", "abstract": " Dieser Beitrag zeigt Schwachstellen von bestehenden objektorientierten Methoden bei der Dekomposition von Spezifikationen auf. Ausgehend von einer Pr\u00e4zisierung des bisher verwendeten Klassifikationskonzeptes wird ein Ansatz vorgestellt, welcher frei von diesen Schwachstellen ist. Dieser Ansatz baut auf ein Modellierungskonzept auf, welches Anforderungen auf der Ebene von Objekten hierarchisch modelliert und so die Schw\u00e4chen der bisherigen, eher klassenorientierten Methoden \u00fcberwindet.", "num_citations": "18\n", "authors": ["1478"]}
{"title": "Modeling and Evolving Crosscutting Concerns in ADORA\n", "abstract": " For an effective handling of crosscutting concerns during the software process, adequate support is required not only in design and coding, but also in requirements engineering. For this purpose, we have developed an aspect-oriented extension of the requirements modeling language ADORA. In this paper, we present an extension of our approach which makes it capable of supporting the evolution of aspect-oriented requirements models for both functional and non-functional aspects.", "num_citations": "17\n", "authors": ["1478"]}
{"title": "Eine gef\u00fchrte Tour durch die Landschaft der Software-Prozesse und-Prozessverbesserung\n", "abstract": " In the last ten years, software processes and software process improvement have been recognized as fundamental constituents for the development and maintenance of quality software. Much effort has been devoted to the development of models and standards for software processes, process maturity determination and process improvement. This article gives an introduction to the concepts of software processes and process improvement and presents an overview of models and standards in this field. First, we introduce the principles of process-oriented software development and discuss both advantages and risks. Then we give an overview of software process models and standards. In a second part, we present the concept of process improvement and illustrate the basic improvement cycle. Finally, we survey models and standards for software process improvement.", "num_citations": "17\n", "authors": ["1478"]}
{"title": "Uncovering Sustainability Requirements: An Exploratory Case Study in Canteens\n", "abstract": " Software systems are embedded into daily life and as such have significant effects on the behavior and decision making of both their users and the people affected by using these systems. Such effects can be positive or negative. Considering them in requirements engineering (RE) is an important step towards sustainable development, as RE strongly influences the development and the evolution of a software system. So far, RE researchers have focused on requirements about minimizing negative environmental effects. However, effects that are enabled by using a software system can also be positive. For example, a software system could motivate its users to take environment-friendly decisions. Corresponding requirements about such positive enabling effects have been far less addressed.In this paper, we present an exploratory case study where we elicited requirements about positive enabling effects with respect to environmental sustainability. The project we studied is about extending an existing decision support system for meal planning in canteens by game-based elements. The extended system shall motivate meal planners who work in canteens to make environment-friendly choices. Our contribution is an exemplar of concrete sustainability requirements as well as insight into the nature of sustainability requirements about positive effects that are enabled by the use of a software system.", "num_citations": "16\n", "authors": ["1478"]}
{"title": "Towards a Benchmark for Traceability\n", "abstract": " Rigorously evaluating and comparing traceability link generation techniques is a challenging task. In fact, traceability is still expensive to implement and it is therefore difficult to find a complete case study that includes both a rich set of artifacts and traceability links among them. Consequently, researchers usually have to create their own case studies by taking a number of existing artifacts and creating traceability links for them. There are two major issues related to the creation of one's own example. First, creating a meaningful case study is time consuming. Second, the created case usually covers a limited set of artifacts and has a limited applicability (eg, a case with traces from high-level requirements to low-level requirements cannot be used to evaluate traceability techniques that are meant to generate links from documentation to source code). We propose a benchmark for traceability that includes all artifacts that\u00a0\u2026", "num_citations": "16\n", "authors": ["1478"]}
{"title": "Seminar on Software Cost Estimation WS 2002/2003\n", "abstract": " The original COCOMO stands for Constructive Cost Model. The word\" constructive\" implies that the complexity of the model can be understood because of the openness of the model, which permits exactly to know WHY the model gives the estimates it does. The model was first published by Dr. Barry Boehm in 1981, and reflected the software development practices of these days. Since this time many efforts were done in the improvement of the software development techniques. Some of the changes were moving away from mainframe overnight batch processing to real time applications, strenuousness in effort in building software for reusing, new kind of system development in including off-the-shelf software components (COTS) and spending as much effort on designing and managing the software development process as was once spent creating the software product.These changes urged to revise the existing model. By the joint efforts of USC-CSE (University of California, Center for Software Engineering) and the COCOMO II Project Affiliate Organizations the COCOMO II model was presented, which should remedy all deficiencies. This new, improved COCOMO (COCOMO II) is now ready to assist professional software cost estimators.", "num_citations": "16\n", "authors": ["1478"]}
{"title": "GARUSO: a gamification approach for involving stakeholders outside organizational reach in requirements engineering\n", "abstract": " Stakeholder participation is a key success factor of Requirements Engineering (RE). Typically, the techniques used for identifying and involving stakeholders in RE assume that stakeholders can be identified among the members of the organizations involved when a software system is ordered, developed or maintained\u2014and that these stakeholders can be told or even mandated to contribute. However, these assumptions no longer hold for many of today\u2019s software systems where significant stakeholders (in particular, end-users and people affected by a system) are outside organizational reach: They are neither known nor can they easily be identified in the involved organizations nor can they be told to participate in RE activities. We have developed the GARUSO approach to address this problem. It uses a strategy for identifying stakeholders outside organizational reach and a social media platform that applies\u00a0\u2026", "num_citations": "15\n", "authors": ["1478"]}
{"title": "Dependency Charts as a Means to Model Inter-Scenario Dependencies\n", "abstract": " Scenarios/use cases have gained wide-spread use over the last couple of years. In software engineering they are mainly used to capture requirements and specify a system. Many software engineering approaches, most notably the UML (Unified Modeling Language [RJB99]), use some notion of scenario to support requirements elicitation and to provide a means for improved communication between software engineers, customers and users, and for enhanced user integration in the software development process. Yet prominent and renowned approaches like the UML lack a concept for modeling dependencies and relations between scenarios and offer only little support for the description and management of scenarios and of inter-scenario relationships. However, dependencies between scenarios are common, in fact dependencies between scenarios occur in any software development project of reasonable size. The existence of dependencies among scenarios needs to be perceived, acknowledged and accepted, they have to be captured and modeled to fully specify and better understand the system, and their impact on system modeling, on design, implementation and on testing needs to be recognized. In this paper we argue that dependencies among scenarios play too important a role in the software development process to omit them from system models and not to consciously consider them in analysis, design and testing. Therefore, we introduce a new kind of chart and a notation to model dependencies among scenarios. We discuss briefly the reasons why a new kind of chart is needed. An example of a dependency chart is presented.", "num_citations": "15\n", "authors": ["1478"]}
{"title": "FlexiView: A Magnet-Based Approach for Visualizing Requirements Artifacts\n", "abstract": " [Context and motivation] Requirements engineers create large numbers of artifacts when eliciting and documenting requirements. They need to navigate through these artifacts and display information details at points of interest for reviewing or editing information. [Question/problem] Traditional visualization mechanisms such as scrolling and opening multiple windows lose context when navigating and can be cumbersome to use, hence. On the other hand, focus+context approaches can display details in context, but they distort the data shown (e.g., fisheye views) or result in a large display canvas which again requires scrolling (e.g., zooming in Adora). [Principal ideas/results] We are developing a novel method for displaying just the information needed to perform an intended task. Our method partitions the available screen space into regions. The boundaries of regions are simulated with a model\u00a0\u2026", "num_citations": "14\n", "authors": ["1478"]}
{"title": "Flexible Sketch-Based Requirements Modeling\n", "abstract": " [Context and motivation] Requirements engineers and stakeholders like to create informal, sketchy models in order to communicate ideas and to make them persistent. They prefer pen and paper over current software modeling tools, because the former allow for any kind of sketches and do not break the creative flow. [Question/problem] To facilitate requirements management, engineers then need to manually transform the sketches into more formal models of requirements. This is a tedious, time-consuming task. Furthermore, there is a risk that the original intentions of the sketched models and informal annotations get lost in the transition. [Principal ideas/results] We present the idea for a seamless, tool-supported transition from informal, sketchy drafts to more formal models such as UML diagrams. Our approach uses an existing sketch recognizer together with a dynamic library of modeling symbols. This\u00a0\u2026", "num_citations": "14\n", "authors": ["1478"]}
{"title": "Simulation-Based Validation and Defect Localization for Evolving, Semi-Formal Requirements Models\n", "abstract": " When requirements models are developed in an iterative and evolutionary way, requirements validation becomes a major problem. In order to detect and fix problems early, the specification should be validated as early as possible, and should also be revalidated after each evolutionary step. In this paper, we show how the ideas of continuous integration and automatic regression testing in the field of coding can be adapted for simulation-based, automatic revalidation of requirements models after each incremental step. While the basic idea is fairly obvious, we are confronted with a major obstacle: requirements models under development are incomplete and semi-formal most of the time, while classic simulation approaches require complete, formal models. We present how we can simulate incomplete, semi-formal models by interactively recording missing behavior or functionality. However, regression simulations\u00a0\u2026", "num_citations": "14\n", "authors": ["1478"]}
{"title": "Feature Unweaving: Refactoring Software Requirements Specifications into Software Product Lines.\n", "abstract": " The design of the variability of a software product line is crucial to its success and evolution. Meaningful variable features need to be elicited, analyzed, documented and validated when an existing software or reference system evolves into a software product line. These variable features are the main discriminators between individual products and they need to reflect the needs of a large variety of stakeholders adequately. In this paper we present a novel approach, called feature unweaving, that supports the identification and extraction of variable features from a given graphical software requirements model. We have extended our aspect-oriented software product line modeling tool such that it supports feature unweaving: it takes a set of model elements that a domain requirements engineer considers to constitute a variable feature and automatically refactors the model into a semantically equivalent one in which\u00a0\u2026", "num_citations": "13\n", "authors": ["1478"]}
{"title": "An Automated Hint Generation Approach for Supporting the Evolution of Requirements Specifications\n", "abstract": " Updating the requirements specification during software evolution is a manual and expensive task. Therefore, software engineers usually choose to apply modifications directly to the code and leave the requirements unchanged. This leads to the loss of the knowledge contained in the requirements documents and thus limits the evolvability of a software system. In this paper, we propose to employ the co-evolution of the code and its test suite to preserve or restore the alignment between implementation and requirements: when a change has been applied to the code, subsequent changes in the test suite as well as failing tests are analyzed and used to automatically generate hints about the affected requirements and how they should be changed. These hints support the engineer in maintaining the requirements specification and thus ease the further evolution of the software system.", "num_citations": "13\n", "authors": ["1478"]}
{"title": "Requirements Engineering I\n", "abstract": " Requirements Engineering (Anforderungstechnik). 1. Das systematische, disziplinierte und quantitativ erfassbare Vorgehen beim Spezifizieren, dh Erfassen, Beschreiben und Pr\u00fcfen von Anforderungen an ein System. 2. Verstehen und Beschreiben, was die Kunden w\u00fcnschen oder brauchen. 3. Spezifikation und Verwaltung von Anforderungen mit dem Ziel, das Risiko zu minimieren, dass ein System entwickelt wird, welche den Kunden nicht n\u00fctzt oder gef\u00e4llt.", "num_citations": "13\n", "authors": ["1478"]}
{"title": "Challenges of working with artifacts in requirements engineering and software engineering\n", "abstract": " When developing or evolving software systems of non-trivial size, having the requirements properly documented is a crucial success factor. The time and effort required for creating and maintaining non-code artifacts are significantly influenced by the tools with which practitioners view, navigate and edit these artifacts. This is not only true for requirements, but for any artifacts used when developing or evolving systems. However, there is not much evidence about how practitioners actually work with artifacts and how well software tools support them. Therefore, we conducted an exploratory study based on 29 interviews with software practitioners to understand the current practice of presenting and manipulating artifacts in tools, how practitioners deal with the challenges encountered, and how these challenges affect the usability of the tools used. We found that practitioners typically work with several\u00a0\u2026", "num_citations": "12\n", "authors": ["1478"]}
{"title": "Lightweight Requirements Engineering Assessments in Software Projects\n", "abstract": " Requirements engineering (RE) is widely recognized as a crucial factor for the success of software projects. Therefore, companies often request assessments of RE processes and resulting artifacts to identify issues and improvement potential. However, industry claims that current assessment approaches do not always fulfill their needs regarding efficiency and effectiveness. Motivated by needs of both, companies asking for an assessment, and a company in the role of an assessor, we have developed a lightweight, tool-supported RE assessment approach. Apart from presenting the approach, we also discuss early experiences we gained from applying our assessment approach in real-world industrial projects.", "num_citations": "12\n", "authors": ["1478"]}
{"title": "Feature Unweaving: Efficient Variability Extraction and Specification for Emerging Software Product Lines\n", "abstract": " Successful software products frequently evolve into software product lines, whether intentionally or not. In such cases, product managers have to be involved in creating and specifying the commonality and variability of the evolving software product line in order to continuously assure a winning business case. In this paper we introduce feature unweaving, a novel approach that allows a product manager to efficiently evolve an integrated graphical requirements model into a product line model: when he or she has identified variable elements, feature unweaving automatically extracts these elements and refactors them into a feature, using an aspect-oriented approach. Feature unweaving significantly reduces the required effort for variability specification, both on a clerical and intellectual level. Furthermore, variability constraints can be added to capture more knowledge about the features and their interdependencies\u00a0\u2026", "num_citations": "12\n", "authors": ["1478"]}
{"title": "Aspect-Oriented Modeling with Integrated Object Models\n", "abstract": " With the advent of aspect-oriented programming, the need for adequate techniques for handling aspect-oriented artifacts in the early phases of the software engineering process has emerged. In this paper, we present an aspect-oriented language extension for an integrated modeling language based on object models. We present the way aspect constructs can be handled in requirements and architectural models, and identify the impact on existing modeling languages and models.", "num_citations": "12\n", "authors": ["1478"]}
{"title": "CrowdRE: Achievements, opportunities and pitfalls\n", "abstract": " This paper is an extended abstract of a keynote given at the Third International Workshop on Crowd-Based Requirements Engineering, held at RE'19. It provides a short guided tour through the landscape of CrowdRE, highlighting achievements, opportunities and pitfalls of CrowdRE.", "num_citations": "11\n", "authors": ["1478"]}
{"title": "Behind Points and Levels\u2014The Influence of Gamification Algorithms on Requirements Prioritization\n", "abstract": " Prioritizing requirements is a crucial ingredient of successful Requirements Engineering (RE). The popular prioritization techniques assume that stakeholders are known and can be mandated to contribute to the prioritization process. This prerequisite no longer holds for many of today's systems where significant stakeholders (end-users, in particular) are outside organizational reach: they are neither known nor can they be identified among the members of the involved organizations. Classic techniques for involving these stakeholders such as polls or questionnaires are neither interactive nor collaborative, which is detrimental for prioritization. Social media enable collaborative prioritization, but fall short in motivating stakeholders outside organizational reach to participate voluntarily. In this light, we are developing the Garuso platform, which combines social media with gamification for motivating stakeholders. While\u00a0\u2026", "num_citations": "11\n", "authors": ["1478"]}
{"title": "Probleme und Schwachstellen der Strukturierten Analyse\n", "abstract": " Die Strukturierte Analyse (SA) hat \u2014 gemessen an wichtigen Bed\u00fcrfnissen und Randbedingungen heutiger Software-Entwicklung \u2014 erhebliche Schwachstellen. Diese betreffen insbesondere das fehlende Information Hiding und verschiedene Probleme im Zusammenhang mit der Verzahnung von Spezifikation und Entwurf.             Die sogenannte \u201eobject-oriented Analysis\u201c l\u00f6st die Probleme von SA nur zum Teil und schafft dabei neue Probleme.             Die festgestellten Schwachstellen k\u00f6nnen teilweise behoben bzw. umgangen werden. Es gibt aber Probleme, die sich nicht l\u00f6sen lassen, ohne den methodischen Rahmen von SA zu sprengen.             Eine Skizze der Richtung, in die eine moderne, graphisch orientierte, teilformale Spezifikationstechnik entwickelt werden m\u00fc\u00dfte, schlie\u00dft den Beitrag ab.", "num_citations": "11\n", "authors": ["1478"]}
{"title": "An exploratory study on user interaction challenges when handling interconnected requirements artifacts of various sizes\n", "abstract": " Requirements documentation is essential for developing software systems of non-trivial size. The cost of creating and maintaining documentation artifacts in terms of time and effort is significantly influenced by the tools with which engineers view, navigate and edit documentation artifacts. However, there is not much evidence about how well documentation tools actually support engineers, particularly when dealing with artifacts that are larger than the available display screen and with multiple artifacts at the same time. Therefore, we conducted an exploratory study based on 29 interviews with software practitioners to understand the current practice of presenting and manipulating artifacts in documentation tools, and how practitioners deal with the challenges encountered. Our study shows that a significant number of artifacts cannot be viewed entirely, even on large screens. Moreover, more than half of the\u00a0\u2026", "num_citations": "10\n", "authors": ["1478"]}
{"title": "Flexible, Lightweight Requirements Modeling with FlexiSketch\n", "abstract": " Early stage requirements models are often documented using paper and pencil-based approaches. In our current research, we are exploring lightweight modeling tools and approaches that could provide a beneficial alternative. We have developed the FlexiSketch tool prototype which combines support for free-form sketching with lightweight metamodeling capabilities. This creates the possibility for an automatic transcription of the documented information in later modeling stages. The tool is designed to be used on tablet devices.", "num_citations": "9\n", "authors": ["1478"]}
{"title": "Methoden und Techniken zum Erreichen didaktischer Ziele in Software-Engineering-Praktika\n", "abstract": " Praktika an der Hochschule sind wirksamer Bestandteil der Software-Engineering-Ausbildung, sie sind aber auch eine Ausbildungsform, in der didaktische Herausforderungen und M\u00f6glichkeiten besonders intensiv zusammentreffen. Zu den didaktischen Zielen geh\u00f6ren eine hohe Motivation der Studierenden und Tutoren, eine wirksame und individuelle Leistungskontrolle, Praxisbezug sowie ein erfolgreicher Umgang mit unterschiedlichen Vorkenntnissen. Dieser Beitrag pr\u00e4sentiert Methoden und Techniken, um diese Ziele zu erreichen, und erl\u00e4utert sie anhand von Beispielen. Aus diesen speziellen Ma\u00dfnahmen werden Prinzipien f\u00fcr den Unterricht des Software Engineering extrahiert.", "num_citations": "9\n", "authors": ["1478"]}
{"title": "Systematically Combining Speci\ufb01cations of Internal and External System Behavior Using Statecharts\n", "abstract": " In contemporary model-based specifications, We typically find a naive combination of models of the externally visible behavior of a system (typically expressed as see-narios or use cases) and of the internal system behavior (partially represented in explicit state models and partially expressed as data). However, a systematic combi-nation and integration of the two behavior aspects has not yet been investigated.In this paper, I sketch (1 s_\\-stematic approach for modeling both external and internal behavior ofa system with stateeharts in an integrated, lion-redttndant way. The main idea is to start with statecharts that model external behavior in the form of use cases or type scenarios and then add statecharts that model internal behavior 0nl_\\-'where the scenario/use case statecharts do not su\ufb01ice for expressing the behavior of the system.", "num_citations": "9\n", "authors": ["1478"]}
{"title": "Hierarchische Verhaltensbeschreibung in objekt-orientierten Systemmodellen\u2014eine Grundlage f\u00fcr modellbasiertes Prototyping\n", "abstract": " Der Beitrag beschreibt ein objekt-orientiertes Modell f\u00fcr Spezifikation und Entwurf von Systemen, das die Generierung von Prototypen gestattet. Das Verhaltensmodell basiert auf Zustandsautomaten, welche in eine \u2018Ist-Teil-von\u2019-Hierarchie eingebettet sind. Zusammen mit den Grundprinzipien der objekt-orientierten Modellierung (vor allem Vererbung und Benutzungs-Abstraktion) ergibt sich eine sehr attraktive Kombination von Anschaulichkeit, Ausdruckskraft und Durchg\u00e4ngigkeit der Modellkonzepte einerseits und von Beobachtbarkeit und Erprobbarkeit des Systemverhaltens andererseits.               Ein solches modellbasiertes Prototyping hat gegen\u00fcber herk\u00f6mmlichen Prototypen den Vorteil, da\u00df ein Modell anschaulicher, besser verstehbar und leichter \u00e4nderbar ist als der Code eines Prototyps.", "num_citations": "9\n", "authors": ["1478"]}
{"title": "SPADES\u2014A Specification and Design System and its Graphical Interface\n", "abstract": " SPADES is a specification system consisting of a method, a language, and a set of tools. These components are based on a set of concepts, which forms its abstract kernel. SPADES supports the specification of software systems, in particular of real time software. The system to be developed is modelled using the Entity-Relationship-concept. While this seems to be the best way for storing specifications. In a computer, it does not automatically lead to representations equally comfortable for humans. This is why SPADES, which has been available for some time, has recently been extended by a graphical interface. This paper gives a brief survey of the system, in particular of its new component.", "num_citations": "9\n", "authors": ["1478"]}
{"title": "Keeping Evolving Requirements and Acceptance Tests Aligned with Automatically Generated Guidance\n", "abstract": " [Context and motivation] When a software-based system evolves, its requirements continuously change. This affects the acceptance tests, which must be adapted accordingly in order to maintain the quality of the evolving system. [Question/problem] In practice, requirements and acceptance test documents are not always aligned with each other, nor with the actual system behavior. Such inconsistencies may introduce software quality problems, unintended costs and project delays. [Principal ideas/results] To keep evolving requirements and their associated acceptance tests aligned, we are developing an approach called GuideGen that automatically generates guidance in natural language on how to modify impacted acceptance tests when a requirement is changed. We evaluated GuideGen using real-world data from three companies. For 262 non-trivial changes of requirements, we generated\u00a0\u2026", "num_citations": "8\n", "authors": ["1478"]}
{"title": "Aligning Requirements and Acceptance Tests via Automatically Generated Guidance\n", "abstract": " Keeping requirements and acceptance test documents aligned and up-to-date plays an important role in the success of software projects. In practice, these documents are not always aligned with each other, nor with the actual system behavior. A previous study showed that even when requirements are updated, acceptance tests might stay outdated, which often leads to quality problems and unintended costs. In order to keep the requirements and test documents in a consistent state, we are developing an approach that automatically generates guidance on how to change impacted acceptance tests when changes in requirements occur. In this paper, we briefly present our approach and a prototype tool that implements it. A preliminary evaluation of our approach yielded encouraging results.", "num_citations": "8\n", "authors": ["1478"]}
{"title": "End-user driven feedback prioritization\n", "abstract": " End-user feedback is becoming more important for the evolution of software systems. There exist various communication channels for end-users (app stores, social networks) which allow them to express their experiences and requirements regarding a software application. End-users communicate a large amount of feedback via these channels which leads to open issues regarding the use of end-user feedback for software development, maintenance and evolution. This includes investigating how to identify relevant feedback scattered across different feedback channels and how to determine the priority of the feedback issues communicated. In this research preview paper, we discuss ideas for enduser driven feedback prioritization.", "num_citations": "8\n", "authors": ["1478"]}
{"title": "Modeling the purposes of models\n", "abstract": " Today, the purpose of a model is often kept implicit. The lack of explicit statements about a model's purpose hinders both its creation and its (re)use. In this paper, we adapt two goal modeling techniques, the Goal-Question-Metric paradigm and KAOS, an intentional modeling language, so that the purpose of a model can be explicitly stated and operationalized. Using some examples, we present how these approaches can document a model's purpose so that this model can be validated, improved and used correctly.", "num_citations": "8\n", "authors": ["1478"]}
{"title": "GuideGen\u2013A Tool for Keeping Requirements and Acceptance Tests Aligned\n", "abstract": " When changes in requirements occur, their associated tests must be adapted accordingly in order to maintain the quality of the evolving system. In practice, inconsistencies in requirements and acceptance tests-together with poor communication of changes-lead to software quality problems, unintended costs and project delays. We are developing GuideGen, a tool that helps requirements engineers, testers and other involved parties keep requirements and acceptance tests aligned. When requirements change, GuideGen analyzes the changes, automatically generates guidance on how to adapt the affected acceptance tests, and sends this information to subscribed parties. GuideGen also flags all non-aligned acceptance tests, thus keeping stakeholders aware of mismatches between requirements and acceptance tests. We evaluated GuideGen with data from three companies. For 262non-trivial changes of\u00a0\u2026", "num_citations": "7\n", "authors": ["1478"]}
{"title": "Mining Twitter messages for software evolution\n", "abstract": " Twitter is a widely used social network. Previous research showed that users engage in Twitter to communicate about software applications via short messages, referred to as tweets, and that some of these tweets are relevant for software evolution. However, a manual analysis is impractical due to the large number of tweets - in the range of thousands per day for popular apps. In this work we present ALERTme, an approach to automatically classify, group and rank tweets about software applications. We apply machine learning techniques for automatically classifying tweets requesting improvements, topic modeling for grouping semantically related tweets and a weighted function for ranking tweets according to their relevance for software evolution. We ran our approach on 68,108 tweets from three different software applications and compared the results against practitioners' assessments. Our results are promising\u00a0\u2026", "num_citations": "7\n", "authors": ["1478"]}
{"title": "Quest for Requirements: Scrutinizing Advanced Search Queries for Cloud Services with Fuzzy Galois Lattices\n", "abstract": " In software and requirements engineering, requirements elicitation is considered an essential step towards building successful systems. Despite extensive existing research in the field of distributed requirements engineering, the topic of requirements elicitation for cloud systems remains still uncovered. Cloud challenges (e.g., heterogeneous and globally distributed users, volatile requirements, frequent change requests) cannot always be satisfied by existing methods. We present a new approach for eliciting requirements for cloud services by analyzing advanced search queries. Our approach builds fuzzy Galois lattices for the terms that compose advanced search queries, thus enabling a thorough analysis of stored search data. This can support cloud providers in observing requirements clusters and new classes of cloud services, identifying the threshold for achieving satisfied consumers with a minimal set of\u00a0\u2026", "num_citations": "7\n", "authors": ["1478"]}
{"title": "Visualization Support for Software Product Line Modeling\n", "abstract": " Product derivation from a product line model is a central activity in product line requirements engineering. A product line framework and/or approach should provide sophisticated visualization and product derivation support, otherwise large product lines become very hard to handle. In this paper we first present how we can benefit from existing single-system visualization techniques in product lines. Then we introduce new visualization aids and concepts that support the analysis of variability and the derivation of products in software product line engineering. We expect that these new visual support mechanisms will significantly ease the work of stakeholders and requirements engineers when negotiating a new product based on a software product line.", "num_citations": "7\n", "authors": ["1478"]}
{"title": "SEED\u2014A Database System for Software Engineering Environments\n", "abstract": " Das Modell einer Datenbank f\u00fcr Anwendungen in der Softwaretechnik wird vorgestellt. Es basiert auf einem Entity-Relationship-Ansatz, enth\u00e4lt aber zus\u00e4tzliche Modellierungsmittel f\u00fcr komplexe Objekte, Konsistenzsicherung, vage bzw. unvollst\u00e4ndige Informationen, Versionen- und Variantenverwaltung. Ein Prototyp eines Datenbanksystems, welches mit diesem Modell arbeitet, wird implementiert.", "num_citations": "7\n", "authors": ["1478"]}
{"title": "ImitGraphs: Towards faster usability tests of graphical model manipulation techniques\n", "abstract": " Due to the increasing use of both general-purpose and domain-specific graphical models (e.g., UML diagrams or graphic DSLs) in different stages of software development, software engineers who work with these models spend more time interacting with modeling tools. Thus, the usability of the interaction techniques employed by modeling tools affects the overall productivity of software development. Tool developers and user interface designers rely on the feedback from usability tests to optimize the user interface of tools that provide a graphical editor. Developing a working prototype to test new techniques is costly due to the complexity and variety of graphical models. This results in either tests at the late stages of development when changes are more expensive, or tests with prototypes that only support a subset of the intended graphical models. In order to simplify conducting usability tests, instead of using the\u00a0\u2026", "num_citations": "6\n", "authors": ["1478"]}
{"title": "A Vision of an Ultralightweight Requirements Modeling Language\n", "abstract": " Despite all efforts in creating and disseminating requirements modeling languages, natural language is still the dominant language for writing requirements specifications in practice. Furthermore, when documenting early requirements, natural language (in combination with pictures) outperforms today\u2019s requirements modeling languages.In this paper, we present a vision and research roadmap for an ultralightweight requirements modeling language which can be used as easily as natural language with pictures, but has a visual structure with some lightweight semantics that allow the visual expression of hierarchical structure, context, general relationship, flow, and influence, while all the details are specified in natural language, both form-based and freetext. Furthermore, it should be possible to evolve parts of such an ultralightweight model into classic models of structure and behavior with full-fledged semantics by incrementally adding more formal model elements and tightening the meaning of the already existing ones. We envisage that such a modeling language\u2013when supported by appropriate tools\u2013will (1) outperform natural language requirements specifications with respect to comprehensibility, changeability, analyzability and internal traceability,(2) be simpler and more straightforward to read and create than today\u2019s heavyweight modeling languages,(3) provide an efficient and effective means for expressing requirements at an early stage.", "num_citations": "6\n", "authors": ["1478"]}
{"title": "An experimental comparison of two navigation techniques for requirements modeling tools\n", "abstract": " In Requirements Engineering, many modeling tasks require viewing different parts of a model concurrently. However, traditional zoom+scroll navigation uses a single focus zoom, i.e., at a given point in time, a user can zoom in on a single spot in the model only. Therefore, new focus+context navigation techniques have been proposed that allow multiple foci at the same time. In this paper, we report on an experiment with students where we compare the participants' performance when using a requirements modeling tool with traditional zoom+scroll navigation vs. one with so-called FlexiView navigation which is a focus+context technique with multiple foci. The participants had to perform typical modeling tasks such as searching, editing, and traversing a model. All tasks were performed on medium-sized tablets with a tool for manipulating so-called ImitGraphs. ImitGraphs are enriched node-and-edge diagrams that\u00a0\u2026", "num_citations": "5\n", "authors": ["1478"]}
{"title": "Choosing Requirements for Experimentation with User Interfaces of Requirements Modeling Tools\n", "abstract": " When designing a new presentation front-end called FlexiView for requirements modeling tools, we encountered a general problem: designing such an interface requires a lot of experimentation which is costly when the code of the tool needs to be adapted for every experiment. On the other hand, when using simplified user interface (UI) tools, the results are difficult to generalize. To improve this situation, we are developing an UI experimentation tool which is based on so-called ImitGraphs. ImitGraphs can act as a simple, but accurate substitute for a modeling tool. In this paper, we define requirements for such an UI experimentation tool based on an analysis of the features of existing requirements modeling tools.", "num_citations": "5\n", "authors": ["1478"]}
{"title": "Towards Bridging the Communication Gap Between Consumers and Providers in the Cloud\n", "abstract": " The number of available cloud services has recently grown considerably. Therefore, consumers demand new methods for choosing the appropriate cloud services for their needs, whereas providers require dedicated ways to correctly elicit requirements from very heterogeneous consumers. In this poster, we present the StakeCloud community platform. This will act as a cloud resources marketplace, allowing consumers to input their needs and providing them with matching cloud services. Moreover, in case the needs are not met, they can be communicated as new requirements to cloud providers. Our solution will enable easier resource identification and requirements communication in cloud systems, thus supporting both consumers and providers.", "num_citations": "5\n", "authors": ["1478"]}
{"title": "Requirements Engineering: Foundation for Software Quality: 15th International Working Conference, REFSQ 2009, Amsterdam, The Netherlands, June 8-9, 2009 Proceedings\n", "abstract": " This book constitutes the refereed proceedings of the 15th International Working Conference on Requirements Engineering: Foundation for Software Quality, REFSQ 2009, held in Amsterdam, The Netherlands, in June 2009. The 14 revised full papers were carefully reviewed and selected from 49 submissions. The papers are organized in thematic sections on value and risk, change and evolution, interactions and inconsistencies, organization and structuring, experience, elicitation, research methods, behavior modeling, empirical studies, and open-source RE.", "num_citations": "5\n", "authors": ["1478"]}
{"title": "Experimental Validation of the ADORA Language\n", "abstract": " ADORA (Analysis and Description of Requirements and Architecture) is an approach to object oriented modeling that is based on object modeling and hierarchical decomposition, using an integrated model. The ADORA language is intended to be used for requirements specifications and high-level, logical views of software architectures. In order to assess the comprehensibility and the appeal of specifications written in ADORA we conducted a controlled experiment with students. We wrote two specifications of the same problem in ADORA and in UML and let the students study them. Then we tested the students' comprehension by asking questions about the contents of the specification and tested how they liked ADORA in comparison to UML by asking questions about personal preferences. In this report we describe the experiment and report the results.", "num_citations": "5\n", "authors": ["1478"]}
{"title": "Entwicklungsrichtlinien f\u00fcr die Programmiersprache Java\n", "abstract": " Entwicklungsrichtlinien sind ein Hilfsmittel, um gemachte Erfahrungen bei der Entwicklung von Software weiterzugeben. Sie helfen Entwicklern, vorhandenen Programmcode zu verstehen und in zuk\u00fcnftig zu erstellendem Programmcode Fehler zu vermeiden. Konsequent und umsichtig angewandt, verbessern sie den Programmierstil und die Lesbarkeit von Programmcode und tragen somit auch zu verbesserter Wartbarkeit von Software bei.", "num_citations": "5\n", "authors": ["1478"]}
{"title": "The Teacher:\u201cConcepts!\u201d The Student:\u201cTools!\u201d\u2014On the Number and Importance of Concepts, Methods, and Tools to be Taught in Software Engineering Education\n", "abstract": " The paper discusses the number and importance of concepts, methods, and tools that should be taught in software engineering education. It is shown that emphasis is quite different from a teacher\u2019s and from a student\u2019s viewpoint. As a synthesis of both viewpoints, I propose an approach that separates concepts and methods from tools in the curriculum and treats both with proper emphasis. The software engineering curriculum of the Department of Computer Science of the University of Zurich which follows these ideas is sketched.", "num_citations": "5\n", "authors": ["1478"]}
{"title": "A Dataflow Retrieval Unit for a Relational Database Machine\n", "abstract": " We present a dataflow retrieval unit for a relational database machine, consisting of an array of special data driven processors (with local networks connecting the processors of neighbouring rows) and some sorters.             The basis of our design is to interpret a query tree as a dataflow program, to map it directly onto hardware structures and to execute it under dataflow control, using pipelining and parallel processing.             We work with sorted relations and assume relations to be delivered from storage as sequential data streams.             In order to execute a query, we first assign a processor (with appropriate program) to every operation and a data path to every arc of the query tree. Then the relations needed are read and flow into the processor tree at the leaves. They traverse it on the preassigned data paths under dataflow control on byte level and are transformed by relational algebra operations in the\u00a0\u2026", "num_citations": "5\n", "authors": ["1478"]}
{"title": "GuideGen: An approach for keeping requirements and acceptance tests aligned via automatically generated guidance\n", "abstract": " ContextWhen software-based systems evolve, their requirements change. The changes in requirements affect the associated acceptance tests, which should be adapted accordingly. In practice, however, requirements and their acceptance tests are not always kept up-to-date nor aligned. Such inconsistencies may introduce software quality problems, unintended costs and project delays.ObjectiveIn order to keep evolving requirements and their acceptance tests aligned, we are developing an approach called GuideGen. GuideGen automatically generates guidance in natural language about how to adapt the impacted acceptance tests when their requirements change.MethodWe have implemented GuideGen as a prototype tool and evaluated it in two studies: first, by assessing the correctness, completeness, understandability and relevance of the generated guidance using three data sets from industry and second\u00a0\u2026", "num_citations": "4\n", "authors": ["1478"]}
{"title": "A qualitative study on using GuideGen to keep requirements and acceptance tests aligned\n", "abstract": " Software requirements constantly change, thus impacting all other artifacts of an evolving system. In order to keep the system in a consistent state, changes in requirements should be documented and applied accordingly to all affected artifacts, including acceptance tests. In practice, however, changes in requirements are not always documented nor applied to the affected acceptance tests. This is mostly due to poor communication, lack of time or work overload, and eventually leads to project delays, unintended costs and unsatisfied customers. GuideGen is a tool-supported approach for keeping requirements and acceptance tests aligned. When a requirement is changed, GuideGen automatically generates guidance in natural language on how to modify impacted acceptance tests and communicates this information to the concerned parties. In this paper, we evaluate GuideGen in terms of its perceived usefulness\u00a0\u2026", "num_citations": "4\n", "authors": ["1478"]}
{"title": "How much Requirements Engineering do we need?\n", "abstract": " As unambiguous and complete requirements specifications are not feasible in most cases, we investigate the question how much Requirements Engineering (RE) we actually need for the development of successful systems and products.  Based on the notion of value of requirements, we discuss risk, shared understanding and customer-supplier relationship as major influencing factors.", "num_citations": "4\n", "authors": ["1478"]}
{"title": "SEED-a DBMS for Software Engineering Applications Based on the Entity-Relationship Approach\n", "abstract": " SEED is a database system which supports the data engineering needs of a software engineering environment. It provides information structures that are not incorporated in conventional database systems, but are typical in the software engineering process. This paper describes two principal features of SEED: how to deal with vague and incomplete information without giving up consistency checking, and the management of database versions and variants. A prototype of SEED is used as the database for an existing specification and design tool.", "num_citations": "4\n", "authors": ["1478"]}
{"title": "Automatic placement of link labels in diagrams\n", "abstract": " While diagrams play a central role in the software lifecycle, computer-based modeling tools are often not used in practice. At least to some extent, this is due to their lack of  exibility and support of recurring and tedious \\model administration\" tasks. Such tasks, like the rearrangement of existing model elements to provide the space required by a new element or the manual adjustment of lines after moving an element, distract the user from the actual modeling activities. In this paper, we present an approach to relieve the modeler from the painful manual placement of the labels accompanying the links in a diagram by handing this task over to the modeling tool. Additionally, we give a short overview over other modeling activities that come along with the creation and manipulation of a diagram but should be handled by the tool and not the user.", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Requirements Engineering: Foundation for Software Quality, Proceedings of the 15th International Working Conference (REFSQ 2009)\n", "abstract": " Requirements Engineering: Foundation for Software Quality, Proceedings of the 15th International Working Conference (REFSQ 2009) \u2014 the Research Portal - University of Namur Skip to main navigation Skip to search Skip to main content the Research Portal - University of Namur Logo English Fran\u00e7ais Home Profiles Research Units Equipment Projects Research Output Student theses Datasets Prizes Activities Press / Media Requirements Engineering: Foundation for Software Quality, Proceedings of the 15th International Working Conference (REFSQ 2009) Martin Glinz, Patrick Heymans Faculty of Computer Science Research Center on Information Systems Engineering Research output: Other contribution Overview Projects (1) Original language English Publication status Published - 2009 Projects 2010 2010 1 Finished Requirements engineering and business/IT alignment Cleve, A. 1/01/10 \u2192 31/01/10 Project: \u2026", "num_citations": "3\n", "authors": ["1478"]}
{"title": "A Novel Algorithm for Line Routing in Hierarchical Diagrams\n", "abstract": " Hierarchical diagrams are well-suited for visualizing the structure and decomposition of complex systems. With the advent of UML 2.0, in particular the new composite structure diagram, hierarchical models have entered the modeling mainstream.However, the current tools poorly support hierarchical modeling and visualization. Simple explosive zooming is the most common means for navigating through hierarchies; some tools even visualize the complete hierarchy in a single large diagram. The line routing algorithms used by the current tools are poorly suited to this task: for example, they produce lines that run across nodes or overlap with other lines.", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Extending a Graphic Modeling Language to Support Partial and Evolutionary Specification\n", "abstract": " The notion of partial and evolutionary specification has gained attention both in research and industry in the last years. While many people regard this just as a process issue, we are convinced that it is as well a language problem. Unfortunately, UML is not expressive enough to deal with evolutionary information in the system. In this paper, we propose an extension to a graphic modeling language called ADORA which is developed in our research group. We conservatively extend the semantics of some ADORA constructs so that intentional incompleteness can be expressed in the language and define a calculus for refining such specifications. With the help of these extensions, evolutionary specifications can be written in a controlled and systematic way. As the language and its extensions are formally defined, the consistency of evolutionary refinements can be checked mechanically by a tool.", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Simulation of Semi-Formal Requirements Models as a Means for their Validation and Evolution\n", "abstract": " Simulation is a common means for validating requirements models. Simulating formal models is state-of-the-art. However, requirements models usually are not formal for two reasons. Firstly, a formal model cannot be generated from scratch in one step. Requirements are vague in the beginning and are refined stepwise towards a more formal representation. Secondly, requirements are changing, thus leading to a continuously evolving model. Hence, a requirements model will be complete and formal only at the end of the modeling process, if at all. If we want to use simulation as a means of continuous validation during the process of requirements evolution, the simulation technique employed must be capable of dealing with semi-formal, incomplete models.In this paper, we present an approach how we can deal with partial models during simulation and how we can use simulation to support evolution of these models. Our approach transfers the ideas of drivers, stubs, and regression from testing to the simulation of requirements models. It also uses the simulation results for evolving an incomplete model in a systematic way towards a more formal and complete one.", "num_citations": "3\n", "authors": ["1478"]}
{"title": "A Syntax Definition Method for Visual Specification Languages\n", "abstract": " Today, the syntax of visual specification languages such as UML is typically defined using metamodeling techniques. However, this kind of syntax definition has drawbacks. In particular, graphic metamodels are not powerful enough, so they must be augmented by a constraint language.In this report, we present a text-based technique for the syntax definition of a graphic specification language. We exploit the fact that in a graphic specification language, most syntactic features are independent of the layout of the graph. So we map the graphic elements to textual ones and define the context-free syntax of this textual language in EBNF. Using our mapping, this grammar also defines the syntax of the graphic language. Simple spatial and context-sensitive constraints are then added by attributing the context-free grammar. Finally, for handling complex structural and dynamic information in the syntax, we give a set of operational rules that work on the attributed EBNF.", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Modellierung 2002\n", "abstract": " Modellierung ist ein Querschnittsthema in der Informatik, das sich seit einigen Jahren als eigenst\u00e4ndiges Gebiet in Forschung, Lehre und Anwendung etabliert hat. Um den Austausch von Ans\u00e4tzen und Erfahrungen im Bereich der Modellierung zwischen den verschiedenen Teildisziplinen der Informatik zu f\u00f6rdern, haben sieben Fachgruppen der Gesellschaft f\u00fcr Informatik 1998 die Tagungsreihe \u201eModellierung \u201cgegr\u00fcndet.", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Modellierung im Informatikstudium\n", "abstract": " Modellierung ist von fundamentaler Bedeutung f\u00fcr die Informatik. Dementsprechend muss Modellierung Bestandteil jedes Informatikstudiums sein.               In diesem Beitrag diskutieren wir verschiedene M\u00f6glichkeiten der Ausbildung von Modellierung im Informatikstudium. Wir schlagen dabei eine eigenst\u00e4ndige Vorlesung zum Thema Modellierung im Grundstudium vor. Anschlie\u00dfend beschreiben wir den Inhalt einer solchen Vorlesung an der Universit\u00e4t Z\u00fcrich.", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Emotionales und Rationales im industriellen Software Engineering\n", "abstract": " Will man den Stand des Software-Engineering in der Industrie verbessern, so ist die Schulung der Mitarbeiter in Software-Engineering eine notwendige Voraussetzung. Schulung im Sinn der Vermittlung von Wissen und praktischen Fertigkeiten reicht jedoch nicht aus. Man beobachtet n\u00e4mlich, da\u00df die Situation an Orten, wo ausgebildete Software-Ingenieure arbeiten, zwar besser ist als anderswo, aber lange nicht so gut, wie man es eigentlich erwarten sollte. Es gibt eine auff\u00e4llige Diskrepanz zwischen dem Kenntnis-und dem Handlungsstand im industriellen Software-Engineering. Dies gilt beispielsweise f\u00fcr-den Stellenwert, den man der Software \u00fcberhaupt beimi\u00dft-die Sch\u00e4tzung von Aufwand und", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Reduction theorems for networks with general sequencing relations\n", "abstract": " A network for project scheduling is characterized by a) a finite set A with elements n, B,..., called actiuitieb of the project b) activity dunationb x (a) for each a\u20ac A or, in the stochastic case, non-negative real random variables X \u201c, their realizations being possible durations of u c) a pnoject atauctuna: this may be deterministic (fixed sequencing relations between each pair of activities) or stochastic (eg if there are alternative procedures for accomplishing a given aim).", "num_citations": "3\n", "authors": ["1478"]}
{"title": "Collaborative sketching and notation creation with FlexiSketch Team\n", "abstract": " We used FlexiSketch Team, our flexible modeling tool, in an explorative study to better understand how novice and experienced engineers sketch and define ad-hoc notations collaboratively in early requirements elicitation and design sessions.", "num_citations": "2\n", "authors": ["1478"]}
{"title": "Problems when Introducing Aspect-Oriented Constructs in Models of Functional Requirements and Possible Solutions to these Problems\n", "abstract": " The new paradigm of aspect-oriented programming demands new modularization techniques in the early phases of software development, ie requirements analysis and architectural design. Especially during the requirements analysis phase, there is a potential for conflicts between the introduced aspect-oriented paradigm and traditionally postulated qualities that must be fulfilled by a requirements specification. In this paper, we analyse the problems which may occur during the requirements phase when using aspect-oriented constructs. We also propose solutions for solving or mitigating the identified problems.", "num_citations": "2\n", "authors": ["1478"]}
{"title": "Spezifikation und Entwurf von Software\n", "abstract": " Spezifikation und Entwurf von Software Page 1 Spezifikation und Entwurf von Software Martin Glinz Seite 1 \u00a9 2001, 2004 by Martin Glinz. Alle Rechte vorbehalten. Reproduktion zum nicht kommerziellen Gebrauch mit Quellenangabe gestattet. Reproduktion - auch auszugsweise - zum kommerziellen Gebrauch nur mit schriftlicher Bewilligung des Verfassers gestattet. Spezifikation und Entwurf von Software Prof. Dr. Martin Glinz Wintersemester 2004/05 Page 2 Spezifikation und Entwurf von Software Martin Glinz Seite 2 Page 3 Spezifikation und Entwurf von Software Martin Glinz Seite 3 Inhalt Teil I: Grundlagen 1 Einf\u00fchrung und \u00dcberblick 2 Systeme und ihr Kontext 3 Modellierungssprachen 4 Einf\u00fchrung in UML Teil II: Requirements Engineering (Anforderungstechnik) 5 Requirements Engineering \u2013 Einf\u00fchrung 6 Requirements Engineering Prozesse 7 Gewinnung von Anforderungen 8 Grunds\u00e4tze der Darstellung von \u2026", "num_citations": "2\n", "authors": ["1478"]}
{"title": "Software-Qualit\u00e4tsmanagement\n", "abstract": " Software-Qualit\u00e4tsmanagement Page 1 Universit\u00e4t Z\u00fcrich Institut f\u00fcr Informatik KV Software Engineering Prof. Dr. Martin Glinz Kapitel 7 Software-Qualit\u00e4tsmanagement \u00a9 2004 by Martin Glinz. Alle Rechte vorbehalten. Reproduktion, Speicherung und Wiedergabe jeglicher Art sind ausschlie\u00dflich f\u00fcr den pers\u00f6nlichen, nicht kommerziellen Gebrauch gestattet, wobei bei auszugsweiser Wiedergabe die Quelle und das Copyright zu nennen sind. Die Verwendung f\u00fcr Unterrichtszwecke ist nicht gestattet. Page 2 2 KV Software Engineering Kapitel 7 \u00a9 2004 by Martin Glinz 7.1 Grundlagen 7.2 Elemente des Qualit\u00e4tsmanagements 7.3 Das Qualit\u00e4tsmanagementsystem 7.4 Dokumentation 7.5 Werkzeuge Page 3 3 KV Software Engineering Kapitel 7 \u00a9 2004 by Martin Glinz Motivation Software ist ein wesentlicher Bestandteil wesentlicher Produkte und Dienstleistungen unseres t\u00e4glichen Lebens. Software \u2013 Programme, \u2026", "num_citations": "2\n", "authors": ["1478"]}
{"title": "Visualizing ADORA Models\n", "abstract": " Most current object modeling methods and tools have weaknesses both in the concepts of hierarchical composition and in the visualization of these hierarchies. Some methods do not support hierarchical composition at all. Those methods which do, employ tools that provide explosive zoom as the only means for the visualization of hierarchies. In this paper", "num_citations": "2\n", "authors": ["1478"]}
{"title": "Stereotypen und ihre Verwendung in objektorientierten Modellen - Eine Klassifikation.\n", "abstract": " Bekannt und popul\u00e4r wurden Stereotypen durch ihren Einsatz in den j\u00fcngst vorgestellten Sprachentw\u00fcrfen der OPEN Modeling Language (OML) und der Unified Modeling Language (UML). Stereotypen er\u00f6ffnen im Bereich der objektorientierten Modellierung interessante neue M\u00f6glichkeiten. Die Verwendung von Stereotypen birgt jedoch auch neue Probleme und Risiken bei der Modellierung. In diesem Beitrag wird eine Klassifikation von Stereotypen nach ihrer Ausdrucksm\u00e4chtigkeit vorgeschlagen. F\u00fcr jede Klasse von Stereotypen werden m\u00f6gliche Einsatzgebiete sowie St\u00e4rken und Schw\u00e4chen diskutiert.", "num_citations": "2\n", "authors": ["1478"]}
{"title": "SEED-das Datenbandksystem f\u00fcr die Software-Entwicklungsumgebung SEEME\n", "abstract": " Im Zusammenhang mit der Konzipierung der Software-Entwicklungsumgebung SEEME stellt sich das Problem einer geeigneten Datenverwaltung, da herk\u00f6mmliche Datenbanksysteme diese Aufgabe nur unzureichend erf\u00fcllen. Um ein Datenmodell f\u00fcr SEEME definieren zu k\u00f6nnen, stellen wir zun\u00e4chst die Anforderungen an das Datenbanksystem einer Software-Entwicklungsumgebung zusammen und vergleichen sie mit den Eigenschaften verschiedener, in der Literatur beschriebener Datenbankmodelle. Dabei zeigt sich, dass keines dieser Modelle die Anforderungen in befriedigender Weise erf\u00fcllt. Wir definieren daher ein neues, an den Anforderungen einer Software-Entwicklungsumgebung orientiertes Datenbankmodell. Dieses basiert auf einem erweiterten Entity-Relationship-Ansatz und schliesst - im Unterschied zu vielen anderen Modellen - die Operationen auf den Daten ein, was die Betrachtung der Datenbank als abstrakten Datentyp erm\u00f6glicht. Die wesentlichen strukturellen Elemente des Modells sind Hierarchien von Objektklassen, welche auf beliebigen Ebenen durch Assoziationen in netzwerkartige Beziehungen gesetzt werden k\u00f6nnen, sowie die Generalisierung von Klassen und Assoziationen. Ferner f\u00fchren wir auf der Datenebene den Begriff des Musters ein, der in einem (noch auszuf\u00fchrenden) Variantenkonzept eine zentrale Stellung einnimmt. F\u00fcr die Datenmanipulation definieren wir mehrere, aufeinander aufbauende Operationsebenen . Die Operationen sind mit ihren Vor- und Nachbedingungen so auf das Datenbankschema abgestimmt, dass sie einerseits die Konsistenz der Datenbank (soweit diese im Schema\u00a0\u2026", "num_citations": "2\n", "authors": ["1478"]}
{"title": "A Study about the Knowledge and Use of Requirements Engineering Standards in Industry\n", "abstract": " The use of standards is considered a vital part of any engineering discipline. So one could expect that standards play an important role in Requirements Engineering (RE) as well. However, little is known about the actual knowledge and use of RE-related standards in industry. Objective. In this article, we investigate to which ex-tent standards and related artifacts such as templates or guidelines are known and used by RE practitioners. Method. To this end, we have conducted an online survey. We could analyze the replies from 90 RE practitioners using a combination of closed and open-text questions. Results. Our results indicate that the knowledge and use of standards and related artifacts in RE may be less widespread than one might expect from an engineering perspective. For example, about 45% of the respondents working as requirements engineers or business analysts do not know at least one of the two\u00a0\u2026", "num_citations": "1\n", "authors": ["1478"]}
{"title": "Handbook for the CPRE Foundation Level according to the IREB Standard\n", "abstract": " Students and practitioners who want to learn about Requirements Engineering and take the certification exam can use this handbook as a companion book to training courses offered by training providers, as well as for self-study and individual preparation for the certification exam. This handbook may also be used to refresh existing knowledge about Requirements Engineering, for example, when preparing for a CPRE Advanced Level course and exam.", "num_citations": "1\n", "authors": ["1478"]}
{"title": "FlexiView Experimental Tool: Fair and Detailed Usability Tests for Requirements Modeling Tools\n", "abstract": " Enhancing the usability of tools such as requirements modeling tools requires several cycles of testing and improvement. Since this process is costly, it is usually ignored. In this paper, we present an experimental tool which we have developed with two goals: (i) comparing the usability of a new navigation technique for requirements artifacts called FlexiView with traditional zooming and scrolling, and (ii) developing a platform that enables fast implementation and fair usability comparisons of new navigation techniques while producing generalizable results.", "num_citations": "1\n", "authors": ["1478"]}
{"title": "Von der Idee zum Anforderungsmodell ohne Medienbruch\n", "abstract": " Von der Idee zum Anforderungsmodell ohne Medienbruch Page 1 Von der Idee zum Anforderungsmodell ohne Medienbruch Requirements Engineering Research Group GI-Fachgruppentreffen RE / 30.11.12 Dustin W\u00fcest, Norbert Seyff, Martin Glinz Page 2 \u00dcbersicht \u2022 Problembeschreibung \u2022 Unser Ansatz: FlexiSketch \u2022 Tool Demo \u2022 Evaluation \u2022 Zuk\u00fcnftige Arbeit, Fazit 28.11.12 Von der Idee zum Anforderungsmodell ohne Medienbruch 3 Page 3 Problem: L\u00fccke zwischen Skizzen und Modellen 28.11.12 Von der Idee zum Anforderungsmodell ohne Medienbruch 4 Quelle: http://www.agilemodeling.com/artifacts/classDiagram.htm Page 4 Problem: L\u00fccke zwischen Skizzen und Modellen 28.11.12 Von der Idee zum Anforderungsmodell ohne Medienbruch 5 Quelle: http://www.agilemodeling.com/artifacts/classDiagram.htm Page 5 Problem: L\u00fccke zwischen Skizzen und Modellen 28.11.12 Von der Idee zum \u2026", "num_citations": "1\n", "authors": ["1478"]}
{"title": "If you want innovative RE, never ask the users \u2013 a formal debate\n", "abstract": " For the first time at an RE conference we propose a formal debate on a topic of critical importance to the RE community. The debate format is based on that of the Economist newspaper, in turn derived from the long-standing Oxford Union practices.", "num_citations": "1\n", "authors": ["1478"]}
{"title": "Grundlagen und Techniken des wissenschaftlichen Arbeitens\n", "abstract": " In einem ersten Teil werden zun\u00e4chst Wissenschaft, Technik und wissenschaftliche Erkenntnis kurz charakterisiert. Daraus werden Forderungen an wissenschaftliches Arbeiten abgeleitet. Die Arten wissenschaftlichen Arbeitens und die beiden Haupttypen von Arbeiten (auf Erkenntnisgewinn bzw. auf Ausbildung/Information ausgerichtet) werden charakterisiert.", "num_citations": "1\n", "authors": ["1478"]}