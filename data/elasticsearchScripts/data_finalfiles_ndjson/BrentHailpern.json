{"title": "Model-driven development: The good, the bad, and the ugly\n", "abstract": " In large software development organizations, increased complexity of products, shortened development cycles, and heightened expectations of quality have created major challenges at all the stages of the software life cycle. As this issue of the IBM Systems Journal illustrates, there are exciting improvements in the technologies of model-driven development (MDD) to meet many of these challenges. Even though the prevalent software-development practices in the industry are still immature, tools that embody MDD technologies are finally being incorporated in large-scale commercial software development. Assuming MDD pervades the industry over the next several years, there is reason to hope for significant improvements in software quality and time to value, but it is far from a foregone conclusion that MDD will succeed where previous software-engineering approaches have failed.", "num_citations": "489\n", "authors": ["1748"]}
{"title": "Software debugging, testing, and verification\n", "abstract": " In commercial software development organizations, increased complexity of products, shortened development cycles, and higher customer expectations of quality have placed a major responsibility on the areas of software debugging, testing, and verification. As this issue of the IBM Systems Journal illustrates, there are exciting improvements in the underlying technology on all three fronts. However, we observe that due to the informal nature of software development as a whole, the prevalent practices in the industry are still immature, even in areas where improved technology exists. In addition, tools that incorporate the more advanced aspects of this technology are not ready for large-scale commercial use. Hence there is reason to hope for significant improvements in this area over the next several years.", "num_citations": "443\n", "authors": ["1748"]}
{"title": "Mechanism for heterogeneous, peer-to-peer, and disconnected workflow operation\n", "abstract": " A mechanism for heterogeneous, peer-to-peer, and disconnected workflow execution across a network infrastructure. Performer Agent entities provide a homogeneous view of humans, applications, and heterogeneous workflow systems and components that act as Performers on the network by executing Tasks. Source Agent entities provide a homogeneous view of heterogeneous service requesters such as workflow scripts executing on different workflow systems, which generate Activities that need to execute on Performers as Tasks. Task Request and Task Response messages are used to standardize the communication between Source Agents and Performer Agents, along with other messages for controlling and queuing Tasks. Workflow systems interact with each other as peers using this mechanism by sending workflow execution requests, workflow script templates, and workflow execution environments to\u00a0\u2026", "num_citations": "313\n", "authors": ["1748"]}
{"title": "Verifying concurrent processes using temporal logic\n", "abstract": " Chapter 2 of this thesis describes our model of a concurrent program: a set of interacting processes and monitors. It is a short chapter, which introduces some important parallel program constructs and the programming language used in the rest of the thesis.Chapter 3 supplies a historical perspective. The verification techniques in this thesis follow the tradition begun by Floyd. That tradition is detailed along with the ideas that form the cornerstones for my techniques. Chapter 4 introduces the major new tool used in this thesis, temporal logic. Temporal logic is a convenient notation for describing liveness properties of programs. In this chapter, we describe the syntax, semantics, and history of temporal logic.", "num_citations": "234\n", "authors": ["1748"]}
{"title": "Modular verification of computer communication protocols\n", "abstract": " Programs that implement computer communications protocols can exhibit extremely complicated behavior, and neither informal reasoning nor testing is reliable enough to establish their correctness. In this paper we discuss the application of modular program verification techniques to protocols. This approach is more reliable than informal reasoning, but has an advantage over formal reasoning based on finite-state models, the complexity of the proof need not grow unmanageably as the size of the program increases. Certain tools of concurrent program verification that are especially useful for protocols are presented, history variables that record sequences of input and output values, temporal logic for expressing properties that must hold in a future system state such as eventual receipt of a message), and module specification and composition rules. The use of these techniques is illustrated by verifying two data\u00a0\u2026", "num_citations": "167\n", "authors": ["1748"]}
{"title": "Web Services: Promises and Compromises: Much of web services\u2019 initial promise will be realized via integration within the enterprise.\n", "abstract": " Much of web services\u2019 initial promise will be realized via integration within the enterprise, either with legacy applications or new business processes that span organizational silos. Enterprises need organizational structures that support this new paradigm.", "num_citations": "165\n", "authors": ["1748"]}
{"title": "System and method for similarity searching in high-dimensional data space\n", "abstract": " Information is analyzed in the form of a plurality of data values that represent a plurality of objects. A set of features that characterize each object of the plurality of objects is identified. The plurality of data values are stored in a database. Each data value corresponds to at least one of the plurality of objects based on the set of features. Ones of the plurality of data values stored in the database are partitioned into a plurality of clusters. Each cluster of the plurality of clusters is assigned to one respective node of a plurality of nodes arranged in a tree hierarchy. Ones of the plurality of nodes of the tree hierarchy are traversed. If desired, information may be analyzed for finding peer groups in e-commerce applications.", "num_citations": "136\n", "authors": ["1748"]}
{"title": "Dynamic method and apparatus for target promotion\n", "abstract": " A system and method for providing target groups of customers with a plurality of promotions for a plurality of goods. Active customers are tracked for each target group. Active customers can include customers with portable devices, customers with hand-held devices, customers who are viewers of a pay-per-view system and customers who are viewers of a web site. The promotions for each target group are calculated based on the promotional objectives for each target group and the conditions in the operating environment. Selected promotions are sent the active customers for each target group.", "num_citations": "127\n", "authors": ["1748"]}
{"title": "Script: a communication abstraction mechanism and its verification\n", "abstract": " In this paper, we introduce a new abstraction mechanism, called a script, which hides the low-level details that implement patterns of communication. A script localizes the communication between a set of roles (formal processes), to which actual processes enroll to participate in the action of the script. The paper discusses the addition of scripts to the languages CSP and ADA, and to a shared-variable language with monitors. Proof rules are presented for proving partial correctness and freedom from deadlock in concurrent programs using scripts.", "num_citations": "106\n", "authors": ["1748"]}
{"title": "Verifying network protocols using temporal logic\n", "abstract": " Programs that implement computer communications protocols can exhibit extremely complicated behavior, and neither informal reasoning nor testing is reliable enough to establish their correctness. In this paper we discuss the application of program verification techniques to protocols. This approach is more reliable than informal reasoning, but has the advantage over formal reasoning based on finite-state models that the complexity of the proof does not grow unmanageably as the size of the program increases. Certain tools of concurrent program verification that are especially useful for protocols are presented: history variables that record sequences of input and output values, temporal logic for expressing properties that must hold in a future system state (such as eventual receipt of a message), and module specification and composition rules. The use of these techniques is illustrated by verifying a simple data\u00a0\u2026", "num_citations": "100\n", "authors": ["1748"]}
{"title": "Interconnect scheme for shared memory local networks\n", "abstract": " A plurality of intelligent work stations are provided access to a shared memory through a switching hierarchy including a first array of mapping boxes for receiving a first address from an intelligent work station and including a virtual address and offset and for converting the virtual address into a terminal switch port designation and logical address, a first switch for forwarding the logical address and offset to the designated terminal switch port, a second array of mapping boxes for receiving the logical address and offset and for converting the logical address into a memory switch port designation and physical address, and a second switch for forwarding the physical address and offset to the designated memory switch port as an address to the shared memory.", "num_citations": "88\n", "authors": ["1748"]}
{"title": "Guest editor's introduction multiparadigm languages and environments\n", "abstract": " H ave you ever gotten into a ming, you are limited to choices 2 or 3: ferent programming languages.(The do-it-yourself construction program aroundthe problem using the terms language and environment are project, and become stuck constructs provided by your language defined in the box on p. 8. I use the because you were missing a particular or give up. term system to mean either a language tool? You had three choices: A new class of programming lan-or an environment.) Such large sys-(1) go out and buy (or borrow) the guages and environments is being de-tems invariably require a linkage right tool, veloped to help solve this problem. editor that combines object files from (2) use the wrong tool as best you They do not restrict the programmer differentcompilers into one execut-could, or to onlyoneparadigm (see box on p. 8); able program. Linkage editors are dif-(3) give up. rather they are multiparadigm systems ficult to use, often have their own ob-If you have not had this experience incorporating two or more of the con-scure syntax, and may not work for all building a bookcase, baking a new ventional program paradigms. For ex-languages. The user is burdened with recipe, or fixing your car, you most ample, the Loops system, described in understanding the calling conventions assuredly have while trying to write a the first article in thisissue, combines (parameter passing and the like) of large computer program. Admit it-features of the Lisp, functional, rule-each of the languages involved. you were programming in Pascal and oriented, and object-oriented para- As operating systems go, the Unix wanted to use your computer's data-digms\u00a0\u2026", "num_citations": "85\n", "authors": ["1748"]}
{"title": "Extending objects to support multiple interfaces and access control\n", "abstract": " A mechanism, called views, that allows programmers to specify multiple interfaces for objects and to control explicitly access to each interface is described. This mechanism provides a simple and flexible means of specifying enforceable access restrictions at many levels of granularity. It also results in system organization that supports browsing based on a number of different criteria. Views is defined, some examples of its uses are given, the impact of views on system organization is discussed, and five approaches to implementing views are outlined.< >", "num_citations": "84\n", "authors": ["1748"]}
{"title": "Local area network interconnect switching system\n", "abstract": " A system is shown for connecting a plurality of intelligent terminals through a central non-blocking switch to each other, to a partitioned memory and to one or more service processors to form a local area network.", "num_citations": "44\n", "authors": ["1748"]}
{"title": "System and method for providing service for searching web site addresses\n", "abstract": " A method for searching for a partially specified Uniform Resource Locator (URL) addresses includes receiving a user request, from a user, including a partially specified URL address. A URL search request handler is invoked to search for the partially specified URL address within an inverted index of web site URLs. A web search request handler is invoked to rank the search results of the search for the partially specified URL address based on one or more keywords specified in the user request, a list of recently accessed URLs, and a user profile. Search results are returned to the user comprising a list of URL addresses based on the search for the partially specified URL and ranked based on the user search data.", "num_citations": "42\n", "authors": ["1748"]}