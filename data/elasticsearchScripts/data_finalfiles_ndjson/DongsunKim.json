{"title": "Reinforcement learning-based dynamic adaptation planning method for architecture-based self-managed software\n", "abstract": " Recently, software systems face dynamically changing environments, and the users of the systems provide changing requirements at run-time. Self-management is emerging to deal with these problems. One of the key issues to achieve self-management is planning for selecting appropriate structure or behavior of self-managed software systems. There are two types of planning in self-management: off-line and on-line planning. Recent discussion has focused on off-line planning which provides static relationships between environmental changes and software configurations. In on-line planning, a software system can autonomously derive mappings between environmental changes and software configurations by learning its dynamic environment and using its prior experience. In this paper, we propose a reinforcement learning-based approach to on-line planning in architecture-based self-management. This\u00a0\u2026", "num_citations": "114\n", "authors": ["2108"]}
{"title": "Fixminer: Mining relevant fix patterns for automated program repair\n", "abstract": " Patching is a common activity in software development. It is generally performed on a source code base to address bugs or add new functionalities. In this context, given the recurrence of bugs across projects, the associated similar patches can be leveraged to extract generic fix actions. While the literature includes various approaches leveraging similarity among patches to guide program repair, these approaches often do not yield fix patterns that are tractable and reusable as actionable input to APR systems. In this paper, we propose a systematic and automated approach to mining relevant and actionable fix patterns based on an iterative clustering strategy applied to atomic changes within patches. The goal of FixMiner is thus to infer separate and reusable fix patterns that can be leveraged in other patch generation systems. Our technique, FixMiner, leverages Rich Edit Script which is a specialized tree structure of the edit scripts that captures the AST-level context of the code changes. FixMiner uses different tree representations of Rich Edit Scripts for each round of clustering to identify similar changes. These are abstract syntax trees, edit actions trees, and code context trees. We have evaluated FixMiner on thousands of software patches collected from open source projects. Preliminary results show that we are able to mine accurate patterns, efficiently exploiting change information in Rich Edit Scripts. We further integrated the mined patterns to an automated program repair prototype, PARFixMiner, with which we are able to correctly fix 26 bugs of the Defects4J benchmark. Beyond this quantitative performance, we show that the mined fix\u00a0\u2026", "num_citations": "76\n", "authors": ["2108"]}
{"title": "SHAGE: a framework for self-managed robot software\n", "abstract": " Behavioral, situational and environmental changes in complex software, such as robot software, cannot be completely captured in software design. To handle this dynamism, self-managed software enables its services dynamically adapted to various situations by reconfiguring its software architecture during run-time. We have developed a practical framework, called SHAGE (Self-Healing, Adaptive, and Growing SoftwarE), to support self-managed software for intelligent service robots. The SHAGE framework is composed of six main elements: a situation monitor to identify internal and external conditions of a software system, ontology-based models to describe architecture and components, brokers to find appropriate architectural reconfiguration patterns and components for a situation, a reconfigurator to actually change the architecture based on the selected reconfiguration pattern and components, a decision\u00a0\u2026", "num_citations": "36\n", "authors": ["2108"]}
{"title": "Automatic identifier inconsistency detection using code dictionary\n", "abstract": " Inconsistent identifiers make it difficult for developers to understand source code. In particular, large software systems written by several developers can be vulnerable to identifier inconsistency. Unfortunately, it is not easy to detect inconsistent identifiers that are already used in source code. Although several techniques have been proposed to address this issue, many of these techniques can result in false alarms since such techniques do not accept domain words and idiom identifiers that are widely used in programming practice. This paper proposes an approach to detecting inconsistent identifiers based on a custom code dictionary. It first automatically builds a Code Dictionary from the existing API documents of popular Java projects by using an Natural Language Processing (NLP) parser. This dictionary records domain words with dominant part-of-speech (POS) and idiom identifiers. This set of domain\u00a0\u2026", "num_citations": "26\n", "authors": ["2108"]}
{"title": "Software engineering education toolkit for embedded software architecture design methodology using robotic systems\n", "abstract": " Recently, industries need more effective software engineering education for undergraduate students as software plays an increasingly important role in consumer products. Specifically, the manufacturing industry emphasizes overall experience with software development processes from requirements to implementation in embedded software development. This paper proposes an educational toolkit focusing on architecture design methodology for embedded software and reports experience with teaching software engineering by using the toolkit. The toolkit has several tools that support methodology education. The toolkit consists of three perspectives: people, process, and technology. Each perspective represents a set of tools which can support educational activities. Particularly, the toolkit introduces LEGO MindStorms NXT as a robotic system to provide experiences with embedded software development, and\u00a0\u2026", "num_citations": "8\n", "authors": ["2108"]}
{"title": "Alchemistj: A framework for self-adaptive software\n", "abstract": " The major goal of self-adaptive software is to provide a mechanism that allows a software system to dynamically change its architectural configuration during run-time to cope with requirement changes and unexpected conditions. Software which needs to handle dynamically changing internal and external environment is one of the areas in which self-adaptive software may do an important role in improving the reliability and performance of software systems. There are three main capabilities that are necessary to support self-adaptive software: the ability to monitor and recognize internal/external situations that affect behavior of the software system; the ability to determine when and what to reconfigure in the software system to handle the situations; and the ability to dynamically change the software architecture during run-time to make the reconfiguration effective. In this paper, we describe a software\u00a0\u2026", "num_citations": "8\n", "authors": ["2108"]}
{"title": "Cost-Aware Clustering of Bug Reports by Using a Genetic Algorithm.\n", "abstract": " The inefficient distribution of bugs to developers is increasing the cost of software development and maintenance. In efforts to tackle this issue, various studies have been carried out to recommend suitable developers for specific bugs. These studies often leverage similarity between bug reports; for example, if a developer addressed a bug report similar to a newly incoming report, that developer can be suitable to fix the bug described in the new report. However, the existing studies have resulted in imbalanced distribution-a large number of bugs can be concentrated in a small number of developers. In this paper, we propose a novel approach to achieve a cost-aware distribution of bug reports to support workload balancing. Our approach is composed of two phases. First, a set of similar report groups composed of strongly related bugs is generated based on their similarity and dependency. Clusters are then created by grouping the similar report groups so that each cluster can have similar cost (ie, minimizing its standard deviation). Our approach leverages a genetic algorithm to find a near-optimal distribution of bug reports because it is an NP-hard problem. The experiments with 1,047 bug reports collected from Mozilla\u2019s Firefox were conducted to evaluate our approach. The results showed that our approach effectively provides an appropriate solution to achieve a costbalanced distribution of bug reports. In addition, we carried out a user study targeting 30 developers from 15 companies to figure out the usefulness and effectiveness of our approach. Among the participants, 67% answered that our approach is useful for triaging their bugs to\u00a0\u2026", "num_citations": "6\n", "authors": ["2108"]}
{"title": "Dynamic Architectural Selection: A Genetic Algorithm Based Approach\n", "abstract": " As the software industry is focusing on dealing with various requirements and environments, such as mobile and ubiquitous environments, software systems are increasingly undergoing many situational changes. These changes influence the quality of services that the software provides. Therefore, to maintain the performance of the software, it must be reconfigured. The reconfiguration is a complex problem if an application faces a large number of situations and has a number of software architectural instances. In this paper, we propose a novel approach to autonomous architectural selection in response to the current situation of various environments. This approach enables a software system to determine the best architectural instance for the current situation. To quickly find the best instance, we apply a genetic algorithm to the selection process. Further, we provide a performance evaluation to demonstrate that\u00a0\u2026", "num_citations": "6\n", "authors": ["2108"]}
{"title": "Designing dynamic software architecture for home service robot software\n", "abstract": " Behavior, situations and environmental changes in embedded software, such as robot software, are hard to expect at software design time. To deal with dynamic behavior, situations and environmental changes at runtime, current software engineering practices are not adequate due to the hardness of software modification. An approach to resolve this problem could be making software really \u201csoft\u201d that enables runtime software modification. We developed a practical framework called SHAGE(Self-Healing, Adaptive, and Growing SoftwarE) to implement reconfigurable software in home service robots. SHAGE enables runtime reconfiguration of software architecture when a service robot encounters unexpected situations or new user requirements. This paper focuses on designing reconfigurable software architecture, so called, dynamic software architecture. We also conducted a case study on a home service\u00a0\u2026", "num_citations": "6\n", "authors": ["2108"]}
{"title": "Applying Dynamic Software Architecture Management to Home Service Robot Software\n", "abstract": " Home service robots increasingly need to provide diverse and complex services such as cooking, sweeping and dishwashing. These services inevitably require a number of software functions simultaneously. For example, the cooking service requires an arm manipulation function to grasp dishes, an navigation function to move around, an object recognition function to find foods, an speech recognition function to understand user requirements, and etc. However, when the services and software functions are executed simultaneously in a robot without run-time software management, those may cause malfunction due to resource contention. In this paper, we describe the situation that causes resource contention and formulate architecture-based adaptation in robot software systems. Based on the formulation we proposed an approach to dynamic robot software management that effectively uses robot computing\u00a0\u2026", "num_citations": "1\n", "authors": ["2108"]}