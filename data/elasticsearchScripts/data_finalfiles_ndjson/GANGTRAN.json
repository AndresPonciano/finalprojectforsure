{"title": "Modular control-flow integrity\n", "abstract": " Control-Flow Integrity (CFI) is a software-hardening technique. It inlines checks into a program so that its execution always follows a predetermined Control-Flow Graph (CFG). As a result, CFI is effective at preventing control-flow hijacking attacks. However, past fine-grained CFI implementations do not support separate compilation, which hinders its adoption.", "num_citations": "232\n", "authors": ["356"]}
{"title": "RockSalt: better, faster, stronger SFI for the x86\n", "abstract": " Software-based fault isolation (SFI), as used in Google's Native Client (NaCl), relies upon a conceptually simple machine-code analysis to enforce a security policy. But for complicated architectures such as the x86, it is all too easy to get the details of the analysis wrong. We have built a new checker that is smaller, faster, and has a much reduced trusted computing base when compared to Google's original analysis. The key to our approach is automatically generating the bulk of the analysis from a declarative description which we relate to a formal model of a subset of the x86 instruction set architecture. The x86 model, developed in Coq, is of independent interest and should be usable for a wide range of machine-level verification tasks.", "num_citations": "165\n", "authors": ["356"]}
{"title": "Per-input control-flow integrity\n", "abstract": " Control-Flow Integrity (CFI) is an effective approach to mitigating control-flow hijacking attacks. Conventional CFI techniques statically extract a control-flow graph (CFG) from a program and instrument the program to enforce that CFG. The statically generated CFG includes all edges for all possible inputs; however, for a concrete input, the CFG may include many unnecessary edges.", "num_citations": "163\n", "authors": ["356"]}
{"title": "Sensitive information tracking in commodity IoT\n", "abstract": " Broadly defined as the Internet of Things (IoT), the growth of commodity devices that integrate physical processes with digital connectivity has had profound effects on society--smart homes, personal monitoring devices, enhanced manufacturing and other IoT applications have changed the way we live, play, and work. Yet extant IoT platforms provide few means of evaluating the use (and potential avenues for misuse) of sensitive information. Thus, consumers and organizations have little information to assess the security and privacy risks these devices present. In this paper, we present SainT, a static taint analysis tool for IoT applications. SainT operates in three phases;(a) translation of platform-specific IoT source code into an intermediate representation (IR),(b) identifying sensitive sources and sinks, and (c) performing static analysis to identify sensitive data flows. We evaluate SainT on 230 SmartThings market apps and find 138 (60%) include sensitive data flows. In addition, we demonstrate SainT on IoTBench, a novel open-source test suite containing 19 apps with 27 unique data leaks. Through this effort, we introduce a rigorously grounded framework for evaluating the use of sensitive information in IoT apps---and therein provide developers, markets, and consumers a means of identifying potential threats to security and privacy.", "num_citations": "151\n", "authors": ["356"]}
{"title": "Soteria: Automated iot safety and security analysis\n", "abstract": " Broadly defined as the Internet of Things (IoT), the growth of commodity devices that integrate physical processes with digital systems have changed the way we live, play and work. Yet existing IoT platforms cannot evaluate whether an IoT app or environment is safe, secure, and operates correctly. In this paper, we present\\Soteria, a static analysis system for validating whether an IoT app or IoT environment (collection of apps working in concert) adheres to identified safety, security, and functional properties. Soteria operates in three phases;(a) translation of platform-specific IoT source code into an intermediate representation (IR),(b) extracting a state model from the IR,(c) applying model checking to verify desired properties. We evaluate Soteria on 65 SmartThings market apps through 35 properties and find nine (14%) individual apps violate ten (29%) properties. Further, our study of combined app environments uncovered eleven property violations not exhibited in the isolated apps. Lastly, we demonstrate Soteria on MalIoT, a novel open-source test suite containing 17 apps with 20 unique violations.", "num_citations": "149\n", "authors": ["356"]}
{"title": "Nativeguard: Protecting android applications from third-party native libraries\n", "abstract": " Android applications often include third-party libraries written in native code. However, current native components are not well managed by Android's security architecture. We present NativeGuard, a security framework that isolates native libraries from other components in Android applications. Leveraging the process-based protection in Android, NativeGuard isolates native libraries of an Android application into a second application where unnecessary privileges are eliminated. NativeGuard requires neither modifications to Android nor access to the source code of an application. It addresses multiple technical issues to support various interfaces that Android provides to the native world. Experimental results demonstrate that our framework works well with a set of real-world applications, and incurs only modest overhead on benchmark programs.", "num_citations": "123\n", "authors": ["356"]}
{"title": "RockJIT: Securing just-in-time compilation using modular control-flow integrity\n", "abstract": " Managed languages such as JavaScript are popular. For performance, modern implementations of managed languages adopt Just-In-Time (JIT) compilation. The danger to a JIT compiler is that an attacker can often control the input program and use it to trigger a vulnerability in the JIT compiler to launch code injection or JIT spraying attacks. In this paper, we propose a general approach called RockJIT to securing JIT compilers through Control-Flow Integrity (CFI). RockJIT builds a fine-grained control-flow graph from the source code of the JIT compiler and dynamically updates the control-flow policy when new code is generated on the fly. Through evaluation on Google's V8 JavaScript engine, we demonstrate that RockJIT can enforce strong security on a JIT compiler, while incurring only modest performance overhead (14.6% on V8) and requiring a small amount of changes to V8's code. Key contributions of\u00a0\u2026", "num_citations": "122\n", "authors": ["356"]}
{"title": "Methods for enforcing control flow of a computer program\n", "abstract": " One aspect of the invention provides a method of controlling execution of a computer program. The method comprises the following runtime steps: parsing code to identify one or more indirect branches; creating a branch ID data structure that maps an indirect branch location to a branch ID, which is the indirect branch's equivalence class ID; creating a target ID data structure that maps a code address to a target ID, which is an equivalence class ID to which the address belongs; and prior to execution of an indirect branch including a return instruction located at an address: obtaining the branch ID associated with the return address from the branch ID data structure; obtaining the target ID associated with an actual return address for the indirect branch from the target ID data structure; and comparing the branch ID and the target ID.", "num_citations": "121\n", "authors": ["356"]}
{"title": "IoTGuard: Dynamic Enforcement of Security and Safety Policy in Commodity IoT.\n", "abstract": " Broadly defined as the Internet of Things (IoT), the growth of commodity devices that integrate physical processes with digital connectivity has changed the way we live, play, and work. To date, the traditional approach to securing IoT has treated devices individually. However, in practice, it has been recently shown that the interactions among devices are often the real cause of safety and security violations. In this paper, we present IOTGUARD, a dynamic, policy-based enforcement system for IoT, which protects users from unsafe and insecure device states by monitoring the behavior of IoT and triggeraction platform apps. IOTGUARD operates in three phases:(a) implementation of a code instrumentor that adds extra logic to an app\u2019s source code to collect app\u2019s information at runtime,(b) storing the apps\u2019 information in a dynamic model that represents the runtime execution behavior of apps, and (c) identifying IoT safety and security policies, and enforcing relevant policies on the dynamic model of individual apps or sets of interacting apps. We demonstrate IOTGUARD on 20 flawed apps and find that IOTGUARD correctly enforces 12 of the 12 policy violations. In addition, we evaluate IOTGUARD on 35 SmartThings IoT and 30 IFTTT trigger-action platform market apps executed in a simulated smart home. IOTGUARD enforces 11 unique policies and blocks 16 states in six (17.1%) SmartThings and five (16.6%) IFTTT apps. IOTGUARD imposes only 17.3% runtime overhead on an app and 19.8% for five interacting apps. Through this effort, we introduce a rigorously grounded system for enforcing correct operation of IoT devices through systematically\u00a0\u2026", "num_citations": "119\n", "authors": ["356"]}
{"title": "Combining control-flow integrity and static analysis for efficient and validated data sandboxing\n", "abstract": " In many software attacks, inducing an illegal control-flow transfer in the target system is one common step. Control-Flow Integrity (CFI) protects a software system by enforcing a pre-determined control-flow graph. In addition to providing strong security, CFI enables static analysis on low-level code. This paper evaluates whether CFI-enabled static analysis can help build efficient and validated data sandboxing. Previous systems generally sandbox memory writes for integrity, but avoid protecting confidentiality due to the high overhead of sandboxing memory reads. To reduce overhead, we have implemented a series of optimizations that remove sandboxing instructions if they are proven unnecessary by static analysis. On top of CFI, our system adds only 2.7% runtime overhead on SPECint2000 for sandboxing memory writes and adds modest 19% for sandboxing both reads and writes. We have also built a principled\u00a0\u2026", "num_citations": "118\n", "authors": ["356"]}
{"title": "Program analysis of commodity IoT applications for security and privacy: Challenges and opportunities\n", "abstract": " Recent advances in Internet of Things (IoT) have enabled myriad domains such as smart homes, personal monitoring devices, and enhanced manufacturing. IoT is now pervasive\u2014new applications are being used in nearly every conceivable environment, which leads to the adoption of device-based interaction and automation. However, IoT has also raised issues about the security and privacy of these digitally augmented spaces. Program analysis is crucial in identifying those issues, yet the application and scope of program analysis in IoT remains largely unexplored by the technical community. In this article, we study privacy and security issues in IoT that require program-analysis techniques with an emphasis on identified attacks against these systems and defenses implemented so far. Based on a study of five IoT programming platforms, we identify the key insights that result from research efforts in both the\u00a0\u2026", "num_citations": "83\n", "authors": ["356"]}
{"title": "An Empirical Security Study of the Native Code in the JDK.\n", "abstract": " It is well known that the use of native methods in Java defeats Java's guarantees of safety and security, which is why the default policy of Java applets, for example, does not allow loading non-local native code. However, there is already a large amount of trusted native C/C++ code that comprises a significant portion of the Java Development Kit (JDK). We have carried out an empirical security study on a portion of the native code in Sun's JDK 1.6. By applying static analysis tools and manual inspection, we have identified in this security-critical code previously undiscovered bugs. Based on our study, we describe a taxonomy to classify bugs. Our taxonomy provides guidance to construction of automated and accurate bug-finding tools. We also suggest systematic remedies that can mediate the threats posed by the native code.", "num_citations": "81\n", "authors": ["356"]}
{"title": "Monitor integrity protection with space efficiency and separate compilation\n", "abstract": " Low-level inlined reference monitors weave monitor code into a program for security. To ensure that monitor code cannot be bypassed by branching instructions, some form of control-flow integrity must be guaranteed. Past approaches to protecting monitor code either have high space overhead or do not support separate compilation. We present Monitor Integrity Protection (MIP), a form of coarse-grained control-flow integrity. The key idea of MIP is to arrange instructions in variable-sized chunks and dynamically restrict indirect branches to target only chunk beginnings. We show that this simple idea is effective in protecting monitor code integrity, enjoys low space and execution-time overhead, supports separate compilation, and is largely compatible with an existing compiler toolchain. We also show that MIP enables a separate verifier that completely disassembles a binary and verifies its security. MIP is designed to\u00a0\u2026", "num_citations": "80\n", "authors": ["356"]}
{"title": "Smartphone dual defense protection framework: Detecting malicious applications in android markets\n", "abstract": " In this paper, we present a smart phone dual defense protection framework that allows Official and Alternative Android Markets to detect malicious applications among those new applications that are submitted for public release. Our framework consists of servers running on clouds where developers who wish to release their new applications can upload their software for verification purpose. The verification server first uses system call statistics to identify potential malicious applications. After verification, if the software is clean, the application will then be released to the relevant markets. To mitigate against false negative cases, users who run new applications can invoke our network traffic monitoring (NTM)tool which triggers network traffic capture upon detecting some suspicious behaviors e.g. detecting sensitive data being sent to output stream of an open socket. The network traffic will be analyzed to see if it\u00a0\u2026", "num_citations": "78\n", "authors": ["356"]}
{"title": "Robusta: Taming the native beast of the JVM\n", "abstract": " Java applications often need to incorporate native-code components for efficiency and for reusing legacy code. However, it is well known that the use of native code defeats Java's security model. We describe the design and implementation of Robusta, a complete framework that provides safety and security to native code in Java applications. Starting from software-based fault isolation (SFI), Robusta isolates native code into a sandbox where dynamic linking/loading of libraries in supported and unsafe system modification and confidentiality violations are prevented. It also mediates native system calls according to a security policy by connecting to Java's security manager. Our prototype implementation of Robusta is based onNative Client and OpenJDK. Experiments in this prototype demonstrate Robusta is effective and efficient, with modest runtime overhead on a set of JNI benchmark programs. Robusta can be\u00a0\u2026", "num_citations": "76\n", "authors": ["356"]}
{"title": "Safe Java native interface\n", "abstract": " Type safety is a promising approach to enhancing software security. Programs written in type-safe programming languages such as Java are type-safe by construction. However, in practice, many complex applications are heterogeneous, ie, they contain components written in different languages. The Java Native Interface (JNI) allows type-safe Java code to interact with unsafe C code. When a type-safe language interacts with an unsafe language in the same address space, in general, the overall application becomes unsafe.In this work, we propose a framework called Safe Java Native Interface (SafeJNI) that ensures type safety of heterogeneous programs that contain Java and C components. We identify the loopholes of using JNI that would permit C code to bypass the type safety of Java. The proposed SafeJNI system fixes these loopholes and guarantees type safety when native C methods are called. The overall approach consists of (i) retro-fitting the native C methods to make them safe, and (ii) developing an enhanced system that captures additional invariants that must be satisfied to guarantee safe interoperation. The SafeJNI framework is implemented through a combination of static and dynamic checks on the C code.", "num_citations": "75\n", "authors": ["356"]}
{"title": "Detection and classification of different botnet C&C channels\n", "abstract": " Unlike other types of malware, botnets are characterized by their command and control (C&C) channels, through which a central authority, the botmaster, may use the infected computer to carry out malicious activities. Given the damage botnets are capable of causing, detection and mitigation of botnet threats are imperative. In this paper, we present a host-based method for detecting and differentiating different types of botnet infections based on their C&C styles, e.g., IRC-based, HTTP-based, or peer-to-peer (P2P) based. Our ability to detect and classify botnet C&C channels shows that there is an inherent similarity in C&C structures for different types of bots and that the network characteristics of botnet C&C traffic is inherently different from legitimate network traffic. The best performance of our detection system has an overall accuracy of 0.929 and a false positive rate of 0.078.", "num_citations": "74\n", "authors": ["356"]}
{"title": "A compositional logic for control flow\n", "abstract": " We present a program logic, , which modularly reasons about unstructured control flow in machine-language programs. Unlike previous program logics, the basic reasoning units in  are multiple-entry and multiple-exit program fragments.  provides fine-grained composition rules to compose program fragments. It is not only useful for reasoning about unstructured control flow in machine languages, but also useful for deriving rules for common control-flow structures such as while-loops, repeat-until-loops, and many others. We also present a semantics for  and prove that the logic is both sound and complete with respect to the semantics. As an application,  and its semantics have been implemented on top of the  machine language, and are embedded in the Foundational Proof-Carrying Code project to produce memory-safety proofs for machine-language programs.", "num_citations": "63\n", "authors": ["356"]}
{"title": "Detection of repackaged android malware with code-heterogeneity features\n", "abstract": " During repackaging, malware writers statically inject malcode and modify the control flow to ensure its execution. Repackaged malware is difficult to detect by existing classification techniques, partly because of their behavioral similarities to benign apps. By exploring the app's internal different behaviors, we propose a new Android repackaged malware detection technique based on code heterogeneity analysis. Our solution strategically partitions the code structure of an app into multiple dependence-based regions (subsets of the code). Each region is independently classified on its behavioral features. We point out the security challenges and design choices for partitioning code structures at the class and method level graphs, and present a solution based on multiple dependence relations. We have performed experimental evaluation with over 7,542 Android apps. For repackaged malware, our partition-based\u00a0\u2026", "num_citations": "57\n", "authors": ["356"]}
{"title": "Strato: A retargetable framework for low-level inlined-reference monitors\n", "abstract": " Low-level Inlined Reference Monitors (IRM) such as control-flow integrity and software-based fault isolation can foil numerous software attacks. Conventionally, those IRMs are implemented through binary rewriting or transformation on equivalent low-level programs that are tightly coupled with a specific Instruction Set Architecture (ISA). Resulting implementations have poor retargetability to different ISAs. This paper introduces an IRM-implementation framework at a compiler intermediate-representation (IR) level. The IR-level framework enables easy retargetability to different ISAs, but raises the challenge of how to preserve security at the low level, as the compiler backend might invalidate the assumptions at the IR level. We propose a constraint language to encode the assumptions and check whether they still hold after the backend transformations and optimizations. Furthermore, an independent verifier is implemented to validate the security of low-level code. We have implemented the framework inside LLVM to enforce the policy of control-flow integrity and data sandboxing for both reads and writes. Experimental results demonstrate that it incurs modest runtime overhead of 19.90% and 25.34% on SPECint2000 programs for x86-32 and x86-64, respectively", "num_citations": "52\n", "authors": ["356"]}
{"title": "Finding bugs in exceptional situations of JNI programs\n", "abstract": " Software flaws in native methods may defeat Java's guarantees of safety and security. One common kind of flaws in native methods results from the discrepancy on how exceptions are handled in Java and in native methods. Unlike exceptions in Java, exceptions raised in the native code through the Java Native Interface (JNI) are not controlled by the Java Virtual Machine (JVM). Only after the native code finishes execution will the JVM's mechanism for exceptions take over. This discrepancy makes handling of JNI exceptions an error prone process and can cause serious security flaws in software written using the JNI.", "num_citations": "48\n", "authors": ["356"]}
{"title": "ILEA: Inter-language analysis across Java and C\n", "abstract": " Java bug finders perform static analysis to find implementation mistakes that can lead to exploits and failures; Java compilers perform static analysis for optimization. allIf Java programs contain foreign function calls to C libraries, however, static analysis is forced to make either optimistic or pessimistic assumptions about the foreign function calls, since models of the C libraries are typically not available.", "num_citations": "48\n", "authors": ["356"]}
{"title": "CaSym: Cache aware symbolic execution for side channel detection and mitigation\n", "abstract": " Cache-based side channels are becoming an important attack vector through which secret information can be leaked to malicious parties. implementations and Previous work on cache-based side channel detection, however, suffers from the code coverage problem or does not provide diagnostic information that is crucial for applying mitigation techniques to vulnerable software. We propose CaSym, a cache-aware symbolic execution to identify and report precise information about where side channels occur in an input program. Compared with existing work, CaSym provides several unique features: (1) CaSym enables verification against various attack models and cache models, (2) unlike many symbolic-execution systems for bug finding, CaSym verifies all program execution paths in a sound way, (3) CaSym uses two novel abstract cache models that provide good balance between analysis scalability and\u00a0\u2026", "num_citations": "46\n", "authors": ["356"]}
{"title": "Analysis of code heterogeneity for high-precision classification of repackaged malware\n", "abstract": " During repackaging, malware writers statically inject malcode and modify the control flow to ensure its execution. Repackaged malware is difficult to detect by existing classification techniques, partly because of their behavioral similarities to benign apps. By exploring the app's internal different behaviors, we propose a new Android repackaged malware detection technique based on code heterogeneity analysis. Our solution strategically partitions the code structure of an app into multiple dependence-based regions (subsets of the code). Each region is independently classified on its behavioral features. We point out the security challenges and design choices for partitioning code structures at the class and method level graphs, and present a solution based on multiple dependence relations. We have performed experimental evaluation with over 7,542 Android apps. For repackaged malware, our partition-based\u00a0\u2026", "num_citations": "42\n", "authors": ["356"]}
{"title": "A novel low-cost method of silica aerogel fabrication using fly ash and trona ore with ambient pressure drying technique\n", "abstract": " Highly porous and hydrophobic silica aerogel is fabricated using fly ash and trona ore as the starting materials and the cost-effective ambient pressure drying technique. The optimal calcination parameters are determined as temperature of 850\u00a0\u00b0C, holding time of 2\u00a0h, and the trona ore/fly ash mass ratio of 1.4. The CO2 release mechanism during calcination is proposed and has been verified by the Thermogravimetric and Differential Scanning Calorimetry analysis (TG/DSC) and X-ray fluorescence (XRF) technique. The hydrogel is derived from reacting the calcination mixture with sulphuric acid solution, followed by filtration. The impurities can be effectively removed through water washing and solvent exchange processes. No ion exchange resin is used in this preparation method, and thus it is a safe, inexpensive and much more straightforward process. In order to minimize drying shrinkage, the hydrogel is first\u00a0\u2026", "num_citations": "40\n", "authors": ["356"]}
{"title": "Semantic foundations for typed assembly languages\n", "abstract": " Typed Assembly Languages (TALs) are used to validate the safety of machine-language programs. The Foundational Proof-Carrying Code project seeks to verify the soundness of TALs using the smallest possible set of axioms: the axioms of a suitably expressive logic plus a specification of machine semantics. This article proposes general semantic foundations that permit modular proofs of the soundness of TALs. These semantic foundations include Typed Machine Language (TML), a type theory for specifying properties of low-level data with powerful and orthogonal type constructors, and Lc, a compositional logic for specifying properties of machine instructions with simplified reasoning about unstructured control flow. Both of these components, whose semantics we specify using higher-order logic, are useful for proving the soundness of TALs. We demonstrate this by using TML and Lc to verify the soundness of\u00a0\u2026", "num_citations": "39\n", "authors": ["356"]}
{"title": "The New Jersey Voting-machine Lawsuit and the AVC Advantage DRE Voting Machine.\n", "abstract": " As a result of a public-interest lawsuit, by Court order we were able to study, for one month, the hardware and source code of the Sequoia AVC Advantage direct-recording electronic voting machine, which is used throughout New Jersey (and Louisiana), and the Court has permitted us to publicly describe almost everything that we were able to learn. In short, these machines are vulnerable to a wide variety of attacks on the voting process. It would not be in the slightest difficult for a moderately determined group or individual to mount a vote-stealing attack that would be successful and undetectable.", "num_citations": "39\n", "authors": ["356"]}
{"title": "Development of a single-phase thermosiphon for cold collection and storage of radiative cooling\n", "abstract": " A single-phase thermosiphon is developed for cold collection and storage of radiative cooling. Compared to the conventional nocturnal radiative cooling systems that use an electric pump to drive the heat transfer fluid, the proposed single-phase thermosiphon uses the buoyancy force to drive heat transfer fluid. This solution does not require electricity, therefore improving the net gain of the radiative cooling system. A single-phase thermosiphon was built, which consists of a flat panel, a cold collection tank, a water return tube, and a water distribution tank. Considering that outdoor radiative cooling flux is constantly changing (i.e. uncontrollable), an indoor testing facility was developed to provide a controllable cooling flux (comparable to a radiative cooling flux of 100\u00a0W/m2) for the evaluation of thermosiphon performance. The testing apparatus is a chilled aluminum flat plate that has a controlled air gap separation\u00a0\u2026", "num_citations": "38\n", "authors": ["356"]}
{"title": "One secure data integrity verification scheme for cloud storage\n", "abstract": " Cloud computing is a novel kind of information technology that users can enjoy sundry cloud services from the shared configurable computing resources. Compared with traditional local storage, cloud storage is a more economical choice because the remote data center can replace users for data management and maintenance, which can save time and money on the series of work. However, delivering data to an unknown Cloud Service Provider (CSP) makes the integrity of data become a potential vulnerability. To solve this problem, we propose a secure identity based aggregate signatures (SIBAS) as the data integrity checking scheme which resorts Trusted Execution Environment (TEE) as the auditor to check the outsourced data in the local side. SIBAS can not only check the integrity of outsourced data, but also achieve the secure key management in TEE through Shamir\u2019s (t, n) threshold scheme. To prove the\u00a0\u2026", "num_citations": "37\n", "authors": ["356"]}
{"title": "Delayed and controlled failures in tamper-resistant software\n", "abstract": " Tamper-resistant software (TRS) consists of two functional components: tamper detection and tamper response. Although both are equally critical to the effectiveness of a TRS system, past research has focused primarily on the former, while giving little thought to the latter. Not surprisingly, many successful breaks of commercial TRS systems found their first breaches at the relatively na\u00efve tamper-response modules. In this paper, we describe a novel tamper-response system that evades hacker detection by introducing delayed, probabilistic failures in a program. This is accomplished by corrupting the program\u2019s internal state at well-chosen locations. Our tamper-response system smoothly blends in with the program and leaves no noticeable traces behind, making it very difficult for a hacker to detect its existence. The paper also presents empirical results to demonstrate the efficacy of our system.", "num_citations": "36\n", "authors": ["356"]}
{"title": "Ptrsplit: Supporting general pointers in automatic program partitioning\n", "abstract": " Partitioning a security-sensitive application into least-privileged components and putting each into a separate protection domain have long been a goal of security practitioners and researchers. However, a stumbling block to automatically partitioning C/C++ applications is the presence of pointers in these applications. Pointers make calculating data dependence, a key step in program partitioning, difficult and hard to scale; furthermore, C/C++ pointers do not carry bounds information, making it impossible to automatically marshall and unmarshall pointer data when they are sent across the boundary of partitions. In this paper, we propose a set of techniques for supporting general pointers in automatic program partitioning. Our system, called PtrSplit, constructs a Program Dependence Graph (PDG) for tracking data and control dependencies in the input program and employs a parameter-tree approach for\u00a0\u2026", "num_citations": "34\n", "authors": ["356"]}
{"title": "Performance evaluation of a metamaterial-based new cool roof using improved Roof Thermal Transfer Value model\n", "abstract": " A new cool roof with potential to generate significant energy savings in buildings has been developed from a metamaterial film named as RadiCold. Considering that the RadiCold film has unique optical and thermal characteristics and the current Roof Thermal Transfer Value model neglecting the effect of roof thermal mass that may lead to overestimating the cooling load from roofs, this work developed an improved Roof Thermal Transfer Value model and validated the model for both RadiCold cool roof and traditional roofing structures. Data from the reduced-size model building experiments showed that the improved Roof Thermal Transfer Value model can accurately describe the heat gains or losses via the roofs. Under real-world weather conditions in the United States (Tucson AZ, Los Angeles, CA, and Orlando FL), the improved Roof Thermal Transfer Value model has been applied to three types of roof\u00a0\u2026", "num_citations": "27\n", "authors": ["356"]}
{"title": "Jvm-portable sandboxing of java\u2019s native libraries\n", "abstract": " Although Java provides strong support for safety and security, native libraries used in a Java application can open security holes. Previous work, Robusta, puts native libraries in a sandbox to protect the integrity and security of Java. However, Robusta\u2019s implementation modifies the internals of OpenJDK, a particular implementation of a Java Virtual Machine (JVM). As such, it is not portable to other JVM implementations. This paper shows how to make the idea of sandboxing native libraries JVM-portable. We present a two-layer approach for sandboxing without modifying the internals of a JVM. We also discuss our experience of sandboxing Java\u2019s core native libraries. Experiments show that our approach of JVM-portable sandboxing incurs modest performance overhead on SPECjvm 2008 benchmark programs.", "num_citations": "27\n", "authors": ["356"]}
{"title": "Novel Na2SO4@ SiO2 phase change material with core-shell structures for high temperature thermal storage\n", "abstract": " Microencapsulated composite material using Na2SO4 as core and SiO2 as shell for high temperature thermal energy storage is prepared. The effects of silica mass percentages within the Na2SO4@SiO2 PCM composites on thermal conductivity, thermal stability, melting temperature, and latent heat are investigated. No new phases are formed during the encapsulation process. The spherical silica nanoparticles with diameters at around 300\u202fnm are well decorated on the surface of Na2SO4. The PCM composite with 5.4% silica addition is determined as the optimal sample due to its excellent comprehensive properties. The inhibition of liquid leakage during melting can be effectively realized. The thermal conductivity of Na2SO4@SiO2 PCM under high temperatures (600\u2013800\u202f\u00b0C) can be increased to 0.59\u202fW/(m\u202fK), 0.62\u202fW/(m\u202fK), and 0.87\u202fW/(m\u202fK), respectively. The initial and peak melting temperatures of the\u00a0\u2026", "num_citations": "26\n", "authors": ["356"]}
{"title": "Silica aerogels formed from soluble silicates and methyl trimethoxysilane (MTMS) using CO2 gas as a gelation agent\n", "abstract": " Silica aerogel has been formed using CO2 gas as the gelation agent through the low-cost ambient pressure drying technique. With water wash and the following solvent exchange process for Na+ removal, this synthesis route has no ion exchange resin used and becomes more straightforward. In order to reduce the silica particle and pore sizes, different hydrolysis-condensation rate control agents including dimethylformamide (DMF), methyltriethoxysilane (TMES), Glycerol and methyltrimethoxylsilane (MTMS) have been applied to modify the structural groups of silica network. Results show that MTMS is the most effective control agent and the optimized MTMS/silica sol volume ratio has been found at 1% by testing the specific surface area of the aerogel. In addition, the effects of chlorotrimethylsilane (TMCS) amount and the calcining temperature on the physicochemical properties of the aerogel have been also\u00a0\u2026", "num_citations": "24\n", "authors": ["356"]}
{"title": "Braille to print translations for Chinese\n", "abstract": " In this paper, we study Braille word segmentation and transformation of Mandarin Braille to Chinese characters. The former consists of rule, sign and knowledge bases for disambiguation and mistake correction by using adjacent constraints and bi-directional maximal matching in which segmentation precision is better than 99%. The latter can be divided into two stages: Braille to Chinese pinyin (a phonemic Romanization) and pinyin to characters. By incorporating a pinyin knowledge dictionary into the system, we have perfectly solved the problem of ambiguity in the translation from Braille to pinyin and developed a statistical language model based on the transformation of pinyin to characters. By using Viterbi search, we have built a multi-level graph and found the sequence of Chinese characters with maximal likelihood. By using an N-Best algorithm to get the N most likely character sequences and probing into the\u00a0\u2026", "num_citations": "24\n", "authors": ["356"]}
{"title": "Using safety properties to generate vulnerability patches\n", "abstract": " Security vulnerabilities are among the most critical software defects in existence. When identified, programmers aim to produce patches that prevent the vulnerability as quickly as possible, motivating the need for automatic program repair (APR) methods to generate patches automatically. Unfortunately, most current APR methods fall short because they approximate the properties necessary to prevent the vulnerability using examples. Approximations result in patches that either do not fix the vulnerability comprehensively, or may even introduce new bugs. Instead, we propose property-based APR, which uses human-specified, program-independent and vulnerability-specific safety properties to derive source code patches for security vulnerabilities. Unlike properties that are approximated by observing the execution of test cases, such safety properties are precise and complete. The primary challenge lies in mapping\u00a0\u2026", "num_citations": "23\n", "authors": ["356"]}
{"title": "Verifying internet of things safety and security in physical spaces\n", "abstract": " Concerns about safety and security have led to questions about the risk of embracing the Internet of Things (IoT). We consider the needs and techniques for verifying the correct operation of IoT devices and environments within the physical spaces they inhabit.", "num_citations": "22\n", "authors": ["356"]}
{"title": "Construction of a semantic model for a typed assembly language\n", "abstract": " Typed Assembly Languages (TALs) can be used to validate the safety of assembly-language programs. However, typing rules are usually trusted as axioms. In this paper, we show how to build semantic models for typing judgments in TALs based on an induction technique, so that both the type-safety theorem and the typing rules can be proved as lemmas in a simple logic. We demonstrate this technique by giving a complete model to a sample TAL. This model allows a typing derivation to be interpreted as a machine-checkable safety proof at the machine level.", "num_citations": "22\n", "authors": ["356"]}
{"title": " CFI: Type-Assisted Control Flow Integrity for x86-64 Binaries\n", "abstract": " Programs aiming for low runtime overhead and high availability draw on several object-oriented features available in the C/C++ programming language, such as dynamic object dispatch. However, there is an alarmingly high number of object dispatch (i.e., forward-edge) corruption vulnerabilities, which undercut security in significant ways and are in need of a thorough solution. In this paper, we propose , an extended control flow integrity (CFI) model that uses both the types and numbers of function parameters to enforce forward- and backward-edge control flow transfers. At a high level, it improves the precision of existing forward-edge recognition approaches by considering the type information of function parameters, which are directly extracted from the application binaries. Therefore,  can be used to harden legacy applications for which source code may not be available. We have evaluated  on\u00a0\u2026", "num_citations": "20\n", "authors": ["356"]}
{"title": "Principles and implementation techniques of software-based fault isolation\n", "abstract": " When protecting a computer system, it is often necessary to isolate an untrusted component into a separate protection domain and provide only controlled interaction between the domain and the rest of the system. Software-based Fault Isolation (SFI) establishes a logical protection domain by inserting dynamic checks before memory and control-transfer instructions. Compared to other isolation mechanisms, it enjoys the benefits of high efficiency (with less than 5% performance overhead), being readily applicable to legacy native code, and not relying on special hardware or OS support. SFI has been successfully applied in many applications, including isolating OS kernel extensions, isolating plug-ins in browsers, and isolating native libraries in the Java Virtual Machine. In this survey article, we will discuss the SFI policy, its main implementation and optimization techniques, as well as an SFI formalization on an idealized assembly language.", "num_citations": "20\n", "authors": ["356"]}
{"title": "Bringing Java's wild native world under control\n", "abstract": " For performance and for incorporating legacy libraries, many Java applications contain native-code components written in unsafe languages such as C and C++. Native-code components interoperate with Java components through the Java Native Interface (JNI). As native code is not regulated by Java's security model, it poses serious security threats to the managed Java world. We introduce a security framework that extends Java's security model and brings native code under control. Leveraging software-based fault isolation, the framework puts native code in a separate sandbox and allows the interaction between the native world and the Java world only through a carefully designed pathway. Two different implementations were built. In one implementation, the security framework is integrated into a Java Virtual Machine (JVM). In the second implementation, the framework is built outside of the JVM and takes\u00a0\u2026", "num_citations": "20\n", "authors": ["356"]}
{"title": "A secure privacy preserving deduplication scheme for cloud computing\n", "abstract": " Data deduplication is a key technique to improve storage efficiency in cloud computing. By pointing redundant files to a single copy, cloud service providers greatly reduce their storage space as well as data transfer costs. Despite of the fact that the traditional deduplication approach has been adopted widely, it comes with a high risk of losing data confidentiality because of the data storage models in cloud computing. To deal with this issue in cloud storage, we first propose a TEE (trusted execution environment) based secure deduplication scheme. In our scheme, each cloud user is assigned a privilege set; the deduplication can be performed if and only if the cloud users have the correct privilege. Moreover, our scheme augments the convergent encryption with users\u2019 privileges and relies on TEE to provide secure key management, which improves the ability of such cryptosystem to resist chosen plaintext attacks\u00a0\u2026", "num_citations": "19\n", "authors": ["356"]}
{"title": "JET: exception checking in the java native interface\n", "abstract": " Java's type system enforces exception-checking rules that stipulate a checked exception thrown by a method must be declared in the throws clause of the method. Software written in Java often invokes native methods through the use of the Java Native Interface (JNI). Java's type system, however, cannot enforce the same exception-checking rules on Java exceptions raised in native methods. This gap makes Java software potentially buggy and often difficult to debug when an exception is raised in native code. In this paper, we propose a complete static-analysis framework called JET to extend exception-checking rules even on native code. The framework has a two-stage design where the first stage throws away a large portion of irrelevant code so that the second stage, a fine-grained analysis, can concentrate on a small set of code for accurate bug finding. This design achieves both high efficiency and accuracy\u00a0\u2026", "num_citations": "19\n", "authors": ["356"]}
{"title": "Finding reference-counting errors in Python/C programs with affine analysis\n", "abstract": " Python is a popular programming language that uses reference counting to manage heap objects. Python also has a Foreign Function Interface (FFI) that allows Python extension modules to be written in native code such as C and C++. Native code, however, is outside Python\u2019s system of memory management; therefore extension programmers are responsible for making sure these objects are reference counted correctly. This is an error prone process when code becomes complex. In this paper, we propose Pungi, a system that statically checks whether Python objects\u2019 reference counts are adjusted correctly in Python/C interface code. Pungi transforms Python/C interface code into affine programs with respect to our proposed abstractions of reference counts. Our system performs static analysis on transformed affine programs and reports possible reference counting errors. Our prototype implementation\u00a0\u2026", "num_citations": "18\n", "authors": ["356"]}
{"title": "Modelling study of the low-pump-power demand constructal T-shaped pipe network for a large scale radiative cooled-cold storage system\n", "abstract": " To provide supplemental cooling to air cooled condenser (ACC) based thermo-electric power plants, radiative cooling is one of the options to ensure comparable efficiency as water cooled power plants. However, radiative cooling has relatively low energy intensity, about 100\u00a0W/m2 cooling power on daily average. To work with power plants generally at few hundreds of megawatts, an intermediate system is needed to bridge this huge energy intensity mismatching at low energy cost. A low-pump-power demand pipe network is proposed to collect cold energy generated by the radiative cooling surfaces using water as the heat transfer fluid and the cold water is thus stored in intermediate storage devices. In this work, head loss and heat loss analysis models have been developed for the proposed constructal T-shaped network design, which provides convenience to integrate and scale up the radiative cooling\u00a0\u2026", "num_citations": "16\n", "authors": ["356"]}
{"title": "Markup SVG\u2014An online content-aware image abstraction and annotation tool\n", "abstract": " Suppose you want to effectively search through millions of images, train an algorithm to perform image and video object recognition, or research the complex patterns and relationships that exist in our visual world. A common and essential component for any of these tasks is a large annotated image dataset. However, obtaining labeled image data is a complex and tedious task that requires methods for annotating and structuring content. Therefore, we developed a comprehensive online tool and data structure, Markup SVG, that simplifies the collection of annotated image data by leveraging state-of-the-art image processing techniques. As the core data structure of our tool, we adopt scalable vector graphics (SVG), an extensible and versatile language built upon XML. Given the extensibility of our framework, we are able to encode low-level image features, high-level semantics, and further define interactions with the\u00a0\u2026", "num_citations": "16\n", "authors": ["356"]}
{"title": "Program-mandering: Quantitative privilege separation\n", "abstract": " Privilege separation is an effective technique to improve software security. However, past partitioning systems do not allow programmers to make quantitative tradeoffs between security and performance. In this paper, we describe our toolchain called PM. It can automatically find the optimal boundary in program partitioning. This is achieved by solving an integer-programming model that optimizes for a user-chosen metric while satisfying the remaining security and performance constraints on other metrics. We choose security metrics to reason about how well computed partitions enforce information flow control to:(1) protect the program from low-integrity inputs or (2) prevent leakage of program secrets. As a result, functions in the sensitive module that fall on the optimal partition boundaries automatically identify where declassification is necessary. We used PM to experiment on a set of real-world programs to protect\u00a0\u2026", "num_citations": "14\n", "authors": ["356"]}
{"title": "Surface modification of porous gC 3 N 4 materials using a waste product for enhanced photocatalytic performance under visible light\n", "abstract": " A facile and low-cost g-C3N4 surface modification approach using a biomass-derived liquid product is proposed in this work. Through the incorporation of renewable and sustainable bio-oil that is generated from a solar powered waste biomass pyrolysis, the surface functionality of a pristine g-C3N4 material is modified with functional groups that are of electron-withdrawing character, leading to the improvement of the photocatalytic hydrogen evolution rate for the modified C3N4 sample. At low reaction temperature (120 \u00b0C), the sample is modified through a cleavage of C\u2013N bonds between three heptazine fragments and tertiary nitrogen, followed by the bonding of oxygenated functional groups. As the reaction temperature increases further to a higher temperature (180 \u00b0C), a partial de-aromatization of the triazine network in the C3N4 sample due to the intercalation of functional groups from this post-synthesis bio-oil\u00a0\u2026", "num_citations": "14\n", "authors": ["356"]}
{"title": "Provide detailed and real-time indoor environmental information using POD\u2013LSE and limited measurements\n", "abstract": " In general, the building environment is a system of unsteady variables that are constantly changing (or fluctuating), even within a single space. Current monitoring capabilities such as thermostats do not fully capture the detailed dynamically changing processes for major environmental parameters in a building/space with regard to both spatial and temporal variations. Detailed indoor environmental information can be provided for potentially better building environmental control and building energy performance improvement using fast calculations from a proper orthogonal decomposition\u2013linear stochastic estimation (POD\u2013LSE) methodology with limited measurements. In this work, the POD\u2013LSE method has been used to reconstruct the entire fluctuating thermal field in an experimental room with a high level of accuracy (error less than 0.56\u00a0\u00b0C for cooling) based on a few real-time measurements. Evaluations to the\u00a0\u2026", "num_citations": "14\n", "authors": ["356"]}
{"title": "\u57fa\u4e8e\u6a21\u578b\u9884\u6d4b\u63a7\u5236\u7684\u6c7d\u8f66\u5e95\u76d8\u96c6\u6210\u63a7\u5236\n", "abstract": " \u4e3a\u4e86\u5b9e\u73b0\u6c7d\u8f66\u5e95\u76d8\u7684\u96c6\u6210\u63a7\u5236,\u63d0\u51fa\u4e86\u6a21\u578b\u9884\u6d4b\u63a7\u5236(MPC)\u65b9\u6cd5.\u5728\u7d27\u6025\u907f\u969c\u64cd\u7eb5\u65f6,\u5229\u7528\u56db\u8f6e\u5dee\u52a8\u5236\u52a8\u548c\u4e3b\u52a8\u524d\u8f6e\u8f6c\u5411\u96c6\u6210\u63a7\u5236\u7684\u65b9\u5f0f\u5b9e\u73b0\u5bf9\u6c7d\u8f66\u7406\u60f3\u64cd\u7eb5\u7279\u6027\u7684\u8ddf\u968f.\u4e0a\u5c42\u96c6\u6210\u63a7\u5236\u5668\u901a\u8fc7\u6a21\u578b\u9884\u6d4b\u63a7\u5236\u65b9\u6cd5\u51b3\u7b56\u4e0b\u5c42\u5b50\u63a7\u5236\u5668\u6240\u9700\u7684\u9644\u52a0\u6a2a\u6446\u529b\u77e9\u548c\u524d\u8f6e\u9644\u52a0\u8f6c\u89d2.\u5efa\u7acb\u4e86\u4e03\u81ea\u7531\u5ea6\u975e\u7ebf\u6027\u8f66\u8f86\u6a21\u578b\u4f5c\u4e3a\u9884\u6d4b\u6a21\u578b,\u5e76\u901a\u8fc7\u5b9e\u8f66\u8bd5\u9a8c\u5bf9\u5176\u7cbe\u5ea6\u8fdb\u884c\u4e86\u9a8c\u8bc1.\u5728Carsim\u4e2d\u7684\u865a\u62df\u8bd5\u9a8c\u5bf9\u6a21\u578b\u9884\u6d4b\u63a7\u5236\u65b9\u6cd5\u7684\u63a7\u5236\u6548\u679c\u8fdb\u884c\u4e86\u9a8c\u8bc1.", "num_citations": "14\n", "authors": ["356"]}
{"title": "Segmentation of Mandarin Braille word and Braille translation based on multi-knowledge\n", "abstract": " This paper is about the segmentation of Braille words and the transformation from Mandarin Braille to Chinese characters. Braille word segmentation consists of the rules base, the signs base of segmentation and knowledge base for disambiguation and mistakes. By using adjacency constraints and bidirectional maximum matching with a dictionary, our system's segmentation precision is better than 99% for the common text. By incorporating a pinyin knowledge dictionary into the system, we perfectly solved the problem of ambiguity in the translation from Braille to pinyin and developed a statistical language model based on the transformation of pinyin into characters. By using a multi-knowledge base to carry out the disambiguation process for each pinyin sentence, we built a multi-level graph and used a Viterbi search to find the sequence of Chinese characters with maximum likelihood, and used an N-best\u00a0\u2026", "num_citations": "14\n", "authors": ["356"]}
{"title": "Study of underfloor air distribution using zonal model-based simulation and experimental measurements\n", "abstract": " Underfloor air distribution (UFAD) is an effective strategy to provide both ventilation and air conditioning for buildings. To predict indoor airflows and temperature distribution, zonal model has advantages over other methods such as multi-zone model and computational fluid dynamics (CFD) by considering the prediction accuracy and computational cost. In this work, a numerical algorithm for floor-mounted diffuser flows, which calculates the airflow mass conservation and energy conservation separately, was implemented in a newly developed zonal model computer program for UFAD application, based on the established zonal model-pressurized zonal model with air-diffuser (POMA). This computer program was validated by lab experiments under both natural convection condition and mechanical ventilation for a lab-scale mixing UFAD system. Comparisons of zonal model simulation results and experimental\u00a0\u2026", "num_citations": "13\n", "authors": ["356"]}
{"title": "Enforcing user-space privilege separation with declarative architectures\n", "abstract": " Applying privilege separation in software development is an effective strategy for limiting the damage of an attack on a software system. In this approach, a software system is separated into a set of communicating protection domains of least privilege. In a privilege-separated system, even if one protection domain is hijacked by an attacker, the rest of the system may still function.", "num_citations": "13\n", "authors": ["356"]}
{"title": "JNI Light: An operational model for the core JNI\n", "abstract": " Through foreign function interfaces (FFIs), software components in different programming languages interact with each other in the same address space. Recent years have witnessed a number of systems that analyze FFIs for safety and reliability. However, lack of formal specifications of FFIs hampers progress in this endeavor. We present a formal operational model, JNI Light (JNIL), for a subset of a widely used FFI\u2014the Java Native Interface (JNI). JNIL focuses on the core issues when a high-level garbage-collected language interacts with a low-level language. It proposes abstractions for handling a shared heap, crosslanguage method calls, cross-language exception handling, and garbage collection. JNIL can directly serve as a formal basis for JNI tools and systems. The abstractions in JNIL are also useful when modeling other FFIs, such as the Python/C interface and the OCaml/C interface.", "num_citations": "13\n", "authors": ["356"]}
{"title": "Field study of thermal environment in Wannan traditional residential buildings in the summer\n", "abstract": " Long-term field measurements of the indoor and outdoor temperatures and air velocities were used to analyze the thermal environment in several typical Chinese Wannan traditional residential buildings in the summer. The results clarify some misunderstandings about traditional buildings, such as concerning the temperature distribution in the tall rooms and the temperature of the cool entry way. Also, detailed analysis of structures such as the raised shaft, the roof, the eaves and measurements of the temperature and wind velocity, etc., show that the shading is the most important element of the design characteristics of Chinese traditional residential buildings in Wannan and that natural ventilation is a less important effect.", "num_citations": "13\n", "authors": ["356"]}
{"title": "A compositional logic for control flow and its application in foundational proof-carrying code\n", "abstract": " Proof-Carrying Code (PCC) is a static mechanism that mechanically verifies type safety of machine-language programs. But the problem in conventional PCC is, who will verify the verifier (the type checker) itself? The Foundational Proof-Carrying Code (FPCC) project at Princeton verifies the soundness of the type checker from the smallest possible set of axioms\u2014logic plus machine semantics. One challenge in the verification is that machine code, unlike high-level languages, contains unstructured control flow (due to arbitrary jumps). A piece of machine code can contain multiple entry points that jump instructions might jump to, and multiple exit points. Traditional Hoare logic and its variants either verify the partial correctness of programs with only one entry and one exit, or need the whole program to verify jump instructions, which is not modular.", "num_citations": "12\n", "authors": ["356"]}
{"title": "Privacy preserving based logistic regression on big data\n", "abstract": " Cloud computing has strong computing power and huge storage space. Machine learning algorithm, combining with cloud computing, makes the processing of large-scale data practical. Logistic regression algorithm is a widely popular machine learning-based classification algorithm that can be implemented in cloud. However, data privacy cannot be guaranteed in big data processing as privacy leakage of the training data may occur. In order to prevent the privacy leakage of logistic regression algorithm in the cloud and promote the processing efficiency of training data, this paper offers a Privacy Preserving Logistic Regression Algorithm (PPLRA). The homomorphic encryption is used to encrypt the private data when they are uploaded for training. Moreover, the approximation of the Sigmoid function in logistic regression using Taylor's theorem can support the safe calculation using homomorphic encryption. The\u00a0\u2026", "num_citations": "11\n", "authors": ["356"]}
{"title": "Fine-grained access control based on trusted execution environment\n", "abstract": " With the wide adoption of mobile devices, it becomes increasingly a reality that mobile users use a variety of apps from various sources. Since the enforcement of strict privacy is difficult, the inappropriate access by malicious apps is a major concern for mobile users, and access control becomes a challenge. In order to prevent the leakage of sensitive information (such as the contact lists, or private pictures) by inappropriate or illegal access, we propose a fine-grained access-control scheme based on Ciphertext-Policy Attribute-Based Encryption (CPABE) and Trusted Execution Environment (TEE), which can effectively protect data. In the scheme, CPABE is adopted in a novel way to solve the important security problems by supporting fine-grained access control during the access period and by supporting the critical operations running in the trusted execution environment. The scheme can be used to mitigate the\u00a0\u2026", "num_citations": "10\n", "authors": ["356"]}
{"title": "Lightweight kernel isolation with virtualization and VM functions\n", "abstract": " Commodity operating systems execute core kernel subsystems in a single address space along with hundreds of dynamically loaded extensions and device drivers. Lack of isolation within the kernel implies that a vulnerability in any of the kernel subsystems or device drivers opens a way to mount a successful attack on the entire kernel.", "num_citations": "10\n", "authors": ["356"]}
{"title": "Optimizing the 3d distributed climate inside greenhouses using multi-objective optimization algorithms and computer fluid dynamics\n", "abstract": " As one of the major production facilities in agriculture, a greenhouse has many spatial distributed factors influencing crop growth and energy consumption, such as temperature field, air flow pattern, CO 2 concentration distribution, etc. By introducing a hybrid computational fluid dynamics\u2013evolutionary algorithm (CFD-EA) method, this paper constructs a micro-climate model of greenhouse with main environmental parameters optimized. Considering environmental factors\u2019 spatial influences together with energy usage simultaneously, the optimal solutions of control variables for crop growth are calculated. A commercial greenhouse located in east China is chosen for the method validation. Field experiments using temperature/velocity sensor matrix are carried out for CFD accuracy investigation. On this basis, the proposed optimization method is employed to search for the optimal control variables and parameters corresponding to the environmental Pareto frontier. By the proposed multi-objective scheme, we believe the method can provide set point basis for the design and regulation of large/medium-sized greenhouse production with high spatial resolution. View Full-Text", "num_citations": "10\n", "authors": ["356"]}
{"title": "Bidirectional grammars for machine-code decoding and encoding\n", "abstract": " Binary analysis, which analyzes machine code, requires a decoder for converting bits into abstract syntax of machine instructions. Binary rewriting requires an encoder for converting instructions to bits. We propose a domain-specific language that enables the specification of both decoding and encoding in a single bidirectional grammar. With dependent types, a bigrammar enables the extraction of an executable decoder and encoder as well as a correctness proof showing their consistency. The bigrammar DSL is embedded in Coq with machine-checked proofs. We have used the bigrammar DSL to specify the decoding and encoding of subsets of the x86-32 and MIPS instruction sets. We have also extracted an executable decoder and encoder from the x86 bigrammar with competitive performance.", "num_citations": "10\n", "authors": ["356"]}
{"title": "Efficient user-space information flow control\n", "abstract": " The model of Decentralized Information Flow Control (DIFC) is effective at improving application security and can support rich confidentiality and integrity policies. We describe the design and implementation of duPro, an efficient user-space information flow control framework. duPro adopts Software-based Fault Isolation (SFI) to isolate protection domains within the same process. It controls the end-to-end information flow at the granularity of SFI domains. Being a user-space framework, duPro does not require any OS changes. Since SFI is more lightweight than hardware-based isolation (eg, OS processes), the inter-domain communication and scheduling in duPro are more efficient than process-level DIFC systems. Finally, duPro supports a novel checkpointing-restoration mechanism for efficiently reusing protection domains. Experiments demonstrate applications can be ported to duPro with negligible overhead\u00a0\u2026", "num_citations": "10\n", "authors": ["356"]}
{"title": "Modification Effects of  on Early Compressive Strength and Hydration Characteristics of High-Volume Fly Ash Concrete\n", "abstract": " Utilization of nanomaterials in high-volume fly ash (HVFA) concrete as a means of improving concrete\u2019s properties is feasible. This paper presents experimental data to evaluate the modification effects of  (NS) on early compressive strength and hydration properties of HVFA concrete. To this end, a mixture design method was used to experimentally investigate the early compressive strength development in the NS-incorporated HVFA concrete. For a better understanding of the modification process, several important hydration characteristics of the selected NS-incorporated HVFA cement pastes were analyzed for hydration kinetics, phase composition, and pore structure through isothermal calorimetry, X-ray diffraction (XRD), thermogravimetric/derivative thermogravimetric (TG/DTG), and mercury intrusion porosimetry (MIP) measurements. Experimental results confirmed that NS can partially compensate for\u00a0\u2026", "num_citations": "9\n", "authors": ["356"]}
{"title": "TraceChain: A blockchain\u2010based scheme to protect data confidentiality and traceability\n", "abstract": " The risk of sharing data in cloud computing has gathered increasing attention. After the owner of some confidential data outsources the data to cloud storage services and shares it with others, the data owner lost the control to the data to a large extent. To achieve data sharing while keeping data confidentiality, attribute\u2010based encryption (ABE) can be employed by cloud storage services. However, ABE can only guarantee that outsourced data on the cloud is decrypted by attribute\u2010satisfying users but cannot restrict data from being accessed by dishonest users whose attributes also satisfy the access\u2010control policy. It is impossible for the data owner to control the shared data after it has been decrypted by dishonest users, especially when a set of attribute\u2010satisfying dishonest users may collude. To address this concern, we propose a traceable data sharing scheme called TraceChain. In TraceChain, data is encrypted\u00a0\u2026", "num_citations": "9\n", "authors": ["356"]}
{"title": "From debugging-information based binary-level type inference to cfg generation\n", "abstract": " Binary-level Control-Flow Graph (CFG) construction is essential for applications such as control-flow integrity. There are two main approaches: the binary-analysis approach and the compiler-modification approach. The binary-analysis approach does not require source code, but it constructs low-precision CFGs. The compiler-modification approach requires source code and modifies compilers for CFG generation. We describe the design and implementation of an alternative system for high-precision CFG construction, which still assumes source code but does not modify compilers. Our approach makes use of standard compiler-generated meta-information, including symbol tables, relocation information, and debugging information. A key component in the system is a type-inference engine that infers types of low-level storage locations such as registers from types in debugging information. Inferred types enable a\u00a0\u2026", "num_citations": "9\n", "authors": ["356"]}
{"title": "Use of proper orthogonal decomposition and linear stochastic estimation technique to investigate real-time detailed airflows for building ventilation\n", "abstract": " As energy efficiency concerns grow for building heating, ventilation, and air-conditioning systems, more advanced mathematical models and methods may be needed for implementing more comprehensive building environmental monitoring practices. This work investigates the methodology of applying a coupled proper orthogonal decomposition (POD) and linear stochastic estimation (LSE) technique to provide detailed real-time velocity information for a single-room test environment under either mechanical ventilation or wind-driven cross natural ventilation with the support of limited on-site monitoring measurements. In addition, an example application of the proposed POD\u2013LSE methodology with limited measurements to obtain real-time fluctuating wind-driven ventilation rates using a POD\u2013LSE reconstructed velocity profile across a window opening is presented and shows very good agreement with the\u00a0\u2026", "num_citations": "9\n", "authors": ["356"]}
{"title": "Producing hook placements to enforce expected access control policies\n", "abstract": " Many security-sensitive programs manage resources on behalf of mutually distrusting clients. To control access to resources, authorization hooks are placed before operations on those resources. Manual hook placements by programmers are often incomplete or incorrect, leading to insecure programs. We advocate an approach that automatically identifies the set of locations to place authorization hooks that mediates all security-sensitive operations in order to enforce expected access control policies at deployment. However, one challenge is that programmers often want to minimize the effort of writing such policies. As a result, they may remove authorization hooks that they believe are unnecessary, but they may remove too many hooks, preventing the enforcement of some desirable access control policies.               In this paper, we propose algorithms that automatically compute a minimal authorization\u00a0\u2026", "num_citations": "9\n", "authors": ["356"]}
{"title": "One secure access scheme based on trusted execution environment\n", "abstract": " The wide adoption of mobile devices poses an imminent threat to preserving privacy. In order to prevent the leakage of sensitive information (such as the contact list, or private pictures) raised by inappropriate access, we propose a secure access scheme based on Trusted Execution Environment (TEE) specifically designed for mobile devices. The proposed scheme has two purposes: secure access and minimizing losses. For secure access, we use TEE to run access authorization and verification; for minimizing losses, we use the strategy of file slice to divide the sensitive file into multiple parts and then encrypt the file parts respectively in case of large-scale leakage. Practically, our scheme's \"minimizing losses\" can be easily expanded to cloud computing by mapping one file part in our scheme to a whole file in cloud computing scenario. The theoretical analysis and experimental evaluation indicate that our scheme\u00a0\u2026", "num_citations": "8\n", "authors": ["356"]}
{"title": "Exception analysis in the java native interface\n", "abstract": " A Foreign Function Interface (FFI) allows one host programming language to interoperate with another foreign language. It enables efficient software development by permitting developers to assemble components in different languages. One typical FFI is the Java Native Interface (JNI), through which Java programs can invoke native-code components developed in C, C++, or assembly code. Although FFIs bring convenience to software development, interface code developed in FFIs is often error prone because of the lack of safety and security enforcement. This paper introduces a static-analysis framework, TurboJet, which finds exception-related bugs in JNI applications. It finds bugs of inconsistent exception declarations and bugs of mishandling JNI exceptions. TurboJet is carefully engineered to achieve both high efficiency and accuracy. We have applied TurboJet on a set of benchmark programs and identified\u00a0\u2026", "num_citations": "8\n", "authors": ["356"]}
{"title": "FDTL: a unified flash memory and hard disk translation layer\n", "abstract": " Flash memory and magnetic disks are two widely used forms of non-volatile storage in consumer electronics. Both forms of storage have their advantages and limitations. The present study describes the design and implementation of a unified flash memory and hard disk translation layer (FDTL) to improve the performance of hybrid storage containing flash memory and disk drives. In this scheme, randomly accessed and frequently read data are mapped into a flash device, whereas sequentially accessed, frequently written, and cold data are mapped into a disk drive. FDTL is a good fit for several kinds of consumer electronics that demand large capacity storage and require high throughput, low energy consumption, and low cost. A trace-driven simulation was implemented to evaluate FDTL. Experimental results show that the I/O performance of FDTL is superior to other storage schemes with similar capacity. FDTL\u00a0\u2026", "num_citations": "8\n", "authors": ["356"]}
{"title": "Tamper response mechanism\n", "abstract": " A tamper response mechanism introduces a delayed failure into a program in response to detected tampering with the program. The mechanism determines a manner of responding to the detected tampering. The manner of responding may include corrupting a global pointer or using other techniques. The mechanism also determines when to respond to the tampering and implements the response at the determined time.", "num_citations": "8\n", "authors": ["356"]}
{"title": "Enforcing resource usage protocols via scoped methods\n", "abstract": " Traditional modularity mechanisms such as Java\u2019s classes and packages or ML\u2019s structures and functors restrict the set of functions that may be applied to an object, but are unable to restrict the timing of these function applications effectively. We propose a new language construct, the scoped method, which allows the implementer of a class to specify a temporal resource usage protocol. This protocol limits the sequence of methods that may be applied to an object. For example, a protocol for file access might specify that the file must be opened, read or written some number of times, and then closed. We present a type-based analysis to enforce the protocol and prove its correctness.", "num_citations": "8\n", "authors": ["356"]}
{"title": "Comprehensive reuse of pyrolysis chars from coals for fabrication of highly insulating building materials\n", "abstract": " A comprehensive concept for coal conversion is proposed in this work, from which a series of products generated including light volatiles, liquid oils, and pyrolysis chars. The result indicates the optimal temperature for the pyrolysis from organic solvent extraction residue is between 700\u202f\u00b0C to 900\u202f\u00b0C, producing largest amount of liquid oils and giving rise to a chemically stable pyrolysis char sample with considerable BET specific surface area. The pyrolysis chars are then utilized as an alternative material for the fabrication of heat-insulating building material (char clay plaster-CCP, char brick-CB and foam glass-FA). Due to the inherent large specific surface area and ample pore channels, the water could be absorbed and stored in these pores, resulting in the effects of regulating indoor humidity and also low thermal conductivity. The char-based building material makes the exterior walls good breathing properties\u00a0\u2026", "num_citations": "7\n", "authors": ["356"]}
{"title": "An overview of unsteady analysis techniques for natural wind turbulence and its effects on natural ventilation\n", "abstract": " Focusing on the turbulence in natural ventilation and its impact on both occupant thermal comfort and building energy consumption, this paper presents a review of existing unsteady natural ventilation envelope flow models, as well as other techniques that have potential application to further our understanding of turbulence in natural ventilation and develop models which capture the dynamics and effects on thermal comfort. Literature provides numerous techniques ranging from quasi-steady temporal inertial theory, to unsteady CFD models, to experimental study, and other statistical and signal processing techniques. The Proper Orthogonal Decomposition and Stochastic Estimate techniques have been paid particular attention as they may be an alternative tool for understanding the turbulence of natural wind and possibly be combined with predictive models in an attempt to quantify the effects on thermal comfort\u00a0\u2026", "num_citations": "7\n", "authors": ["356"]}
{"title": "JATO: Native code atomicity for Java\n", "abstract": " Atomicity enforcement in a multi-threaded application can be critical to the application\u2019s safety. In this paper, we take the challenge of enforcing atomicity in a multilingual application, which is developed in multiple programming languages. Specifically, we describe the design and implementation of JATO, which enforces the atomicity of a native method when a Java application invokes the native method through the Java Native Interface (JNI). JATO relies on a constraint-based system, which generates constraints from both Java and native code based on how Java objects are accessed by threads. Constraints are then solved to infer a set of Java objects that need to be locked in native methods to enforce the atomicity of the native method invocation. We also propose a number of optimizations that soundly improve the performance. Evaluation through JATO\u2019s prototype implementation demonstrates it\u00a0\u2026", "num_citations": "7\n", "authors": ["356"]}
{"title": "Weak updates and separation logic\n", "abstract": " Separation Logic (SL) provides a simple but powerful technique for reasoning about imperative programs that use shared data structures. Unfortunately, SL supports only \u201cstrong updates\u201d, in which mutation to a heap location is safe only if a unique reference is owned. This limits the applicability of SL when reasoning about the interaction between many high-level languages (e.g., ML, Java, C#) and low-level ones since these high-level languages do not support strong updates. Instead, they adopt the discipline of \u201cweak updates\u201d, in which there is a global \u201cheap type\u201d to enforce the invariant of type-preserving heap updates. We present SLw, a logic that extends SL with reference types and elegantly reasons about the interaction between strong and weak updates. We also describe a semantic framework for reference types; this framework is used to prove the soundness of SLw.", "num_citations": "7\n", "authors": ["356"]}
{"title": "Methodologies for quantifying (Re-) randomization security and timing under JIT-ROP\n", "abstract": " Just-in-time return-oriented programming (JIT-ROP) allows one to dynamically discover instruction pages and launch code reuse attacks, effectively bypassing most fine-grained address space layout randomization (ASLR) protection. However, in-depth questions regarding the impact of code (re-) randomization on code reuse attacks have not been studied. For example, how would one compute the re-randomization interval effectively by considering the speed of gadget convergence to defeat JIT-ROP attacks?; how do starting pointers in JIT-ROP impact gadget availability and gadget convergence time?; what impact do fine-grained code randomizations have on the Turing-complete expressive power of JIT-ROP payloads? We conduct a comprehensive measurement study on the effectiveness of fine-grained code randomization schemes, with 5 tools, 20 applications including 6 browsers, 1 browser engine, and 25\u00a0\u2026", "num_citations": "6\n", "authors": ["356"]}
{"title": "SNPL: one scheme of securing nodes in IoT perception layer\n", "abstract": " The trustworthiness of data is vital data analysis in the age of big data. In cyber-physical systems, most data is collected by sensors. With the increase of sensors as Internet of Things (IoT) nodes in the network, the security risk of data tampering, unauthorized access, false identify, and others are overgrowing because of vulnerable nodes, which leads to the great economic and social loss. This paper proposes a security scheme, Securing Nodes in IoT Perception Layer (SNPL), for protecting nodes in the perception layer. The SNPL is constructed by novel lightweight algorithms to ensure security and satisfy performance requirements, as well as safety technologies to provide security isolation for sensitive operations. A series of experiments with different types and numbers of nodes are presented. Experimental results and performance analysis show that SNPL is efficient and effective at protecting IoT from faulty or malicious nodes. Some potential practical application scenarios are also discussed to motivate the implementation of the proposed scheme in the real world. View Full-Text", "num_citations": "6\n", "authors": ["356"]}
{"title": "Analyzing control flow integrity with LLVM-CFI\n", "abstract": " Control-flow hijacking attacks are used to perform malicious computations. Current solutions for assessing the attack surface after a control flow integrity (CFI) policy was applied can measure only indirect transfer averages in the best case without providing any insights wrt the absolute calltarget reduction per callsite, and gadget availability. Further, tool comparison is underdeveloped or not possible at all. CFI has proven to be one of the most promising protections against control flow hijacking attacks, thus many efforts have been made to improve CFI in various ways. However, there is a lack of systematic assessment of existing CFI protections.", "num_citations": "6\n", "authors": ["356"]}
{"title": "CFG construction soundness in control-flow integrity\n", "abstract": " Control-Flow Integrity (CFI) is an intensively studied technique for hardening software security. It enforces a Control-Flow Graph (CFG) by inlining runtime checks into target programs. Many methods have been proposed to construct the enforced CFG, with different degrees of precision and sets of assumptions. However, past CFI work has not made attempt at justifying their CFG construction soundness using formal semantics and proofs. In this paper, we formalize the CFG construction in two major CFI systems, identify their assumptions, and prove their soundness; the soundness proof shows that their computed sets of targets for indirect calls are safe over-approximations.", "num_citations": "6\n", "authors": ["356"]}
{"title": "Languages must expose memory heterogeneity\n", "abstract": " The last decade has seen an explosion in new and innovative memory technologies. While certain technologies, like transactional memory, have seen adoption at the language level, others, such as sandboxed memory, scratchpad memory, and persistent memory, have not received any systematic programming language support. This is true even though the underlying compiler-level mechanisms for these mechanisms are similar. In this paper, we argue that programming languages must be enhanced to expose heterogeneous memory technologies to programmers, so that they can enjoy the benefits of those technologies and be able to reason about programs that use the advanced features of novel memory technologies. We sketch a language design that allows programmers to specify memory requirements and behaviors, for both data and code. We further describe how a compiler can support such a language\u00a0\u2026", "num_citations": "6\n", "authors": ["356"]}
{"title": "Natural ventilation performance of single room building with fluctuating wind speed and thermal mass\n", "abstract": " Natural ventilation is driven by either buoyancy forces or wind pressure forces or their combinations that inherit stochastic variation into ventilation rates. Since the ventilation rate is a nonlinear function of multiple variable factors including wind speed, wind direction, internal heat source and building structural thermal mass, the conventional methods for quantifying ventilation rate simply using dominant wind direction and average wind speed may not accurately describe the characteristic performance of natural ventilation. From a new point of view, the natural ventilation performance of a single room building under fluctuating wind speed condition using the Monte-Carlo simulation approach was investigated by incorporating building fa\u00e7ade thermal mass effect. Given a same hourly turbulence intensity distribution, the wind speeds with 1 min frequency fluctuations were generated using a stochastic model\u00a0\u2026", "num_citations": "6\n", "authors": ["356"]}
{"title": "A hierarchical SVG image abstraction layer for medical imaging\n", "abstract": " As medical imaging rapidly expands, there is an increasing need to structure and organize image data for efficient analysis, storage and retrieval. In response, a large fraction of research in the areas of content-based image retrieval (CBIR) and picture archiving and communication systems (PACS) has focused on structuring information to bridge the \"semantic gap\", a disparity between machine and human image understanding. An additional consideration in medical images is the organization and integration of clinical diagnostic information. As a step towards bridging the semantic gap, we design and implement a hierarchical image abstraction layer using an XML based language, Scalable Vector Graphics (SVG). Our method encodes features from the raw image and clinical information into an extensible \"layer\" that can be stored in a SVG document and efficiently searched. Any feature extracted from the raw\u00a0\u2026", "num_citations": "6\n", "authors": ["356"]}
{"title": "Insecurities and inaccuracies of the Sequoia AVC Advantage 9.00 H DRE voting machine\n", "abstract": " The Sequoia AVC Advantage is a direct-recording electronic (DRE) voting machine used in New Jersey, Pennsylvania, and other states. I. The AVC Advantage 9.00 is easily \u201chacked,\u201d by the installation of fraudulent firmware. This is done by prying just one ROM chip from its socket and pushing a new one in, or by replacement of the Z80 processor chip. We have demonstrated that this \u201chack\u201d takes just 7 minutes to perform. The fraudulent firmware can steal votes during an election, just as its criminal designer programs it to do. The fraud cannot practically be detected. There is", "num_citations": "6\n", "authors": ["356"]}
{"title": "One enhanced secure access scheme for outsourced data\n", "abstract": " The popularity of apps makes smart phones rapidly become the most widespread form of communication. Due to\u00a0the impact\u00a0of resource constraints in mobile phones, users prefer to outsource data from the local device to the cloud. Access control of outsourced data drives the researches for protecting sensitive data from all the possibly malicious software access or from cloud service provider misbehavior. The unexpected attacks from the local device or the cloud that are trying to breach the data access policy imposed by data owner has resulted in inadequate current access control solutions. Therefore, this paper proposes one access control scheme for Android devices to avoid authentication bypass attacks from both sides. Attribute-Based Encryption is used to design one app-level fine-grained data access for the purpose of data confidentiality in the local side. Moreover, Trusted Execution Environment is\u00a0\u2026", "num_citations": "5\n", "authors": ["356"]}
{"title": "Refining Indirect Call Targets at the Binary Level\n", "abstract": " Enforcing fine-grained Control-Flow Integrity (CFI) is critical for increasing software security. However, for commercial off-the-shelf (COTS) binaries, constructing highprecision Control-Flow Graphs (CFGs) is challenging, because there is no source-level information, such as symbols and types, to assist in indirect-branch target inference. The lack of sourcelevel information brings extra challenges to inferring targets for indirect calls compared to other kinds of indirect branches. Points-to analysis could be a promising solution for this problem, but there is no practical points-to analysis framework for inferring indirect call targets at the binary level. Value set analysis (VSA) is the state-of-the-art binary-level points-to analysis but does not scale to large programs. It is also highly conservative by design and thus leads to low-precision CFG construction. In this paper, we present a binary-level points-to analysis framework called BPA to construct sound and high-precision CFGs. It is a new way of performing points-to analysis at the binary level with the focus on resolving indirect call targets. BPA employs several major techniques, including assuming a block memory model and a memory access analysis for partitioning memory into blocks, to achieve a better balance between scalability and precision. In evaluation, we demonstrate that BPA achieves a 34.5% precision improvement rate over the current state-of-theart technique without introducing false negatives.", "num_citations": "5\n", "authors": ["356"]}
{"title": "Program analysis of commodity IoT applications for security and privacy: Challenges and opportunities\n", "abstract": " Recent advances in Internet of Things (IoT) have enabled myriad domains such as smart homes, personal monitoring devices, and enhanced manufacturing. IoT is now pervasive---new applications are being used in nearly every conceivable environment, which leads to the adoption of device-based interaction and automation. However, IoT has also raised issues about the security and privacy of these digitally augmented spaces. Program analysis is crucial in identifying those issues, yet the application and scope of program analysis in IoT remains largely unexplored by the technical community. In this paper, we study privacy and security issues in IoT that require program-analysis techniques with an emphasis on identified attacks against these systems and defenses implemented so far. Based on a study of five IoT programming platforms, we identify the key insights that result from research efforts in both the\u00a0\u2026", "num_citations": "5\n", "authors": ["356"]}
{"title": "Redroid: Prioritizing data flows and sinks for app security transformation\n", "abstract": " Security transformation is to transfer applications to meet security guarantees. How to prioritize Android apps and find suitable transformation options is a challenging problem. Typical real-world apps have a large number of sensitive flows and sinks. Thus, security analysts need to prioritize these flows and data sinks according to their risks, ie, flow ranking and sink ranking. We present an efficient graph-algorithm based risk metric for prioritizing risky flows and sinks in Android grayware apps. Our risk prioritization produces orderings that are consistent with published security reports.", "num_citations": "5\n", "authors": ["356"]}
{"title": "Evaluation method of vehicle sound quality\n", "abstract": " The study of sound quality which is a newly developed research area has become a hot topic and become to attract increasing attention from academia and industries. The description of sound quality, the technique of subjective and objective evaluation, and the way of improving sound quality inside vehicle are outlined. Based on an extensive discussion over the sound quality issues, the progress in sound quality methodologies and evaluation method are reviewed, and the prospects of the future development are introduced and discussed.", "num_citations": "5\n", "authors": ["356"]}
{"title": "Mechanized metatheory for user-defined type extensions\n", "abstract": " Motivation Type systems are a natural discipline for ensuring that programs maintain certain runtime invariants. Of course, language designers cannot anticipate all the invariants that programmers will want to enforce. Therefore, it is desirable to allow programmers to specify and statically check invariants of interest for their applications.Researchers have designed expressive type systems that allow programmer-defined invariants to be directly encoded as types. However, there is a tradeoff between type-system expressiveness and ease of use for programmers. First, the more expressive the type system, the more annotation burden there is on the programmer. For example, expressive type systems often require programmers to manually discharge proof obligations to ensure that a program fragment meets its specified type. Second, the more expressive the type system, the more difficult it is for programmers to understand. In traditional type systems, each type has a relatively simple set of syntax-directed rules, which constitutes a programming discipline for programmers to obey. As type systems become more expressive, it becomes more difficult for programmers to understand what programming idioms can and cannot be typechecked and why. As a result, languages with expressive type systems may be challenging for programmers to use effectively.", "num_citations": "5\n", "authors": ["356"]}
{"title": "Research on the fluctuating characteristics of airflow in the naturally ventilated buildings\n", "abstract": " Natural ventilation\u2019s fluctuating airflow has impacts on the thermal comfort and VOCs transportation in the naturally ventilated buildings. Research about the fluctuating characteristics of the airflow in naturally ventilated buildings was carried on in this paper. A significant amount of data for airflow velocity of natural ventilation was recorded. Based on these simultaneously measured velocities of the indoor and outdoor airflow, the characteristic parameters, such as energy spectrum, turbulence intensity, and dimensional restructuring etc., of the airflow under naturally ventilated situation were analyzed. Not only the methods of statistical analysis but also the methods of turbulence theory, chaos theory and fractal theory were used to describe the structural characteristics of the fluctuating airflow of natural ventilation. The basic rules governing how the airflow fluctuating characteristics change when airflow goes through the building\u2019s openings or enters the building space were summarized in this paper.", "num_citations": "5\n", "authors": ["356"]}
{"title": "Braille translation based on multi-knowledge\n", "abstract": " The transformation from Braille to Mandarin Characters can be divided into two steps: from Braille to Pinyin and from Pinyin to Mandarin Characters. Incorporating the Legal Pinyin Table into our system the ambiguity problem was solved in the transformation from Braille to Pinyin. A standard statistical Bigram Markov model was used in the subsystem to transform Pinyin to Mandarin Characters. Then two modifications of the smoothing method which are consistent with the phrase-level Bigram model were proposed to overcome the sparse data problem in our system model. For each Pinyin sentence, a multi-level graph was used with the Viterbi algorithm to search for the best Mandarin sentence in the maximal likelihood. The measurement of N-best algorithm was studied to get N best Mandarin sentences. Experiments show that the correct rate of the system is 94. 38%. If proper nouns are not considered, our system can achieve a further 2% improvement. The accuracy rate for the top-5 hypothesis by using N-Best algorithm is 3% higher than that of the best hypothesis.", "num_citations": "5\n", "authors": ["356"]}
{"title": "Iotrepair: Systematically addressing device faults in commodity iot\n", "abstract": " IoT devices are decentralized and deployed in unstable environments, which causes them to be prone to various types of faults, such as power failure and network disruption. Yet, current IoT platforms require programmers to handle faults manually, a complex and error-prone task. In this paper, we present IoTRepair, a fault-handling system for IoT that (1) integrates with fault identification modules to track faulty devices, (2) provides a library of fault-handling functions for effectively handling different fault types, (3) provides a fault handler on top of the library for autonomous IoT fault handling, with deployed devices, user preferences, and developer configuration as input. Through an evaluation in a simulated lab environment, we find IoTRepair reduces the incorrect states on average 63.51%, which corresponds to less unsafe and insecure device states. Overall, through a systematic design of an IoT fault handler, we\u00a0\u2026", "num_citations": "4\n", "authors": ["356"]}
{"title": "SmartShell: Automated Shell Scripts Synthesis from Natural Language\n", "abstract": " Modern shell scripts provide interfaces with rich functionality for system administration. However, it is not easy for end-users to write correct shell scripts; misusing commands may cause unpredictable results. In this paper, we present SmartShell, an automated function-based tool for shell script synthesis, which uses natural language descriptions as input. It can help the computer system to \u201cunderstand\u201d users\u2019 intentions. SmartShell is based on two insights: (1) natural language descriptions for system objects (such as files and processes) and operations can be recognized by natural language processing tools; (2) system-administration tasks are often completed by short shell scripts that can be automatically synthesized from natural language descriptions. SmartShell synthesizes shell scripts in three steps: (1) using natural language processing tools to convert the description of a system-administration task into a\u00a0\u2026", "num_citations": "4\n", "authors": ["356"]}
{"title": "Assurance for defense in depth via retrofitting\n", "abstract": " The computer security community has long advocated defense in depth, the concept of building multiple layers of defense to protect a system. Unfortunately, it has been difficult to realize this vision in practice, and software often ships with inadequate defenses, typically developed in an ad hoc fashion. Currently, programmers reason about security manually and lack tools to validate assurance that security controls provide satisfactory defenses. In this position paper, we propose STRATA\u2014a holistic framework for defense in depth. We examine application of STRATA in the context of adding security controls to legacy code for authorization, containment, and auditing. The STRATA framework aims to support a combination of:(1) interactive techniques to develop retrofitting policies that describe the connection between program constructs and security policy and (2) automated techniques to produce optimal security controls that satisfy retrofitting policies. We show that by reasoning about defense in depth a variety of advantages can be obtained, including optimization, continuous improvement, and assurance across multiple security controls.", "num_citations": "4\n", "authors": ["356"]}
{"title": "JNI Light: An operational model for the core JNI\n", "abstract": " Through foreign function interfaces (FFIs), software components in different programming languages interact with each other in the same address space. Recent years have witnessed a number of systems that analyse FFIs for safety and reliability. However, lack of formal specifications of FFIs hampers progress in this endeavour. We present a formal operational model, Java Native Interface (JNI) light (JNIL), for a subset of a widely used FFI \u2013 the Java Native Interface (JNI). JNIL focuses on the core issues when a high-level garbage-collected language interacts with a low-level language. It proposes abstractions for handling a shared heap, cross-language method calls, cross-language exception handling, and garbage collection. JNIL can directly serve as a formal basis for JNI tools and systems. We demonstrate its utility by proving soundness of a system that checks native code in JNI programs for type-unsafe use\u00a0\u2026", "num_citations": "3\n", "authors": ["356"]}
{"title": "Features of Ring-opening Polymerization of# epsilon#-Caprolactone Initiated by La (Oar) _ (3)--Optimal Conditions Explored by Orthogonal Experimental Design\n", "abstract": " The ring-opening polymerization of# epsilon#-caprolactone (CL) with lanthanum tris (2, 6-di-tert-butyl-4-methylphenolate)[La (OAr) _ (3)] as the initiator was reported in this work. Orthogonal experimental design was used to find the optimal conditions of the polymerization. The optimal conditions of the two orthogonal experimental designs were found to be: t= 20\u2103, t= 50 min, c (CL)= 0.6 mol/L, n (CL)\u2236 n (La)= 1 000 and t= 30\u2103, t= 30 min, c (CL)= 0.7 mol/L, n (CL)\u2236 n (La)= 1 000, respectively. The crystallinity of PCL was above 50% measured by means of DSC, the melt temperature increased with the increase of the molecular weight, while the melt enthalpy (# DETAL# H_ (m)) and crystallinity decreased with the increase of the molecular weight.", "num_citations": "3\n", "authors": ["356"]}
{"title": "Prioritizing data flows and sinks for app security transformation\n", "abstract": " There have been extensive investigations on identifying sensitive data flows in Android apps for detecting malicious behaviors. Typical real world apps have a large number of sensitive flows and sinks. Thus, security analysts need to prioritize these flows and data sinks according to their risks, i.e., flow ranking and sink ranking. In this paper, we present an efficient graph-algorithm based risk metric for prioritizing risky flows and sinks in Android grayware apps. The new risk metric is quantitative and can differentiate the sensitivities of flows and sinks in an app. In the experiments, our risk prioritization produces orderings that are highly consistent with manual inspection. To enable post-detection security enforcement of sensitive sinks, we also present an automatic rewriting framework that utilizes the above prioritization technique. Our rewriting strategies are more feasible than the state-of-art solutions by supporting\u00a0\u2026", "num_citations": "2\n", "authors": ["356"]}
{"title": "IVT: an efficient method for sharing subtype polymorphic objects\n", "abstract": " Shared memory provides the fastest form of inter-process communication. Sharing polymorphic objects between different address spaces requires solving the issue of sharing pointers. In this paper, we propose a method, named Indexed Virtual Tables (IVT for short), to share polymorphic objects efficiently. On object construction, the virtual table pointers are replaced with indexes, which are used to find the actual virtual table pointers on dynamic dispatch. Only a few addition and load instructions are needed for both operations. Experimental results show that the IVT can outperform prior techniques on both object construction time and dynamic dispatch time. We also apply the proposed IVT technique to several practical scenarios, resulting the improvement of overall performance.", "num_citations": "2\n", "authors": ["356"]}
{"title": "CSCAC: one constant-size CPABE access control scheme in trusted execution environment\n", "abstract": " The popularity of versatile mobile devices has been increasing concerns about their security. How to protect the sensitive data is an urgent issue to be solved. Ciphertext-policy attribute-based encryption (CPABE) is a practical method for encrypting data and can utilise user's attributes to encrypt the sensitive data. In this paper, we propose a constant-size CPABE access control (CSCAC) model by using the Trusted Execution Environment to manage the dynamic key generated by attributes. The original data is encrypted by a symmetric storage key, then the storage key is encrypted under an AND-gate access policy. Only the user who possesses a set of attributes that satisfy the access policy can recover the storage key. The security analysis shows the design of this access control scheme reduces the burden and risk in the case of one single authority.", "num_citations": "2\n", "authors": ["356"]}
{"title": "Debugopt: Debugging fully optimized natively compiled programs using multistage instrumentation\n", "abstract": " The accuracy of debugging information is crucial for source level debugging. However the debugging information may be inaccurate after sophisticated optimizations if the target program is compiled into native code. Hence, the efficiency of diagnosing software is affected due to inaccurate debugging information.To address the issue, we propose Debugopt, a framework for debugging fully optimized natively compiled programs using multistage instrumentation. At compile time, Debugopt generates unoptimized programs with accurate debugging information and optimized programs. At debugging time, Debugopt dynamically replaces the execution of optimized programs with unoptimized programs. Debugopt is implemented on multiple architectures, including x86-32, x86-64, armv7 and mips3. Debugopt's overhead is small during normal execution on a large range of benchmarks.", "num_citations": "2\n", "authors": ["356"]}
{"title": "WebC: toward a portable framework for deploying legacy code in web browsers\n", "abstract": " For security, most web applications are developed in some type-safe language, such as JavaScriptor Java. However, there is a huge amount of legacy codes developed in unsafe languages, which provide richfunctionality and are more efficient than their type-safe counterparts. To allow browsers to incorporate type-safecomponents in a secure way, previous approaches use the software-based fault isolation (SFI) to isolate untrustedlegacy code. The SFI approach performs machine-code transformation for security, but the downside is the lossof architecture independence. We propose WebC, a system that allows legacy code transmitted over the web viathe Low Level Virtual Machine (LLVM) bitcode format. The untrusted bitcode is transformed by WebC intocode in the WebC security language, which enforces both memory isolation and control-flow integrity. Comparedwith previous approaches, WebC is\u00a0\u2026", "num_citations": "2\n", "authors": ["356"]}
{"title": "Weak updates and separation logic\n", "abstract": " Separation logic provides a simple but powerful technique for reasoning about low-level imperative programs that use shared data structures. Unfortunately, separation logic supports only \u201cstrong updates,\u201d in which mutation to a heap location is safe only if a unique reference is owned. This limits the applicability of separation logic when reasoning about the interaction between many high-level languages (e.g., ML, Java, C#) and low-level ones since the high-level languages do not support strong updates. Instead, they adopt the discipline of \u201cweak updates,\u201d in which there is a global \u201cheap type\u201d to enforce the invariant of type-preserving heap updates. We present SL                                            w                 , a logic that extends separation logic with reference types and elegantly reasons about the interaction between strong and weak updates. We describe a semantic framework for reference types, which is used\u00a0\u2026", "num_citations": "2\n", "authors": ["356"]}
{"title": "Maskless etching and server capacitance micro-accelerometer [J]\n", "abstract": " Processing deep-narrow groove is the key of sandwich micro-device process. With the maskless wet chemical etching, the cantilever rudiment and the mass were made, and the structure of sandwich micro-accelerometer was manufactured accurately. Two kinds of micro-accelerometer were successfully fabricated with\u00b170 g/\u00b15 g full-scale range. Initial testing showed: relative precision less than 1\u00d7 10\u20134, residual error 0.4 mg with\u00b15 g full-scale range, nonlinearity 0.02% and residual error 7 mg with\u00b170 g full-scale range.", "num_citations": "2\n", "authors": ["356"]}
{"title": "SpecSafe: detecting cache side channels in a speculative world\n", "abstract": " The high-profile Spectre attack and its variants have revealed that speculative execution may leave secret-dependent footprints in the cache, allowing an attacker to learn confidential data. However, existing static side-channel detectors either ignore speculative execution, leading to false negatives, or lack a precise cache model, leading to false positives. In this paper, somewhat surprisingly, we show that it is challenging to develop a speculation-aware static analysis with precise cache models: a combination of existing works does not necessarily catch all cache side channels. Motivated by this observation, we present a new semantic definition of security against cache-based side-channel attacks, called Speculative-Aware noninterference (SANI), which is applicable to a variety of attacks and cache models. We also develop SpecSafe to detect the violations of SANI. Unlike other speculation-aware symbolic\u00a0\u2026", "num_citations": "1\n", "authors": ["356"]}
{"title": "\u03c1FEM: Efficient Backward-edge Protection Using Reversed Forward-edge Mappings\n", "abstract": " In this paper, we propose reversed forward-edge mapper (\u03c1FEM), a Clang/LLVM compiler-based tool, to protect the backward edges of a program\u2019s control flow graph (CFG) against runtime control-flow hijacking (eg, code reuse attacks). It protects backward-edge transfers in C/C++ originating from virtual and non-virtual functions by first statically constructing a precise virtual table hierarchy, with which to form a precise forward-edge mapping between callees and non-virtual calltargets based on precise function signatures, and then checks each instrumented callee return against the previously computed set at runtime. We have evaluated \u03c1FEM using the Chrome browser, NodeJS, Nginx, Memcached, and the SPEC CPU2017 benchmark. Our results show that \u03c1FEM enforces less than 2.77 return targets per callee in geomean, even for applications heavily relying on backward edges. \u03c1FEM\u2019s runtime overhead is\u00a0\u2026", "num_citations": "1\n", "authors": ["356"]}
{"title": "Measuring Attack Surface Reduction in the Presence of Code (Re-) Randomization.\n", "abstract": " Just-in-time return-oriented programming (JITROP) technique allows one to dynamically discover instruction pages and launch code reuse attacks, effectively bypassing most fine-grained address space layout randomization (ASLR) protection. However, in-depth questions regarding the impact of code (re-) randomization on code reuse attacks have not been studied. For example, how do starting pointers in JITROP impact gadget availability?; how would one compute the rerandomization interval effectively to defeat JIT-ROP attacks? what impact do fine-grained randomization and re-randomization have on the Turing completeness of JIT-ROP payloads? We conduct a comprehensive measurement study on the effectiveness of finegrained code randomization and re-randomization, with 5 tools, 13 applications, and 19 dynamic libraries. We provide methodologies to measure JIT-ROP gadget availability, quality, and\u00a0\u2026", "num_citations": "1\n", "authors": ["356"]}
{"title": "Rapid Vulnerability Mitigation with Security Workarounds\n", "abstract": " The existence of pre-patch windows allows adversaries to exploit vulnerabilities before they are patched. Prior work has proposed to harden programs with security workarounds to enable users to mitigate vulnerabilities before a patch is available. However, it requires access to the source code of the programs. This paper introduces RVM, an approach to automatically hardening binary code with security workarounds. RVM statically analyzes binary code of programs to identify error-handling code in the programs, in order to synthesize security workarounds. We designed and implemented a prototype of RVM for Windows and Linux binaries. We evaluate the coverage and performance of RVM on binaries of popular Windows and Linux applications containing real-world vulnerabilities.", "num_citations": "1\n", "authors": ["356"]}
{"title": "Soteria: automated IoT safety and security analysis\n", "abstract": " Broadly defined as the Internet of Things (IoT), the growth of commodity devices that integrate physical processes with digital systems have changed the way we live, play and work. Yet existing IoT platforms cannot evaluate whether an IoT app or environment is safe, secure, and operates correctly. In this paper, we present Soteria, a static analysis system for validating whether an IoT app or IoT environment (collection of apps working in concert) adheres to identified safety, security, and functional properties. Soteria operates in three phases;(a) translation of platform-specific IoT source code into an intermediate representation (IR),(b) extracting a state model from the IR,(c) applying model checking to verify desired properties. We evaluate Soteria on 65 SmartThings market apps through 35 properties and find nine (14%) individual apps violate ten (29%) properties. Further, our study of combined app environments\u00a0\u2026", "num_citations": "1\n", "authors": ["356"]}
{"title": "Document analysis support for the manual auditing of elections\n", "abstract": " Recent developments have resulted in dramatic changes in the way elections are conducted, both in the United States and around the world. Well-publicized flaws in the security of electronic voting systems have led to a push for the use of verifiable paper records in the election process. In this paper, we describe the application of document analysis techniques to facilitate the manual auditing of elections,both to assure the reliability of the final outcome as well as to help reconcile the differences that may arise between repeated scans of the same ballot. We show how techniques developed for document duplicate detection can be applied to this problem, and present experimental results that demonstrate the efficacy of our approach. Related issues concerning machine support for the auditing of elections are also discussed.", "num_citations": "1\n", "authors": ["356"]}