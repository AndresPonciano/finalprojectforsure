{"title": "Oscar clusters\n", "abstract": " The Open Source Cluster Application Resources (OSCAR) is a cluster software stack providing a complete infrastructure for cluster computing. The OSCAR project started in April 2000 with its first public release a year later as a self-installing compilation of \u201cbest practices\u201d for high-performance classic Beowulf cluster computing. Since its inception approximately three years ago, OSCAR has matured to include cluster installation, maintenance, and operation capabilities and as a result has become one of the most popular cluster computing packages worldwide. In the past year, OSCAR has begun to expand into other cluster paradigms including Thin OSCAR, a diskless cluster solution, and High-", "num_citations": "46\n", "authors": ["723"]}
{"title": "Open Source Cluster Application Resources (OSCAR): design, implementation and interest for the [computer] scientific community\n", "abstract": " this article we will present a brief history of OSCAR, the actual components of OSCAR as well as the design and implementation proposal for OSCAR 2.1 and beyond", "num_citations": "45\n", "authors": ["723"]}
{"title": "Fine-grained preemption analysis for latency investigation across virtual machines\n", "abstract": " This paper studies the preemption between programs running in different virtual machines on the same computer. One of the current monitoring methods consist of updating the average steal time through collaboration with the hypervisor. However, the average is insufficient to diagnose abnormal latencies in time-sensitive applications. Moreover, the added latency is not directly visible from the virtual machine point of view. The main challenge is to recover the cause of preemption of a task running in a virtual machine, whether it is a task on the host computer or in another virtual machine. We propose a new method to study thread preemption crossing virtual machines boundaries using kernel tracing. The host computer and each monitored virtual machine are traced simultaneously. We developed an efficient and portable trace synchronization method, which is required to account for time offset and drift that occur\u00a0\u2026", "num_citations": "31\n", "authors": ["723"]}
{"title": "Recovering system metrics from kernel trace\n", "abstract": " Important Linux kernel subsystems are statically instrumented with tracepoints, which enables the gathering of detailed information about a running system, such as process scheduling, system calls and memory management. Each time a tracepoint is encountered, an event is generated and can be recorded to disk for offline analysis. Kernel tracing provides system-wide instrumentation that has low performance impact, suitable for tracing online systems in order to debug hard-to-reproduce errors or analyze the performance.Despite these benefits, a kernel trace may be difficult to analyze due to the large number of events. Moreover, trace events expose low-level behavior of the kernel that requires deep understanding of kernel internals to analyze. In many cases, the meaning of an event may depend on previous events. To get valuable information from a kernel trace, fast and reliable analysis tools are required.", "num_citations": "29\n", "authors": ["723"]}
{"title": "Wait analysis of distributed systems using kernel tracing\n", "abstract": " We propose a new class of profiler for distributed and heterogeneous systems. In these systems, a task may wait for the result of another task, either locally or remotely. Such wait dependencies are invisible to instruction profilers. We propose a host-based, precise method to recover recursively wait causes across machines, using blocking as the fundamental mechanism to detect changes in the control flow. It relies solely on operating system events, namely scheduling, interrupts and network events. It is therefore capable of observing kernel threads interactions and achieves user-space runtime independence. Given a task, the algorithm computes its active path from the trace, which is presented in an interactive viewer for inspection. We validated our new method with workloads representing major architecture and operating conditions found in distributed programs. We then used our method to analyze the\u00a0\u2026", "num_citations": "28\n", "authors": ["723"]}
{"title": "High performance tracing tools for multicore linux hard real-time systems\n", "abstract": " Real-time systems have always been more difficult to monitor and debug because of the real-time constraints which rule out any tool significantly impacting the system latency and performance. Tracing is often the most reliable tool available for studying real-time systems. In recent years, the real-time behavior of Linux systems has greatly improved and, with proper CPU shielding on multicore systems, it is now possible to have latencies in the low microsecond range. In that context, tracers must ensure that their overhead is within that range, predictable and scales well to multiple cores. The recently released LTTng 2.0 toolchain has been optimized for multicore performance, scalability and flexibility. We have studied its impact on the maximum latency for serving hard real-time applications in a multicore environment using CPU shielding. In order to achieve this, we used and extended the real time verification tools\u00a0\u2026", "num_citations": "11\n", "authors": ["723"]}
{"title": "Teaching operating systems concepts with execution visualization\n", "abstract": " Introduction to Operating System Concepts with Execution VisualizationWe present a new approach to introduce Operating Systems concepts to Computer Engineeringundergraduate students. These concepts are the basis on which students build a mental model ofthe whole computer in order to make important design decisions throughout their career. Onemajor challenge in teaching Operating Systems is the complexity, intangible andnondeterministic nature of an actual computer system containing many cores operating inparallel. We propose an holistic approach to address this challenge. Using a full open source operatingsystem, a carefully designed set of experiments and novel execution visualization tools, studentscan understand in depth the execution of their own computer and see the effect of running realprograms. A key benefit is to expose runtime delays like system calls, interrupts and scheduling, which leads to improved awareness of program performance implications. We think that using astandard workstation and making its behavior visible is a key factor to increase engagement ofstudents. We describe the five problem solving activities we developed and the purpose of eachtools used. We present outcomes following the first semester using this approach atPolytechnique Montreal.", "num_citations": "10\n", "authors": ["723"]}
{"title": "Analyse de performance de syst\u00e8mes distribu\u00e9s et h\u00e9t\u00e9rog\u00e8nes \u00e0 l'aide de tra\u00e7age noyau\n", "abstract": " Les syst\u00e8mes infonuagiques sont en utilisation croissante. La complexit\u00e9 de ces syst\u00e8mes provient du fait qu'ils s' ex\u00e9cutent de mani\u00e8re distribu\u00e9e sur des architectures multicoeurs. Cette composition de services est souvent h\u00e9t\u00e9rog\u00e8ne, c.-\u00e0-d. qui implique diff\u00e9rentes technologies, librairies et environnements de programmation. L'interop\u00e9rabilit\u00e9 est assur\u00e9e plut\u00f4t par l'utilisation de protocoles ouverts. L'espace de configuration r\u00e9sultant cro\u00eet de mani\u00e8re exponentielle avec le nombre de param\u00e8tres, et change continuellement en fonction des nouveaux besoins et de l'adaptation de la capacit\u00e9. Lorsqu'un probl\u00e8me de performance survient, il doit \u00eatre possible d'identifier rapidement la cause pour y rem\u00e9dier. Or, ce probl\u00e8me peut \u00eatre intermittent et difficile \u00e0 reproduire, et dont la cause peut \u00eatre une interaction transitoire entre des t\u00e2ches ou des ressources. Les outils utilis\u00e9s actuellement pour le diagnostic des probl\u00e8mes de performance comprennent les m\u00e9triques d'utilisation des ressources, les outils de profilage, la surveillance du r\u00e9seau, des outils de tra\u00e7age, des d\u00e9bogueurs interactifs et les journaux syst\u00e8mes. Or, chaque composant doit \u00eatre analys\u00e9 s\u00e9par\u00e9ment, ou l'utilisateur doit corr\u00e9ler manuellement cette information pour tenter de d\u00e9duire la cause du probl\u00e8me. L'observation globale de l'ex\u00e9cution de syst\u00e8mes distribu\u00e9s est un enjeu majeur pour en maitriser la complexit\u00e9 et r\u00e9gler les probl\u00e8mes efficacement. L'objectif principal de cette recherche est d'obtenir un outil d'analyse permettant de comprendre la performance d'ensemble d'une application distribu\u00e9e. Ce type d'analyse existe au niveau applicatif, mais elles sont sp\u00e9cifiques \u00e0\u00a0\u2026", "num_citations": "1\n", "authors": ["723"]}
{"title": "MILLE-XTERM and LTSP\n", "abstract": " If you thought Network Computing was dead, wait until you read this.", "num_citations": "1\n", "authors": ["723"]}
{"title": "Root raid in ram how to\n", "abstract": " L\u2019Universit\u00e9 de Sherbrooke est impliqu\u00e9e dans le d\u00e9veloppement et le support de grappes dont les noeuds de calcul ne possedent pas de disque rigide (grappe sans disques). Ce type de grappe utilise un systeme d\u2019exploitation Linux standard avec un systeme de fichiers minimal r\u00e9sidant en m\u00e9moire vive. Nous telechargeons ce systeme via diff\u00e9rents protocoles de communication (Trivial File Transfer Protocol (TFTP), Network File System (NFS), ssh,...), afin d\u2019assurera chaque noeud de calcul une plus grande autonomie en cas de panne r\u00e9seau ou d\u2019inaccessibilit\u00e9 du serveur ma\u0131tre. Afin d\u2019assurer la compatibilit\u00e9 avec diff\u00e9rents noyaux Linux standards, nous utilisons la capacit\u00e9 du noyau Linuxa g\u00e9rer les r\u00e9seaux redondants de disques ind\u00e9pendants (RAID, Redundant Array of Independant Disks) pour monter un r\u00e9seau RAID-0 de disques virtuels en m\u00e9moire vive, afin d\u2019y installer le systeme d\u2019op\u00e9ration. Nous\u00a0\u2026", "num_citations": "1\n", "authors": ["723"]}