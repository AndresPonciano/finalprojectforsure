{"title": "Detection of diverse design pattern variants\n", "abstract": " We propose a method for automatic detection of occurrences of design patterns. We also describe its proof-of-concept implementation and the results of comparative experiments with other tools. The method presented here is able to detect many nonstandard implementation variants of design patterns, while its efficiency is comparable to other state-of-the-art detection tools. Moreover, the method is highly customizable because an analyst can introduce a new pattern retrieval query or modify an existing one and then repeat the detection using the results of earlier source code analysis stored in a relational database.", "num_citations": "48\n", "authors": ["1919"]}
{"title": "Implementation variants of the singleton design pattern\n", "abstract": " We present a study of different implementation variants of the Singleton pattern and propose an intuitive definition of this pattern expressed as a first-order logic formula. We also show that our method for automatically detecting design patterns can be used to detect instances of the Singleton with respect to this definition. We also provide data on experiments with a proof-of-concept implementation of this detection method. These experiments prove the efficiency and high accuracy of the method, which is able to detect many non-standard variants of the Singleton in real source code.", "num_citations": "26\n", "authors": ["1919"]}
{"title": "Performance antipatterns of one to many association in hibernate\n", "abstract": " Hibernate is the most popular ORM framework for Java. It is a straightforward and easy-to-use implementation of Java Persistence API. However, its simplicity of usage often becomes mischievous to developers and leads to serious performance issues in Hibernate-based applications. This paper presents five performance antipatterns related to the usage of one-to-many associations in Hibernate. These antipatterns focus on the problems of the owning side of collections, the Java types and annotations used in mappings, as well as processing of collections. Each antipattern consists of the description of a problem along with a sample code, negative performance consequences, and the recommended solution. Performance is analyzed in terms of the number and complexity of issued database statement. The code samples illustrate how the antipatterns decrease performance and how to implement the mappings to\u00a0\u2026", "num_citations": "10\n", "authors": ["1919"]}
{"title": "Relaxing queries to detect variants of design patterns\n", "abstract": " Design patterns codify general solutions to frequently encountered design problems. They also facilitate writing robust and readable code. Their usage happens to be particularly profitable if the documentation of the resulting system is lost, inaccurate or out of date. In reverse engineering, detection of instances of design patterns is extremely helpful as it aids grasping high level design ideas. However, the actual instances of design patterns can diverge from their canonical textbook templates. Useful pattern detection tools should thus be able to identify not only orthodox implementations but also their disparate variants. In this paper, we present a method to generate queries to detect canonical instances of design patters. We formulate these queries so that they are language-agnostic. They precisely reflect the intents of the canonical implementations of design patterns. However, they abstract from any peculiarities of\u00a0\u2026", "num_citations": "9\n", "authors": ["1919"]}
{"title": "Towards a comprehensive test suite for detectors of design patterns\n", "abstract": " Detection of design patterns is an important part of reverse engineering. Availability of patterns provides for a better understanding of code and also makes analysis more efficient in terms of time and cost. In recent years, we have observed a continual improvement in the field of automatic detection of design patterns in source code. Existing approaches can detect a fairly broad range of design patterns, targeting both structural and behavioral aspects of patterns. However, it is not straightforward to assess and compare these approaches. There is no common ground on which to evaluate the accuracy of the detection approaches, given the existence of variants and specific code constructs used to implement a design pattern. We propose a systematic approach to constructing a comprehensive test suite for detectors of design patterns. This approach is applied to construct a test suite covering the Singleton pattern. The\u00a0\u2026", "num_citations": "7\n", "authors": ["1919"]}
{"title": "The good, the bad, and the ugly: three ways to use a semantic code query system\n", "abstract": " D-CUBED is a semantic code query system for Java. Its focus is on capturing the semantics of an analyzed program. It provides rich support to investigate the call flow and data flow of a program by using static analysis techniques with the custom model of symbolic instances. The usage scenarios of D-CUBED include:(1) detection of design patterns with the focus on code semantics (the good),(2) discovery of bugs, including a range of security holes (the bad),(3) assessment and improvement of a design by discovering bad design and code practices (the ugly).", "num_citations": "3\n", "authors": ["1919"]}
{"title": "Visitor Pattern Revisited for Recognition.\n", "abstract": " Detection of design patterns is an important part of the reverse engineering process since it helps in more effective analysis of complex systems. In this paper we approach the Visitor design pattern. We propose a robust methodology of finding instances of the Visitor pattern in object oriented code. The method consists in examining source code in order to find basic structural and behavioural relations among program elements. The identified relations are stored in a relational database and then queried simply by SQL in order to find candidate participants of Visitor instances. We have also analysed the definition of the Visitor pattern to find its core properties. Design patterns have their canonical forms, but many instances of them can diverge from the canonical form. We tried to relax the original definition of the Visitor pattern, so that also apparent non-canonical instances of this pattern can be found. This paper contains experimental data which show that our method is efficient and is able to detect non-canonical examples of the Visitor pattern.", "num_citations": "1\n", "authors": ["1919"]}