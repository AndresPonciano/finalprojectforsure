{"title": "Framework specialization aspects\n", "abstract": " Object-oriented frameworks play an important role in different kinds of software, such as product-lines, middleware, GUI components, IDEs, etc. Over the past recent years, fundamentals of framework design stabilized around the adoption of design patterns. However, major difficulties concerning framework learning and usage are still evident, and constitute a burden for those who have to deal with it. This paper proposes an approach that aims to facilitate framework usage, based on the concept of specialization aspect. We show how framework hot-spots can be modularized in terms of specialization aspects, and how these can give support for specializing a framework in a step-wise way. The approach is conservative, in the sense that specialization aspects can be developed for an existing framework\" as is\". In order to support these claims, a case study has been carried out by applying the technique on the\u00a0\u2026", "num_citations": "40\n", "authors": ["2166"]}
{"title": "A model-driven approach to variability management in product-line engineering\n", "abstract": " Object-oriented frameworks play an essential role in the implementation of product-line architectures (PLAs) for product families. However, recent case studies reveal that deriving products from the shared software assets of a product-line is a timeconsuming and expensive activity. In this paper, we present a model-driven approach for product derivation in framework-based product-lines. This approach aims to alleviate the aforementioned problems by bridging the gap between domain and application engineering activities in product-line-based development. Our approach is centered on a layered model embracing different artifacts ranging from models for conceptual and architectural variability to models for the realization of variation points. The approach provides mechanisms for enforcing the variation rules throughout the product derivation process and for documenting the variability issues in frameworks and the derived applications. We demonstrate the approach using an existing Java GUI framework.", "num_citations": "39\n", "authors": ["2166"]}
{"title": "Managing duplicates in a web archive\n", "abstract": " Crawlers harvest the web by iteratively downloading documents referenced by URLs. It is frequent to find different URLs that refer to the same document, leading crawlers to download duplicates. Hence, web archives built through incremental crawls waste space storing these documents. In this paper, we study the existence of duplicates within a web archive and discuss strategies to eliminate them at storage level during the crawl. We present a storage system architecture that addresses the requirements of web archives and detail its implementation and evaluation. The system is now supporting an archive for the Portuguese web replacing previous NFS-based storage servers. Experimental results showed that the elimination of duplicates can improve storage throughput. The web storage system outperformed NFS based storage by 68% in read operations and by 50% in write operations. 1", "num_citations": "38\n", "authors": ["2166"]}
{"title": "Automating the construction of domain-specific modeling languages for object-oriented frameworks\n", "abstract": " The extension of frameworks with domain-specific modeling languages (DSML) has proved to be an effective way of improving the productivity in software product-line engineering. However, developing and evolving a DSML is typically a difficult and time-consuming task because it requires to develop and maintain a code generator, which transforms application models into framework-based code. In this paper, we propose a new approach for extending object-oriented frameworks that aims to alleviate this problem. The approach is based on developing an additional aspect-oriented layer that encodes a DSML for building framework-based applications, eliminating the need of implementing a code generator. We further show how a language workbench is capable of automating the construction of DSMLs using the proposed layer.", "num_citations": "19\n", "authors": ["2166"]}
{"title": "Automated domain-specific modeling languages for generating framework-based applications\n", "abstract": " The adoption of Domain-Specific Modeling Languages (DSMLs) for generating framework-based applications has proved to be an effective way of enforcing the correct use of frameworks and improve the productivity of application developers. However, the development of the code generator of a DSML is typically a laborious task with difficulties in what concerns complexity, understandability, and maintainability. In this paper, we address this problem with a new approach for developing DSMLs for frameworks that allows to eliminate the need of implementing code generators. The approach relies on the extension of frameworks with an additional layer based on aspect-oriented programming that encodes a DSML. By means of a generic language workbench, framework-based applications can be generated from application models described in that DSML. The proposed language workbench was implemented in a\u00a0\u2026", "num_citations": "16\n", "authors": ["2166"]}
{"title": "Design annotations to improve API discoverability\n", "abstract": " User studies have revealed that programmers face several obstacles when learning application programming interfaces (APIs). A considerable part of such difficulties relate to discovery of API elements and the relationships among them. To address discoverability problems, we show how to complement APIs with design annotations, which document design decisions in a program-processable form for types, methods, and parameters. The information provided by the annotations is consumed by the integrated development environment (IDE) in order to assist API users with useful code completion proposals regarding object creation and manipulation, which facilitate API exploration and learning. As a proof of concept, we developed Dacite, a tool which comprises a set of Java annotations and an accompanying plugin for the Eclipse IDE. A user study revealed that Dacite is usable and effective, and Dacite\u2019s\u00a0\u2026", "num_citations": "14\n", "authors": ["2166"]}
{"title": "Novel interaction metaphors for object-oriented programming concepts\n", "abstract": " Despite the fact that pedagogical programming environments have been available for several years, some fundamental concepts of object-oriented programming and design, such as encapsulation, interfaces, polymorphism, and inheritance, are not addressed by existing tools to a full extent. This paper presents novel interaction metaphors embodied in tool support that, as opposed to existing tools, makes possible to illustrate such object-oriented programming concepts with first-class representations. A tool referred to as AguiaJ, which is being used at our institution for the past three years, embodies novel interaction metaphors for addressing the aforementioned concepts in a gradual and comprehensive way. We explain the innovative tool features using a running example involving the domain of image manipulation.", "num_citations": "13\n", "authors": ["2166"]}
{"title": "AGUIA/J: a tool for interactive experimentation of objects\n", "abstract": " Learning and teaching object-oriented programming are still perceived as being difficult tasks. This paper presents AGUIA/J, a pedagogical tool for interactive experimentation and visualization of object-oriented Java programs. The approach is based on having a graphical environment for experimenting a set of user-developed classes where objects of such classes can be created and controlled interactively. The main innovative aspects of the tool comprise the visualization of objects in widgets that take different forms according to their classes and state, a mechanism to address the query-command separation principle, and the capability of runtime adaptation of the objects in the workbench to new versions of their classes. An experiment using AGUIA/J as courseware in pilot lab classes has resulted in higher approval rates for the involved students, as well as significantly lower drop-out rates.", "num_citations": "13\n", "authors": ["2166"]}
{"title": "An open-ended environment for teaching Java in context\n", "abstract": " Teaching programming in context, ie having students learning how to program by manipulating artifacts of a familiar domain (eg images, card games), has demonstrated convincing results in terms of raising student retention and interest in CS. This paper presents a pedagogical environment for teaching Java in context that is extensible with respect to the domains it supports. Instructors model domains and develop visualization widgets for rendering their objects. In turn, students use the environment to visualize and manipulate objects of the domain when solving exercises. The advantage and originality of the proposed environment is that it embodies an open-ended platform for creating diverse contexts at a low cost, standing as an enabler for widening the spectrum of abstractions for programming in context.", "num_citations": "11\n", "authors": ["2166"]}
{"title": "Stepwise API usage assistance using n-gram language models\n", "abstract": " Reusing software involves learning third-party APIs, a process that is often time-consuming and error-prone. Recommendation systems for API usage assistance based on statistical models built from source code corpora are capable of assisting API users through code completion mechanisms in IDEs. A valid sequence of API calls involving different types may be regarded as a well-formed sentence of tokens from the API vocabulary. In this article we describe an approach for recommending subsequent tokens to complete API sentences using n-gram language models built from source code corpora. The provided system was integrated in the code completion facilities of the Eclipse IDE, providing contextualized completion proposals for Java taking into account the nearest lines of code. The approach was evaluated against existing client code of four widely used APIs, revealing that in more than 90% of the cases\u00a0\u2026", "num_citations": "9\n", "authors": ["2166"]}
{"title": "Modular Hot Spots: A Pattern Language for Developing High-Level Framework Reuse Interfaces using Aspects.\n", "abstract": " Applications based on an object-oriented framework can be built by programming against the framework\u2019s reuse interface. Mastering a framework is typically a time-consuming and difficult task. This paper presents a pattern language for developing higher level reuse interfaces for an existing framework. When applying the patterns that constitute the language it is implied that the framework becomes enhanced with an additional layer of reusable modules that rely on aspect-oriented programming. These modules are referred to as Modular Hot Spots. They modularize existing hot spots, enabling a framework-based application to be built in a stepwise way and at a higher abstraction level than if using the conventional reuse interface. By raising the abstraction level, it is intended that the development of framework-based applications becomes facilitated.Proceedings of the 13th European Conference on Pattern Languages of Programs (EuroPLoP 2008), edited by Till Schmmer and Allan Kelly, ISSN 1613-0073< issn-1613-0073. html>. Copyright cO2009 for the individual papers by the papers\u2019 authors. Copying permitted for private and academic purposes. Re-publication of material from this volume requires permission by the copyright owners.", "num_citations": "8\n", "authors": ["2166"]}
{"title": "Modularizing framework hot-spots using aspects\n", "abstract": " Frameworks are software systems implementing the shared structure and functionality for a family of applications. We propose that the extension points, also known as hot spots, of a framework to be expressed as a set of aspects, creating thus an aspect-oriented wrapper for an object-oriented framework. The benefits of this approach include improved modularity, implying better configurability of application features and stronger reuse of framework code. We illustrate the approach using a popular graphical Java framework, JHotDraw.", "num_citations": "8\n", "authors": ["2166"]}
{"title": "Design profiles: toward unified tool support for design patterns and UML profiles\n", "abstract": " In the current trend of software engineering, patterns and profiles lend themselves as two powerful complementary mechanisms for documenting and enforcing design rules. In this paper, we study how unified tool support can be achieved for patterns and profiles by interpreting them as role\u2010based structural descriptions and exploiting existing tool support for role modeling. The approach is realized using so\u2010called design profiles, which allow both validation and generation of models according to rules expressed in the patterns and profiles. A prototypical tool environment supporting the approach has been developed. The practical applicability of the approach is demonstrated by specifying design rules of the enterprise Java beans (EJB) platform and by producing an environment for designing EJB\u2010based applications. We also discuss possible usage scenarios in the context of this case study. Copyright \u00a9 2008\u00a0\u2026", "num_citations": "6\n", "authors": ["2166"]}
{"title": "Collaborative course project for practicing component-based software engineering\n", "abstract": " Empirical studies revealed that computer science and engineering students have difficulty in mastering concepts such as interfaces and information hiding. These concepts are central to component-based software engineering (CBSE), a challenging subject to address in a university course, given that some degree of software development complexity is necessary for effectively practicing it. This paper describes an experiment carried in an advanced programming course offered at our institution, consisting of having a collaborative course project targeting the practice of CBSE. In this collaborative project, different student teams developed parts of an IDE whose designs were tested by other teams in terms of component interoperability and extensibility. Although students were able to practice the CBSE-related concepts in approximate real settings, the necessary technical supervision from instructors might consist of a\u00a0\u2026", "num_citations": "5\n", "authors": ["2166"]}
{"title": "GUI-driven code tracing\n", "abstract": " A significant part of a developer's activity is spent on maintenance tasks, which might involve dealing with unfamiliar code. Especially in these cases, a maintenance task is likely to imply a considerable amount of time locating the relevant source code that needs to be changed. This paper proposes a navigation mechanism for tracing UI elements of a running program to their representation in the source code. The technique relies on instrumenting the program in order to enable navigation from UI elements to locations in the source code. We have developed a prototype implementing the proposed mechanism and performed a user study where programmers were asked to perform maintenance tasks on programs of different sizes. We observed that the proposed mechanism enables fast code location, and that the time spent to accomplish similar tasks does not change significantly as program size increases.", "num_citations": "5\n", "authors": ["2166"]}
{"title": "An exploratory study of how programming instructors illustrate variables and control flow\n", "abstract": " We present an exploratory study that investigated how programming instructors illustrate program execution, namely variable manipulation and control flow. The study involved tasks where instructors were asked to doodle illustrations of program execution in a sheet of paper for given Java methods with example input/output. We found eight illustration patterns, some of which relate to specific variable roles (Gatherer, Stepper for array indexing, Most Wanted Holder). By analyzing existing pedagogical animation and debugging tools, we conclude that their visualizations do not have a broad representation of the aspects evidenced by the illustration patterns of instructors, hinting that human illustrations tend to be considerably richer.", "num_citations": "4\n", "authors": ["2166"]}
{"title": "GUI code tracing through direct program interaction\n", "abstract": " A significant part of a developer's activity is spent on maintenance tasks, which might involve dealing with unfamiliar code. Especially in these cases, a maintenance task is likely to imply a considerable amount of time locating the relevant source code that needs to be changed, a problem often referred to as feature location. This paper proposes a navigation mechanism for tracing user interface elements of a running program to their representation in the source code. The mechanism realization relies on instrumenting the program in order to enable navigation from user interface elements to locations in the source code. We developed a prototype implementation of the proposed mechanism that implies an acceptable instrumentation overhead, suitable for being used on industrial\u2010scale programs. We performed a user study and observed that the proposed mechanism enables fast code location and that the time\u00a0\u2026", "num_citations": "4\n", "authors": ["2166"]}
{"title": "Automatic support for model-driven specialization of object-oriented frameworks\n", "abstract": " An appealing strategy for supporting specialization of an object-oriented framework is to adopt a domain-specific modeling approach, where a domain metamodel and a code generator are manually developed to support model-driven framework specialization. Our research advocates that this support can be automated by having an additional specialization layer in the framework.", "num_citations": "3\n", "authors": ["2166"]}
{"title": "Xdiagram: a declarative textual DSL for describing diagram editors (tool demo)\n", "abstract": " When compared to the realm of textual syntax, developing graphical syntax for a domain-specific modeling language (DSML) is still challenging. Xdiagram is a research prototype that consists of a textual domain-specific language (DSL) for specifying diagrammatic representations against abstract syntax defined in the Eclipse Modeling Framework (EMF). Specifications are written in Xdiagram against such models in a declarative fashion in order to obtain a diagram editor. We explain the main primitives of our DSL using conceptual modeling as an example domain for illustration.", "num_citations": "2\n", "authors": ["2166"]}
{"title": "VISCTE: Runtime Exploration of Component-Based Systems\n", "abstract": " Component-based systems are often comprised of a large number of components, as well as services for binding them together. Static visualization of component dependencies suffers from scalability issues, due to the high number of nodes and edges, despite the fact that there have been previous approaches to mitigate this problem through diagram cluttering reduction mechanisms. Another limitation of static visualization is the inability to represent bindings that are dynamically determined at runtime. In this paper, we describe VISCTE, a tool for exploring component collaborations through runtime monitoring. We target concept location at the component level, where a user-controlled recording process enables developers to obtain diagrams that depict a partial representation of the system. We materialized the approach for OSGi-based component systems and successfully experimented it with an industrial-scale\u00a0\u2026", "num_citations": "2\n", "authors": ["2166"]}
{"title": "Concern-based learning of complex software platforms\n", "abstract": " Learning complex software platforms is a challenging task. This paper studies the problem of platform learning from the viewpoint of multidimensional separation of concerns in software systems. In this approach, concerns are used to identify and specify the kinds of learning tasks and interactions that should be supported by a learning environment for software platforms. The approach has been applied to build a concern-based learning environment for a Nokia GUI platform. A generic concern management tool has been used to build the r environment.", "num_citations": "2\n", "authors": ["2166"]}
{"title": "Enhancing Visualizations in Pedagogical Debuggers by Leveraging on Code Analysis\n", "abstract": " PandionJ is a pedagogical debugger that provides users with rich visualizations of program state that resemble teacher-drawn illustrations. Its design was driven by a study that investigated how programming teachers illustrate variables, transposing illustration patterns into the tool. These illustrations require static analysis of the source code to infer relationships between variables. We describe the innovative features of the tool regarding how it addresses program variables. The tool was adopted in an introductory programming course, and the pass rates of the first course edition using it were significantly higher when compared to the three previous editions.", "num_citations": "1\n", "authors": ["2166"]}
{"title": "PandionJ: a pedagogical debugger featuring illustrations of variable tracing and look-ahead\n", "abstract": " We present PandionJ, a pedagogical debugger for Java with innovative features regarding how the program state information is presented to users. We consider aspects that are either not available or not fully automated in existing debuggers (pedagogical or not), such as illustration of the history of variable values and look-ahead of their future state. Our approach relies on static analysis of code in order to infer variable roles, relationships, and behavior. This information is used to render illustrations of program state that existing debuggers are not capable of providing without requiring additional user input.", "num_citations": "1\n", "authors": ["2166"]}
{"title": "Developing contexts for teaching Java using AGUIA/J\n", "abstract": " Teaching programming in context, ie having exercises dealing with artifacts of a familiar domain (eg images, card games), has demonstrated convincing results in terms of raising student retention and interest in CS. This session addresses the development of contexts for Java by means of AGUIA/J plugins.", "num_citations": "1\n", "authors": ["2166"]}
{"title": "Aspects as specialization units for framework-based SPLs\n", "abstract": " A popular technique to implement software product-lines is through object-oriented application frameworks. A major problem with application frameworks is the unstructured, cross-cutting character of their specialization interfaces, and the weak connections between the specialization goals of the application developer and the different parts of the specialization interface. In this position paper, we propose an approach for supporting the specialization of object-oriented frameworks, consisting in representing the variability and the specializations using aspects. In addition to the framework classes, abstract aspects are provided as framework hot spots. Specialization units are implemented by concrete aspects which extend those hot spots. The proposed method can be used to create a modular specialization interface for an existing object-oriented framework in a non-intrusive way. An illustrative example is presented and the potential advantages of the proposed approach are discussed.", "num_citations": "1\n", "authors": ["2166"]}