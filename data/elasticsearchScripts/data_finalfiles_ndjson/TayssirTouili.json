{"title": "Pushdown model checking for malware detection\n", "abstract": " The number of malware is growing extraordinarily fast. Therefore, it is important to have efficient malware detectors. Malware writers try to obfuscate their code by different techniques. Many well-known obfuscation techniques rely on operations on the stack such as inserting dead code by adding useless push and pop instructions, or hiding calls to the operating system, etc. Thus, it is important for malware detectors to be able to deal with the program\u2019s stack. In this study, we propose a new model-checking approach for malware detection that takes into account the behavior of the stack. Our approach consists in: (1) Modeling the program using a pushdown system (PDS). (2) Introducing a new logic, called stack computation tree predicate logic (SCTPL), to represent the malicious behavior. SCTPL can be seen as an extension of the branching-time temporal logic CTL with variables, quantifiers, and predicates\u00a0\u2026", "num_citations": "85\n", "authors": ["691"]}
{"title": "Efficient malware detection using model-checking\n", "abstract": " Over the past decade, malware costs more than $10 billion every year and the cost is still increasing. Classical signature-based and emulation-based methods are becoming insufficient, since malware writers can easily obfuscate existing malware such that new variants cannot be detected by these methods. Thus, it is important to have more robust techniques for malware detection. In our previous work [24], we proposed to use model-checking to identify malware. We used pushdown systems (PDSs) to model the program (this allows to keep track of the program\u2019s stack behavior), and we defined the SCTPL logic to specify the malicious behaviors, where SCTPL can be seen as an extension of the branching-time temporal logic CTL with variables, quantifiers, and predicates over the stack. Malware detection was then reduced to SCTPL model-checking of PDSs. However, in our previous work [24], the way we\u00a0\u2026", "num_citations": "82\n", "authors": ["691"]}
{"title": "Regular model checking using widening techniques\n", "abstract": " In this paper, we consider symbolic model checking of safety properties of linear parametrized systems. Sets of configurations are represented by regular languages and actions by regular relations. Since the verification problem amounts to the computation of the reachability set, we focus on the computation of R\u2217(\u03c6) for a regular relation R and a regular language \u03c6. We present a technique called regular widening that allows, when it terminates, the computation of either the reachability set R\u2217(\u03c6) of a system or the transitive closure R\u2217 of a regular relation. We show that our method can be uniformly applied to several parametrized systems. Furthermore, we show that it is powerful enough to simulate some existing methods that compute either R\u2217 or R\u2217(\u03c6) for each R (resp. \u03c6) belonging to a subclass of regular relations (resp. belonging to a subclass of regular languages).", "num_citations": "81\n", "authors": ["691"]}
{"title": "Extrapolating tree transformations\n", "abstract": " We consider the framework of regular tree model checking where sets of configurations of a system are represented by regular tree languages and its dynamics is modeled by a term rewriting system (or a regular tree transducer). We focus on the computation of the reachability set R* (L) where R is a regular tree transducer and L is a regular tree language. The construction of this set is not possible in general. Therefore, we present a general acceleration technique, called regular tree widening which allows to speed up the convergence of iterative fixpoint computations in regular tree model checking. This technique can be applied uniformly to various kinds of transformations.               We show the application of our framework to different analysis contexts: verification of parametrized tree networks and data-flow analysis of multithreaded programs. Parametrized networks are modeled by relabeling tree\u00a0\u2026", "num_citations": "76\n", "authors": ["691"]}
{"title": "Antichain-based universality and inclusion testing over nondeterministic finite tree automata\n", "abstract": " We propose new antichain-based algorithms for checking universality and inclusion of nondeterministic tree automata (NTA). We have implemented these algorithms in a prototype tool and our experiments show that they provide a significant improvement over the traditional determinisation-based approaches. We use our antichain-based inclusion checking algorithm to build an abstract regular tree model checking framework based entirely on NTA. We show the significantly improved efficiency of this framework through a series of experiments with verifying various programs over dynamic linked tree-shaped data structures.", "num_citations": "57\n", "authors": ["691"]}
{"title": "Reachability analysis of process rewrite systems\n", "abstract": " Process Rewrite Systems (PRS for short) subsume many common (infinite-state) models such as pushdown systems and Petri nets. They can be adopted as formal models of parallel programs (multithreaded programs) with procedure calls. We develop automata techniques allowing to build finite representations of the forward/backward sets of reachable configurations of PRSs modulo various term structural equivalences (corresponding to properties of the operators of sequential composition and parallel composition). We show that, in several cases, these reachability sets can be represented by polynomial size finite bottom-up tree-automata. When associativity and commutativity of the parallel composition is taken into account, nonregular representations based on (a decidable class of) counter tree automata are sometimes needed.", "num_citations": "54\n", "authors": ["691"]}
{"title": "On the reachability analysis of acyclic networks of pushdown systems\n", "abstract": " We address the reachability problem in acyclic networks of pushdown systems. We consider communication based either on shared memory or on message passing through unbounded lossy channels. We prove mainly that the reachability problem between recognizable sets of configurations (i.e., definable by a finite union of products of finite-state automata) is decidable for such networks, and that for lossy channel pushdown networks, the channel language is effectively recognizable. This fact holds although the set of reachable configurations (including stack contents) for a network of depth (at least) 2 is not rational in general (i.e., not definable by a multi-tape finite automaton). Moreover, we prove that for a network of depth 1, the reachability set is rational and effectively constructible (under an additional condition on the topology for lossy channel networks).", "num_citations": "51\n", "authors": ["691"]}
{"title": "On computing reachability sets of process rewrite systems\n", "abstract": " We consider the problem of symbolic reachability analysis of a class of term rewrite systems called Process Rewrite Systems (PRS). A PRS can be seen as the union of two mutually interdependent sets of term rewrite rules: a prefix rewrite system (or, equivalently, a pushdown system), and a multiset rewrite system (or, equivalently, a Petri net). These systems are natural models for multithreaded programs with dynamic creation of concurrent processes and recursive procedure calls. We propose a generic framework based on tree automata allowing to combine (finite-state automata based) procedures for the reachability analysis of pushdown systems with (linear arithmetics/semilinear sets based) procedures for the analysis of Petri nets in order to analyze PRS models. We provide a construction which is parametrized by such procedures and we show that it can be instantiated to (1) derive procedures for\u00a0\u2026", "num_citations": "51\n", "authors": ["691"]}
{"title": "Model-checking for android malware detection\n", "abstract": " The popularity of Android devices results in a significant increase of Android malwares. These malwares commonly steal users\u2019 private data or do malicious tasks. Therefore, it is important to efficiently and automatically analyze Android applications and identify their malicious behaviors. This paper introduces an automatic and scalable approach to analyze Android applications and identify malicious applications. Our approach consists of modeling an Android application as a PushDown System (PDS), succinctly specifying malicious behaviors in Computation Tree Logic (CTL) or Linear Temporal Logic (LTL), and reducing the Android malware detection problem to CTL/LTL model-checking for PDSs. We implemented our techniques in a tool and applied it to analyze more than 1260 android applications. We obtained encouraging results. In particular, we discovered ten programs known as benign that are\u00a0\u2026", "num_citations": "35\n", "authors": ["691"]}
{"title": "Efficient CTL model-checking for pushdown systems\n", "abstract": " Pushdown systems (PDS) are well adapted to model sequential programs with (possibly recursive) procedure calls. Therefore, it is important to have efficient model checking algorithms for PDSs. We consider in this paper CTL model checking for PDSs. We consider the \u201cstandard\u201d CTL model checking problem where whether a configuration of a PDS satisfies an atomic proposition or not depends only on the control state of the configuration. We consider also CTL model checking with regular valuations, where the set of configurations in which an atomic proposition holds is a regular language. We reduce these problems to the emptiness problem in Alternating B\u00fcchi Pushdown Systems, and we give an algorithm to solve this emptiness problem. Our algorithms are more efficient than the other existing algorithms for CTL model checking for PDSs in the literature. We implemented our techniques in a tool, and we\u00a0\u2026", "num_citations": "34\n", "authors": ["691"]}
{"title": "PoMMaDe: pushdown model-checking for malware detection\n", "abstract": " We present PoMMaDe, a Pushd own Model-checking based M alware D etector. In PoMMaDe, a binary program is modeled as a pushdown system (PDS) which allows to track the stack of the program, and malicious behaviors are specified in SCTPL or SLTPL, where SCTPL (resp. SLTPL) is an extension of CTL (resp. LTL) with variables, quantifiers, and predicates over the stack (needed for malware specification). The malware detection problem is reduced to SCTPL/SLTPL model-checking for PDSs. PoMMaDe allows us to detect 600 real malwares, 200 new malwares generated by two malware generators NGVCK and VCL32, and prove benign programs are benign. In particular, PoMMaDe was able to detect several malwares that could not be detected by well-known anti-viruses such as Avira, Avast, Kaspersky, McAfee, AVG, BitDefender, Eset Nod32, F-Secure, Norton, Panda, Trend Micro and Qihoo 360.", "num_citations": "33\n", "authors": ["691"]}
{"title": "Permutation rewriting and algorithmic verification\n", "abstract": " We propose a natural subclass of regular languages (Alphabetic Pattern Constraints, APC) which is effectively closed under permutation rewriting, i.e., under iterative application of rules of the form ab\u00a0\u2192\u00a0ba. It is well-known that regular languages do not have this closure property, in general. Our result can be applied for example to regular model checking, for verifying properties of parametrized linear networks of regular processes, and for modeling and verifying properties of asynchronous distributed systems. We also consider the complexity of testing membership in APC and show that the question is complete for PSPACE when the input is an NFA, and complete for NLOGSPACE when it is a DFA. Moreover, we show that both the inclusion problem and the question of closure under permutation rewriting are PSPACE-complete when we restrict to the class APC.", "num_citations": "33\n", "authors": ["691"]}
{"title": "Mining malware specifications through static reachability analysis\n", "abstract": " The number of malicious software (malware) is growing out of control. Syntactic signature based detection cannot cope with such growth and manual construction of malware signature databases needs to be replaced by computer learning based approaches. Currently, a single modern signature capturing the semantics of a malicious behavior can be used to replace an arbitrarily large number of old-fashioned syntactical signatures. However teaching computers to learn such behaviors is a challenge. Existing work relies on dynamic analysis to extract malicious behaviors, but such technique does not guarantee the coverage of all behaviors. To sidestep this limitation we show how to learn malware signatures using static reachability analysis. The idea is to model binary programs using pushdown systems (that can be used to model the stack operations occurring during the binary code execution), use\u00a0\u2026", "num_citations": "32\n", "authors": ["691"]}
{"title": "LTL model-checking for malware detection\n", "abstract": " Nowadays, malware has become a critical security threat. Traditional anti-viruses such as signature-based techniques and code emulation become insufficient and easy to get around. Thus, it is important to have efficient and robust malware detectors. In [20,19], CTL model-checking for PushDown Systems (PDSs) was shown to be a robust technique for malware detection. However, the approach of [20,19] lacks precision and runs out of memory in several cases. In this work, we show that several malware specifications could be expressed in a more precise manner using LTL instead of CTL. Moreover, LTL can express malicious behaviors that cannot be expressed in CTL. Thus, since LTL model-checking for PDSs is polynomial in the size of PDSs while CTL model-checking for PDSs is exponential, we propose to use LTL model-checking for PDSs for malware detection. Our approach consists of: (1\u00a0\u2026", "num_citations": "32\n", "authors": ["691"]}
{"title": "Analyzing asynchronous programs with preemption\n", "abstract": " Multiset pushdown systems have been introduced by Sen and Viswanathan as an adequate model for asynchronous programs where some procedure calls can be stored as tasks to be processed later. The model is a pushdown system supplied with a multiset of pending tasks. Tasks may be added to the multiset at each transition, whereas a task is taken from the multiset only when the stack is empty. In this paper, we consider an extension of these models where tasks may be of different priority level, and can be preempted at any point of their execution by tasks of higher priority. We investigate the control point reachability problem for these models. Our main result is that this problem is decidable by reduction to the reachability problem for a decidable class of Petri nets with inhibitor arcs. We also identify two subclasses of these models for which the control point reachability problem is reducible respectively to the reachability problem and to the coverability problem for Petri nets (without inhibitor arcs).", "num_citations": "25\n", "authors": ["691"]}
{"title": "Spade: Verification of Multithreaded Dynamic and Recursive Programs\n", "abstract": " Recently, there are a lot of tools that have been considered for software verification.We can for example mention BLAST [HJMS02], SLAM [BR01], KISS [QW04,QR05], ZING [QRR04], and MAGIC [CCG\u2009+\u200903,CCG\u2009+\u200904,CCK\u2009+\u200906]. However, none of these tools can deal with parallelism, communication between parallel processes, dynamic process creation, and recursion at the same time. The tool we propose, called SPADE, allows to analyse automatically boolean programs presenting all these features. As far as we know, this is the first software model checking tool based on an expressive model that accurately models all these aspects in programs.", "num_citations": "24\n", "authors": ["691"]}
{"title": "Model checking dynamic pushdown networks\n", "abstract": " A dynamic pushdown network (DPN) is a set of pushdown systems (PDSs) where each process can dynamically create new instances of PDSs. DPNs are a natural model of multi-threaded programs with (possibly recursive) procedure calls and thread creation. Thus, it is important to have model checking algorithms for DPNs. We consider in this work model checking DPNs against single-indexed LTL and CTL properties of the form  such that f                                    i                  is a LTL/CTL formula over the PDS i. We consider the model checking problems w.r.t. simple valuations (i.e., whether a configuration satisfies an atomic proposition depends only on its control location) and w.r.t. regular valuations (i.e., the set of the configurations satisfying an atomic proposition is a regular set of configurations). We show that these model checking problems are decidable. We propose automata-based approaches for\u00a0\u2026", "num_citations": "15\n", "authors": ["691"]}
{"title": "PuMoC: a CTL model-checker for sequential programs\n", "abstract": " In this paper, we present PuMoC, a CTL model checker for Pushdown systems (PDSs) and sequential C/C++ and Java programs. PuMoC allows to do CTL model-checking w.r.t simple valuations, where the atomic propositions depend on the control locations of the PDSs, and w.r.t. regular valuations, where atomic propositions are regular predicates over the stack content. Our tool allowed to (1) check 500 randomly generated PDSs against several CTL formulas; (2) check around 1461 versions of 30 Windows drivers taken from SLAM benchmarks; (3) check several C and Java programs; and (4) perform data flow analysis of real-world Java programs. Our results show the efficiency and the applicability of our tool.", "num_citations": "15\n", "authors": ["691"]}
{"title": "Computer Aided Verification\n", "abstract": " Computer Aided Verification - NASA/ADS Now on home page ads icon ads Enable full ADS view NASA/ADS Computer Aided Verification Touili, Tayssir ; Cook, Byron ; Jackson, Paul Abstract Publication: Lecture Notes in Computer Science Pub Date: 2010 DOI: 10.1007/978-3-642-14295-6 Bibcode: 2010LNCS......T Keywords: Computer Science; Logics and Meanings of Programs; Software Engineering; Programming Languages; Compilers; Interpreters; Mathematical Logic and Formal Languages; Artificial Intelligence (incl. Robotics); Computer Communication Networks full text sources Publisher | \u00a9 The SAO/NASA Astrophysics Data System adshelp[at]cfa.harvard.edu The ADS is operated by the Smithsonian Astrophysical Observatory under NASA Cooperative Agreement NNX16AC86A NASA logo Smithsonian logo Resources About ADS ADS Help What's New Careers@ADS Social @adsabs ADS Blog Project \u2026", "num_citations": "14\n", "authors": ["691"]}
{"title": "A decision procedure for detecting atomicity violations for communicating processes with locks\n", "abstract": " We present a new decision procedure for detecting property violations in pushdown models for concurrent programs that use lock-based synchronization, where each thread\u2019s lock operations are properly nested (\u00e0 la synchronized methods in Java). The technique detects violations expressed as indexed phase automata (PAs)\u2014a class of non-deterministic finite automata in which the only loops are self-loops.               Our interest in PAs stems from their ability to capture atomic-set serializability violations. (Atomic-set serializability is a relaxation of atomicity to only a user-specified set of memory locations.) We implemented the decision procedure and applied it to detecting atomic-set-serializability violations in models of concurrent Java programs. Compared with a prior method based on a semi-decision procedure, not only was the decision procedure 7.5X faster overall, but the semi-decision procedure timed\u00a0\u2026", "num_citations": "14\n", "authors": ["691"]}
{"title": "Regular hedge model checking\n", "abstract": " We extend the regular model checking framework so that it can handle systems with arbitrary width tree-like structures. Configurations of a system are represented by trees of arbitrary arities, sets of configurations are represented by regular hedge automata, and the dynamics of a system is modeled by a regular hedge transducer. We consider the problem of computing the transitive closure T                 + of a regular hedge transducer T. This construction is not possible in general. Therefore, we present a general acceleration technique for computing T                 +. Our method consists of enhancing the termination of the iterative computation of the different compositions T                 i by merging the states of the hedge transducers according to an appropriate equivalence relation that preserves the traces of the transducers. We provide a methodology for effectively deriving equivalence relations that are\u00a0\u2026", "num_citations": "14\n", "authors": ["691"]}
{"title": "Dealing with communication for dynamic multithreaded recursive programs\n", "abstract": " This paper presents a new contribution to the model-checking of multithreaded programs with recursive procedure calls, result passing between recursive procedures, dynamic creation of parallel processes, and synchronisation between parallel threads. To represent such programs accurately, we define the model SPAD that can be seen as the extension with synchronisation of the class PAD (the subclass of the rewrite systems PRS where parallel composition is not allowed in the lefthand sides of the rules). We consider in this paper the reachability problem of this model, which is undecidable. As in [BET03a, BET04], we reduce this problem to the computation of abstractions of the sets of execution paths of the program, and we propose a generic technique that can compute different abstractions (of different precisions and different costs) of these sets.", "num_citations": "14\n", "authors": ["691"]}
{"title": "Automatic extraction of malicious behaviors\n", "abstract": " The number of new malwares is increasing everyday. Thus malware detection is nowadays a big challenge. The existing techniques for malware detection require a huge effort of engineering to manually extract the malicious behaviors. To avoid this tedious task, we propose in this paper an approach to automatically extract the malicious behaviors. We model a program using an API call graph, and we represent the malicious behaviors using a malicious API graph. We then reduce the malicious behavior extraction problem to the problem of retrieving from the benign and malicious API call graphs the set of subgraphs that are relevant for malicious behaviors. We solve this issue by applying and adapting well-known efficient Information Retrieval techniques based on the TFIDF scheme. We use our automatically extracted malicious behavior specification for malware detection using a kind of product between graphs\u00a0\u2026", "num_citations": "12\n", "authors": ["691"]}
{"title": "Widening techniques for regular model checking\n", "abstract": " Sauf mention contraire ci-dessus, le contenu de cette notice bibliographique peut \u00eatre utilis\u00e9 dans le cadre d\u2019une licence CC BY 4.0 Inist-CNRS/Unless otherwise stated above, the content of this bibliographic record may be used under a CC BY 4.0 licence by Inist-CNRS/A menos que se haya se\u00f1alado antes, el contenido de este registro bibliogr\u00e1fico puede ser utilizado al amparo de una licencia CC BY 4.0 Inist-CNRS", "num_citations": "12\n", "authors": ["691"]}
{"title": "Verifying parallel programs with dynamic communication structures\n", "abstract": " We address the verification problem of networks of communicating pushdown systems modeling communicating parallel programs with procedure calls. Processes in such networks can read the control state of the other processes according to a given communication structure (specifying the observability rights between processes). The reachability problem of such models is undecidable in general. First, we define a class of networks that effectively preserves recognizability (hence, its reachability problem is decidable). Then, we consider networks where the communication structure can change dynamically during the execution according to a phase graph. The reachability problem for these dynamic networks being undecidable in general, we define a subclass for which it becomes decidable. Then, we consider reachability when the switches in the communication structures are bounded. We show that this\u00a0\u2026", "num_citations": "11\n", "authors": ["691"]}
{"title": "Widening techniques for regular tree model checking\n", "abstract": " We consider the framework of regular tree model checking where sets of configurations of a system are represented by regular tree languages and its dynamics is modeled by a term rewriting system (or a regular tree transducer). We focus on the computation of the reachability set R*(L) where R is a regular tree transducer and L is a regular tree language. The construction of this set is not possible in general. Therefore, we present a general acceleration technique, called regular tree widening which allows to speed up the convergence of iterative fixpoint computations in regular tree model checking. This technique can be applied uniformly to various kinds of transformations. We show the application of our framework to different analysis contexts: verification of parameterized tree networks and data-flow analysis of multithreaded programs. Parametrized networks are modeled by relabeling tree transducers\u00a0\u2026", "num_citations": "9\n", "authors": ["691"]}
{"title": "Computing transitive closures of hedge transformations\n", "abstract": " We consider the framework of  regular hedge model checking  where configurations are represented by trees of arbitrary arities, sets of configurations are represented by regular hedge automata, and the dynamic of a system is modeled by a term rewriting system. We consider the problem of computing the transitive closure  R*(L)  of a hedge automaton  L  and a (not necessarily structure preserving) term rewriting system  R . This construction is not possible in general. Therefore, we present a semi-algorithm that computes, in case of termination, an over-approximation of this reachability set. We show that our procedure computes the exact reachability set in many practical applications. We have successfully applied our technique to compute transitive closures for some mutual exclusion protocols defined on arbitrary width tree topologies, as well as for two interesting XML applications.", "num_citations": "9\n", "authors": ["691"]}
{"title": "CARET model checking for pushdown systems\n", "abstract": " CARET (A temporal logic of calls and returns) was introduced by Alur et al. This logic allows to write linear temporal logic formulas while taking into account matching of calls and returns. However, CARET model checking for Push-down Systems (PDSs) was never considered in the literature. Previous works only dealt with the model checking problem for Recursive State Machine (RSMs). While RSMs are a good formalism to model sequential programs written in structured programming languages like C or Java, they become non suitable for modeling binary or assembly programs, since, in these programs, explicit push and pop of the stack can occur. Thus, it is very important to have a CARET model checking algorithm for PDSs. We tackle this problem in this paper. We also consider CARET model checking with regular valuations, where the set of configurations in which an atomic proposition holds is a regular\u00a0\u2026", "num_citations": "8\n", "authors": ["691"]}
{"title": "Analyse symbolique de syst\u00e8mes infinis bas\u00e9e sur les automates: Application \u00e0 la v\u00e9rification de syst\u00e8mes param\u00e9tr\u00e9s et dynamiques\n", "abstract": " Nous nous int\u00e9ressons dans cette th\u00e8se au model-checking des syst\u00e8mes infinis, notamment les syst\u00e8mes param\u00e9tr\u00e9s et les programmes r\u00e9cursifs parall\u00e8les. Nous pr\u00e9sen\\-tons un cadre uniforme pour la v\u00e9rification algorithmique de ces syst\u00e8mes. Ce cadre est bas\u00e9 sur la repr\u00e9sentation des ensembles de configurations par des automates de mots ou d'arbres, et la repr\u00e9sentation des relations de transition des syst\u00e8mes par des r\u00e8gles de r\u00e9\u00e9critures de mots ou de termes. Le probl\u00e8me de la v\u00e9rification est ensuite r\u00e9duit au calcul des ensembles des accessibles dans ce cadre. Les contributions de cette th\u00e8se sont les suivantes: 1-D\u00e9finition d'une technique d'acc\u00e9l\u00e9ration g\u00e9n\u00e9rale. Nous proposons une m\u00e9thode bas\u00e9e sur des techniques d'extrapolation sur les automates, et nous \u00e9tudions la puissance de cette approche. 2-Techniques de model-checking r\u00e9gulier pour la v\u00e9rification des r\u00e9seaux param\u00e9tr\u00e9s avec des topologies lin\u00e9aires et arborescentes. En particulier, nous consid\u00e9rons les r\u00e9seaux mod\u00e9lis\u00e9s par des syst\u00e8mes de r\u00e9\u00e9criture comprenant des semi-commutations, c-\u00e0-d. des r\u00e8gles de la forme ab-> ba, et nous exhibons une classe de langages qui est effectivement ferm\u00e9e par ces syst\u00e8mes. 3-Mod\u00e9lisation et v\u00e9rification des programmes r\u00e9cursifs parall\u00e8les. Dans un premier temps, nous \u00e9tudions les mod\u00e8les PRS qui sont plus g\u00e9n\u00e9raux que les syst\u00e8mes \u00e0 pile, les r\u00e9seaux de Petri, et les syst\u00e8mes PA; et nous proposons des algorithmes qui calculent les ensembles des accessibles de (sous-classes de) PRS en consid\u00e9rant diff\u00e9rentes s\u00e9mantiques. Dans une autre approche, nous consid\u00e9rons des mod\u00e8les bas\u00e9s sur des automates \u00e0\u00a0\u2026", "num_citations": "8\n", "authors": ["691"]}
{"title": "BCARET Model Checking for Malware Detection\n", "abstract": " The number of malware is growing fast recently. Traditional malware detectors based on signature matching and code emulation are easy to bypass. To overcome this problem, model-checking appears as an efficient approach that has been extensively applied for malware detection in recent years. Pushdown systems were proposed as a natural model for programs, as they allow to take into account the program\u2019s stack into the model. CARET and BCARET were proposed as formalisms for malicious behavior specification since they can specify properties that require matchings of calls and returns which is crucial for malware detection. In this paper, we propose to use BCARET for malicious behavior specification. Since BCARET formulas for malicious behaviors are huge, we propose to extend BCARET with variables, quantifiers and predicates over the stack. Our new logic is called SBPCARET. We\u00a0\u2026", "num_citations": "7\n", "authors": ["691"]}
{"title": "Verifying parallel programs with dynamic communication structures\n", "abstract": " We address the verification problem of networks of communicating pushdown systems modeling communicating parallel programs with procedure calls. Processes in such networks can read the control state of the other processes according to a given communication structure (specifying the observability rights between processes). The reachability problem of such models is undecidable in general. First, we define a class of networks that effectively preserves recognizability (hence, its reachability problem is decidable). Then, we consider networks where the communication structure can change dynamically during the execution according to a phase graph. The reachability problem for these dynamic networks being undecidable in general, we define a subclass for which it becomes decidable. Then, we consider reachability when the switches in the communication structures are bounded. We show that this problem\u00a0\u2026", "num_citations": "7\n", "authors": ["691"]}
{"title": "Reachability analysis of self modifying code\n", "abstract": " Self modifying code is code that modifies its own instructions during execution time. It is nowadays widely used, especially in malware to make the code hard to analyse and to detect by anti-viruses. Thus, the analysis of such self modifying programs is a big challenge. Pushdown systems (PDSs) is a natural model that is extensively used for the analysis of sequential programs because they allow to accurately model procedure calls and mimic the program's stack. In this work, we propose to extend the PushDown System model with selfmodifying rules. We call the new model Self-Modifying Push- Down System (SM-PDS). A SM-PDS is a PDS that can modify its own set of transitions during execution. We show how SMPDSs can be used to naturally represent self-modifying programs and provide efficient algorithms to compute the backward and forward reachable configurations of SM-PDSs. We implemented our\u00a0\u2026", "num_citations": "6\n", "authors": ["691"]}
{"title": "Computing transitive closures of hedge transformations\n", "abstract": " We consider the framework of regular hedge model checking where configurations are represented by trees of arbitrary arities, sets of configurations are represented by regular hedge automata, and the dynamic of a system is modelled by a term rewriting system. We consider the problem of computing the transitive closure R*(L) of a hedge automaton L and a (not necessarily structure preserving) term rewriting system R. This construction is not possible in general. Therefore, we present a semi-algorithm that computes, in case of termination, an over-approximation of this reachability set. We show that our procedure computes the exact reachability set in many practical applications. We have successfully applied our technique to compute transitive closures for some mutual exclusion protocols defined on arbitrary width tree topologies, as well as for two interesting XML applications.", "num_citations": "6\n", "authors": ["691"]}
{"title": "Bounded communication reachability analysis of process rewrite systems with ordered parallelism\n", "abstract": " We define a new model called O-PRS that extends the Process Rewrite Systems formalism with a new associative operator, \u201c\u29b6\u201d, that allows to model parallel composition while keeping the order between parallel processes. Indeed, sometimes, it is important to remember the order between the parallel processes. The reachability problem of O-PRS being undecidable, we develop tree automata techniques allowing to build polynomial finite representations of (1) the exact reachable configurations in O-PRS modulo various equivalences that omit the associativity of \u201c\u29b6\u201d, and (2) underapproximations of the reachable configurations if the associativity of \u201c\u29b6\u201d is considered. We show that these underapproximations are exact if the number of communications between ordered parallel processes is bounded. We implemented our algorithms in a tool that was used for the analysis of a concurrent lexer server.", "num_citations": "6\n", "authors": ["691"]}
{"title": "Learning android malware\n", "abstract": " The number of Android malware is increasing every day. Thus Android malware detection is nowadays a big challenge. One of the most tedious tasks in malware detection is the extraction of malicious behaviors. This task is usually done manually and requires a huge effort of engineering. To avoid this step, we propose in this paper to use machine learning techniques for malware detection. Unlike the existing learning based approaches, we propose to use API call graphs to represent the behaviors of Android applications. Then, given a set of malicious applications and a set of benign applications, we apply well-known learning techniques based on Random Walk Graph Kernel (combined with Support Vector Machines). We can achieve a high detection rate with only few false alarms (98.76% for detection rate with 0.24% of false alarms).", "num_citations": "5\n", "authors": ["691"]}
{"title": "Model-checking software library API usage rules\n", "abstract": " Modern software increasingly relies on using third-party libraries which are accessed via application programming interfaces (APIs). Libraries usually impose constraints on how API functions can be used (API usage rules) and programmers have to obey these API usage rules. However, API usage rules often are not well documented or documented informally. In this work, we show how to use the SCTPL and SLTPL logics to precisely and formally specify API usage rules in libraries, where SCTPL/SLTPL can be seen as an extension of the branching/linear temporal logic CTL/LTL with variables, quantifiers and predicates over the stack. This allows library providers to formally describe API usage rules without knowing how their libraries will be used by programmers. We propose an automated approach to check whether programs using libraries violate API usage rules or not. Our approach consists in\u00a0\u2026", "num_citations": "5\n", "authors": ["691"]}
{"title": "Attenuation regulation as a term rewriting system\n", "abstract": " The classical attenuation regulation of gene expression in bacteria is considered. We propose to represent the secondary RNA structure in the leader region of a gene or an operon by a term, and we give a probabilistic term rewriting system modeling the whole process of such a regulation.", "num_citations": "4\n", "authors": ["691"]}
{"title": "On symbolic verification of weakly extended PAD\n", "abstract": " We consider the verification problem of a class of infinite-state systems called wPAD. These systems can be used to model programs with (possibly recursive) procedure calls and dynamic creation of parallel processes. They correspond to PAD models extended with an acyclic finite-state control unit, where PAD models can be seen as combinations of prefix rewrite systems (pushdown systems) with context-free multiset rewrite systems (synchronization-free Petri nets). Recently, we have presented symbolic reachability techniques for the class of PAD based on the use of a class of unranked tree automata. In this paper, we generalize our previous work to the class wPAD which is strictly larger than PAD. This generalization brings a positive answer to an open question on decidability of the model checking problem for wPAD against EF logic. Moreover, we show how symbolic reachability analysis of wPAD can be\u00a0\u2026", "num_citations": "4\n", "authors": ["691"]}
{"title": "Learning malware using generalized graph kernels\n", "abstract": " Machine learning techniques were extensively applied to learn and detect malware. However, these techniques use often rough abstractions of programs. We propose in this work to use a more precise model for programs, namely extended API call graphs, where nodes correspond to API function calls, edges specify the execution order between the API functions, and edge labels indicate the dependence relation between API functions parameters. To learn such graphs, we propose to use Generalized Random Walk Graph Kernels (combined with Support Vector Machines). We implemented our techniques and obtained encouraging results for malware detection: 96.73% of detection rate with 0.73% of false alarms.", "num_citations": "3\n", "authors": ["691"]}
{"title": "Precise extraction of malicious behaviors\n", "abstract": " In recent years, the damage cost caused by malwares is huge. Thus, malware detection is a big challenge. The task of specifying malware takes a huge amount of time and engineering effort since it currently requires the manual study of the malicious code. Thus, in order to avoid the tedious manual analysis of malicious codes, this task has to be automatized. To this aim, we propose in this work to represent malicious behaviors using extended API call graphs, where nodes correspond to API function calls, edges specify the execution order between the API functions, and edge labels indicate the dependence relation between API functions parameters. We define new static analysis techniques that allow to extract such graphs from programs, and show how to automatically extract, from a set of malicious and benign programs, an extended API call graph that represents the malicious behaviors. Finally, We show how\u00a0\u2026", "num_citations": "3\n", "authors": ["691"]}
{"title": "CARET analysis of multithreaded programs\n", "abstract": " Dynamic Pushdown Networks (DPNs) are a natural model for multithreaded programs with (recursive) procedure calls and thread creation. On the other hand, CARET is a temporal logic that allows to write linear temporal formulas while taking into account the matching between calls and returns. We consider in this paper the model-checking problem of DPNs against CARET formulas. We show that this problem can be effectively solved by a reduction to the emptiness problem of B\u00fcchi Dynamic Pushdown Systems. We then show that CARET model checking is also decidable for DPNs communicating with locks. Our results can, in particular, be used for the detection of concurrent malware.", "num_citations": "3\n", "authors": ["691"]}
{"title": "LTL model-checking for dynamic pushdown networks communicating via locks\n", "abstract": " A Dynamic Pushdown Network (DPN) is a set of pushdown systems (PDSs) where each process can dynamically create new instances of PDSs. DPNs are a natural model of multi-threaded programs with (possibly recursive) procedure calls and thread creation. Extending DPNs with locks allows processes to synchronize with each other. Thus, DPNs with locks are a well adapted formalism to model multi-threaded programs that synchronize via locks. Therefore, it is important to have model-checking algorithms for DPNs with locks. We consider in this work model-checking for DPNs with locks against single-indexed LTL properties of the form V fi s.t. fi is a LTL formula interpreted over the PDS i. We consider the model-checking problems w.r.t. simple valuations (i.e, whether a configuration satisfies an atomic proposition depends only on its control location and held locks) and w.r.t. regular valuations (i.e., the set of the configurations satisfying an atomic proposition is a regular set of configurations). We show that these model-checking problems are decidable.", "num_citations": "3\n", "authors": ["691"]}
{"title": "V eri cation de R eseaux Param etr es Bas ee sur des Techniques de R e ecriture\n", "abstract": " R esum e Nous consid erons le probl eme de la v eri cation des r eseaux param etr es de processus, c'est-a-dire des r eseaux comprenant un nombre arbitraire de processus identiques. Nous mod elisons ces syst emes par des syst emes de re ecriture de nissant des relations r eguli eres et nous repr esentons les ensembles de con gurations par des langages r eguliers. Nous r eduisons le probl eme de la v eri cation a celui du calcul de R (), ou R (resp.), une relation r eguli ere (resp. un langage r egulier). Nous proposons alors deux r esultats principaux:1. Nous montrons qu'une classe de r eguliers (SRE+), qui correspond aux langages de niveau 3/2 de la hi erarchie de Straubing, est e ectivement ferm ee par permutations: nous proposons un algorithme qui calcule R (), pour tout langage de la classe et tout ensemble de permutations R. 2. Nous de nissons une approche symbolique pour le calcul de R () bas ee sur une technique automatique d'extrapolation qui permet d'acc el erer les calculs de points xes pour aider la convergence. Nous avons r ealis e un prototype d'outil bas e sur cette technique d'extrapolation. Cet outil a permis de v eri er automatiquement et e cacement les protocoles d'exclusion mutuelle de Dijkstra, de Burns, de Szymanski, de celui de Lamport connu sous le nom du\\Bakery algorithm\" et le\\token passing protocol\".", "num_citations": "3\n", "authors": ["691"]}
{"title": "STAMAD: a STAtic MAlware Detector\n", "abstract": " One of the main challenges in malware detection is the discovery of malicious behaviors. This task requires a huge amount of engineering and manual study of the code. To avoid this tedious manual task, we propose in this paper a tool, called STAMAD, that, given a training set of known malwares and benign programs,(1) either automatically extracts malicious behaviors using Information Retrieval techniques, or (2) applies machine learning techniques to automatically learn malwares. Then, in both cases, STAMAD can classify a new given unseen program as malicious or benign.", "num_citations": "2\n", "authors": ["691"]}
{"title": "Branching temporal logic of calls and returns for pushdown systems\n", "abstract": " Pushdown Systems (PDSs) are a natural model for sequential programs with (recursive) procedure calls. In this work, we define the Branching temporal logic of CAlls and RETurns (BCARET) that allows to write branching temporal formulas while taking into account the matching between calls and returns. We consider the model-checking problem of PDSs against BCARET formulas with \u201cstandard\u201d valuations (where an atomic proposition holds at a configuration c or not depends only on the control state of c, not on its stack) as well as regular valuations (where the set of configurations in which an atomic proposition holds is regular). We show that these problems can be effectively solved by a reduction to the emptiness problem of Alternating B\u00fcchi Pushdown Systems. We show that our results can be applied for malware detection.", "num_citations": "2\n", "authors": ["691"]}
{"title": "Static analysis of multithreaded recursive programs communicating via rendez-vous\n", "abstract": " We present in this paper a generic framework for the analysis of multi-threaded programs with recursive procedure calls, synchronisation by rendez-vous between parallel threads, and dynamic creation of new threads. To this end, we consider a model called Synchronized Dynamic Pushdown Networks (SDPNs) that can be seen as a network of pushdown processes executing synchronized transitions, spawning new pushdown processes, and performing internal pushdown actions. The reachability problem for this model is unfortunately undecidable. Therefore, we tackle this problem by introducing an abstraction framework based on Kleene algebras in order to compute an abstraction of the execution paths between two regular sets of configurations. We combine an automata theoretic saturation procedure with constraint solving in a finite domain. We then apply this framework to a Counter-Example\u00a0\u2026", "num_citations": "2\n", "authors": ["691"]}
{"title": "Reachability analysis of dynamic pushdown networks with priorities\n", "abstract": " In this paper, we consider the reachability problem of multi-threaded programs where threads have priorities and are scheduled by a priority based round-robin scheduler. For that, we introduce a new model, called Dynamic Pushdown Networks with Priorities (P-DPNs) that extends the well known DPN model with priorities. We represent potentially infinite sets of configurations of P-DPNs using finite state automata and show that the backward reachability sets of P-DPNs are regular and can be effectively computed.", "num_citations": "2\n", "authors": ["691"]}
{"title": "Verifying multithreaded recursive programs with integer variables\n", "abstract": " We consider the verification problem of programs containing the following complex features: (1) dynamic creation of parallel threads, (2) synchronisation between parallel threads via global variables, (3) (possibly recursive) procedure calls, and (4) integer variables. The configurations of such programs are represented by terms, and their transitions by term rewriting systems. The novelty of our modeling w.r.t. other existing works consists in explicitely modeling integer variables in the terms. We propose a semi-decision procedure that, in case of termination, checks whether an infinite set of configurations, represented by a regular tree language, is reachable from an infinite set of initial configurations of the program (usually represented by a set of non ground terms). As fas as we know, this is the first time that reachability between non-ground terms and regular tree languages is considered. We implemented our\u00a0\u2026", "num_citations": "2\n", "authors": ["691"]}
{"title": "LTL Model Checking of Self Modifying Code\n", "abstract": " Self modifying code is code that can modify its own instructions during the execution of the program. It is extensively used by malware writers to obfuscate their malicious code. Thus, analysing self modifying code is nowadays a big challenge. In this paper, we consider the LTL model-checking problem of self modifying code. We model such programs using self-modifying pushdown systems (SM-PDS), an extension of pushdown systems that can modify its own set of transitions during execution. We reduce the LTL model-checking problem to the emptiness problem of self-modifying Buchi pushdown systems (SM-BPDS). We implemented our techniques in a tool that we successfully applied for the detection of several self-modifying malware. Our tool was also able to detect several malwares that well-known antiviruses such as BitDefender, Kinsoft, Avira, eScan, Kaspersky, Qihoo-360, Baidu, Avast, and Symantec\u00a0\u2026", "num_citations": "1\n", "authors": ["691"]}
{"title": "Model-checking hyperltl for pushdown systems\n", "abstract": " Temporal logics such as LTL are often used to express safety or correctness properties of programs. However, they cannot model complex formulas known as hyperproperties introducing relations between different execution paths of a same system. In order to do so, the logic HyperLTL adds existential and universal quantifications of path variables to LTL. The model-checking problem, that is, determining if a given representation of a program verifies a HyperLTL property, has been shown to be decidable for finite state systems. In this paper, we prove that this result does not hold for Pushdown Systems nor for the subclass of Visibly Pushdown Systems. We therefore introduce an algorithm that over-approximates the model-checking problem with an automata-theoretic approach. We also detail an under-approximation method based on a phase-bounded analysis of Multi-Stack Pushdown Systems. We then\u00a0\u2026", "num_citations": "1\n", "authors": ["691"]}
{"title": "Dealing with priorities and locks for concurrent programs\n", "abstract": " In this paper, we consider the backward reachability problem of multi-threaded programs where the threads have priorities, can be synchronized using locks and are scheduled by a priority based round-robin scheduler. For that, we extend the well known Dynamic Pushdown Network model with priorities and locks (called PL-DPN). We represent potentially infinite sets of configurations of PL-DPNs using finite state automata and show that the backward reachability sets of PL-DPNs are regular and can be effectively computed if we restrict the usage of priorities inside lock usages. Also, we show that allowing an unrestricted usage of nested locks and priorities leads to undecidability. We evaluate the performance of our algorithm on benchmarks drawn from real time systems, device drivers and hypervisor obtaining encouraging results and discovering new bugs.", "num_citations": "1\n", "authors": ["691"]}
{"title": "Reachability analysis of pushdown systems with an upper stack\n", "abstract": " Pushdown systems (PDSs) are a natural model for sequential programs, but they can fail to accurately represent the way an assembly stack actually operates. Indeed, one may want to access the part of the memory that is below the current stack or base pointer, hence the need for a model that keeps track of this part of the memory. To this end, we introduce pushdown systems with an upper stack (UPDSs), an extension of PDSs where symbols popped from the stack are not destroyed but instead remain just above its top, and may be overwritten by later push rules. We prove that the sets of successors  and predecessors  of a regular set of configurations of such a system are not always regular, but that  is context-sensitive, so that we can decide whether a single configuration is forward reachable or not. In order to underapproximate  in a regular fashion, we consider a bounded-phase analysis\u00a0\u2026", "num_citations": "1\n", "authors": ["691"]}
{"title": "Extracting Android malicious behaviors\n", "abstract": " The number of Android malwares is increasing quickly. That makes the Android devices more vulnerable while they are the target of malware\u2019s writers. Thus, the challenge nowadays is to detect the malicious Android applications. To this aim, we need to know what are the malicious behaviors that Android malwares apply. In this paper, we introduce a method to automatically extract the malicious behaviors for Android malware detection. We present the behaviors of an Android application by an API call graph and we use a malicious API graph to represent the malicious behaviors. Then, given a set of malicious and benign applications, we compute the malicious behaviors by extracting from the API call graphs the subgraphs that are relevant to the malicious API call graphs but not relevant to the benign ones. This relevance is measured by applying the TFIDF weighting scheme widely used in the Information\u00a0\u2026", "num_citations": "1\n", "authors": ["691"]}
{"title": "Beyond model checking: Parameters everywhere\n", "abstract": " Beyond Model Checking Page 1 Journ\u00e9es GDR GPL \u2013 D\u00e9fis 2025 12 juin 2014 Paris, France Beyond Model Checking: Parameters Everywhere \u00c9tienne Andr\u00e91, Beno\u00eet Delahaye2, Peter Habermehl3, Claude Jard2, Didier Lime4, Laure Petrucci1, Olivier H. Roux4, Tayssir Touili3 1Universit\u00e9 Paris 13, Sorbonne Paris Cit\u00e9, LIPN, CNRS, France 2LINA/Universit\u00e9 de Nantes, France 3LIAFA, Universit\u00e9 Paris Diderot \u2013 Paris7, France 4IRCCyN, \u00c9cole Centrale de Nantes, France \u00c9. Andr\u00e9, OH Roux et al. Beyond Model Checking 12 juin 2014 1 / 5 Page 2 Introduction Beyond Model Checking Model checking guarantees the absence of bugs \u00c9. Andr\u00e9, OH Roux et al. Beyond Model Checking 12 juin 2014 2 / 5 Page 3 Introduction Beyond Model Checking Model checking guarantees the absence of bugs . . . but its use in the industry is rather disappointing \u00c9. Andr\u00e9, OH Roux et al. Beyond Model Checking 12 juin 2014 2 / 5 \u2026", "num_citations": "1\n", "authors": ["691"]}
{"title": "Computer Aided Verification: 22nd International Conference, CAV 2010, Edinburgh, UK, July 15-19, 2010, Proceedings\n", "abstract": " This volume contains the proceedings of the 22nd International Conference on Computer-Aided Veri'cation (CAV) held in Edinburgh, UK, July 15-19 2010. CAV is dedicated to the advancement of the theory and practice of comput-assistedformalanalysismethods forsoftwareandhardwaresystems. Theconf-ence covers the spectrum from theoretical results to concrete applications, with an emphasis on practical veri'cation tools and the algorithms and techniques that are needed for their implementation. We received 145 submissions: 101 submissions of regular papers and 44 s-missions of tool papers. These submissions went through a meticulous review process; eachsubmissionwasreviewedbyatleast 4, andonaverage4. 2 Program Committee members. Authors had the opportunity to respond to the initial-views during an author response period. This helped the Program Committee members to select 51 papers: 34 regular papers and 17 tool papers. In addition to the accepted papers, the program also included:-Five invited talks:* Policy Monitoring in First-Order Temporal Logic, by David Basin (ETH Zurich)* Retro'tting Legacy Code for Security, by Somesh Jha (University of Wisconsin-Madison)* Induction, Invariants, and Abstraction, by Deepak Kapur (University of New Mexico)* Quantitative Information Flow: From Theory to Practice? by Pasquale Malacaria (Queen Mary University) and* Memory Management in Concurrent Algorithms, by Maged Michael (IBM)-Four invited tutorials:* ABC: An Academic Industrial-Strength Veri'cation Tool, by Robert Brayton (University of California, Berkeley)* SoftwareModelChecking, byKennethMcMillan\u00a0\u2026", "num_citations": "1\n", "authors": ["691"]}
{"title": "Constrained reachability of process rewrite systems\n", "abstract": " We consider the problem of analyzing multi-threaded programs with recursive calls, dynamic creation of parallel procedures, and communication. We model such programs by Process Rewrite Systems (PRS) which are sets of term rewriting rules. Terms in this framework represent program control structures. The semantics of PRS systems is defined modulo structural equivalences on terms expressing properties of the operators appearing in the terms (idle process, sequential composition, and asynchronous parallel composition).               We consider the problem of reachability analysis of PRSs under constraints on the execution actions. This problem is undecidable even for regular constraints. [LS98] showed that it becomes decidable for decomposable constraints for the PRS subclass PA if structural equivalences are not taken into account. In this work, we go further and show that for decomposable\u00a0\u2026", "num_citations": "1\n", "authors": ["691"]}