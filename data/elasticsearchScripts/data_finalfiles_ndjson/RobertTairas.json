{"title": "Phoenix-based clone detection using suffix trees\n", "abstract": " A code clone represents a sequence of statements that are duplicated in multiple locations of a program. Clones often arise in source code as a result of multiple cut/paste operations on the source, or due to the emergence of crosscutting concerns. Programs containing code clones can manifest problems during the maintenance phase. When a fault is found or an update is needed on the original copy of a code section, all similar clones must also be found so that they can be fixed or updated accordingly. The ability to detect clones becomes a necessity when performing maintenance tasks. However, if done manually, clone detection can be a slow and tedious activity that is also error prone. A tool that can automatically detect clones offers a significant advantage during software evolution. With such an automated detection tool, clones can be found and updated in less time. Moreover, restructuring or refactoring of\u00a0\u2026", "num_citations": "96\n", "authors": ["994"]}
{"title": "Increasing clone maintenance support by unifying clone detection and refactoring activities\n", "abstract": " ContextClone detection tools provide an automated mechanism to discover clones in source code. On the other side, refactoring capabilities within integrated development environments provide the necessary functionality to assist programmers in refactoring. However, we have observed a gap between the processes of clone detection and refactoring.ObjectiveIn this paper, we describe our work on unifying the code clone maintenance process by bridging the gap between clone detection and refactoring.MethodThrough an Eclipse plug-in called CeDAR (Clone Detection, Analysis, and Refactoring), we forward clone detection results to the refactoring engine in Eclipse. In this case, the refactoring engine is supplied with information about the detected clones to which it can then determine those clones that can be refactored. We describe the extensions to Eclipse\u2019s refactoring engine to allow clones with additional\u00a0\u2026", "num_citations": "87\n", "authors": ["994"]}
{"title": "Clone evolution: a systematic review\n", "abstract": " Detection of code clones \u2014 similar or identical source code fragments \u2014 is of concern both to researchers and to practitioners. An analysis of the clone detection results for a single source code version provides a developer with information about a discrete state in the evolution of the software system. However, tracing clones across multiple source code versions permits a clone analysis to consider a temporal dimension. Such an analysis of clone evolution can be used to uncover the patterns and characteristics exhibited by clones as they evolve within a system. Developers can use the results of this analysis to understand the clones more completely, which may help them to manage the clones more effectively. Thus, studies of clone evolution serve a key role in understanding and addressing issues of cloning in software. In this paper, we present a systematic review of the literature on clone evolution. In particular\u00a0\u2026", "num_citations": "81\n", "authors": ["994"]}
{"title": "An information retrieval process to aid in the analysis of code clones\n", "abstract": " The advent of new static analysis tools has automated the searching for code clones, which are duplicated or similar code fragments in a program. However, clone detection tools can report many clones if the source code that is being searched is large. Programmers may have difficulty comprehending the extensive results from the detection tool, which may inhibit the ability to maintain the identified clones. Latent Semantic Indexing (LSI) is an information retrieval technique that attempts to find relationships in a corpus based on the analysis of the documents in the corpus and the terms in the documents. In this paper, LSI is used to cluster clone classes that have been identified initially by a clone detection tool. The goal of this paper is to detect trends and associations among the clustered clone classes and determine if they provide further comprehension to assist in the maintenance of clones. Experimental\u00a0\u2026", "num_citations": "73\n", "authors": ["994"]}
{"title": "Code template inference using language models\n", "abstract": " This paper investigates the use of a natural language processing technique that automatically detects project-specific code templates (ie, frequently used code blocks), which can be made available to software developers within an integrated development environment. During software development, programmers often and in some cases unknowingly rewrite the same code block that represents some functionality. These frequently used code blocks can inform the existence and possible use of code templates. Many existing code editors support code templates, but programmers are expected to manually define these templates and subsequently add them as templates in the editor. Furthermore, the support of editors to provide templates based on the editing context is still limited. The use of n-gram language models within the context of software development is described and evaluated to overcome these restrictions\u00a0\u2026", "num_citations": "30\n", "authors": ["994"]}
{"title": "A model engineering approach to tool interoperability\n", "abstract": " The integration of various tools is a common requirement throughout the software development process. It is often desirable to consult several tools that perform similar functionalities in the same domain to obtain different perspectives and results to assist design and maintenance decisions. In many cases, tool interoperability requires the generalization of tool-specific data, which necessitates homogenizing the data such that intellectual assets can be shared through a common framework (e.g., the integration of results from various clone detection tools). This tool demonstration summary presents a software language engineering solution technique that uses Model-Driven Engineering to address tool interoperability. A specific focus of the paper is a demonstration of model transformation applied to the task of homogenizing different data formats among similar tools. The challenges of tool integration are\u00a0\u2026", "num_citations": "27\n", "authors": ["994"]}
{"title": "Get to know your clones with CeDAR\n", "abstract": " This demonstration introduces the CeDAR Eclipse plug-in for Java that incorporates the results from different clone detection tools and displays properties of the clones in an IDE. Some properties are displayed directly in the source code editor for quicker access. In addition, current clone refactoring capabilities will be demonstrated.", "num_citations": "17\n", "authors": ["994"]}
{"title": "Clone detection and refactoring\n", "abstract": " The area of clone detection (ie, searching for duplicate fragments of source code) has received wide interest recently as indicated by numerous efforts in clone detection tool development. Additionally, some work has been done in the area of selecting and refactoring the detected clones. However, the actual refactoring of clones is typically separated from the initial clone detection and subsequent selection of clones, because the task is delegated to a refactoring tool. This research abstract describes an investigation that will bridge the gap between clone detection and refactoring by researching and developing a comprehensive clone detection and refactoring process that begins with the detection of clones and ends with their refactoring.", "num_citations": "16\n", "authors": ["994"]}
{"title": "Aspect mining from a modelling perspective\n", "abstract": " Aspect mining aims at identifying, analysing, and refactoring crosscutting concerns throughout a legacy system for the purpose of improving software modularisation. This paper presents our investigation into raising the benefits of aspect mining to high level domain-specific models. A key contribution is the capability to identify crosscutting concerns early in development, which will assist in the modularisation of a design through aspects, before proceeding to the implementation level. Furthermore, our experience has led us to believe that aspects are easier to identify at the modelling level, because much of the accidental complexities of implementation concerns are not present in the corresponding modelling abstractions.", "num_citations": "12\n", "authors": ["994"]}
{"title": "Sub-clone refactoring in open source software artifacts\n", "abstract": " We present a study of revisions made to open source projects that documents the actual refactoring of code associated with code clones (ie, sections of duplicated code). The study identifies a characteristic in which some clone refactorings were performed on only part of the clone (ie, a sub-clone). We conclude that sub-clones should be considered during the clone maintenance activity.", "num_citations": "10\n", "authors": ["994"]}
{"title": "Clone maintenance through analysis and refactoring\n", "abstract": " The removal of duplicate code associated with code clones provides a mechanism to improve code clone maintenance by eliminating redundant code and reducing the amount of code that needs to be maintained. The research described in this paper contributes to the field of code clone maintenance by exploring techniques that determine novel factors influencing code clone analysis and refactoring, and by developing a process that unifies the phases of code clone detection, analysis, and refactoring.", "num_citations": "10\n", "authors": ["994"]}
{"title": "Sub-clones: Considering the Part Rather than the Whole.\n", "abstract": " Researchers have proposed various automated clone detection tools that can assist programmers in finding code clones (ie, duplicated sections of code). Such tools can serve as input into the process of clone removal through refactoring activities. In this paper, we consider the scenario in which an automated clone detection tool was used to find code clones as part of the clone refactoring process. Actual refactorings associated with the detected clones were obtained from changes identified between consecutive versions of open source software artifacts. Based on two separate studies, observations reveal instances of sub-clone refactoring where only part of the clone ranges are actually refactored. We conclude that sub-clone refactoring should be considered to augment refactoring performed on the entire clone.", "num_citations": "8\n", "authors": ["994"]}
{"title": "Coclorep: A dsl for code clones\n", "abstract": " Code clones are pieces of code that are duplicated in multiple locations in the source code of a software application. The existence of these clones and the availability of clone detection tools to find them lend to the need for techniques to analyze the clones in an effort to enhance the quality of the source code. This paper describes an investigation into the development of CoCloRep, a Domain-Specific Language (DSL) for the representation of code clones. The benefits of Model-Driven Engineering (MDE) in this context are observed through the use of model transformations on the clones that are represented by instances of this DSL. These transformations provide a means to analyze the clones. The DSL is developed in the AMMA platform (ATLAS Model Management Architecture), which is a modeling tool that provides features through its own DSLs to specify metamodels and to perform transformations on models.", "num_citations": "8\n", "authors": ["994"]}
{"title": "Representing clones in a localized manner\n", "abstract": " Code clones (ie, duplicate sections of code) can be scattered throughout the source files of a program. Manually evaluating group of such clones requires observing each clone in its origina location (ie, opening each file and finding the source location o each clone), which can be a time-consuming process. As a alternative, this paper introduces a technique that localizes th representation of code clones to provide a summary of th properties of two or more clones in one location. In our approach the results of a clone detection tool are analyzed in an automate manner to determine the properties (ie, similarities an differences) of the clones. These properties are visualized directl within the source editor. The localized representation is realize as part of the features of an Eclipse plug-in called CeDAR.", "num_citations": "7\n", "authors": ["994"]}
{"title": "Representation, analysis, and refactoring techniques to support code clone maintenance\n", "abstract": " The existence of code cloning, which represents identical or near identical sections of code, has been documented to occur frequently in software systems. The main purpose of cloning is the reuse of a code fragment that performs some functionality by copying and pasting it to a new location in the source code. Code clones embody a unique form of coupling, because their similarity inadvertently connects their representative sections of code together. This inherent duplication requires attention to be given to all related duplicates, even if just one of these duplicates is being evaluated or changed. Failure to consider all related clones when maintaining cloned code can result in errors that are difficult to identify initially.", "num_citations": "5\n", "authors": ["994"]}
{"title": "Centralizing clone group representation and maintenance\n", "abstract": " This poster describes contributions to improve clone group representation and maintenance tasks. Centralizing the representation of clones enables displaying their properties without the need to look at individual instances. Centralizing their maintenance enables removal to be performed simultaneously. The benefits of centralizing clone groups are demonstrated in an Eclipse plug-in.", "num_citations": "5\n", "authors": ["994"]}