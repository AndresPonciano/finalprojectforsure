{"title": "Do Dynamic Object Process Graphs Support Program Understanding?-A Controlled Experiment.\n", "abstract": " Using automatic program analysis techniques for extracting architectural information and its visualization is widely considered useful for program understanding. However, it has to be empirically validated if a given technique is beneficial in practice. This is usually done by performing a set of case studies. To find out for sure whether a technique really has any effect, controlled experiments have to be conducted. Dynamic object process graphs are one such technique. These graphs describe the control flow of an application from the perspective of a single object. In previous research, we conducted case studies which indicated that they may be useful for program understanding, but this assumption has not been validated so far. We report on a controlled experiment which investigated this question: Does the availability of such graphs support program understanding or not? We describe the research questions that\u00a0\u2026", "num_citations": "66\n", "authors": ["241"]}
{"title": "Challenges in reengineering automotive software\n", "abstract": " Automotive software is different from the kind of software that is usually addressed by current reengineering research. This paper gives an overview of the particular conditions and challenges that arise in the automotive domain.", "num_citations": "24\n", "authors": ["241"]}
{"title": "Reengineering embedded automotive software\n", "abstract": " The fact that software ages holds for embedded automotive software as well as for any other kind of software. In comparison to IT software, the automotive domain has to deal with different kinds of requirements, such as real time properties, feedback control, and constrained resources. Therefore, used programming languages are C - to meet resource constraints - and data flow oriented graphical languages - to meet the used engineering method and notation of feedback control engineers. This makes the software quite different from what the software maintenance and reengineering community is usually working on, and their results are seldom directly applicable. In this paper, we describe results of a Bosch-internal research project that focused on the adaption of existing reengineering techniques and methods to embedded automotive software development. The goal was to make software maintenance more\u00a0\u2026", "num_citations": "18\n", "authors": ["241"]}
{"title": "Experience report: White box test case generation for automotive embedded software\n", "abstract": " Testing software based on symbolic execution is a promising and well-researched approach. Recently, various dynamic symbolic execution approaches have been proposed that are of interest for industrial practice. However, the corresponding tools are typically not directly usable on model-based languages that are predominantly used in the automotive sector. To this end, we use an internal software analysis framework for model-based, embedded software that allows us to easily integrate various approaches leveraging static and dynamic symbolic execution. In our case study, we describe idiosyncrasies of automotive embedded software and show the benefits of leveraging symbolic information to generate test cases. We study and compare different techniques for generating test cases. We evaluate all techniques empirically on relevant, real-world programs from engine control.", "num_citations": "10\n", "authors": ["241"]}
{"title": "Online construction of dynamic object process graphs\n", "abstract": " A dynamic object process graph is a view on the control flow graph from the perspective of a single object. It has been shown that such a graph can be a useful starting point for many reverse engineering tasks, such as program understanding, protocol recovery, and feature location. In a previous paper, we described how dynamic object process graphs can be constructed from detailed program traces. However, the size of such traces is immense. Moreover, the instrumentation was described only for procedural languages. Object-oriented features such as exceptions require special treatment. Also, techniques like multithreading and reflection were not handled by our previous approach. This prevented it from being applicable to real-life systems. In this paper, we introduce an alternative way of collecting the necessary data. By constructing an intermediate graph online, i.e., concurrently with the running program, the\u00a0\u2026", "num_citations": "10\n", "authors": ["241"]}
{"title": "A program interpreter framework for arbitrary abstractions\n", "abstract": " Abstract interpretation, symbolic execution, concolic testing and other techniques all require interpretation of a program. They all share common requirements for the interpreter, but also have their specialties. In this paper, we present a pragmatic interpreter framework that allows easy realization of all these use cases. This is possible because the interpreter supports arbitrary abstractions and strategies for the varying decisions that have to be considered for different analyses. Furthermore, since the interpreter works on an abstraction of the program, it is applicable for multiple input languages as well as models from model-based development. In this paper, we describe the design of the interpreter and demonstrate how easy it can be adapted to several analyses.", "num_citations": "8\n", "authors": ["241"]}
{"title": "Views for efficient program understanding of automotive software\n", "abstract": " Automotive Software is often developed using graphical notations, such as ASCET or Matlab Simulink models. This means that also different approaches to program comprehension have to be developed. In this paper, we present the results of a research project that developed and evaluated different views on such models.", "num_citations": "6\n", "authors": ["241"]}
{"title": "Industrial program comprehension challenge 2011: Archeology and anthropology of embedded control systems\n", "abstract": " The Industrial Program Comprehension Challenge is a two-year-old track of the International Conference on Program Comprehension that provides a venue for researchers and industrial practitioners to communicate about new research directions that can help address real world problems. This year, 2011, a scenario-based challenge was created to inspire researchers to apply the best \"archaeological\" techniques for understanding the complexity of industrial software, and foster appreciation for the delicate \"anthropological\" scenario which drives the behavior of the software engineers, management, and customers. Participants had two months to work on the challenge and submit write-ups of their solutions. Acceptable submissions were exhibited as posters, while the best solutions were presented during the Industrial Challenge conference session. This new challenge format gives researchers the opportunity to\u00a0\u2026", "num_citations": "6\n", "authors": ["241"]}
{"title": "Automotive software: Characteristics and reengineering challenges\n", "abstract": " Automotive software is different from the kind of software that is usually addressed by current reengineering research. This paper gives an overview of the particular conditions and challenges that we face in the automotive domain.", "num_citations": "5\n", "authors": ["241"]}
{"title": "Using library dependencies for clustering\n", "abstract": " Software clustering is an established approach to automatic architecture recovery. It groups components that are in some way similar to each other. Usually, the similarity measure is based on the dependencies between components of a system. Library dependencies are intentionally ignored during the clustering process \u2013 otherwise, system components would be clustered with library components they use. We propose to particularly look at the dependencies on external components or libraries to learn more about an application\u2019s high-level structure. The number of dependencies of a component from different kinds of libraries provides insightful information about the component\u2019s functionality. Our case study illustrates the potential of this idea.", "num_citations": "5\n", "authors": ["241"]}
{"title": "When program comprehension met bug fixing\n", "abstract": " Localizing and fixing bugs requires a certain amount of program understanding to be successful. In this paper, we report about a recently conducted \u201cprogram comprehension challenge\u201d, where the task was to find and fix bugs\u2013but the focus was on program comprehension. Some participants used fault localization techniques, others built on different kinds of static analysis techniques. We present the approaches and results of the challenge, and discuss the relation between program comprehension, fault localization, and bug fixing.", "num_citations": "4\n", "authors": ["241"]}
{"title": "Parsing variant C code: An evaluation on automotive software\n", "abstract": " Software product lines are often implemented using the C preprocessor. Different features are selected based on macros; the corresponding code is activated or deactivated using# if. Unfortunately, C preprocessor constructs are not parseable in general, since they break the syntactical structure of C code [1]. This imposes a severe limitation on software analyses: They usually cannot be performed on unpreprocessed C code. In this paper, we will discuss how and to what extent large parts of the unpreprocessed code can be parsed anyway, and what the results can be used for.", "num_citations": "3\n", "authors": ["241"]}
{"title": "Reengineering automotive software at Bosch\n", "abstract": " Software Reengineering has been a topic at Bosch for 10 years now. This paper reports about our experiences during this time, about ongoing reengineering activities, and about potential topics for the research community.", "num_citations": "3\n", "authors": ["241"]}
{"title": "Towards recovering and exploiting domain knowledge from C code: A case study on automotive software\n", "abstract": " To create a software system, a lot of knowledge about the domain that it deals with is needed. This is particularly true for embedded control software, which is in close contact with physical machinery, relationships, and effects. In this paper, we investigate if and how this knowledge that was once built into the software can be recovered from the source code - and what it can be used for. We apply approaches from previous research to an engine control software and adapt it to our setting. In particular, we are constrained to pure C code with limited structure, whereas previous work has mainly dealt with object-oriented software. Despite these limiting conditions, our study shows promising results.", "num_citations": "2\n", "authors": ["241"]}
{"title": "Type 2 clone detection on ASCET models\n", "abstract": " Clones are a well-known bad smell pattern in software. So far, research has concentrated on detection of clones in textual languages, while model-based development becomes increasingly important. This is in particular true for the automotive domain, where modelling languages like ASCET are used. This paper presents the adaptation and extension of an existing approach for detection of clones in models. The main novelty is a graph analysis that can detect clones of type 2 (ie, identical structure, but renamed elements) and distinguish between consistently and inconsistently renamed model elements.", "num_citations": "2\n", "authors": ["241"]}
{"title": "Transformation of preprocessor variance to post-build variance\n", "abstract": " Software product lines are widely used to efficiently develop similar variants of a software. In automotive software development, they are often implemented based on the C preprocessor. Even tools for model based development generate such code. The advantage of the preprocessor approach is that only the needed code ends up in the control unit. This way, resource consumption is minimized. On the other hand, for testing and creating meta program versions, post build variance is needed or at least easier to handle. Meta program version means that several of the possible static configurations are integrated in a single binary file, and the concrete configuration can be dynamically selected at engine start. We have developed an approach and tooling to transform existing C code that contains preprocessor variance to post-build variance code.", "num_citations": "1\n", "authors": ["241"]}
{"title": "Towards interactive model mining from embedded software\n", "abstract": " The idea of model mining is the extraction of higherlevel models from code. For example, one could extract state machines that describe the behavior of a program. Such models can be very helpful for software maintenance tasks such as program understanding. The major drawback of fully-automatic model extraction is that, when applied on real world systems (eg, software-intensive systems), the resulting models are complex, difficult, and contain information on a quite low level. Developers can hardly find and understand the information they need. In this paper, we present our ideas towards a framework that solves this problem. The main idea is to let developers contribute to the process of model extraction. The ultimate goal of the framework is to provide high quality representative types of models on an adequate level of abstraction and with low manual effort.", "num_citations": "1\n", "authors": ["241"]}
{"title": "Use Cases of a Generic Model Interpreter in an Automotive Software Setting\n", "abstract": " Model based approaches are widely used to develop today's automotive software systems. They promise to reduce development effort by raising the level of abstraction and making the software better accessible to domain experts. On the other hand, the same effects as for classical code occur: Complexity inevitably increases over time, and models become hard to understand. This is where software analysis can help. Other use cases of software analysis, like test case generation or quality assurance, are of similar importance. Unfortunately, only limited support by analysis tools is available on model level - mainly because each modeling language is different and would require a specific analysis tool. Analyzing the generated code is also not an option, because that code can be arbitrarily far away from the models. We introduce an abstract model interpreter as a way to get out of this situation. It exploits the\u00a0\u2026", "num_citations": "1\n", "authors": ["241"]}
{"title": "A software analysis framework for automotive embedded software\n", "abstract": " One major drawback of model based development is that support by software analysis tools is usually not available. This is because each modeling language would require specially crafted tools. We present a framework that circumvents this problem by allowing integrated analysis of different models from the automotive domain. It also exploits certain specialities of the domain to realize analyses that would otherwise not have been possible.", "num_citations": "1\n", "authors": ["241"]}