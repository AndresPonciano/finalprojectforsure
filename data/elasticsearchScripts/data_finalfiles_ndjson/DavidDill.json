{"title": "Timing assumptions and verification of finite-state concurrent systems\n", "abstract": " We have described a scheme that allows timing assumptions to be incorporated into automatic proofs of arbitrary finite-state temporal properties. The obvious extension is to be able to prove timing properties, not just assume them. This would provide a verification framework for finite-state hard real-time systems. We conjecture that the method presented can, in fact, be extended in this way.             Another major question is practicality. We believe that, with some simple program optimizations, the proposed method can be useful for certain small but tricky systems, such as asynchronous control circuits. For larger systems, approximate and heuristic methods will be needed.", "num_citations": "1058\n", "authors": ["1778"]}
{"title": "Trace theory for automatic hierarchical verification of speed-independent circuits\n", "abstract": " VLSI and concurrency are two of the most active areas of computer science research. In VLSI, the technological trend is towards more complex and faster circuits. There is also a continuing challenge to reduce the time and expense of producing correct designs. The challenge in concurrent systems is correctness: because they are inherently nondeterministic, they are much trickier than sequential circuits.1.1. 1. Asynchronous Circuits This dissertation explores a topic at the convergence of VLSI and concurrency: the semantics and automatic verification of asynchronous circuits. Asynchronous circuit design, after many years of neglect by all but a few engineers and researchers, has recently attracted renewed interest within the VLSI community because it offers a way to cope with problems that accompany the increasing complexity of VLSI circuits. Asynchronous circuits are also interesting to study because they are pure concurrent systems. Unlike concurrent programming languages, which present various distractions such as complicated data domains, variable binding constructs, and recursion, an asynchronous circuit consists of a fixed set of modules communicating over a fixed set of unbuffered channels (wires) with no hidden handshaking or other implicit protocols. The complexity of asynchronous circuit operation stems entirely from communication and synchronization.", "num_citations": "803\n", "authors": ["1778"]}
{"title": "A decision procedure for bit-vectors and arrays\n", "abstract": " STP is a decision procedure for the satisfiability of quantifier-free formulas in the theory of bit-vectors and arrays that has been optimized for large problems encountered in software analysis applications. The basic architecture of the procedure consists of word-level pre-processing algorithms followed by translation to SAT. The primary bottlenecks in software verification and bug finding applications are large arrays and linear bit-vector arithmetic. New algorithms based on the abstraction-refinement paradigm are presented for reasoning about large arrays. A solver for bit-vector linear arithmetic is presented that eliminates variables and parts of variables to enable other transformations, and reduce the size of the problem that is eventually received by the SAT solver.               These and other algorithms have been implemented in STP, which has been heavily tested over thousands of examples obtained from\u00a0\u2026", "num_citations": "776\n", "authors": ["1778"]}
{"title": "Better verification through symmetry\n", "abstract": " A fundamental difficulty in automatic formal verification of finite-state systems is thestate explosion problem\u2014even relatively simple systems can produce very large state spaces, causing great difficulties for methods that rely on explicit state enumeration. We address the problem by exploiting structuralsymmetries in the description of the system to be verified.               We make symmetries easy to detect by introducing a new data typescalarset, a finite and unordered set, to our description language. The operations on scalarsets are restricted so that states are guaranteed to have the same future behaviors, up to permutation of the elements of the scalarsets. Using the symmetries implied by scalarsets, a verifier can automatically generate a reduced state space, on the fly. We provide a proof of the soundness of the new symmetry-based verification algorithm based on a definition of the formal semantics of a\u00a0\u2026", "num_citations": "755\n", "authors": ["1778"]}
{"title": "Protocol verification as a hardware design aid.\n", "abstract": " The role of automatic formal protocol veri cation in hardware design is considered. Principles are identi ed that maximize the bene ts of protocol veri cation while minimizing the labor and computation required. A new protocol description language and veri er (both called Mur') are described, along with experiences in applying them to two industrial protocols that were developed as part of hardware designs.", "num_citations": "628\n", "authors": ["1778"]}
{"title": "The Mur \u03d5 verification system\n", "abstract": " This is a brief overview of the Mur\u03d5 verification system.", "num_citations": "475\n", "authors": ["1778"]}
{"title": "Parallelizing the Mur\u03d5 verifier\n", "abstract": " With the use of state and memory reduction techniques in verification by explicit state enumeration, runtime becomes a major limiting factor. We describe a parallel version of the explicit state enumeration verifier Mur\u03d5 for distributed memory multiprocessors and networks of workstations that is based on the message passing paradigm. In experiments with three complex cache coherence protocols, parallel Mur\u03d5 shows close to linear speedups, which are largely insensitive to communication latency and bandwidth. There is some slowdown with increasing communication overhead, for which a simple yet relatively accurate approximation formula is given. Techniques to reduce overhead and required bandwidth and to allow heterogeneity and dynamically changing load in the parallel machine are discussed, which we expect will allow good speedups when using conventional networks of workstations.", "num_citations": "370\n", "authors": ["1778"]}
{"title": "Automated identification of stratifying signatures in cellular subpopulations\n", "abstract": " Elucidation and examination of cellular subpopulations that display condition-specific behavior can play a critical contributory role in understanding disease mechanism, as well as provide a focal point for development of diagnostic criteria linking such a mechanism to clinical prognosis. Despite recent advancements in single-cell measurement technologies, the identification of relevant cell subsets through manual efforts remains standard practice. As new technologies such as mass cytometry increase the parameterization of single-cell measurements, the scalability and subjectivity inherent in manual analyses slows both analysis and progress. We therefore developed Citrus (cluster identification, characterization, and regression), a data-driven approach for the identification of stratifying subpopulations in multidimensional cytometry datasets. The methodology of Citrus is demonstrated through the identification of\u00a0\u2026", "num_citations": "353\n", "authors": ["1778"]}
{"title": "Experience with predicate abstraction\n", "abstract": " This reports some experiences with a recently-implemented prototype system for verification using predicate abstraction, based on the method of Graf and Sa\u00efdi [9]. Systems are described using a language of iterated guarded commands, called Mur\u00f8 -- (since it is a simplified version of our Mur\u00f8 protocol description language). The system makes use of two libraries: SVC [1] (an efficient decision procedure for quantifier- free first-order logic) and the CMU BDD library. The use of these libraries increases the scope of problems that can be handled by predicate abstraction through increased efficiency, especially in SVC, which is typically called thousands of times. The verification system also provides limited support for quantifiers in formulas. The system has been applied successfully to two nontrivial examples: the Flash multiprocessor cache coherence protocol, and a concurrent garbage collection algorithm\u00a0\u2026", "num_citations": "341\n", "authors": ["1778"]}