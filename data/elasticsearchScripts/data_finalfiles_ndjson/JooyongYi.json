{"title": "Filtering false alarms of buffer overflow analysis using SMT solvers\n", "abstract": " Buffer overflow detection using static analysis can provide a powerful tool for software programmers to find difficult bugs in C programs. Sound static analysis based on abstract interpretation, however, often suffers from false alarm problem. Although more precise abstraction can reduce the number of the false alarms in general, the cost to perform such analysis is often too high to be practical for large software. On the other hand, less precise abstraction is likely to be scalable in exchange for the increased false alarms. In order to attain both precision and scalability, we present a method that first applies less precise abstraction to find buffer overflow alarms fast, and selectively applies a more precise analysis only to the limited areas of code around the potential false alarms. In an attempt to develop the precise analysis of alarm filtering for large C programs, we perform a symbolic execution over the potential alarms\u00a0\u2026", "num_citations": "50\n", "authors": ["2110"]}
{"title": "What do software engineers care about? gaps between research and practice\n", "abstract": " It is a cliche to say that there is a gap between research and practice. As the interest and importance in the practical impact of research has been growing, the gap between research and practice is expected to be narrowing. However, our study reveals that there still seems to be a wide gap. We survey so ware engineers about what they care about when developing so ware. We then compare our survey results with the research topics of the papers published in ICSE/FSE recently. We found the following discrepancy: while so ware engineers care more about so ware development productivity than the quality of so ware, papers on research areas closely related to so ware productivity--such as so ware development process management and so ware development techniques--are significantly less published than papers on so ware verification and validation that account for more than half of publications. We also\u00a0\u2026", "num_citations": "28\n", "authors": ["2110"]}
{"title": "Dynamic reverse code generation for backward execution\n", "abstract": " The need for backward execution in debuggers has been raised a number of times. Backward execution helps a user naturally think backwards and, in turn, easily locate the cause of a bug. Backward execution has been implemented mostly by state-saving or checkpointing, which are inherently not scalable. In this paper, we present a method to generate reverse code, so that backtracking can be performed by executing reverse code. The novelty of our work is that we generate reverse code on-the-fly, while running a debugger, which makes it possible to apply the method even to debugging multi-threaded programs.", "num_citations": "15\n", "authors": ["2110"]}
{"title": "Understanding the impact of pair programming on the minds of developers\n", "abstract": " Software is mostly, if not entirely, a knowledge artifact. Software best practices are often thought to work because they induce more productive behaviour in software developers. In this paper we deployed a new generation tool, portable multichannel EEG, to obtain direct physical insight into the mental processes of working software developers engaged in their standard activities. We have demonstrated the feasibility of this approach and obtained a glimpse of its potential power to distinguish physical brain activity of developers working with different methodologies.", "num_citations": "12\n", "authors": ["2110"]}
{"title": "Design and validation of precooked developer dashboards\n", "abstract": " Despite increasing popularity of developer dashboards, the effectiveness of dashboards is still in question. In order to design a dashboard that is effective and useful for developers, it is important to know (a) what information developers need to see in a dashboard, and (b) how developers want to use a dashboard with that necessary information. To answer these questions, we conducted two series of face-to-face individual interviews with developers. In the first step we analyzed answers, build a Goal-Question-Metric model and designed a precooked developer dashboard. Then, during the second separate series of interviews, we validated the GQM and derived feedback on the designed dashboard. Given that the cost of dashboard customization prevents developers from utilizing dashboards, we believe that our findings can provide a solid starting point to build precooked developer dashboards that can be\u00a0\u2026", "num_citations": "10\n", "authors": ["2110"]}
{"title": "A new architecture and implementation strategy for non-invasive software measurement systems\n", "abstract": " Despite that non-invasive software measurement tools have proven their usefulness in software production, their adoption in software industry is still limited. Reasons for the limited distributions have been studied and analysed recently. In this paper, we propose a new architecture for non-invasive software measurement systems that address the problems of the existing systems. The outcome of our early experimentation is quite promising and gives us the desired additional confidence on its successful distribution.", "num_citations": "8\n", "authors": ["2110"]}
{"title": "Program Validation by Symbolic and Reverse Execution\n", "abstract": " Program Errors (aka \u2018Bugs\u2019) s Recall of Chrysler Pacifica in 2006 s Summary: ON CERTAIN PASSENGER VEHICLES, THE FUEL PUMP MODULE AND THE POWER TRAIN CONTROL MODULE SOFTWARE MAY ALLOW THE ENGINE TO STALL UNDER CERTAIN OPERATING CONDITIONS. s Consequence: THIS COULD CAUSE A CRASH TO OCCUR WITHOUT PRIOR WARNING.", "num_citations": "6\n", "authors": ["2110"]}
{"title": "A Case for Dynamic Reverse-code Generation to Debug Non-deterministic Programs\n", "abstract": " Backtracking (i.e., reverse execution) helps the user of a debugger to naturally think backwards along the execution path of a program, and thinking backwards makes it easy to locate the origin of a bug. So far backtracking has been implemented mostly by state saving or by checkpointing. These implementations, however, inherently do not scale. Meanwhile, a more recent backtracking method based on reverse-code generation seems promising because executing reverse code can restore the previous states of a program without state saving. In the literature, there can be found two methods that generate reverse code: (a) static reverse-code generation that pre-generates reverse code through static analysis before starting a debugging session, and (b) dynamic reverse-code generation that generates reverse code by applying dynamic analysis on the fly during a debugging session. In particular, we espoused the latter one in our previous work to accommodate non-determinism of a program caused by e.g., multi-threading. To demonstrate the usefulness of our dynamic reverse-code generation, this article presents a case study of various backtracking methods including ours. We compare the memory usage of various backtracking methods in a simple but nontrivial example, a bounded-buffer program. In the case of non-deterministic programs such as this bounded-buffer program, our dynamic reverse-code generation outperforms the existing backtracking methods in terms of memory efficiency.", "num_citations": "5\n", "authors": ["2110"]}
{"title": "Mining plausible hypotheses from the literature via meta-analysis\n", "abstract": " Meta-analysis is highly advocated in many fields of empirical research such as medicine and psychology, due to its capability to synthesize quantitative evidence of effects from the literature, based on statistical analysis. However, the adoption of meta-analysis to software engineering is still suffering from inertia, despite the fact that many software engineering researchers have long been arguing the need for it. As an attempt to move beyond the lockstep, we in this paper explore a different use of meta-analysis. Our proposition is that meta-analysis is useful for mining hypotheses because their plausibility is backed by evidence accumulated in the literature, and thus researchers could focus their effort on the areas that are of particular need. We assess our proposition by conducting a lightweight case study on the literature of defect prediction. We found that three out of five hypotheses we extract from our meta-analysis\u00a0\u2026", "num_citations": "4\n", "authors": ["2110"]}
{"title": "Toward a better understanding of how to develop software under stress-drafting the lines for future research\n", "abstract": " The software is often produced under significant time constraints. Our idea is to understand the effects of various software development practices on the performance of developers working in stressful environments, and identify the best operating conditions for software developed under stressful conditions collecting data through questionnaires, non-invasive software measurement tools that can collect measurable data about software engineers and the software they develop, without intervening their activities, and biophysical sensors and then try to recreated also in different processes or key development practices such conditions.", "num_citations": "4\n", "authors": ["2110"]}
{"title": "Comparison of agile, quasi-agile and traditional methodologies\n", "abstract": " In this study we were able to gather a substantial quantity of detailed responses from a group of individuals and companies that are broadly quite similar to those found in several of the major world centers of technological innovation. As such, our analysis of the results provides some tantalizing hints to organizational and methodological challenges and practices of a broad range of groups.             One intriguing suggestion is that while \u201ctraditional\u201d and well defined Agile groups function according to the standards established to support those approaches, Quasi-Agile groups do not. Instead, Quasi-Agile groups seem to pursue the goals of Agile using measures and underlying approaches more similar to traditional methods. One might expect that such a discordance to affect the effectiveness of a group\u2019s efforts.", "num_citations": "3\n", "authors": ["2110"]}
{"title": "Precooked developer dashboards: what to show and how to use\n", "abstract": " Designing an effective and useful dashboard is expensive and it would be important to determine if it is possible to elaborate a\" generic\" useful and effective dashboard, usable in a variety of circumstances. To determine if it is possible to develop such dashboard and, if so, its structure we interviewed 67 software engineers from 44 different companies. Their answers made us confident in the possibility of building such dashboard.", "num_citations": "3\n", "authors": ["2110"]}
{"title": "Towards non-invasive software measurement system: Architecture and implementation\n", "abstract": " Despite that non-invasive software measurement tools have proven their usefulness in software production, their adoption in software industry is still limited. Reasons for the limited distributions have been studied and analyzed in works like (Coman et al, Proceedings of 476 the 31st International Conference on Software Engineering (ICSE 2009), Vancouver 89\u201399, 2009) [1]. In this paper, we propose a new architecture for non-invasive software measurement systems that address the problems of the existing systems. The outcome of our early experimentation is quite promising and gives us the desired additional confidence on its successful distribution.", "num_citations": "1\n", "authors": ["2110"]}
{"title": "Linkage of Model Checking to Debugger Using Extended JPDA\n", "abstract": " Debugger is very helpful tool to trace the cause of errors. Its utility is halved, however, in the case of concurrent program. In general, we cannot predict in which executionpath the errors are hidden. Model checking would be the solution to this matter That makes it possible to discover which execution-paths include the error in reasonable time. We can find out the source of the error, just investigating these execution-paths with a debugger. We suggest the way that links model checking to Java debugger using extended JPDA.", "num_citations": "1\n", "authors": ["2110"]}
{"title": "Systematic Testing of Java Programs Using Extend JPDA and Reflection\n", "abstract": " Model checking is an effective technique for verifying the correctness of concurrent systems. There are several approaches to apply model checking directly to implementation program. In the case of Java program, it\u2019s common to develop a Java virtual machine in Java for the sake of analyzing a Java program. We suggest another approach that model checking techniques could be applied using JPDA and Java\u2019s reflection instead of another time-consuming Java virtual machine. This approach has a benefit to have a Java debugger and a systematic tester put together easily.", "num_citations": "1\n", "authors": ["2110"]}