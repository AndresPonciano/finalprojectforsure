{"title": "Model-checking parameterized concurrent programs using linear interfaces\n", "abstract": " We consider the verification of parameterized Boolean programs\u2014 abstractions of shared-memory concurrent programs with an unbounded number of threads. We propose that such programs can be model-checked by iteratively considering the program under k-round schedules, for increasing values of k, using a novel compositional construct called linear interfaces that summarize the effect of a block of threads in a k-round schedule. We also develop a game-theoretic sound technique to show that k rounds of schedule suffice to explore the entire search-space, which allows us to prove a parameterized program entirely correct. We implement a symbolic model-checker, and report on experiments verifying parameterized predicate abstractions of Linux device drivers interacting with a kernel to show the efficacy of our technique.", "num_citations": "88\n", "authors": ["1768"]}
{"title": "Getting rid of store-buffers in TSO analysis\n", "abstract": " We propose an approach for reducing the TSO reachability analysis of concurrent programs to their SC reachability analysis, under some conditions on the explored behaviors. First, we propose a linear code-to-code translation that takes as input a concurrent program P and produces a concurrent program P\u2032 such that, running P\u2032 under SC yields the same set of reachable (shared) states as running P under TSO with at most k context-switches for each thread, for a fixed k. Basically, we show that it is possible to use only O(k) additional copies of the shared variables of P as local variables to simulate the store buffers, even if they are unbounded. Furthermore, we show that our translation can be extended so that an unbounded number of context-switches is possible, under the condition that each write operation sent to the store buffer stays there for at most k context-switches of the thread. Experimental\u00a0\u2026", "num_citations": "77\n", "authors": ["1768"]}
{"title": "Analyzing recursive programs using a fixed-point calculus\n", "abstract": " We show that recursive programs where variables range over finite domains can be effectively and efficiently analyzed by describing the analysis algorithm using a formula in a fixed-point calculus. In contrast with programming in traditional languages, a fixed-point calculus serves as a high-level programming language to easily, correctly, and succinctly describe model-checking algorithms While there have been declarative high-level formalisms that have been proposed earlier for analysis problems (e.g., Datalog the fixed-point calculus we propose has the salient feature that it also allows algorithmic aspects to be specified. We exhibit two classes of algorithms of symbolic (BDD-based) algorithms written using this framework-- one for checking for errors in sequential recursive Boolean programs, and the other to check for errors reachable within a bounded number of context-switches in a concurrent recursive\u00a0\u2026", "num_citations": "60\n", "authors": ["1768"]}
{"title": "Analyzing temporal role based access control models\n", "abstract": " Today, Role Based Access Control (RBAC) is the de facto model used for advanced access control, and is widely deployed in diverse enterprises of all sizes. Several extensions to the authorization as well as the administrative models for RBAC have been adopted in recent years. In this paper, we consider the temporal extension of RBAC (TRBAC), and develop safety analysis techniques for it. Safety analysis is essential for understanding the implications of security policies both at the stage of specification and modification. Towards this end, in this paper, we first define an administrative model for TRBAC. Our strategy for performing safety analysis is to appropriately decompose the TRBAC analysis problem into multiple subproblems similar to RBAC. Along with making the analysis simpler, this enables us to leverage and adapt existing analysis techniques developed for traditional RBAC. We have adapted and\u00a0\u2026", "num_citations": "43\n", "authors": ["1768"]}
{"title": "CSeq: A concurrency pre-processor for sequential C verification tools\n", "abstract": " Sequentialization translates concurrent programs into equivalent nondeterministic sequential programs so that the different concurrent schedules no longer need to be handled explicitly. It can thus be used as a concurrency preprocessing technique for automated sequential program verification tools. Our CSeq tool implements a novel sequentialization for C programs using pthreads, which extends the Lal/Reps sequentialization to support dynamic thread creation. CSeq now works with three different backend tools, CBMC, ESBMC, and LLBMC, and is competitive with state-of-the-art verification tools for concurrent programs.", "num_citations": "41\n", "authors": ["1768"]}
{"title": "Lazy-CSeq: a lazy sequentialization tool for C\n", "abstract": " We describe a version of the lazy sequentialization schema by La Torre, Madhusudan, and Parlato that is optimized for bounded programs, and avoids the re-computation of the local state of each process at each context switch. Lazy-CSeq implements this sequentialization schema for sequentially consistent C programs using POSIX threads. Experiments show that it is very competitive.", "num_citations": "39\n", "authors": ["1768"]}
{"title": "Policy analysis for self-administrated role-based access control\n", "abstract": " Current techniques for security analysis of administrative role-based access control (ARBAC) policies restrict themselves to the separate administration assumption that essentially separates administrative roles from regular ones. The naive algorithm of tracking all users is all that is known for the analysis of ARBAC policies without separate administration, and the state space explosion that this results in precludes building effective tools. In contrast, the separate administration assumption greatly simplifies the analysis since it makes it sufficient to track only one user at a time. However, separation limits the expressiveness of the models and restricts modeling distributed administrative control. We undertake a fundamental study of analysis of ARBAC policies without the separate administration restriction, and show that analysis algorithms can be built that track only a bounded number of users, where the\u00a0\u2026", "num_citations": "35\n", "authors": ["1768"]}
{"title": "Security analysis of role-based access control through program verification\n", "abstract": " We propose a novel scheme for proving administrative role-based access control (ARBAC) policies correct with respect to security properties using the powerful abstraction-based tools available for program verification. Our scheme uses a combination of abstraction and reduction to program verification to perform security analysis. We convert ARBAC policies to imperative programs that simulate the policy abstractly, and then utilize further abstract-interpretation techniques from program analysis to analyze the programs in order to prove the policies secure. We argue that the aggressive set-abstractions and numerical-abstractions we use are natural and appropriate in the access control setting. We implement our scheme using a tool called VAC that translates ARBAC policies to imperative programs followed by an interval-based static analysis of the program, and show that we can effectively prove access control\u00a0\u2026", "num_citations": "35\n", "authors": ["1768"]}
{"title": "Scope-bounded pushdown languages\n", "abstract": " We study the formal language theory of multistack pushdown automata (MPA) restricted to computations where a symbol can be popped from a stack S only if it was pushed within a bounded number of contexts of S (scoped MPA). We show that scoped MPA are indeed a robust model of computation, by focusing on the corresponding theory of visibly MPA (MVPA). We prove the equivalence of the deterministic and nondeterministic versions and show that scope-bounded computations of an n-stack MVPA can be simulated, rearranging the input word, by using only one stack. These results have some interesting consequences, such as, the closure under complement, the decidability of universality, inclusion and equality, and the effective semilinearity of the Parikh image (Parikh's theorem). As a further contribution, we give a logical characterization and compare the expressiveness of the scope-bounded restriction\u00a0\u2026", "num_citations": "34\n", "authors": ["1768"]}
{"title": "Scope-bounded multistack pushdown systems: Fixed-point, sequentialization, and tree-width\n", "abstract": " We present a novel fixed-point algorithm to solve reachability of multi-stack pushdown systems restricted to runs where matching push and pop transitions happen within a bounded number of context switches. The followed approach is compositional, in the sense that the runs of the system are summarized by bounded-size interfaces. Moreover, it is suitable for a direct implementation and can be exploited to prove two new results. We give a sequentialization for this class of systems, ie, for each such multi-stack pushdown system we construct an equivalent single-stack pushdown system that faithfully simulates the behavior of each thread. We prove that the behavior graphs (multiply nested words) for these systems have bounded tree-width, and thus a number of decidability results can be derived from Courcelle's theorem.", "num_citations": "33\n", "authors": ["1768"]}
{"title": "Lazy sequentialization for TSO and PSO via shared memory abstractions\n", "abstract": " Lazy sequentialization is one of the most effective approaches for the bounded verification of concurrent programs. Existing tools assume sequential consistency (SC), thus the feasibility of lazy sequentializations for weak memory models (WMMs) remains untested. Here, we describe the first lazy sequentialization approach for the total store order (TSO) and partial store order (PSO) memory models. We replace all shared memory accesses with operations on a shared memory abstraction (SMA), an abstract data type that encapsulates the semantics of the underlying WMM and implements it under the simpler SC model. We give efficient SMA implementations for TSO and PSO that are based on temporal circular doubly-linked lists, a new data structure that allows an efficient simulation of the store buffers. We show experimentally, both on the SV-COMP concurrency benchmarks and a real world instance, that this\u00a0\u2026", "num_citations": "29\n", "authors": ["1768"]}
{"title": "CSeq: A sequentialization tool for C\n", "abstract": " Sequentialization translates concurrent programs into equivalent non-deterministic sequential programs so that the different concurrent schedules no longer need to be handled explicitly. It can thus be used as a concurrency pre-processor for many sequential program verification techniques. CSeq implements sequentialization for C and uses ESBMC as sequential verification backend [5].", "num_citations": "29\n", "authors": ["1768"]}
{"title": "Sequentializing parameterized programs\n", "abstract": " We exhibit assertion-preserving (reachability preserving) transformations from parameterized concurrent shared-memory programs, under a k-round scheduling of processes, to sequential programs. The salient feature of the sequential program is that it tracks the local variables of only one thread at any point, and uses only O(k) copies of shared variables (it does not use extra counters, not even one counter to keep track of the number of threads). Sequentialization is achieved using the concept of a linear interface that captures the effect an unbounded block of processes have on the shared state in a k-round schedule. Our transformation utilizes linear interfaces to sequentialize the program, and to ensure the sequential program explores only reachable states and preserves local invariants.", "num_citations": "29\n", "authors": ["1768"]}
{"title": "Verification of scope-dependent hierarchical state machines\n", "abstract": " A hierarchical state machine (Hsm) is a finite state machine where a vertex can either expand to another hierarchical state machine (box) or be a basic vertex (node). Each node is labeled with atomic propositions. We study an extension of such model which allows atomic propositions to label also boxes (Shsm). We show that Shsms can be exponentially more succinct than Shsms and verification is in general harder by an exponential factor. We carefully establish the computational complexity of reachability, cycle detection, and model checking against general Ltl and Ctl specifications. We also discuss some natural and interesting restrictions of the considered problems for which we can prove that Shsms can be verified as much efficiently as Hsms, still preserving an exponential gap of succinctness.", "num_citations": "25\n", "authors": ["1768"]}
{"title": "Vac-verifier of administrative role-based access control policies\n", "abstract": " In this paper we present Vac, an automatic tool for verifying security properties of administrative Role-based Access Control (RBAC). RBAC has become an increasingly popular access control model, particularly suitable for large organizations, and it is implemented in several software. Automatic security analysis of administrative RBAC systems is recognized as an important problem, as an analysis tool can help designers check whether their policies meet expected security properties. Vac converts administrative RBAC policies to imperative programs that simulate the policies both precisely and abstractly and supports several automatic verification back-ends to analyze the resulting programs. In this paper, we describe the architecture of Vac and overview the analysis techniques that have been implemented in the tool. We also report on experiments with several benchmarks from the literature.", "num_citations": "23\n", "authors": ["1768"]}
{"title": "Security analysis for temporal role based access control\n", "abstract": " Providing restrictive and secure access to resources is a challenging and socially important problem. Among the many formal security models, Role Based Access Control (RBAC) has become the norm in many of today's organizations for enforcing security. For every model, it is necessary to analyze and prove that the corresponding system is secure. Such analysis helps understand the implications of security policies and helps organizations gain confidence on the control they have on resources while providing access, and devise and maintain policies.", "num_citations": "23\n", "authors": ["1768"]}
{"title": "Lazy sequentialization for the safety verification of unbounded concurrent programs\n", "abstract": " Lazy sequentialization has emerged as one of the most promising approaches for concurrent program analysis but the only efficient implementation given so far works just for bounded programs. This restricts the approach to bug-finding purposes. In this paper, we describe and evaluate a new lazy sequentialization translation that does not unwind loops and thus allows to analyze unbounded computations, even with an unbounded number of context switches. In connection with an appropriate sequential backend verification tool it can thus also be used for the safety verification of concurrent programs, rather than just for bug-finding. The main technical novelty of our translation is the simulation of the thread resumption in a way that does not use gotos and thus does not require that each statement is executed at most once. We have implemented this translation in the UL-CSeq tool for C99 programs that\u00a0\u2026", "num_citations": "22\n", "authors": ["1768"]}
{"title": "The language theory of bounded context-switching\n", "abstract": " Concurrent compositions of recursive programs with finite data are a natural abstraction model for concurrent programs. Since reachability is undecidable for this class, a restricted form of reachability has become popular in the formal verification literature, where the set of states reached within k context-switches, for a fixed small constant k, is explored. In this paper, we consider the language theory of these models: concurrent recursive programs with finite data domains that communicate using shared memory and work within k round-robin rounds of context-switches, and where further the stack operations are made visible (as in visibly pushdown automata). We show that the corresponding class of languages, for any fixed k, forms a robust subclass of context-sensitive languages, closed under all the Boolean operations. Our main technical contribution is to show that these automata are determinizable as\u00a0\u2026", "num_citations": "22\n", "authors": ["1768"]}
{"title": "MU-CSeq: Sequentialization of C programs by shared memory unwindings\n", "abstract": " We implement a new sequentialization algorithm for multi-threaded C programs with dynamic thread creation as a new CSeq module. The novel basic idea of this algorithm is to fix (by a nondeterministic guess) the sequence of write operations in the shared memory and then simulate the behavior of the program according to any scheduling that respects this choice. Simulation is done thread-by-thread and the thread creation mechanism is replaced by function calls.", "num_citations": "19\n", "authors": ["1768"]}
{"title": "Unbounded lazy-CSeq: A lazy sequentialization tool for C programs with unbounded context switches\n", "abstract": " We describe a new CSeq module for the verification of multi-threaded C programs with dynamic thread creation. This module implements a variation of the lazy sequentialization algorithm implemented in Lazy-CSeq. The main novelty is that we now support an unbounded number of context switches and allow unbounded loops, while the number of allowed threads still remains bounded. This is achieved by a modified sequentialization transformation and the use of the CPAchecker as sequential verification backend.", "num_citations": "18\n", "authors": ["1768"]}
{"title": "A unifying approach for multistack pushdown automata\n", "abstract": " We give a general approach to show the closure under complement and decide the emptiness for many classes of multistack visibly pushdown automata (Mvpa). A central notion in our approach is the visibly path-tree, i.e., a stack tree with the encoding of a path that denotes a linear ordering of the nodes. We show that the set of all such trees with a bounded size labeling is regular, and path-trees allow us to design simple conversions between tree automata and Mvpa\u2019s. As corollaries of our results we get the closure under complement of ordered Mvpa that was an open problem, and a better upper bound on the algorithm to check the emptiness of bounded-phase Mvpa\u2019s.", "num_citations": "18\n", "authors": ["1768"]}
{"title": "MU-CSeq 0.4: individual memory location unwindings\n", "abstract": " We present the MU-CSeq tool for the verification of multi-threaded C programs with dynamic thread creation, dynamic memory allocation, and pointer arithmetic. It is based on sequentializing the programs over the new notion of individual memory location unwinding (IMU). IMU is derived from the notion of memory unwinding that has been implemented in the previous versions of MU-CSeq. The main concepts of IMU are: (1) the use of multiple write sequences, one for each individual shared memory location that is effectively used in the executions and (2) the use of memory addresses rather than variable names in the operations on the shared memory, which requires a separate table to map write sequences but supports pointer arithmetic.", "num_citations": "17\n", "authors": ["1768"]}
{"title": "Using shared memory abstractions to design eager sequentializations for weak memory models\n", "abstract": " Sequentialization translates concurrent programs into equivalent nondeterministic sequential programs so that the different concurrent schedules no longer need to be handled explicitly. However, existing sequentializations assume sequential consistency, which modern hardware architectures no longer guarantee. Here we describe a new approach to embed weak memory models within eager sequentializations. Our approach is based on the separation of intra-thread computations from inter-thread communications by means of a shared memory abstraction (SMA). We give details of SMA implementations for the SC, TSO, and PSO memory models that are based on the idea of individual memory unwindings. We use our approach to implement a new, efficient BMC-based bug finding tool for multi-threaded C programs under SC, TSO, or PSO based on these SMAs, and show experimentally that it is\u00a0\u2026", "num_citations": "16\n", "authors": ["1768"]}
{"title": "Parallel bug-finding in concurrent programs via reduced interleaving instances\n", "abstract": " Concurrency poses a major challenge for program verification, but it can also offer an opportunity to scale when subproblems can be analysed in parallel. We exploit this opportunity here and use a parametrizable code-to-code translation to generate a set of simpler program instances, each capturing a reduced set of the original program's interleavings. These instances can then be checked independently in parallel. Our approach does not depend on the tool that is chosen for the final analysis, is compatible with weak memory models, and amplifies the effectiveness of existing tools, making them find bugs faster and with fewer resources. We use Lazy-CSeq as an off-the-shelf final verifier to demonstrate that our approach is able, already with a small number of cores, to find bugs in the hardest known concurrency benchmarks in a matter of minutes, whereas other dynamic and static tools fail to do so in hours.", "num_citations": "15\n", "authors": ["1768"]}
{"title": "A linear time algorithm for the minimum weighted feedback vertex set on diamonds\n", "abstract": " Given an undirected and vertex weighted graph G, the Weighted Feedback Vertex Problem (WFVP) consists in finding a subset F\u2286 V of vertices of minimum weight such that each cycle in G contains at least one vertex in F. The WFVP on general graphs is known to be NP-hard. In this paper we introduce a new class of graphs, namely the diamond graphs, and give a linear time algorithm to solve WFVP on it.", "num_citations": "15\n", "authors": ["1768"]}
{"title": "Lazy-CSeq 2.0: combining lazy sequentialization with abstract interpretation\n", "abstract": " Lazy sequentialization has emerged as one of the most effective techniques to find bugs in concurrent programs. However, the size of the shared global and thread-local state still poses a problem for further scaling. We therefore use abstract interpretation to minimize the representation of the concurrent program\u2019s state variables. More specifically, we run the Frama-C abstract interpretation tool over the sequentialized program output by Lazy-CSeq to compute over-approximating intervals for all (original) state variables and then exploit CBMC\u2019s bitvector support to reduce the number of bits required to represent these in the sequentialized program. We demonstrate that this leads to substantial performance gains on complex instances.", "num_citations": "12\n", "authors": ["1768"]}
{"title": "MU-CSeq 0.3: sequentialization by read-implicit and coarse-grained memory unwindings\n", "abstract": " We describe a new CSeq module that implements improved algorithms for the verification of multi-threaded C programs with dynamic thread creation. It is based on sequentializing the programs according to a guessed sequence of write operations in the shared memory (memory unwinding, MU). The original algorithm (implemented in MU-CSeq 0.1) stores the values of all shared variables for each write (read-explicit fine-grained MU), which requires multiple copies of the shared variables. Our new algorithms store only the writes (read-implicit MU) or only a subset of the writes (coarse-grained MU), which reduces the memory footprint of the unwinding and so allows larger unwinding bounds.", "num_citations": "10\n", "authors": ["1768"]}
{"title": "A Tabu Search Heuristic Based on k-Diamonds for the Weighted Feedback Vertex Set Problem\n", "abstract": " Given an undirected and vertex weighted graph G\u2009=\u2009(V,E,w), the Weighted Feedback Vertex Problem (WFVP) consists of finding a subset F\u2009\u2286\u2009V of vertices of minimum weight such that each cycle in G contains at least one vertex in F. The WFVP on general graphs is known to be NP-hard and to be polynomially solvable on some special classes of graphs (e.g., interval graphs, co-comparability graphs, diamond graphs). In this paper we introduce an extension of diamond graphs, namely the k-diamond graphs, and give a dynamic programming algorithm to solve WFVP in linear time on this class of graphs. Other than solving an open question, this algorithm allows an efficient exploration of a neighborhood structure that can be defined by using such a class of graphs. We used this neighborhood structure inside our Iterated Tabu Search heuristic. Our extensive experimental results show the effectiveness of\u00a0\u2026", "num_citations": "10\n", "authors": ["1768"]}
{"title": "Fast payment schemes for truthful mechanisms with verification\n", "abstract": " In this paper we study optimization problems with verifiable one-parameter selfish agents introduced by Auletta et al.[V. Auletta, R. De Prisco, P. Penna, P. Persiano, The power of verification for one-parameter agents, in: Proceedings of the 31st International Colloquium on Automata, Languages and Programming, ICALP, in: LNCS, vol. 3142, 2004, pp. 171\u2013182]. Our goal is to allocate load among the agents, provided that the secret data of each agent is a single positive real number: the cost they incur per unit load. In such a setting the payment is given after the load completion, therefore if a positive load is assigned to an agent, we are able to verify if the agent declared to be faster than she actually is. We design truthful mechanisms when the agents\u2019 type sets are upper-bounded by a finite value. We provide a truthful mechanism that is c\u22c5(1+ \u03f5)-approximate if the underlying algorithm is c-approximate and weakly\u00a0\u2026", "num_citations": "9\n", "authors": ["1768"]}
{"title": "Concurrent program verification with lazy sequentialization and interval analysis\n", "abstract": " Lazy sequentialization has proven to be one of the most effective techniques for concurrent program verification. The Lazy-CSeq sequentialization tool performs a \u201clazy\u201d code-to-code translation from a concurrent program into an equivalent non-deterministic sequential program, i.e., it preserves the valuations of the program variables along its executions. The obtained program is then analyzed using sequential bounded model checking tools. However, the sizes of the individual states still pose problems for further scaling. We therefore use abstract interpretation to minimize the representation of the concurrent program\u2019s (shared global and thread-local) state variables. More specifically, we run the Frama-C abstract interpretation tool over the programs constructed by Lazy-CSeq to compute overapproximating intervals for all (original) state variables and then exploit CBMC\u2019s bitvector support to reduce the\u00a0\u2026", "num_citations": "7\n", "authors": ["1768"]}
{"title": "Context-bounded analysis of TSO systems\n", "abstract": " We address the state reachability problem in concurrent programs running over the TSO weak memory model. This problem has been shown to be decidable with non-primitive recursive complexity in the case of finite-state threads. For recursive threads this problem is undecidable. The aim of this paper is to provide under-approximate analyses for TSO systems that are decidable and have better (elementary) complexity. We propose three bounding concepts for TSO behaviors that are inspired from the concept of bounding the number of context switches introduced by Qadeer and Rehof for the sequentially consistent (SC) model. We investigate the decidability and the complexity of the state reachability problems under these three bounding concepts for TSO, and provide reduction of these problems to known reachability problems of concurrent systems under the SC semantics.", "num_citations": "7\n", "authors": ["1768"]}
{"title": "Quantified data automata on skinny trees: An abstract domain for lists\n", "abstract": " We propose a new approach to heap analysis through an abstract domain of automata, called automatic shapes. Automatic shapes are modeled after a particular version of quantified data automata on skinny trees (QSDAs), that allows to define universally quantified properties of programs manipulating acyclic heaps with a single pointer field, including data-structures such singly-linked lists. To ensure convergence of the abstract fixed-point computation, we introduce a subclass of QSDAs called elastic QSDAs, which forms an abstract domain. We evaluate our approach on several list manipulating programs and we show that the proposed domain is powerful enough to prove a large class of these programs correct.", "num_citations": "6\n", "authors": ["1768"]}
{"title": "On the complexity of LTL model-checking of recursive state machines\n", "abstract": " Recursive state machines (rsms) are models for programs with recursive procedural calls. While Ltl model-checking is Exptime-complete on such models, on finite-state machines, it is Pspace-complete in general and becomes Np-complete for interesting fragments. In this paper, we systematically study the computational complexity of model-checking rsm s against several syntactic fragments of Ltl. Our main result shows that if in the specification we disallow next and until, and retain only the box and diamond operators, model-checking is in Np. Thus, differently from the full logic, for this fragment the abstract complexity of model-checking does not change moving from finite-state machines to rsms. Our results on the other studied fragments confirm this trend, in the sense that, moving from finite-state machines to rsm s, the complexity of model-checking either rises from Pspace-complete to Exptime-complete\u00a0\u2026", "num_citations": "5\n", "authors": ["1768"]}
{"title": "On the path-width of integer linear programming\n", "abstract": " We consider the feasibility problem of integer linear programming (ILP). We show that solutions of any ILP instance can be naturally represented by an FO-definable class of graphs. For each solution there may be many graphs representing it. However, one of these graphs is of path-width at most 2n, where n is the number of variables in the instance. Since FO is decidable on graphs of bounded path- width, we obtain an alternative decidability result for ILP. The technique we use underlines a common principle to prove decidability which has previously been employed for automata with auxiliary storage. We also show how this new result links to automata theory and program verification.", "num_citations": "4\n", "authors": ["1768"]}
{"title": "Lazy-CSeq 0.6 c: An improved lazy sequentialization tool for C (competition contribution)\n", "abstract": " We describe an improved version of the bounded lazy sequentialization schema, and its implementation within the CSeq framework for sequentially consistent C programs using POSIX threads. The new schema uses an optimized representation of the context switch points and eagerly guesses these, but retains the other characteristics of the original lazy schema. Experiments show that the optimizations lead to substantial performance gains.", "num_citations": "4\n", "authors": ["1768"]}
{"title": "A Robust Class of Context-Sensitive Languages\n", "abstract": " We define a new class of languages defined by multi-stack automata that forms a robust subclass of context-sensitive languages, with decidable emptiness and closure under boolean operations. This class, called multi-stack visibly pushdown languages (MVPLs), is defined using multi-stack pushdown automata with two restrictions:(a) the pushdown automaton is visible, ie the input letter determines the operation on the stacks, and (b) any computation of the machine can be split into stages, where in each stage, there is at most one stack that is popped. MVPLs are an extension of visibly pushdown languages that captures noncontext free behaviors, and has applications in analyzing abstractions of multithreaded recursive programs, significantly enlarging the search space that can be explored for them. We show that MVPLs are closed under boolean operations, and problems such as emptiness and inclusion are decidable. We characterize MVPLs using monadic second-order logic over appropriate structures, and exhibit a Parikh theorem for them.", "num_citations": "4\n", "authors": ["1768"]}
{"title": "Improvements for truthful mechanisms with verifiable one-parameter selfish agents\n", "abstract": " In this paper we study optimization problems with verifiable one-parameter selfish agents introduced by Auletta et al. [ICALP 2004]. Our goal is to allocate load among the agents, provided that the secret data of each agent is a single positive rational number: the cost they incur per unit load. In such a setting the payment is given after the load completion, therefore if a positive load is assigned to an agent, we are able to verify if the agent declared to be faster than she actually is. We design truthful mechanisms when the agents\u2019 type sets are upper-bounded by a finite value. We provide a truthful mechanism that is c \u00b7(1\u2009+\u2009\u03b5)-approximate if the underlying algorithm is c-approximate and weakly-monotone. Moreover, if type sets are also discrete, we provide a truthful mechanism preserving the approximation ratio of the used algorithm. Our results improve the existing ones which provide truthful mechanisms\u00a0\u2026", "num_citations": "4\n", "authors": ["1768"]}
{"title": "Preventing unauthorized data flows\n", "abstract": " Trojan Horse attacks can lead to unauthorized data flows and can cause either a confidentiality violation or an integrity violation. Existing solutions to address this problem employ analysis techniques that keep track of all subject accesses to objects, and hence can be expensive. In this paper we show that for an unauthorized flow to exist in an access control matrix, a flow of length one must exist. Thus, to eliminate unauthorized flows, it is sufficient to remove all one-step flows, thereby avoiding the need for expensive transitive closure computations. This new insight allows us to develop an efficient methodology to identify and prevent all unauthorized flows leading to confidentiality and integrity violations. We develop separate solutions for two different environments that occur in real life, and experimentally validate the efficiency and restrictiveness of the proposed approaches using real data sets.", "num_citations": "3\n", "authors": ["1768"]}
{"title": "Reachability of scope-bounded multistack pushdown systems\n", "abstract": " A multi-stack pushdown system is a natural model of concurrent programs. The basic verification problems are undecidable and a common trend is to consider under-approximations of the system behaviors to gain decidability. In this paper, we restrict the semantics such that a symbol that is pushed onto a stack s can be popped only within a given number of contexts involving s, i.e., we bound the scope (in terms of number of contexts) of matching push and pop transitions. This restriction permits runs with unboundedly many contexts even between matching push and pop transitions (for systems with at least three stacks). We call the resulting model a multi-stack pushdown system with scope-bounded matching relations (SMpds). We show that the configuration reachability and the location reachability problems for SMpds are both Pspace-complete, and that the set of the reachable configurations can be captured by\u00a0\u2026", "num_citations": "2\n", "authors": ["1768"]}
{"title": "On the model-checking of branching-time temporal logic with BDI modalities\n", "abstract": " The use of rational agents for modeling real world systems has been thoroughly investigated and is now well accepted. An architecture that has emerged for the study of agent-oriented systems sees such systems as rational agents having certain mental attitudes of belief, desire, and intention (agents). Agent beliefs can be seen as the informative component of the system state, ie, what the system knows about the state of the environment. Agent desires can be thought of as representing the motivational state of the system, ie, the information about the objectives to be accomplished including priorities or payo s associated with them. Agent intentions capture the deliberative component of the system, ie, a high-level plan coming with the agent\u2019s commitment to achieve it (intentions force the agent to pursue certain desires)[8].", "num_citations": "2\n", "authors": ["1768"]}
{"title": "Model Checking BDI Logics over Finite-state Worlds.\n", "abstract": " Logics with belief, desire and intention attitudes (BDI logics) are among the most widely studied formal languages for modelling rational agents. We consider the logic Ctl\u2217 bdithat augments the branching-time logic Ctl\u2217 with the BDI modalities and adopt the possible-world semantics by Rao and Georgeff. In this paper, we introduce the model-checking problem of Ctl\u2217 bdi over finite-state models that are described by tuples of Kripke structures (one for each world) and where the BDI relations are captured by finite-state relations. We then solve the problem by giving an exponential time decision algorithm that is obtained by adapting the standard decision algorithm for Ctl\u2217.", "num_citations": "2\n", "authors": ["1768"]}
{"title": "Bounded Model Checking of Multi-threaded Programs via Sequentialization\n", "abstract": " In order to achieve greater computational power, processors now contain several cores that work in parallel and, consequently, multi-threaded software is rapidly becoming widespread. The inherently nondeterministic nature of concurrent computations can cause errors that show up rarely and are difficult to reproduce and repair. Traditional testing techniques perform an explicit exploration of the possible program executions, and are thus not adequate to spot such bugs. They need to be complemented by symbolic verification techniques that analyse multiple thread interactions simultaneously. Sequentialization consists in translating a given concurrent program into a corresponding non-deterministic sequential program that simulates executions of the original program. We investigate on whether combining sequentialization (to symbolically represent thread interleavings) with bounded model-checking (BMC) can be effective for finding errors in concurrent software. Specifically, we target multi-threaded C programs with POSIX threads. We make the following contributions: (1) evaluate the Lal-Reps sequentialization schema in combination with BMC; (2) propose and evaluate a new sequentialization schema specifically tailored to BMC and aimed at fast bug finding; (3) present a framework for building tools based on sequentialization.", "num_citations": "2\n", "authors": ["1768"]}
{"title": "On Multi-stack Visibly Pushdown Languages\n", "abstract": " We contribute to the theory of formal languages of visibly multistack pushdown automata (MVPA). First, we show closure under the main operations and decidability of the main decision problems for the class of MVPA restricted to computations where a symbol can be popped from a stack S only if it was pushed within the last k contexts of S, for a given k (in each context only one stack can be pushed or popped). In particular, this class turns out to be determinizable. Second, we show the closure under complement of the class of languages accepted by ordered MVPA, where the limitation is that a stack can be popped only if all the lower indexed stacks are empty. This also gains the decidability of universality, inclusion and equivalence. As a further contribution, we compare the classes of languages accepted by different models of MVPA.", "num_citations": "2\n", "authors": ["1768"]}
{"title": "VERISMART 2.0: swarm-based bug-finding for multi-threaded programs with Lazy-CSeq\n", "abstract": " Swarm-based verification methods split a verification problem into a large number of independent simpler tasks and so exploit the availability of large numbers of cores to speed up verification. Lazy-CSeq is a BMC-based bug-finding tool for C programs using POSIX threads that is based on sequentialization. Here we present the tool VeriSmart 2.0, which extends Lazy-CSeq with a swarm-based bug-finding method. The key idea of this approach is to constrain the interleaving such that context switches can only happen within selected tiles (more specifically, contiguous code segments within the individual threads). This under-approximates the program's behaviours, with the number and size of tiles as additional parameters, which allows us to vary the complexity of the tasks. Overall, this significantly improves peak memory consumption and (wall-clock) analysis time.", "num_citations": "1\n", "authors": ["1768"]}
{"title": "Finding rare concurrent programming bugs:: An automatic, symbolic, randomized, and parallelizable approach\n", "abstract": " Finding Rare Concurrent Programming Bugs Page 1 Gennaro Parlato gennaro@ecs.soton.ac.uk ICTAC 2018 15th International Colloquium on Theoretical Aspects of Computing Stellenbosch, South Africa, Oct 19, 2018 Finding Rare Concurrent Programming Bugs An Automatic, Symbolic, Randomized, and Parallelizable Approach Page 2 Concurrent programs Concurrency is everywhere in computing \u2013 Embedded systems \u2013 multi-core architectures \u2013 worldwide networks Large concurrent computing resources are available \u2013 clusters \u2013 cloud computing There is a big demand for concurrent software \u2013 enterprise customer services (eg, telecom companies) \u2013 government services (eg, tax payment services) \u2013 social networks, cloud services, \u2026 Page 3 Developing concurrent programs is difficult Programmers have to guarantee \u2013 correctness of sequential execution of each individual thread \u2013 under nondeterministic \u2026", "num_citations": "1\n", "authors": ["1768"]}
{"title": "MU-CSeq 0.4: Individual Memory Location Unwindings\n", "abstract": " We present the MU-CSeq tool for the verification of multithreaded C programs with dynamic thread creation, dynamic memory allocation, and pointer arithmetic. It is based on sequentializing the programs over the new notion of individual memory location unwinding (IMU). IMU is derived from the notion of memory unwinding that has been implemented in the previous versions of MU-CSeq. The main concepts of IMU are:(1) the use of multiple write sequences, one for each individual shared memory location that is effectively used in the executions and (2) the use of memory addresses rather than variable names in the operations on the shared memory, which requires a separate table to map write sequences but supports pointer arithmetic.", "num_citations": "1\n", "authors": ["1768"]}
{"title": "Separating computation from communication: a design approach for concurrent program verification\n", "abstract": " We describe an approach to design static analysis and verification tools for concurrent programs that separates intra-thread computation from inter-thread communication by means of a shared memory abstraction (SMA). We formally characterize the concept of thread-asynchronous transition systems that underpins our approach and that allows us to design tools as two independent components, the intra-thread analysis, which can be optimized separately, and the implementation of the SMA itself, which can be exchanged easily (e.g., from the SC to the TSO memory model). We describe the SMA\u2019s API and show that several concurrent verification techniques from the literature can easily be recast in our setting and thus be extended to weak memory models. We give SMA implementations for the SC, TSO, and PSO memory models that are based on the idea of individual memory unwindings. We instantiate our approach by developing a new, efficient BMC-based bug finding tool for multi-threaded C programs under SC, TSO, or PSO based on these SMAs, and show experimentally that it is competitive to existing tools.", "num_citations": "1\n", "authors": ["1768"]}
{"title": "Lazy-CSeq 1.0:(Competition Contribution)\n", "abstract": " Sequentialization translates concurrent programs into (under certain assumptions) equivalent nondeterministic sequential programs and so reduces concurrent verification to its sequential counterpart. In previous work, we have developed and implemented in the Lazy-CSeq tool a lazy sequentialization schema for bounded programs that introduces very small memory overheads and very few sources of nondeterminism and is thus very effective in practice [1, 2]. The current version of Lazy-CSeq adds deadlock detection, counterexample generation, and explicit schedule control. It also implements an improved version of the original schema, which uses an optimized representation of the context switch points and eagerly guesses these, but retains its other characteristics. Experiments show that these optimizations lead to some performance gains.", "num_citations": "1\n", "authors": ["1768"]}
{"title": "CSeq: A Sequentialization Tool for C\n", "abstract": " Sequentialization translates concurrent programs into equivalent non-deterministic sequential programs so that the different concurrent schedules no longer need to be handled explicitly. It can thus be used as a concurrency pre-processor for many sequential program verification techniques. CSeq implements sequentialization for C and uses ESBMC as sequential verification backend.", "num_citations": "1\n", "authors": ["1768"]}
{"title": "Looking at computations from a different angle\n", "abstract": " We present a novel framework to reason about programs based on encodings of computations as graphs. The main insight here is to rearrange the programs such that given a bound k, each computation can be explored according to any tree decomposition of width k of the corresponding behaviour graph. This produces under-approximations parameterized on k, which result in a complete method when we restrict to classes of behaviour graphs of bounded tree-width. As an additional feature, the transformation of the input program can be targeted to existing tools for the analysis, and thus, off-the-shelf tools based on fixed-point, or capable of analyzing sequential programs with scalar variables and nondeterminism, can be used.To illustrate our approach, we develop this framework for sequential programs and discuss how to extend it to handle concurrency. For the case of sequential programs, we develop a compositional approach to generate on-the-fly tree decompositions of nested words, which is based on graph-summaries. To illustrate our technique, we also implement our algorithms for C programs.", "num_citations": "1\n", "authors": ["1768"]}